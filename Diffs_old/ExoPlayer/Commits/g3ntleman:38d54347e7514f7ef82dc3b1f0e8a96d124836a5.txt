diff --git a/ISSUE_TEMPLATE b/ISSUE_TEMPLATE
index 6e55f3dcd6..1b912312d1 100644
--- a/ISSUE_TEMPLATE
+++ b/ISSUE_TEMPLATE
@@ -1,19 +1,44 @@
-*** PLEASE DO NOT IGNORE THIS ISSUE TEMPLATE ***
-
-Please search the existing issues before filing a new one, including issues that
-are closed. When filing a new issue please include ALL of the following, unless
-you're certain that they're not useful for the particular issue being reported.
-
-- A description of the issue.
-- Steps describing how the issue can be reproduced, ideally in the ExoPlayer
-  demo app.
-- A link to content that reproduces the issue. If you don't wish to post it
-  publicly, please submit the issue, then email the link to
-  dev.exoplayer@gmail.com including the issue number in the subject line.
-- The version of ExoPlayer being used.
-- The device(s) and version(s) of Android on which the issue can be reproduced,
-  and how easily it reproduces. If possible, please test on multiple devices and
-  Android versions.
-- A bug report taken from the device just after the issue occurs, attached as a
-  file. A bug report can be captured using "adb bugreport". Output from "adb
-  logcat" or a log snippet is not sufficient.
+*** ISSUES THAT IGNORE THIS TEMPLATE WILL BE CLOSED WITHOUT INVESTIGATION ***
+
+Before filing an issue:
+-----------------------
+- Search existing issues, including issues that are closed.
+- Consult our FAQs, supported devices and supported formats pages. These can be
+  found at https://google.github.io/ExoPlayer/.
+- Rule out issues in your own code. A good way to do this is to try and
+  reproduce the issue in the ExoPlayer demo app.
+- This issue tracker is intended for bugs, feature requests and ExoPlayer
+  specific questions. If you're asking a general Android development question,
+  please do so on Stack Overflow.
+
+When reporting a bug:
+-----------------------
+Fill out the sections below, leaving the headers but replacing the content. If
+you're unable to provide certain information, please explain why in the relevant
+section. We may close issues if they do not include sufficient information.
+
+### Issue description
+Describe the issue in detail, including observed and expected behavior.
+
+### Reproduction steps
+Describe how the issue can be reproduced, ideally using the ExoPlayer demo app.
+
+### Link to test content
+Provide a link to media that reproduces the issue. If you don't wish to post it
+publicly, please submit the issue, then email the link to
+dev.exoplayer@gmail.com including the issue number in the subject line.
+
+### Version of ExoPlayer being used
+Specify the absolute version number. Avoid using terms such as "latest".
+
+### Device(s) and version(s) of Android being used
+Specify the devices and versions of Android on which the issue can be
+reproduced, and how easily it reproduces. If possible, please test on multiple
+devices and Android versions.
+
+### A full bug report captured from the device
+Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
+log snippet is NOT sufficient. Please attach the captured bug report as a file.
+If you don't wish to post it publicly, please submit the issue, then email the
+bug report to dev.exoplayer@gmail.com including the issue number in the subject
+line.
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index fdb5e3d8a2..a0c750660d 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,9 +1,126 @@
 # Release notes #
 
-### r2.1.1 ###
+### r2.3.1 ###
+
+* Fix NPE enabling WebVTT subtitles in DASH streams
+  ([#2596](https://github.com/google/ExoPlayer/issues/2596)).
+* Fix skipping to keyframes when MediaCodecVideoRenderer is enabled but without
+  a Surface ([#2575](https://github.com/google/ExoPlayer/issues/2575)).
+* Minor fix for CEA-708 decoder
+  ([#2595](https://github.com/google/ExoPlayer/issues/2595)).
+
+### r2.3.0 ###
+
+* GVR extension: Wraps the Google VR Audio SDK to provide spatial audio
+  rendering. You can read more about the GVR extension
+  [here](https://medium.com/google-exoplayer/spatial-audio-with-exoplayer-and-gvr-cecb00e9da5f#.xdjebjd7g).
+* DASH improvements:
+    * Support embedded CEA-608 closed captions
+      ([#2362](https://github.com/google/ExoPlayer/issues/2362)).
+    * Support embedded EMSG events
+      ([#2176](https://github.com/google/ExoPlayer/issues/2176)).
+    * Support mspr:pro manifest element
+      ([#2386](https://github.com/google/ExoPlayer/issues/2386)).
+    * Correct handling of empty segment indices at the start of live events
+      ([#1865](https://github.com/google/ExoPlayer/issues/1865)).
+* HLS improvements:
+    * Respect initial track selection
+      ([#2353](https://github.com/google/ExoPlayer/issues/2353)).
+    * Reduced frequency of media playlist requests when playback position is
+      close to the live edge
+      ([#2548](https://github.com/google/ExoPlayer/issues/2548)).
+    * Exposed the master playlist through ExoPlayer.getCurrentManifest()
+      ([#2537](https://github.com/google/ExoPlayer/issues/2537)).
+    * Support CLOSED-CAPTIONS #EXT-X-MEDIA type
+      ([#341](https://github.com/google/ExoPlayer/issues/341)).
+    * Fixed handling of negative values in #EXT-X-SUPPORT
+      ([#2495](https://github.com/google/ExoPlayer/issues/2495)).
+    * Fixed potential endless buffering state for streams with WebVTT subtitles
+      ([#2424](https://github.com/google/ExoPlayer/issues/2424)).
+* MPEG-TS improvements:
+    * Support for multiple programs.
+    * Support for multiple closed captions and caption service descriptors
+     ([#2161](https://github.com/google/ExoPlayer/issues/2161)).
+* MP3: Add `FLAG_ENABLE_CONSTANT_BITRATE_SEEKING` extractor option to enable
+  constant bitrate seeking in MP3 files that would otherwise be unseekable
+  ([#2445](https://github.com/google/ExoPlayer/issues/2445)).
+* ID3: Better handle malformed ID3 data
+  ([#2486](https://github.com/google/ExoPlayer/issues/2486)).
+* Track selection: Added maxVideoBitrate parameter to DefaultTrackSelector.
+* DRM: Add support for CENC ClearKey on API level 21+
+  ([#2361](https://github.com/google/ExoPlayer/issues/2361)).
+* DRM: Support dynamic setting of key request headers
+  ([#1924](https://github.com/google/ExoPlayer/issues/1924)).
+* SmoothStreaming: Fixed handling of start_time placeholder
+  ([#2447](https://github.com/google/ExoPlayer/issues/2447)).
+* FLAC extension: Fix proguard configuration
+  ([#2427](https://github.com/google/ExoPlayer/issues/2427)).
+* Misc bugfixes.
 
-Bugfix release only. Users of r2.1.0 and r2.0.x should proactively update to
-this version.
+### r2.2.0 ###
+
+* Demo app: Automatic recovery from BehindLiveWindowException, plus improved
+  handling of pausing and resuming live streams
+  ([#2344](https://github.com/google/ExoPlayer/issues/2344)).
+* AndroidTV: Added Support for tunneled video playback
+  ([#1688](https://github.com/google/ExoPlayer/issues/1688)).
+* DRM: Renamed StreamingDrmSessionManager to DefaultDrmSessionManager and
+  added support for using offline licenses
+  ([#876](https://github.com/google/ExoPlayer/issues/876)).
+* DRM: Introduce OfflineLicenseHelper to help with offline license acquisition,
+  renewal and release.
+* UI: Updated player control assets. Added vector drawables for use on API level
+  21 and above.
+* UI: Made player control seek bar work correctly with key events if focusable
+  ([#2278](https://github.com/google/ExoPlayer/issues/2278)).
+* HLS: Improved support for streams that use EXT-X-DISCONTINUITY without
+  EXT-X-DISCONTINUITY-SEQUENCE
+  ([#1789](https://github.com/google/ExoPlayer/issues/1789)).
+* HLS: Support for EXT-X-START tag
+  ([#1544](https://github.com/google/ExoPlayer/issues/1544)).
+* HLS: Check #EXTM3U header is present when parsing the playlist. Fail
+  gracefully if not ([#2301](https://github.com/google/ExoPlayer/issues/2301)).
+* HLS: Fix memory leak
+  ([#2319](https://github.com/google/ExoPlayer/issues/2319)).
+* HLS: Fix non-seamless first adaptation where master playlist omits resolution
+  tags ([#2096](https://github.com/google/ExoPlayer/issues/2096)).
+* HLS: Fix handling of WebVTT subtitle renditions with non-standard segment file
+  extensions ([#2025](https://github.com/google/ExoPlayer/issues/2025) and
+  [#2355](https://github.com/google/ExoPlayer/issues/2355)).
+* HLS: Better handle inconsistent HLS playlist update
+  ([#2249](https://github.com/google/ExoPlayer/issues/2249)).
+* DASH: Don't overflow when dealing with large segment numbers
+  ([#2311](https://github.com/google/ExoPlayer/issues/2311)).
+* DASH: Fix propagation of language from the manifest
+  ([#2335](https://github.com/google/ExoPlayer/issues/2335)).
+* SmoothStreaming: Work around "Offset to sample data was negative" failures
+  ([#2292](https://github.com/google/ExoPlayer/issues/2292),
+  [#2101](https://github.com/google/ExoPlayer/issues/2101) and
+  [#1152](https://github.com/google/ExoPlayer/issues/1152)).
+* MP3/ID3: Added support for parsing Chapter and URL link frames
+  ([#2316](https://github.com/google/ExoPlayer/issues/2316)).
+* MP3/ID3: Handle ID3 frames that end with empty text field
+  ([#2309](https://github.com/google/ExoPlayer/issues/2309)).
+* Added ClippingMediaSource for playing clipped portions of media
+  ([#1988](https://github.com/google/ExoPlayer/issues/1988)).
+* Added convenience methods to query whether the current window is dynamic and
+  seekable ([#2320](https://github.com/google/ExoPlayer/issues/2320)).
+* Support setting of default headers on HttpDataSource.Factory implementations
+  ([#2166](https://github.com/google/ExoPlayer/issues/2166)).
+* Fixed cache failures when using an encrypted cache content index.
+* Fix visual artifacts when switching output surface
+  ([#2093](https://github.com/google/ExoPlayer/issues/2093)).
+* Fix gradle + proguard configurations.
+* Fix player position when replacing the MediaSource
+  ([#2369](https://github.com/google/ExoPlayer/issues/2369)).
+* Misc bug fixes, including
+  [#2330](https://github.com/google/ExoPlayer/issues/2330),
+  [#2269](https://github.com/google/ExoPlayer/issues/2269),
+  [#2252](https://github.com/google/ExoPlayer/issues/2252),
+  [#2264](https://github.com/google/ExoPlayer/issues/2264) and
+  [#2290](https://github.com/google/ExoPlayer/issues/2290).
+
+### r2.1.1 ###
 
 * Fix some subtitle types (e.g. WebVTT) being displayed out of sync
   ([#2208](https://github.com/google/ExoPlayer/issues/2208)).
@@ -18,15 +135,15 @@ this version.
 * HLS: Support for seeking in live streams
   ([#87](https://github.com/google/ExoPlayer/issues/87)).
 * HLS: Improved support:
- * Support for EXT-X-PROGRAM-DATE-TIME
-   ([#747](https://github.com/google/ExoPlayer/issues/747)).
- * Improved handling of sample timestamps and their alignment across variants
-   and renditions.
- * Fix issue that could cause playbacks to get stuck in an endless initial
-   buffering state.
- * Correctly propagate BehindLiveWindowException instead of
-   IndexOutOfBoundsException exception
-   ([#1695](https://github.com/google/ExoPlayer/issues/1695)).
+    * Support for EXT-X-PROGRAM-DATE-TIME
+      ([#747](https://github.com/google/ExoPlayer/issues/747)).
+    * Improved handling of sample timestamps and their alignment across variants
+      and renditions.
+    * Fix issue that could cause playbacks to get stuck in an endless initial
+      buffering state.
+    * Correctly propagate BehindLiveWindowException instead of
+      IndexOutOfBoundsException exception
+      ([#1695](https://github.com/google/ExoPlayer/issues/1695)).
 * MP3/MP4: Support for ID3 metadata, including embedded album art
   ([#979](https://github.com/google/ExoPlayer/issues/979)).
 * Improved customization of UI components. You can read about customization of
@@ -36,25 +153,25 @@ this version.
   MediaPeriod transitions.
 * EIA608: Support for caption styling and positioning.
 * MPEG-TS: Improved support:
- * Support injection of custom TS payload readers.
- * Support injection of custom section payload readers.
- * Support SCTE-35 splice information messages.
- * Support multiple table sections in a single PSI section.
- * Fix NullPointerException when an unsupported stream type is encountered
-   ([#2149](https://github.com/google/ExoPlayer/issues/2149)).
- * Avoid failure when expected ID3 header not found
-   ([#1966](https://github.com/google/ExoPlayer/issues/1966)).
+    * Support injection of custom TS payload readers.
+    * Support injection of custom section payload readers.
+    * Support SCTE-35 splice information messages.
+    * Support multiple table sections in a single PSI section.
+    * Fix NullPointerException when an unsupported stream type is encountered
+      ([#2149](https://github.com/google/ExoPlayer/issues/2149)).
+    * Avoid failure when expected ID3 header not found
+      ([#1966](https://github.com/google/ExoPlayer/issues/1966)).
 * Improvements to the upstream cache package.
- * Support caching of media segments for DASH, HLS and SmoothStreaming. Note
-   that caching of manifest and playlist files is still not supported in the
-   (normal) case where the corresponding responses are compressed.
- * Support caching for ExtractorMediaSource based playbacks.
+    * Support caching of media segments for DASH, HLS and SmoothStreaming. Note
+      that caching of manifest and playlist files is still not supported in the
+      (normal) case where the corresponding responses are compressed.
+    * Support caching for ExtractorMediaSource based playbacks.
 * Improved flexibility of SimpleExoPlayer
   ([#2102](https://github.com/google/ExoPlayer/issues/2102)).
 * Fix issue where only the audio of a video would play due to capability
-  detection issues ([#2007](https://github.com/google/ExoPlayer/issues/2007))
-  ([#2034](https://github.com/google/ExoPlayer/issues/2034))
-  ([#2157](https://github.com/google/ExoPlayer/issues/2157)).
+  detection issues ([#2007](https://github.com/google/ExoPlayer/issues/2007),
+  [#2034](https://github.com/google/ExoPlayer/issues/2034) and
+  [#2157](https://github.com/google/ExoPlayer/issues/2157)).
 * Fix issues that could cause ExtractorMediaSource based playbacks to get stuck
   buffering ([#1962](https://github.com/google/ExoPlayer/issues/1962)).
 * Correctly set SimpleExoPlayerView surface aspect ratio when an active player
@@ -74,11 +191,6 @@ this version.
 
 ### r2.0.3 ###
 
-* Fix crash on Jellybean devices when using playback controls
-  ([#1965](https://github.com/google/ExoPlayer/issues/1965)).
-
-### r2.0.3 ###
-
 * Fixed NullPointerException in ExtractorMediaSource
   ([#1914](https://github.com/google/ExoPlayer/issues/1914)).
 * Fixed NullPointerException in HlsMediaPeriod
@@ -125,62 +237,63 @@ some of the motivations behind ExoPlayer 2.x
   structure and class names have also been sanitized. Read more
   [here](https://medium.com/google-exoplayer/exoplayer-2-x-new-package-and-class-names-ef8e1d9ba96f#.lv8sd4nez).
 * Key architectural changes:
- * Late binding between rendering and media source components. Allows the same
-   rendering components to be re-used from one playback to another. Enables
-   features such as gapless playback through playlists and DASH multi-period
-   support.
- * Improved track selection design. More details can be found
-   [here](https://medium.com/google-exoplayer/exoplayer-2-x-track-selection-2b62ff712cc9#.n00zo76b6).
- * LoadControl now used to control buffering and loading across all playback
-   types.
- * Media source components given additional structure. A new MediaSource class
-   has been introduced. MediaSources expose Timelines that describe the media
-   they expose, and can consist of multiple MediaPeriods. This enables features
-   such as seeking in live playbacks and DASH multi-period support.
- * Responsibility for loading the initial DASH/SmoothStreaming/HLS manifest is
-   promoted to the corresponding MediaSource components and is no longer the
-   application's responsibility.
- * Higher level abstractions such as SimpleExoPlayer have been added to the
-   library. These make the library easier to use for common use cases. The demo
-   app is halved in size as a result, whilst at the same time gaining more
-   functionality. Read more
-   [here](https://medium.com/google-exoplayer/exoplayer-2-x-improved-demo-app-d97171aaaaa1).
- * Enhanced library support for implementing audio extensions. Read more
-   [here](https://medium.com/google-exoplayer/exoplayer-2-x-new-audio-features-cfb26c2883a#.ua75vu4s3).
- * Format and MediaFormat are replaced by a single Format class.
+    * Late binding between rendering and media source components. Allows the
+      same rendering components to be re-used from one playback to another.
+      Enables features such as gapless playback through playlists and DASH
+      multi-period support.
+    * Improved track selection design. More details can be found
+      [here](https://medium.com/google-exoplayer/exoplayer-2-x-track-selection-2b62ff712cc9#.n00zo76b6).
+    * LoadControl now used to control buffering and loading across all playback
+      types.
+    * Media source components given additional structure. A new MediaSource
+      class has been introduced. MediaSources expose Timelines that describe the
+      media they expose, and can consist of multiple MediaPeriods. This enables
+      features such as seeking in live playbacks and DASH multi-period support.
+    * Responsibility for loading the initial DASH/SmoothStreaming/HLS manifest
+      is promoted to the corresponding MediaSource components and is no longer
+      the application's responsibility.
+    * Higher level abstractions such as SimpleExoPlayer have been added to the
+      library. These make the library easier to use for common use cases. The
+      demo app is halved in size as a result, whilst at the same time gaining
+      more functionality. Read more
+      [here](https://medium.com/google-exoplayer/exoplayer-2-x-improved-demo-app-d97171aaaaa1).
+    * Enhanced library support for implementing audio extensions. Read more
+      [here](https://medium.com/google-exoplayer/exoplayer-2-x-new-audio-features-cfb26c2883a#.ua75vu4s3).
+    * Format and MediaFormat are replaced by a single Format class.
 * Key new features:
- * Playlist support. Includes support for gapless playback between playlist
-   items and consistent application of LoadControl and TrackSelector policies
-   when transitioning between items
-   ([#1270](https://github.com/google/ExoPlayer/issues/1270)).
- * Seeking in live playbacks for DASH and SmoothStreaming
-   ([#291](https://github.com/google/ExoPlayer/issues/291)).
- * DASH multi-period support
-   ([#557](https://github.com/google/ExoPlayer/issues/557)).
- * MediaSource composition allows MediaSources to be concatenated into a
-   playlist, merged and looped. Read more
-   [here](https://medium.com/google-exoplayer/exoplayer-2-x-mediasource-composition-6c285fcbca1f#.zfha8qupz).
- * Looping support (see above)
-   ([#490](https://github.com/google/ExoPlayer/issues/490)).
- * Ability to query information about all tracks in a piece of media (including
-   those not supported by the device)
-  ([#1121](https://github.com/google/ExoPlayer/issues/1121)).
- * Improved player controls.
- * Support for PSSH in fMP4 moof atoms
-   ([#1143](https://github.com/google/ExoPlayer/issues/1143)).
- * Support for Opus in Ogg
-   ([#1447](https://github.com/google/ExoPlayer/issues/1447)).
- * CacheDataSource support for standalone media file playbacks (mp3, mp4 etc).
- * FFMPEG extension (for audio only).
+    * Playlist support. Includes support for gapless playback between playlist
+      items and consistent application of LoadControl and TrackSelector policies
+      when transitioning between items
+      ([#1270](https://github.com/google/ExoPlayer/issues/1270)).
+    * Seeking in live playbacks for DASH and SmoothStreaming
+      ([#291](https://github.com/google/ExoPlayer/issues/291)).
+    * DASH multi-period support
+      ([#557](https://github.com/google/ExoPlayer/issues/557)).
+    * MediaSource composition allows MediaSources to be concatenated into a
+      playlist, merged and looped. Read more
+      [here](https://medium.com/google-exoplayer/exoplayer-2-x-mediasource-composition-6c285fcbca1f#.zfha8qupz).
+    * Looping support (see above)
+      ([#490](https://github.com/google/ExoPlayer/issues/490)).
+    * Ability to query information about all tracks in a piece of media
+      (including those not supported by the device)
+      ([#1121](https://github.com/google/ExoPlayer/issues/1121)).
+    * Improved player controls.
+    * Support for PSSH in fMP4 moof atoms
+      ([#1143](https://github.com/google/ExoPlayer/issues/1143)).
+    * Support for Opus in Ogg
+      ([#1447](https://github.com/google/ExoPlayer/issues/1447)).
+    * CacheDataSource support for standalone media file playbacks (mp3, mp4
+      etc).
+    * FFMPEG extension (for audio only).
 * Key bug fixes:
- * Removed unnecessary secondary requests when playing standalone media files
-   ([#1041](https://github.com/google/ExoPlayer/issues/1041)).
- * Fixed playback of video only (i.e. no audio) live streams
-   ([#758](https://github.com/google/ExoPlayer/issues/758)).
- * Fixed silent failure when media buffer is too small
-   ([#583](https://github.com/google/ExoPlayer/issues/583)).
- * Suppressed "Sending message to a Handler on a dead thread" warnings
-   ([#426](https://github.com/google/ExoPlayer/issues/426)).
+    * Removed unnecessary secondary requests when playing standalone media 
+      files ([#1041](https://github.com/google/ExoPlayer/issues/1041)).
+    * Fixed playback of video only (i.e. no audio) live streams
+      ([#758](https://github.com/google/ExoPlayer/issues/758)).
+    * Fixed silent failure when media buffer is too small
+      ([#583](https://github.com/google/ExoPlayer/issues/583)).
+    * Suppressed "Sending message to a Handler on a dead thread" warnings
+      ([#426](https://github.com/google/ExoPlayer/issues/426)).
 
 # Legacy release notes #
 
@@ -191,6 +304,20 @@ in all V2 releases. This cannot be assumed for changes in r1.5.12 and later,
 however it can be assumed that all such changes are included in the most recent
 V2 release.
 
+### r1.5.15 ###
+
+* SmoothStreaming: Fixed handling of start_time placeholder
+  ([#2447](https://github.com/google/ExoPlayer/issues/2447)).
+* Misc bugfixes.
+
+### r1.5.14 ###
+
+* Fixed cache failures when using an encrypted cache content index.
+* SmoothStreaming: Work around "Offset to sample data was negative" failures
+  ([#2292](https://github.com/google/ExoPlayer/issues/2292),
+  [#2101](https://github.com/google/ExoPlayer/issues/2101) and
+  [#1152](https://github.com/google/ExoPlayer/issues/1152)).
+
 ### r1.5.13 ###
 
 * Improvements to the upstream cache package.
diff --git a/build.gradle b/build.gradle
index f9a72ba267..9883c04e54 100644
--- a/build.gradle
+++ b/build.gradle
@@ -11,16 +11,13 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-
 buildscript {
     repositories {
         jcenter()
     }
     dependencies {
         classpath 'com.android.tools.build:gradle:2.3.0'
-        classpath 'com.novoda:bintray-release:0.3.4'
+        classpath 'com.novoda:bintray-release:0.4.0'
     }
 }
 
@@ -29,13 +26,24 @@ allprojects {
         jcenter()
     }
     project.ext {
-        compileSdkVersion=24
-        targetSdkVersion=24
-        buildToolsVersion='25.0.0'
-        releaseRepoName = 'exoplayer'
+        // Important: ExoPlayer specifies a minSdkVersion of 9 because various
+        // components provided by the library may be of use on older devices.
+        // However, please note that the core media playback functionality
+        // provided by the library requires API level 16 or greater.
+        minSdkVersion=9
+        compileSdkVersion=25
+        targetSdkVersion=25
+        buildToolsVersion='25'
+        releaseRepoName = getBintrayRepo()
         releaseUserOrg = 'google'
         releaseGroupId = 'com.google.android.exoplayer'
-        releaseVersion = 'r2.1.1'
+        releaseVersion = 'r2.3.1'
         releaseWebsite = 'https://github.com/google/ExoPlayer'
     }
 }
+
+def getBintrayRepo() {
+    boolean publicRepo = hasProperty('publicRepo') &&
+        property('publicRepo').toBoolean()
+    return publicRepo ? 'exoplayer' : 'exoplayer-test'
+}
diff --git a/demo/assets/ic_launcher.svg b/demo/assets/ic_launcher.svg
deleted file mode 100644
index 5486b27e29..0000000000
--- a/demo/assets/ic_launcher.svg
+++ /dev/null
@@ -1,660 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:xlink="http://www.w3.org/1999/xlink"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="192"
-   height="192"
-   id="svg3089"
-   version="1.1"
-   inkscape:version="0.48.4 r9939"
-   sodipodi:docname="exoplayer.svg"
-   enable-background="new">
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="2.0893424"
-     inkscape:cx="79.970323"
-     inkscape:cy="85.448985"
-     inkscape:current-layer="layer2"
-     showgrid="true"
-     inkscape:grid-bbox="true"
-     inkscape:document-units="px"
-     showguides="true"
-     inkscape:guide-bbox="true"
-     inkscape:window-width="1920"
-     inkscape:window-height="1176"
-     inkscape:window-x="1920"
-     inkscape:window-y="24"
-     inkscape:window-maximized="1" />
-  <defs
-     id="defs3091">
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4624">
-      <stop
-         style="stop-color:#ffffff;stop-opacity:1;"
-         offset="0"
-         id="stop4626" />
-      <stop
-         style="stop-color:#ffffff;stop-opacity:0;"
-         offset="1"
-         id="stop4628" />
-    </linearGradient>
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4498">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop4500" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop4502" />
-    </linearGradient>
-    <linearGradient
-       id="linearGradient4511">
-      <stop
-         id="stop4513"
-         offset="0"
-         style="stop-color:#ffffff;stop-opacity:1;" />
-      <stop
-         id="stop4515"
-         offset="1"
-         style="stop-color:#ffffff;stop-opacity:0;" />
-    </linearGradient>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4219">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.5"
-         id="feFlood4221" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4223" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="2"
-         in="composite"
-         id="feGaussianBlur4225" />
-      <feOffset
-         result="offset"
-         dy="4"
-         dx="4"
-         id="feOffset4227" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4229" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4464">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4466" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4468" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4470" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4472" />
-      <feComposite
-         result="fbSourceGraphic"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4474" />
-      <feColorMatrix
-         id="feColorMatrix4476"
-         values="0 0 0 -1 0 0 0 0 -1 0 0 0 0 -1 0 0 0 0 1 0"
-         in="fbSourceGraphic"
-         result="fbSourceGraphicAlpha" />
-      <feFlood
-         in="fbSourceGraphic"
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4478" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="fbSourceGraphic"
-         id="feComposite4480" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4482" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4484" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="fbSourceGraphic"
-         in2="offset"
-         id="feComposite4486" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4494">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4496" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4498" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4500" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4502" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4504" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4535">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4537" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4539" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4541" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4543" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4545" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4557">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4559" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4561" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4563" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4565" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4567" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter4575">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4577" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4579" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur4581" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4583" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4585" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       id="filter4575-6"
-       color-interpolation-filters="sRGB">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood4577-1" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite4579-3" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         id="feGaussianBlur4581-3" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset4583-6" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite4585-9" />
-    </filter>
-    <filter
-       id="filter3896"
-       inkscape:collect="always">
-      <feBlend
-         id="feBlend3898"
-         in2="BackgroundImage"
-         mode="multiply"
-         inkscape:collect="always" />
-    </filter>
-    <filter
-       inkscape:label="Drop Shadow"
-       style="color-interpolation-filters:sRGB;"
-       id="filter3909">
-      <feFlood
-         result="flood"
-         flood-color="rgb(0,0,0)"
-         flood-opacity="0.2"
-         id="feFlood3911" />
-      <feComposite
-         result="composite1"
-         operator="in"
-         in="flood"
-         in2="SourceGraphic"
-         id="feComposite3913" />
-      <feGaussianBlur
-         result="blur"
-         stdDeviation="6"
-         in="composite"
-         id="feGaussianBlur3915" />
-      <feOffset
-         result="offset"
-         dy="6"
-         dx="0"
-         id="feOffset3917" />
-      <feComposite
-         result="composite2"
-         operator="over"
-         in="SourceGraphic"
-         in2="offset"
-         id="feComposite3919" />
-    </filter>
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4498"
-       id="linearGradient4504"
-       x1="43.149372"
-       y1="63.20599"
-       x2="110.44475"
-       y2="130.50137"
-       gradientUnits="userSpaceOnUse" />
-    <linearGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4498-7"
-       id="linearGradient4504-7"
-       x1="43.149372"
-       y1="63.20599"
-       x2="110.44475"
-       y2="130.50137"
-       gradientUnits="userSpaceOnUse" />
-    <linearGradient
-       inkscape:collect="always"
-       id="linearGradient4498-7">
-      <stop
-         style="stop-color:#000000;stop-opacity:1;"
-         offset="0"
-         id="stop4500-0" />
-      <stop
-         style="stop-color:#000000;stop-opacity:0;"
-         offset="1"
-         id="stop4502-0" />
-    </linearGradient>
-    <linearGradient
-       gradientTransform="translate(-0.12691481,66.675082)"
-       y2="130.50137"
-       x2="110.44475"
-       y1="63.20599"
-       x1="43.149372"
-       gradientUnits="userSpaceOnUse"
-       id="linearGradient4521"
-       xlink:href="#linearGradient4498-7"
-       inkscape:collect="always" />
-    <radialGradient
-       inkscape:collect="always"
-       xlink:href="#linearGradient4624"
-       id="radialGradient4630"
-       cx="17.483059"
-       cy="18.005892"
-       fx="17.483059"
-       fy="18.005892"
-       r="88.000001"
-       gradientTransform="matrix(-0.00420028,0.99999118,-1.888314,-0.00793148,51.557271,20.787508)"
-       gradientUnits="userSpaceOnUse" />
-    <filter
-       id="filter4680"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow"
-       width="1.4100000000000001"
-       height="1.4700000000000002"
-       x="-0.23000000000000009"
-       y="-0.23000000000000009">
-      <feFlood
-         id="feFlood4682"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4684"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4686"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4688"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4690"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-    <filter
-       id="filter4692"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow"
-       width="1.3600000000000001"
-       x="-0.2400000000000001"
-       y="-0.070000000000000034"
-       height="1.3600000000000001">
-      <feFlood
-         id="feFlood4694"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4696"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4698"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4700"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4702"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-    <filter
-       id="filter4710"
-       style="color-interpolation-filters:sRGB;"
-       inkscape:label="Drop Shadow">
-      <feFlood
-         id="feFlood4712"
-         flood-opacity="0.2"
-         flood-color="rgb(0,0,0)"
-         result="flood" />
-      <feComposite
-         id="feComposite4714"
-         in2="SourceGraphic"
-         in="flood"
-         operator="in"
-         result="composite1" />
-      <feGaussianBlur
-         id="feGaussianBlur4716"
-         in="composite"
-         stdDeviation="6"
-         result="blur" />
-      <feOffset
-         id="feOffset4718"
-         dx="0"
-         dy="6"
-         result="offset" />
-      <feComposite
-         id="feComposite4720"
-         in2="offset"
-         in="SourceGraphic"
-         operator="over"
-         result="composite2" />
-    </filter>
-  </defs>
-  <metadata
-     id="metadata3094">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     style="display:none"
-     sodipodi:insensitive="true"
-     transform="translate(0,176)"
-     inkscape:groupmode="layer"
-     inkscape:label="Layer 1"
-     id="layer1">
-    <image
-       width="192"
-       height="192"
-       xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAABHNCSVQICAgIfAhkiAAAIABJREFU eJztnVlXE1vax/9JZSBAAgljoAHbNBIwKHAOCsJSUZperr7qj3A+Tn+K8w2OV2fRx0YBFwioDEqE AA3vQRYUCCRQCZmH94KVLEBIatg1xfrdKVV771Sef2oPz6D797//nenr60MqlcKPTjgcBgCUlpZq /RU5er0e8/Pz0E1OTmZqamrQ3t4u95hk5+zsDABQVlam9VfkrKysIJFIQJ9KpdDe3g6v1yv3mGQn nU4jnU5r/RU5Xq8XHR0dSCaT0Gf/0+PxaCLQKHq8Xi88Hk/u3/qLf9REoFHMXDV+4IoAAE0EGsXJ dcYPXCMAQBOBRnFxk/EDNwgA+DFFYDabYTabtf6KiHzGDwCGfDdnRZCvATEJBAJYXl5GMBiEXq+H Xn+jXonAZ588O65EIgG/34/j42Po9XqUl5ejtLQUNptNUH8MwyAcDiMUCiGdTqOqqgoOhwNGo5Hz ro5U5wDZcVmtVnR2dsJut4va302wsd28AgDkEUEwGMTY2Bjq6+vR29sLi8UiSb9s98kjkQj29vbA MAxMJhNSqRQsFgt6e3tRWVkJiqKI9pcllUrh5OQEfr8fkUgEFEUhHo/DZrOhoaGh4HOS+hwgEolg aWkJ+/v7GB4ehtVqlaRfgJ3xAywEAEgrgqWlJdA0jX/961+i93WVm35NT05OsL29jVQqBZ1Oh8rK SrS0tMBgYPX4OPd3ExRFoaqqClVVVZf+P5lMYmdnBycnJ8hkMqAoCi0tLaisrBTUn1AsFgv6+/sB AKOjo3A6nejq6hK9Xy62qnvz5k1maGiIeMN8ePv2LRwOh2xTrmAwCIqiUFpaio2NDTAMAwCor69H Y2OjKP0BEOWXcXd3F/v7+wAAm82G1tZWhMNhpFIpSX+JL+L1euH3+/H48WNR+2BrP/Pz8+zeAFnE fBMsLS3JavwAsLGxgUgkApvNhjt37qh6wdjY2JgTbSwWw/LyMhiGgcViQU9PjyxjytrP0tKSKG8C PrbJ+R0uhgiCwSBomsaLFy+ItcmWr1+/4uDgACaTCc3NzSgrK5NszSEVZrMZnZ2diEQiODs7w6dP nxCPx1FXV4fm5mZJx+LxeDA6OgqXy0X0TcTXJnltq5DeIh0bG5PU+JPJJBYXFzE3N4eKigr09vbi /v37MJvNSCaTko1DapLJJMxmM+7fv4/e3l5UVFRgbm4Oi4uLkn7uFy9eYGxsjFh7Qn6Qea/iSL0J AoEA6uvrBbXBpS+fzwebzYbu7m5J+lQyFRUVePjwIQDgy5cvYBgGbrdbkm3L+vp6BAIBwX0JtUFB G+sk3gTLy8ui7wzQNI3Z2VkEAgH09/fj7t27ovanRu7evYv+/n4EAgHMzs6CpmlR++vq6sLy8rKg Nkj8AAs+WRIqgmAwKNqcm6ZpTE9PAwD6+vpw+/ZtUfopJm7fvo2+vj4AwPT0tGhCsFgsuV0wPpBa hxI5WhUiAjFOdwOBAN6+fQsAGBgYgNPpJN5HseN0OjEwMADgfHs6EAgQ74Pvd09yE4aY9fEVgdDD pIuk02nMz88jGAzi8ePHnA2/2H1z+PTndDrx+PFjBINBzM/PEz1M4/Pdk96B5HQQxoZ8A7zq22Mw GLC/v4/a2lre/WUyGRiNRqyuruLOnTugKIr3jkaxx+gK7c9gMCCVSmF9fR3t7e1IJBLQ6XS82spk Mjg9PUV5eTn0ej0r3yHSxj8/Pw+8efMmQ5rl5eVL/2YYJvPbb79l3r17lwmHw5f+9p///EdQX0dH R5mJiYlMNBoV1E4mk8mEQqFMKBQS3E6x9xeNRjMTExOZo6MjQe3Mzs5mYrFY7t/hcDjz7t27zG+/ /ZZhGObStVdtigQfP37MkJt/XODiFqmYvj2zs7OoqanBkydPiLQnta+MWvszm8148uQJNjc3sbGx kVs0cyWTyVwa002+Q2K64IjmX+zxePDrr7/CZDIRP+QKBAIYHx/HgwcP4HK5iLatwR6Xy4UHDx5g fHyc+CL5xYsXMJlM+PXXX0V1jxFNAEtLS7lDFpIsLi6CpmkMDQ2JHh+gURi9Xo+hoSHQNI3FxUXi 7T98+BBLS0vE280iigVlfXs6OjrQ0dFBxG0ilUrh9evXcLvd6OjoIDBKDZJ0dHTA7Xbj9evXRJKs ZVOXdHR0gKZpQWcG+RBFAFd9e4Qelh0fH2NqagrPnz8vOke1YsJiseD58+eYmZnB0dER73auzvlJ +w5dhLgAbvLt4SsCn8+Hw8NDYgtdDfEZHBzE0dERfD4f53tvWvBmfYdIQ1wA+Xx7uIpgamoKNTU1 cLvdpIanIRFutxs1NTWYmppifU++3R4SvkPXQVwAhXx72IpgbGwMDx8+/C78T0M9VFVV4eHDh6ym L4W2OoX6Dt0EcQGw2ZnJJ4JkMolXr15heHgYRqOR9PA0JMZoNGJ4eBivXr269oSeoijW+/xi7PoR b5Gtf4fH48H29val62OxGD58+ICRkRHSw2KFGnxz1NTfRUZGRvDhwwfEYrHc/5lMJvh8Ptb7/CT9 xrII8gUS6ttjMBjw7t079PX14fT0FAaDAWVlZbJlMFabb47S+7uKXq/H2dkZkskkKioq8PHjR3R3 d7PyJ8rw8B0qBOeg+Cz58vb88ccf+Mc//sG6rXQ6jdraWtjtdvz88898hkOMYs/Xr5T6AB8/fgRF URgeHsb9+/dhMplY3Tc3N4fu7u7c9STyDnEWAGnfntPTU9jtdpSXlxNpTwhq9c1Ran83UV5eDoZh cHp6ymlMbH2HuMBpDfD27VsYDAZivj2xWAwGgwE///wz3G73D5eL9EfE6/XC7XbjwYMHSCaTiMfj RNp98eIFDAZDLhCKLawFQDpvTzKZxMLCwqXX8Y+YkPdH4upuT3V1Nd6/f08sI4XH44HD4eDkO8RK AFnfHpJeeW/evEF/f/93r0BNBMXJdVudqVQKQ0NDePPmDbF+PB4PJ98hVgIgnbdnbGws71anJoLi It8+fyKRwMjICFFfHy6+QwUFQDpvz9TUFCu/Hk0ExQHbQ64nT55wcpsoBFvfoYICIJm3x+fzob29 nfUJryYCdcMlkstoNKK9vZ2XA911sPUdKigAUnl7jo+PAYCzb48mAnXCJ4wxaxtZWxECW9+hggIg 4X+RSqVy21980ESgLoTE8Ga3w0kE1bCxXUkEMDExIdifXxOBOiARwP7kyRNMTEwIHgsbFwvRg2oX Fxfx6NEjIm1pIlA2JLM3PHr0SHCMcUVFBaLRaN5rRBVAIBCA2WwmGsaoiUCZkE5dYrFYYDabBUWB yf4GWFpaEiWAXROBshArb09HR4eoGSEAEQUwOzsrahyvJgJlIHbduCdPnmB2dla09okLIJPJ4Pj4 GDU1NaLn7dFEIC9SVA7V6/WoqakRlGUib/ukGzQajfB6vZJlbNNEIA9S1o52uVzwer2ihMgSF8Dq 6irvXJF80UQgLVIXTgeA/v5+UdYDRAWQTqdlKy+qiUAa5DB+4Dyeua2tDZlMhmi7RAWwuLgIiqJI NskJTQTiIpfxZykpKSGef5SYAAKBAGpqamQvM6qJQBzkNn7gPIjKZrMRzRBHTADLy8uSF12+CU0E ZFGC8Wfp6OggmiGOiABomkZrayuJpoihZBGk02kEg0GcnZ3h7OwMwWBQMQHrV1GS8QNAPB5Ha2sr seqVRDINbW1t5SoKKglSxbz5sru7mwv8TyQSMBqNSKVSMJlMqKioyF2n0+lA0zTi8Tgoispdm63s 3tjYKMv4lWb8WZxOJ6anp4lU/xQsAJqmFV1/V0oRMAyDb9++Qa/Xw2g0oqGhIe+mQHZHo7y8/Ma0 MKlUCjs7O0gkErkcSjabTZTxX0Spxp/l9u3boGlasAgEC2B7e1vyfX+uiCmCZDKJzc1N6PV61NXV 4W9/+xvR9imKQlNTU+7fDMNgY2MD6XQaLpdLlHSBSjd+4PwtMDs7K68AAoGAoBKnUkJaBMFgELu7 u7BYLGhrayPSJhtsNlvuDbC9vY1IJILGxkZeWdGuQw3Gn6W2thaBQIB3akRA4CLY5/MpevpzFRIL 41AohNXVVSQSCbjdbrS0tBAaHXdaWlrgdruRSCSwurqKUCgkqD01GT9wPg0SGkPMWwDZPVm1IUQE Xq8XoVAI7e3tcDgchEfGH4fDgfb2doRCIUGfTU3Gn8Vmswk6e+ItgOXlZdy9e5d3x3LCVQQHBwdY W1uDx+MhmiKGNPX19fB4PFhbW8PBwQHr+9Rq/ABw9+5dQecCvAVAKqejXLAVwefPnyWf5wulra0N FosFnz9/Lnitmo0/ixBb5CWAr1+/FkXdrnwiiEajWFhYwL1791Q51bPZbLh37x4WFhZujIstBuMH zjNJfP36lde9vARwcHBw6SBHzVwVgU6ng9/vx+7uLnp6emQcGRl6enqwu7sLv99/KUa2WIwfOA9+ 5zLluwgvAbAtaKAWsiIwGAzY29tDLBaTLKBHClwuF2KxGPb29mAwGIrK+LPwtUlDOBzG2dnZtb4o ZrMZV/++sbGB5ubma7NuXXd9PrheLyYulwszMzNoamqC1WoVrTL5RbIVW6TAarUiFAphZmYG/f39 kny+QoTDYYRCISQSCcHXNzU1YWFh4ZJPWqH2w+EwtzcARVGIRCKyl9ghjU6nw87ODpqamkDTtKwx DWJBURRomkZTUxN2dnZYpQxREyUlJYhEIpy/O0NpaWleg776d5vNljfPT6H2hF4vBn6/H1arFVar FX/5y1+wubkp6RSB1CluPrxeL3p7e5FKpRAMBhGPx2U/yygtLUV5eTlKSkqIXG+z2S4VACx0fWlp Kbc3wMbGBu7cucPlFsUTjUYRCATgdDqRyWSQTCYV7UrNh+ycP5lMIpPJwOl0IhAIFMyapjbu3LmD jY0NTvdwEgDDMLLVmRWLlZWVaxe8xSKCmxa8LpcLKysrMoxIPMxmMxiG4XSP6LlBlcznz5/zbnWq XQSFdnt6enpYHZYVM6wFcHJyomg3AK4cHBzg1q1bBa9TqwjYbnXeunWL9x66Eqmvr8fJyQnr61kL YHt7W7bIJDE4OTlhfcKrNhFw2ee32WycDEbpNDY2Ynt7m/X1rAVAomCBUvB6vZx9e9QiAj6HXG1t bar4bGzhYqusBVAs+8ahUAjV1dW87lW6CISc8FZXVwuOJ1AKXGyVlQAikQgqKyt5D0hJ7OzsCFrL KFUEQt0b6uvrsbOzQ3BE8lFZWYlwOMzqWlYC2NvbuxSXqlaCwSDq6uoEt6M0EZDy7amrq1OEi4RQ mpqasLu7y+paVgJgGEaU4Gup2d3dJXb6qRQRkHRsczgcrA1HyRgMBjAMQ6ZCjF6vLwrvz2QySbRU EyC/CMTw6rRYLLKntySB2WwmVyWyGHaANjc3RQlgl0sEYrk0t7S0YHNzk3i7UpNKpcgIIJFIEP/l lAMxq9VILQKx/fnFruwjBSUlJaxCJQt+Ur/fL7vXoFAYhiGy+M2HVCKQIpilrq6Os0+N0nA4HPD7 /QWvKyiA4+Nj1W+Bfvv2TZK4XrFFIFUkl81mw7dv30TvR0wcDgerNOqs1gBqDxCR8pUulgikDmNU +zQoG7xViIKf8qakrWpCjOJq+SAtAjlieKV+ZmLAJtCmoAAuRtiokd3dXTQ0NEjeLykRyBXA3tDQ oPozATa2W1AAasyJc5FYLCbbFE6oCOTM3kBRFGKxmCx9k4KN7ap7oscCuU+w+YpACalL5H52QiEy BVI7bFNuiAlXESjB+AFlPDshsFnHFL0AlLKYYysCpRg/oJxnJyZFLwAluXEUEoGSjB9Q1rMTi6IW QDqdVpwj300iUJrxA+fpBuXO2Cc2RS2As7MzRSbxvZiLVMm5OisqKiRN3ygHeXODZk/TxMr1KXZu 0OyXl63GyPZ6KXC5XFhYWABwnp5EiblIxX4eJHOD8rm+YG5Qg8HA2ng0NNQI59yghVBablCdTsfZ nUOqXJ3ZpFxKzUWq0+mQyWREex6kc4NyvZ5zblC1UVZWhtPTU7mH8R0Xc3UqORfp6emp7ImLxaao BaDX6xVXy+ymBa8SRRCPx1XvFVqI4v50gKJcuQvt9ihNBEp6dmJR9AJQynE+261OJYlAKc9OTIpe AEo4zue6z68UESjh2QmBjYCLXgByp/jge8ilBBHI/eyEwqYASEEBqD042mw2y+bTIvSEV04RpFIp 1RdDYWO7BQXANseiUmlsbMTe3p7k/ZJyb5BLBHt7e6pPh8/GdgsKoBgyBku9mCPt2yOHCIphAUxk CpROp1XvFiulR6NYjm1Si0DtXqBsE7oVFEBVVZXqK4jU1tZKspYR26tTKhEwDIPa2lrR+xGTk5MT 2O32gtcVFADbDFtKxmaziV4HSyqXZilEcHBwoPpkCGwzGhYUgNFoZJVgSOmI+UqX2p9fbBGoffoD nM//2QRDsVoDFMORuMvl4lQ8jS1yBbOIJYLt7e1r6yarDYqiWAmZlQCU5lDGB4PBQPxNJncklxgi iEQiqk+HApzngyIiAOB8Dq32U0Hg/EyA1HpGbuPPQlIEfr9f9Xv/wPkJts1mYxXMxUoADQ0NRVFA zWq1ElkMK8X4s5ASwcHBgSTBQGKzs7PDWsisBGCxWFS/FZqlqakJ+/v7vO9XmvFnESqC/f39oiiE CJxvgbLNacvaGa5YYoPLy8txdHTE616lGn8WISI4OjoqikzgADdbZS2AYtgJyuLxeLC2tsbpHqUb fxY+IlhbW1PFZ2MLF1tlLYCWlhbVp8u+SGVlJevTYbUYfxYuImAYRvUVgC6yu7vLqRgiawFUVlYK mjsrjbq6Ovz5558Fr1Ob8WdhK4I///xT9PppUrK/v89J0EUfEJOPe/fu5ZJTXYdajT9LIREsLCzg 3r17Eo5IeXASgM1mU33RhKt0dHRcWxdX7caf5SYRbG5uoqOjQ4YRiUcsFuPsw8RJAK2trVhfX+fU gdIpKSmB3W4HTdPQ6XSKztXJl4u5SHU6HWiaht1uZ51gSi2sr6+jtbWV0z15c4Nezd1JURQYhkE4 HL42RkBpuUHZYjKZcHR0hFAoBJqm0dvbq8hcnUJwuVz48OEDnE5nLtubFJ8xHyRzfV5nm4Jzg14l lUrBYrGwirRRE5lMBk1NTdjZ2YHT6VR9ANB1pFIpOJ1O7OzsoKmpqWjOdbJEo1FYLBbO3x3n3KA9 PT349OkT7t+/z+r6QoidG5QtXq8X/f392NnZQTAYhNPplKxvKdwPaJpGJpNBf3+/5LlIb4Jkrs9P nz7lcq2ybZ93btBi8A69yMVcnQ0NDTCbzdcujNXK5uYmzGYzGhoaFJ2LVAh8bZKXAOrq6hSZdJYP Vxe8mUwGDocDjY2NebdI1cLCwgIaGxvhcDguTXuKSQSnp6e8zzJ4CaC5uRk+n49Xh0oi325PSUkJ enp68PnzZ1XmRmIYBp8/f0ZPT8+NU4BiEYHP50NzczOve3kfhCmt9hZX2G513rt3D5FIhLPvkJys ra0hEomwOuQqBhEIsUXeAujs7MSXL194dywnXPf56+rq0NbWBq/Xq2h3kP39fXi9XrS1tXGaEqhZ BF++fEFnZyfv+3kLwGAwqHJqIOSQy+PxoLy8HKurq4rKlOH3+7G6uory8nJBn02NImAYRlAIpyBf ILfbja2tLSFNSAqJE97y8nK0t7fDaDTC5/OJEmjPlu3tbfh8PhiNRrS3twv251ebCLa2tuB2uwW1 ISj62W63Y21tDbdv3xY0CCkg7d5gtVrhdruRTCaxtrYGvV6Puro60fPpMAyDg4MDpNNpuFwu4gHs WREo4ZygEN++fRNse4KfXktLC2ialvTgiCtifqEGgwFtbW0Azo3zf//7H/R6PYxGIxoaGgQHEqVS Kezt7SGRSCCdTqO2tpazvwtX1CACmqY5+f3fhGABOJ1OTE9PK1YAUn6RNpvt0htgd3cXsVgMBoMB iUQCRqMRqVQKJpPpUhFqnU6H09NTxONxUBSVuzaZTMJsNssSq6t0EWxtbWFgYEBwO0Ten7dv31bk W0DuL/CmzATpdPqSI1wmk4HT6VRcQTqlioCmaWLTbiJP3Ol0YmNjg0RTxFDiF5dFr9fDarWirKwM ZWVlsFqtijP+LEpbGJtMJmxsbBD7sSX21Ds7O/H161dSzQlCycavRpQkgpWVFUH7/lchJgC73Y7D w0PZ0+ppxi8OShBB9uyJTdpzthB973Z3d8vqS68Zv7jILYJoNIru7m6ibRIVgF6vx/r6uixxw5rx S4NcIojFYlhbW4NOpyPaLvGVV3t7O2ZnZ0k3mxfN+KVFDhHMzMygq6uLeLvEBZBIJODxeCQLKNGM Xx6kFEE2gk2Mwn3EBaDT6VBVVYXDw0PRA90145cXKUSQTqdxeHiI6upqUdoXbfO5r68Pk5OTYjWv Gb9CEFsEk5OT6OvrE619UU9furq6sLKyQrxdzfiVhVgiWFlZEWXefxFRBWC32xGLxYiWJtKMX5mQ FkEkEkEsFhO0589mx0j08/fu7m68e/eOSFua8SsbkiJ49+6d4D3/QCBQMOUKqyJ5Qnn69Kng9YBm /OqAhAgmJyfx9OlTwWMhUiOMhAAoioLH4+GdSUIzfnUhRAQ+nw8ej4dIQRYiVSKtViuROXxVVRUA 4Pj4mNN9mvGrEz4iyNpG1laEEIlEWGXcKyiAzs5OLC0tCR4QcB5DvLq6yvpAQzN+dcNFBIlEAqur q4JjfLMsLS2x8hotKAC73U40Fcjg4CCr9YBm/MUBWxFMTk5icHCQWL/7+/usdpBY7QINDw9jdHRU 8KAutvfq1asb/64Zf3GRTwRGoxGvXr3C8PAwsf5GR0dZt8dKAFarFU6nk+g+77NnzzAzM/NdJJRm /MXJdSKgKArj4+N49uwZsX68Xi+cTifrjNuszwG6urrg9/uJicBgMKCnp+dSbKxm/MXNVREcHR3h wYMHxIKovF4v/H4/p9NjTgdhjx8/RjKZJDYdMpvNSCaT+PjxY277S6O4yW6Hv3//HgaDgViO2dHR USSTSTx+/JjTfZyl19XVBZfLhZcvX6K+vh5dXV2wWCy5v3OtPFJRUZErb6PxY5BNZ8inPvHFKXMk EsHS0hL29/cxPDzMq9CI7s2bN5mhoSHONwLnR83Ly8sIBoPQ6/UwGAzw+/24desWKyGYTCb88ccf GB4exsnJCZLJJKqrq2ULqwyHwwDOK4do/ZGHoigcHR3ljH9ychIDAwOso7z29/dhNBqh1+uRTqdh tVrR2dnJ219ofn5eeGrEq6+c33//Hd3d3QVP4SiKgs/nQ3d3N+7fv490Oo14PI73799jaGhIlOCH QoRCIQAQnGNT6+97jEYjxsfHMTAwkJv2JJNJAMBPP/1U8EdPr9fjv//9L/75z38SHRfxFA56vZ7V vM7r9aKzsxN7e3u560tKSvD06VO8fv0aIyMjpIdWkKzopCofWuz9XeTVq1d49uzZpQWvTqfDTz/9 hLW1NVbrPzFyJxFvkY3/Rb7dHoPBgJGREYyNjcnyFtAgSyKRwNjYGEZGRq7d7UmlUqwPy8SIMCQu gEK+Q2y3OoeHhzE3N8fZd0hDORwfH2Nubo7VoVQhEbD17eEKcQHk8x3ius8/ODiIw8PDoqhH9qPh 8/lweHjIyb0hnwjY+vZwhbgAbvId4nvI5Xa7UV1djampKRLD05CAyclJ1NTU8HJsu0kEbH17uCJK RNhV3yGhJ7zV1dXo7+/H69eviYZXapAlEong9evXGBwcFOTSfFUEXHx7uCJKIs+s71A2IJ7ECS9F UXj+/DkWFxdhNpvR0dEhuE0NcqysrCAWi+H58+dE2vN4PDn74eLbwxXRYoK7urowNzdHvN3u7m44 nU6Mj4+LnndIozDpdBrj4+NwOp3E83YCwNzcnKiZIUQTgNfrxS+//IJ4PE7UlRo4X2cMDQ3h/fv3 kmWg0/iezc3N3MEl6fn56Ogo4vE4fvnlF1HzDokigItz/q6uLgwODuLly5eYmZn5bg7P1XfoIn19 faioqMDExIQsCXl/VGKxGCYmJlBRUSE4adVV356ZmRm8fPkSg4ODuV9+MZNvCfIFuo58C16hvkM3 YTQasbS0hLa2NpSUlOSO2LlS7L45QvszGAyIRqNYW1tDV1eX4INKrr49pN3l5+fnyQqAzwB///13 /P3vfycyn89kMlhcXITNZkNHRwfi8Tin+4vdN4dvfyaTCSsrK2AYBt3d3URSlPP17SEpAsHOcBfh OzC2vkNsefToEQKBAKamptDa2sqpllSx++bw6Y+maWxsbKCzs5N4vAYf3x7ShfuIrAGEDEiMnZyL XqrT09OgaZp4H8UOTdOYnp4GcB4IJcYhFN/vnuSaQLAAhKqRVN6h63A6nblasrOzs9ja2hKln2Ji a2srV+BkYGBAtNK3Qn17SIlAkABIvIpI5h26CafTib6+PtjtdszMzODLly+i9qdGvnz5gpmZGdjt dvT19Yle85mEbw8JEfBeA5Cah5HOO1Sor/7+fiSTSSwuLiIej8PtdqOiokKS/pXG6ekpfD4fTCYT Ojs7Ja3wub+/j/7+fsHtCF0T8PrEpLejsr5DL168INZmPgwGQ+7U8uvXr1hfX4fJZEJjYyPKysok GYMcGAwGnJ2dYWtrC/F4HHV1dXj48KHk4yDt2yNEBJwFIEbqkot5h6TODNHc3Izm5mYAwMLCAiKR CGw2G+7cuQOz2SzpWMQiFothfX0dDMPAYrGgp6dHtrFwzdvDFr4i4CQAMQ20q6sLb9++lTU3UGtr KyiKQmlpKTY2NnKZKurr69HY2CjLmPiyu7ubm1rabDZ0dnYiHA7LXsfZ7/dzTl3CFj4iYH0QJpVh Li0tgaZpyaZDFwkGgwDw3a/TyckJtre3kUqloNPpUFlZiaamJsFz5pv640oymcTOzg5OTk6QyWRA URRaWlq+SztCqj8+jI6Owul0il7yCGBvq6wPwqT8VS6Ud0gOKisrLxnlyVLcAAABS0lEQVRTOBzG //3f/4FhGJjNZqRSKZSUlMDhcKCyshJGo1GUcSQSCZycnMDv9yMajYKiKMRiMdhsNjQ2NuKvf/2r KP3yhUTeHj5weRMUfAPIOSW56juk0+lgt9sF+Q3lg6uvjE6ng16vh16vRzweh9/vRyAQQCQSQUlJ CUpLS2Gz2VBSUnKtKPL1l0gkEI1GwTAMwuEwotEoLBYL7HY7HA4HTCYT0uk00uk06+chtu+RTqdD IBBAJpMhkrdHKIVst+AbQO5cndflHYpGo6L1pxbfHCX3J0fKlZtg8ya4UQByG/9NiPmA1eCbo6b+ lEAhEVx7EqxU49fQ4EO+E+PvBKAZv0YxcpMILglAM36NYuY6EeQEoBm/xo/AVRHo9Xo9VlZWNOPX +GHIioCiKBjm5+fx/PlzzM/Pyz0u2VFbjK7S+1MyFEVhamoK/w+AyfN+zOygegAAAABJRU5ErkJg gg== "
-       id="image3116"
-       x="0"
-       y="-176" />
-  </g>
-  <g
-     style="display:inline"
-     inkscape:label="base"
-     id="layer2"
-     inkscape:groupmode="layer">
-    <g
-       id="g4704"
-       style="filter:url(#filter4710)">
-      <path
-         style="fill:#8097a2;fill-opacity:1;stroke:none;display:inline"
-         d="m 68,30.7 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,34.283686 180.39647,30.7 175.9375,30.7 l -107.937501,0 z"
-         id="path3938-4"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#546e7a;fill-opacity:1;stroke:none;display:inline"
-         d="m 68,33.3 0,52 -60,0 0,24 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.9375 C 184,36.883686 180.39647,33.3 175.9375,33.3 l -107.937501,0 z"
-         id="path3938-5"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#607d8b;fill-opacity:1;stroke:none"
-         d="m 68,32.000003 0,52 -60,0 L 8,108 l 60,0 0,52 107.9375,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79916 7.21875,-7.96875 l 0,-111.937497 c 0,-4.447564 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937501,0 z"
-         id="path3938"
-         inkscape:connector-curvature="0" />
-      <path
-         sodipodi:nodetypes="cccc"
-         inkscape:connector-curvature="0"
-         d="m 107.07401,68.171344 0,55.657316 L 149.27466,96 z"
-         style="fill:#ffffff;stroke:none"
-         inkscape:label="Triangle"
-         id="path4262" />
-    </g>
-  </g>
-  <g
-     style="display:inline"
-     inkscape:label="Layer"
-     id="layer3"
-     inkscape:groupmode="layer"
-     sodipodi:insensitive="true">
-    <path
-       style="opacity:0.11522636;fill:url(#linearGradient4504);fill-opacity:1;stroke:none"
-       d="M 14.214274,89.623384 74.117285,35.304552 143.41187,104.59914 106.15739,181.5665 z"
-       id="path4488"
-       inkscape:connector-curvature="0" />
-    <path
-       style="opacity:0.11522636;fill:url(#linearGradient4521);fill-opacity:1;stroke:none;display:inline"
-       d="m 74,101.96875 -8.09375,7.34375 2.09375,0 0,49.375 0,1.3125 0,1.3125 65.3125,0 L 74,101.96875 z"
-       id="path4488-8"
-       inkscape:connector-curvature="0" />
-    <g
-       transform="translate(0,2.2931745)"
-       id="g4071"
-       style="filter:url(#filter4692)">
-      <path
-         style="fill:#08a0b5;fill-opacity:1;stroke:none;display:inline"
-         d="M 22.0625,154.3 C 17.60353,154.3 14,150.71631 14,146.26875 L 14,102.3 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2-1"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#33c9dd;fill-opacity:1;stroke:none;display:inline"
-         d="M 22.0625,151.7 C 17.60353,151.7 14,148.11631 14,143.66875 L 14,99.7 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2-8"
-         inkscape:connector-curvature="0" />
-      <path
-         style="fill:#00bcd4;fill-opacity:1;stroke:none"
-         d="M 22.0625,153 C 17.60353,153 14,149.41631 14,144.96875 L 14,101 l 60,0 0,52 -51.9375,0 z"
-         id="rect3104-7-2"
-         inkscape:connector-curvature="0" />
-    </g>
-    <g
-       transform="translate(-0.511613,5.6775255)"
-       id="g4111"
-       style="filter:url(#filter4680)">
-      <g
-         id="g4106">
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-1-0"
-           d="m 22.574113,29.7293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#35baf6;fill-opacity:1;stroke:none;display:inline" />
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-8-8"
-           d="m 22.574113,32.3293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#0a91ce;fill-opacity:1;stroke:none;display:inline" />
-        <path
-           inkscape:connector-curvature="0"
-           id="rect3104-7-2-2"
-           d="m 22.574113,31.0293 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,43.96875 60,0 0,-52 -51.9375,0 z"
-           style="fill:#03a9f4;fill-opacity:1;stroke:none" />
-      </g>
-    </g>
-  </g>
-  <g
-     inkscape:groupmode="layer"
-     id="layer5"
-     inkscape:label="finish"
-     style="opacity:0.18656718;display:inline"
-     sodipodi:insensitive="true">
-    <path
-       inkscape:connector-curvature="0"
-       style="fill:url(#radialGradient4630);fill-opacity:1;stroke:none;display:inline"
-       d="m 67.999998,30.703125 0,1.28125 0,1.3125 0,2.09375 -45.937501,0 c -4.45897,0 -8.0625,3.58369 -8.0625,8.03125 l 0,1.3125 0,1.3125 0,36.65625 -5.9999995,0 0,1.28125 0,1.3125 0,21.406255 0,1.28125 0,1.3125 5.9999995,0 0,36.65624 0,1.3125 0,1.28125 c 0,4.44756 3.60353,8.03125 8.0625,8.03125 l 45.937501,0 0,2.125 0,1.28125 0,1.3125 107.937502,0 c 0.27869,0 0.57242,-0.0352 0.84375,-0.0625 4.06997,-0.41 7.21875,-3.79915 7.21875,-7.96875 l 0,-1.3125 0,-1.28125 0,-109.343745 0,-1.3125 0,-1.28125 c 0,-4.44757 -3.60353,-8.03125 -8.0625,-8.03125 l -107.937503,0 z"
-       id="path3938-4-0" />
-  </g>
-</svg>
diff --git a/demo/build.gradle b/demo/build.gradle
index 5aa98b2fd9..01946c8504 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -24,25 +24,24 @@ android {
 
     buildTypes {
         release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+            shrinkResources true
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt')
         }
         debug {
             jniDebuggable = true
-            debuggable = true
         }
     }
 
     lintOptions {
-        abortOnError false
+        // The demo app does not have translations.
+        disable 'MissingTranslation'
     }
 
     productFlavors {
         noExtensions
         withExtensions
     }
-
-    buildToolsVersion '25.0.0'
 }
 
 dependencies {
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 4c6d832211..9a6e1a4d3a 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer2.demo"
-    android:versionCode="2101"
-    android:versionName="2.1.1">
+    android:versionCode="2301"
+    android:versionName="2.3.1">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
@@ -27,7 +27,7 @@
 
   <application
       android:label="@string/application_name"
-      android:icon="@drawable/ic_launcher"
+      android:icon="@mipmap/ic_launcher"
       android:banner="@drawable/ic_banner"
       android:largeHeap="true"
       android:allowBackup="false"
diff --git a/demo/src/main/assets/media.exolist.json b/demo/src/main/assets/media.exolist.json
index 6fa46d7451..dd88f206c1 100644
--- a/demo/src/main/assets/media.exolist.json
+++ b/demo/src/main/assets/media.exolist.json
@@ -183,52 +183,52 @@
         "uri": "https://storage.googleapis.com/wvmedia/clear/vp9/tears/tears_uhd.mpd"
       },
       {
-        "name": "WV: Secure SD & HD (WebM,VP9)",
+        "name": "WV: Secure Fullsample SD & HD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure SD (WebM,VP9)",
+        "name": "WV: Secure Fullsample SD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_sd.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure HD (WebM,VP9)",
+        "name": "WV: Secure Fullsample HD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_hd.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure UHD (WebM,VP9)",
+        "name": "WV: Secure Fullsample UHD (WebM,VP9)",
         "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/tears/tears_uhd.mpd",
         "drm_scheme": "widevine",
         "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Subsample (WebM, VP9 with altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_altref_subsample/sintel_1080p_vp9_altref_subsample.mpd",
+        "name": "WV: Secure Subsample SD & HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Fullsample (WebM, VP9 with altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_altref_fullsample/sintel_1080p_vp9_altref_fullsample.mpd",
+        "name": "WV: Secure Subsample SD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_sd.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Subsample (WebM, VP9 without altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_noaltref_subsample/sintel_1080p_vp9_noaltref_subsample.mpd",
+        "name": "WV: Secure Subsample HD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_hd.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       },
       {
-        "name": "WV: Secure Fullsample (WebM, VP9 without altref)",
-        "uri": "https://storage.googleapis.com/widevine_test/vp9/sintel_1080p_vp9_noaltref_fullsample/sintel_1080p_vp9_noaltref_fullsample.mpd",
+        "name": "WV: Secure Subsample UHD (WebM,VP9)",
+        "uri": "https://storage.googleapis.com/wvmedia/cenc/vp9/subsample/24fps/tears/tears_uhd.mpd",
         "drm_scheme": "widevine",
-        "drm_license_url": "https://widevine-proxy.appspot.com/proxy"
+        "drm_license_url": "https://proxy.uat.widevine.com/proxy?provider=widevine_test"
       }
     ]
   },
@@ -277,6 +277,18 @@
       }
     ]
   },
+  {
+    "name": "ClearKey DASH",
+    "samples": [
+      {
+        "name": "Big Buck Bunny (CENC ClearKey)",
+        "uri": "http://html5.cablelabs.com:8100/cenc/ck/dash.mpd",
+        "extension": "mpd",
+        "drm_scheme": "cenc",
+        "drm_license_url": "https://wasabeef.jp/demos/cenc-ck-dash.json"
+      }
+    ]
+  },
   {
     "name": "SmoothStreaming",
     "samples": [
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
index 5ad28f9e72..e39cd16743 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
@@ -26,16 +26,17 @@
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
-import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
 import com.google.android.exoplayer2.metadata.id3.ApicFrame;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
 import com.google.android.exoplayer2.metadata.id3.GeobFrame;
 import com.google.android.exoplayer2.metadata.id3.Id3Frame;
 import com.google.android.exoplayer2.metadata.id3.PrivFrame;
 import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
-import com.google.android.exoplayer2.metadata.id3.TxxxFrame;
+import com.google.android.exoplayer2.metadata.id3.UrlLinkFrame;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.TrackGroup;
@@ -55,7 +56,7 @@
  */
 /* package */ final class EventLogger implements ExoPlayer.EventListener,
     AudioRendererEventListener, VideoRendererEventListener, AdaptiveMediaSourceEventListener,
-    ExtractorMediaSource.EventListener, StreamingDrmSessionManager.EventListener,
+    ExtractorMediaSource.EventListener, DefaultDrmSessionManager.EventListener,
     MetadataRenderer.Output {
 
   private static final String TAG = "EventLogger";
@@ -100,9 +101,6 @@ public void onPositionDiscontinuity() {
 
   @Override
   public void onTimelineChanged(Timeline timeline, Object manifest) {
-    if (timeline == null) {
-      return;
-    }
     int periodCount = timeline.getPeriodCount();
     int windowCount = timeline.getWindowCount();
     Log.d(TAG, "sourceInfo [periodCount=" + periodCount + ", windowCount=" + windowCount);
@@ -153,7 +151,7 @@ public void onTracksChanged(TrackGroupArray ignored, TrackSelectionArray trackSe
             String formatSupport = getFormatSupportString(
                 mappedTrackInfo.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex));
             Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
-                + getFormatString(trackGroup.getFormat(trackIndex))
+                + Format.toLogString(trackGroup.getFormat(trackIndex))
                 + ", supported=" + formatSupport);
           }
           Log.d(TAG, "    ]");
@@ -185,7 +183,7 @@ public void onTracksChanged(TrackGroupArray ignored, TrackSelectionArray trackSe
           String formatSupport = getFormatSupportString(
               RendererCapabilities.FORMAT_UNSUPPORTED_TYPE);
           Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
-              + getFormatString(trackGroup.getFormat(trackIndex))
+              + Format.toLogString(trackGroup.getFormat(trackIndex))
               + ", supported=" + formatSupport);
         }
         Log.d(TAG, "    ]");
@@ -224,7 +222,7 @@ public void onAudioDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onAudioInputFormatChanged(Format format) {
-    Log.d(TAG, "audioFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
+    Log.d(TAG, "audioFormatChanged [" + getSessionTimeString() + ", " + Format.toLogString(format)
         + "]");
   }
 
@@ -254,7 +252,7 @@ public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onVideoInputFormatChanged(Format format) {
-    Log.d(TAG, "videoFormatChanged [" + getSessionTimeString() + ", " + getFormatString(format)
+    Log.d(TAG, "videoFormatChanged [" + getSessionTimeString() + ", " + Format.toLogString(format)
         + "]");
   }
 
@@ -279,13 +277,23 @@ public void onRenderedFirstFrame(Surface surface) {
     // Do nothing.
   }
 
-  // StreamingDrmSessionManager.EventListener
+  // DefaultDrmSessionManager.EventListener
 
   @Override
   public void onDrmSessionManagerError(Exception e) {
     printInternalError("drmSessionManagerError", e);
   }
 
+  @Override
+  public void onDrmKeysRestored() {
+    Log.d(TAG, "drmKeysRestored [" + getSessionTimeString() + "]");
+  }
+
+  @Override
+  public void onDrmKeysRemoved() {
+    Log.d(TAG, "drmKeysRemoved [" + getSessionTimeString() + "]");
+  }
+
   @Override
   public void onDrmKeysLoaded() {
     Log.d(TAG, "drmKeysLoaded [" + getSessionTimeString() + "]");
@@ -349,10 +357,13 @@ private void printInternalError(String type, Exception e) {
   private void printMetadata(Metadata metadata, String prefix) {
     for (int i = 0; i < metadata.length(); i++) {
       Metadata.Entry entry = metadata.get(i);
-      if (entry instanceof TxxxFrame) {
-        TxxxFrame txxxFrame = (TxxxFrame) entry;
-        Log.d(TAG, prefix + String.format("%s: description=%s, value=%s", txxxFrame.id,
-            txxxFrame.description, txxxFrame.value));
+      if (entry instanceof TextInformationFrame) {
+        TextInformationFrame textInformationFrame = (TextInformationFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: value=%s", textInformationFrame.id,
+            textInformationFrame.value));
+      } else if (entry instanceof UrlLinkFrame) {
+        UrlLinkFrame urlLinkFrame = (UrlLinkFrame) entry;
+        Log.d(TAG, prefix + String.format("%s: url=%s", urlLinkFrame.id, urlLinkFrame.url));
       } else if (entry instanceof PrivFrame) {
         PrivFrame privFrame = (PrivFrame) entry;
         Log.d(TAG, prefix + String.format("%s: owner=%s", privFrame.id, privFrame.owner));
@@ -364,17 +375,17 @@ private void printMetadata(Metadata metadata, String prefix) {
         ApicFrame apicFrame = (ApicFrame) entry;
         Log.d(TAG, prefix + String.format("%s: mimeType=%s, description=%s",
             apicFrame.id, apicFrame.mimeType, apicFrame.description));
-      } else if (entry instanceof TextInformationFrame) {
-        TextInformationFrame textInformationFrame = (TextInformationFrame) entry;
-        Log.d(TAG, prefix + String.format("%s: description=%s", textInformationFrame.id,
-            textInformationFrame.description));
       } else if (entry instanceof CommentFrame) {
         CommentFrame commentFrame = (CommentFrame) entry;
-        Log.d(TAG, prefix + String.format("%s: language=%s description=%s", commentFrame.id,
+        Log.d(TAG, prefix + String.format("%s: language=%s, description=%s", commentFrame.id,
             commentFrame.language, commentFrame.description));
       } else if (entry instanceof Id3Frame) {
         Id3Frame id3Frame = (Id3Frame) entry;
         Log.d(TAG, prefix + String.format("%s", id3Frame.id));
+      } else if (entry instanceof EventMessage) {
+        EventMessage eventMessage = (EventMessage) entry;
+        Log.d(TAG, prefix + String.format("EMSG: scheme=%s, id=%d, value=%s",
+            eventMessage.schemeIdUri, eventMessage.id, eventMessage.value));
       }
     }
   }
@@ -433,33 +444,6 @@ private static String getAdaptiveSupportString(int trackCount, int adaptiveSuppo
     }
   }
 
-  private static String getFormatString(Format format) {
-    if (format == null) {
-      return "null";
-    }
-    StringBuilder builder = new StringBuilder();
-    builder.append("id=").append(format.id).append(", mimeType=").append(format.sampleMimeType);
-    if (format.bitrate != Format.NO_VALUE) {
-      builder.append(", bitrate=").append(format.bitrate);
-    }
-    if (format.width != Format.NO_VALUE && format.height != Format.NO_VALUE) {
-      builder.append(", res=").append(format.width).append("x").append(format.height);
-    }
-    if (format.frameRate != Format.NO_VALUE) {
-      builder.append(", fps=").append(format.frameRate);
-    }
-    if (format.channelCount != Format.NO_VALUE) {
-      builder.append(", channels=").append(format.channelCount);
-    }
-    if (format.sampleRate != Format.NO_VALUE) {
-      builder.append(", sample_rate=").append(format.sampleRate);
-    }
-    if (format.language != null) {
-      builder.append(", language=").append(format.language);
-    }
-    return builder.toString();
-  }
-
   private static String getTrackStatusString(TrackSelection selection, TrackGroup group,
       int trackIndex) {
     return getTrackStatusString(selection != null && selection.getTrackGroup() == group
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 243fcadce0..adb04eaa24 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -36,15 +36,16 @@
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
-import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
+import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -54,7 +55,7 @@
 import com.google.android.exoplayer2.source.hls.HlsMediaSource;
 import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
 import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
-import com.google.android.exoplayer2.trackselection.AdaptiveVideoTrackSelection;
+import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -69,8 +70,6 @@
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.CookiePolicy;
-import java.util.HashMap;
-import java.util.Map;
 import java.util.UUID;
 
 /**
@@ -100,7 +99,6 @@
   }
 
   private Handler mainHandler;
-  private Timeline.Window window;
   private EventLogger eventLogger;
   private SimpleExoPlayerView simpleExoPlayerView;
   private LinearLayout debugRootView;
@@ -112,12 +110,11 @@
   private DefaultTrackSelector trackSelector;
   private TrackSelectionHelper trackSelectionHelper;
   private DebugTextViewHelper debugViewHelper;
-  private boolean playerNeedsSource;
+  private boolean needRetrySource;
 
   private boolean shouldAutoPlay;
-  private boolean isTimelineStatic;
-  private int playerWindow;
-  private long playerPosition;
+  private int resumeWindow;
+  private long resumePosition;
 
   // Activity lifecycle
 
@@ -125,9 +122,9 @@
   public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     shouldAutoPlay = true;
+    clearResumePosition();
     mediaDataSourceFactory = buildDataSourceFactory(true);
     mainHandler = new Handler();
-    window = new Timeline.Window();
     if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
       CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
     }
@@ -148,7 +145,8 @@ public void onCreate(Bundle savedInstanceState) {
   @Override
   public void onNewIntent(Intent intent) {
     releasePlayer();
-    isTimelineStatic = false;
+    shouldAutoPlay = true;
+    clearResumePosition();
     setIntent(intent);
   }
 
@@ -231,7 +229,8 @@ public void onVisibilityChange(int visibility) {
 
   private void initializePlayer() {
     Intent intent = getIntent();
-    if (player == null) {
+    boolean needNewPlayer = player == null;
+    if (needNewPlayer) {
       boolean preferExtensionDecoders = intent.getBooleanExtra(PREFER_EXTENSION_DECODERS, false);
       UUID drmSchemeUuid = intent.hasExtra(DRM_SCHEME_UUID_EXTRA)
           ? UUID.fromString(intent.getStringExtra(DRM_SCHEME_UUID_EXTRA)) : null;
@@ -239,19 +238,9 @@ private void initializePlayer() {
       if (drmSchemeUuid != null) {
         String drmLicenseUrl = intent.getStringExtra(DRM_LICENSE_URL);
         String[] keyRequestPropertiesArray = intent.getStringArrayExtra(DRM_KEY_REQUEST_PROPERTIES);
-        Map<String, String> keyRequestProperties;
-        if (keyRequestPropertiesArray == null || keyRequestPropertiesArray.length < 2) {
-          keyRequestProperties = null;
-        } else {
-          keyRequestProperties = new HashMap<>();
-          for (int i = 0; i < keyRequestPropertiesArray.length - 1; i += 2) {
-            keyRequestProperties.put(keyRequestPropertiesArray[i],
-                keyRequestPropertiesArray[i + 1]);
-          }
-        }
         try {
           drmSessionManager = buildDrmSessionManager(drmSchemeUuid, drmLicenseUrl,
-              keyRequestProperties);
+              keyRequestPropertiesArray);
         } catch (UnsupportedDrmException e) {
           int errorStringId = Util.SDK_INT < 18 ? R.string.error_drm_not_supported
               : (e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
@@ -264,10 +253,10 @@ private void initializePlayer() {
       @SimpleExoPlayer.ExtensionRendererMode int extensionRendererMode =
           ((DemoApplication) getApplication()).useExtensionRenderers()
               ? (preferExtensionDecoders ? SimpleExoPlayer.EXTENSION_RENDERER_MODE_PREFER
-                  : SimpleExoPlayer.EXTENSION_RENDERER_MODE_ON)
+              : SimpleExoPlayer.EXTENSION_RENDERER_MODE_ON)
               : SimpleExoPlayer.EXTENSION_RENDERER_MODE_OFF;
       TrackSelection.Factory videoTrackSelectionFactory =
-          new AdaptiveVideoTrackSelection.Factory(BANDWIDTH_METER);
+          new AdaptiveTrackSelection.Factory(BANDWIDTH_METER);
       trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
       trackSelectionHelper = new TrackSelectionHelper(trackSelector, videoTrackSelectionFactory);
       player = ExoPlayerFactory.newSimpleInstance(this, trackSelector, new DefaultLoadControl(),
@@ -278,22 +267,14 @@ private void initializePlayer() {
       player.addListener(eventLogger);
       player.setAudioDebugListener(eventLogger);
       player.setVideoDebugListener(eventLogger);
-      player.setId3Output(eventLogger);
+      player.setMetadataOutput(eventLogger);
 
       simpleExoPlayerView.setPlayer(player);
-      if (isTimelineStatic) {
-        if (playerPosition == C.TIME_UNSET) {
-          player.seekToDefaultPosition(playerWindow);
-        } else {
-          player.seekTo(playerWindow, playerPosition);
-        }
-      }
       player.setPlayWhenReady(shouldAutoPlay);
       debugViewHelper = new DebugTextViewHelper(player, debugTextView);
       debugViewHelper.start();
-      playerNeedsSource = true;
     }
-    if (playerNeedsSource) {
+    if (needNewPlayer || needRetrySource) {
       String action = intent.getAction();
       Uri[] uris;
       String[] extensions;
@@ -324,15 +305,19 @@ private void initializePlayer() {
       }
       MediaSource mediaSource = mediaSources.length == 1 ? mediaSources[0]
           : new ConcatenatingMediaSource(mediaSources);
-      player.prepare(mediaSource, !isTimelineStatic, !isTimelineStatic);
-      playerNeedsSource = false;
+      boolean haveResumePosition = resumeWindow != C.INDEX_UNSET;
+      if (haveResumePosition) {
+        player.seekTo(resumeWindow, resumePosition);
+      }
+      player.prepare(mediaSource, !haveResumePosition, false);
+      needRetrySource = false;
       updateButtonVisibilities();
     }
   }
 
   private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
-    int type = Util.inferContentType(!TextUtils.isEmpty(overrideExtension) ? "." + overrideExtension
-        : uri.getLastPathSegment());
+    int type = TextUtils.isEmpty(overrideExtension) ? Util.inferContentType(uri)
+        : Util.inferContentType("." + overrideExtension);
     switch (type) {
       case C.TYPE_SS:
         return new SsMediaSource(uri, buildDataSourceFactory(false),
@@ -352,13 +337,19 @@ private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
   }
 
   private DrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(UUID uuid,
-      String licenseUrl, Map<String, String> keyRequestProperties) throws UnsupportedDrmException {
+      String licenseUrl, String[] keyRequestPropertiesArray) throws UnsupportedDrmException {
     if (Util.SDK_INT < 18) {
       return null;
     }
     HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(licenseUrl,
-        buildHttpDataSourceFactory(false), keyRequestProperties);
-    return new StreamingDrmSessionManager<>(uuid,
+        buildHttpDataSourceFactory(false));
+    if (keyRequestPropertiesArray != null) {
+      for (int i = 0; i < keyRequestPropertiesArray.length - 1; i += 2) {
+        drmCallback.setKeyRequestProperty(keyRequestPropertiesArray[i],
+            keyRequestPropertiesArray[i + 1]);
+      }
+    }
+    return new DefaultDrmSessionManager<>(uuid,
         FrameworkMediaDrm.newInstance(uuid), drmCallback, null, mainHandler, eventLogger);
   }
 
@@ -367,12 +358,7 @@ private void releasePlayer() {
       debugViewHelper.stop();
       debugViewHelper = null;
       shouldAutoPlay = player.getPlayWhenReady();
-      playerWindow = player.getCurrentWindowIndex();
-      playerPosition = C.TIME_UNSET;
-      Timeline timeline = player.getCurrentTimeline();
-      if (!timeline.isEmpty() && timeline.getWindow(playerWindow, window).isSeekable) {
-        playerPosition = player.getCurrentPosition();
-      }
+      updateResumePosition();
       player.release();
       player = null;
       trackSelector = null;
@@ -381,6 +367,17 @@ private void releasePlayer() {
     }
   }
 
+  private void updateResumePosition() {
+    resumeWindow = player.getCurrentWindowIndex();
+    resumePosition = player.isCurrentWindowSeekable() ? Math.max(0, player.getCurrentPosition())
+        : C.TIME_UNSET;
+  }
+
+  private void clearResumePosition() {
+    resumeWindow = C.INDEX_UNSET;
+    resumePosition = C.TIME_UNSET;
+  }
+
   /**
    * Returns a new DataSource factory.
    *
@@ -422,13 +419,17 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
 
   @Override
   public void onPositionDiscontinuity() {
-    // Do nothing.
+    if (needRetrySource) {
+      // This will only occur if the user has performed a seek whilst in the error state. Update the
+      // resume position so that if the user then retries, playback will resume from the position to
+      // which they seeked.
+      updateResumePosition();
+    }
   }
 
   @Override
   public void onTimelineChanged(Timeline timeline, Object manifest) {
-    isTimelineStatic = !timeline.isEmpty()
-        && !timeline.getWindow(timeline.getWindowCount() - 1, window).isDynamic;
+    // Do nothing.
   }
 
   @Override
@@ -459,9 +460,15 @@ public void onPlayerError(ExoPlaybackException e) {
     if (errorString != null) {
       showToast(errorString);
     }
-    playerNeedsSource = true;
-    updateButtonVisibilities();
-    showControls();
+    needRetrySource = true;
+    if (isBehindLiveWindow(e)) {
+      clearResumePosition();
+      initializePlayer();
+    } else {
+      updateResumePosition();
+      updateButtonVisibilities();
+      showControls();
+    }
   }
 
   @Override
@@ -485,7 +492,7 @@ public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray tra
   private void updateButtonVisibilities() {
     debugRootView.removeAllViews();
 
-    retryButton.setVisibility(playerNeedsSource ? View.VISIBLE : View.GONE);
+    retryButton.setVisibility(needRetrySource ? View.VISIBLE : View.GONE);
     debugRootView.addView(retryButton);
 
     if (player == null) {
@@ -535,4 +542,18 @@ private void showToast(String message) {
     Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
   }
 
+  private static boolean isBehindLiveWindow(ExoPlaybackException e) {
+    if (e.type != ExoPlaybackException.TYPE_SOURCE) {
+      return false;
+    }
+    Throwable cause = e.getSourceException();
+    while (cause != null) {
+      if (cause instanceof BehindLiveWindowException) {
+        return true;
+      }
+      cause = cause.getCause();
+    }
+    return false;
+  }
+
 }
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
index 946181284f..081ad190b5 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
@@ -262,11 +262,13 @@ private SampleGroup getGroup(String groupName, List<SampleGroup> groups) {
     }
 
     private UUID getDrmUuid(String typeString) throws ParserException {
-      switch (typeString.toLowerCase()) {
+      switch (Util.toLowerInvariant(typeString)) {
         case "widevine":
           return C.WIDEVINE_UUID;
         case "playready":
           return C.PLAYREADY_UUID;
+        case "cenc":
+          return C.CLEARKEY_UUID;
         default:
           try {
             return UUID.fromString(typeString);
diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
index 936cdf90f8..576eb23c9d 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java
@@ -51,7 +51,7 @@
   private static final TrackSelection.Factory RANDOM_FACTORY = new RandomTrackSelection.Factory();
 
   private final MappingTrackSelector selector;
-  private final TrackSelection.Factory adaptiveVideoTrackSelectionFactory;
+  private final TrackSelection.Factory adaptiveTrackSelectionFactory;
 
   private MappedTrackInfo trackInfo;
   private int rendererIndex;
@@ -67,13 +67,13 @@
 
   /**
    * @param selector The track selector.
-   * @param adaptiveVideoTrackSelectionFactory A factory for adaptive video {@link TrackSelection}s,
-   *     or null if the selection helper should not support adaptive video.
+   * @param adaptiveTrackSelectionFactory A factory for adaptive {@link TrackSelection}s, or null
+   *     if the selection helper should not support adaptive tracks.
    */
   public TrackSelectionHelper(MappingTrackSelector selector,
-      TrackSelection.Factory adaptiveVideoTrackSelectionFactory) {
+      TrackSelection.Factory adaptiveTrackSelectionFactory) {
     this.selector = selector;
-    this.adaptiveVideoTrackSelectionFactory = adaptiveVideoTrackSelectionFactory;
+    this.adaptiveTrackSelectionFactory = adaptiveTrackSelectionFactory;
   }
 
   /**
@@ -92,7 +92,7 @@ public void showSelectionDialog(Activity activity, CharSequence title, MappedTra
     trackGroups = trackInfo.getTrackGroups(rendererIndex);
     trackGroupsAdaptive = new boolean[trackGroups.length];
     for (int i = 0; i < trackGroups.length; i++) {
-      trackGroupsAdaptive[i] = adaptiveVideoTrackSelectionFactory != null
+      trackGroupsAdaptive[i] = adaptiveTrackSelectionFactory != null
           && trackInfo.getAdaptiveSupport(rendererIndex, i, false)
               != RendererCapabilities.ADAPTIVE_NOT_SUPPORTED
           && trackGroups.get(i).length > 1;
@@ -271,7 +271,7 @@ public void onClick(View view) {
 
   private void setOverride(int group, int[] tracks, boolean enableRandomAdaptation) {
     TrackSelection.Factory factory = tracks.length == 1 ? FIXED_FACTORY
-        : (enableRandomAdaptation ? RANDOM_FACTORY : adaptiveVideoTrackSelectionFactory);
+        : (enableRandomAdaptation ? RANDOM_FACTORY : adaptiveTrackSelectionFactory);
     override = new SelectionOverride(factory, group, tracks);
   }
 
@@ -301,15 +301,18 @@ private void setOverride(int group, int[] tracks, boolean enableRandomAdaptation
   private static String buildTrackName(Format format) {
     String trackName;
     if (MimeTypes.isVideo(format.sampleMimeType)) {
-      trackName = joinWithSeparator(joinWithSeparator(buildResolutionString(format),
-          buildBitrateString(format)), buildTrackIdString(format));
+      trackName = joinWithSeparator(joinWithSeparator(joinWithSeparator(
+          buildResolutionString(format), buildBitrateString(format)), buildTrackIdString(format)),
+          buildSampleMimeTypeString(format));
     } else if (MimeTypes.isAudio(format.sampleMimeType)) {
-      trackName = joinWithSeparator(joinWithSeparator(joinWithSeparator(buildLanguageString(format),
-          buildAudioPropertyString(format)), buildBitrateString(format)),
-          buildTrackIdString(format));
+      trackName = joinWithSeparator(joinWithSeparator(joinWithSeparator(joinWithSeparator(
+          buildLanguageString(format), buildAudioPropertyString(format)),
+          buildBitrateString(format)), buildTrackIdString(format)),
+          buildSampleMimeTypeString(format));
     } else {
-      trackName = joinWithSeparator(joinWithSeparator(buildLanguageString(format),
-          buildBitrateString(format)), buildTrackIdString(format));
+      trackName = joinWithSeparator(joinWithSeparator(joinWithSeparator(buildLanguageString(format),
+          buildBitrateString(format)), buildTrackIdString(format)),
+          buildSampleMimeTypeString(format));
     }
     return trackName.length() == 0 ? "unknown" : trackName;
   }
@@ -342,4 +345,8 @@ private static String buildTrackIdString(Format format) {
     return format.id == null ? "" : ("id:" + format.id);
   }
 
+  private static String buildSampleMimeTypeString(Format format) {
+    return format.sampleMimeType == null ? "" : format.sampleMimeType;
+  }
+
 }
diff --git a/demo/src/main/res/drawable-hdpi/ic_launcher.png b/demo/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100644
index 3e5716b8ad..0000000000
Binary files a/demo/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-mdpi/ic_launcher.png b/demo/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100644
index a5d2a53b13..0000000000
Binary files a/demo/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-xhdpi/ic_banner.png b/demo/src/main/res/drawable-xhdpi/ic_banner.png
index dad9daa4de..520d83cc3b 100644
Binary files a/demo/src/main/res/drawable-xhdpi/ic_banner.png and b/demo/src/main/res/drawable-xhdpi/ic_banner.png differ
diff --git a/demo/src/main/res/drawable-xhdpi/ic_launcher.png b/demo/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100644
index 1d00268635..0000000000
Binary files a/demo/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-xxhdpi/ic_launcher.png b/demo/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100644
index ef2f312fd4..0000000000
Binary files a/demo/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png b/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png
deleted file mode 100644
index 0acebb43c1..0000000000
Binary files a/demo/src/main/res/drawable-xxxhdpi/ic_launcher.png and /dev/null differ
diff --git a/demo/src/main/res/mipmap-hdpi/ic_launcher.png b/demo/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..6e8b5499de
Binary files /dev/null and b/demo/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-mdpi/ic_launcher.png b/demo/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..26fe2f0782
Binary files /dev/null and b/demo/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-xhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..d3251491ce
Binary files /dev/null and b/demo/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..b5a12d35f3
Binary files /dev/null and b/demo/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..9c26192c32
Binary files /dev/null and b/demo/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/demo/src/main/res/values/strings.xml b/demo/src/main/res/values/strings.xml
index c0e1488fe5..ac17ad4443 100644
--- a/demo/src/main/res/values/strings.xml
+++ b/demo/src/main/res/values/strings.xml
@@ -16,8 +16,7 @@
 
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
 
-  <!-- The user visible name of the application. [CHAR LIMIT=20] -->
-  <string name="application_name">ExoPlayer2 Demo</string>
+  <string name="application_name">ExoPlayer</string>
 
   <string name="video">Video</string>
 
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 3c9a36c891..f031a9dc48 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -18,22 +18,11 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
     }
 
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
-    }
-
     sourceSets.main {
         jniLibs.srcDirs = ['jniLibs']
     }
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
index 7efc542dd0..246e23e172 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
@@ -57,8 +57,8 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.chromium.net.CronetEngine;
+import org.chromium.net.NetworkException;
 import org.chromium.net.UrlRequest;
-import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
 import org.chromium.net.impl.UrlResponseInfoImpl;
 import org.junit.Before;
@@ -99,7 +99,7 @@
   @Mock
   private Executor mockExecutor;
   @Mock
-  private UrlRequestException mockUrlRequestException;
+  private NetworkException mockNetworkException;
   @Mock private CronetEngine mockCronetEngine;
 
   private CronetDataSource dataSourceUnderTest;
@@ -118,7 +118,8 @@ public void setUp() throws Exception {
             TEST_CONNECT_TIMEOUT_MS,
             TEST_READ_TIMEOUT_MS,
             true, // resetTimeoutOnRedirects
-            mockClock));
+            mockClock,
+            null));
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(true);
     when(mockCronetEngine.newUrlRequestBuilder(
             anyString(), any(UrlRequest.Callback.class), any(Executor.class)))
@@ -172,7 +173,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             testUrlResponseInfo,
-            mockUrlRequestException);
+            mockNetworkException);
         dataSourceUnderTest.onResponseStarted(
             mockUrlRequest2,
             testUrlResponseInfo);
@@ -245,8 +246,8 @@ public void testRequestOpenFail() {
   @Test
   public void testRequestOpenFailDueToDnsFailure() {
     mockResponseStartFailure();
-    when(mockUrlRequestException.getErrorCode()).thenReturn(
-        UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED);
+    when(mockNetworkException.getErrorCode()).thenReturn(
+        NetworkException.ERROR_HOSTNAME_NOT_RESOLVED);
 
     try {
       dataSourceUnderTest.open(testDataSpec);
@@ -728,7 +729,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             createUrlResponseInfo(500), // statusCode
-            mockUrlRequestException);
+            mockNetworkException);
         return null;
       }
     }).when(mockUrlRequest).start();
@@ -764,7 +765,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         dataSourceUnderTest.onFailed(
             mockUrlRequest,
             createUrlResponseInfo(500), // statusCode
-            mockUrlRequestException);
+            mockNetworkException);
         return null;
       }
     }).when(mockUrlRequest).read(any(ByteBuffer.class));
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index 83f46bd488..4f15a6eabc 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -32,7 +32,6 @@
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -40,9 +39,10 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import org.chromium.net.CronetEngine;
+import org.chromium.net.CronetException;
+import org.chromium.net.NetworkException;
 import org.chromium.net.UrlRequest;
 import org.chromium.net.UrlRequest.Status;
-import org.chromium.net.UrlRequestException;
 import org.chromium.net.UrlResponseInfo;
 
 /**
@@ -97,7 +97,8 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
   private final int connectTimeoutMs;
   private final int readTimeoutMs;
   private final boolean resetTimeoutOnRedirects;
-  private final Map<String, String> requestProperties;
+  private final RequestProperties defaultRequestProperties;
+  private final RequestProperties requestProperties;
   private final ConditionVariable operation;
   private final Clock clock;
 
@@ -135,7 +136,7 @@ public OpenException(String errorMessage, DataSpec dataSpec, int cronetConnectio
   public CronetDataSource(CronetEngine cronetEngine, Executor executor,
       Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener) {
     this(cronetEngine, executor, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
-        DEFAULT_READ_TIMEOUT_MILLIS, false);
+        DEFAULT_READ_TIMEOUT_MILLIS, false, null);
   }
 
   /**
@@ -148,17 +149,20 @@ public CronetDataSource(CronetEngine cronetEngine, Executor executor,
    * @param connectTimeoutMs The connection timeout, in milliseconds.
    * @param readTimeoutMs The read timeout, in milliseconds.
    * @param resetTimeoutOnRedirects Whether the connect timeout is reset when a redirect occurs.
+   * @param defaultRequestProperties The default request properties to be used.
    */
   public CronetDataSource(CronetEngine cronetEngine, Executor executor,
       Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener,
-      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects) {
+      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects,
+      RequestProperties defaultRequestProperties) {
     this(cronetEngine, executor, contentTypePredicate, listener, connectTimeoutMs,
-        readTimeoutMs, resetTimeoutOnRedirects, new SystemClock());
+        readTimeoutMs, resetTimeoutOnRedirects, new SystemClock(), defaultRequestProperties);
   }
 
   /* package */ CronetDataSource(CronetEngine cronetEngine, Executor executor,
       Predicate<String> contentTypePredicate, TransferListener<? super CronetDataSource> listener,
-      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects, Clock clock) {
+      int connectTimeoutMs, int readTimeoutMs, boolean resetTimeoutOnRedirects, Clock clock,
+      RequestProperties defaultRequestProperties) {
     this.cronetEngine = Assertions.checkNotNull(cronetEngine);
     this.executor = Assertions.checkNotNull(executor);
     this.contentTypePredicate = contentTypePredicate;
@@ -167,7 +171,8 @@ public CronetDataSource(CronetEngine cronetEngine, Executor executor,
     this.readTimeoutMs = readTimeoutMs;
     this.resetTimeoutOnRedirects = resetTimeoutOnRedirects;
     this.clock = Assertions.checkNotNull(clock);
-    requestProperties = new HashMap<>();
+    this.defaultRequestProperties = defaultRequestProperties;
+    requestProperties = new RequestProperties();
     operation = new ConditionVariable();
   }
 
@@ -175,23 +180,17 @@ public CronetDataSource(CronetEngine cronetEngine, Executor executor,
 
   @Override
   public void setRequestProperty(String name, String value) {
-    synchronized (requestProperties) {
-      requestProperties.put(name, value);
-    }
+    requestProperties.set(name, value);
   }
 
   @Override
   public void clearRequestProperty(String name) {
-    synchronized (requestProperties) {
-      requestProperties.remove(name);
-    }
+    requestProperties.remove(name);
   }
 
   @Override
   public void clearAllRequestProperties() {
-    synchronized (requestProperties) {
-      requestProperties.clear();
-    }
+    requestProperties.clear();
   }
 
   @Override
@@ -400,12 +399,17 @@ public synchronized void onSucceeded(UrlRequest request, UrlResponseInfo info) {
 
   @Override
   public synchronized void onFailed(UrlRequest request, UrlResponseInfo info,
-      UrlRequestException error) {
+      CronetException error) {
     if (request != currentUrlRequest) {
       return;
     }
-    exception = error.getErrorCode() == UrlRequestException.ERROR_HOSTNAME_NOT_RESOLVED
-        ? new UnknownHostException() : error;
+    if (error instanceof NetworkException
+        && ((NetworkException) error).getErrorCode()
+            == NetworkException.ERROR_HOSTNAME_NOT_RESOLVED) {
+      exception = new UnknownHostException();
+    } else {
+      exception = error;
+    }
     operation.open();
   }
 
@@ -415,16 +419,24 @@ private UrlRequest buildRequest(DataSpec dataSpec) throws OpenException {
     UrlRequest.Builder requestBuilder = cronetEngine.newUrlRequestBuilder(dataSpec.uri.toString(),
         this, executor);
     // Set the headers.
-    synchronized (requestProperties) {
-      if (dataSpec.postBody != null && dataSpec.postBody.length != 0
-          && !requestProperties.containsKey(CONTENT_TYPE)) {
-        throw new OpenException("POST request with non-empty body must set Content-Type", dataSpec,
-            Status.IDLE);
-      }
-      for (Entry<String, String> headerEntry : requestProperties.entrySet()) {
-        requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
+    boolean isContentTypeHeaderSet = false;
+    if (defaultRequestProperties != null) {
+      for (Entry<String, String> headerEntry : defaultRequestProperties.getSnapshot().entrySet()) {
+        String key = headerEntry.getKey();
+        isContentTypeHeaderSet = isContentTypeHeaderSet || CONTENT_TYPE.equals(key);
+        requestBuilder.addHeader(key, headerEntry.getValue());
       }
     }
+    Map<String, String> requestPropertiesSnapshot = requestProperties.getSnapshot();
+    for (Entry<String, String> headerEntry : requestPropertiesSnapshot.entrySet()) {
+      String key = headerEntry.getKey();
+      isContentTypeHeaderSet = isContentTypeHeaderSet || CONTENT_TYPE.equals(key);
+      requestBuilder.addHeader(key, headerEntry.getValue());
+    }
+    if (dataSpec.postBody != null && dataSpec.postBody.length != 0 && !isContentTypeHeaderSet) {
+      throw new OpenException("POST request with non-empty body must set Content-Type", dataSpec,
+          Status.IDLE);
+    }
     // Set the Range header.
     if (currentDataSpec.position != 0 || currentDataSpec.length != C.LENGTH_UNSET) {
       StringBuilder rangeValue = new StringBuilder();
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
index 0f94dad158..db560305a7 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceFactory.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer2.ext.cronet;
 
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Predicate;
@@ -25,7 +27,7 @@
 /**
  * A {@link Factory} that produces {@link CronetDataSource}.
  */
-public final class CronetDataSourceFactory implements Factory {
+public final class CronetDataSourceFactory extends BaseFactory {
 
   /**
    * The default connection timeout, in milliseconds.
@@ -67,9 +69,10 @@ public CronetDataSourceFactory(CronetEngine cronetEngine,
   }
 
   @Override
-  public CronetDataSource createDataSource() {
+  protected CronetDataSource createDataSourceInternal(HttpDataSource.RequestProperties
+      defaultRequestProperties) {
     return new CronetDataSource(cronetEngine, executor, contentTypePredicate, transferListener,
-        connectTimeoutMs, readTimeoutMs, resetTimeoutOnRedirects);
+        connectTimeoutMs, readTimeoutMs, resetTimeoutOnRedirects, null, defaultRequestProperties);
   }
 
 }
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index d7c5e21fcc..beafcb6a96 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -31,9 +31,7 @@ FFMPEG_EXT_PATH="${EXOPLAYER_ROOT}/extensions/ffmpeg/src/main"
 NDK_PATH="<path to Android NDK>"
 ```
 
-* Fetch and build FFmpeg.
-
-For example, to fetch and build for armv7a:
+* Fetch and build FFmpeg. For example, to fetch and build for armv7a:
 
 ```
 cd "${FFMPEG_EXT_PATH}/jni" && \
@@ -63,20 +61,20 @@ git clone git://source.ffmpeg.org/ffmpeg ffmpeg && cd ffmpeg && \
     --enable-decoder=vorbis \
     --enable-decoder=opus \
     --enable-decoder=flac \
+    --enable-decoder=alac \
     && \
 make -j4 && \
 make install-libs
 ```
 
-* Build the JNI native libraries.
+* Build the JNI native libraries. Repeat this step for any other architectures
+  you need to support.
 
 ```
 cd "${FFMPEG_EXT_PATH}"/jni && \
 ${NDK_PATH}/ndk-build APP_ABI=armeabi-v7a -j4
 ```
 
-Repeat these steps for any other architectures you need to support.
-
 * In your project, you can add a dependency on the extension by using a rule
   like this:
 
diff --git a/extensions/ffmpeg/build.gradle b/extensions/ffmpeg/build.gradle
index 66facb204b..47dba3767c 100644
--- a/extensions/ffmpeg/build.gradle
+++ b/extensions/ffmpeg/build.gradle
@@ -18,19 +18,9 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/ffmpeg/src/main/proguard.cfg b/extensions/ffmpeg/proguard-rules.txt
similarity index 100%
rename from extensions/ffmpeg/src/main/proguard.cfg
rename to extensions/ffmpeg/proguard-rules.txt
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
index 1a70310a8d..8d75ca3dbb 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
@@ -17,8 +17,9 @@
 
 import android.os.Handler;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.audio.AudioCapabilities;
+import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
@@ -42,25 +43,15 @@ public FfmpegAudioRenderer() {
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
-   */
-  public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener) {
-    super(eventHandler, eventListener);
-  }
-
-  /**
-   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
-   *     null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
-   *     default capabilities (no encoded audio passthrough support) should be assumed.
+   * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
   public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioCapabilities audioCapabilities) {
-    super(eventHandler, eventListener, audioCapabilities);
+      AudioProcessor... audioProcessors) {
+    super(eventHandler, eventListener, audioProcessors);
   }
 
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(Format format) {
     if (!FfmpegLibrary.isAvailable()) {
       return FORMAT_UNSUPPORTED_TYPE;
     }
@@ -69,6 +60,11 @@ public int supportsFormat(Format format) {
         : MimeTypes.isAudio(mimeType) ? FORMAT_UNSUPPORTED_SUBTYPE : FORMAT_UNSUPPORTED_TYPE;
   }
 
+  @Override
+  public final int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
+    return ADAPTIVE_NOT_SEAMLESS;
+  }
+
   @Override
   protected FfmpegDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
       throws FfmpegDecoderException {
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
index 12f4bcf672..2af2101ee7 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.nio.ByteBuffer;
 import java.util.List;
 
@@ -88,6 +89,13 @@ public FfmpegDecoderException decode(DecoderInputBuffer inputBuffer,
     if (!hasOutputFormat) {
       channelCount = ffmpegGetChannelCount(nativeContext);
       sampleRate = ffmpegGetSampleRate(nativeContext);
+      if (sampleRate == 0 && "alac".equals(codecName)) {
+        // ALAC decoder did not set the sample rate in earlier versions of FFMPEG.
+        // See https://trac.ffmpeg.org/ticket/6096
+        ParsableByteArray parsableExtraData = new ParsableByteArray(extraData);
+        parsableExtraData.setPosition(extraData.length - 4);
+        sampleRate = parsableExtraData.readUnsignedIntToInt();
+      }
       hasOutputFormat = true;
     }
     outputBuffer.data.position(0);
@@ -123,6 +131,7 @@ public int getSampleRate() {
   private static byte[] getExtraData(String mimeType, List<byte[]> initializationData) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AAC:
+      case MimeTypes.AUDIO_ALAC:
       case MimeTypes.AUDIO_OPUS:
         return initializationData.get(0);
       case MimeTypes.AUDIO_VORBIS:
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
index 90b42c01bb..4992bcbb3e 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegLibrary.java
@@ -92,6 +92,8 @@ public static boolean supportsFormat(String mimeType) {
         return "amrwb";
       case MimeTypes.AUDIO_FLAC:
         return "flac";
+      case MimeTypes.AUDIO_ALAC:
+        return "alac";
       default:
         return null;
     }
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index a40a1adead..1c23b9987c 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -18,19 +18,9 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/flac/src/main/proguard.cfg b/extensions/flac/proguard-rules.txt
similarity index 60%
rename from extensions/flac/src/main/proguard.cfg
rename to extensions/flac/proguard-rules.txt
index 8e7f5e17d5..ee0a9fa5b5 100644
--- a/extensions/flac/src/main/proguard.cfg
+++ b/extensions/flac/proguard-rules.txt
@@ -5,7 +5,10 @@
     native <methods>;
 }
 
-# Some members of this class are being accessed from native methods. Keep them unobfuscated.
+# Some members of these classes are being accessed from native methods. Keep them unobfuscated.
 -keep class com.google.android.exoplayer2.ext.flac.FlacDecoderJni {
     *;
 }
+-keep class com.google.android.exoplayer2.util.FlacStreamInfo {
+    *;
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
index 42c5908619..d13194793e 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
@@ -67,7 +67,7 @@
   @Override
   public void init(ExtractorOutput output) {
     extractorOutput = output;
-    trackOutput = extractorOutput.track(0);
+    trackOutput = extractorOutput.track(0, C.TRACK_TYPE_AUDIO);
     extractorOutput.endTracks();
     try {
       decoderJni = new FlacDecoderJni();
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
index 954a090ee9..246cde9d2f 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
@@ -17,7 +17,7 @@
 
 import android.os.Handler;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.audio.AudioCapabilities;
+import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
@@ -38,25 +38,15 @@ public LibflacAudioRenderer() {
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
-   */
-  public LibflacAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener) {
-    super(eventHandler, eventListener);
-  }
-
-  /**
-   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
-   *     null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
-   *     default capabilities (no encoded audio passthrough support) should be assumed.
+   * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
   public LibflacAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioCapabilities audioCapabilities) {
-    super(eventHandler, eventListener, audioCapabilities);
+      AudioProcessor... audioProcessors) {
+    super(eventHandler, eventListener, audioProcessors);
   }
 
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(Format format) {
     return FlacLibrary.isAvailable() && MimeTypes.AUDIO_FLAC.equalsIgnoreCase(format.sampleMimeType)
         ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
   }
diff --git a/extensions/flac/src/main/jni/Android.mk b/extensions/flac/src/main/jni/Android.mk
index e009333633..ff54c1b3c0 100644
--- a/extensions/flac/src/main/jni/Android.mk
+++ b/extensions/flac/src/main/jni/Android.mk
@@ -31,7 +31,7 @@ LOCAL_C_INCLUDES := \
 LOCAL_SRC_FILES := $(FLAC_SOURCES)
 
 LOCAL_CFLAGS += '-DVERSION="1.3.1"' -DFLAC__NO_MD5 -DFLAC__INTEGER_ONLY_LIBRARY -DFLAC__NO_ASM
-LOCAL_CFLAGS += -D_REENTRANT -DPIC -DU_COMMON_IMPLEMENTATION -fPIC
+LOCAL_CFLAGS += -D_REENTRANT -DPIC -DU_COMMON_IMPLEMENTATION -fPIC -DHAVE_SYS_PARAM_H
 LOCAL_CFLAGS += -O3 -funroll-loops -finline-functions
 
 LOCAL_LDLIBS := -llog -lz -lm
diff --git a/extensions/flac/src/main/jni/flac_parser.cc b/extensions/flac/src/main/jni/flac_parser.cc
index 7d22c7fe79..e4925cb462 100644
--- a/extensions/flac/src/main/jni/flac_parser.cc
+++ b/extensions/flac/src/main/jni/flac_parser.cc
@@ -453,7 +453,8 @@ int64_t FLACParser::getSeekPosition(int64_t timeUs) {
   }
 
   FLAC__StreamMetadata_SeekPoint* points = mSeekTable->points;
-  for (unsigned i = mSeekTable->num_points - 1; i >= 0; i--) {
+  for (unsigned i = mSeekTable->num_points; i > 0; ) {
+    i--;
     if (points[i].sample_number <= sample) {
       return firstFrameOffset + points[i].stream_offset;
     }
diff --git a/extensions/gvr/README.md b/extensions/gvr/README.md
new file mode 100644
index 0000000000..bae5de4812
--- /dev/null
+++ b/extensions/gvr/README.md
@@ -0,0 +1,38 @@
+# ExoPlayer GVR Extension #
+
+## Description ##
+
+The GVR extension wraps the [Google VR SDK for Android][]. It provides a
+GvrAudioProcessor, which uses [GvrAudioSurround][] to provide binaural rendering
+of surround sound and ambisonic soundfields.
+
+## Using the extension ##
+
+The easiest way to use the extension is to add it as a gradle dependency. You
+need to make sure you have the jcenter repository included in the `build.gradle`
+file in the root of your project:
+
+```gradle
+repositories {
+    jcenter()
+}
+```
+
+Next, include the following in your module's `build.gradle` file:
+
+```gradle
+compile 'com.google.android.exoplayer:extension-gvr:rX.X.X'
+```
+
+where `rX.X.X` is the version, which must match the version of the ExoPlayer
+library being used.
+
+## Using GvrAudioProcessor ##
+
+* If using SimpleExoPlayer, override SimpleExoPlayer.buildAudioProcessors to
+  return a GvrAudioProcessor.
+* If constructing renderers directly, pass a GvrAudioProcessor to
+  MediaCodecAudioRenderer's constructor.
+
+[Google VR SDK for Android]: https://developers.google.com/vr/android/
+[GvrAudioSurround]: https://developers.google.com/vr/android/reference/com/google/vr/sdk/audio/GvrAudioSurround
diff --git a/extensions/gvr/build.gradle b/extensions/gvr/build.gradle
new file mode 100644
index 0000000000..5156cf0540
--- /dev/null
+++ b/extensions/gvr/build.gradle
@@ -0,0 +1,35 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion 19
+        targetSdkVersion project.ext.targetSdkVersion
+    }
+}
+
+dependencies {
+    compile project(':library')
+    compile 'com.google.vr:sdk-audio:1.30.0'
+}
+
+ext {
+    releaseArtifact = 'extension-gvr'
+    releaseDescription = 'Google VR extension for ExoPlayer.'
+}
+apply from: '../../publish.gradle'
diff --git a/extensions/gvr/src/main/AndroidManifest.xml b/extensions/gvr/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..6706b2507e
--- /dev/null
+++ b/extensions/gvr/src/main/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest package="com.google.android.exoplayer2.ext.gvr"/>
diff --git a/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
new file mode 100644
index 0000000000..2117985da0
--- /dev/null
+++ b/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.gvr;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.audio.AudioProcessor;
+import com.google.vr.sdk.audio.GvrAudioSurround;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * An {@link AudioProcessor} that uses {@code GvrAudioSurround} to provide binaural rendering of
+ * surround sound and ambisonic soundfields.
+ */
+public final class GvrAudioProcessor implements AudioProcessor {
+
+  private static final int FRAMES_PER_OUTPUT_BUFFER = 1024;
+  private static final int OUTPUT_CHANNEL_COUNT = 2;
+  private static final int OUTPUT_FRAME_SIZE = OUTPUT_CHANNEL_COUNT * 2; // 16-bit stereo output.
+
+  private int sampleRateHz;
+  private int channelCount;
+  private GvrAudioSurround gvrAudioSurround;
+  private ByteBuffer buffer;
+  private boolean inputEnded;
+
+  private float w;
+  private float x;
+  private float y;
+  private float z;
+
+  /**
+   * Creates a new GVR audio processor.
+   */
+  public GvrAudioProcessor() {
+    // Use the identity for the initial orientation.
+    w = 1f;
+    sampleRateHz = Format.NO_VALUE;
+    channelCount = Format.NO_VALUE;
+  }
+
+  /**
+   * Updates the listener head orientation. May be called on any thread. See
+   * {@code GvrAudioSurround.updateNativeOrientation}.
+   */
+  public synchronized void updateOrientation(float w, float x, float y, float z) {
+    this.w = w;
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    if (gvrAudioSurround != null) {
+      gvrAudioSurround.updateNativeOrientation(w, x, y, z);
+    }
+  }
+
+  @Override
+  public synchronized boolean configure(int sampleRateHz, int channelCount,
+      @C.Encoding int encoding) throws UnhandledFormatException {
+    if (encoding != C.ENCODING_PCM_16BIT) {
+      maybeReleaseGvrAudioSurround();
+      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+    }
+    if (this.sampleRateHz == sampleRateHz && this.channelCount == channelCount) {
+      return false;
+    }
+    this.sampleRateHz = sampleRateHz;
+    this.channelCount = channelCount;
+    maybeReleaseGvrAudioSurround();
+    int surroundFormat;
+    switch (channelCount) {
+      case 2:
+        surroundFormat = GvrAudioSurround.SurroundFormat.SURROUND_STEREO;
+        break;
+      case 4:
+        surroundFormat = GvrAudioSurround.SurroundFormat.FIRST_ORDER_AMBISONICS;
+        break;
+      case 6:
+        surroundFormat = GvrAudioSurround.SurroundFormat.SURROUND_FIVE_DOT_ONE;
+        break;
+      case 9:
+        surroundFormat = GvrAudioSurround.SurroundFormat.SECOND_ORDER_AMBISONICS;
+        break;
+      case 16:
+        surroundFormat = GvrAudioSurround.SurroundFormat.THIRD_ORDER_AMBISONICS;
+        break;
+      default:
+        throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+    }
+    gvrAudioSurround = new GvrAudioSurround(surroundFormat, sampleRateHz, channelCount,
+        FRAMES_PER_OUTPUT_BUFFER);
+    gvrAudioSurround.updateNativeOrientation(w, x, y, z);
+    if (buffer == null) {
+      buffer = ByteBuffer.allocateDirect(FRAMES_PER_OUTPUT_BUFFER * OUTPUT_FRAME_SIZE)
+          .order(ByteOrder.nativeOrder());
+    }
+    return true;
+  }
+
+  @Override
+  public boolean isActive() {
+    return gvrAudioSurround != null;
+  }
+
+  @Override
+  public int getOutputChannelCount() {
+    return OUTPUT_CHANNEL_COUNT;
+  }
+
+  @Override
+  public int getOutputEncoding() {
+    return C.ENCODING_PCM_16BIT;
+  }
+
+  @Override
+  public void queueInput(ByteBuffer input) {
+    int position = input.position();
+    int readBytes = gvrAudioSurround.addInput(input, position, input.limit() - position);
+    input.position(position + readBytes);
+  }
+
+  @Override
+  public void queueEndOfStream() {
+    inputEnded = true;
+    gvrAudioSurround.triggerProcessing();
+  }
+
+  @Override
+  public ByteBuffer getOutput() {
+    int writtenBytes = gvrAudioSurround.getOutput(buffer, 0, buffer.capacity());
+    buffer.position(0).limit(writtenBytes);
+    return buffer;
+  }
+
+  @Override
+  public boolean isEnded() {
+    return inputEnded && gvrAudioSurround.getAvailableOutputSize() == 0;
+  }
+
+  @Override
+  public void flush() {
+    gvrAudioSurround.flush();
+    inputEnded = false;
+  }
+
+  @Override
+  public synchronized void release() {
+    buffer = null;
+    maybeReleaseGvrAudioSurround();
+  }
+
+  private void maybeReleaseGvrAudioSurround() {
+    if (this.gvrAudioSurround != null) {
+      GvrAudioSurround gvrAudioSurround = this.gvrAudioSurround;
+      this.gvrAudioSurround = null;
+      gvrAudioSurround.release();
+    }
+  }
+
+}
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index 442f0f78dc..3a2daefb8f 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -12,42 +12,31 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 apply plugin: 'com.android.library'
-apply plugin: 'bintray-release'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
 
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
     lintOptions {
-        abortOnError false
+        // See: https://github.com/square/okio/issues/58
+        warning 'InvalidPackage'
     }
 }
 
 dependencies {
     compile project(':library')
-    compile('com.squareup.okhttp3:okhttp:3.4.1') {
+    compile('com.squareup.okhttp3:okhttp:3.6.0') {
         exclude group: 'org.json'
     }
 }
 
-publish {
-    artifactId = 'extension-okhttp'
-    description = 'An OkHttp extension for ExoPlayer.'
-    repoName = releaseRepoName
-    userOrg = releaseUserOrg
-    groupId = releaseGroupId
-    version = releaseVersion
-    website = releaseWebsite
+ext {
+    releaseArtifact = 'extension-okhttp'
+    releaseDescription = 'OkHttp extension for ExoPlayer.'
 }
+apply from: '../../publish.gradle'
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index 8577d33781..47850c0637 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -27,7 +27,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
@@ -51,7 +50,8 @@
   private final Predicate<String> contentTypePredicate;
   private final TransferListener<? super OkHttpDataSource> listener;
   private final CacheControl cacheControl;
-  private final HashMap<String, String> requestProperties;
+  private final RequestProperties defaultRequestProperties;
+  private final RequestProperties requestProperties;
 
   private DataSpec dataSpec;
   private Response response;
@@ -87,7 +87,7 @@ public OkHttpDataSource(Call.Factory callFactory, String userAgent,
    */
   public OkHttpDataSource(Call.Factory callFactory, String userAgent,
       Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener) {
-    this(callFactory, userAgent, contentTypePredicate, listener, null);
+    this(callFactory, userAgent, contentTypePredicate, listener, null, null);
   }
 
   /**
@@ -99,16 +99,19 @@ public OkHttpDataSource(Call.Factory callFactory, String userAgent,
    *     {@link #open(DataSpec)}.
    * @param listener An optional listener.
    * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
+   * @param defaultRequestProperties The optional default {@link RequestProperties} to be sent to
+   *    the server as HTTP headers on every request.
    */
   public OkHttpDataSource(Call.Factory callFactory, String userAgent,
       Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener,
-      CacheControl cacheControl) {
+      CacheControl cacheControl, RequestProperties defaultRequestProperties) {
     this.callFactory = Assertions.checkNotNull(callFactory);
     this.userAgent = Assertions.checkNotEmpty(userAgent);
     this.contentTypePredicate = contentTypePredicate;
     this.listener = listener;
     this.cacheControl = cacheControl;
-    this.requestProperties = new HashMap<>();
+    this.defaultRequestProperties = defaultRequestProperties;
+    this.requestProperties = new RequestProperties();
   }
 
   @Override
@@ -125,24 +128,18 @@ public Uri getUri() {
   public void setRequestProperty(String name, String value) {
     Assertions.checkNotNull(name);
     Assertions.checkNotNull(value);
-    synchronized (requestProperties) {
-      requestProperties.put(name, value);
-    }
+    requestProperties.set(name, value);
   }
 
   @Override
   public void clearRequestProperty(String name) {
     Assertions.checkNotNull(name);
-    synchronized (requestProperties) {
-      requestProperties.remove(name);
-    }
+    requestProperties.remove(name);
   }
 
   @Override
   public void clearAllRequestProperties() {
-    synchronized (requestProperties) {
-      requestProperties.clear();
-    }
+    requestProperties.clear();
   }
 
   @Override
@@ -261,18 +258,21 @@ protected final long bytesRemaining() {
   private Request makeRequest(DataSpec dataSpec) {
     long position = dataSpec.position;
     long length = dataSpec.length;
-    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+    boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
 
     HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
     Request.Builder builder = new Request.Builder().url(url);
     if (cacheControl != null) {
       builder.cacheControl(cacheControl);
     }
-    synchronized (requestProperties) {
-      for (Map.Entry<String, String> property : requestProperties.entrySet()) {
-        builder.addHeader(property.getKey(), property.getValue());
+    if (defaultRequestProperties != null) {
+      for (Map.Entry<String, String> property : defaultRequestProperties.getSnapshot().entrySet()) {
+        builder.header(property.getKey(), property.getValue());
       }
     }
+    for (Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {
+      builder.header(property.getKey(), property.getValue());
+    }
     if (!(position == 0 && length == C.LENGTH_UNSET)) {
       String rangeRequest = "bytes=" + position + "-";
       if (length != C.LENGTH_UNSET) {
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
index 33f204a6f3..5228065db1 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer2.ext.okhttp;
 
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.upstream.TransferListener;
 import okhttp3.CacheControl;
@@ -24,7 +26,7 @@
 /**
  * A {@link Factory} that produces {@link OkHttpDataSource}.
  */
-public final class OkHttpDataSourceFactory implements Factory {
+public final class OkHttpDataSourceFactory extends BaseFactory {
 
   private final Call.Factory callFactory;
   private final String userAgent;
@@ -58,8 +60,10 @@ public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
   }
 
   @Override
-  public OkHttpDataSource createDataSource() {
-    return new OkHttpDataSource(callFactory, userAgent, null, listener, cacheControl);
+  protected OkHttpDataSource createDataSourceInternal(
+      HttpDataSource.RequestProperties defaultRequestProperties) {
+    return new OkHttpDataSource(callFactory, userAgent, null, listener, cacheControl,
+        defaultRequestProperties);
   }
 
 }
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index 3bc06ddaf4..a6523788cb 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -18,19 +18,9 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
@@ -42,4 +32,3 @@ android {
 dependencies {
     compile project(':library')
 }
-
diff --git a/extensions/opus/src/main/proguard.cfg b/extensions/opus/proguard-rules.txt
similarity index 100%
rename from extensions/opus/src/main/proguard.cfg
rename to extensions/opus/proguard-rules.txt
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
index 2dd2697aab..564a41fc77 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
@@ -17,7 +17,7 @@
 
 import android.os.Handler;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.audio.AudioCapabilities;
+import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -40,39 +40,28 @@ public LibopusAudioRenderer() {
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
-   */
-  public LibopusAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener) {
-    super(eventHandler, eventListener);
-  }
-
-  /**
-   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
-   *     null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
-   *     default capabilities (no encoded audio passthrough support) should be assumed.
+   * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
   public LibopusAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioCapabilities audioCapabilities) {
-    super(eventHandler, eventListener, audioCapabilities);
+      AudioProcessor... audioProcessors) {
+    super(eventHandler, eventListener, audioProcessors);
   }
 
   /**
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
-   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
-   *     default capabilities (no encoded audio passthrough support) should be assumed.
+   * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
   public LibopusAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
-      AudioCapabilities audioCapabilities, DrmSessionManager<ExoMediaCrypto> drmSessionManager,
-      boolean playClearSamplesWithoutKeys) {
-    super(eventHandler, eventListener, audioCapabilities, drmSessionManager,
-        playClearSamplesWithoutKeys);
+      DrmSessionManager<ExoMediaCrypto> drmSessionManager, boolean playClearSamplesWithoutKeys,
+      AudioProcessor... audioProcessors) {
+    super(eventHandler, eventListener, null, drmSessionManager, playClearSamplesWithoutKeys,
+        audioProcessors);
   }
 
   @Override
-  public int supportsFormat(Format format) {
+  protected int supportsFormatInternal(Format format) {
     return OpusLibrary.isAvailable() && MimeTypes.AUDIO_OPUS.equalsIgnoreCase(format.sampleMimeType)
         ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
   }
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
index 6d0deb44ae..83e461d279 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
@@ -213,7 +213,7 @@ private native int opusDecode(long decoder, long timeUs, ByteBuffer inputBuffer,
       SimpleOutputBuffer outputBuffer, int sampleRate);
   private native int opusSecureDecode(long decoder, long timeUs, ByteBuffer inputBuffer,
       int inputSize, SimpleOutputBuffer outputBuffer, int sampleRate,
-      ExoMediaCrypto wvCrypto, int inputMode, byte[] key, byte[] iv,
+      ExoMediaCrypto mediaCrypto, int inputMode, byte[] key, byte[] iv,
       int numSubSamples, int[] numBytesOfClearData, int[] numBytesOfEncryptedData);
   private native void opusClose(long decoder);
   private native void opusReset(long decoder);
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 97c6b46280..90ded8fdc0 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -40,6 +40,18 @@ git clone https://chromium.googlesource.com/webm/libvpx libvpx && \
 git clone https://chromium.googlesource.com/libyuv/libyuv libyuv
 ```
 
+* Checkout the appropriate branches of libvpx and libyuv (the scripts and
+  makefiles bundled in this repo are known to work only at these versions of the
+  libraries - we will update this periodically as newer versions of
+  libvpx/libyuv are released):
+
+```
+cd "${VP9_EXT_PATH}/jni/libvpx" && \
+git checkout tags/v1.6.1 -b v1.6.1 && \
+cd "${VP9_EXT_PATH}/jni/libyuv" && \
+git checkout e2611a73
+```
+
 * Run a script that generates necessary configuration files for libvpx:
 
 ```
@@ -79,5 +91,7 @@ dependencies {
     `generate_libvpx_android_configs.sh`
   * Clean and re-build the project.
 * If you want to use your own version of libvpx or libyuv, place it in
-  `${VP9_EXT_PATH}/jni/libvpx` or `${VP9_EXT_PATH}/jni/libyuv` respectively.
+  `${VP9_EXT_PATH}/jni/libvpx` or `${VP9_EXT_PATH}/jni/libyuv` respectively. But
+  please note that `generate_libvpx_android_configs.sh` and the makefiles need
+  to be modified to work with arbitrary versions of libvpx and libyuv.
 
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index 3bc06ddaf4..91d80f4970 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -18,19 +18,9 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
-    }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     sourceSets.main {
diff --git a/extensions/vp9/src/main/proguard.cfg b/extensions/vp9/proguard-rules.txt
similarity index 100%
rename from extensions/vp9/src/main/proguard.cfg
rename to extensions/vp9/proguard-rules.txt
diff --git a/extensions/vp9/src/androidTest/assets/roadtrip-vp92-10bit.webm b/extensions/vp9/src/androidTest/assets/roadtrip-vp92-10bit.webm
new file mode 100644
index 0000000000..b3bd1b9d74
Binary files /dev/null and b/extensions/vp9/src/androidTest/assets/roadtrip-vp92-10bit.webm differ
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index b1ddf2368c..f888554e22 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -19,6 +19,7 @@
 import android.net.Uri;
 import android.os.Looper;
 import android.test.InstrumentationTestCase;
+import android.util.Log;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
@@ -38,8 +39,11 @@
 
   private static final String BEAR_URI = "asset:///bear-vp9.webm";
   private static final String BEAR_ODD_DIMENSIONS_URI = "asset:///bear-vp9-odd-dimensions.webm";
+  private static final String ROADTRIP_10BIT_URI = "asset:///roadtrip-vp92-10bit.webm";
   private static final String INVALID_BITSTREAM_URI = "asset:///invalid-bitstream.webm";
 
+  private static final String TAG = "VpxPlaybackTest";
+
   public void testBasicPlayback() throws ExoPlaybackException {
     playUri(BEAR_URI);
   }
@@ -48,6 +52,15 @@ public void testOddDimensionsPlayback() throws ExoPlaybackException {
     playUri(BEAR_ODD_DIMENSIONS_URI);
   }
 
+  public void test10BitProfile2Playback() throws ExoPlaybackException {
+    if (VpxLibrary.isHighBitDepthSupported()) {
+      Log.d(TAG, "High Bit Depth supported.");
+      playUri(ROADTRIP_10BIT_URI);
+      return;
+    }
+    Log.d(TAG, "High Bit Depth not supported.");
+  }
+
   public void testInvalidBitstream() {
     try {
       playUri(INVALID_BITSTREAM_URI);
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index e4cc2ae3ce..d0417bc37e 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -65,6 +65,7 @@
   private final boolean playClearSamplesWithoutKeys;
   private final EventDispatcher eventDispatcher;
   private final FormatHolder formatHolder;
+  private final DecoderInputBuffer flagsOnlyBuffer;
   private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
 
   private DecoderCounters decoderCounters;
@@ -149,6 +150,7 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
     joiningDeadlineMs = -1;
     clearLastReportedVideoSize();
     formatHolder = new FormatHolder();
+    flagsOnlyBuffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     outputMode = VpxDecoder.OUTPUT_MODE_NONE;
   }
@@ -165,10 +167,22 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       return;
     }
 
-    // Try and read a format if we don't have one already.
-    if (format == null && !readFormat()) {
-      // We can't make progress without one.
-      return;
+    if (format == null) {
+      // We don't have a format yet, so try and read one.
+      flagsOnlyBuffer.clear();
+      int result = readSource(formatHolder, flagsOnlyBuffer, true);
+      if (result == C.RESULT_FORMAT_READ) {
+        onInputFormatChanged(formatHolder.format);
+      } else if (result == C.RESULT_BUFFER_READ) {
+        // End of stream read having not read a format.
+        Assertions.checkState(flagsOnlyBuffer.isEndOfStream());
+        inputStreamEnded = true;
+        outputStreamEnded = true;
+        return;
+      } else {
+        // We still don't have a format and can't make progress without one.
+        return;
+      }
     }
 
     if (isRendererAvailable()) {
@@ -327,7 +341,7 @@ private boolean feedInputBuffer() throws VpxDecoderException, ExoPlaybackExcepti
       // We've already read an encrypted sample into buffer, and are waiting for keys.
       result = C.RESULT_BUFFER_READ;
     } else {
-      result = readSource(formatHolder, inputBuffer);
+      result = readSource(formatHolder, inputBuffer, false);
     }
 
     if (result == C.RESULT_NOTHING_READ) {
@@ -485,15 +499,6 @@ private void releaseDecoder() {
     }
   }
 
-  private boolean readFormat() throws ExoPlaybackException {
-    int result = readSource(formatHolder, null);
-    if (result == C.RESULT_FORMAT_READ) {
-      onInputFormatChanged(formatHolder.format);
-      return true;
-    }
-    return false;
-  }
-
   private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
     Format oldFormat = format;
     format = newFormat;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index 0d7547d125..73ec7c2f96 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -141,7 +141,7 @@ public void release() {
   private native long vpxClose(long context);
   private native long vpxDecode(long context, ByteBuffer encoded, int length);
   private native long vpxSecureDecode(long context, ByteBuffer encoded, int length,
-      ExoMediaCrypto wvCrypto, int inputMode, byte[] key, byte[] iv,
+      ExoMediaCrypto mediaCrypto, int inputMode, byte[] key, byte[] iv,
       int numSubSamples, int[] numBytesOfClearData, int[] numBytesOfEncryptedData);
   private native int vpxGetFrame(long context, VpxOutputBuffer outputBuffer);
   private native int vpxGetErrorCode(long context);
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
index 2caa33c17c..24331127ec 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxLibrary.java
@@ -57,6 +57,16 @@ public static String getBuildConfig() {
     return isAvailable() ? vpxGetBuildConfig() : null;
   }
 
+  /**
+   * Returns true if the underlying libvpx library supports high bit depth.
+   */
+  public static boolean isHighBitDepthSupported() {
+    String config = getBuildConfig();
+    int indexHbd = config != null
+        ? config.indexOf("--enable-vp9-highbitdepth") : -1;
+    return indexHbd >= 0;
+  }
+
   private static native String vpxGetVersion();
   private static native String vpxGetBuildConfig();
   public static native boolean vpxIsSecureDecodeSupported();
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
index c76d0eda03..db3cf49b0c 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxOutputBuffer.java
@@ -26,6 +26,7 @@
   public static final int COLORSPACE_UNKNOWN = 0;
   public static final int COLORSPACE_BT601 = 1;
   public static final int COLORSPACE_BT709 = 2;
+  public static final int COLORSPACE_BT2020 = 3;
 
   private final VpxDecoder owner;
 
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
index d108ae8b4f..837539593e 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxRenderer.java
@@ -42,6 +42,12 @@
     1.793f, -0.533f, 0.0f,
   };
 
+  private static final float[] kColorConversion2020 = {
+    1.168f, 1.168f, 1.168f,
+    0.0f, -0.188f, 2.148f,
+    1.683f, -0.652f, 0.0f,
+  };
+
   private static final String VERTEX_SHADER =
       "varying vec2 interp_tc;\n"
       + "attribute vec4 in_pos;\n"
@@ -59,12 +65,13 @@
       + "uniform sampler2D v_tex;\n"
       + "uniform mat3 mColorConversion;\n"
       + "void main() {\n"
-      + "  vec3 yuv;"
+      + "  vec3 yuv;\n"
       + "  yuv.x = texture2D(y_tex, interp_tc).r - 0.0625;\n"
       + "  yuv.y = texture2D(u_tex, interp_tc).r - 0.5;\n"
       + "  yuv.z = texture2D(v_tex, interp_tc).r - 0.5;\n"
-      + "  gl_FragColor = vec4(mColorConversion * yuv, 1.0);"
+      + "  gl_FragColor = vec4(mColorConversion * yuv, 1.0);\n"
       + "}\n";
+
   private static final FloatBuffer TEXTURE_VERTICES = nativeFloatBuffer(
       -1.0f, 1.0f,
       -1.0f, -1.0f,
@@ -156,8 +163,18 @@ public void onDrawFrame(GL10 unused) {
     }
     VpxOutputBuffer outputBuffer = renderedOutputBuffer;
     // Set color matrix. Assume BT709 if the color space is unknown.
-    float[] colorConversion = outputBuffer.colorspace == VpxOutputBuffer.COLORSPACE_BT601
-        ? kColorConversion601 : kColorConversion709;
+    float[] colorConversion = kColorConversion709;
+    switch (outputBuffer.colorspace) {
+      case VpxOutputBuffer.COLORSPACE_BT601:
+        colorConversion = kColorConversion601;
+        break;
+      case VpxOutputBuffer.COLORSPACE_BT2020:
+        colorConversion = kColorConversion2020;
+        break;
+      case VpxOutputBuffer.COLORSPACE_BT709:
+      default:
+        break; // Do nothing
+    }
     GLES20.glUniformMatrix3fv(colorMatrixLocation, 1, false, colorConversion, 0);
 
     for (int i = 0; i < 3; i++) {
diff --git a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
index f0fb2761db..566396e0bf 100755
--- a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
+++ b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
@@ -40,7 +40,7 @@ config[0]+=" --enable-neon-asm"
 
 arch[1]="armeabi"
 config[1]="--target=armv7-android-gcc --sdk-path=$ndk --disable-neon"
-config[1]+=" --disable-neon-asm --disable-media"
+config[1]+=" --disable-neon-asm"
 
 arch[2]="mips"
 config[2]="--force-target=mips32-android-gcc --sdk-path=$ndk"
@@ -78,12 +78,12 @@ convert_asm() {
   for i in $(seq 0 ${limit}); do
     while read file; do
       case "${file}" in
-        *.asm.s)
+        *.asm.[sS])
           # Some files may already have been processed (there are duplicated
           # .asm.s files for vp8 in the armeabi/armeabi-v7a configurations).
           file="libvpx/${file}"
           if [[ ! -e "${file}" ]]; then
-            asm_file="${file%.s}"
+            asm_file="${file%.[sS]}"
             cat "${asm_file}" | libvpx/build/make/ads2gas.pl > "${file}"
             remove_trailing_whitespace "${file}"
             rm "${asm_file}"
@@ -105,7 +105,11 @@ for i in $(seq 0 ${limit}); do
   echo "configure ${config[${i}]} ${common_params}"
   ../../libvpx/configure ${config[${i}]} ${common_params}
   rm -f libvpx_srcs.txt
-  make libvpx_srcs.txt
+  for f in ${allowed_files}; do
+    # the build system supports multiple different configurations. avoid
+    # failing out when, for example, vp8_rtcd.h is not part of a configuration
+    make "${f}" || true
+  done
 
   # remove files that aren't needed
   rm -rf !(${allowed_files// /|})
diff --git a/extensions/vp9/src/main/jni/libvpx.mk b/extensions/vp9/src/main/jni/libvpx.mk
index 6cc706ffa8..887de56218 100644
--- a/extensions/vp9/src/main/jni/libvpx.mk
+++ b/extensions/vp9/src/main/jni/libvpx.mk
@@ -35,16 +35,22 @@ LOCAL_SRC_FILES += $(addprefix libvpx/, $(filter-out vpx_config.c, \
                      $(filter %.c, $(libvpx_codec_srcs))))
 
 # include assembly files if they exist
-# "%.asm.s" covers neon assembly and "%.asm" covers x86 assembly
+# "%.asm.[sS]" covers neon assembly and "%.asm" covers x86 assembly
 LOCAL_SRC_FILES += $(addprefix libvpx/, \
                      $(filter %.asm.s %.asm, $(libvpx_codec_srcs)))
+LOCAL_SRC_FILES += $(addprefix libvpx/, \
+                     $(filter %.asm.S %.asm, $(libvpx_codec_srcs)))
 
 ifneq ($(findstring armeabi-v7a, $(TARGET_ARCH_ABI)),)
-# append .neon to *_neon.c and *.s
+# append .neon to *_neon.c and *.[sS]
 LOCAL_SRC_FILES := $(subst _neon.c,_neon.c.neon,$(LOCAL_SRC_FILES))
 LOCAL_SRC_FILES := $(subst .s,.s.neon,$(LOCAL_SRC_FILES))
+LOCAL_SRC_FILES := $(subst .S,.S.neon,$(LOCAL_SRC_FILES))
 endif
 
+# remove duplicates
+LOCAL_SRC_FILES := $(sort $(LOCAL_SRC_FILES))
+
 LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/libvpx \
                            $(LOCAL_PATH)/libvpx/vpx
 
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 137ff9ac21..c091091389 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -74,8 +74,11 @@ DECODER_FUNC(jlong, vpxInit) {
   vpx_codec_dec_cfg_t cfg = {0, 0, 0};
   cfg.threads = android_getCpuCount();
   errorCode = 0;
-  if (vpx_codec_dec_init(context, &vpx_codec_vp9_dx_algo, &cfg, 0)) {
-    LOGE("ERROR: Fail to initialize libvpx decoder.");
+  vpx_codec_err_t err = vpx_codec_dec_init(context, &vpx_codec_vp9_dx_algo,
+                                           &cfg, 0);
+  if (err) {
+    LOGE("ERROR: Failed to initialize libvpx decoder, error = %d.", err);
+    errorCode = err;
     return 0;
   }
 
@@ -160,6 +163,7 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     const int kColorspaceUnknown = 0;
     const int kColorspaceBT601 = 1;
     const int kColorspaceBT709 = 2;
+    const int kColorspaceBT2020 = 3;
 
     int colorspace = kColorspaceUnknown;
     switch (img->cs) {
@@ -169,6 +173,9 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
       case VPX_CS_BT_709:
         colorspace = kColorspaceBT709;
         break;
+    case VPX_CS_BT_2020:
+        colorspace = kColorspaceBT2020;
+        break;
       default:
         break;
     }
@@ -186,14 +193,55 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     jbyte* const data =
         reinterpret_cast<jbyte*>(env->GetDirectBufferAddress(dataObject));
 
-    // TODO: This copy can be eliminated by using external frame buffers. NOLINT
-    // This is insignificant for smaller videos but takes ~1.5ms for 1080p
-    // clips. So this should eventually be gotten rid of.
-    const uint64_t y_length = img->stride[VPX_PLANE_Y] * img->d_h;
-    const uint64_t uv_length = img->stride[VPX_PLANE_U] * ((img->d_h + 1) / 2);
-    memcpy(data, img->planes[VPX_PLANE_Y], y_length);
-    memcpy(data + y_length, img->planes[VPX_PLANE_U], uv_length);
-    memcpy(data + y_length + uv_length, img->planes[VPX_PLANE_V], uv_length);
+    const int32_t uvHeight = (img->d_h + 1) / 2;
+    const uint64_t yLength = img->stride[VPX_PLANE_Y] * img->d_h;
+    const uint64_t uvLength = img->stride[VPX_PLANE_U] * uvHeight;
+    int sample = 0;
+    if (img->fmt == VPX_IMG_FMT_I42016) {  // HBD planar 420.
+      // Note: The stride for BT2020 is twice of what we use so this is wasting
+      // memory. The long term goal however is to upload half-float/short so
+      // it's not important to optimize the stride at this time.
+      // Y
+      for (int y = 0; y < img->d_h; y++) {
+        const uint16_t* srcBase = reinterpret_cast<uint16_t*>(
+            img->planes[VPX_PLANE_Y] + img->stride[VPX_PLANE_Y] * y);
+        int8_t* destBase = data + img->stride[VPX_PLANE_Y] * y;
+        for (int x = 0; x < img->d_w; x++) {
+          // Lightweight dither. Carryover the remainder of each 10->8 bit
+          // conversion to the next pixel.
+          sample += *srcBase++;
+          *destBase++ = sample >> 2;
+          sample = sample & 3;  // Remainder.
+        }
+      }
+      // UV
+      const int32_t uvWidth = (img->d_w + 1) / 2;
+      for (int y = 0; y < uvHeight; y++) {
+        const uint16_t* srcUBase = reinterpret_cast<uint16_t*>(
+            img->planes[VPX_PLANE_U] + img->stride[VPX_PLANE_U] * y);
+        const uint16_t* srcVBase = reinterpret_cast<uint16_t*>(
+            img->planes[VPX_PLANE_V] + img->stride[VPX_PLANE_V] * y);
+        int8_t* destUBase = data + yLength + img->stride[VPX_PLANE_U] * y;
+        int8_t* destVBase = data + yLength + uvLength
+            + img->stride[VPX_PLANE_V] * y;
+        for (int x = 0; x < uvWidth; x++) {
+          // Lightweight dither. Carryover the remainder of each 10->8 bit
+          // conversion to the next pixel.
+          sample += *srcUBase++;
+          *destUBase++ = sample >> 2;
+          sample = (*srcVBase++) + (sample & 3);  // srcV + previousRemainder.
+          *destVBase++ = sample >> 2;
+          sample = sample & 3;  // Remainder.
+        }
+      }
+    } else {
+      // TODO: This copy can be eliminated by using external frame buffers. This
+      // is insignificant for smaller videos but takes ~1.5ms for 1080p clips.
+      // So this should eventually be gotten rid of.
+      memcpy(data, img->planes[VPX_PLANE_Y], yLength);
+      memcpy(data + yLength, img->planes[VPX_PLANE_U], uvLength);
+      memcpy(data + yLength + uvLength, img->planes[VPX_PLANE_V], uvLength);
+    }
   }
   return 0;
 }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index c5e71526be..8c0a9b91f6 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,4 +1,4 @@
-#Mon Mar 06 13:32:50 CET 2017
+#Mon Mar 13 11:17:14 GMT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
diff --git a/library/build.gradle b/library/build.gradle
index 5ec947d0eb..abca404cfa 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -1,5 +1,3 @@
-import com.android.builder.core.BuilderConstants
-
 // Copyright (C) 2016 The Android Open Source Project
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
@@ -13,28 +11,21 @@ import com.android.builder.core.BuilderConstants
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
+import com.android.builder.core.BuilderConstants
+
 apply plugin: 'com.android.library'
-apply plugin: 'bintray-release'
 
 android {
     compileSdkVersion project.ext.compileSdkVersion
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        // Important: ExoPlayerLib specifies a minSdkVersion of 9 because
-        // various components provided by the library may be of use on older
-        // devices. However, please note that the core video playback
-        // functionality provided by the library requires API level 16 or
-        // greater.
-        minSdkVersion 9
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
         // Re-enable test coverage when the following issue is fixed:
         // https://code.google.com/p/android/issues/detail?id=226070
         // debug {
@@ -42,10 +33,6 @@ android {
         // }
     }
 
-    lintOptions {
-        abortOnError false
-    }
-
     sourceSets {
         androidTest {
             java.srcDirs += "../testutils/src/main/java/"
@@ -54,10 +41,10 @@ android {
 }
 
 dependencies {
+    compile 'com.android.support:support-annotations:25.2.0'
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
     androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'
     androidTestCompile 'org.mockito:mockito-core:1.9.5'
-    compile 'com.android.support:support-annotations:25.0.1'
 }
 
 android.libraryVariants.all { variant ->
@@ -93,12 +80,8 @@ android.libraryVariants.all { variant ->
     }
 }
 
-publish {
-    artifactId = 'exoplayer'
-    description = 'The ExoPlayer library.'
-    repoName = releaseRepoName
-    userOrg = releaseUserOrg
-    groupId = releaseGroupId
-    version = releaseVersion
-    website = releaseWebsite
+ext {
+    releaseArtifact = 'exoplayer'
+    releaseDescription = 'The ExoPlayer library.'
 }
+apply from: '../publish.gradle'
diff --git a/library/proguard-rules.txt b/library/proguard-rules.txt
new file mode 100644
index 0000000000..75f2d095be
--- /dev/null
+++ b/library/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Accessed via reflection in SubtitleDecoderFactory.DEFAULT
+-keepclassmembers class com.google.android.exoplayer2.text.cea.Cea608Decoder {
+    public <init>(java.lang.String, int);
+}
+-keepclassmembers class com.google.android.exoplayer2.text.cea.Cea708Decoder {
+    public <init>(int);
+}
diff --git a/library/src/androidTest/assets/mp4/sample_fragmented_sei.mp4 b/library/src/androidTest/assets/mp4/sample_fragmented_sei.mp4
new file mode 100644
index 0000000000..16907fdd98
Binary files /dev/null and b/library/src/androidTest/assets/mp4/sample_fragmented_sei.mp4 differ
diff --git a/library/src/androidTest/assets/mp4/sample_fragmented_sei.mp4.0.dump b/library/src/androidTest/assets/mp4/sample_fragmented_sei.mp4.0.dump
new file mode 100644
index 0000000000..9d3755b23b
--- /dev/null
+++ b/library/src/androidTest/assets/mp4/sample_fragmented_sei.mp4.0.dump
@@ -0,0 +1,382 @@
+seekMap:
+  isSeekable = false
+  duration = UNSET TIME
+  getPosition(0) = 0
+numberOfTracks = 3
+track 0:
+  format:
+    bitrate = -1
+    id = 1
+    containerMimeType = null
+    sampleMimeType = video/avc
+    maxInputSize = -1
+    width = 1080
+    height = 720
+    frameRate = -1.0
+    rotationDegrees = 0
+    pixelWidthHeightRatio = 1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = -1
+    encoderPadding = -1
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+      data = length 29, hash 4746B5D9
+      data = length 10, hash 7A0D0F2B
+  sample count = 30
+  sample 0:
+    time = 66000
+    flags = 1
+    data = length 38070, hash B58E1AEE
+  sample 1:
+    time = 199000
+    flags = 0
+    data = length 8340, hash 8AC449FF
+  sample 2:
+    time = 132000
+    flags = 0
+    data = length 1295, hash C0DA5090
+  sample 3:
+    time = 100000
+    flags = 0
+    data = length 469, hash D6E0A200
+  sample 4:
+    time = 166000
+    flags = 0
+    data = length 564, hash E5F56C5B
+  sample 5:
+    time = 332000
+    flags = 0
+    data = length 6075, hash 8756E49E
+  sample 6:
+    time = 266000
+    flags = 0
+    data = length 847, hash DCC2B618
+  sample 7:
+    time = 233000
+    flags = 0
+    data = length 455, hash B9CCE047
+  sample 8:
+    time = 299000
+    flags = 0
+    data = length 467, hash 69806D94
+  sample 9:
+    time = 466000
+    flags = 0
+    data = length 4549, hash 3944F501
+  sample 10:
+    time = 399000
+    flags = 0
+    data = length 1087, hash 491BF106
+  sample 11:
+    time = 367000
+    flags = 0
+    data = length 380, hash 5FED016A
+  sample 12:
+    time = 433000
+    flags = 0
+    data = length 455, hash 8A0610
+  sample 13:
+    time = 599000
+    flags = 0
+    data = length 5190, hash B9031D8
+  sample 14:
+    time = 533000
+    flags = 0
+    data = length 1071, hash 684E7DC8
+  sample 15:
+    time = 500000
+    flags = 0
+    data = length 653, hash 8494F326
+  sample 16:
+    time = 566000
+    flags = 0
+    data = length 485, hash 2CCC85F4
+  sample 17:
+    time = 733000
+    flags = 0
+    data = length 4884, hash D16B6A96
+  sample 18:
+    time = 666000
+    flags = 0
+    data = length 997, hash 164FF210
+  sample 19:
+    time = 633000
+    flags = 0
+    data = length 640, hash F664125B
+  sample 20:
+    time = 700000
+    flags = 0
+    data = length 491, hash B5930C7C
+  sample 21:
+    time = 866000
+    flags = 0
+    data = length 2989, hash 92CF4FCF
+  sample 22:
+    time = 800000
+    flags = 0
+    data = length 838, hash 294A3451
+  sample 23:
+    time = 767000
+    flags = 0
+    data = length 544, hash FCCE2DE6
+  sample 24:
+    time = 833000
+    flags = 0
+    data = length 329, hash A654FFA1
+  sample 25:
+    time = 1000000
+    flags = 0
+    data = length 1517, hash 5F7EBF8B
+  sample 26:
+    time = 933000
+    flags = 0
+    data = length 803, hash 7A5C4C1D
+  sample 27:
+    time = 900000
+    flags = 0
+    data = length 415, hash B31BBC3B
+  sample 28:
+    time = 967000
+    flags = 0
+    data = length 415, hash 850DFEA3
+  sample 29:
+    time = 1033000
+    flags = 0
+    data = length 619, hash AB5E56CA
+track 1:
+  format:
+    bitrate = -1
+    id = 2
+    containerMimeType = null
+    sampleMimeType = audio/mp4a-latm
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = -1
+    pixelWidthHeightRatio = -1.0
+    channelCount = 1
+    sampleRate = 44100
+    pcmEncoding = -1
+    encoderDelay = -1
+    encoderPadding = -1
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = und
+    drmInitData = -
+    initializationData:
+      data = length 5, hash 2B7623A
+  sample count = 46
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 18, hash 96519432
+  sample 1:
+    time = 23000
+    flags = 1
+    data = length 4, hash EE9DF
+  sample 2:
+    time = 46000
+    flags = 1
+    data = length 4, hash EEDBF
+  sample 3:
+    time = 69000
+    flags = 1
+    data = length 157, hash E2F078F4
+  sample 4:
+    time = 92000
+    flags = 1
+    data = length 371, hash B9471F94
+  sample 5:
+    time = 116000
+    flags = 1
+    data = length 373, hash 2AB265CB
+  sample 6:
+    time = 139000
+    flags = 1
+    data = length 402, hash 1295477C
+  sample 7:
+    time = 162000
+    flags = 1
+    data = length 455, hash 2D8146C8
+  sample 8:
+    time = 185000
+    flags = 1
+    data = length 434, hash F2C5D287
+  sample 9:
+    time = 208000
+    flags = 1
+    data = length 450, hash 84143FCD
+  sample 10:
+    time = 232000
+    flags = 1
+    data = length 429, hash EF769D50
+  sample 11:
+    time = 255000
+    flags = 1
+    data = length 450, hash EC3DE692
+  sample 12:
+    time = 278000
+    flags = 1
+    data = length 447, hash 3E519E13
+  sample 13:
+    time = 301000
+    flags = 1
+    data = length 457, hash 1E4F23A0
+  sample 14:
+    time = 325000
+    flags = 1
+    data = length 447, hash A439EA97
+  sample 15:
+    time = 348000
+    flags = 1
+    data = length 456, hash 1E9034C6
+  sample 16:
+    time = 371000
+    flags = 1
+    data = length 398, hash 99DB7345
+  sample 17:
+    time = 394000
+    flags = 1
+    data = length 474, hash 3F05F10A
+  sample 18:
+    time = 417000
+    flags = 1
+    data = length 416, hash C105EE09
+  sample 19:
+    time = 441000
+    flags = 1
+    data = length 454, hash 5FDBE458
+  sample 20:
+    time = 464000
+    flags = 1
+    data = length 438, hash 41A93AC3
+  sample 21:
+    time = 487000
+    flags = 1
+    data = length 443, hash 10FDA652
+  sample 22:
+    time = 510000
+    flags = 1
+    data = length 412, hash 1F791E25
+  sample 23:
+    time = 534000
+    flags = 1
+    data = length 482, hash A6D983D
+  sample 24:
+    time = 557000
+    flags = 1
+    data = length 386, hash BED7392F
+  sample 25:
+    time = 580000
+    flags = 1
+    data = length 463, hash 5309F8C9
+  sample 26:
+    time = 603000
+    flags = 1
+    data = length 394, hash 21C7321F
+  sample 27:
+    time = 626000
+    flags = 1
+    data = length 489, hash 71B4730D
+  sample 28:
+    time = 650000
+    flags = 1
+    data = length 403, hash D9C6DE89
+  sample 29:
+    time = 673000
+    flags = 1
+    data = length 447, hash 9B14B73B
+  sample 30:
+    time = 696000
+    flags = 1
+    data = length 439, hash 4760D35B
+  sample 31:
+    time = 719000
+    flags = 1
+    data = length 463, hash 1601F88D
+  sample 32:
+    time = 743000
+    flags = 1
+    data = length 423, hash D4AE6773
+  sample 33:
+    time = 766000
+    flags = 1
+    data = length 497, hash A3C674D3
+  sample 34:
+    time = 789000
+    flags = 1
+    data = length 419, hash D3734A1F
+  sample 35:
+    time = 812000
+    flags = 1
+    data = length 474, hash DFB41F9
+  sample 36:
+    time = 835000
+    flags = 1
+    data = length 413, hash 53E7CB9F
+  sample 37:
+    time = 859000
+    flags = 1
+    data = length 445, hash D15B0E39
+  sample 38:
+    time = 882000
+    flags = 1
+    data = length 453, hash 77ED81E4
+  sample 39:
+    time = 905000
+    flags = 1
+    data = length 545, hash 3321AEB9
+  sample 40:
+    time = 928000
+    flags = 1
+    data = length 317, hash F557D0E
+  sample 41:
+    time = 952000
+    flags = 1
+    data = length 537, hash ED58CF7B
+  sample 42:
+    time = 975000
+    flags = 1
+    data = length 458, hash 51CDAA10
+  sample 43:
+    time = 998000
+    flags = 1
+    data = length 465, hash CBA1EFD7
+  sample 44:
+    time = 1021000
+    flags = 1
+    data = length 446, hash D6735B8A
+  sample 45:
+    time = 1044000
+    flags = 1
+    data = length 10, hash A453EEBE
+track 3:
+  format:
+    bitrate = -1
+    id = null
+    containerMimeType = null
+    sampleMimeType = application/cea-608
+    maxInputSize = -1
+    width = -1
+    height = -1
+    frameRate = -1.0
+    rotationDegrees = -1
+    pixelWidthHeightRatio = -1.0
+    channelCount = -1
+    sampleRate = -1
+    pcmEncoding = -1
+    encoderDelay = -1
+    encoderPadding = -1
+    subsampleOffsetUs = 9223372036854775807
+    selectionFlags = 0
+    language = null
+    drmInitData = -
+    initializationData:
+  sample count = 0
+tracksEnded = true
diff --git a/library/src/androidTest/assets/mp4/sample_fragmented_zero_size_atom.mp4 b/library/src/androidTest/assets/mp4/sample_fragmented_zero_size_atom.mp4
new file mode 100644
index 0000000000..3d3c63786e
Binary files /dev/null and b/library/src/androidTest/assets/mp4/sample_fragmented_zero_size_atom.mp4 differ
diff --git a/library/src/androidTest/assets/ts/sample.ac3.0.dump b/library/src/androidTest/assets/ts/sample.ac3.0.dump
index c5f241950b..1b6c77efb6 100644
--- a/library/src/androidTest/assets/ts/sample.ac3.0.dump
+++ b/library/src/androidTest/assets/ts/sample.ac3.0.dump
@@ -6,7 +6,7 @@ numberOfTracks = 1
 track 0:
   format:
     bitrate = -1
-    id = null
+    id = 0
     containerMimeType = null
     sampleMimeType = audio/ac3
     maxInputSize = -1
diff --git a/library/src/androidTest/assets/ts/sample.adts.0.dump b/library/src/androidTest/assets/ts/sample.adts.0.dump
index 3325abcfeb..0a7427d3f1 100644
--- a/library/src/androidTest/assets/ts/sample.adts.0.dump
+++ b/library/src/androidTest/assets/ts/sample.adts.0.dump
@@ -6,7 +6,7 @@ numberOfTracks = 2
 track 0:
   format:
     bitrate = -1
-    id = null
+    id = 0
     containerMimeType = null
     sampleMimeType = audio/mp4a-latm
     maxInputSize = -1
@@ -606,7 +606,7 @@ track 0:
 track 1:
   format:
     bitrate = -1
-    id = null
+    id = 1
     containerMimeType = null
     sampleMimeType = application/id3
     maxInputSize = -1
diff --git a/library/src/androidTest/assets/ts/sample.ps.0.dump b/library/src/androidTest/assets/ts/sample.ps.0.dump
index 48127ce1c6..3b44fb6fb9 100644
--- a/library/src/androidTest/assets/ts/sample.ps.0.dump
+++ b/library/src/androidTest/assets/ts/sample.ps.0.dump
@@ -6,7 +6,7 @@ numberOfTracks = 2
 track 192:
   format:
     bitrate = -1
-    id = null
+    id = 192
     containerMimeType = null
     sampleMimeType = audio/mpeg-L2
     maxInputSize = 4096
@@ -45,7 +45,7 @@ track 192:
 track 224:
   format:
     bitrate = -1
-    id = null
+    id = 224
     containerMimeType = null
     sampleMimeType = video/mpeg2
     maxInputSize = -1
diff --git a/library/src/androidTest/assets/ts/sample.ts.0.dump b/library/src/androidTest/assets/ts/sample.ts.0.dump
index 8b0da7bd02..26c6665aaa 100644
--- a/library/src/androidTest/assets/ts/sample.ts.0.dump
+++ b/library/src/androidTest/assets/ts/sample.ts.0.dump
@@ -6,7 +6,7 @@ numberOfTracks = 2
 track 256:
   format:
     bitrate = -1
-    id = null
+    id = 1/256
     containerMimeType = null
     sampleMimeType = video/mpeg2
     maxInputSize = -1
@@ -38,7 +38,7 @@ track 256:
 track 257:
   format:
     bitrate = -1
-    id = null
+    id = 1/257
     containerMimeType = null
     sampleMimeType = audio/mpeg-L2
     maxInputSize = 4096
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
index be18d64195..93c0a7dc11 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -21,7 +21,6 @@
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SampleStream;
-import com.google.android.exoplayer2.source.SinglePeriodTimeline;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
@@ -29,8 +28,10 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
@@ -48,12 +49,112 @@
    */
   private static final int TIMEOUT_MS = 10000;
 
-  public void testPlayToEnd() throws Exception {
+  private static final Format TEST_VIDEO_FORMAT = Format.createVideoSampleFormat(null,
+      MimeTypes.VIDEO_H264, null, Format.NO_VALUE, Format.NO_VALUE, 1280, 720, Format.NO_VALUE,
+      null, null);
+  private static final Format TEST_AUDIO_FORMAT =  Format.createAudioSampleFormat(null,
+      MimeTypes.AUDIO_AAC, null, Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
+
+  /**
+   * Tests playback of a source that exposes an empty timeline. Playback is expected to end without
+   * error.
+   */
+  public void testPlayEmptyTimeline() throws Exception {
     PlayerWrapper playerWrapper = new PlayerWrapper();
-    Format format = Format.createVideoSampleFormat(null, MimeTypes.VIDEO_H264, null,
-        Format.NO_VALUE, Format.NO_VALUE, 1280, 720, Format.NO_VALUE, null, null);
-    playerWrapper.setup(new SinglePeriodTimeline(0, false), new Object(), format);
-    playerWrapper.blockUntilEndedOrError(TIMEOUT_MS);
+    Timeline timeline = Timeline.EMPTY;
+    MediaSource mediaSource = new FakeMediaSource(timeline, null);
+    FakeRenderer renderer = new FakeRenderer(null);
+    playerWrapper.setup(mediaSource, renderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(0, playerWrapper.positionDiscontinuityCount);
+    assertEquals(0, renderer.formatReadCount);
+    assertEquals(0, renderer.bufferReadCount);
+    assertFalse(renderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertNull(playerWrapper.manifest);
+  }
+
+  /**
+   * Tests playback of a source that exposes a single period.
+   */
+  public void testPlaySinglePeriodTimeline() throws Exception {
+    PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 0));
+    Object manifest = new Object();
+    MediaSource mediaSource = new FakeMediaSource(timeline, manifest, TEST_VIDEO_FORMAT);
+    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
+    playerWrapper.setup(mediaSource, renderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(0, playerWrapper.positionDiscontinuityCount);
+    assertEquals(1, renderer.formatReadCount);
+    assertEquals(1, renderer.bufferReadCount);
+    assertTrue(renderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertEquals(manifest, playerWrapper.manifest);
+    assertEquals(new TrackGroupArray(new TrackGroup(TEST_VIDEO_FORMAT)), playerWrapper.trackGroups);
+  }
+
+  /**
+   * Tests playback of a source that exposes three periods.
+   */
+  public void testPlayMultiPeriodTimeline() throws Exception {
+    PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = new FakeTimeline(
+        new TimelineWindowDefinition(false, false, 0),
+        new TimelineWindowDefinition(false, false, 0),
+        new TimelineWindowDefinition(false, false, 0));
+    MediaSource mediaSource = new FakeMediaSource(timeline, null, TEST_VIDEO_FORMAT);
+    FakeRenderer renderer = new FakeRenderer(TEST_VIDEO_FORMAT);
+    playerWrapper.setup(mediaSource, renderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(2, playerWrapper.positionDiscontinuityCount);
+    assertEquals(3, renderer.formatReadCount);
+    assertEquals(1, renderer.bufferReadCount);
+    assertTrue(renderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertNull(playerWrapper.manifest);
+  }
+
+  /**
+   * Tests that the player does not unnecessarily reset renderers when playing a multi-period
+   * source.
+   */
+  public void testReadAheadToEndDoesNotResetRenderer() throws Exception {
+    final PlayerWrapper playerWrapper = new PlayerWrapper();
+    Timeline timeline = new FakeTimeline(
+        new TimelineWindowDefinition(false, false, 10),
+        new TimelineWindowDefinition(false, false, 10),
+        new TimelineWindowDefinition(false, false, 10));
+    MediaSource mediaSource = new FakeMediaSource(timeline, null, TEST_VIDEO_FORMAT,
+        TEST_AUDIO_FORMAT);
+
+    FakeRenderer videoRenderer = new FakeRenderer(TEST_VIDEO_FORMAT);
+    FakeMediaClockRenderer audioRenderer = new FakeMediaClockRenderer(TEST_AUDIO_FORMAT) {
+
+      @Override
+      public long getPositionUs() {
+        // Simulate the playback position lagging behind the reading position: the renderer media
+        // clock position will be the start of the timeline until the stream is set to be final, at
+        // which point it jumps to the end of the timeline allowing the playing period to advance.
+        // TODO: Avoid hard-coding ExoPlayerImplInternal.RENDERER_TIMESTAMP_OFFSET_US.
+        return isCurrentStreamFinal() ? 60000030 : 60000000;
+      }
+
+      @Override
+      public boolean isEnded() {
+        // Allow playback to end once the final period is playing.
+        return playerWrapper.positionDiscontinuityCount == 2;
+      }
+
+    };
+    playerWrapper.setup(mediaSource, videoRenderer, audioRenderer);
+    playerWrapper.blockUntilEnded(TIMEOUT_MS);
+    assertEquals(2, playerWrapper.positionDiscontinuityCount);
+    assertEquals(1, audioRenderer.positionResetCount);
+    assertTrue(videoRenderer.isEnded);
+    assertTrue(audioRenderer.isEnded);
+    assertEquals(timeline, playerWrapper.timeline);
+    assertNull(playerWrapper.manifest);
   }
 
   /**
@@ -65,12 +166,14 @@ public void testPlayToEnd() throws Exception {
     private final HandlerThread playerThread;
     private final Handler handler;
 
-    private Timeline expectedTimeline;
-    private Object expectedManifest;
-    private Format expectedFormat;
     private ExoPlayer player;
+    private Timeline timeline;
+    private Object manifest;
+    private TrackGroupArray trackGroups;
     private Exception exception;
-    private boolean seenPositionDiscontinuity;
+
+    // Written only on the main thread.
+    private volatile int positionDiscontinuityCount;
 
     public PlayerWrapper() {
       endedCountDownLatch = new CountDownLatch(1);
@@ -81,34 +184,28 @@ public PlayerWrapper() {
 
     // Called on the test thread.
 
-    public void blockUntilEndedOrError(long timeoutMs) throws Exception {
+    public void blockUntilEnded(long timeoutMs) throws Exception {
       if (!endedCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS)) {
         exception = new TimeoutException("Test playback timed out.");
       }
       release();
-
       // Throw any pending exception (from playback, timing out or releasing).
       if (exception != null) {
         throw exception;
       }
     }
 
-    public void setup(final Timeline timeline, final Object manifest, final Format format) {
-      expectedTimeline = timeline;
-      expectedManifest = manifest;
-      expectedFormat = format;
+    public void setup(final MediaSource mediaSource, final Renderer... renderers) {
       handler.post(new Runnable() {
         @Override
         public void run() {
           try {
-            Renderer fakeRenderer = new FakeVideoRenderer(expectedFormat);
-            player = ExoPlayerFactory.newInstance(new Renderer[] {fakeRenderer},
-                new DefaultTrackSelector());
+            player = ExoPlayerFactory.newInstance(renderers, new DefaultTrackSelector());
             player.addListener(PlayerWrapper.this);
             player.setPlayWhenReady(true);
-            player.prepare(new FakeMediaSource(timeline, manifest, format));
+            player.prepare(mediaSource);
           } catch (Exception e) {
-            handlePlayerException(e);
+            handleError(e);
           }
         }
       });
@@ -123,7 +220,7 @@ public void run() {
               player.release();
             }
           } catch (Exception e) {
-            handlePlayerException(e);
+            handleError(e);
           } finally {
             playerThread.quit();
           }
@@ -132,7 +229,7 @@ public void run() {
       playerThread.join();
     }
 
-    private void handlePlayerException(Exception exception) {
+    private void handleError(Exception exception) {
       if (this.exception == null) {
         this.exception = exception;
       }
@@ -155,32 +252,83 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
 
     @Override
     public void onTimelineChanged(Timeline timeline, Object manifest) {
-      assertEquals(expectedTimeline, timeline);
-      assertEquals(expectedManifest, manifest);
+      this.timeline = timeline;
+      this.manifest = manifest;
     }
 
     @Override
-    public void onTracksChanged(TrackGroupArray trackGroups,
-        TrackSelectionArray trackSelections) {
-      assertEquals(new TrackGroupArray(new TrackGroup(expectedFormat)), trackGroups);
+    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+      this.trackGroups = trackGroups;
     }
 
     @Override
     public void onPlayerError(ExoPlaybackException exception) {
-      this.exception = exception;
-      endedCountDownLatch.countDown();
+      handleError(exception);
     }
 
+    @SuppressWarnings("NonAtomicVolatileUpdate")
     @Override
     public void onPositionDiscontinuity() {
-      assertFalse(seenPositionDiscontinuity);
-      assertEquals(0, player.getCurrentWindowIndex());
-      assertEquals(0, player.getCurrentPeriodIndex());
-      assertEquals(0, player.getCurrentPosition());
-      assertEquals(0, player.getBufferedPosition());
-      assertEquals(expectedTimeline, player.getCurrentTimeline());
-      assertEquals(expectedManifest, player.getCurrentManifest());
-      seenPositionDiscontinuity = true;
+      positionDiscontinuityCount++;
+    }
+
+  }
+
+  private static final class TimelineWindowDefinition {
+
+    public final boolean isSeekable;
+    public final boolean isDynamic;
+    public final long durationUs;
+
+    public TimelineWindowDefinition(boolean isSeekable, boolean isDynamic, long durationUs) {
+      this.isSeekable = isSeekable;
+      this.isDynamic = isDynamic;
+      this.durationUs = durationUs;
+    }
+
+  }
+
+  private static final class FakeTimeline extends Timeline {
+
+    private final TimelineWindowDefinition[] windowDefinitions;
+
+    public FakeTimeline(TimelineWindowDefinition... windowDefinitions) {
+      this.windowDefinitions = windowDefinitions;
+    }
+
+    @Override
+    public int getWindowCount() {
+      return windowDefinitions.length;
+    }
+
+    @Override
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
+      TimelineWindowDefinition windowDefinition = windowDefinitions[windowIndex];
+      Object id = setIds ? windowIndex : null;
+      return window.set(id, C.TIME_UNSET, C.TIME_UNSET, windowDefinition.isSeekable,
+          windowDefinition.isDynamic, 0, windowDefinition.durationUs, windowIndex, windowIndex, 0);
+    }
+
+    @Override
+    public int getPeriodCount() {
+      return windowDefinitions.length;
+    }
+
+    @Override
+    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+      TimelineWindowDefinition windowDefinition = windowDefinitions[periodIndex];
+      Object id = setIds ? periodIndex : null;
+      return period.set(id, id, periodIndex, windowDefinition.durationUs, 0);
+    }
+
+    @Override
+    public int getIndexOfPeriod(Object uid) {
+      if (!(uid instanceof Integer)) {
+        return C.INDEX_UNSET;
+      }
+      int index = (Integer) uid;
+      return index >= 0 && index < windowDefinitions.length ? index : C.INDEX_UNSET;
     }
 
   }
@@ -193,18 +341,21 @@ public void onPositionDiscontinuity() {
 
     private final Timeline timeline;
     private final Object manifest;
-    private final Format format;
+    private final TrackGroupArray trackGroupArray;
+    private final ArrayList<FakeMediaPeriod> activeMediaPeriods;
 
-    private FakeMediaPeriod mediaPeriod;
     private boolean preparedSource;
-    private boolean releasedPeriod;
     private boolean releasedSource;
 
-    public FakeMediaSource(Timeline timeline, Object manifest, Format format) {
-      Assertions.checkArgument(timeline.getPeriodCount() == 1);
+    public FakeMediaSource(Timeline timeline, Object manifest, Format... formats) {
       this.timeline = timeline;
       this.manifest = manifest;
-      this.format = format;
+      TrackGroup[] trackGroups = new TrackGroup[formats.length];
+      for (int i = 0; i < formats.length; i++) {
+        trackGroups[i] = new TrackGroup(formats[i]);
+      }
+      trackGroupArray = new TrackGroupArray(trackGroups);
+      activeMediaPeriods = new ArrayList<>();
     }
 
     @Override
@@ -221,33 +372,29 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
 
     @Override
     public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
+      Assertions.checkIndex(index, 0, timeline.getPeriodCount());
       assertTrue(preparedSource);
-      assertNull(mediaPeriod);
-      assertFalse(releasedPeriod);
       assertFalse(releasedSource);
-      assertEquals(0, index);
       assertEquals(0, positionUs);
-      mediaPeriod = new FakeMediaPeriod(format);
+      FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray);
+      activeMediaPeriods.add(mediaPeriod);
       return mediaPeriod;
     }
 
     @Override
     public void releasePeriod(MediaPeriod mediaPeriod) {
       assertTrue(preparedSource);
-      assertNotNull(this.mediaPeriod);
-      assertFalse(releasedPeriod);
       assertFalse(releasedSource);
-      assertEquals(this.mediaPeriod, mediaPeriod);
-      this.mediaPeriod.release();
-      releasedPeriod = true;
+      FakeMediaPeriod fakeMediaPeriod = (FakeMediaPeriod) mediaPeriod;
+      assertTrue(activeMediaPeriods.remove(fakeMediaPeriod));
+      fakeMediaPeriod.release();
     }
 
     @Override
     public void releaseSource() {
       assertTrue(preparedSource);
-      assertNotNull(this.mediaPeriod);
-      assertTrue(releasedPeriod);
       assertFalse(releasedSource);
+      assertTrue(activeMediaPeriods.isEmpty());
       releasedSource = true;
     }
 
@@ -259,12 +406,12 @@ public void releaseSource() {
    */
   private static final class FakeMediaPeriod implements MediaPeriod {
 
-    private final TrackGroup trackGroup;
+    private final TrackGroupArray trackGroupArray;
 
     private boolean preparedPeriod;
 
-    public FakeMediaPeriod(Format format) {
-      trackGroup = new TrackGroup(format);
+    public FakeMediaPeriod(TrackGroupArray trackGroupArray) {
+      this.trackGroupArray = trackGroupArray;
     }
 
     public void release() {
@@ -286,30 +433,38 @@ public void maybeThrowPrepareError() throws IOException {
     @Override
     public TrackGroupArray getTrackGroups() {
       assertTrue(preparedPeriod);
-      return new TrackGroupArray(trackGroup);
+      return trackGroupArray;
     }
 
     @Override
     public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
         SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
       assertTrue(preparedPeriod);
-      assertEquals(1, selections.length);
-      assertEquals(1, mayRetainStreamFlags.length);
-      assertEquals(1, streams.length);
-      assertEquals(1, streamResetFlags.length);
-      assertEquals(0, positionUs);
-      if (streams[0] != null && (selections[0] == null || !mayRetainStreamFlags[0])) {
-        streams[0] = null;
+      int rendererCount = selections.length;
+      for (int i = 0; i < rendererCount; i++) {
+        if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
+          streams[i] = null;
+        }
       }
-      if (streams[0] == null && selections[0] != null) {
-        FakeSampleStream stream = new FakeSampleStream(trackGroup.getFormat(0));
-        assertEquals(trackGroup, selections[0].getTrackGroup());
-        streams[0] = stream;
-        streamResetFlags[0] = true;
+      for (int i = 0; i < rendererCount; i++) {
+        if (streams[i] == null && selections[i] != null) {
+          TrackSelection selection = selections[i];
+          assertEquals(1, selection.length());
+          assertEquals(0, selection.getIndexInTrackGroup(0));
+          TrackGroup trackGroup = selection.getTrackGroup();
+          assertTrue(trackGroupArray.indexOf(trackGroup) != C.INDEX_UNSET);
+          streams[i] = new FakeSampleStream(trackGroup.getFormat(0));
+          streamResetFlags[i] = true;
+        }
       }
       return 0;
     }
 
+    @Override
+    public void discardBuffer(long positionUs) {
+      // Do nothing.
+    }
+
     @Override
     public long readDiscontinuity() {
       assertTrue(preparedPeriod);
@@ -332,7 +487,7 @@ public long seekToUs(long positionUs) {
     @Override
     public long getNextLoadPositionUs() {
       assertTrue(preparedPeriod);
-      return 0;
+      return C.TIME_END_OF_SOURCE;
     }
 
     @Override
@@ -352,7 +507,6 @@ public boolean continueLoading(long positionUs) {
     private final Format format;
 
     private boolean readFormat;
-    private boolean readEndOfStream;
 
     public FakeSampleStream(Format format) {
       this.format = format;
@@ -364,16 +518,16 @@ public boolean isReady() {
     }
 
     @Override
-    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
-      Assertions.checkState(!readEndOfStream);
-      if (readFormat) {
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
+        boolean formatRequired) {
+      if (formatRequired || !readFormat) {
+        formatHolder.format = format;
+        readFormat = true;
+        return C.RESULT_FORMAT_READ;
+      } else {
         buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
-        readEndOfStream = true;
         return C.RESULT_BUFFER_READ;
       }
-      formatHolder.format = format;
-      readFormat = true;
-      return C.RESULT_FORMAT_READ;
     }
 
     @Override
@@ -389,21 +543,30 @@ public void skipToKeyframeBefore(long timeUs) {
   }
 
   /**
-   * Fake {@link Renderer} that supports any video format. The renderer verifies that it reads a
-   * given {@link Format} then a buffer with the end of stream flag set.
+   * Fake {@link Renderer} that supports any format with the matching MIME type. The renderer
+   * verifies that it reads a given {@link Format}.
    */
-  private static final class FakeVideoRenderer extends BaseRenderer {
+  private static class FakeRenderer extends BaseRenderer {
 
     private final Format expectedFormat;
 
-    private boolean isEnded;
+    public int positionResetCount;
+    public int formatReadCount;
+    public int bufferReadCount;
+    public boolean isEnded;
 
-    public FakeVideoRenderer(Format expectedFormat) {
-      super(C.TRACK_TYPE_VIDEO);
-      Assertions.checkArgument(MimeTypes.isVideo(expectedFormat.sampleMimeType));
+    public FakeRenderer(Format expectedFormat) {
+      super(expectedFormat == null ? C.TRACK_TYPE_UNKNOWN
+          : MimeTypes.getTrackType(expectedFormat.sampleMimeType));
       this.expectedFormat = expectedFormat;
     }
 
+    @Override
+    protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
+      positionResetCount++;
+      isEnded = false;
+    }
+
     @Override
     public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
       if (isEnded) {
@@ -412,20 +575,23 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
 
       // Verify the format matches the expected format.
       FormatHolder formatHolder = new FormatHolder();
-      readSource(formatHolder, null);
-      assertEquals(expectedFormat, formatHolder.format);
-
-      // Verify that we get an end-of-stream buffer.
       DecoderInputBuffer buffer =
           new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
-      readSource(null, buffer);
-      assertTrue(buffer.isEndOfStream());
-      isEnded = true;
+      int result = readSource(formatHolder, buffer, false);
+      if (result == C.RESULT_FORMAT_READ) {
+        formatReadCount++;
+        assertEquals(expectedFormat, formatHolder.format);
+      } else if (result == C.RESULT_BUFFER_READ) {
+        bufferReadCount++;
+        if (buffer.isEndOfStream()) {
+          isEnded = true;
+        }
+      }
     }
 
     @Override
     public boolean isReady() {
-      return isEnded;
+      return isSourceReady();
     }
 
     @Override
@@ -435,7 +601,21 @@ public boolean isEnded() {
 
     @Override
     public int supportsFormat(Format format) throws ExoPlaybackException {
-      return MimeTypes.isVideo(format.sampleMimeType) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
+      return getTrackType() == MimeTypes.getTrackType(format.sampleMimeType) ? FORMAT_HANDLED
+          : FORMAT_UNSUPPORTED_TYPE;
+    }
+
+  }
+
+  private abstract static class FakeMediaClockRenderer extends FakeRenderer implements MediaClock {
+
+    public FakeMediaClockRenderer(Format expectedFormat) {
+      super(expectedFormat);
+    }
+
+    @Override
+    public MediaClock getMediaClock() {
+      return this;
     }
 
   }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
index c8c1b4ed93..e13afceb40 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/FormatTest.java
@@ -59,8 +59,8 @@ public void testParcelable() {
     DrmInitData drmInitData = new DrmInitData(DRM_DATA_1, DRM_DATA_2);
     byte[] projectionData = new byte[] {1, 2, 3};
     Metadata metadata = new Metadata(
-        new TextInformationFrame("id1", "description1"),
-        new TextInformationFrame("id2", "description2"));
+        new TextInformationFrame("id1", "description1", "value1"),
+        new TextInformationFrame("id2", "description2", "value2"));
 
     Format formatToParcel = new Format("id", MimeTypes.VIDEO_MP4, MimeTypes.VIDEO_H264, null,
         1024, 2048, 1920, 1080, 24, 90, 2, projectionData, C.STEREO_MODE_TOP_BOTTOM, 6, 44100,
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
new file mode 100644
index 0000000000..985e93404a
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.drm;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.when;
+
+import android.test.InstrumentationTestCase;
+import android.test.MoreAsserts;
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Arrays;
+import java.util.HashMap;
+import org.mockito.Mock;
+
+/**
+ * Tests {@link OfflineLicenseHelper}.
+ */
+public class OfflineLicenseHelperTest extends InstrumentationTestCase {
+
+  private OfflineLicenseHelper<?> offlineLicenseHelper;
+  @Mock private HttpDataSource httpDataSource;
+  @Mock private MediaDrmCallback mediaDrmCallback;
+  @Mock private ExoMediaDrm<ExoMediaCrypto> mediaDrm;
+
+  @Override
+  protected void setUp() throws Exception {
+    TestUtil.setUpMockito(this);
+
+    when(mediaDrm.openSession()).thenReturn(new byte[] {1, 2, 3});
+
+    offlineLicenseHelper = new OfflineLicenseHelper<>(mediaDrm, mediaDrmCallback, null);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    offlineLicenseHelper.releaseResources();
+  }
+
+  public void testDownloadRenewReleaseKey() throws Exception {
+    DashManifest manifest = newDashManifestWithAllElements();
+    setStubLicenseAndPlaybackDurationValues(1000, 200);
+
+    byte[] keySetId = {2, 5, 8};
+    setStubKeySetId(keySetId);
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertOfflineLicenseKeySetIdEqual(keySetId, offlineLicenseKeySetId);
+
+    byte[] keySetId2 = {6, 7, 0, 1, 4};
+    setStubKeySetId(keySetId2);
+
+    byte[] offlineLicenseKeySetId2 = offlineLicenseHelper.renew(offlineLicenseKeySetId);
+
+    assertOfflineLicenseKeySetIdEqual(keySetId2, offlineLicenseKeySetId2);
+
+    offlineLicenseHelper.release(offlineLicenseKeySetId2);
+  }
+
+  public void testDownloadFailsIfThereIsNoInitData() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest =
+        newDashManifest(newPeriods(newAdaptationSets(newRepresentations(null /*no init data*/))));
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfThereIsNoRepresentation() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest = newDashManifest(newPeriods(newAdaptationSets(/*no representation*/)));
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfThereIsNoAdaptationSet() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest = newDashManifest(newPeriods(/*no adaptation set*/));
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfThereIsNoPeriod() throws Exception {
+    setDefaultStubValues();
+    DashManifest manifest = newDashManifest(/*no periods*/);
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadFailsIfNoKeySetIdIsReturned() throws Exception {
+    setStubLicenseAndPlaybackDurationValues(1000, 200);
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNull(offlineLicenseKeySetId);
+  }
+
+  public void testDownloadDoesNotFailIfDurationNotAvailable() throws Exception {
+    setDefaultStubKeySetId();
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    assertNotNull(offlineLicenseKeySetId);
+  }
+
+  public void testGetLicenseDurationRemainingSec() throws Exception {
+    long licenseDuration = 1000;
+    int playbackDuration = 200;
+    setStubLicenseAndPlaybackDurationValues(licenseDuration, playbackDuration);
+    setDefaultStubKeySetId();
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    Pair<Long, Long> licenseDurationRemainingSec = offlineLicenseHelper
+        .getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+
+    assertEquals(licenseDuration, (long) licenseDurationRemainingSec.first);
+    assertEquals(playbackDuration, (long) licenseDurationRemainingSec.second);
+  }
+
+  public void testGetLicenseDurationRemainingSecExpiredLicense() throws Exception {
+    long licenseDuration = 0;
+    int playbackDuration = 0;
+    setStubLicenseAndPlaybackDurationValues(licenseDuration, playbackDuration);
+    setDefaultStubKeySetId();
+    DashManifest manifest = newDashManifestWithAllElements();
+
+    byte[] offlineLicenseKeySetId = offlineLicenseHelper.download(httpDataSource, manifest);
+
+    Pair<Long, Long> licenseDurationRemainingSec = offlineLicenseHelper
+        .getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+
+    assertEquals(licenseDuration, (long) licenseDurationRemainingSec.first);
+    assertEquals(playbackDuration, (long) licenseDurationRemainingSec.second);
+  }
+
+  private void setDefaultStubValues()
+      throws android.media.NotProvisionedException, android.media.DeniedByServerException {
+    setDefaultStubKeySetId();
+    setStubLicenseAndPlaybackDurationValues(1000, 200);
+  }
+
+  private void setDefaultStubKeySetId()
+      throws android.media.NotProvisionedException, android.media.DeniedByServerException {
+    setStubKeySetId(new byte[] {2, 5, 8});
+  }
+
+  private void setStubKeySetId(byte[] keySetId)
+      throws android.media.NotProvisionedException, android.media.DeniedByServerException {
+    when(mediaDrm.provideKeyResponse(any(byte[].class), any(byte[].class))).thenReturn(keySetId);
+  }
+
+  private static void assertOfflineLicenseKeySetIdEqual(
+      byte[] expectedKeySetId, byte[] actualKeySetId) throws Exception {
+    assertNotNull(actualKeySetId);
+    MoreAsserts.assertEquals(expectedKeySetId, actualKeySetId);
+  }
+
+  private void setStubLicenseAndPlaybackDurationValues(long licenseDuration,
+      long playbackDuration) {
+    HashMap<String, String> keyStatus = new HashMap<>();
+    keyStatus.put(WidevineUtil.PROPERTY_LICENSE_DURATION_REMAINING,
+        String.valueOf(licenseDuration));
+    keyStatus.put(WidevineUtil.PROPERTY_PLAYBACK_DURATION_REMAINING,
+        String.valueOf(playbackDuration));
+    when(mediaDrm.queryKeyStatus(any(byte[].class))).thenReturn(keyStatus);
+  }
+
+  private static DashManifest newDashManifestWithAllElements() {
+    return newDashManifest(newPeriods(newAdaptationSets(newRepresentations(newDrmInitData()))));
+  }
+
+  private static DashManifest newDashManifest(Period... periods) {
+    return new DashManifest(0, 0, 0, false, 0, 0, 0, null, null, Arrays.asList(periods));
+  }
+
+  private static Period newPeriods(AdaptationSet... adaptationSets) {
+    return new Period("", 0, Arrays.asList(adaptationSets));
+  }
+
+  private static AdaptationSet newAdaptationSets(Representation... representations) {
+    return new AdaptationSet(0, C.TRACK_TYPE_VIDEO, Arrays.asList(representations), null);
+  }
+
+  private static Representation newRepresentations(DrmInitData drmInitData) {
+    Format format = Format.createVideoContainerFormat("id", MimeTypes.VIDEO_MP4,
+        MimeTypes.VIDEO_H264, "", Format.NO_VALUE, 1024, 768, Format.NO_VALUE, null, 0);
+    if (drmInitData != null) {
+      format = format.copyWithDrmInitData(drmInitData);
+    }
+    return Representation.newInstance("", 0, format, "", new SingleSegmentBase());
+  }
+
+  private static DrmInitData newDrmInitData() {
+    return new DrmInitData(new SchemeData(C.WIDEVINE_UUID, "mimeType",
+        new byte[]{1, 4, 7, 0, 3, 6}));
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
index c47614e4ee..95ad8b446e 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.TestUtil;
 
@@ -25,12 +26,31 @@
 public final class FragmentedMp4ExtractorTest extends InstrumentationTestCase {
 
   public void testSample() throws Exception {
-    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
+    TestUtil.assertOutput(getExtractorFactory(), "mp4/sample_fragmented.mp4", getInstrumentation());
+  }
+
+  public void testSampleWithSeiPayloadParsing() throws Exception {
+    // Enabling the CEA-608 track enables SEI payload parsing.
+    TestUtil.assertOutput(getExtractorFactory(FragmentedMp4Extractor.FLAG_ENABLE_CEA608_TRACK),
+        "mp4/sample_fragmented_sei.mp4", getInstrumentation());
+  }
+
+  public void testAtomWithZeroSize() throws Exception {
+    TestUtil.assertThrows(getExtractorFactory(), "mp4/sample_fragmented_zero_size_atom.mp4",
+        getInstrumentation(), ParserException.class);
+  }
+
+  private static TestUtil.ExtractorFactory getExtractorFactory() {
+    return getExtractorFactory(0);
+  }
+
+  private static TestUtil.ExtractorFactory getExtractorFactory(final int flags) {
+    return new TestUtil.ExtractorFactory() {
       @Override
       public Extractor create() {
-        return new FragmentedMp4Extractor();
+        return new FragmentedMp4Extractor(flags, null);
       }
-    }, "mp4/sample_fragmented.mp4", getInstrumentation());
+    };
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
index ebb547810b..bcfa90a565 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
@@ -69,8 +69,8 @@
   @Override
   protected void setUp() throws Exception {
     FakeExtractorOutput fakeExtractorOutput = new FakeExtractorOutput();
-    adtsOutput = fakeExtractorOutput.track(0);
-    id3Output = fakeExtractorOutput.track(1);
+    adtsOutput = fakeExtractorOutput.track(0, C.TRACK_TYPE_AUDIO);
+    id3Output = fakeExtractorOutput.track(1, C.TRACK_TYPE_METADATA);
     adtsReader = new AdtsReader(true);
     TrackIdGenerator idGenerator = new TrackIdGenerator(0, 1);
     adtsReader.createTracks(fakeExtractorOutput, idGenerator);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
index 453a33a521..c4d9de3100 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
@@ -16,9 +16,9 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
index c9d6535164..7bf722cd8f 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
@@ -17,11 +17,11 @@
 
 import android.test.InstrumentationTestCase;
 import android.util.SparseArray;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.PositionHolder;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
@@ -30,6 +30,7 @@
 import com.google.android.exoplayer2.testutil.FakeTrackOutput;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.ByteArrayOutputStream;
 import java.util.Random;
 
@@ -74,7 +75,8 @@ public Extractor create() {
 
   public void testCustomPesReader() throws Exception {
     CustomTsPayloadReaderFactory factory = new CustomTsPayloadReaderFactory(true, false);
-    TsExtractor tsExtractor = new TsExtractor(new TimestampAdjuster(0), factory, false);
+    TsExtractor tsExtractor = new TsExtractor(TsExtractor.MODE_NORMAL, new TimestampAdjuster(0),
+        factory);
     FakeExtractorInput input = new FakeExtractorInput.Builder()
         .setData(TestUtil.getByteArray(getInstrumentation(), "ts/sample.ts"))
         .setSimulateIOErrors(false)
@@ -92,13 +94,14 @@ public void testCustomPesReader() throws Exception {
     TrackOutput trackOutput = reader.getTrackOutput();
     assertTrue(trackOutput == output.trackOutputs.get(257 /* PID of audio track. */));
     assertEquals(
-        Format.createTextSampleFormat("Overriding format", "mime", null, 0, 0, "und", null, 0),
+        Format.createTextSampleFormat("1/257", "mime", null, 0, 0, "und", null, 0),
         ((FakeTrackOutput) trackOutput).format);
   }
 
   public void testCustomInitialSectionReader() throws Exception {
     CustomTsPayloadReaderFactory factory = new CustomTsPayloadReaderFactory(false, true);
-    TsExtractor tsExtractor = new TsExtractor(new TimestampAdjuster(0), factory, false);
+    TsExtractor tsExtractor = new TsExtractor(TsExtractor.MODE_NORMAL, new TimestampAdjuster(0),
+        factory);
     FakeExtractorInput input = new FakeExtractorInput.Builder()
         .setData(TestUtil.getByteArray(getInstrumentation(), "ts/sample_with_sdt.ts"))
         .setSimulateIOErrors(false)
@@ -178,8 +181,9 @@ public void seek() {
 
     @Override
     public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-      output = extractorOutput.track(idGenerator.getNextId());
-      output.format(Format.createTextSampleFormat("Overriding format", "mime", null, 0, 0,
+      idGenerator.generateNewId();
+      output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_UNKNOWN);
+      output.format(Format.createTextSampleFormat(idGenerator.getFormatId(), "mime", null, 0, 0,
           language, null, 0));
     }
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
new file mode 100644
index 0000000000..b33dfd1067
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.test.MoreAsserts;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import java.nio.ByteBuffer;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link EventMessageDecoder}.
+ */
+public final class EventMessageDecoderTest extends TestCase {
+
+  public void testDecodeEventMessage() {
+    byte[] rawEmsgBody = new byte[] {
+        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+        49, 50, 51, 0, // value = "123"
+        0, 0, -69, -128, // timescale = 48000
+        0, 0, 0, 0, // presentation_time_delta (ignored) = 0
+        0, 2, 50, -128, // event_duration = 144000
+        0, 15, 67, -45, // id = 1000403
+        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
+    EventMessageDecoder decoder = new EventMessageDecoder();
+    MetadataInputBuffer buffer = new MetadataInputBuffer();
+    buffer.data = ByteBuffer.allocate(rawEmsgBody.length).put(rawEmsgBody);
+    Metadata metadata = decoder.decode(buffer);
+    assertEquals(1, metadata.length());
+    EventMessage eventMessage = (EventMessage) metadata.get(0);
+    assertEquals("urn:test", eventMessage.schemeIdUri);
+    assertEquals("123", eventMessage.value);
+    assertEquals(3000, eventMessage.durationMs);
+    assertEquals(1000403, eventMessage.id);
+    MoreAsserts.assertEquals(new byte[] {0, 1, 2, 3, 4}, eventMessage.messageData);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
new file mode 100644
index 0000000000..baafb6b18b
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.os.Parcel;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link EventMessage}.
+ */
+public final class EventMessageTest extends TestCase {
+
+  public void testEventMessageParcelable() {
+    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
+        new byte[] {0, 1, 2, 3, 4});
+    // Write to parcel.
+    Parcel parcel = Parcel.obtain();
+    eventMessage.writeToParcel(parcel, 0);
+    // Create from parcel.
+    parcel.setDataPosition(0);
+    EventMessage fromParcelEventMessage = EventMessage.CREATOR.createFromParcel(parcel);
+    // Assert equals.
+    assertEquals(eventMessage, fromParcelEventMessage);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
new file mode 100644
index 0000000000..182ae6f1c9
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link ChapterFrame}.
+ */
+public final class ChapterFrameTest extends TestCase {
+
+  public void testParcelable() {
+    Id3Frame[] subFrames = new Id3Frame[] {
+      new TextInformationFrame("TIT2", null, "title"),
+      new UrlLinkFrame("WXXX", "description", "url")
+    };
+    ChapterFrame chapterFrameToParcel = new ChapterFrame("id", 0, 1, 2, 3, subFrames);
+
+    Parcel parcel = Parcel.obtain();
+    chapterFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    ChapterFrame chapterFrameFromParcel = ChapterFrame.CREATOR.createFromParcel(parcel);
+    assertEquals(chapterFrameToParcel, chapterFrameFromParcel);
+
+    parcel.recycle();
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
new file mode 100644
index 0000000000..9641de7669
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link ChapterTocFrame}.
+ */
+public final class ChapterTocFrameTest extends TestCase {
+
+  public void testParcelable() {
+    String[] children = new String[] {"child0", "child1"};
+    Id3Frame[] subFrames = new Id3Frame[] {
+        new TextInformationFrame("TIT2", null, "title"),
+        new UrlLinkFrame("WXXX", "description", "url")
+    };
+    ChapterTocFrame chapterTocFrameToParcel = new ChapterTocFrame("id", false, true, children,
+        subFrames);
+
+    Parcel parcel = Parcel.obtain();
+    chapterTocFrameToParcel.writeToParcel(parcel, 0);
+    parcel.setDataPosition(0);
+
+    ChapterTocFrame chapterTocFrameFromParcel = ChapterTocFrame.CREATOR.createFromParcel(parcel);
+    assertEquals(chapterTocFrameToParcel, chapterTocFrameFromParcel);
+
+    parcel.recycle();
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
index 6bfa6fccfc..e271108ce4 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
@@ -21,9 +21,9 @@
 import junit.framework.TestCase;
 
 /**
- * Test for {@link Id3Decoder}
+ * Test for {@link Id3Decoder}.
  */
-public class Id3DecoderTest extends TestCase {
+public final class Id3DecoderTest extends TestCase {
 
   public void testDecodeTxxxFrame() throws MetadataDecoderException {
     byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 41, 84, 88, 88, 88, 0, 0, 0, 31, 0, 0,
@@ -32,9 +32,10 @@ public void testDecodeTxxxFrame() throws MetadataDecoderException {
     Id3Decoder decoder = new Id3Decoder();
     Metadata metadata = decoder.decode(rawId3, rawId3.length);
     assertEquals(1, metadata.length());
-    TxxxFrame txxxFrame = (TxxxFrame) metadata.get(0);
-    assertEquals("", txxxFrame.description);
-    assertEquals("mdialog_VINDICO1527664_start", txxxFrame.value);
+    TextInformationFrame textInformationFrame = (TextInformationFrame) metadata.get(0);
+    assertEquals("TXXX", textInformationFrame.id);
+    assertEquals("", textInformationFrame.description);
+    assertEquals("mdialog_VINDICO1527664_start", textInformationFrame.value);
   }
 
   public void testDecodeApicFrame() throws MetadataDecoderException {
@@ -60,7 +61,19 @@ public void testDecodeTextInformationFrame() throws MetadataDecoderException {
     assertEquals(1, metadata.length());
     TextInformationFrame textInformationFrame = (TextInformationFrame) metadata.get(0);
     assertEquals("TIT2", textInformationFrame.id);
-    assertEquals("Hello World", textInformationFrame.description);
+    assertNull(textInformationFrame.description);
+    assertEquals("Hello World", textInformationFrame.value);
+  }
+
+  public void testDecodePrivFrame() throws MetadataDecoderException {
+    byte[] rawId3 = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 19, 80, 82, 73, 86, 0, 0, 0, 9, 0, 0,
+        116, 101, 115, 116, 0, 1, 2, 3, 4};
+    Id3Decoder decoder = new Id3Decoder();
+    Metadata metadata = decoder.decode(rawId3, rawId3.length);
+    assertEquals(1, metadata.length());
+    PrivFrame privFrame = (PrivFrame) metadata.get(0);
+    assertEquals("test", privFrame.owner);
+    MoreAsserts.assertEquals(new byte[] {1, 2, 3, 4}, privFrame.privateData);
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
new file mode 100644
index 0000000000..c50ff06699
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.scte35;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataDecoderException;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.nio.ByteBuffer;
+import java.util.List;
+import junit.framework.TestCase;
+
+/**
+ * Test for {@link SpliceInfoDecoder}.
+ */
+public final class SpliceInfoDecoderTest extends TestCase {
+
+  private SpliceInfoDecoder decoder;
+  private MetadataInputBuffer inputBuffer;
+
+  @Override
+  public void setUp() {
+    decoder = new SpliceInfoDecoder();
+    inputBuffer = new MetadataInputBuffer();
+  }
+
+  public void testWrappedAroundTimeSignalCommand() throws MetadataDecoderException {
+    byte[] rawTimeSignalSection = new byte[] {
+        0, // table_id.
+        (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+        0x14, // section_length(8).
+        0x00, // protocol_version.
+        0x00, // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+        0x00, 0x00, 0x00, 0x00, // pts_adjustment(32).
+        0x00, // cw_index.
+        0x00, // tier(8).
+        0x00, // tier(4), splice_command_length(4).
+        0x05, // splice_command_length(8).
+        0x06, // splice_command_type = time_signal.
+        // Start of splice_time().
+        (byte) 0x80, // time_specified_flag, reserved, pts_time(1).
+        0x52, 0x03, 0x02, (byte) 0x8f, // pts_time(32). PTS for a second after playback position.
+        0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
+
+    // The playback position is 57:15:58.43 approximately.
+    // With this offset, the playback position pts before wrapping is 0x451ebf851.
+    Metadata metadata = feedInputBuffer(rawTimeSignalSection, 0x3000000000L, -0x50000L);
+    assertEquals(1, metadata.length());
+    assertEquals(removePtsConversionPrecisionError(0x3001000000L, inputBuffer.subsampleOffsetUs),
+        ((TimeSignalCommand) metadata.get(0)).playbackPositionUs);
+  }
+
+  public void test2SpliceInsertCommands() throws MetadataDecoderException {
+    byte[] rawSpliceInsertCommand1 = new byte[] {
+        0, // table_id.
+        (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+        0x19, // section_length(8).
+        0x00, // protocol_version.
+        0x00, // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+        0x00, 0x00, 0x00, 0x00, // pts_adjustment(32).
+        0x00, // cw_index.
+        0x00, // tier(8).
+        0x00, // tier(4), splice_command_length(4).
+        0x0e, // splice_command_length(8).
+        0x05, // splice_command_type = splice_insert.
+        // Start of splice_insert().
+        0x00, 0x00, 0x00, 0x42, // splice_event_id.
+        0x00, // splice_event_cancel_indicator, reserved.
+        0x40, // out_of_network_indicator, program_splice_flag, duration_flag,
+              // splice_immediate_flag, reserved.
+        // start of splice_time().
+        (byte) 0x80, // time_specified_flag, reserved, pts_time(1).
+        0x00, 0x00, 0x00, 0x00, // PTS for playback position 3s.
+        0x00, 0x10, // unique_program_id.
+        0x01, // avail_num.
+        0x02, // avails_expected.
+        0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
+
+    Metadata metadata = feedInputBuffer(rawSpliceInsertCommand1, 2000000, 3000000);
+    assertEquals(1, metadata.length());
+    SpliceInsertCommand command = (SpliceInsertCommand) metadata.get(0);
+    assertEquals(66, command.spliceEventId);
+    assertFalse(command.spliceEventCancelIndicator);
+    assertFalse(command.outOfNetworkIndicator);
+    assertTrue(command.programSpliceFlag);
+    assertFalse(command.spliceImmediateFlag);
+    assertEquals(3000000, command.programSplicePlaybackPositionUs);
+    assertEquals(C.TIME_UNSET, command.breakDuration);
+    assertEquals(16, command.uniqueProgramId);
+    assertEquals(1, command.availNum);
+    assertEquals(2, command.availsExpected);
+
+    byte[] rawSpliceInsertCommand2 = new byte[] {
+        0, // table_id.
+        (byte) 0x80, // section_syntax_indicator, private_indicator, reserved, section_length(4).
+        0x22, // section_length(8).
+        0x00, // protocol_version.
+        0x00, // encrypted_packet, encryption_algorithm, pts_adjustment(1).
+        0x00, 0x00, 0x00, 0x00, // pts_adjustment(32).
+        0x00, // cw_index.
+        0x00, // tier(8).
+        0x00, // tier(4), splice_command_length(4).
+        0x13, // splice_command_length(8).
+        0x05, // splice_command_type = splice_insert.
+        // Start of splice_insert().
+        (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, // splice_event_id.
+        0x00, // splice_event_cancel_indicator, reserved.
+        0x00, // out_of_network_indicator, program_splice_flag, duration_flag,
+              // splice_immediate_flag, reserved.
+        0x02, // component_count.
+        0x10, // component_tag.
+        // start of splice_time().
+        (byte) 0x81, // time_specified_flag, reserved, pts_time(1).
+        (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, // PTS for playback position 10s.
+        // start of splice_time().
+        0x11, // component_tag.
+        0x00, // time_specified_flag, reserved.
+        0x00, 0x20, // unique_program_id.
+        0x01, // avail_num.
+        0x02, // avails_expected.
+        0x00, 0x00, 0x00, 0x00}; // CRC_32 (ignored, check happens at extraction).
+
+    // By changing the subsample offset we force adjuster reconstruction.
+    long subsampleOffset = 1000011;
+    metadata = feedInputBuffer(rawSpliceInsertCommand2, 1000000, subsampleOffset);
+    assertEquals(1, metadata.length());
+    command = (SpliceInsertCommand) metadata.get(0);
+    assertEquals(0xffffffffL, command.spliceEventId);
+    assertFalse(command.spliceEventCancelIndicator);
+    assertFalse(command.outOfNetworkIndicator);
+    assertFalse(command.programSpliceFlag);
+    assertFalse(command.spliceImmediateFlag);
+    assertEquals(C.TIME_UNSET, command.programSplicePlaybackPositionUs);
+    assertEquals(C.TIME_UNSET, command.breakDuration);
+    List<SpliceInsertCommand.ComponentSplice> componentSplices = command.componentSpliceList;
+    assertEquals(2, componentSplices.size());
+    assertEquals(16, componentSplices.get(0).componentTag);
+    assertEquals(1000000, componentSplices.get(0).componentSplicePlaybackPositionUs);
+    assertEquals(17, componentSplices.get(1).componentTag);
+    assertEquals(C.TIME_UNSET, componentSplices.get(1).componentSplicePts);
+    assertEquals(32, command.uniqueProgramId);
+    assertEquals(1, command.availNum);
+    assertEquals(2, command.availsExpected);
+  }
+
+  private Metadata feedInputBuffer(byte[] data, long timeUs, long subsampleOffset)
+      throws MetadataDecoderException{
+    inputBuffer.clear();
+    inputBuffer.data = ByteBuffer.allocate(data.length).put(data);
+    inputBuffer.timeUs = timeUs;
+    inputBuffer.subsampleOffsetUs = subsampleOffset;
+    return decoder.decode(inputBuffer);
+  }
+
+  private static long removePtsConversionPrecisionError(long timeUs, long offsetUs) {
+    return TimestampAdjuster.ptsToUs(TimestampAdjuster.usToPts(timeUs - offsetUs)) + offsetUs;
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
new file mode 100644
index 0000000000..0933fb858b
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import static org.mockito.Mockito.doAnswer;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Timeline.Period;
+import com.google.android.exoplayer2.Timeline.Window;
+import com.google.android.exoplayer2.source.MediaSource.Listener;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Unit tests for {@link ClippingMediaSource}.
+ */
+public final class ClippingMediaSourceTest extends InstrumentationTestCase {
+
+  private static final long TEST_PERIOD_DURATION_US = 1000000;
+  private static final long TEST_CLIP_AMOUNT_US = 300000;
+
+  @Mock
+  private MediaSource mockMediaSource;
+  private Timeline clippedTimeline;
+  private Window window;
+  private Period period;
+
+  @Override
+  protected void setUp() throws Exception {
+    TestUtil.setUpMockito(this);
+    window = new Timeline.Window();
+    period = new Timeline.Period();
+  }
+
+  public void testNoClipping() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
+
+    Timeline clippedTimeline = getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
+
+    assertEquals(1, clippedTimeline.getWindowCount());
+    assertEquals(1, clippedTimeline.getPeriodCount());
+    assertEquals(TEST_PERIOD_DURATION_US, clippedTimeline.getWindow(0, window).getDurationUs());
+    assertEquals(TEST_PERIOD_DURATION_US, clippedTimeline.getPeriod(0, period).getDurationUs());
+  }
+
+  public void testClippingUnseekableWindowThrows() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), false);
+
+    // If the unseekable window isn't clipped, clipping succeeds.
+    getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
+    try {
+      // If the unseekable window is clipped, clipping fails.
+      getClippedTimeline(timeline, 1, TEST_PERIOD_DURATION_US);
+      fail("Expected clipping to fail.");
+    } catch (IllegalArgumentException e) {
+      // Expected.
+    }
+  }
+
+  public void testClippingStart() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
+
+    Timeline clippedTimeline = getClippedTimeline(timeline, TEST_CLIP_AMOUNT_US,
+        TEST_PERIOD_DURATION_US);
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
+        clippedTimeline.getWindow(0, window).getDurationUs());
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
+        clippedTimeline.getPeriod(0, period).getDurationUs());
+  }
+
+  public void testClippingEnd() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
+
+    Timeline clippedTimeline = getClippedTimeline(timeline, 0,
+        TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
+        clippedTimeline.getWindow(0, window).getDurationUs());
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
+        clippedTimeline.getPeriod(0, period).getDurationUs());
+  }
+
+  public void testClippingStartAndEnd() {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
+
+    Timeline clippedTimeline = getClippedTimeline(timeline, TEST_CLIP_AMOUNT_US,
+        TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 2);
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3,
+        clippedTimeline.getWindow(0, window).getDurationUs());
+    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3,
+        clippedTimeline.getPeriod(0, period).getDurationUs());
+  }
+
+  /**
+   * Wraps the specified timeline in a {@link ClippingMediaSource} and returns the clipped timeline.
+   */
+  private Timeline getClippedTimeline(Timeline timeline, long startMs, long endMs) {
+    mockMediaSourceSourceWithTimeline(timeline);
+    new ClippingMediaSource(mockMediaSource, startMs, endMs).prepareSource(null, true,
+        new Listener() {
+          @Override
+          public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
+            clippedTimeline = timeline;
+          }
+        });
+    return clippedTimeline;
+  }
+
+  /**
+   * Returns a mock {@link MediaSource} with the specified {@link Timeline} in its source info.
+   */
+  private MediaSource mockMediaSourceSourceWithTimeline(final Timeline timeline) {
+    doAnswer(new Answer<Void>() {
+      @Override
+      public Void answer(InvocationOnMock invocation) throws Throwable {
+        MediaSource.Listener listener = (MediaSource.Listener) invocation.getArguments()[2];
+        listener.onSourceInfoRefreshed(timeline, null);
+        return null;
+      }
+    }).when(mockMediaSource).prepareSource(Mockito.any(ExoPlayer.class), Mockito.anyBoolean(),
+        Mockito.any(MediaSource.Listener.class));
+    return mockMediaSource;
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
index 944781b890..4de0ae4081 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
@@ -20,6 +20,8 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * Unit tests for {@link DashManifestParser}.
@@ -70,34 +72,57 @@ public void testParseMediaPresentationDescriptionWithSegmentTemplate() throws IO
   }
 
   public void testParseCea608AccessibilityChannel() {
-    assertEquals(1, DashManifestParser.parseCea608AccessibilityChannel("CC1=eng"));
-    assertEquals(2, DashManifestParser.parseCea608AccessibilityChannel("CC2=eng"));
-    assertEquals(3, DashManifestParser.parseCea608AccessibilityChannel("CC3=eng"));
-    assertEquals(4, DashManifestParser.parseCea608AccessibilityChannel("CC4=eng"));
+    assertEquals(1, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC1=eng")));
+    assertEquals(2, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC2=eng")));
+    assertEquals(3, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC3=eng")));
+    assertEquals(4, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC4=eng")));
 
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(null));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(""));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel("CC0=eng"));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel("CC5=eng"));
-    assertEquals(Format.NO_VALUE,
-        DashManifestParser.parseCea608AccessibilityChannel("Wrong format"));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors(null)));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC0=eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("CC5=eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
+        buildCea608AccessibilityDescriptors("Wrong format")));
   }
 
   public void testParseCea708AccessibilityChannel() {
-    assertEquals(1, DashManifestParser.parseCea708AccessibilityChannel("1=lang:eng"));
-    assertEquals(2, DashManifestParser.parseCea708AccessibilityChannel("2=lang:eng"));
-    assertEquals(3, DashManifestParser.parseCea708AccessibilityChannel("3=lang:eng"));
-    assertEquals(62, DashManifestParser.parseCea708AccessibilityChannel("62=lang:eng"));
-    assertEquals(63, DashManifestParser.parseCea708AccessibilityChannel("63=lang:eng"));
+    assertEquals(1, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("1=lang:eng")));
+    assertEquals(2, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("2=lang:eng")));
+    assertEquals(3, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("3=lang:eng")));
+    assertEquals(62, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("62=lang:eng")));
+    assertEquals(63, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("63=lang:eng")));
 
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(null));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(""));
-    assertEquals(Format.NO_VALUE,
-        DashManifestParser.parseCea708AccessibilityChannel("0=lang:eng"));
-    assertEquals(Format.NO_VALUE,
-        DashManifestParser.parseCea708AccessibilityChannel("64=lang:eng"));
-    assertEquals(Format.NO_VALUE,
-        DashManifestParser.parseCea708AccessibilityChannel("Wrong format"));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors(null)));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+        buildCea708AccessibilityDescriptors("")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+            buildCea708AccessibilityDescriptors("0=lang:eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+            buildCea708AccessibilityDescriptors("64=lang:eng")));
+    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
+            buildCea708AccessibilityDescriptors("Wrong format")));
+  }
+
+  private static List<SchemeValuePair> buildCea608AccessibilityDescriptors(String value) {
+    return Collections.singletonList(new SchemeValuePair("urn:scte:dash:cc:cea-608:2015", value));
+  }
+
+  private static List<SchemeValuePair> buildCea708AccessibilityDescriptors(String value) {
+    return Collections.singletonList(new SchemeValuePair("urn:scte:dash:cc:cea-708:2015", value));
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
new file mode 100644
index 0000000000..c796025b08
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import junit.framework.TestCase;
+
+/**
+ * Unit tests for {@link DashManifest}.
+ */
+public class DashManifestTest extends TestCase {
+
+  private static final UtcTimingElement DUMMY_UTC_TIMING = new UtcTimingElement("", "");
+  private static final List<SchemeValuePair> DUMMY_ACCESSIBILITY_DESCRIPTORS =
+      Collections.emptyList();
+  private static final SingleSegmentBase DUMMY_SEGMENT_BASE = new SingleSegmentBase();
+  private static final Format DUMMY_FORMAT = Format.createSampleFormat("", "", 0);
+
+  public void testCopy() throws Exception {
+    Representation[][][] representations = newRepresentations(3, 2, 3);
+    DashManifest sourceManifest = newDashManifest(10,
+        newPeriod("1", 1,
+            newAdaptationSet(2, representations[0][0]),
+            newAdaptationSet(3, representations[0][1])),
+        newPeriod("4", 4,
+            newAdaptationSet(5, representations[1][0]),
+            newAdaptationSet(6, representations[1][1])),
+        newPeriod("7", 7,
+            newAdaptationSet(8, representations[2][0]),
+            newAdaptationSet(9, representations[2][1])));
+
+    List<RepresentationKey> keys = Arrays.asList(
+        new RepresentationKey(0, 0, 0),
+        new RepresentationKey(0, 0, 1),
+        new RepresentationKey(0, 1, 2),
+
+        new RepresentationKey(1, 0, 1),
+        new RepresentationKey(1, 1, 0),
+        new RepresentationKey(1, 1, 2),
+
+        new RepresentationKey(2, 0, 1),
+        new RepresentationKey(2, 0, 2),
+        new RepresentationKey(2, 1, 0));
+    // Keys don't need to be in any particular order
+    Collections.shuffle(keys, new Random(0));
+
+    DashManifest copyManifest = sourceManifest.copy(keys);
+
+    DashManifest expectedManifest = newDashManifest(10,
+        newPeriod("1", 1,
+            newAdaptationSet(2, representations[0][0][0], representations[0][0][1]),
+            newAdaptationSet(3, representations[0][1][2])),
+        newPeriod("4", 4,
+            newAdaptationSet(5, representations[1][0][1]),
+            newAdaptationSet(6, representations[1][1][0], representations[1][1][2])),
+        newPeriod("7", 7,
+            newAdaptationSet(8, representations[2][0][1], representations[2][0][2]),
+            newAdaptationSet(9, representations[2][1][0])));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  public void testCopySameAdaptationIndexButDifferentPeriod() throws Exception {
+    Representation[][][] representations = newRepresentations(2, 1, 1);
+    DashManifest sourceManifest = newDashManifest(10,
+        newPeriod("1", 1,
+            newAdaptationSet(2, representations[0][0])),
+        newPeriod("4", 4,
+            newAdaptationSet(5, representations[1][0])));
+
+    DashManifest copyManifest = sourceManifest.copy(Arrays.asList(
+        new RepresentationKey(0, 0, 0),
+        new RepresentationKey(1, 0, 0)));
+
+    DashManifest expectedManifest = newDashManifest(10,
+        newPeriod("1", 1,
+            newAdaptationSet(2, representations[0][0])),
+        newPeriod("4", 4,
+            newAdaptationSet(5, representations[1][0])));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  public void testCopySkipPeriod() throws Exception {
+    Representation[][][] representations = newRepresentations(3, 2, 3);
+    DashManifest sourceManifest = newDashManifest(10,
+        newPeriod("1", 1,
+            newAdaptationSet(2, representations[0][0]),
+            newAdaptationSet(3, representations[0][1])),
+        newPeriod("4", 4,
+            newAdaptationSet(5, representations[1][0]),
+            newAdaptationSet(6, representations[1][1])),
+        newPeriod("7", 7,
+            newAdaptationSet(8, representations[2][0]),
+            newAdaptationSet(9, representations[2][1])));
+
+    DashManifest copyManifest = sourceManifest.copy(Arrays.asList(
+        new RepresentationKey(0, 0, 0),
+        new RepresentationKey(0, 0, 1),
+        new RepresentationKey(0, 1, 2),
+
+        new RepresentationKey(2, 0, 1),
+        new RepresentationKey(2, 0, 2),
+        new RepresentationKey(2, 1, 0)));
+
+    DashManifest expectedManifest = newDashManifest(7,
+        newPeriod("1", 1,
+            newAdaptationSet(2, representations[0][0][0], representations[0][0][1]),
+            newAdaptationSet(3, representations[0][1][2])),
+        newPeriod("7", 4,
+            newAdaptationSet(8, representations[2][0][1], representations[2][0][2]),
+            newAdaptationSet(9, representations[2][1][0])));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  private static void assertManifestEquals(DashManifest expected, DashManifest actual) {
+    assertEquals(expected.availabilityStartTime, actual.availabilityStartTime);
+    assertEquals(expected.duration, actual.duration);
+    assertEquals(expected.minBufferTime, actual.minBufferTime);
+    assertEquals(expected.dynamic, actual.dynamic);
+    assertEquals(expected.minUpdatePeriod, actual.minUpdatePeriod);
+    assertEquals(expected.timeShiftBufferDepth, actual.timeShiftBufferDepth);
+    assertEquals(expected.suggestedPresentationDelay, actual.suggestedPresentationDelay);
+    assertEquals(expected.utcTiming, actual.utcTiming);
+    assertEquals(expected.location, actual.location);
+    assertEquals(expected.getPeriodCount(), actual.getPeriodCount());
+    for (int i = 0; i < expected.getPeriodCount(); i++) {
+      Period expectedPeriod = expected.getPeriod(i);
+      Period actualPeriod = actual.getPeriod(i);
+      assertEquals(expectedPeriod.id, actualPeriod.id);
+      assertEquals(expectedPeriod.startMs, actualPeriod.startMs);
+      List<AdaptationSet> expectedAdaptationSets = expectedPeriod.adaptationSets;
+      List<AdaptationSet> actualAdaptationSets = actualPeriod.adaptationSets;
+      assertEquals(expectedAdaptationSets.size(), actualAdaptationSets.size());
+      for (int j = 0; j < expectedAdaptationSets.size(); j++) {
+        AdaptationSet expectedAdaptationSet = expectedAdaptationSets.get(j);
+        AdaptationSet actualAdaptationSet = actualAdaptationSets.get(j);
+        assertEquals(expectedAdaptationSet.id, actualAdaptationSet.id);
+        assertEquals(expectedAdaptationSet.type, actualAdaptationSet.type);
+        assertEquals(expectedAdaptationSet.accessibilityDescriptors,
+            actualAdaptationSet.accessibilityDescriptors);
+        assertEquals(expectedAdaptationSet.representations, actualAdaptationSet.representations);
+      }
+    }
+  }
+
+  private static Representation[][][] newRepresentations(int periodCount, int adaptationSetCounts,
+      int representationCounts) {
+    Representation[][][] representations = new Representation[periodCount][][];
+    for (int i = 0; i < periodCount; i++) {
+      representations[i] = new Representation[adaptationSetCounts][];
+      for (int j = 0; j < adaptationSetCounts; j++) {
+        representations[i][j] = new Representation[representationCounts];
+        for (int k = 0; k < representationCounts; k++) {
+          representations[i][j][k] = newRepresentation();
+        }
+      }
+    }
+    return representations;
+  }
+
+  private static Representation newRepresentation() {
+    return Representation.newInstance("", 0, DUMMY_FORMAT, "", DUMMY_SEGMENT_BASE);
+  }
+
+  private static DashManifest newDashManifest(int duration, Period... periods) {
+    return new DashManifest(0, duration, 1, false, 2, 3, 4, DUMMY_UTC_TIMING, Uri.EMPTY,
+        Arrays.asList(periods));
+  }
+
+  private static Period newPeriod(String id, int startMs, AdaptationSet... adaptationSets) {
+    return new Period(id, startMs, Arrays.asList(adaptationSets));
+  }
+
+  private static AdaptationSet newAdaptationSet(int seed, Representation... representations) {
+    return new AdaptationSet(++seed, ++seed, Arrays.asList(representations),
+        DUMMY_ACCESSIBILITY_DESCRIPTORS);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
index 008cd0e556..5d10aba1ae 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
@@ -29,13 +29,13 @@ public void testGetCacheKey() {
     String uri = "http://www.google.com";
     SegmentBase base = new SingleSegmentBase(new RangedUri(null, 0, 1), 1, 0, 1, 1);
     Format format = Format.createVideoContainerFormat("0", MimeTypes.APPLICATION_MP4, null,
-        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null);
+        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null, 0);
     Representation representation = Representation.newInstance("test_stream_1", 3, format, uri,
         base);
     assertEquals("test_stream_1.0.3", representation.getCacheKey());
 
     format = Format.createVideoContainerFormat("150", MimeTypes.APPLICATION_MP4, null,
-        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null);
+        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null, 0);
     representation = Representation.newInstance("test_stream_1", Representation.REVISION_ID_DEFAULT,
         format, uri, base);
     assertEquals("test_stream_1.150.-1", representation.getCacheKey());
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
index 488341d4f3..aa279f23f4 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -18,6 +18,8 @@
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.nio.charset.Charset;
@@ -29,70 +31,98 @@
  */
 public class HlsMasterPlaylistParserTest extends TestCase {
 
-  public void testParseMasterPlaylist() {
-    Uri playlistUri = Uri.parse("https://example.com/test.m3u8");
-    String playlistString = "#EXTM3U\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
-        + "http://example.com/low.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
-        + "http://example.com/spaces_in_codecs.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=384x160\n"
-        + "http://example.com/mid.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=7680000\n"
-        + "http://example.com/hi.m3u8\n"
-        + "\n"
-        + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
-        + "http://example.com/audio-only.m3u8";
-    ByteArrayInputStream inputStream = new ByteArrayInputStream(
-        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+  private static final String PLAYLIST_URI = "https://example.com/test.m3u8";
+
+  private static final String MASTER_PLAYLIST = " #EXTM3U \n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+      + "http://example.com/low.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
+      + "http://example.com/spaces_in_codecs.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=384x160\n"
+      + "http://example.com/mid.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=7680000\n"
+      + "http://example.com/hi.m3u8\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
+      + "http://example.com/audio-only.m3u8";
+
+  private static final String PLAYLIST_WITH_INVALID_HEADER = "#EXTMU3\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+      + "http://example.com/low.m3u8\n";
+
+  private static final String MASTER_PLAYLIST_WITH_CC = " #EXTM3U \n"
+      + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,LANGUAGE=\"es\",NAME=\"Eng\",INSTREAM-ID=\"SERVICE4\"\n"
+      + "\n"
+      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+      + "http://example.com/low.m3u8\n";
+
+  public void testParseMasterPlaylist() throws IOException{
+    HlsMasterPlaylist masterPlaylist = parseMasterPlaylist(PLAYLIST_URI, MASTER_PLAYLIST);
+
+    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
+    assertNotNull(variants);
+    assertEquals(5, variants.size());
+
+    assertEquals(1280000, variants.get(0).format.bitrate);
+    assertNotNull(variants.get(0).format.codecs);
+    assertEquals("mp4a.40.2,avc1.66.30", variants.get(0).format.codecs);
+    assertEquals(304, variants.get(0).format.width);
+    assertEquals(128, variants.get(0).format.height);
+    assertEquals("http://example.com/low.m3u8", variants.get(0).url);
+
+    assertEquals(1280000, variants.get(1).format.bitrate);
+    assertNotNull(variants.get(1).format.codecs);
+    assertEquals("mp4a.40.2 , avc1.66.30 ", variants.get(1).format.codecs);
+    assertEquals("http://example.com/spaces_in_codecs.m3u8", variants.get(1).url);
+
+    assertEquals(2560000, variants.get(2).format.bitrate);
+    assertEquals(null, variants.get(2).format.codecs);
+    assertEquals(384, variants.get(2).format.width);
+    assertEquals(160, variants.get(2).format.height);
+    assertEquals("http://example.com/mid.m3u8", variants.get(2).url);
+
+    assertEquals(7680000, variants.get(3).format.bitrate);
+    assertEquals(null, variants.get(3).format.codecs);
+    assertEquals(Format.NO_VALUE, variants.get(3).format.width);
+    assertEquals(Format.NO_VALUE, variants.get(3).format.height);
+    assertEquals("http://example.com/hi.m3u8", variants.get(3).url);
+
+    assertEquals(65000, variants.get(4).format.bitrate);
+    assertNotNull(variants.get(4).format.codecs);
+    assertEquals("mp4a.40.5", variants.get(4).format.codecs);
+    assertEquals(Format.NO_VALUE, variants.get(4).format.width);
+    assertEquals(Format.NO_VALUE, variants.get(4).format.height);
+    assertEquals("http://example.com/audio-only.m3u8", variants.get(4).url);
+  }
+
+  public void testPlaylistWithInvalidHeader() throws IOException {
     try {
-      HlsPlaylist playlist = new HlsPlaylistParser().parse(playlistUri, inputStream);
-      assertNotNull(playlist);
-      assertEquals(HlsPlaylist.TYPE_MASTER, playlist.type);
-
-      HlsMasterPlaylist masterPlaylist = (HlsMasterPlaylist) playlist;
-
-      List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
-      assertNotNull(variants);
-      assertEquals(5, variants.size());
-
-      assertEquals(1280000, variants.get(0).format.bitrate);
-      assertNotNull(variants.get(0).format.codecs);
-      assertEquals("mp4a.40.2,avc1.66.30", variants.get(0).format.codecs);
-      assertEquals(304, variants.get(0).format.width);
-      assertEquals(128, variants.get(0).format.height);
-      assertEquals("http://example.com/low.m3u8", variants.get(0).url);
-
-      assertEquals(1280000, variants.get(1).format.bitrate);
-      assertNotNull(variants.get(1).format.codecs);
-      assertEquals("mp4a.40.2 , avc1.66.30 ", variants.get(1).format.codecs);
-      assertEquals("http://example.com/spaces_in_codecs.m3u8", variants.get(1).url);
-
-      assertEquals(2560000, variants.get(2).format.bitrate);
-      assertEquals(null, variants.get(2).format.codecs);
-      assertEquals(384, variants.get(2).format.width);
-      assertEquals(160, variants.get(2).format.height);
-      assertEquals("http://example.com/mid.m3u8", variants.get(2).url);
-
-      assertEquals(7680000, variants.get(3).format.bitrate);
-      assertEquals(null, variants.get(3).format.codecs);
-      assertEquals(Format.NO_VALUE, variants.get(3).format.width);
-      assertEquals(Format.NO_VALUE, variants.get(3).format.height);
-      assertEquals("http://example.com/hi.m3u8", variants.get(3).url);
-
-      assertEquals(65000, variants.get(4).format.bitrate);
-      assertNotNull(variants.get(4).format.codecs);
-      assertEquals("mp4a.40.5", variants.get(4).format.codecs);
-      assertEquals(Format.NO_VALUE, variants.get(4).format.width);
-      assertEquals(Format.NO_VALUE, variants.get(4).format.height);
-      assertEquals("http://example.com/audio-only.m3u8", variants.get(4).url);
-    } catch (IOException exception) {
-      fail(exception.getMessage());
+      parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_INVALID_HEADER);
+      fail("Expected exception not thrown.");
+    } catch (ParserException e) {
+      // Expected due to invalid header.
     }
   }
 
+  public void testPlaylistWithClosedCaption() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, MASTER_PLAYLIST_WITH_CC);
+    assertEquals(1, playlist.muxedCaptionFormats.size());
+    Format closedCaptionFormat = playlist.muxedCaptionFormats.get(0);
+    assertEquals(MimeTypes.APPLICATION_CEA708, closedCaptionFormat.sampleMimeType);
+    assertEquals(4, closedCaptionFormat.accessibilityChannel);
+    assertEquals("es", closedCaptionFormat.language);
+  }
+
+  private static HlsMasterPlaylist parseMasterPlaylist(String uri, String playlistString)
+      throws IOException {
+    Uri playlistUri = Uri.parse(uri);
+    ByteArrayInputStream inputStream = new ByteArrayInputStream(
+        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    return (HlsMasterPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
index 67ec907d61..3d976353cc 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -34,6 +35,8 @@ public void testParseMediaPlaylist() {
     Uri playlistUri = Uri.parse("https://example.com/test.m3u8");
     String playlistString = "#EXTM3U\n"
         + "#EXT-X-VERSION:3\n"
+        + "#EXT-X-PLAYLIST-TYPE:VOD\n"
+        + "#EXT-X-START:TIME-OFFSET=-25"
         + "#EXT-X-TARGETDURATION:8\n"
         + "#EXT-X-MEDIA-SEQUENCE:2679\n"
         + "#EXT-X-DISCONTINUITY-SEQUENCE:4\n"
@@ -70,62 +73,69 @@ public void testParseMediaPlaylist() {
       assertEquals(HlsPlaylist.TYPE_MEDIA, playlist.type);
 
       HlsMediaPlaylist mediaPlaylist = (HlsMediaPlaylist) playlist;
+      assertEquals(HlsMediaPlaylist.PLAYLIST_TYPE_VOD, mediaPlaylist.playlistType);
+      assertEquals(mediaPlaylist.durationUs - 25000000, mediaPlaylist.startOffsetUs);
 
       assertEquals(2679, mediaPlaylist.mediaSequence);
       assertEquals(3, mediaPlaylist.version);
-      assertEquals(true, mediaPlaylist.hasEndTag);
-      List<HlsMediaPlaylist.Segment> segments = mediaPlaylist.segments;
+      assertTrue(mediaPlaylist.hasEndTag);
+      List<Segment> segments = mediaPlaylist.segments;
       assertNotNull(segments);
       assertEquals(5, segments.size());
 
-      assertEquals(4, segments.get(0).discontinuitySequenceNumber);
-      assertEquals(7975000, segments.get(0).durationUs);
-      assertEquals(false, segments.get(0).isEncrypted);
-      assertEquals(null, segments.get(0).encryptionKeyUri);
-      assertEquals(null, segments.get(0).encryptionIV);
-      assertEquals(51370, segments.get(0).byterangeLength);
-      assertEquals(0, segments.get(0).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2679.ts", segments.get(0).url);
+      Segment segment = segments.get(0);
+      assertEquals(4, mediaPlaylist.discontinuitySequence + segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertFalse(segment.isEncrypted);
+      assertEquals(null, segment.encryptionKeyUri);
+      assertEquals(null, segment.encryptionIV);
+      assertEquals(51370, segment.byterangeLength);
+      assertEquals(0, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2679.ts", segment.url);
 
-      assertEquals(4, segments.get(1).discontinuitySequenceNumber);
-      assertEquals(7975000, segments.get(1).durationUs);
-      assertEquals(true, segments.get(1).isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2680", segments.get(1).encryptionKeyUri);
-      assertEquals("0x1566B", segments.get(1).encryptionIV);
-      assertEquals(51501, segments.get(1).byterangeLength);
-      assertEquals(2147483648L, segments.get(1).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2680.ts", segments.get(1).url);
+      segment = segments.get(1);
+      assertEquals(0, segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertTrue(segment.isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2680", segment.encryptionKeyUri);
+      assertEquals("0x1566B", segment.encryptionIV);
+      assertEquals(51501, segment.byterangeLength);
+      assertEquals(2147483648L, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2680.ts", segment.url);
 
-      assertEquals(4, segments.get(2).discontinuitySequenceNumber);
-      assertEquals(7941000, segments.get(2).durationUs);
-      assertEquals(false, segments.get(2).isEncrypted);
-      assertEquals(null, segments.get(2).encryptionKeyUri);
-      assertEquals(null, segments.get(2).encryptionIV);
-      assertEquals(51501, segments.get(2).byterangeLength);
-      assertEquals(2147535149L, segments.get(2).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2681.ts", segments.get(2).url);
+      segment = segments.get(2);
+      assertEquals(0, segment.relativeDiscontinuitySequence);
+      assertEquals(7941000, segment.durationUs);
+      assertFalse(segment.isEncrypted);
+      assertEquals(null, segment.encryptionKeyUri);
+      assertEquals(null, segment.encryptionIV);
+      assertEquals(51501, segment.byterangeLength);
+      assertEquals(2147535149L, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2681.ts", segment.url);
 
-      assertEquals(5, segments.get(3).discontinuitySequenceNumber);
-      assertEquals(7975000, segments.get(3).durationUs);
-      assertEquals(true, segments.get(3).isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2682", segments.get(3).encryptionKeyUri);
+      segment = segments.get(3);
+      assertEquals(1, segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertTrue(segment.isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2682", segment.encryptionKeyUri);
       // 0xA7A == 2682.
-      assertNotNull(segments.get(3).encryptionIV);
-      assertEquals("A7A", segments.get(3).encryptionIV.toUpperCase(Locale.getDefault()));
-      assertEquals(51740, segments.get(3).byterangeLength);
-      assertEquals(2147586650L, segments.get(3).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2682.ts", segments.get(3).url);
+      assertNotNull(segment.encryptionIV);
+      assertEquals("A7A", segment.encryptionIV.toUpperCase(Locale.getDefault()));
+      assertEquals(51740, segment.byterangeLength);
+      assertEquals(2147586650L, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2682.ts", segment.url);
 
-      assertEquals(5, segments.get(4).discontinuitySequenceNumber);
-      assertEquals(7975000, segments.get(4).durationUs);
-      assertEquals(true, segments.get(4).isEncrypted);
-      assertEquals("https://priv.example.com/key.php?r=2682", segments.get(4).encryptionKeyUri);
+      segment = segments.get(4);
+      assertEquals(1, segment.relativeDiscontinuitySequence);
+      assertEquals(7975000, segment.durationUs);
+      assertTrue(segment.isEncrypted);
+      assertEquals("https://priv.example.com/key.php?r=2682", segment.encryptionKeyUri);
       // 0xA7B == 2683.
-      assertNotNull(segments.get(4).encryptionIV);
-      assertEquals("A7B", segments.get(4).encryptionIV.toUpperCase(Locale.getDefault()));
-      assertEquals(C.LENGTH_UNSET, segments.get(4).byterangeLength);
-      assertEquals(0, segments.get(4).byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2683.ts", segments.get(4).url);
+      assertNotNull(segment.encryptionIV);
+      assertEquals("A7B", segment.encryptionIV.toUpperCase(Locale.getDefault()));
+      assertEquals(C.LENGTH_UNSET, segment.byterangeLength);
+      assertEquals(0, segment.byterangeOffset);
+      assertEquals("https://priv.example.com/fileSequence2683.ts", segment.url);
     } catch (IOException exception) {
       fail(exception.getMessage());
     }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
index 18e39be93c..6689d73ff1 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
@@ -20,14 +20,16 @@
 import android.test.MoreAsserts;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
-import com.google.android.exoplayer2.testutil.FakeDataSource.Builder;
-import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.FileDataSource;
+import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
 
-/** Unit tests for {@link CacheDataSource}. */
+/**
+ * Unit tests for {@link CacheDataSource}.
+ */
 public class CacheDataSourceTest extends InstrumentationTestCase {
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
@@ -40,13 +42,13 @@
 
   @Override
   protected void setUp() throws Exception {
-    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
     simpleCache = new SimpleCache(cacheDir, new NoOpCacheEvictor());
   }
 
   @Override
   protected void tearDown() throws Exception {
-    TestUtil.recursiveDelete(cacheDir);
+    Util.recursiveDelete(cacheDir);
   }
 
   public void testMaxCacheFileSize() throws Exception {
@@ -117,9 +119,22 @@ public void testContentLengthEdgeCases() throws Exception {
         C.LENGTH_UNSET, KEY_2)));
   }
 
+  public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
+    CacheDataSource cacheDataSource = createCacheDataSource(false, true,
+        CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
+    assertReadData(cacheDataSource, true, 0, C.LENGTH_UNSET);
+    MoreAsserts.assertEmpty(simpleCache.getKeys());
+  }
+
+  public void testReadOnlyCache() throws Exception {
+    CacheDataSource cacheDataSource = createCacheDataSource(false, false, 0, null);
+    assertReadDataContentLength(cacheDataSource, false, false);
+    assertEquals(0, cacheDir.list().length);
+  }
+
   private void assertCacheAndRead(boolean unboundedRequest, boolean simulateUnknownLength)
       throws IOException {
-    // Read all data from upstream and cache
+    // Read all data from upstream and write to cache
     CacheDataSource cacheDataSource = createCacheDataSource(false, simulateUnknownLength);
     assertReadDataContentLength(cacheDataSource, unboundedRequest, simulateUnknownLength);
 
@@ -169,15 +184,27 @@ private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLeng
 
   private CacheDataSource createCacheDataSource(boolean setReadException,
       boolean simulateUnknownLength) {
-    Builder builder = new Builder();
+    return createCacheDataSource(setReadException, simulateUnknownLength,
+        CacheDataSource.FLAG_BLOCK_ON_CACHE);
+  }
+
+  private CacheDataSource createCacheDataSource(boolean setReadException,
+      boolean simulateUnknownLength, @CacheDataSource.Flags int flags) {
+    return createCacheDataSource(setReadException, simulateUnknownLength, flags,
+        new CacheDataSink(simpleCache, MAX_CACHE_FILE_SIZE));
+  }
+
+  private CacheDataSource createCacheDataSource(boolean setReadException,
+      boolean simulateUnknownLength, @CacheDataSource.Flags int flags,
+      CacheDataSink cacheWriteDataSink) {
+    FakeDataSource.Builder builder = new FakeDataSource.Builder();
     if (setReadException) {
       builder.appendReadError(new IOException("Shouldn't read from upstream"));
     }
-    builder.setSimulateUnknownLength(simulateUnknownLength);
-    builder.appendReadData(TEST_DATA);
-    FakeDataSource upstream = builder.build();
-    return new CacheDataSource(simpleCache, upstream, CacheDataSource.FLAG_BLOCK_ON_CACHE,
-        MAX_CACHE_FILE_SIZE);
+    FakeDataSource upstream =
+        builder.setSimulateUnknownLength(simulateUnknownLength).appendReadData(TEST_DATA).build();
+    return new CacheDataSource(simpleCache, upstream, new FileDataSource(), cacheWriteDataSink,
+        flags, null);
   }
 
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
new file mode 100644
index 0000000000..70a7d797c1
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.content.Context;
+import android.net.Uri;
+import android.test.AndroidTestCase;
+import android.test.MoreAsserts;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.FakeDataSource;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.upstream.DataSink;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.FileDataSource;
+import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
+import com.google.android.exoplayer2.upstream.crypto.AesCipherDataSink;
+import com.google.android.exoplayer2.upstream.crypto.AesCipherDataSource;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+
+/**
+ * Additional tests for {@link CacheDataSource}.
+ */
+public class CacheDataSourceTest2 extends AndroidTestCase {
+
+  private static final String EXO_CACHE_DIR = "exo";
+  private static final int EXO_CACHE_MAX_FILESIZE = 128;
+
+  private static final Uri URI = Uri.parse("http://test.com/content");
+  private static final String KEY = "key";
+  private static final byte[] DATA = TestUtil.buildTestData(8 * EXO_CACHE_MAX_FILESIZE + 1);
+
+  // A DataSpec that covers the full file.
+  private static final DataSpec FULL = new DataSpec(URI, 0, DATA.length, KEY);
+
+  private static final int OFFSET_ON_BOUNDARY = EXO_CACHE_MAX_FILESIZE;
+  // A DataSpec that starts at 0 and extends to a cache file boundary.
+  private static final DataSpec END_ON_BOUNDARY = new DataSpec(URI, 0, OFFSET_ON_BOUNDARY, KEY);
+  // A DataSpec that starts on the same boundary and extends to the end of the file.
+  private static final DataSpec START_ON_BOUNDARY = new DataSpec(URI, OFFSET_ON_BOUNDARY,
+      DATA.length - OFFSET_ON_BOUNDARY, KEY);
+
+  private static final int OFFSET_OFF_BOUNDARY = EXO_CACHE_MAX_FILESIZE * 2 + 1;
+  // A DataSpec that starts at 0 and extends to just past a cache file boundary.
+  private static final DataSpec END_OFF_BOUNDARY = new DataSpec(URI, 0, OFFSET_OFF_BOUNDARY, KEY);
+  // A DataSpec that starts on the same boundary and extends to the end of the file.
+  private static final DataSpec START_OFF_BOUNDARY = new DataSpec(URI, OFFSET_OFF_BOUNDARY,
+      DATA.length - OFFSET_OFF_BOUNDARY, KEY);
+
+  public void testWithoutEncryption() throws IOException {
+    testReads(false);
+  }
+
+  public void testWithEncryption() throws IOException {
+    testReads(true);
+  }
+
+  private void testReads(boolean useEncryption) throws IOException {
+    FakeDataSource upstreamSource = buildFakeUpstreamSource();
+    CacheDataSource source = buildCacheDataSource(getContext(), upstreamSource, useEncryption);
+    // First read, should arrive from upstream.
+    testRead(END_ON_BOUNDARY, source);
+    assertSingleOpen(upstreamSource, 0, OFFSET_ON_BOUNDARY);
+    // Second read, should arrive from upstream.
+    testRead(START_OFF_BOUNDARY, source);
+    assertSingleOpen(upstreamSource, OFFSET_OFF_BOUNDARY, DATA.length);
+    // Second read, should arrive part from cache and part from upstream.
+    testRead(END_OFF_BOUNDARY, source);
+    assertSingleOpen(upstreamSource, OFFSET_ON_BOUNDARY, OFFSET_OFF_BOUNDARY);
+    // Third read, should arrive from cache.
+    testRead(FULL, source);
+    assertNoOpen(upstreamSource);
+    // Various reads, should all arrive from cache.
+    testRead(FULL, source);
+    assertNoOpen(upstreamSource);
+    testRead(START_ON_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+    testRead(END_ON_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+    testRead(START_OFF_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+    testRead(END_OFF_BOUNDARY, source);
+    assertNoOpen(upstreamSource);
+  }
+
+  private void testRead(DataSpec dataSpec, CacheDataSource source) throws IOException {
+    byte[] scratch = new byte[4096];
+    Random random = new Random(0);
+    source.open(dataSpec);
+    int position = (int) dataSpec.absoluteStreamPosition;
+    int bytesRead = 0;
+    while (bytesRead != C.RESULT_END_OF_INPUT) {
+      int maxBytesToRead = random.nextInt(scratch.length) + 1;
+      bytesRead = source.read(scratch, 0, maxBytesToRead);
+      if (bytesRead != C.RESULT_END_OF_INPUT) {
+        MoreAsserts.assertEquals(Arrays.copyOfRange(DATA, position, position + bytesRead),
+            Arrays.copyOf(scratch, bytesRead));
+        position += bytesRead;
+      }
+    }
+    source.close();
+  }
+
+  /**
+   * Asserts that a single {@link DataSource#open(DataSpec)} call has been made to the upstream
+   * source, with the specified start (inclusive) and end (exclusive) positions.
+   */
+  private void assertSingleOpen(FakeDataSource upstreamSource, int start, int end) {
+    DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
+    assertEquals(1, openedDataSpecs.length);
+    assertEquals(start, openedDataSpecs[0].position);
+    assertEquals(start, openedDataSpecs[0].absoluteStreamPosition);
+    assertEquals(end - start, openedDataSpecs[0].length);
+  }
+
+  /**
+   * Asserts that the upstream source was not opened.
+   */
+  private void assertNoOpen(FakeDataSource upstreamSource) {
+    DataSpec[] openedDataSpecs = upstreamSource.getAndClearOpenedDataSpecs();
+    assertEquals(0, openedDataSpecs.length);
+  }
+
+  private static FakeDataSource buildFakeUpstreamSource() {
+    return new FakeDataSource.Builder().appendReadData(DATA).build();
+  }
+
+  private static CacheDataSource buildCacheDataSource(Context context, DataSource upstreamSource,
+      boolean useAesEncryption) throws CacheException {
+    File cacheDir = context.getExternalCacheDir();
+    Cache cache = new SimpleCache(new File(cacheDir, EXO_CACHE_DIR), new NoOpCacheEvictor());
+    emptyCache(cache);
+
+    // Source and cipher
+    final String secretKey = "testKey:12345678";
+    DataSource file = new FileDataSource();
+    DataSource cacheReadDataSource = useAesEncryption
+        ? new AesCipherDataSource(Util.getUtf8Bytes(secretKey), file) : file;
+
+    // Sink and cipher
+    CacheDataSink cacheSink = new CacheDataSink(cache, EXO_CACHE_MAX_FILESIZE);
+    byte[] scratch = new byte[3897];
+    DataSink cacheWriteDataSink = useAesEncryption
+        ? new AesCipherDataSink(Util.getUtf8Bytes(secretKey), cacheSink, scratch) : cacheSink;
+
+    return new CacheDataSource(cache,
+        upstreamSource,
+        cacheReadDataSource,
+        cacheWriteDataSink,
+        CacheDataSource.FLAG_BLOCK_ON_CACHE,
+        null); // eventListener
+  }
+
+  private static void emptyCache(Cache cache) throws CacheException {
+    for (String key : cache.getKeys()) {
+      for (CacheSpan span : cache.getCachedSpans(key)) {
+        cache.removeSpan(span);
+      }
+    }
+    // Sanity check that the cache really is empty now.
+    assertTrue(cache.getKeys().isEmpty());
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
index dd4de7cce2..7f6e203c20 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
@@ -4,7 +4,7 @@
 import android.test.MoreAsserts;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -36,13 +36,13 @@
 
   @Override
   public void setUp() throws Exception {
-    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
     index = new CachedContentIndex(cacheDir);
   }
 
   @Override
   protected void tearDown() throws Exception {
-    TestUtil.recursiveDelete(cacheDir);
+    Util.recursiveDelete(cacheDir);
   }
 
   public void testAddGetRemove() throws Exception {
@@ -163,7 +163,7 @@ public void testGetNewId() throws Exception {
 
   public void testEncryption() throws Exception {
     byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
-    byte[] key2 = "bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    byte[] key2 = "Foo12345Foo12345".getBytes(C.UTF8_NAME); // 128 bit key
 
     assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
         new CachedContentIndex(cacheDir, key));
@@ -181,7 +181,7 @@ public void testEncryption() throws Exception {
     // Assert file content is different
     FileInputStream fis1 = new FileInputStream(file1);
     FileInputStream fis2 = new FileInputStream(file2);
-    for (int b; (b = fis1.read()) == fis2.read();) {
+    for (int b; (b = fis1.read()) == fis2.read(); ) {
       assertTrue(b != -1);
     }
 
@@ -205,6 +205,12 @@ public void testEncryption() throws Exception {
     // Non encrypted index file can be read even when encryption key provided.
     assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir),
         new CachedContentIndex(cacheDir, key));
+
+    // Test multiple store() calls
+    CachedContentIndex index = new CachedContentIndex(cacheDir, key);
+    index.addNew(new CachedContent(15, "key3", 110));
+    index.store();
+    assertStoredAndLoadedEqual(index, new CachedContentIndex(cacheDir, key));
   }
 
   private void assertStoredAndLoadedEqual(CachedContentIndex index, CachedContentIndex index2)
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
new file mode 100644
index 0000000000..f2e199578c
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.extractor.ChunkIndex;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.io.IOException;
+import org.mockito.Mock;
+
+/**
+ * Tests for {@link CachedRegionTracker}.
+ */
+public final class CachedRegionTrackerTest extends InstrumentationTestCase {
+
+  private static final String CACHE_KEY = "abc";
+  private static final long MS_IN_US = 1000;
+
+  // 5 chunks, each 20 bytes long and 100 ms long.
+  private static final ChunkIndex CHUNK_INDEX = new ChunkIndex(
+      new int[] {20, 20, 20, 20, 20},
+      new long[] {100, 120, 140, 160, 180},
+      new long[] {100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US},
+      new long[] {0, 100 * MS_IN_US, 200 * MS_IN_US, 300 * MS_IN_US, 400 * MS_IN_US});
+
+  @Mock private Cache cache;
+  private CachedRegionTracker tracker;
+
+  private CachedContentIndex index;
+  private File cacheDir;
+
+  @Override
+  protected void setUp() throws Exception {
+    TestUtil.setUpMockito(this);
+
+    tracker = new CachedRegionTracker(cache, CACHE_KEY, CHUNK_INDEX);
+
+    cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
+    index = new CachedContentIndex(cacheDir);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    Util.recursiveDelete(cacheDir);
+  }
+
+  public void testGetRegion_noSpansInCache() {
+    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(100));
+    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(150));
+  }
+
+  public void testGetRegion_fullyCached() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 100));
+
+    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(101));
+    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(121));
+  }
+
+  public void testGetRegion_partiallyCached() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 40));
+
+    assertEquals(200, tracker.getRegionEndTimeMs(101));
+    assertEquals(200, tracker.getRegionEndTimeMs(121));
+  }
+
+  public void testGetRegion_multipleSpanAddsJoinedCorrectly() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 20));
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(120, 20));
+
+    assertEquals(200, tracker.getRegionEndTimeMs(101));
+    assertEquals(200, tracker.getRegionEndTimeMs(121));
+  }
+
+  public void testGetRegion_fullyCachedThenPartiallyRemoved() throws Exception {
+    // Start with the full stream in cache.
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 100));
+
+    // Remove the middle bit.
+    tracker.onSpanRemoved(
+        cache,
+        newCacheSpan(140, 40));
+
+    assertEquals(200, tracker.getRegionEndTimeMs(101));
+    assertEquals(200, tracker.getRegionEndTimeMs(121));
+
+    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(181));
+  }
+
+  public void testGetRegion_subchunkEstimation() throws Exception {
+    tracker.onSpanAdded(
+        cache,
+        newCacheSpan(100, 10));
+
+    assertEquals(50, tracker.getRegionEndTimeMs(101));
+    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(111));
+  }
+
+  private CacheSpan newCacheSpan(int position, int length) throws IOException {
+    return SimpleCacheSpanTest.createCacheSpan(index, cacheDir, CACHE_KEY, position, length, 0);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
index 0b40cd7735..8c684b1cb3 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.test.InstrumentationTestCase;
-import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -48,13 +48,13 @@ public static CacheSpan createCacheSpan(CachedContentIndex index, File cacheDir,
 
   @Override
   protected void setUp() throws Exception {
-    cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
     index = new CachedContentIndex(cacheDir);
   }
 
   @Override
   protected void tearDown() throws Exception {
-    TestUtil.recursiveDelete(cacheDir);
+    Util.recursiveDelete(cacheDir);
   }
 
   public void testCacheFile() throws Exception {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
index 5f539c6213..1a6beeb6ba 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
@@ -16,12 +16,15 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.test.InstrumentationTestCase;
+import android.test.MoreAsserts;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.NavigableSet;
+import java.util.Random;
 import java.util.Set;
 
 /**
@@ -35,20 +38,20 @@
 
   @Override
   protected void setUp() throws Exception {
-    this.cacheDir = TestUtil.createTempFolder(getInstrumentation().getContext());
+    cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
   }
 
   @Override
   protected void tearDown() throws Exception {
-    TestUtil.recursiveDelete(cacheDir);
+    Util.recursiveDelete(cacheDir);
   }
 
   public void testCommittingOneFile() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
 
-    CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
-    assertFalse(cacheSpan.isCached);
-    assertTrue(cacheSpan.isOpenEnded());
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    assertFalse(cacheSpan1.isCached);
+    assertTrue(cacheSpan1.isOpenEnded());
 
     assertNull(simpleCache.startReadWriteNonBlocking(KEY_1, 0));
 
@@ -58,20 +61,33 @@ public void testCommittingOneFile() throws Exception {
     assertEquals(0, simpleCache.getCacheSpace());
     assertEquals(0, cacheDir.listFiles().length);
 
-    addCache(simpleCache, 0, 15);
+    addCache(simpleCache, KEY_1, 0, 15);
 
     Set<String> cachedKeys = simpleCache.getKeys();
     assertEquals(1, cachedKeys.size());
     assertTrue(cachedKeys.contains(KEY_1));
     cachedSpans = simpleCache.getCachedSpans(KEY_1);
     assertEquals(1, cachedSpans.size());
-    assertTrue(cachedSpans.contains(cacheSpan));
+    assertTrue(cachedSpans.contains(cacheSpan1));
     assertEquals(15, simpleCache.getCacheSpace());
 
-    cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
-    assertTrue(cacheSpan.isCached);
-    assertFalse(cacheSpan.isOpenEnded());
-    assertEquals(15, cacheSpan.length);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertTrue(cacheSpan2.isCached);
+    assertFalse(cacheSpan2.isOpenEnded());
+    assertEquals(15, cacheSpan2.length);
+    assertCachedDataReadCorrect(cacheSpan2);
+  }
+
+  public void testReadCacheWithoutReleasingWriteCacheSpan() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan2);
+    simpleCache.releaseHoleSpan(cacheSpan1);
   }
 
   public void testSetGetLength() throws Exception {
@@ -83,12 +99,12 @@ public void testSetGetLength() throws Exception {
 
     simpleCache.startReadWrite(KEY_1, 0);
 
-    addCache(simpleCache, 0, 15);
+    addCache(simpleCache, KEY_1, 0, 15);
 
     simpleCache.setContentLength(KEY_1, 150);
     assertEquals(150, simpleCache.getContentLength(KEY_1));
 
-    addCache(simpleCache, 140, 10);
+    addCache(simpleCache, KEY_1, 140, 10);
 
     // Check if values are kept after cache is reloaded.
     SimpleCache simpleCache2 = getSimpleCache();
@@ -107,16 +123,144 @@ public void testSetGetLength() throws Exception {
     assertEquals(150, simpleCache2.getContentLength(KEY_1));
   }
 
+  public void testReloadCache() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    simpleCache = getSimpleCache();
+
+    // read data back
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan2);
+  }
+
+  public void testEncryptedIndex() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    SimpleCache simpleCache = getEncryptedSimpleCache(key);
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    simpleCache = getEncryptedSimpleCache(key);
+
+    // read data back
+    CacheSpan cacheSpan2 = simpleCache.startReadWrite(KEY_1, 0);
+    assertCachedDataReadCorrect(cacheSpan2);
+  }
+
+  public void testEncryptedIndexWrongKey() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    SimpleCache simpleCache = getEncryptedSimpleCache(key);
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    byte[] key2 = "Foo12345Foo12345".getBytes(C.UTF8_NAME); // 128 bit key
+    simpleCache = getEncryptedSimpleCache(key2);
+
+    // Cache should be cleared
+    assertEquals(0, simpleCache.getKeys().size());
+    assertEquals(0, cacheDir.listFiles().length);
+  }
+
+  public void testEncryptedIndexLostKey() throws Exception {
+    byte[] key = "Bar12345Bar12345".getBytes(C.UTF8_NAME); // 128 bit key
+    SimpleCache simpleCache = getEncryptedSimpleCache(key);
+
+    // write data
+    CacheSpan cacheSpan1 = simpleCache.startReadWrite(KEY_1, 0);
+    addCache(simpleCache, KEY_1, 0, 15);
+    simpleCache.releaseHoleSpan(cacheSpan1);
+
+    // Reload cache
+    simpleCache = getSimpleCache();
+
+    // Cache should be cleared
+    assertEquals(0, simpleCache.getKeys().size());
+    assertEquals(0, cacheDir.listFiles().length);
+  }
+
+
+  public void testGetCachedBytes() throws Exception {
+    SimpleCache simpleCache = getSimpleCache();
+    CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
+
+    // No cached bytes, returns -'length'
+    assertEquals(-100, simpleCache.getCachedBytes(KEY_1, 0, 100));
+
+    // Position value doesn't affect the return value
+    assertEquals(-100, simpleCache.getCachedBytes(KEY_1, 20, 100));
+
+    addCache(simpleCache, KEY_1, 0, 15);
+
+    // Returns the length of a single span
+    assertEquals(15, simpleCache.getCachedBytes(KEY_1, 0, 100));
+
+    // Value is capped by the 'length'
+    assertEquals(10, simpleCache.getCachedBytes(KEY_1, 0, 10));
+
+    addCache(simpleCache, KEY_1, 15, 35);
+
+    // Returns the length of two adjacent spans
+    assertEquals(50, simpleCache.getCachedBytes(KEY_1, 0, 100));
+
+    addCache(simpleCache, KEY_1, 60, 10);
+
+    // Not adjacent span doesn't affect return value
+    assertEquals(50, simpleCache.getCachedBytes(KEY_1, 0, 100));
+
+    // Returns length of hole up to the next cached span
+    assertEquals(-5, simpleCache.getCachedBytes(KEY_1, 55, 100));
+
+    simpleCache.releaseHoleSpan(cacheSpan);
+  }
+
   private SimpleCache getSimpleCache() {
     return new SimpleCache(cacheDir, new NoOpCacheEvictor());
   }
 
-  private void addCache(SimpleCache simpleCache, int position, int length) throws IOException {
-    File file = simpleCache.startFile(KEY_1, position, length);
+  private SimpleCache getEncryptedSimpleCache(byte[] secretKey) {
+    return new SimpleCache(cacheDir, new NoOpCacheEvictor(), secretKey);
+  }
+
+  private static void addCache(SimpleCache simpleCache, String key, int position, int length)
+      throws IOException {
+    File file = simpleCache.startFile(key, position, length);
     FileOutputStream fos = new FileOutputStream(file);
-    fos.write(new byte[length]);
-    fos.close();
+    try {
+      fos.write(generateData(key, position, length));
+    } finally {
+      fos.close();
+    }
     simpleCache.commitFile(file);
   }
 
+  private static void assertCachedDataReadCorrect(CacheSpan cacheSpan) throws IOException {
+    assertTrue(cacheSpan.isCached);
+    byte[] expected = generateData(cacheSpan.key, (int) cacheSpan.position, (int) cacheSpan.length);
+    FileInputStream inputStream = new FileInputStream(cacheSpan.file);
+    try {
+      MoreAsserts.assertEquals(expected, Util.toByteArray(inputStream));
+    } finally {
+      inputStream.close();
+    }
+  }
+
+  private static byte[] generateData(String key, int position, int length) {
+    byte[] bytes = new byte[length];
+    new Random((long) (key.hashCode() ^ position)).nextBytes(bytes);
+    return bytes;
+  }
+
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
new file mode 100644
index 0000000000..b4e7e6e7f6
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Random;
+import javax.crypto.Cipher;
+import junit.framework.TestCase;
+
+/**
+ * Unit tests for {@link AesFlushingCipher}.
+ */
+public class AesFlushingCipherTest extends TestCase {
+
+  private static final int DATA_LENGTH = 65536;
+  private static final byte[] KEY = Util.getUtf8Bytes("testKey:12345678");
+  private static final long NONCE = 0;
+  private static final long START_OFFSET = 11;
+  private static final long RANDOM_SEED = 0x12345678;
+
+  private AesFlushingCipher encryptCipher;
+  private AesFlushingCipher decryptCipher;
+
+  @Override
+  protected void setUp() {
+    encryptCipher = new AesFlushingCipher(Cipher.ENCRYPT_MODE, KEY, NONCE, START_OFFSET);
+    decryptCipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, KEY, NONCE, START_OFFSET);
+  }
+
+  @Override
+  protected void tearDown() {
+    encryptCipher = null;
+    decryptCipher = null;
+  }
+
+  private long getMaxUnchangedBytesAllowedPostEncryption(long length) {
+    // Assuming that not more than 10% of the resultant bytes should be identical.
+    // The value of 10% is arbitrary, ciphers standards do not name a value.
+    return length / 10;
+  }
+
+  // Count the number of bytes that do not match.
+  private int getDifferingByteCount(byte[] data1, byte[] data2, int startOffset) {
+    int count = 0;
+    for (int i = startOffset; i < data1.length; i++) {
+      if (data1[i] != data2[i]) {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  // Count the number of bytes that do not match.
+  private int getDifferingByteCount(byte[] data1, byte[] data2) {
+    return getDifferingByteCount(data1, data2, 0);
+  }
+
+  // Test a single encrypt and decrypt call
+  public void testSingle() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+
+    encryptCipher.updateInPlace(data, 0, data.length);
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    decryptCipher.updateInPlace(data, 0, data.length);
+    int differingByteCount = getDifferingByteCount(reference, data);
+    assertEquals(0, differingByteCount);
+  }
+
+  // Test several encrypt and decrypt calls, each aligned on a 16 byte block size
+  public void testAligned() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+    Random random = new Random(RANDOM_SEED);
+
+    int offset = 0;
+    while (offset < data.length) {
+      int bytes = (1 + random.nextInt(50)) * 16;
+      bytes = Math.min(bytes, data.length - offset);
+      assertEquals(0, bytes % 16);
+      encryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    offset = 0;
+    while (offset < data.length) {
+      int bytes = (1 + random.nextInt(50)) * 16;
+      bytes = Math.min(bytes, data.length - offset);
+      assertEquals(0, bytes % 16);
+      decryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int differingByteCount = getDifferingByteCount(reference, data);
+    assertEquals(0, differingByteCount);
+  }
+
+  // Test several encrypt and decrypt calls, not aligned on block boundary
+  public void testUnAligned() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+    Random random = new Random(RANDOM_SEED);
+
+    // Encrypt
+    int offset = 0;
+    while (offset < data.length) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, data.length - offset);
+      encryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    offset = 0;
+    while (offset < data.length) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, data.length - offset);
+      decryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    int differingByteCount = getDifferingByteCount(reference, data);
+    assertEquals(0, differingByteCount);
+  }
+
+  // Test decryption starting from the middle of an encrypted block
+  public void testMidJoin() {
+    byte[] reference = TestUtil.buildTestData(DATA_LENGTH);
+    byte[] data = reference.clone();
+    Random random = new Random(RANDOM_SEED);
+
+    // Encrypt
+    int offset = 0;
+    while (offset < data.length) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, data.length - offset);
+      encryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+    }
+
+    // Verify
+    int unchangedByteCount = data.length - getDifferingByteCount(reference, data);
+    assertTrue(unchangedByteCount <= getMaxUnchangedBytesAllowedPostEncryption(data.length));
+
+    // Setup decryption from random location
+    offset = random.nextInt(4096);
+    decryptCipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, KEY, NONCE, offset + START_OFFSET);
+    int remainingLength = data.length - offset;
+    int originalOffset = offset;
+
+    // Decrypt
+    while (remainingLength > 0) {
+      int bytes = 1 + random.nextInt(4095);
+      bytes = Math.min(bytes, remainingLength);
+      decryptCipher.updateInPlace(data, offset, bytes);
+      offset += bytes;
+      remainingLength -= bytes;
+    }
+
+    // Verify
+    int differingByteCount = getDifferingByteCount(reference, data, originalOffset);
+    assertEquals(0, differingByteCount);
+  }
+
+}
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java
index 7cdbb9a5b1..6c5d7c76f7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/util/AtomicFileTest.java
@@ -17,7 +17,6 @@
 package com.google.android.exoplayer2.util;
 
 import android.test.InstrumentationTestCase;
-import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -34,14 +33,14 @@
 
   @Override
   public void setUp() throws Exception {
-    tempFolder = TestUtil.createTempFolder(getInstrumentation().getContext());
+    tempFolder = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
     file = new File(tempFolder, "atomicFile");
     atomicFile = new AtomicFile(file);
   }
 
   @Override
   protected void tearDown() throws Exception {
-    TestUtil.recursiveDelete(tempFolder);
+    Util.recursiveDelete(tempFolder);
   }
 
   public void testDelete() throws Exception {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
index a747930152..49719b95f7 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
@@ -371,6 +371,73 @@ public void testReadEmptyString() {
     assertNull(parser.readLine());
   }
 
+  public void testReadNullTerminatedStringWithLengths() {
+    byte[] bytes = new byte[] {
+        'f', 'o', 'o', 0, 'b', 'a', 'r', 0
+    };
+    // Test with lengths that match NUL byte positions.
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readNullTerminatedString(4));
+    assertEquals(4, parser.getPosition());
+    assertEquals("bar", parser.readNullTerminatedString(4));
+    assertEquals(8, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with lengths that do not match NUL byte positions.
+    parser = new ParsableByteArray(bytes);
+    assertEquals("fo", parser.readNullTerminatedString(2));
+    assertEquals(2, parser.getPosition());
+    assertEquals("o", parser.readNullTerminatedString(2));
+    assertEquals(4, parser.getPosition());
+    assertEquals("bar", parser.readNullTerminatedString(3));
+    assertEquals(7, parser.getPosition());
+    assertEquals("", parser.readNullTerminatedString(1));
+    assertEquals(8, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit at NUL
+    parser = new ParsableByteArray(bytes, 4);
+    assertEquals("foo", parser.readNullTerminatedString(4));
+    assertEquals(4, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit before NUL
+    parser = new ParsableByteArray(bytes, 3);
+    assertEquals("foo", parser.readNullTerminatedString(3));
+    assertEquals(3, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+  }
+
+  public void testReadNullTerminatedString() {
+    byte[] bytes = new byte[] {
+        'f', 'o', 'o', 0, 'b', 'a', 'r', 0
+    };
+    // Test normal case.
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals(4, parser.getPosition());
+    assertEquals("bar", parser.readNullTerminatedString());
+    assertEquals(8, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit at NUL.
+    parser = new ParsableByteArray(bytes, 4);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals(4, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+    // Test with limit before NUL.
+    parser = new ParsableByteArray(bytes, 3);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals(3, parser.getPosition());
+    assertNull(parser.readNullTerminatedString());
+  }
+
+  public void testReadNullTerminatedStringWithoutEndingNull() {
+    byte[] bytes = new byte[] {
+        'f', 'o', 'o', 0, 'b', 'a', 'r'
+    };
+    ParsableByteArray parser = new ParsableByteArray(bytes);
+    assertEquals("foo", parser.readNullTerminatedString());
+    assertEquals("bar", parser.readNullTerminatedString());
+    assertNull(parser.readNullTerminatedString());
+  }
+
   public void testReadSingleLineWithoutEndingTrail() {
     byte[] bytes = new byte[] {
       'f', 'o', 'o'
diff --git a/library/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java
index 35e168e514..923d1d8aaa 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer2/util/UtilTest.java
@@ -142,8 +142,10 @@ public void testParseXsDuration() {
   public void testParseXsDateTime() throws Exception {
     assertEquals(1403219262000L, Util.parseXsDateTime("2014-06-19T23:07:42"));
     assertEquals(1407322800000L, Util.parseXsDateTime("2014-08-06T11:00:00Z"));
+    assertEquals(1407322800000L, Util.parseXsDateTime("2014-08-06T11:00:00,000Z"));
     assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55-08:00"));
     assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55-0800"));
+    assertEquals(1411161535000L, Util.parseXsDateTime("2014-09-19T13:18:55.000-0800"));
   }
 
   public void testUnescapeInvalidFileName() {
diff --git a/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index 514bbca8f4..f6aae200dd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -28,6 +28,7 @@
 
   private final int trackType;
 
+  private RendererConfiguration configuration;
   private int index;
   private int state;
   private SampleStream stream;
@@ -70,9 +71,11 @@ public final int getState() {
   }
 
   @Override
-  public final void enable(Format[] formats, SampleStream stream, long positionUs, boolean joining,
-      long offsetUs) throws ExoPlaybackException {
+  public final void enable(RendererConfiguration configuration, Format[] formats,
+      SampleStream stream, long positionUs, boolean joining, long offsetUs)
+      throws ExoPlaybackException {
     Assertions.checkState(state == STATE_DISABLED);
+    this.configuration = configuration;
     state = STATE_ENABLED;
     onEnabled(joining);
     replaceStream(formats, stream, offsetUs);
@@ -237,30 +240,46 @@ protected void onDisabled() {
 
   // Methods to be called by subclasses.
 
+  /**
+   * Returns the configuration set when the renderer was most recently enabled.
+   */
+  protected final RendererConfiguration getConfiguration() {
+    return configuration;
+  }
+
   /**
    * Returns the index of the renderer within the player.
-   *
-   * @return The index of the renderer within the player.
    */
   protected final int getIndex() {
     return index;
   }
 
+  /**
+   * Use {@link #readSource(FormatHolder, DecoderInputBuffer, boolean)} instead.
+   */
+  @Deprecated
+  protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buffer) {
+    return readSource(formatHolder, buffer, false);
+  }
+
   /**
    * Reads from the enabled upstream source. If the upstream source has been read to the end then
    * {@link C#RESULT_BUFFER_READ} is only returned if {@link #setCurrentStreamFinal()} has been
    * called. {@link C#RESULT_NOTHING_READ} is returned otherwise.
    *
-   * @see SampleStream#readData(FormatHolder, DecoderInputBuffer)
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the
    *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   * @param formatRequired Whether the caller requires that the format of the stream be read even if
+   *     it's not changing. A sample will never be read if set to true, however it is still possible
+   *     for the end of stream or nothing to be read.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
-  protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buffer) {
-    int result = stream.readData(formatHolder, buffer);
+  protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buffer,
+      boolean formatRequired) {
+    int result = stream.readData(formatHolder, buffer, formatRequired);
     if (result == C.RESULT_BUFFER_READ) {
       if (buffer.isEndOfStream()) {
         readEndOfStream = true;
@@ -292,7 +311,7 @@ protected final boolean isSourceReady() {
    * @param timeUs The specified time.
    */
   protected void skipToKeyframeBefore(long timeUs) {
-    stream.skipToKeyframeBefore(timeUs);
+    stream.skipToKeyframeBefore(timeUs - streamOffsetUs);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/C.java b/library/src/main/java/com/google/android/exoplayer2/C.java
index 3e6fac4a5e..6a1db191a0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/src/main/java/com/google/android/exoplayer2/C.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2;
 
+import android.annotation.TargetApi;
+import android.content.Context;
 import android.media.AudioFormat;
 import android.media.AudioManager;
 import android.media.MediaCodec;
@@ -96,6 +98,13 @@ private C() {}
   @SuppressWarnings("InlinedApi")
   public static final int CRYPTO_MODE_AES_CBC = MediaCodec.CRYPTO_MODE_AES_CBC;
 
+  /**
+   * Represents an unset {@link android.media.AudioTrack} session identifier. Equal to
+   * {@link AudioManager#AUDIO_SESSION_ID_GENERATE}.
+   */
+  @SuppressWarnings("InlinedApi")
+  public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
+
   /**
    * Represents an audio encoding, or an invalid or unset value.
    */
@@ -434,9 +443,16 @@ private C() {}
    */
   public static final UUID UUID_NIL = new UUID(0L, 0L);
 
+  /**
+   * UUID for the ClearKey DRM scheme.
+   * <p>
+   * ClearKey is supported on Android devices running Android 5.0 (API Level 21) and up.
+   */
+  public static final UUID CLEARKEY_UUID = new UUID(0x1077EFECC0B24D02L, 0xACE33C1E52E2FB4BL);
+
   /**
    * UUID for the Widevine DRM scheme.
-   * <p></p>
+   * <p>
    * Widevine is supported on Android devices running Android 4.3 (API Level 18) and up.
    */
   public static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
@@ -468,7 +484,7 @@ private C() {}
    * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
    * should be a {@link android.media.PlaybackParams}, or null, which will be used to configure the
    * underlying {@link android.media.AudioTrack}. The message object should not be modified by the
-   * caller after it has been passed
+   * caller after it has been passed.
    */
   public static final int MSG_SET_PLAYBACK_PARAMS = 3;
 
@@ -506,7 +522,13 @@ private C() {}
    * The stereo mode for 360/3D/VR videos.
    */
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({Format.NO_VALUE, STEREO_MODE_MONO, STEREO_MODE_TOP_BOTTOM, STEREO_MODE_LEFT_RIGHT})
+  @IntDef({
+      Format.NO_VALUE,
+      STEREO_MODE_MONO,
+      STEREO_MODE_TOP_BOTTOM,
+      STEREO_MODE_LEFT_RIGHT,
+      STEREO_MODE_STEREO_MESH
+  })
   public @interface StereoMode {}
   /**
    * Indicates Monoscopic stereo layout, used with 360/3D/VR videos.
@@ -520,6 +542,16 @@ private C() {}
    * Indicates Left-Right stereo layout, used with 360/3D/VR videos.
    */
   public static final int STEREO_MODE_LEFT_RIGHT = 2;
+  /**
+   * Indicates a stereo layout where the left and right eyes have separate meshes,
+   * used with 360/3D/VR videos.
+   */
+  public static final int STEREO_MODE_STEREO_MESH = 3;
+
+  /**
+   * Priority for media playback.
+   */
+  public static final int PRIORITY_PLAYBACK = 0;
 
   /**
    * Converts a time in microseconds to the corresponding time in milliseconds, preserving
@@ -543,4 +575,13 @@ public static long msToUs(long timeMs) {
     return timeMs == TIME_UNSET ? TIME_UNSET : (timeMs * 1000);
   }
 
+  /**
+   * Returns a newly generated {@link android.media.AudioTrack} session identifier.
+   */
+  @TargetApi(21)
+  public static int generateAudioSessionIdV21(Context context) {
+    return ((AudioManager) context.getSystemService(Context.AUDIO_SERVICE))
+        .generateAudioSessionId();
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index 4832036c9d..c34df60d83 100644
--- a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DefaultAllocator;
+import com.google.android.exoplayer2.util.PriorityTaskManager;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -60,6 +61,7 @@
   private final long maxBufferUs;
   private final long bufferForPlaybackUs;
   private final long bufferForPlaybackAfterRebufferUs;
+  private final PriorityTaskManager priorityTaskManager;
 
   private int targetBufferSize;
   private boolean isBuffering;
@@ -97,11 +99,36 @@ public DefaultLoadControl(DefaultAllocator allocator) {
    */
   public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs,
       long bufferForPlaybackMs, long bufferForPlaybackAfterRebufferMs) {
+    this(allocator, minBufferMs, maxBufferMs, bufferForPlaybackMs, bufferForPlaybackAfterRebufferMs,
+        null);
+  }
+
+  /**
+   * Constructs a new instance.
+   *
+   * @param allocator The {@link DefaultAllocator} used by the loader.
+   * @param minBufferMs The minimum duration of media that the player will attempt to ensure is
+   *     buffered at all times, in milliseconds.
+   * @param maxBufferMs The maximum duration of media that the player will attempt buffer, in
+   *     milliseconds.
+   * @param bufferForPlaybackMs The duration of media that must be buffered for playback to start or
+   *     resume following a user action such as a seek, in milliseconds.
+   * @param bufferForPlaybackAfterRebufferMs The default duration of media that must be buffered for
+   *     playback to resume after a rebuffer, in milliseconds. A rebuffer is defined to be caused by
+   *     buffer depletion rather than a user action.
+   * @param priorityTaskManager If not null, registers itself as a task with priority
+   *     {@link C#PRIORITY_PLAYBACK} during loading periods, and unregisters itself during draining
+   *     periods.
+   */
+  public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs,
+      long bufferForPlaybackMs, long bufferForPlaybackAfterRebufferMs,
+      PriorityTaskManager priorityTaskManager) {
     this.allocator = allocator;
     minBufferUs = minBufferMs * 1000L;
     maxBufferUs = maxBufferMs * 1000L;
     bufferForPlaybackUs = bufferForPlaybackMs * 1000L;
     bufferForPlaybackAfterRebufferUs = bufferForPlaybackAfterRebufferMs * 1000L;
+    this.priorityTaskManager = priorityTaskManager;
   }
 
   @Override
@@ -146,8 +173,16 @@ public boolean shouldStartPlayback(long bufferedDurationUs, boolean rebuffering)
   public boolean shouldContinueLoading(long bufferedDurationUs) {
     int bufferTimeState = getBufferTimeState(bufferedDurationUs);
     boolean targetBufferSizeReached = allocator.getTotalBytesAllocated() >= targetBufferSize;
+    boolean wasBuffering = isBuffering;
     isBuffering = bufferTimeState == BELOW_LOW_WATERMARK
         || (bufferTimeState == BETWEEN_WATERMARKS && isBuffering && !targetBufferSizeReached);
+    if (priorityTaskManager != null && isBuffering != wasBuffering) {
+      if (isBuffering) {
+        priorityTaskManager.add(C.PRIORITY_PLAYBACK);
+      } else {
+        priorityTaskManager.remove(C.PRIORITY_PLAYBACK);
+      }
+    }
     return isBuffering;
   }
 
@@ -158,6 +193,9 @@ private int getBufferTimeState(long bufferedDurationUs) {
 
   private void reset(boolean resetAllocator) {
     targetBufferSize = 0;
+    if (priorityTaskManager != null && isBuffering) {
+      priorityTaskManager.remove(C.PRIORITY_PLAYBACK);
+    }
     isBuffering = false;
     if (resetAllocator) {
       allocator.reset();
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
index 72ac72e981..ca7367f1b0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlaybackException.java
@@ -56,8 +56,7 @@
    * The type of the playback failure. One of {@link #TYPE_SOURCE}, {@link #TYPE_RENDERER} and
    * {@link #TYPE_UNEXPECTED}.
    */
-  @Type
-  public final int type;
+  @Type public final int type;
 
   /**
    * If {@link #type} is {@link #TYPE_RENDERER}, this is the index of the renderer.
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index 6c64d2c0f3..083569416c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -447,4 +447,20 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
    */
   int getBufferedPercentage();
 
+  /**
+   * Returns whether the current window is dynamic, or {@code false} if the {@link Timeline} is
+   * empty.
+   *
+   * @see Timeline.Window#isDynamic
+   */
+  boolean isCurrentWindowDynamic();
+
+  /**
+   * Returns whether the current window is seekable, or {@code false} if the {@link Timeline} is
+   * empty.
+   *
+   * @see Timeline.Window#isSeekable
+   */
+  boolean isCurrentWindowSeekable();
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index a7cbeb524c..d44d138091 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -22,12 +22,12 @@
 import android.util.Log;
 import com.google.android.exoplayer2.ExoPlayerImplInternal.PlaybackInfo;
 import com.google.android.exoplayer2.ExoPlayerImplInternal.SourceInfo;
-import com.google.android.exoplayer2.ExoPlayerImplInternal.TrackInfo;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.util.concurrent.CopyOnWriteArraySet;
@@ -271,6 +271,22 @@ public int getBufferedPercentage() {
         : (int) (duration == 0 ? 100 : (bufferedPosition * 100) / duration);
   }
 
+  @Override
+  public boolean isCurrentWindowDynamic() {
+    if (timeline.isEmpty()) {
+      return false;
+    }
+    return timeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
+  }
+
+  @Override
+  public boolean isCurrentWindowSeekable() {
+    if (timeline.isEmpty()) {
+      return false;
+    }
+    return timeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
+  }
+
   @Override
   public int getRendererCount() {
     return renderers.length;
@@ -319,11 +335,11 @@ public Object getCurrentManifest() {
         break;
       }
       case ExoPlayerImplInternal.MSG_TRACKS_CHANGED: {
-        TrackInfo trackInfo = (TrackInfo) msg.obj;
+        TrackSelectorResult trackSelectorResult = (TrackSelectorResult) msg.obj;
         tracksSelected = true;
-        trackGroups = trackInfo.groups;
-        trackSelections = trackInfo.selections;
-        trackSelector.onSelectionActivated(trackInfo.info);
+        trackGroups = trackSelectorResult.groups;
+        trackSelections = trackSelectorResult.selections;
+        trackSelector.onSelectionActivated(trackSelectorResult.info);
         for (EventListener listener : listeners) {
           listener.onTracksChanged(trackGroups, trackSelections);
         }
@@ -332,8 +348,10 @@ public Object getCurrentManifest() {
       case ExoPlayerImplInternal.MSG_SEEK_ACK: {
         if (--pendingSeekAcks == 0) {
           playbackInfo = (ExoPlayerImplInternal.PlaybackInfo) msg.obj;
-          for (EventListener listener : listeners) {
-            listener.onPositionDiscontinuity();
+          if (msg.arg1 != 0) {
+            for (EventListener listener : listeners) {
+              listener.onPositionDiscontinuity();
+            }
           }
         }
         break;
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 8866bb7c48..e4c109e85b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -26,16 +26,15 @@
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.SampleStream;
-import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.PriorityHandlerThread;
 import com.google.android.exoplayer2.util.StandaloneMediaClock;
 import com.google.android.exoplayer2.util.TraceUtil;
-import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -72,20 +71,6 @@ public PlaybackInfo copyWithPeriodIndex(int periodIndex) {
 
   }
 
-  public static final class TrackInfo {
-
-    public final TrackGroupArray groups;
-    public final TrackSelectionArray selections;
-    public final Object info;
-
-    public TrackInfo(TrackGroupArray groups, TrackSelectionArray selections, Object info) {
-      this.groups = groups;
-      this.selections = selections;
-      this.info = info;
-    }
-
-  }
-
   public static final class SourceInfo {
 
     public final Timeline timeline;
@@ -470,6 +455,8 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
     TraceUtil.beginSection("doSomeWork");
 
     updatePlaybackPositions();
+    playingPeriodHolder.mediaPeriod.discardBuffer(playbackInfo.positionUs);
+
     boolean allRenderersEnded = true;
     boolean allRenderersReadyOrEnded = true;
     for (Renderer renderer : enabledRenderers) {
@@ -559,7 +546,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
       // The seek position was valid for the timeline that it was performed into, but the
       // timeline has changed and a suitable seek position could not be resolved in the new one.
       playbackInfo = new PlaybackInfo(0, 0);
-      eventHandler.obtainMessage(MSG_SEEK_ACK, playbackInfo).sendToTarget();
+      eventHandler.obtainMessage(MSG_SEEK_ACK, 1, 0, playbackInfo).sendToTarget();
       // Set the internal position to (0,TIME_UNSET) so that a subsequent seek to (0,0) isn't
       // ignored.
       playbackInfo = new PlaybackInfo(0, C.TIME_UNSET);
@@ -569,6 +556,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
       return;
     }
 
+    boolean seekPositionAdjusted = seekPosition.windowPositionUs == C.TIME_UNSET;
     int periodIndex = periodPosition.first;
     long periodPositionUs = periodPosition.second;
 
@@ -578,10 +566,13 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
         // Seek position equals the current position. Do nothing.
         return;
       }
-      periodPositionUs = seekToPeriodPosition(periodIndex, periodPositionUs);
+      long newPeriodPositionUs = seekToPeriodPosition(periodIndex, periodPositionUs);
+      seekPositionAdjusted |= periodPositionUs != newPeriodPositionUs;
+      periodPositionUs = newPeriodPositionUs;
     } finally {
       playbackInfo = new PlaybackInfo(periodIndex, periodPositionUs);
-      eventHandler.obtainMessage(MSG_SEEK_ACK, playbackInfo).sendToTarget();
+      eventHandler.obtainMessage(MSG_SEEK_ACK, seekPositionAdjusted ? 1 : 0, 0, playbackInfo)
+          .sendToTarget();
     }
   }
 
@@ -620,6 +611,7 @@ private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
       enabledRenderers = new Renderer[0];
       rendererMediaClock = null;
       rendererMediaClockSource = null;
+      playingPeriodHolder = null;
     }
 
     // Update the holders.
@@ -795,7 +787,8 @@ private void reselectTracksInternal() throws ExoPlaybackException {
           }
         }
       }
-      eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.getTrackInfo()).sendToTarget();
+      eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.trackSelectorResult)
+          .sendToTarget();
       enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
     } else {
       // Release and re-prepare/buffer periods after the one whose selection changed.
@@ -1134,33 +1127,38 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     }
 
     if (readingPeriodHolder.isLast) {
-      for (Renderer renderer : enabledRenderers) {
+      for (int i = 0; i < renderers.length; i++) {
+        Renderer renderer = renderers[i];
+        SampleStream sampleStream = readingPeriodHolder.sampleStreams[i];
         // Defer setting the stream as final until the renderer has actually consumed the whole
         // stream in case of playlist changes that cause the stream to be no longer final.
-        if (renderer.hasReadStreamToEnd()) {
+        if (sampleStream != null && renderer.getStream() == sampleStream
+            && renderer.hasReadStreamToEnd()) {
           renderer.setCurrentStreamFinal();
         }
       }
       return;
     }
 
-    for (Renderer renderer : enabledRenderers) {
-      if (!renderer.hasReadStreamToEnd()) {
+    for (int i = 0; i < renderers.length; i++) {
+      Renderer renderer = renderers[i];
+      SampleStream sampleStream = readingPeriodHolder.sampleStreams[i];
+      if (renderer.getStream() != sampleStream
+          || (sampleStream != null && !renderer.hasReadStreamToEnd())) {
         return;
       }
     }
 
     if (readingPeriodHolder.next != null && readingPeriodHolder.next.prepared) {
-      TrackSelectionArray oldTrackSelections = readingPeriodHolder.trackSelections;
+      TrackSelectorResult oldTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
       readingPeriodHolder = readingPeriodHolder.next;
-      TrackSelectionArray newTrackSelections = readingPeriodHolder.trackSelections;
+      TrackSelectorResult newTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
 
       boolean initialDiscontinuity =
           readingPeriodHolder.mediaPeriod.readDiscontinuity() != C.TIME_UNSET;
       for (int i = 0; i < renderers.length; i++) {
         Renderer renderer = renderers[i];
-        TrackSelection oldSelection = oldTrackSelections.get(i);
-        TrackSelection newSelection = newTrackSelections.get(i);
+        TrackSelection oldSelection = oldTrackSelectorResult.selections.get(i);
         if (oldSelection == null) {
           // The renderer has no current stream and will be enabled when we play the next period.
         } else if (initialDiscontinuity) {
@@ -1168,9 +1166,12 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
           // be disabled and re-enabled when it starts playing the next period.
           renderer.setCurrentStreamFinal();
         } else if (!renderer.isCurrentStreamFinal()) {
-          if (newSelection != null) {
-            // Replace the renderer's SampleStream so the transition to playing the next period
-            // can be seamless.
+          TrackSelection newSelection = newTrackSelectorResult.selections.get(i);
+          RendererConfiguration oldConfig = oldTrackSelectorResult.rendererConfigurations[i];
+          RendererConfiguration newConfig = newTrackSelectorResult.rendererConfigurations[i];
+          if (newSelection != null && newConfig.equals(oldConfig)) {
+            // Replace the renderer's SampleStream so the transition to playing the next period can
+            // be seamless.
             Format[] formats = new Format[newSelection.length()];
             for (int j = 0; j < formats.length; j++) {
               formats[j] = newSelection.getFormat(j);
@@ -1178,8 +1179,9 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
             renderer.replaceStream(formats, readingPeriodHolder.sampleStreams[i],
                 readingPeriodHolder.getRendererOffset());
           } else {
-            // The renderer will be disabled when transitioning to playing the next period. Mark the
-            // SampleStream as final to play out any remaining data.
+            // The renderer will be disabled when transitioning to playing the next period, either
+            // because there's no new selection or because a configuration change is required. Mark
+            // the SampleStream as final to play out any remaining data.
             renderer.setCurrentStreamFinal();
           }
         }
@@ -1215,7 +1217,7 @@ private void maybeUpdateLoadingPeriod() throws IOException {
 
     long newLoadingPeriodStartPositionUs;
     if (loadingPeriodHolder == null) {
-      newLoadingPeriodStartPositionUs = playbackInfo.startPositionUs;
+      newLoadingPeriodStartPositionUs = playbackInfo.positionUs;
     } else {
       int newLoadingWindowIndex = timeline.getPeriod(newLoadingPeriodIndex, period).windowIndex;
       if (newLoadingPeriodIndex
@@ -1315,20 +1317,21 @@ private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPl
       return;
     }
 
-    playingPeriodHolder = periodHolder;
     int enabledRendererCount = 0;
     boolean[] rendererWasEnabledFlags = new boolean[renderers.length];
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
       rendererWasEnabledFlags[i] = renderer.getState() != Renderer.STATE_DISABLED;
-      TrackSelection newSelection = periodHolder.trackSelections.get(i);
+      TrackSelection newSelection = periodHolder.trackSelectorResult.selections.get(i);
       if (newSelection != null) {
         enabledRendererCount++;
       }
-      if (rendererWasEnabledFlags[i] && (newSelection == null || renderer.isCurrentStreamFinal())) {
+      if (rendererWasEnabledFlags[i] && (newSelection == null
+          || (renderer.isCurrentStreamFinal()
+          && renderer.getStream() == playingPeriodHolder.sampleStreams[i]))) {
         // The renderer should be disabled before playing the next period, either because it's not
-        // needed to play the next period, or because we need to disable and re-enable it because
-        // the renderer thinks that its current stream is final.
+        // needed to play the next period, or because we need to re-enable it as its current stream
+        // is final and it's not reading ahead.
         if (renderer == rendererMediaClockSource) {
           // Sync standaloneMediaClock so that it can take over timing responsibilities.
           standaloneMediaClock.setPositionUs(rendererMediaClock.getPositionUs());
@@ -1340,7 +1343,8 @@ private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPl
       }
     }
 
-    eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.getTrackInfo()).sendToTarget();
+    playingPeriodHolder = periodHolder;
+    eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.trackSelectorResult).sendToTarget();
     enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
   }
 
@@ -1350,10 +1354,12 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
     enabledRendererCount = 0;
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
-      TrackSelection newSelection = playingPeriodHolder.trackSelections.get(i);
+      TrackSelection newSelection = playingPeriodHolder.trackSelectorResult.selections.get(i);
       if (newSelection != null) {
         enabledRenderers[enabledRendererCount++] = renderer;
         if (renderer.getState() == Renderer.STATE_DISABLED) {
+          RendererConfiguration rendererConfiguration =
+              playingPeriodHolder.trackSelectorResult.rendererConfigurations[i];
           // The renderer needs enabling with its new track selection.
           boolean playing = playWhenReady && state == ExoPlayer.STATE_READY;
           // Consider as joining only if the renderer was previously disabled.
@@ -1364,8 +1370,8 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
             formats[j] = newSelection.getFormat(j);
           }
           // Enable the renderer.
-          renderer.enable(formats, playingPeriodHolder.sampleStreams[i], rendererPositionUs,
-              joining, playingPeriodHolder.getRendererOffset());
+          renderer.enable(rendererConfiguration, formats, playingPeriodHolder.sampleStreams[i],
+              rendererPositionUs, joining, playingPeriodHolder.getRendererOffset());
           MediaClock mediaClock = renderer.getMediaClock();
           if (mediaClock != null) {
             if (rendererMediaClock != null) {
@@ -1402,6 +1408,7 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
     public boolean hasEnabledTracks;
     public MediaPeriodHolder next;
     public boolean needsContinueLoading;
+    public TrackSelectorResult trackSelectorResult;
 
     private final Renderer[] renderers;
     private final RendererCapabilities[] rendererCapabilities;
@@ -1409,10 +1416,7 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int enabledRende
     private final LoadControl loadControl;
     private final MediaSource mediaSource;
 
-    private Object trackSelectionsInfo;
-    private TrackGroupArray trackGroups;
-    private TrackSelectionArray trackSelections;
-    private TrackSelectionArray periodTrackSelections;
+    private TrackSelectorResult periodTrackSelectorResult;
 
     public MediaPeriodHolder(Renderer[] renderers, RendererCapabilities[] rendererCapabilities,
         long rendererPositionOffsetUs, TrackSelector trackSelector, LoadControl loadControl,
@@ -1458,20 +1462,17 @@ public boolean isFullyBuffered() {
 
     public void handlePrepared() throws ExoPlaybackException {
       prepared = true;
-      trackGroups = mediaPeriod.getTrackGroups();
       selectTracks();
       startPositionUs = updatePeriodTrackSelection(startPositionUs, false);
     }
 
     public boolean selectTracks() throws ExoPlaybackException {
-      Pair<TrackSelectionArray, Object> selectorResult = trackSelector.selectTracks(
-          rendererCapabilities, trackGroups);
-      TrackSelectionArray newTrackSelections = selectorResult.first;
-      if (newTrackSelections.equals(periodTrackSelections)) {
+      TrackSelectorResult selectorResult = trackSelector.selectTracks(rendererCapabilities,
+          mediaPeriod.getTrackGroups());
+      if (selectorResult.isEquivalent(periodTrackSelectorResult)) {
         return false;
       }
-      trackSelections = newTrackSelections;
-      trackSelectionsInfo = selectorResult.second;
+      trackSelectorResult = selectorResult;
       return true;
     }
 
@@ -1482,16 +1483,16 @@ public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStr
 
     public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStreams,
         boolean[] streamResetFlags) {
+      TrackSelectionArray trackSelections = trackSelectorResult.selections;
       for (int i = 0; i < trackSelections.length; i++) {
         mayRetainStreamFlags[i] = !forceRecreateStreams
-            && Util.areEqual(periodTrackSelections == null ? null : periodTrackSelections.get(i),
-            trackSelections.get(i));
+            && trackSelectorResult.isEquivalent(periodTrackSelectorResult, i);
       }
 
       // Disable streams on the period and get new streams for updated/newly-enabled tracks.
       positionUs = mediaPeriod.selectTracks(trackSelections.getAll(), mayRetainStreamFlags,
           sampleStreams, streamResetFlags, positionUs);
-      periodTrackSelections = trackSelections;
+      periodTrackSelectorResult = trackSelectorResult;
 
       // Update whether we have enabled tracks and sanity check the expected streams are non-null.
       hasEnabledTracks = false;
@@ -1505,14 +1506,10 @@ public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStr
       }
 
       // The track selection has changed.
-      loadControl.onTracksSelected(renderers, trackGroups, trackSelections);
+      loadControl.onTracksSelected(renderers, trackSelectorResult.groups, trackSelections);
       return positionUs;
     }
 
-    public TrackInfo getTrackInfo() {
-      return new TrackInfo(trackGroups, trackSelections, trackSelectionsInfo);
-    }
-
     public void release() {
       try {
         mediaSource.releasePeriod(mediaPeriod);
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index ea522ac4c8..bee9904590 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  String VERSION = "2.1.1";
+  String VERSION = "2.3.1";
 
   /**
    * The version of the library, expressed as an integer.
@@ -32,7 +32,7 @@
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
-  int VERSION_INT = 2001001;
+  int VERSION_INT = 2003001;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer2/Format.java b/library/src/main/java/com/google/android/exoplayer2/Format.java
index 14efb6a2c7..866e512288 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Format.java
@@ -120,7 +120,7 @@
   /**
    * The stereo layout for 360/3D/VR video, or {@link #NO_VALUE} if not applicable. Valid stereo
    * modes are {@link C#STEREO_MODE_MONO}, {@link C#STEREO_MODE_TOP_BOTTOM}, {@link
-   * C#STEREO_MODE_LEFT_RIGHT}.
+   * C#STEREO_MODE_LEFT_RIGHT}, {@link C#STEREO_MODE_STEREO_MESH}.
    */
   @C.StereoMode
   public final int stereoMode;
@@ -183,20 +183,18 @@
    */
   public final int accessibilityChannel;
 
-  // Lazily initialized hashcode and framework media format.
-
+  // Lazily initialized hashcode.
   private int hashCode;
-  private MediaFormat frameworkMediaFormat;
 
   // Video.
 
   public static Format createVideoContainerFormat(String id, String containerMimeType,
       String sampleMimeType, String codecs, int bitrate, int width, int height,
-      float frameRate, List<byte[]> initializationData) {
+      float frameRate, List<byte[]> initializationData, @C.SelectionFlags int selectionFlags) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, width,
         height, frameRate, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, initializationData, null,
-        null);
+        NO_VALUE, NO_VALUE, selectionFlags, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE,
+        initializationData, null, null);
   }
 
   public static Format createVideoSampleFormat(String id, String sampleMimeType, String codecs,
@@ -289,8 +287,8 @@ public static Format createTextSampleFormat(String id, String sampleMimeType, St
   }
 
   public static Format createTextSampleFormat(String id, String sampleMimeType, String codecs,
-      int bitrate, @C.SelectionFlags int selectionFlags, String language,
-      int accessibilityChannel, DrmInitData drmInitData) {
+      int bitrate, @C.SelectionFlags int selectionFlags, String language, int accessibilityChannel,
+      DrmInitData drmInitData) {
     return createTextSampleFormat(id, sampleMimeType, codecs, bitrate, selectionFlags, language,
         accessibilityChannel, drmInitData, OFFSET_SAMPLE_RELATIVE);
   }
@@ -323,11 +321,20 @@ public static Format createImageSampleFormat(String id, String sampleMimeType, S
 
   // Generic.
 
-  public static Format createContainerFormat(String id, String containerMimeType, String codecs,
-      String sampleMimeType, int bitrate) {
+  public static Format createContainerFormat(String id, String containerMimeType,
+      String sampleMimeType, String codecs, int bitrate, @C.SelectionFlags int selectionFlags,
+      String language) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, 0, null, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, null, null);
+        NO_VALUE, NO_VALUE, selectionFlags, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE, null, null,
+        null);
+  }
+
+  public static Format createSampleFormat(String id, String sampleMimeType,
+      long subsampleOffsetUs) {
+    return new Format(id, null, sampleMimeType, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
+        NO_VALUE, 0, null, NO_VALUE, subsampleOffsetUs, null, null, null);
   }
 
   public static Format createSampleFormat(String id, String sampleMimeType, String codecs,
@@ -431,16 +438,19 @@ public Format copyWithContainerInfo(String id, String codecs, int bitrate, int w
         drmInitData, metadata);
   }
 
-  public Format copyWithManifestFormatInfo(Format manifestFormat,
-      boolean preferManifestDrmInitData) {
+  public Format copyWithManifestFormatInfo(Format manifestFormat) {
+    if (this == manifestFormat) {
+      // No need to copy from ourselves.
+      return this;
+    }
     String id = manifestFormat.id;
     String codecs = this.codecs == null ? manifestFormat.codecs : this.codecs;
     int bitrate = this.bitrate == NO_VALUE ? manifestFormat.bitrate : this.bitrate;
     float frameRate = this.frameRate == NO_VALUE ? manifestFormat.frameRate : this.frameRate;
     @C.SelectionFlags int selectionFlags = this.selectionFlags |  manifestFormat.selectionFlags;
     String language = this.language == null ? manifestFormat.language : this.language;
-    DrmInitData drmInitData = (preferManifestDrmInitData && manifestFormat.drmInitData != null)
-        || this.drmInitData == null ? manifestFormat.drmInitData : this.drmInitData;
+    DrmInitData drmInitData = manifestFormat.drmInitData != null ? manifestFormat.drmInitData
+        : this.drmInitData;
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
         height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
         channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding, selectionFlags,
@@ -486,31 +496,28 @@ public int getPixelCount() {
   @SuppressLint("InlinedApi")
   @TargetApi(16)
   public final MediaFormat getFrameworkMediaFormatV16() {
-    if (frameworkMediaFormat == null) {
-      MediaFormat format = new MediaFormat();
-      format.setString(MediaFormat.KEY_MIME, sampleMimeType);
-      maybeSetStringV16(format, MediaFormat.KEY_LANGUAGE, language);
-      maybeSetIntegerV16(format, MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize);
-      maybeSetIntegerV16(format, MediaFormat.KEY_WIDTH, width);
-      maybeSetIntegerV16(format, MediaFormat.KEY_HEIGHT, height);
-      maybeSetFloatV16(format, MediaFormat.KEY_FRAME_RATE, frameRate);
-      maybeSetIntegerV16(format, "rotation-degrees", rotationDegrees);
-      maybeSetIntegerV16(format, MediaFormat.KEY_CHANNEL_COUNT, channelCount);
-      maybeSetIntegerV16(format, MediaFormat.KEY_SAMPLE_RATE, sampleRate);
-      maybeSetIntegerV16(format, "encoder-delay", encoderDelay);
-      maybeSetIntegerV16(format, "encoder-padding", encoderPadding);
-      for (int i = 0; i < initializationData.size(); i++) {
-        format.setByteBuffer("csd-" + i, ByteBuffer.wrap(initializationData.get(i)));
-      }
-      frameworkMediaFormat = format;
+    MediaFormat format = new MediaFormat();
+    format.setString(MediaFormat.KEY_MIME, sampleMimeType);
+    maybeSetStringV16(format, MediaFormat.KEY_LANGUAGE, language);
+    maybeSetIntegerV16(format, MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize);
+    maybeSetIntegerV16(format, MediaFormat.KEY_WIDTH, width);
+    maybeSetIntegerV16(format, MediaFormat.KEY_HEIGHT, height);
+    maybeSetFloatV16(format, MediaFormat.KEY_FRAME_RATE, frameRate);
+    maybeSetIntegerV16(format, "rotation-degrees", rotationDegrees);
+    maybeSetIntegerV16(format, MediaFormat.KEY_CHANNEL_COUNT, channelCount);
+    maybeSetIntegerV16(format, MediaFormat.KEY_SAMPLE_RATE, sampleRate);
+    maybeSetIntegerV16(format, "encoder-delay", encoderDelay);
+    maybeSetIntegerV16(format, "encoder-padding", encoderPadding);
+    for (int i = 0; i < initializationData.size(); i++) {
+      format.setByteBuffer("csd-" + i, ByteBuffer.wrap(initializationData.get(i)));
     }
-    return frameworkMediaFormat;
+    return format;
   }
 
   @Override
   public String toString() {
     return "Format(" + id + ", " + containerMimeType + ", " + sampleMimeType + ", " + bitrate + ", "
-        + ", " + language + ", [" + width + ", " + height + ", " + frameRate + "]"
+        + language + ", [" + width + ", " + height + ", " + frameRate + "]"
         + ", [" + channelCount + ", " + sampleRate + "])";
   }
 
@@ -593,6 +600,38 @@ private static void maybeSetFloatV16(MediaFormat format, String key, float value
     }
   }
 
+  // Utility methods
+
+  /**
+   * Returns a prettier {@link String} than {@link #toString()}, intended for logging.
+   */
+  public static String toLogString(Format format) {
+    if (format == null) {
+      return "null";
+    }
+    StringBuilder builder = new StringBuilder();
+    builder.append("id=").append(format.id).append(", mimeType=").append(format.sampleMimeType);
+    if (format.bitrate != Format.NO_VALUE) {
+      builder.append(", bitrate=").append(format.bitrate);
+    }
+    if (format.width != Format.NO_VALUE && format.height != Format.NO_VALUE) {
+      builder.append(", res=").append(format.width).append("x").append(format.height);
+    }
+    if (format.frameRate != Format.NO_VALUE) {
+      builder.append(", fps=").append(format.frameRate);
+    }
+    if (format.channelCount != Format.NO_VALUE) {
+      builder.append(", channels=").append(format.channelCount);
+    }
+    if (format.sampleRate != Format.NO_VALUE) {
+      builder.append(", sample_rate=").append(format.sampleRate);
+    }
+    if (format.language != null) {
+      builder.append(", language=").append(format.language);
+    }
+    return builder.toString();
+  }
+
   // Parcelable implementation.
 
   @Override
@@ -636,9 +675,6 @@ public void writeToParcel(Parcel dest, int flags) {
     dest.writeParcelable(metadata, 0);
   }
 
-  /**
-   * {@link Creator} implementation.
-   */
   public static final Creator<Format> CREATOR = new Creator<Format>() {
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/Renderer.java b/library/src/main/java/com/google/android/exoplayer2/Renderer.java
index b610a64bea..e16caec980 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Renderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Renderer.java
@@ -92,6 +92,7 @@
    * This method may be called when the renderer is in the following states:
    * {@link #STATE_DISABLED}.
    *
+   * @param configuration The renderer configuration.
    * @param formats The enabled formats.
    * @param stream The {@link SampleStream} from which the renderer should consume.
    * @param positionUs The player's current position.
@@ -100,8 +101,8 @@
    *     before they are rendered.
    * @throws ExoPlaybackException If an error occurs.
    */
-  void enable(Format[] formats, SampleStream stream, long positionUs, boolean joining,
-      long offsetUs) throws ExoPlaybackException;
+  void enable(RendererConfiguration configuration, Format[] formats, SampleStream stream,
+      long positionUs, boolean joining, long offsetUs) throws ExoPlaybackException;
 
   /**
    * Starts the renderer, meaning that calls to {@link #render(long, long)} will cause media to be
diff --git a/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java b/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
index 4312bff632..151453c12c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
+++ b/library/src/main/java/com/google/android/exoplayer2/RendererCapabilities.java
@@ -79,6 +79,20 @@
    */
   int ADAPTIVE_NOT_SUPPORTED = 0b0000;
 
+  /**
+   * A mask to apply to the result of {@link #supportsFormat(Format)} to obtain one of
+   * {@link #TUNNELING_SUPPORTED} and {@link #TUNNELING_NOT_SUPPORTED}.
+   */
+  int TUNNELING_SUPPORT_MASK = 0b10000;
+  /**
+   * The {@link Renderer} supports tunneled output.
+   */
+  int TUNNELING_SUPPORTED = 0b10000;
+  /**
+   * The {@link Renderer} does not support tunneled output.
+   */
+  int TUNNELING_NOT_SUPPORTED = 0b00000;
+
   /**
    * Returns the track type that the {@link Renderer} handles. For example, a video renderer will
    * return {@link C#TRACK_TYPE_VIDEO}, an audio renderer will return {@link C#TRACK_TYPE_AUDIO}, a
@@ -91,7 +105,7 @@
 
   /**
    * Returns the extent to which the {@link Renderer} supports a given format. The returned value is
-   * the bitwise OR of two properties:
+   * the bitwise OR of three properties:
    * <ul>
    * <li>The level of support for the format itself. One of {@link #FORMAT_HANDLED},
    * {@link #FORMAT_EXCEEDS_CAPABILITIES}, {@link #FORMAT_UNSUPPORTED_SUBTYPE} and
@@ -99,9 +113,12 @@
    * <li>The level of support for adapting from the format to another format of the same mime type.
    * One of {@link #ADAPTIVE_SEAMLESS}, {@link #ADAPTIVE_NOT_SEAMLESS} and
    * {@link #ADAPTIVE_NOT_SUPPORTED}.</li>
+   * <li>The level of support for tunneling. One of {@link #TUNNELING_SUPPORTED} and
+   * {@link #TUNNELING_NOT_SUPPORTED}.</li>
    * </ul>
    * The individual properties can be retrieved by performing a bitwise AND with
-   * {@link #FORMAT_SUPPORT_MASK} and {@link #ADAPTIVE_SUPPORT_MASK} respectively.
+   * {@link #FORMAT_SUPPORT_MASK}, {@link #ADAPTIVE_SUPPORT_MASK} and
+   * {@link #TUNNELING_SUPPORT_MASK} respectively.
    *
    * @param format The format.
    * @return The extent to which the renderer is capable of supporting the given format.
diff --git a/library/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java b/library/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java
new file mode 100644
index 0000000000..93bbd1e4b6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/RendererConfiguration.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+/**
+ * The configuration of a {@link Renderer}.
+ */
+public final class RendererConfiguration {
+
+  /**
+   * The default configuration.
+   */
+  public static final RendererConfiguration DEFAULT =
+      new RendererConfiguration(C.AUDIO_SESSION_ID_UNSET);
+
+  /**
+   * The audio session id to use for tunneling, or {@link C#AUDIO_SESSION_ID_UNSET} if tunneling
+   * should not be enabled.
+   */
+  public final int tunnelingAudioSessionId;
+
+  /**
+   * @param tunnelingAudioSessionId The audio session id to use for tunneling, or
+   *     {@link C#AUDIO_SESSION_ID_UNSET} if tunneling should not be enabled.
+   */
+  public RendererConfiguration(int tunnelingAudioSessionId) {
+    this.tunnelingAudioSessionId = tunnelingAudioSessionId;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    RendererConfiguration other = (RendererConfiguration) obj;
+    return tunnelingAudioSessionId == other.tunnelingAudioSessionId;
+  }
+
+  @Override
+  public int hashCode() {
+    return tunnelingAudioSessionId;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 36753309e2..3ce4937911 100644
--- a/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -28,8 +28,8 @@
 import android.view.SurfaceView;
 import android.view.TextureView;
 import com.google.android.exoplayer2.audio.AudioCapabilities;
+import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
-import com.google.android.exoplayer2.audio.AudioTrack;
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -37,7 +37,6 @@
 import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
-import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.text.Cue;
@@ -178,7 +177,7 @@ protected SimpleExoPlayer(Context context, TrackSelector trackSelector, LoadCont
 
     // Set initial values.
     audioVolume = 1;
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
     audioStreamType = C.STREAM_TYPE_DEFAULT;
     videoScalingMode = C.VIDEO_SCALING_MODE_DEFAULT;
 
@@ -393,7 +392,7 @@ public Format getAudioFormat() {
   }
 
   /**
-   * Returns the audio session identifier, or {@code AudioTrack.SESSION_ID_NOT_SET} if not set.
+   * Returns the audio session identifier, or {@link C#AUDIO_SESSION_ID_UNSET} if not set.
    */
   public int getAudioSessionId() {
     return audioSessionId;
@@ -449,15 +448,6 @@ public void setTextOutput(TextRenderer.Output output) {
     textOutput = output;
   }
 
-  /**
-   * @deprecated Use {@link #setMetadataOutput(MetadataRenderer.Output)} instead.
-   * @param output The output.
-   */
-  @Deprecated
-  public void setId3Output(MetadataRenderer.Output output) {
-    setMetadataOutput(output);
-  }
-
   /**
    * Sets a listener to receive metadata events.
    *
@@ -490,8 +480,8 @@ public void prepare(MediaSource mediaSource) {
   }
 
   @Override
-  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetTimeline) {
-    player.prepare(mediaSource, resetPosition, resetTimeline);
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    player.prepare(mediaSource, resetPosition, resetState);
   }
 
   @Override
@@ -557,63 +547,73 @@ public void blockingSendMessages(ExoPlayerMessage... messages) {
   }
 
   @Override
-  public int getCurrentPeriodIndex() {
-    return player.getCurrentPeriodIndex();
+  public int getRendererCount() {
+    return player.getRendererCount();
   }
 
   @Override
-  public int getCurrentWindowIndex() {
-    return player.getCurrentWindowIndex();
+  public int getRendererType(int index) {
+    return player.getRendererType(index);
   }
 
   @Override
-  public long getDuration() {
-    return player.getDuration();
+  public TrackGroupArray getCurrentTrackGroups() {
+    return player.getCurrentTrackGroups();
   }
 
   @Override
-  public long getCurrentPosition() {
-    return player.getCurrentPosition();
+  public TrackSelectionArray getCurrentTrackSelections() {
+    return player.getCurrentTrackSelections();
   }
 
   @Override
-  public long getBufferedPosition() {
-    return player.getBufferedPosition();
+  public Timeline getCurrentTimeline() {
+    return player.getCurrentTimeline();
   }
 
   @Override
-  public int getBufferedPercentage() {
-    return player.getBufferedPercentage();
+  public Object getCurrentManifest() {
+    return player.getCurrentManifest();
   }
 
   @Override
-  public int getRendererCount() {
-    return player.getRendererCount();
+  public int getCurrentPeriodIndex() {
+    return player.getCurrentPeriodIndex();
   }
 
   @Override
-  public int getRendererType(int index) {
-    return player.getRendererType(index);
+  public int getCurrentWindowIndex() {
+    return player.getCurrentWindowIndex();
   }
 
   @Override
-  public TrackGroupArray getCurrentTrackGroups() {
-    return player.getCurrentTrackGroups();
+  public long getDuration() {
+    return player.getDuration();
   }
 
   @Override
-  public TrackSelectionArray getCurrentTrackSelections() {
-    return player.getCurrentTrackSelections();
+  public long getCurrentPosition() {
+    return player.getCurrentPosition();
   }
 
   @Override
-  public Timeline getCurrentTimeline() {
-    return player.getCurrentTimeline();
+  public long getBufferedPosition() {
+    return player.getBufferedPosition();
   }
 
   @Override
-  public Object getCurrentManifest() {
-    return player.getCurrentManifest();
+  public int getBufferedPercentage() {
+    return player.getBufferedPercentage();
+  }
+
+  @Override
+  public boolean isCurrentWindowDynamic() {
+    return player.isCurrentWindowDynamic();
+  }
+
+  @Override
+  public boolean isCurrentWindowSeekable() {
+    return player.isCurrentWindowSeekable();
   }
 
   // Renderer building.
@@ -625,7 +625,7 @@ private void buildRenderers(Context context, Handler mainHandler,
     buildVideoRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
         componentListener, allowedVideoJoiningTimeMs, out);
     buildAudioRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
-        componentListener, out);
+        componentListener, buildAudioProcessors(), out);
     buildTextRenderers(context, mainHandler, extensionRendererMode, componentListener, out);
     buildMetadataRenderers(context, mainHandler, extensionRendererMode, componentListener, out);
     buildMiscellaneousRenderers(context, mainHandler, extensionRendererMode, out);
@@ -637,7 +637,7 @@ private void buildRenderers(Context context, Handler mainHandler,
    * @param context The {@link Context} associated with the player.
    * @param mainHandler A handler associated with the main thread's looper.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
-   * not be used for DRM protected playbacks.
+   *     not be used for DRM protected playbacks.
    * @param extensionRendererMode The extension renderer mode.
    * @param eventListener An event listener.
    * @param allowedVideoJoiningTimeMs The maximum duration in milliseconds for which video renderers
@@ -682,17 +682,19 @@ protected void buildVideoRenderers(Context context, Handler mainHandler,
    * @param context The {@link Context} associated with the player.
    * @param mainHandler A handler associated with the main thread's looper.
    * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
-   * not be used for DRM protected playbacks.
+   *     not be used for DRM protected playbacks.
    * @param extensionRendererMode The extension renderer mode.
    * @param eventListener An event listener.
+   * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio buffers
+   *     before output. May be empty.
    * @param out An array to which the built renderers should be appended.
    */
   protected void buildAudioRenderers(Context context, Handler mainHandler,
       DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       @ExtensionRendererMode int extensionRendererMode, AudioRendererEventListener eventListener,
-      ArrayList<Renderer> out) {
+      AudioProcessor[] audioProcessors, ArrayList<Renderer> out) {
     out.add(new MediaCodecAudioRenderer(MediaCodecSelector.DEFAULT, drmSessionManager, true,
-        mainHandler, eventListener, AudioCapabilities.getCapabilities(context)));
+        mainHandler, eventListener, AudioCapabilities.getCapabilities(context), audioProcessors));
 
     if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
       return;
@@ -706,8 +708,9 @@ protected void buildAudioRenderers(Context context, Handler mainHandler,
       Class<?> clazz =
           Class.forName("com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer");
       Constructor<?> constructor = clazz.getConstructor(Handler.class,
-          AudioRendererEventListener.class);
-      Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener);
+          AudioRendererEventListener.class, AudioProcessor[].class);
+      Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener,
+          audioProcessors);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibopusAudioRenderer.");
     } catch (ClassNotFoundException e) {
@@ -720,8 +723,9 @@ protected void buildAudioRenderers(Context context, Handler mainHandler,
       Class<?> clazz =
           Class.forName("com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer");
       Constructor<?> constructor = clazz.getConstructor(Handler.class,
-          AudioRendererEventListener.class);
-      Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener);
+          AudioRendererEventListener.class, AudioProcessor[].class);
+      Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener,
+          audioProcessors);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibflacAudioRenderer.");
     } catch (ClassNotFoundException e) {
@@ -734,8 +738,9 @@ protected void buildAudioRenderers(Context context, Handler mainHandler,
       Class<?> clazz =
           Class.forName("com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer");
       Constructor<?> constructor = clazz.getConstructor(Handler.class,
-          AudioRendererEventListener.class);
-      Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener);
+          AudioRendererEventListener.class, AudioProcessor[].class);
+      Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener,
+          audioProcessors);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded FfmpegAudioRenderer.");
     } catch (ClassNotFoundException e) {
@@ -772,7 +777,7 @@ protected void buildTextRenderers(Context context, Handler mainHandler,
   protected void buildMetadataRenderers(Context context, Handler mainHandler,
       @ExtensionRendererMode int extensionRendererMode, MetadataRenderer.Output output,
       ArrayList<Renderer> out) {
-    out.add(new MetadataRenderer(output, mainHandler.getLooper(), new Id3Decoder()));
+    out.add(new MetadataRenderer(output, mainHandler.getLooper()));
   }
 
   /**
@@ -788,6 +793,13 @@ protected void buildMiscellaneousRenderers(Context context, Handler mainHandler,
     // Do nothing.
   }
 
+  /**
+   * Builds an array of {@link AudioProcessor}s that will process PCM audio before output.
+   */
+  protected AudioProcessor[] buildAudioProcessors() {
+    return new AudioProcessor[0];
+  }
+
   // Internal methods.
 
   private void removeSurfaceCallbacks() {
@@ -949,7 +961,7 @@ public void onAudioDisabled(DecoderCounters counters) {
       }
       audioFormat = null;
       audioDecoderCounters = null;
-      audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+      audioSessionId = C.AUDIO_SESSION_ID_UNSET;
     }
 
     // TextRenderer.Output implementation
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java b/library/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
new file mode 100644
index 0000000000..2e0d1f98d9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/AudioProcessor.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import com.google.android.exoplayer2.C;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * Interface for audio processors.
+ */
+public interface AudioProcessor {
+
+  /**
+   * Exception thrown when a processor can't be configured for a given input audio format.
+   */
+  final class UnhandledFormatException extends Exception {
+
+    public UnhandledFormatException(int sampleRateHz, int channelCount, @C.Encoding int encoding) {
+      super("Unhandled format: " + sampleRateHz + " Hz, " + channelCount + " channels in encoding "
+          + encoding);
+    }
+
+  }
+
+  /**
+   * An empty, direct {@link ByteBuffer}.
+   */
+  ByteBuffer EMPTY_BUFFER = ByteBuffer.allocateDirect(0).order(ByteOrder.nativeOrder());
+
+  /**
+   * Configures the processor to process input audio with the specified format. After calling this
+   * method, {@link #isActive()} returns whether the processor needs to handle buffers; if not, the
+   * processor will not accept any buffers until it is reconfigured. Returns {@code true} if the
+   * processor must be flushed, or if the value returned by {@link #isActive()} has changed as a
+   * result of the call. If it's active, {@link #getOutputChannelCount()} and
+   * {@link #getOutputEncoding()} return the processor's output format.
+   *
+   * @param sampleRateHz The sample rate of input audio in Hz.
+   * @param channelCount The number of interleaved channels in input audio.
+   * @param encoding The encoding of input audio.
+   * @return {@code true} if the processor must be flushed or the value returned by
+   *     {@link #isActive()} has changed as a result of the call.
+   * @throws UnhandledFormatException Thrown if the specified format can't be handled as input.
+   */
+  boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
+      throws UnhandledFormatException;
+
+  /**
+   * Returns whether the processor is configured and active.
+   */
+  boolean isActive();
+
+  /**
+   * Returns the number of audio channels in the data output by the processor.
+   */
+  int getOutputChannelCount();
+
+  /**
+   * Returns the audio encoding used in the data output by the processor.
+   */
+  @C.Encoding
+  int getOutputEncoding();
+
+  /**
+   * Queues audio data between the position and limit of the input {@code buffer} for processing.
+   * {@code buffer} must be a direct byte buffer with native byte order. Its contents are treated as
+   * read-only. Its position will be advanced by the number of bytes consumed (which may be zero).
+   * The caller retains ownership of the provided buffer. Calling this method invalidates any
+   * previous buffer returned by {@link #getOutput()}.
+   *
+   * @param buffer The input buffer to process.
+   */
+  void queueInput(ByteBuffer buffer);
+
+  /**
+   * Queues an end of stream signal. After this method has been called,
+   * {@link #queueInput(ByteBuffer)} may not be called until after the next call to
+   * {@link #flush()}. Calling {@link #getOutput()} will return any remaining output data. Multiple
+   * calls may be required to read all of the remaining output data. {@link #isEnded()} will return
+   * {@code true} once all remaining output data has been read.
+   */
+  void queueEndOfStream();
+
+  /**
+   * Returns a buffer containing processed output data between its position and limit. The buffer
+   * will always be a direct byte buffer with native byte order. Calling this method invalidates any
+   * previously returned buffer. The buffer will be empty if no output is available.
+   *
+   * @return A buffer containing processed output data between its position and limit.
+   */
+  ByteBuffer getOutput();
+
+  /**
+   * Returns whether this processor will return no more output from {@link #getOutput()} until it
+   * has been {@link #flush()}ed and more input has been queued.
+   */
+  boolean isEnded();
+
+  /**
+   * Clears any state in preparation for receiving a new stream of input buffers.
+   */
+  void flush();
+
+  /**
+   * Releases any resources associated with this instance.
+   */
+  void release();
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
index 8e6cf68dc8..3b8a1b8f39 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/AudioTrack.java
@@ -17,6 +17,7 @@
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.media.AudioAttributes;
 import android.media.AudioFormat;
 import android.media.AudioTimestamp;
 import android.media.PlaybackParams;
@@ -24,34 +25,38 @@
 import android.os.SystemClock;
 import android.util.Log;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.ArrayList;
 
 /**
  * Plays audio data. The implementation delegates to an {@link android.media.AudioTrack} and handles
  * playback position smoothing, non-blocking writes and reconfiguration.
  * <p>
  * Before starting playback, specify the input format by calling
- * {@link #configure(String, int, int, int, int)}. Next call {@link #initialize(int)}, optionally
- * specifying an audio session.
+ * {@link #configure(String, int, int, int, int)}. Optionally call {@link #setAudioSessionId(int)},
+ * {@link #setStreamType(int)}, {@link #enableTunnelingV21(int)} and {@link #disableTunneling()}
+ * to configure audio playback. These methods may be called after writing data to the track, in
+ * which case it will be reinitialized as required.
  * <p>
  * Call {@link #handleBuffer(ByteBuffer, long)} to write data, and {@link #handleDiscontinuity()}
  * when the data being fed is discontinuous. Call {@link #play()} to start playing the written data.
  * <p>
- * Call {@link #configure(String, int, int, int, int)} whenever the input format changes. If
- * {@link #isInitialized()} returns {@code false} after the call, it is necessary to call
- * {@link #initialize(int)} before writing more data.
+ * Call {@link #configure(String, int, int, int, int)} whenever the input format changes. The track
+ * will be reinitialized on the next call to {@link #handleBuffer(ByteBuffer, long)}.
  * <p>
- * The underlying {@link android.media.AudioTrack} is created by {@link #initialize(int)} and
- * released by {@link #reset()} (and {@link #configure(String, int, int, int, int)} unless the input
- * format is unchanged). It is safe to call {@link #initialize(int)} after calling {@link #reset()}
- * without reconfiguration.
+ * Calling {@link #reset()} releases the underlying {@link android.media.AudioTrack} (and so does
+ * calling {@link #configure(String, int, int, int, int)} unless the format is unchanged). It is
+ * safe to call {@link #handleBuffer(ByteBuffer, long)} after {@link #reset()} without calling
+ * {@link #configure(String, int, int, int, int)}.
  * <p>
- * Call {@link #release()} when the instance is no longer required.
+ * Call {@link #playToEndOfStream()} repeatedly to play out all data when no more input buffers will
+ * be provided via {@link #handleBuffer(ByteBuffer, long)} until the next {@link #reset}. Call
+ * {@link #release()} when the instance is no longer required.
  */
 public final class AudioTrack {
 
@@ -60,6 +65,19 @@
    */
   public interface Listener {
 
+    /**
+     * Called when the audio track has been initialized with a newly generated audio session id.
+     *
+     * @param audioSessionId The newly generated audio session id.
+     */
+    void onAudioSessionId(int audioSessionId);
+
+    /**
+     * Called when the audio track handles a buffer whose timestamp is discontinuous with the last
+     * buffer handled since it was reset.
+     */
+    void onPositionDiscontinuity();
+
     /**
      * Called when the audio track underruns.
      *
@@ -73,6 +91,21 @@
 
   }
 
+  /**
+   * Thrown when a failure occurs configuring the track.
+   */
+  public static final class ConfigurationException extends Exception {
+
+    public ConfigurationException(Throwable cause) {
+      super(cause);
+    }
+
+    public ConfigurationException(String message) {
+      super(message);
+    }
+
+  }
+
   /**
    * Thrown when a failure occurs initializing an {@link android.media.AudioTrack}.
    */
@@ -104,13 +137,15 @@ public InitializationException(int audioTrackState, int sampleRate, int channelC
   public static final class WriteException extends Exception {
 
     /**
-     * An error value returned from {@link android.media.AudioTrack#write(byte[], int, int)}.
+     * The error value returned from {@link android.media.AudioTrack#write(byte[], int, int)} or
+     *     {@link android.media.AudioTrack#write(ByteBuffer, int, int)}.
      */
     public final int errorCode;
 
     /**
-     * @param errorCode An error value returned from
-     *     {@link android.media.AudioTrack#write(byte[], int, int)}.
+     * @param errorCode The error value returned from
+     *     {@link android.media.AudioTrack#write(byte[], int, int)} or
+     *     {@link android.media.AudioTrack#write(ByteBuffer, int, int)}.
      */
     public WriteException(int errorCode) {
       super("AudioTrack write failed: " + errorCode);
@@ -134,20 +169,6 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
 
   }
 
-  /**
-   * Returned in the result of {@link #handleBuffer} if the buffer was discontinuous.
-   */
-  public static final int RESULT_POSITION_DISCONTINUITY = 1;
-  /**
-   * Returned in the result of {@link #handleBuffer} if the buffer can be released.
-   */
-  public static final int RESULT_BUFFER_CONSUMED = 2;
-
-  /**
-   * Represents an unset {@link android.media.AudioTrack} session identifier.
-   */
-  public static final int SESSION_ID_NOT_SET = 0;
-
   /**
    * Returned by {@link #getCurrentPositionUs} when the position is not set.
    */
@@ -210,15 +231,15 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   /**
    * AudioTrack timestamps are deemed spurious if they are offset from the system clock by more
    * than this amount.
-   *
-   * <p>This is a fail safe that should not be required on correctly functioning devices.
+   * <p>
+   * This is a fail safe that should not be required on correctly functioning devices.
    */
   private static final long MAX_AUDIO_TIMESTAMP_OFFSET_US = 5 * C.MICROS_PER_SECOND;
 
   /**
    * AudioTrack latencies are deemed impossibly large if they are greater than this amount.
-   *
-   * <p>This is a fail safe that should not be required on correctly functioning devices.
+   * <p>
+   * This is a fail safe that should not be required on correctly functioning devices.
    */
   private static final long MAX_LATENCY_US = 5 * C.MICROS_PER_SECOND;
 
@@ -249,30 +270,34 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   public static boolean failOnSpuriousAudioTimestamp = false;
 
   private final AudioCapabilities audioCapabilities;
+  private final ChannelMappingAudioProcessor channelMappingAudioProcessor;
+  private final AudioProcessor[] availableAudioProcessors;
   private final Listener listener;
   private final ConditionVariable releasingConditionVariable;
   private final long[] playheadOffsets;
   private final AudioTrackUtil audioTrackUtil;
 
   /**
-   * Used to keep the audio session active on pre-V21 builds (see {@link #initialize(int)}).
+   * Used to keep the audio session active on pre-V21 builds (see {@link #initialize()}).
    */
   private android.media.AudioTrack keepSessionIdAudioTrack;
 
   private android.media.AudioTrack audioTrack;
   private int sampleRate;
   private int channelConfig;
-  @C.StreamType
-  private int streamType;
   @C.Encoding
-  private int sourceEncoding;
+  private int encoding;
   @C.Encoding
-  private int targetEncoding;
+  private int outputEncoding;
+  @C.StreamType
+  private int streamType;
   private boolean passthrough;
-  private int pcmFrameSize;
   private int bufferSize;
   private long bufferSizeUs;
 
+  private ByteBuffer avSyncHeader;
+  private int bytesUntilNextAvSync;
+
   private int nextPlayheadOffsetIndex;
   private int playheadOffsetCount;
   private long smoothedPlayheadOffsetUs;
@@ -281,8 +306,12 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private long lastTimestampSampleTimeUs;
 
   private Method getLatencyMethod;
+  private int pcmFrameSize;
   private long submittedPcmBytes;
   private long submittedEncodedFrames;
+  private int outputPcmFrameSize;
+  private long writtenPcmBytes;
+  private long writtenEncodedFrames;
   private int framesPerEncodedSample;
   private int startMediaTimeState;
   private long startMediaTimeUs;
@@ -290,22 +319,36 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   private long latencyUs;
   private float volume;
 
-  private byte[] temporaryBuffer;
-  private int temporaryBufferOffset;
-  private ByteBuffer currentSourceBuffer;
-
-  private ByteBuffer resampledBuffer;
-  private boolean useResampledBuffer;
-
+  private AudioProcessor[] audioProcessors;
+  private ByteBuffer[] outputBuffers;
+  private ByteBuffer inputBuffer;
+  private ByteBuffer outputBuffer;
+  private byte[] preV21OutputBuffer;
+  private int preV21OutputBufferOffset;
+  private int drainingAudioProcessorIndex;
+  private boolean handledEndOfStream;
+
+  private boolean playing;
+  private int audioSessionId;
+  private boolean tunneling;
   private boolean hasData;
   private long lastFeedElapsedRealtimeMs;
 
   /**
-   * @param audioCapabilities The current audio capabilities.
+   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
+   *     default capabilities (no encoded audio passthrough support) should be assumed.
+   * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio before
+   *     output. May be empty.
    * @param listener Listener for audio track events.
    */
-  public AudioTrack(AudioCapabilities audioCapabilities, Listener listener) {
+  public AudioTrack(AudioCapabilities audioCapabilities, AudioProcessor[] audioProcessors,
+      Listener listener) {
     this.audioCapabilities = audioCapabilities;
+    channelMappingAudioProcessor = new ChannelMappingAudioProcessor();
+    availableAudioProcessors = new AudioProcessor[audioProcessors.length + 2];
+    availableAudioProcessors[0] = new ResamplingAudioProcessor();
+    availableAudioProcessors[1] = channelMappingAudioProcessor;
+    System.arraycopy(audioProcessors, 0, availableAudioProcessors, 2, audioProcessors.length);
     this.listener = listener;
     releasingConditionVariable = new ConditionVariable(true);
     if (Util.SDK_INT >= 18) {
@@ -327,6 +370,10 @@ public AudioTrack(AudioCapabilities audioCapabilities, Listener listener) {
     volume = 1.0f;
     startMediaTimeState = START_NOT_SET;
     streamType = C.STREAM_TYPE_DEFAULT;
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+    drainingAudioProcessorIndex = C.INDEX_UNSET;
+    this.audioProcessors = new AudioProcessor[0];
+    outputBuffers = new ByteBuffer[0];
   }
 
   /**
@@ -340,14 +387,6 @@ public boolean isPassthroughSupported(String mimeType) {
         && audioCapabilities.supportsEncoding(getEncodingForMimeType(mimeType));
   }
 
-  /**
-   * Returns whether the audio track has been successfully initialized via {@link #initialize} and
-   * not yet {@link #reset}.
-   */
-  public boolean isInitialized() {
-    return audioTrack != null;
-  }
-
   /**
    * Returns the playback position in the stream starting at zero, in microseconds, or
    * {@link #CURRENT_POSITION_NOT_SET} if it is not yet available.
@@ -385,7 +424,7 @@ public long getCurrentPositionUs(boolean sourceEnded) {
         // The AudioTrack has started, but we don't have any samples to compute a smoothed position.
         currentPositionUs = audioTrackUtil.getPlaybackHeadPositionUs() + startMediaTimeUs;
       } else {
-        // getPlayheadPositionUs() only has a granularity of ~20ms, so we base the position off the
+        // getPlayheadPositionUs() only has a granularity of ~20 ms, so we base the position off the
         // system clock (and a smoothed offset between it and the playhead position) so as to
         // prevent jitter in the reported positions.
         currentPositionUs = systemClockUs + smoothedPlayheadOffsetUs + startMediaTimeUs;
@@ -409,9 +448,70 @@ public long getCurrentPositionUs(boolean sourceEnded) {
    *     {@link C#ENCODING_PCM_32BIT}.
    * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
    *     suitable buffer size automatically.
+   * @throws ConfigurationException If an error occurs configuring the track.
    */
   public void configure(String mimeType, int channelCount, int sampleRate,
-      @C.PcmEncoding int pcmEncoding, int specifiedBufferSize) {
+      @C.PcmEncoding int pcmEncoding, int specifiedBufferSize) throws ConfigurationException {
+    configure(mimeType, channelCount, sampleRate, pcmEncoding, specifiedBufferSize, null);
+  }
+
+  /**
+   * Configures (or reconfigures) the audio track.
+   *
+   * @param mimeType The mime type.
+   * @param channelCount The number of channels.
+   * @param sampleRate The sample rate in Hz.
+   * @param pcmEncoding For PCM formats, the encoding used. One of {@link C#ENCODING_PCM_16BIT},
+   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT} and
+   *     {@link C#ENCODING_PCM_32BIT}.
+   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
+   *     suitable buffer size automatically.
+   * @param outputChannels A mapping from input to output channels that is applied to this track's
+   *     input as a preprocessing step, if handling PCM input. Specify {@code null} to leave the
+   *     input unchanged. Otherwise, the element at index {@code i} specifies index of the input
+   *     channel to map to output channel {@code i} when preprocessing input buffers. After the
+   *     map is applied the audio data will have {@code outputChannels.length} channels.
+   * @throws ConfigurationException If an error occurs configuring the track.
+   */
+  public void configure(String mimeType, int channelCount, int sampleRate,
+      @C.PcmEncoding int pcmEncoding, int specifiedBufferSize, int[] outputChannels)
+      throws ConfigurationException {
+    boolean passthrough = !MimeTypes.AUDIO_RAW.equals(mimeType);
+    @C.Encoding int encoding = passthrough ? getEncodingForMimeType(mimeType) : pcmEncoding;
+    boolean flush = false;
+    if (!passthrough) {
+      pcmFrameSize = Util.getPcmFrameSize(pcmEncoding, channelCount);
+
+      // Reconfigure the audio processors.
+      channelMappingAudioProcessor.setChannelMap(outputChannels);
+      ArrayList<AudioProcessor> newAudioProcessors = new ArrayList<>();
+      for (AudioProcessor audioProcessor : availableAudioProcessors) {
+        try {
+          flush |= audioProcessor.configure(sampleRate, channelCount, encoding);
+        } catch (AudioProcessor.UnhandledFormatException e) {
+          throw new ConfigurationException(e);
+        }
+        if (audioProcessor.isActive()) {
+          newAudioProcessors.add(audioProcessor);
+          channelCount = audioProcessor.getOutputChannelCount();
+          encoding = audioProcessor.getOutputEncoding();
+        } else {
+          audioProcessor.flush();
+        }
+      }
+
+      if (flush) {
+        int count = newAudioProcessors.size();
+        audioProcessors = newAudioProcessors.toArray(new AudioProcessor[count]);
+        outputBuffers = new ByteBuffer[count];
+        for (int i = 0; i < count; i++) {
+          AudioProcessor audioProcessor = audioProcessors[i];
+          audioProcessor.flush();
+          outputBuffers[i] = audioProcessor.getOutput();
+        }
+      }
+    }
+
     int channelConfig;
     switch (channelCount) {
       case 1:
@@ -439,21 +539,31 @@ public void configure(String mimeType, int channelCount, int sampleRate,
         channelConfig = C.CHANNEL_OUT_7POINT1_SURROUND;
         break;
       default:
-        throw new IllegalArgumentException("Unsupported channel count: " + channelCount);
+        throw new ConfigurationException("Unsupported channel count: " + channelCount);
     }
 
-    boolean passthrough = !MimeTypes.AUDIO_RAW.equals(mimeType);
-    @C.Encoding int sourceEncoding;
-    if (passthrough) {
-      sourceEncoding = getEncodingForMimeType(mimeType);
-    } else if (pcmEncoding == C.ENCODING_PCM_8BIT || pcmEncoding == C.ENCODING_PCM_16BIT
-        || pcmEncoding == C.ENCODING_PCM_24BIT || pcmEncoding == C.ENCODING_PCM_32BIT) {
-      sourceEncoding = pcmEncoding;
-    } else {
-      throw new IllegalArgumentException("Unsupported PCM encoding: " + pcmEncoding);
+    // Workaround for overly strict channel configuration checks on nVidia Shield.
+    if (Util.SDK_INT <= 23 && "foster".equals(Util.DEVICE) && "NVIDIA".equals(Util.MANUFACTURER)) {
+      switch (channelCount) {
+        case 7:
+          channelConfig = C.CHANNEL_OUT_7POINT1_SURROUND;
+          break;
+        case 3:
+        case 5:
+          channelConfig = AudioFormat.CHANNEL_OUT_5POINT1;
+          break;
+        default:
+          break;
+      }
     }
 
-    if (isInitialized() && this.sourceEncoding == sourceEncoding && this.sampleRate == sampleRate
+    // Workaround for Nexus Player not reporting support for mono passthrough.
+    // (See [Internal: b/34268671].)
+    if (Util.SDK_INT <= 25 && "fugu".equals(Util.DEVICE) && passthrough && channelCount == 1) {
+      channelConfig = AudioFormat.CHANNEL_OUT_STEREO;
+    }
+
+    if (!flush && isInitialized() && this.encoding == encoding && this.sampleRate == sampleRate
         && this.channelConfig == channelConfig) {
       // We already have an audio track with the correct sample rate, channel config and encoding.
       return;
@@ -461,48 +571,41 @@ public void configure(String mimeType, int channelCount, int sampleRate,
 
     reset();
 
-    this.sourceEncoding = sourceEncoding;
+    this.encoding = encoding;
     this.passthrough = passthrough;
     this.sampleRate = sampleRate;
     this.channelConfig = channelConfig;
-    targetEncoding = passthrough ? sourceEncoding : C.ENCODING_PCM_16BIT;
-    pcmFrameSize = 2 * channelCount; // 2 bytes per 16-bit sample * number of channels.
+    outputEncoding = passthrough ? encoding : C.ENCODING_PCM_16BIT;
+    outputPcmFrameSize = Util.getPcmFrameSize(C.ENCODING_PCM_16BIT, channelCount);
 
     if (specifiedBufferSize != 0) {
       bufferSize = specifiedBufferSize;
     } else if (passthrough) {
       // TODO: Set the minimum buffer size using getMinBufferSize when it takes the encoding into
       // account. [Internal: b/25181305]
-      if (targetEncoding == C.ENCODING_AC3 || targetEncoding == C.ENCODING_E_AC3) {
+      if (outputEncoding == C.ENCODING_AC3 || outputEncoding == C.ENCODING_E_AC3) {
         // AC-3 allows bitrates up to 640 kbit/s.
         bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 80 * 1024 / C.MICROS_PER_SECOND);
-      } else /* (targetEncoding == C.ENCODING_DTS || targetEncoding == C.ENCODING_DTS_HD */ {
+      } else /* (outputEncoding == C.ENCODING_DTS || outputEncoding == C.ENCODING_DTS_HD */ {
         // DTS allows an 'open' bitrate, but we assume the maximum listed value: 1536 kbit/s.
         bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 192 * 1024 / C.MICROS_PER_SECOND);
       }
     } else {
       int minBufferSize =
-          android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, targetEncoding);
+          android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, outputEncoding);
       Assertions.checkState(minBufferSize != ERROR_BAD_VALUE);
       int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
-      int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * pcmFrameSize;
+      int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * outputPcmFrameSize;
       int maxAppBufferSize = (int) Math.max(minBufferSize,
-          durationUsToFrames(MAX_BUFFER_DURATION_US) * pcmFrameSize);
+          durationUsToFrames(MAX_BUFFER_DURATION_US) * outputPcmFrameSize);
       bufferSize = multipliedBufferSize < minAppBufferSize ? minAppBufferSize
           : multipliedBufferSize > maxAppBufferSize ? maxAppBufferSize
           : multipliedBufferSize;
     }
-    bufferSizeUs = passthrough ? C.TIME_UNSET : framesToDurationUs(pcmBytesToFrames(bufferSize));
+    bufferSizeUs = passthrough ? C.TIME_UNSET : framesToDurationUs(bufferSize / outputPcmFrameSize);
   }
 
-  /**
-   * Initializes the audio track for writing new buffers using {@link #handleBuffer}.
-   *
-   * @param sessionId Audio track session identifier to re-use, or {@link #SESSION_ID_NOT_SET} to
-   *     create a new one.
-   * @return The new (or re-used) session identifier.
-   */
-  public int initialize(int sessionId) throws InitializationException {
+  private void initialize() throws InitializationException {
     // If we're asynchronously releasing a previous audio track then we block until it has been
     // released. This guarantees that we cannot end up in a state where we have multiple audio
     // track instances. Without this guarantee it would be possible, in extreme cases, to exhaust
@@ -510,23 +613,26 @@ public int initialize(int sessionId) throws InitializationException {
     // initialization of the audio track to fail.
     releasingConditionVariable.block();
 
-    if (sessionId == SESSION_ID_NOT_SET) {
+    if (tunneling) {
+      audioTrack = createHwAvSyncAudioTrackV21(sampleRate, channelConfig, outputEncoding,
+          bufferSize, audioSessionId);
+    } else if (audioSessionId == C.AUDIO_SESSION_ID_UNSET) {
       audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
-          targetEncoding, bufferSize, MODE_STREAM);
+          outputEncoding, bufferSize, MODE_STREAM);
     } else {
       // Re-attach to the same audio session.
       audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
-          targetEncoding, bufferSize, MODE_STREAM, sessionId);
+          outputEncoding, bufferSize, MODE_STREAM, audioSessionId);
     }
     checkAudioTrackInitialized();
 
-    sessionId = audioTrack.getAudioSessionId();
+    int audioSessionId = audioTrack.getAudioSessionId();
     if (enablePreV21AudioSessionWorkaround) {
       if (Util.SDK_INT < 21) {
         // The workaround creates an audio track with a two byte buffer on the same session, and
         // does not release it until this object is released, which keeps the session active.
         if (keepSessionIdAudioTrack != null
-            && sessionId != keepSessionIdAudioTrack.getAudioSessionId()) {
+            && audioSessionId != keepSessionIdAudioTrack.getAudioSessionId()) {
           releaseKeepSessionIdAudioTrack();
         }
         if (keepSessionIdAudioTrack == null) {
@@ -535,21 +641,25 @@ public int initialize(int sessionId) throws InitializationException {
           @C.PcmEncoding int encoding = C.ENCODING_PCM_16BIT;
           int bufferSize = 2; // Use a two byte buffer, as it is not actually used for playback.
           keepSessionIdAudioTrack = new android.media.AudioTrack(streamType, sampleRate,
-              channelConfig, encoding, bufferSize, MODE_STATIC, sessionId);
+              channelConfig, encoding, bufferSize, MODE_STATIC, audioSessionId);
         }
       }
     }
+    if (this.audioSessionId != audioSessionId) {
+      this.audioSessionId = audioSessionId;
+      listener.onAudioSessionId(audioSessionId);
+    }
 
     audioTrackUtil.reconfigure(audioTrack, needsPassthroughWorkarounds());
-    setAudioTrackVolume();
+    setVolumeInternal();
     hasData = false;
-    return sessionId;
   }
 
   /**
    * Starts or resumes playing audio if the audio track has been initialized.
    */
   public void play() {
+    playing = true;
     if (isInitialized()) {
       resumeSystemTimeUs = System.nanoTime() / 1000;
       audioTrack.play();
@@ -567,47 +677,40 @@ public void handleDiscontinuity() {
   }
 
   /**
-   * Attempts to write data from a {@link ByteBuffer} to the audio track, starting from its current
-   * position and ending at its limit (exclusive). The position of the {@link ByteBuffer} is
-   * advanced by the number of bytes that were successfully written.
+   * Attempts to process data from a {@link ByteBuffer}, starting from its current position and
+   * ending at its limit (exclusive). The position of the {@link ByteBuffer} is advanced by the
+   * number of bytes that were handled. {@link Listener#onPositionDiscontinuity()} will be called if
+   * {@code presentationTimeUs} is discontinuous with the last buffer handled since the last reset.
    * <p>
-   * Returns a bit field containing {@link #RESULT_BUFFER_CONSUMED} if the data was written in full,
-   * and {@link #RESULT_POSITION_DISCONTINUITY} if the buffer was discontinuous with previously
-   * written data.
-   * <p>
-   * If the data was not written in full then the same {@link ByteBuffer} must be provided to
-   * subsequent calls until it has been fully consumed, except in the case of an interleaving call
-   * to {@link #configure} or {@link #reset}.
+   * Returns whether the data was handled in full. If the data was not handled in full then the same
+   * {@link ByteBuffer} must be provided to subsequent calls until it has been fully consumed,
+   * except in the case of an interleaving call to {@link #reset()} (or an interleaving call to
+   * {@link #configure(String, int, int, int, int)} that caused the track to be reset).
    *
-   * @param buffer The buffer containing audio data to play back.
-   * @param presentationTimeUs Presentation timestamp of the next buffer in microseconds.
-   * @return A bit field with {@link #RESULT_BUFFER_CONSUMED} if the buffer can be released, and
-   *     {@link #RESULT_POSITION_DISCONTINUITY} if the buffer was not contiguous with previously
-   *     written data.
+   * @param buffer The buffer containing audio data.
+   * @param presentationTimeUs The presentation timestamp of the buffer in microseconds.
+   * @return Whether the buffer was handled fully.
+   * @throws InitializationException If an error occurs initializing the track.
    * @throws WriteException If an error occurs writing the audio data.
    */
-  public int handleBuffer(ByteBuffer buffer, long presentationTimeUs) throws WriteException {
-    boolean hadData = hasData;
-    hasData = hasPendingData();
-    if (hadData && !hasData && audioTrack.getPlayState() != PLAYSTATE_STOPPED) {
-      long elapsedSinceLastFeedMs = SystemClock.elapsedRealtime() - lastFeedElapsedRealtimeMs;
-      listener.onUnderrun(bufferSize, C.usToMs(bufferSizeUs), elapsedSinceLastFeedMs);
+  @SuppressWarnings("ReferenceEquality")
+  public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
+      throws InitializationException, WriteException {
+    Assertions.checkArgument(inputBuffer == null || buffer == inputBuffer);
+    if (!isInitialized()) {
+      initialize();
+      if (playing) {
+        play();
+      }
     }
-    int result = writeBuffer(buffer, presentationTimeUs);
-    lastFeedElapsedRealtimeMs = SystemClock.elapsedRealtime();
-    return result;
-  }
-
-  private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws WriteException {
-    boolean isNewSourceBuffer = currentSourceBuffer == null;
-    Assertions.checkState(isNewSourceBuffer || currentSourceBuffer == buffer);
-    currentSourceBuffer = buffer;
 
     if (needsPassthroughWorkarounds()) {
       // An AC-3 audio track continues to play data written while it is paused. Stop writing so its
       // buffer empties. See [Internal: b/18899620].
       if (audioTrack.getPlayState() == PLAYSTATE_PAUSED) {
-        return 0;
+        // We force an underrun to pause the track, so don't notify the listener in this case.
+        hasData = false;
+        return false;
       }
 
       // A new AC-3 audio track's playback position continues to increase from the old track's
@@ -615,32 +718,29 @@ private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
       // head position actually returns to zero.
       if (audioTrack.getPlayState() == PLAYSTATE_STOPPED
           && audioTrackUtil.getPlaybackHeadPosition() != 0) {
-        return 0;
+        return false;
       }
     }
 
-    int result = 0;
-    if (isNewSourceBuffer) {
-      // We're seeing this buffer for the first time.
+    boolean hadData = hasData;
+    hasData = hasPendingData();
+    if (hadData && !hasData && audioTrack.getPlayState() != PLAYSTATE_STOPPED) {
+      long elapsedSinceLastFeedMs = SystemClock.elapsedRealtime() - lastFeedElapsedRealtimeMs;
+      listener.onUnderrun(bufferSize, C.usToMs(bufferSizeUs), elapsedSinceLastFeedMs);
+    }
 
-      if (!currentSourceBuffer.hasRemaining()) {
+    if (inputBuffer == null) {
+      // We are seeing this buffer for the first time.
+      if (!buffer.hasRemaining()) {
         // The buffer is empty.
-        currentSourceBuffer = null;
-        return RESULT_BUFFER_CONSUMED;
-      }
-
-      useResampledBuffer = targetEncoding != sourceEncoding;
-      if (useResampledBuffer) {
-        Assertions.checkState(targetEncoding == C.ENCODING_PCM_16BIT);
-        // Resample the buffer to get the data in the target encoding.
-        resampledBuffer = resampleTo16BitPcm(currentSourceBuffer, sourceEncoding, resampledBuffer);
-        buffer = resampledBuffer;
+        return true;
       }
 
       if (passthrough && framesPerEncodedSample == 0) {
         // If this is the first encoded sample, calculate the sample size in frames.
-        framesPerEncodedSample = getFramesPerEncodedSample(targetEncoding, buffer);
+        framesPerEncodedSample = getFramesPerEncodedSample(outputEncoding, buffer);
       }
+
       if (startMediaTimeState == START_NOT_SET) {
         startMediaTimeUs = Math.max(0, presentationTimeUs);
         startMediaTimeState = START_IN_SYNC;
@@ -659,66 +759,175 @@ private int writeBuffer(ByteBuffer buffer, long presentationTimeUs) throws Write
           // number of bytes submitted.
           startMediaTimeUs += (presentationTimeUs - expectedPresentationTimeUs);
           startMediaTimeState = START_IN_SYNC;
-          result |= RESULT_POSITION_DISCONTINUITY;
+          listener.onPositionDiscontinuity();
         }
       }
+
+      if (passthrough) {
+        submittedEncodedFrames += framesPerEncodedSample;
+      } else {
+        submittedPcmBytes += buffer.remaining();
+      }
+
+      inputBuffer = buffer;
+    }
+
+    if (passthrough) {
+      // Passthrough buffers are not processed.
+      writeBuffer(inputBuffer, presentationTimeUs);
+    } else {
+      processBuffers(presentationTimeUs);
+    }
+
+    if (!inputBuffer.hasRemaining()) {
+      inputBuffer = null;
+      return true;
+    }
+    return false;
+  }
+
+  private void processBuffers(long avSyncPresentationTimeUs) throws WriteException {
+    int count = audioProcessors.length;
+    int index = count;
+    while (index >= 0) {
+      ByteBuffer input = index > 0 ? outputBuffers[index - 1]
+          : (inputBuffer != null ? inputBuffer : AudioProcessor.EMPTY_BUFFER);
+      if (index == count) {
+        writeBuffer(input, avSyncPresentationTimeUs);
+      } else {
+        AudioProcessor audioProcessor = audioProcessors[index];
+        audioProcessor.queueInput(input);
+        ByteBuffer output = audioProcessor.getOutput();
+        outputBuffers[index] = output;
+        if (output.hasRemaining()) {
+          // Handle the output as input to the next audio processor or the AudioTrack.
+          index++;
+          continue;
+        }
+      }
+
+      if (input.hasRemaining()) {
+        // The input wasn't consumed and no output was produced, so give up for now.
+        return;
+      }
+
+      // Get more input from upstream.
+      index--;
+    }
+  }
+
+  @SuppressWarnings("ReferenceEquality")
+  private boolean writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs)
+      throws WriteException {
+    if (!buffer.hasRemaining()) {
+      return true;
+    }
+    if (outputBuffer != null) {
+      Assertions.checkArgument(outputBuffer == buffer);
+    } else {
+      outputBuffer = buffer;
       if (Util.SDK_INT < 21) {
-        // Copy {@code buffer} into {@code temporaryBuffer}.
         int bytesRemaining = buffer.remaining();
-        if (temporaryBuffer == null || temporaryBuffer.length < bytesRemaining) {
-          temporaryBuffer = new byte[bytesRemaining];
+        if (preV21OutputBuffer == null || preV21OutputBuffer.length < bytesRemaining) {
+          preV21OutputBuffer = new byte[bytesRemaining];
         }
         int originalPosition = buffer.position();
-        buffer.get(temporaryBuffer, 0, bytesRemaining);
+        buffer.get(preV21OutputBuffer, 0, bytesRemaining);
         buffer.position(originalPosition);
-        temporaryBufferOffset = 0;
+        preV21OutputBufferOffset = 0;
       }
     }
-
-    buffer = useResampledBuffer ? resampledBuffer : buffer;
     int bytesRemaining = buffer.remaining();
     int bytesWritten = 0;
     if (Util.SDK_INT < 21) { // passthrough == false
       // Work out how many bytes we can write without the risk of blocking.
       int bytesPending =
-          (int) (submittedPcmBytes - (audioTrackUtil.getPlaybackHeadPosition() * pcmFrameSize));
+          (int) (writtenPcmBytes - (audioTrackUtil.getPlaybackHeadPosition() * outputPcmFrameSize));
       int bytesToWrite = bufferSize - bytesPending;
       if (bytesToWrite > 0) {
         bytesToWrite = Math.min(bytesRemaining, bytesToWrite);
-        bytesWritten = audioTrack.write(temporaryBuffer, temporaryBufferOffset, bytesToWrite);
-        if (bytesWritten >= 0) {
-          temporaryBufferOffset += bytesWritten;
+        bytesWritten = audioTrack.write(preV21OutputBuffer, preV21OutputBufferOffset, bytesToWrite);
+        if (bytesWritten > 0) {
+          preV21OutputBufferOffset += bytesWritten;
+          buffer.position(buffer.position() + bytesWritten);
         }
-        buffer.position(buffer.position() + bytesWritten);
       }
+    } else if (tunneling) {
+      Assertions.checkState(avSyncPresentationTimeUs != C.TIME_UNSET);
+      bytesWritten = writeNonBlockingWithAvSyncV21(audioTrack, buffer, bytesRemaining,
+          avSyncPresentationTimeUs);
     } else {
       bytesWritten = writeNonBlockingV21(audioTrack, buffer, bytesRemaining);
     }
 
+    lastFeedElapsedRealtimeMs = SystemClock.elapsedRealtime();
+
     if (bytesWritten < 0) {
       throw new WriteException(bytesWritten);
     }
 
     if (!passthrough) {
-      submittedPcmBytes += bytesWritten;
+      writtenPcmBytes += bytesWritten;
     }
     if (bytesWritten == bytesRemaining) {
       if (passthrough) {
-        submittedEncodedFrames += framesPerEncodedSample;
+        writtenEncodedFrames += framesPerEncodedSample;
       }
-      currentSourceBuffer = null;
-      result |= RESULT_BUFFER_CONSUMED;
+      outputBuffer = null;
+      return true;
     }
-    return result;
+    return false;
   }
 
   /**
-   * Ensures that the last data passed to {@link #handleBuffer(ByteBuffer, long)} is played in full.
+   * Plays out remaining audio. {@link #isEnded()} will return {@code true} when playback has ended.
+   *
+   * @throws WriteException If an error occurs draining data to the track.
    */
-  public void handleEndOfStream() {
-    if (isInitialized()) {
-      audioTrackUtil.handleEndOfStream(getSubmittedFrames());
+  public void playToEndOfStream() throws WriteException {
+    if (handledEndOfStream || !isInitialized()) {
+      return;
+    }
+
+    // Drain the audio processors.
+    boolean audioProcessorNeedsEndOfStream = false;
+    if (drainingAudioProcessorIndex == C.INDEX_UNSET) {
+      drainingAudioProcessorIndex = passthrough ? audioProcessors.length : 0;
+      audioProcessorNeedsEndOfStream = true;
+    }
+    while (drainingAudioProcessorIndex < audioProcessors.length) {
+      AudioProcessor audioProcessor = audioProcessors[drainingAudioProcessorIndex];
+      if (audioProcessorNeedsEndOfStream) {
+        audioProcessor.queueEndOfStream();
+      }
+      processBuffers(C.TIME_UNSET);
+      if (!audioProcessor.isEnded()) {
+        return;
+      }
+      audioProcessorNeedsEndOfStream = true;
+      drainingAudioProcessorIndex++;
+    }
+
+    // Finish writing any remaining output to the track.
+    if (outputBuffer != null) {
+      writeBuffer(outputBuffer, C.TIME_UNSET);
+      if (outputBuffer != null) {
+        return;
+      }
     }
+
+    // Drain the track.
+    audioTrackUtil.handleEndOfStream(getWrittenFrames());
+    bytesUntilNextAvSync = 0;
+    handledEndOfStream = true;
+  }
+
+  /**
+   * Returns whether all buffers passed to {@link #handleBuffer(ByteBuffer, long)} have been
+   * completely processed and played.
+   */
+  public boolean isEnded() {
+    return !isInitialized() || (handledEndOfStream && !hasPendingData());
   }
 
   /**
@@ -726,7 +935,7 @@ public void handleEndOfStream() {
    */
   public boolean hasPendingData() {
     return isInitialized()
-        && (getSubmittedFrames() > audioTrackUtil.getPlaybackHeadPosition()
+        && (getWrittenFrames() > audioTrackUtil.getPlaybackHeadPosition()
         || overrideHasPendingData());
   }
 
@@ -743,21 +952,70 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
   }
 
   /**
-   * Sets the stream type for audio track. If the stream type has changed, {@link #isInitialized()}
-   * will return {@code false} and the caller must re-{@link #initialize(int)} the audio track
-   * before writing more data. The caller must not reuse the audio session identifier when
-   * re-initializing with a new stream type.
+   * Sets the stream type for audio track. If the stream type has changed and if the audio track
+   * is not configured for use with tunneling, then the audio track is reset and the audio session
+   * id is cleared.
+   * <p>
+   * If the audio track is configured for use with tunneling then the stream type is ignored, the
+   * audio track is not reset and the audio session id is not cleared. The passed stream type will
+   * be used if the audio track is later re-configured into non-tunneled mode.
    *
    * @param streamType The {@link C.StreamType} to use for audio output.
-   * @return Whether the stream type changed.
    */
-  public boolean setStreamType(@C.StreamType int streamType) {
+  public void setStreamType(@C.StreamType int streamType) {
     if (this.streamType == streamType) {
-      return false;
+      return;
     }
     this.streamType = streamType;
+    if (tunneling) {
+      // The stream type is ignored in tunneling mode, so no need to reset.
+      return;
+    }
     reset();
-    return true;
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+  }
+
+  /**
+   * Sets the audio session id. The audio track is reset if the audio session id has changed.
+   */
+  public void setAudioSessionId(int audioSessionId) {
+    if (this.audioSessionId != audioSessionId) {
+      this.audioSessionId = audioSessionId;
+      reset();
+    }
+  }
+
+  /**
+   * Enables tunneling. The audio track is reset if tunneling was previously disabled or if the
+   * audio session id has changed. Enabling tunneling requires platform API version 21 onwards.
+   * <p>
+   * If this instance has {@link AudioProcessor}s and tunneling is enabled, care must be taken that
+   * audio processors do not output buffers with a different duration than their input, and buffer
+   * processors must produce output corresponding to their last input immediately after that input
+   * is queued.
+   *
+   * @param tunnelingAudioSessionId The audio session id to use.
+   * @throws IllegalStateException Thrown if enabling tunneling on platform API version &lt; 21.
+   */
+  public void enableTunnelingV21(int tunnelingAudioSessionId) {
+    Assertions.checkState(Util.SDK_INT >= 21);
+    if (!tunneling || audioSessionId != tunnelingAudioSessionId) {
+      tunneling = true;
+      audioSessionId = tunnelingAudioSessionId;
+      reset();
+    }
+  }
+
+  /**
+   * Disables tunneling. If tunneling was previously enabled then the audio track is reset and the
+   * audio session id is cleared.
+   */
+  public void disableTunneling() {
+    if (tunneling) {
+      tunneling = false;
+      audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+      reset();
+    }
   }
 
   /**
@@ -768,17 +1026,17 @@ public boolean setStreamType(@C.StreamType int streamType) {
   public void setVolume(float volume) {
     if (this.volume != volume) {
       this.volume = volume;
-      setAudioTrackVolume();
+      setVolumeInternal();
     }
   }
 
-  private void setAudioTrackVolume() {
+  private void setVolumeInternal() {
     if (!isInitialized()) {
       // Do nothing.
     } else if (Util.SDK_INT >= 21) {
-      setAudioTrackVolumeV21(audioTrack, volume);
+      setVolumeInternalV21(audioTrack, volume);
     } else {
-      setAudioTrackVolumeV3(audioTrack, volume);
+      setVolumeInternalV3(audioTrack, volume);
     }
   }
 
@@ -786,6 +1044,7 @@ private void setAudioTrackVolume() {
    * Pauses playback.
    */
   public void pause() {
+    playing = false;
     if (isInitialized()) {
       resetSyncParams();
       audioTrackUtil.pause();
@@ -795,16 +1054,28 @@ public void pause() {
   /**
    * Releases the underlying audio track asynchronously.
    * <p>
-   * Calling {@link #initialize(int)} will block until the audio track has been released, so it is
-   * safe to initialize immediately after a reset. The audio session may remain active until
-   * {@link #release()} is called.
+   * Calling {@link #handleBuffer(ByteBuffer, long)} will block until the audio track has been
+   * released, so it is safe to use the audio track immediately after a reset. The audio session may
+   * remain active until {@link #release()} is called.
    */
   public void reset() {
     if (isInitialized()) {
       submittedPcmBytes = 0;
       submittedEncodedFrames = 0;
+      writtenPcmBytes = 0;
+      writtenEncodedFrames = 0;
       framesPerEncodedSample = 0;
-      currentSourceBuffer = null;
+      inputBuffer = null;
+      outputBuffer = null;
+      for (int i = 0; i < audioProcessors.length; i++) {
+        AudioProcessor audioProcessor = audioProcessors[i];
+        audioProcessor.flush();
+        outputBuffers[i] = audioProcessor.getOutput();
+      }
+      handledEndOfStream = false;
+      drainingAudioProcessorIndex = C.INDEX_UNSET;
+      avSyncHeader = null;
+      bytesUntilNextAvSync = 0;
       startMediaTimeState = START_NOT_SET;
       latencyUs = 0;
       resetSyncParams();
@@ -837,6 +1108,11 @@ public void run() {
   public void release() {
     reset();
     releaseKeepSessionIdAudioTrack();
+    for (AudioProcessor audioProcessor : availableAudioProcessors) {
+      audioProcessor.release();
+    }
+    audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+    playing = false;
   }
 
   /**
@@ -974,8 +1250,8 @@ private void checkAudioTrackInitialized() throws InitializationException {
     throw new InitializationException(state, sampleRate, channelConfig, bufferSize);
   }
 
-  private long pcmBytesToFrames(long byteCount) {
-    return byteCount / pcmFrameSize;
+  private boolean isInitialized() {
+    return audioTrack != null;
   }
 
   private long framesToDurationUs(long frameCount) {
@@ -987,7 +1263,11 @@ private long durationUsToFrames(long durationUs) {
   }
 
   private long getSubmittedFrames() {
-    return passthrough ? submittedEncodedFrames : pcmBytesToFrames(submittedPcmBytes);
+    return passthrough ? submittedEncodedFrames : (submittedPcmBytes / pcmFrameSize);
+  }
+
+  private long getWrittenFrames() {
+    return passthrough ? writtenEncodedFrames : (writtenPcmBytes / outputPcmFrameSize);
   }
 
   private void resetSyncParams() {
@@ -1005,7 +1285,7 @@ private void resetSyncParams() {
    */
   private boolean needsPassthroughWorkarounds() {
     return Util.SDK_INT < 23
-        && (targetEncoding == C.ENCODING_AC3 || targetEncoding == C.ENCODING_E_AC3);
+        && (outputEncoding == C.ENCODING_AC3 || outputEncoding == C.ENCODING_E_AC3);
   }
 
   /**
@@ -1021,79 +1301,23 @@ private boolean overrideHasPendingData() {
   }
 
   /**
-   * Converts the provided buffer into 16-bit PCM.
-   *
-   * @param buffer The buffer containing the data to convert.
-   * @param sourceEncoding The data encoding.
-   * @param out A buffer into which the output should be written, if its capacity is sufficient.
-   * @return The 16-bit PCM output. Different to the out parameter if null was passed, or if the
-   *     capacity was insufficient for the output.
+   * Instantiates an {@link android.media.AudioTrack} to be used with tunneling video playback.
    */
-  private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, @C.PcmEncoding int sourceEncoding,
-      ByteBuffer out) {
-    int offset = buffer.position();
-    int limit = buffer.limit();
-    int size = limit - offset;
-
-    int resampledSize;
-    switch (sourceEncoding) {
-      case C.ENCODING_PCM_8BIT:
-        resampledSize = size * 2;
-        break;
-      case C.ENCODING_PCM_24BIT:
-        resampledSize = (size / 3) * 2;
-        break;
-      case C.ENCODING_PCM_32BIT:
-        resampledSize = size / 2;
-        break;
-      case C.ENCODING_PCM_16BIT:
-      case C.ENCODING_INVALID:
-      case Format.NO_VALUE:
-      default:
-        // Never happens.
-        throw new IllegalStateException();
-    }
-
-    ByteBuffer resampledBuffer = out;
-    if (resampledBuffer == null || resampledBuffer.capacity() < resampledSize) {
-      resampledBuffer = ByteBuffer.allocateDirect(resampledSize);
-    }
-    resampledBuffer.position(0);
-    resampledBuffer.limit(resampledSize);
-
-    // Samples are little endian.
-    switch (sourceEncoding) {
-      case C.ENCODING_PCM_8BIT:
-        // 8->16 bit resampling. Shift each byte from [0, 256) to [-128, 128) and scale up.
-        for (int i = offset; i < limit; i++) {
-          resampledBuffer.put((byte) 0);
-          resampledBuffer.put((byte) ((buffer.get(i) & 0xFF) - 128));
-        }
-        break;
-      case C.ENCODING_PCM_24BIT:
-        // 24->16 bit resampling. Drop the least significant byte.
-        for (int i = offset; i < limit; i += 3) {
-          resampledBuffer.put(buffer.get(i + 1));
-          resampledBuffer.put(buffer.get(i + 2));
-        }
-        break;
-      case C.ENCODING_PCM_32BIT:
-        // 32->16 bit resampling. Drop the two least significant bytes.
-        for (int i = offset; i < limit; i += 4) {
-          resampledBuffer.put(buffer.get(i + 2));
-          resampledBuffer.put(buffer.get(i + 3));
-        }
-        break;
-      case C.ENCODING_PCM_16BIT:
-      case C.ENCODING_INVALID:
-      case Format.NO_VALUE:
-      default:
-        // Never happens.
-        throw new IllegalStateException();
-    }
-
-    resampledBuffer.position(0);
-    return resampledBuffer;
+  @TargetApi(21)
+  private static android.media.AudioTrack createHwAvSyncAudioTrackV21(int sampleRate,
+      int channelConfig, int encoding, int bufferSize, int sessionId) {
+    AudioAttributes attributesBuilder = new AudioAttributes.Builder()
+        .setUsage(AudioAttributes.USAGE_MEDIA)
+        .setContentType(AudioAttributes.CONTENT_TYPE_MOVIE)
+        .setFlags(AudioAttributes.FLAG_HW_AV_SYNC)
+        .build();
+    AudioFormat format = new AudioFormat.Builder()
+        .setChannelMask(channelConfig)
+        .setEncoding(encoding)
+        .setSampleRate(sampleRate)
+        .build();
+    return new android.media.AudioTrack(attributesBuilder, format, bufferSize, MODE_STREAM,
+        sessionId);
   }
 
   @C.Encoding
@@ -1125,18 +1349,57 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe
   }
 
   @TargetApi(21)
-  private static int writeNonBlockingV21(
-      android.media.AudioTrack audioTrack, ByteBuffer buffer, int size) {
+  private static int writeNonBlockingV21(android.media.AudioTrack audioTrack, ByteBuffer buffer,
+      int size) {
     return audioTrack.write(buffer, size, WRITE_NON_BLOCKING);
   }
 
   @TargetApi(21)
-  private static void setAudioTrackVolumeV21(android.media.AudioTrack audioTrack, float volume) {
+  private int writeNonBlockingWithAvSyncV21(android.media.AudioTrack audioTrack,
+      ByteBuffer buffer, int size, long presentationTimeUs) {
+    // TODO: Uncomment this when [Internal ref b/33627517] is clarified or fixed.
+    // if (Util.SDK_INT >= 23) {
+    //   // The underlying platform AudioTrack writes AV sync headers directly.
+    //   return audioTrack.write(buffer, size, WRITE_NON_BLOCKING, presentationTimeUs * 1000);
+    // }
+    if (avSyncHeader == null) {
+      avSyncHeader = ByteBuffer.allocate(16);
+      avSyncHeader.order(ByteOrder.BIG_ENDIAN);
+      avSyncHeader.putInt(0x55550001);
+    }
+    if (bytesUntilNextAvSync == 0) {
+      avSyncHeader.putInt(4, size);
+      avSyncHeader.putLong(8, presentationTimeUs * 1000);
+      avSyncHeader.position(0);
+      bytesUntilNextAvSync = size;
+    }
+    int avSyncHeaderBytesRemaining = avSyncHeader.remaining();
+    if (avSyncHeaderBytesRemaining > 0) {
+      int result = audioTrack.write(avSyncHeader, avSyncHeaderBytesRemaining, WRITE_NON_BLOCKING);
+      if (result < 0) {
+        bytesUntilNextAvSync = 0;
+        return result;
+      }
+      if (result < avSyncHeaderBytesRemaining) {
+        return 0;
+      }
+    }
+    int result = writeNonBlockingV21(audioTrack, buffer, size);
+    if (result < 0) {
+      bytesUntilNextAvSync = 0;
+      return result;
+    }
+    bytesUntilNextAvSync -= result;
+    return result;
+  }
+
+  @TargetApi(21)
+  private static void setVolumeInternalV21(android.media.AudioTrack audioTrack, float volume) {
     audioTrack.setVolume(volume);
   }
 
   @SuppressWarnings("deprecation")
-  private static void setAudioTrackVolumeV3(android.media.AudioTrack audioTrack, float volume) {
+  private static void setVolumeInternalV3(android.media.AudioTrack audioTrack, float volume) {
     audioTrack.setStereoVolume(volume, volume);
   }
 
@@ -1385,7 +1648,7 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
       playbackParams = (playbackParams != null ? playbackParams : new PlaybackParams())
           .allowDefaults();
       this.playbackParams = playbackParams;
-      this.playbackSpeed = playbackParams.getSpeed();
+      playbackSpeed = playbackParams.getSpeed();
       maybeApplyPlaybackParams();
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java b/library/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
new file mode 100644
index 0000000000..e81d7e218a
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.C.Encoding;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.Arrays;
+
+/**
+ * An {@link AudioProcessor} that applies a mapping from input channels onto specified output
+ * channels. This can be used to reorder, duplicate or discard channels.
+ */
+/* package */ final class ChannelMappingAudioProcessor implements AudioProcessor {
+
+  private int channelCount;
+  private int sampleRateHz;
+  private int[] pendingOutputChannels;
+
+  private boolean active;
+  private int[] outputChannels;
+  private ByteBuffer buffer;
+  private ByteBuffer outputBuffer;
+  private boolean inputEnded;
+
+  /**
+   * Creates a new processor that applies a channel mapping.
+   */
+  public ChannelMappingAudioProcessor() {
+    buffer = EMPTY_BUFFER;
+    outputBuffer = EMPTY_BUFFER;
+  }
+
+  /**
+   * Resets the channel mapping. After calling this method, call {@link #configure(int, int, int)}
+   * to start using the new channel map.
+   *
+   * @see AudioTrack#configure(String, int, int, int, int, int[])
+   */
+  public void setChannelMap(int[] outputChannels) {
+    pendingOutputChannels = outputChannels;
+  }
+
+  @Override
+  public boolean configure(int sampleRateHz, int channelCount, @Encoding int encoding)
+      throws UnhandledFormatException {
+    boolean outputChannelsChanged = !Arrays.equals(pendingOutputChannels, outputChannels);
+    outputChannels = pendingOutputChannels;
+    if (outputChannels == null) {
+      active = false;
+      return outputChannelsChanged;
+    }
+    if (encoding != C.ENCODING_PCM_16BIT) {
+      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+    }
+    if (!outputChannelsChanged && this.sampleRateHz == sampleRateHz
+        && this.channelCount == channelCount) {
+      return false;
+    }
+    this.sampleRateHz = sampleRateHz;
+    this.channelCount = channelCount;
+
+    active = channelCount != outputChannels.length;
+    for (int i = 0; i < outputChannels.length; i++) {
+      int channelIndex = outputChannels[i];
+      if (channelIndex >= channelCount) {
+        throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+      }
+      active |= (channelIndex != i);
+    }
+    return true;
+  }
+
+  @Override
+  public boolean isActive() {
+    return active;
+  }
+
+  @Override
+  public int getOutputChannelCount() {
+    return outputChannels == null ? channelCount : outputChannels.length;
+  }
+
+  @Override
+  public int getOutputEncoding() {
+    return C.ENCODING_PCM_16BIT;
+  }
+
+  @Override
+  public void queueInput(ByteBuffer inputBuffer) {
+    int position = inputBuffer.position();
+    int limit = inputBuffer.limit();
+    int frameCount = (limit - position) / (2 * channelCount);
+    int outputSize = frameCount * outputChannels.length * 2;
+    if (buffer.capacity() < outputSize) {
+      buffer = ByteBuffer.allocateDirect(outputSize).order(ByteOrder.nativeOrder());
+    } else {
+      buffer.clear();
+    }
+    while (position < limit) {
+      for (int channelIndex : outputChannels) {
+        buffer.putShort(inputBuffer.getShort(position + 2 * channelIndex));
+      }
+      position += channelCount * 2;
+    }
+    inputBuffer.position(limit);
+    buffer.flip();
+    outputBuffer = buffer;
+  }
+
+  @Override
+  public void queueEndOfStream() {
+    inputEnded = true;
+  }
+
+  @Override
+  public ByteBuffer getOutput() {
+    ByteBuffer outputBuffer = this.outputBuffer;
+    this.outputBuffer = EMPTY_BUFFER;
+    return outputBuffer;
+  }
+
+  @SuppressWarnings("ReferenceEquality")
+  @Override
+  public boolean isEnded() {
+    return inputEnded && outputBuffer == EMPTY_BUFFER;
+  }
+
+  @Override
+  public void flush() {
+    outputBuffer = EMPTY_BUFFER;
+    inputEnded = false;
+  }
+
+  @Override
+  public void release() {
+    flush();
+    buffer = EMPTY_BUFFER;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 648bfd5762..e34068861d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -41,16 +41,16 @@
  * Decodes and renders audio using {@link MediaCodec} and {@link AudioTrack}.
  */
 @TargetApi(16)
-public class MediaCodecAudioRenderer extends MediaCodecRenderer implements MediaClock,
-    AudioTrack.Listener {
+public class MediaCodecAudioRenderer extends MediaCodecRenderer implements MediaClock {
 
   private final EventDispatcher eventDispatcher;
   private final AudioTrack audioTrack;
 
   private boolean passthroughEnabled;
+  private boolean codecNeedsDiscardChannelsWorkaround;
   private android.media.MediaFormat passthroughMediaFormat;
   private int pcmEncoding;
-  private int audioSessionId;
+  private int channelCount;
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
 
@@ -123,14 +123,16 @@ public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
    *     default capabilities (no encoded audio passthrough support) should be assumed.
+   * @param audioProcessors Optional {@link AudioProcessor}s that will process PCM audio before
+   *     output.
    */
   public MediaCodecAudioRenderer(MediaCodecSelector mediaCodecSelector,
       DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
       boolean playClearSamplesWithoutKeys, Handler eventHandler,
-      AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities) {
+      AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities,
+      AudioProcessor... audioProcessors) {
     super(C.TRACK_TYPE_AUDIO, mediaCodecSelector, drmSessionManager, playClearSamplesWithoutKeys);
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-    audioTrack = new AudioTrack(audioCapabilities, this);
+    audioTrack = new AudioTrack(audioCapabilities, audioProcessors, new AudioTrackListener());
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
   }
 
@@ -141,10 +143,11 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
     if (!MimeTypes.isAudio(mimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
     }
+    int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
     if (allowPassthrough(mimeType) && mediaCodecSelector.getPassthroughDecoderInfo() != null) {
-      return ADAPTIVE_NOT_SEAMLESS | FORMAT_HANDLED;
+      return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | FORMAT_HANDLED;
     }
-    MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType, false, false);
+    MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType, false);
     if (decoderInfo == null) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     }
@@ -155,7 +158,7 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
         && (format.channelCount == Format.NO_VALUE
         ||  decoderInfo.isAudioChannelCountSupportedV21(format.channelCount)));
     int formatSupport = decoderCapable ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
-    return ADAPTIVE_NOT_SEAMLESS | formatSupport;
+    return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | formatSupport;
   }
 
   @Override
@@ -185,7 +188,9 @@ protected boolean allowPassthrough(String mimeType) {
   }
 
   @Override
-  protected void configureCodec(MediaCodec codec, Format format, MediaCrypto crypto) {
+  protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+      MediaCrypto crypto) {
+    codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);
     if (passthroughEnabled) {
       // Override the MIME type used to configure the codec if we are using a passthrough decoder.
       passthroughMediaFormat = format.getFrameworkMediaFormatV16();
@@ -217,39 +222,72 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
     // output 16-bit PCM.
     pcmEncoding = MimeTypes.AUDIO_RAW.equals(newFormat.sampleMimeType) ? newFormat.pcmEncoding
         : C.ENCODING_PCM_16BIT;
+    channelCount = newFormat.channelCount;
   }
 
   @Override
-  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat) {
+  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
+      throws ExoPlaybackException {
     boolean passthrough = passthroughMediaFormat != null;
     String mimeType = passthrough ? passthroughMediaFormat.getString(MediaFormat.KEY_MIME)
         : MimeTypes.AUDIO_RAW;
     MediaFormat format = passthrough ? passthroughMediaFormat : outputFormat;
     int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
     int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
-    audioTrack.configure(mimeType, channelCount, sampleRate, pcmEncoding, 0);
+    int[] channelMap;
+    if (codecNeedsDiscardChannelsWorkaround && channelCount == 6 && this.channelCount < 6) {
+      channelMap = new int[this.channelCount];
+      for (int i = 0; i < this.channelCount; i++) {
+        channelMap[i] = i;
+      }
+    } else {
+      channelMap = null;
+    }
+
+    try {
+      audioTrack.configure(mimeType, channelCount, sampleRate, pcmEncoding, 0, channelMap);
+    } catch (AudioTrack.ConfigurationException e) {
+      throw ExoPlaybackException.createForRenderer(e, getIndex());
+    }
   }
 
   /**
-   * Called when the audio session id becomes known. Once the id is known it will not change (and
-   * hence this method will not be called again) unless the renderer is disabled and then
-   * subsequently re-enabled.
-   * <p>
-   * The default implementation is a no-op. One reason for overriding this method would be to
-   * instantiate and enable a {@link Virtualizer} in order to spatialize the audio channels. For
-   * this use case, any {@link Virtualizer} instances should be released in {@link #onDisabled()}
-   * (if not before).
+   * Called when the audio session id becomes known. The default implementation is a no-op. One
+   * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in
+   * order to spatialize the audio channels. For this use case, any {@link Virtualizer} instances
+   * should be released in {@link #onDisabled()} (if not before).
    *
-   * @param audioSessionId The audio session id.
+   * @see AudioTrack.Listener#onAudioSessionId(int)
    */
   protected void onAudioSessionId(int audioSessionId) {
     // Do nothing.
   }
 
+  /**
+   * @see AudioTrack.Listener#onPositionDiscontinuity()
+   */
+  protected void onAudioTrackPositionDiscontinuity() {
+    // Do nothing.
+  }
+
+  /**
+   * @see AudioTrack.Listener#onUnderrun(int, long, long)
+   */
+  protected void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
+      long elapsedSinceLastFeedMs) {
+    // Do nothing.
+  }
+
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     super.onEnabled(joining);
     eventDispatcher.enabled(decoderCounters);
+    int tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
+    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
+      audioTrack.enableTunnelingV21(tunnelingAudioSessionId);
+    } else {
+      audioTrack.disableTunneling();
+    }
   }
 
   @Override
@@ -274,7 +312,6 @@ protected void onStopped() {
 
   @Override
   protected void onDisabled() {
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     try {
       audioTrack.release();
     } finally {
@@ -289,7 +326,7 @@ protected void onDisabled() {
 
   @Override
   public boolean isEnded() {
-    return super.isEnded() && !audioTrack.hasPendingData();
+    return super.isEnded() && audioTrack.isEnded();
   }
 
   @Override
@@ -325,54 +362,25 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       return true;
     }
 
-    if (!audioTrack.isInitialized()) {
-      // Initialize the AudioTrack now.
-      try {
-        if (audioSessionId == AudioTrack.SESSION_ID_NOT_SET) {
-          audioSessionId = audioTrack.initialize(AudioTrack.SESSION_ID_NOT_SET);
-          eventDispatcher.audioSessionId(audioSessionId);
-          onAudioSessionId(audioSessionId);
-        } else {
-          audioTrack.initialize(audioSessionId);
-        }
-      } catch (AudioTrack.InitializationException e) {
-        throw ExoPlaybackException.createForRenderer(e, getIndex());
-      }
-      if (getState() == STATE_STARTED) {
-        audioTrack.play();
-      }
-    }
-
-    int handleBufferResult;
     try {
-      handleBufferResult = audioTrack.handleBuffer(buffer, bufferPresentationTimeUs);
-    } catch (AudioTrack.WriteException e) {
+      if (audioTrack.handleBuffer(buffer, bufferPresentationTimeUs)) {
+        codec.releaseOutputBuffer(bufferIndex, false);
+        decoderCounters.renderedOutputBufferCount++;
+        return true;
+      }
+    } catch (AudioTrack.InitializationException | AudioTrack.WriteException e) {
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
-
-    // If we are out of sync, allow currentPositionUs to jump backwards.
-    if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
-      handleAudioTrackDiscontinuity();
-      allowPositionDiscontinuity = true;
-    }
-
-    // Release the buffer if it was consumed.
-    if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
-      codec.releaseOutputBuffer(bufferIndex, false);
-      decoderCounters.renderedOutputBufferCount++;
-      return true;
-    }
-
     return false;
   }
 
   @Override
-  protected void onOutputStreamEnded() {
-    audioTrack.handleEndOfStream();
-  }
-
-  protected void handleAudioTrackDiscontinuity() {
-    // Do nothing
+  protected void renderToEndOfStream() throws ExoPlaybackException {
+    try {
+      audioTrack.playToEndOfStream();
+    } catch (AudioTrack.WriteException e) {
+      throw ExoPlaybackException.createForRenderer(e, getIndex());
+    }
   }
 
   @Override
@@ -386,9 +394,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
         break;
       case C.MSG_SET_STREAM_TYPE:
         @C.StreamType int streamType = (Integer) message;
-        if (audioTrack.setStreamType(streamType)) {
-          audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-        }
+        audioTrack.setStreamType(streamType);
         break;
       default:
         super.handleMessage(messageType, message);
@@ -396,11 +402,41 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
     }
   }
 
-  // AudioTrack.Listener implementation.
+  /**
+   * Returns whether the decoder is known to output six audio channels when provided with input with
+   * fewer than six channels.
+   * <p>
+   * See [Internal: b/35655036].
+   */
+  private static boolean codecNeedsDiscardChannelsWorkaround(String codecName) {
+    // The workaround applies to Samsung Galaxy S6 and Samsung Galaxy S7.
+    return Util.SDK_INT < 24 && "OMX.SEC.aac.dec".equals(codecName)
+        && "samsung".equals(Util.MANUFACTURER)
+        && (Util.DEVICE.startsWith("zeroflte") || Util.DEVICE.startsWith("herolte")
+        || Util.DEVICE.startsWith("heroqlte"));
+  }
+
+  private final class AudioTrackListener implements AudioTrack.Listener {
+
+    @Override
+    public void onAudioSessionId(int audioSessionId) {
+      eventDispatcher.audioSessionId(audioSessionId);
+      MediaCodecAudioRenderer.this.onAudioSessionId(audioSessionId);
+    }
+
+    @Override
+    public void onPositionDiscontinuity() {
+      onAudioTrackPositionDiscontinuity();
+      // We are out of sync so allow currentPositionUs to jump backwards.
+      MediaCodecAudioRenderer.this.allowPositionDiscontinuity = true;
+    }
+
+    @Override
+    public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+      eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+      onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+    }
 
-  @Override
-  public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
-    eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java b/library/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
new file mode 100644
index 0000000000..752f55a0ca
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * An {@link AudioProcessor} that converts audio data to {@link C#ENCODING_PCM_16BIT}.
+ */
+/* package */ final class ResamplingAudioProcessor implements AudioProcessor {
+
+  private int sampleRateHz;
+  private int channelCount;
+  @C.PcmEncoding
+  private int encoding;
+  private ByteBuffer buffer;
+  private ByteBuffer outputBuffer;
+  private boolean inputEnded;
+
+  /**
+   * Creates a new audio processor that converts audio data to {@link C#ENCODING_PCM_16BIT}.
+   */
+  public ResamplingAudioProcessor() {
+    sampleRateHz = Format.NO_VALUE;
+    channelCount = Format.NO_VALUE;
+    encoding = C.ENCODING_INVALID;
+    buffer = EMPTY_BUFFER;
+    outputBuffer = EMPTY_BUFFER;
+  }
+
+  @Override
+  public boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
+      throws UnhandledFormatException {
+    if (encoding != C.ENCODING_PCM_8BIT && encoding != C.ENCODING_PCM_16BIT
+        && encoding != C.ENCODING_PCM_24BIT && encoding != C.ENCODING_PCM_32BIT) {
+      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+    }
+    if (this.sampleRateHz == sampleRateHz && this.channelCount == channelCount
+        && this.encoding == encoding) {
+      return false;
+    }
+    this.sampleRateHz = sampleRateHz;
+    this.channelCount = channelCount;
+    this.encoding = encoding;
+    if (encoding == C.ENCODING_PCM_16BIT) {
+      buffer = EMPTY_BUFFER;
+    }
+    return true;
+  }
+
+  @Override
+  public boolean isActive() {
+    return encoding != C.ENCODING_INVALID && encoding != C.ENCODING_PCM_16BIT;
+  }
+
+  @Override
+  public int getOutputChannelCount() {
+    return channelCount;
+  }
+
+  @Override
+  public int getOutputEncoding() {
+    return C.ENCODING_PCM_16BIT;
+  }
+
+  @Override
+  public void queueInput(ByteBuffer inputBuffer) {
+    // Prepare the output buffer.
+    int position = inputBuffer.position();
+    int limit = inputBuffer.limit();
+    int size = limit - position;
+    int resampledSize;
+    switch (encoding) {
+      case C.ENCODING_PCM_8BIT:
+        resampledSize = size * 2;
+        break;
+      case C.ENCODING_PCM_24BIT:
+        resampledSize = (size / 3) * 2;
+        break;
+      case C.ENCODING_PCM_32BIT:
+        resampledSize = size / 2;
+        break;
+      case C.ENCODING_PCM_16BIT:
+      case C.ENCODING_INVALID:
+      case Format.NO_VALUE:
+      default:
+        throw new IllegalStateException();
+    }
+    if (buffer.capacity() < resampledSize) {
+      buffer = ByteBuffer.allocateDirect(resampledSize).order(ByteOrder.nativeOrder());
+    } else {
+      buffer.clear();
+    }
+
+    // Resample the little endian input and update the input/output buffers.
+    switch (encoding) {
+      case C.ENCODING_PCM_8BIT:
+        // 8->16 bit resampling. Shift each byte from [0, 256) to [-128, 128) and scale up.
+        for (int i = position; i < limit; i++) {
+          buffer.put((byte) 0);
+          buffer.put((byte) ((inputBuffer.get(i) & 0xFF) - 128));
+        }
+        break;
+      case C.ENCODING_PCM_24BIT:
+        // 24->16 bit resampling. Drop the least significant byte.
+        for (int i = position; i < limit; i += 3) {
+          buffer.put(inputBuffer.get(i + 1));
+          buffer.put(inputBuffer.get(i + 2));
+        }
+        break;
+      case C.ENCODING_PCM_32BIT:
+        // 32->16 bit resampling. Drop the two least significant bytes.
+        for (int i = position; i < limit; i += 4) {
+          buffer.put(inputBuffer.get(i + 2));
+          buffer.put(inputBuffer.get(i + 3));
+        }
+        break;
+      case C.ENCODING_PCM_16BIT:
+      case C.ENCODING_INVALID:
+      case Format.NO_VALUE:
+      default:
+        // Never happens.
+        throw new IllegalStateException();
+    }
+    inputBuffer.position(inputBuffer.limit());
+    buffer.flip();
+    outputBuffer = buffer;
+  }
+
+  @Override
+  public void queueEndOfStream() {
+    inputEnded = true;
+  }
+
+  @Override
+  public ByteBuffer getOutput() {
+    ByteBuffer outputBuffer = this.outputBuffer;
+    this.outputBuffer = EMPTY_BUFFER;
+    return outputBuffer;
+  }
+
+  @SuppressWarnings("ReferenceEquality")
+  @Override
+  public boolean isEnded() {
+    return inputEnded && outputBuffer == EMPTY_BUFFER;
+  }
+
+  @Override
+  public void flush() {
+    outputBuffer = EMPTY_BUFFER;
+    inputEnded = false;
+  }
+
+  @Override
+  public void release() {
+    flush();
+    buffer = EMPTY_BUFFER;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index 572f7b54c1..5594d9a90e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.audio;
 
 import android.media.PlaybackParams;
+import android.media.audiofx.Virtualizer;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
@@ -33,6 +34,7 @@
 import com.google.android.exoplayer2.drm.DrmSession;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.TraceUtil;
@@ -43,8 +45,7 @@
 /**
  * Decodes and renders audio using a {@link SimpleDecoder}.
  */
-public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements MediaClock,
-    AudioTrack.Listener {
+public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements MediaClock {
 
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
@@ -67,12 +68,12 @@
    */
   private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
 
+  private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
   private final boolean playClearSamplesWithoutKeys;
-
   private final EventDispatcher eventDispatcher;
   private final AudioTrack audioTrack;
-  private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
   private final FormatHolder formatHolder;
+  private final DecoderInputBuffer flagsOnlyBuffer;
 
   private DecoderCounters decoderCounters;
   private Format inputFormat;
@@ -83,8 +84,7 @@
   private DrmSession<ExoMediaCrypto> drmSession;
   private DrmSession<ExoMediaCrypto> pendingDrmSession;
 
-  @ReinitializationState
-  private int decoderReinitializationState;
+  @ReinitializationState private int decoderReinitializationState;
   private boolean decoderReceivedBuffers;
   private boolean audioTrackNeedsConfigure;
 
@@ -94,8 +94,6 @@
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
 
-  private int audioSessionId;
-
   public SimpleDecoderAudioRenderer() {
     this(null, null);
   }
@@ -104,10 +102,11 @@ public SimpleDecoderAudioRenderer() {
    * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
   public SimpleDecoderAudioRenderer(Handler eventHandler,
-      AudioRendererEventListener eventListener) {
-    this(eventHandler, eventListener, null);
+      AudioRendererEventListener eventListener, AudioProcessor... audioProcessors) {
+    this(eventHandler, eventListener, null, null, false, audioProcessors);
   }
 
   /**
@@ -135,17 +134,19 @@ public SimpleDecoderAudioRenderer(Handler eventHandler,
    *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
    *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param audioProcessors Optional {@link AudioProcessor}s that will process audio before output.
    */
   public SimpleDecoderAudioRenderer(Handler eventHandler,
       AudioRendererEventListener eventListener, AudioCapabilities audioCapabilities,
-      DrmSessionManager<ExoMediaCrypto> drmSessionManager, boolean playClearSamplesWithoutKeys) {
+      DrmSessionManager<ExoMediaCrypto> drmSessionManager, boolean playClearSamplesWithoutKeys,
+      AudioProcessor... audioProcessors) {
     super(C.TRACK_TYPE_AUDIO);
-    eventDispatcher = new EventDispatcher(eventHandler, eventListener);
-    audioTrack = new AudioTrack(audioCapabilities, this);
     this.drmSessionManager = drmSessionManager;
-    formatHolder = new FormatHolder();
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    eventDispatcher = new EventDispatcher(eventHandler, eventListener);
+    audioTrack = new AudioTrack(audioCapabilities, audioProcessors, new AudioTrackListener());
+    formatHolder = new FormatHolder();
+    flagsOnlyBuffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
     audioTrackNeedsConfigure = true;
   }
@@ -155,16 +156,53 @@ public MediaClock getMediaClock() {
     return this;
   }
 
+  @Override
+  public final int supportsFormat(Format format) {
+    int formatSupport = supportsFormatInternal(format);
+    if (formatSupport == FORMAT_UNSUPPORTED_TYPE || formatSupport == FORMAT_UNSUPPORTED_SUBTYPE) {
+      return formatSupport;
+    }
+    int tunnelingSupport = Util.SDK_INT >= 21 ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
+    return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | formatSupport;
+  }
+
+  /**
+   * Returns the {@link #FORMAT_SUPPORT_MASK} component of the return value for
+   * {@link #supportsFormat(Format)}.
+   *
+   * @param format The format.
+   * @return The extent to which the renderer supports the format itself.
+   */
+  protected abstract int supportsFormatInternal(Format format);
+
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     if (outputStreamEnded) {
+      try {
+        audioTrack.playToEndOfStream();
+      } catch (AudioTrack.WriteException e) {
+        throw ExoPlaybackException.createForRenderer(e, getIndex());
+      }
       return;
     }
 
     // Try and read a format if we don't have one already.
-    if (inputFormat == null && !readFormat()) {
-      // We can't make progress without one.
-      return;
+    if (inputFormat == null) {
+      // We don't have a format yet, so try and read one.
+      flagsOnlyBuffer.clear();
+      int result = readSource(formatHolder, flagsOnlyBuffer, true);
+      if (result == C.RESULT_FORMAT_READ) {
+        onInputFormatChanged(formatHolder.format);
+      } else if (result == C.RESULT_BUFFER_READ) {
+        // End of stream read having not read a format.
+        Assertions.checkState(flagsOnlyBuffer.isEndOfStream());
+        inputStreamEnded = true;
+        processEndOfStream();
+        return;
+      } else {
+        // We still don't have a format and can't make progress without one.
+        return;
+      }
     }
 
     // If we don't have a decoder yet, we need to instantiate one.
@@ -177,14 +215,41 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
         while (drainOutputBuffer()) {}
         while (feedInputBuffer()) {}
         TraceUtil.endSection();
-      } catch (AudioTrack.InitializationException | AudioTrack.WriteException
-          | AudioDecoderException e) {
+      } catch (AudioDecoderException | AudioTrack.ConfigurationException
+          | AudioTrack.InitializationException | AudioTrack.WriteException e) {
         throw ExoPlaybackException.createForRenderer(e, getIndex());
       }
       decoderCounters.ensureUpdated();
     }
   }
 
+  /**
+   * Called when the audio session id becomes known. The default implementation is a no-op. One
+   * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in
+   * order to spatialize the audio channels. For this use case, any {@link Virtualizer} instances
+   * should be released in {@link #onDisabled()} (if not before).
+   *
+   * @see AudioTrack.Listener#onAudioSessionId(int)
+   */
+  protected void onAudioSessionId(int audioSessionId) {
+    // Do nothing.
+  }
+
+  /**
+   * @see AudioTrack.Listener#onPositionDiscontinuity()
+   */
+  protected void onAudioTrackPositionDiscontinuity() {
+    // Do nothing.
+  }
+
+  /**
+   * @see AudioTrack.Listener#onUnderrun(int, long, long)
+   */
+  protected void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
+      long elapsedSinceLastFeedMs) {
+    // Do nothing.
+  }
+
   /**
    * Creates a decoder for the given format.
    *
@@ -212,7 +277,8 @@ protected Format getOutputFormat() {
   }
 
   private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderException,
-      AudioTrack.InitializationException, AudioTrack.WriteException {
+      AudioTrack.ConfigurationException, AudioTrack.InitializationException,
+      AudioTrack.WriteException {
     if (outputBuffer == null) {
       outputBuffer = decoder.dequeueOutputBuffer();
       if (outputBuffer == null) {
@@ -231,8 +297,7 @@ private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderExc
       } else {
         outputBuffer.release();
         outputBuffer = null;
-        outputStreamEnded = true;
-        audioTrack.handleEndOfStream();
+        processEndOfStream();
       }
       return false;
     }
@@ -244,28 +309,7 @@ private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderExc
       audioTrackNeedsConfigure = false;
     }
 
-    if (!audioTrack.isInitialized()) {
-      if (audioSessionId == AudioTrack.SESSION_ID_NOT_SET) {
-        audioSessionId = audioTrack.initialize(AudioTrack.SESSION_ID_NOT_SET);
-        eventDispatcher.audioSessionId(audioSessionId);
-        onAudioSessionId(audioSessionId);
-      } else {
-        audioTrack.initialize(audioSessionId);
-      }
-      if (getState() == STATE_STARTED) {
-        audioTrack.play();
-      }
-    }
-
-    int handleBufferResult = audioTrack.handleBuffer(outputBuffer.data, outputBuffer.timeUs);
-
-    // If we are out of sync, allow currentPositionUs to jump backwards.
-    if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
-      allowPositionDiscontinuity = true;
-    }
-
-    // Release the buffer if it was consumed.
-    if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
+    if (audioTrack.handleBuffer(outputBuffer.data, outputBuffer.timeUs)) {
       decoderCounters.renderedOutputBufferCount++;
       outputBuffer.release();
       outputBuffer = null;
@@ -302,7 +346,7 @@ private boolean feedInputBuffer() throws AudioDecoderException, ExoPlaybackExcep
       // We've already read an encrypted sample into buffer, and are waiting for keys.
       result = C.RESULT_BUFFER_READ;
     } else {
-      result = readSource(formatHolder, inputBuffer);
+      result = readSource(formatHolder, inputBuffer, false);
     }
 
     if (result == C.RESULT_NOTHING_READ) {
@@ -343,6 +387,15 @@ private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackExc
         && (bufferEncrypted || !playClearSamplesWithoutKeys);
   }
 
+  private void processEndOfStream() throws ExoPlaybackException {
+    outputStreamEnded = true;
+    try {
+      audioTrack.playToEndOfStream();
+    } catch (AudioTrack.WriteException e) {
+      throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+    }
+  }
+
   private void flushDecoder() throws ExoPlaybackException {
     waitingForKeys = false;
     if (decoderReinitializationState != REINITIALIZATION_STATE_NONE) {
@@ -361,7 +414,7 @@ private void flushDecoder() throws ExoPlaybackException {
 
   @Override
   public boolean isEnded() {
-    return outputStreamEnded && !audioTrack.hasPendingData();
+    return outputStreamEnded && audioTrack.isEnded();
   }
 
   @Override
@@ -381,23 +434,16 @@ public long getPositionUs() {
     return currentPositionUs;
   }
 
-  /**
-   * Called when the audio session id becomes known. Once the id is known it will not change (and
-   * hence this method will not be called again) unless the renderer is disabled and then
-   * subsequently re-enabled.
-   * <p>
-   * The default implementation is a no-op.
-   *
-   * @param audioSessionId The audio session id.
-   */
-  protected void onAudioSessionId(int audioSessionId) {
-    // Do nothing.
-  }
-
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     decoderCounters = new DecoderCounters();
     eventDispatcher.enabled(decoderCounters);
+    int tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
+    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
+      audioTrack.enableTunnelingV21(tunnelingAudioSessionId);
+    } else {
+      audioTrack.disableTunneling();
+    }
   }
 
   @Override
@@ -425,7 +471,6 @@ protected void onStopped() {
   @Override
   protected void onDisabled() {
     inputFormat = null;
-    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
     audioTrackNeedsConfigure = true;
     waitingForKeys = false;
     try {
@@ -499,15 +544,6 @@ private void releaseDecoder() {
     decoderReceivedBuffers = false;
   }
 
-  private boolean readFormat() throws ExoPlaybackException {
-    int result = readSource(formatHolder, null);
-    if (result == C.RESULT_FORMAT_READ) {
-      onInputFormatChanged(formatHolder.format);
-      return true;
-    }
-    return false;
-  }
-
   private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
     Format oldFormat = inputFormat;
     inputFormat = newFormat;
@@ -537,6 +573,7 @@ private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException
       // There aren't any final output buffers, so release the decoder immediately.
       releaseDecoder();
       maybeInitDecoder();
+      audioTrackNeedsConfigure = true;
     }
 
     eventDispatcher.inputFormatChanged(newFormat);
@@ -553,9 +590,7 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
         break;
       case C.MSG_SET_STREAM_TYPE:
         @C.StreamType int streamType = (Integer) message;
-        if (audioTrack.setStreamType(streamType)) {
-          audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
-        }
+        audioTrack.setStreamType(streamType);
         break;
       default:
         super.handleMessage(messageType, message);
@@ -563,11 +598,27 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
     }
   }
 
-  // AudioTrack.Listener implementation.
+  private final class AudioTrackListener implements AudioTrack.Listener {
+
+    @Override
+    public void onAudioSessionId(int audioSessionId) {
+      eventDispatcher.audioSessionId(audioSessionId);
+      SimpleDecoderAudioRenderer.this.onAudioSessionId(audioSessionId);
+    }
+
+    @Override
+    public void onPositionDiscontinuity() {
+      onAudioTrackPositionDiscontinuity();
+      // We are out of sync so allow currentPositionUs to jump backwards.
+      SimpleDecoderAudioRenderer.this.allowPositionDiscontinuity = true;
+    }
+
+    @Override
+    public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
+      eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+      onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+    }
 
-  @Override
-  public void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
-    eventDispatcher.audioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java b/library/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
index b76f3e8d0c..84c89de427 100644
--- a/library/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
@@ -61,8 +61,7 @@
    */
   public long timeUs;
 
-  @BufferReplacementMode
-  private final int bufferReplacementMode;
+  @BufferReplacementMode private final int bufferReplacementMode;
 
   /**
    * @param bufferReplacementMode Determines the behavior of {@link #ensureSpaceForWrite(int)}. One
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java b/library/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
similarity index 61%
rename from library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java
rename to library/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 4e4845c70b..6fc149ba32 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/StreamingDrmSessionManager.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -24,7 +24,10 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
+import android.support.annotation.IntDef;
 import android.text.TextUtils;
+import android.util.Log;
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.drm.ExoMediaDrm.KeyRequest;
@@ -32,19 +35,23 @@
 import com.google.android.exoplayer2.drm.ExoMediaDrm.ProvisionRequest;
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.HashMap;
+import java.util.Map;
 import java.util.UUID;
 
 /**
- * A {@link DrmSessionManager} that supports streaming playbacks using {@link MediaDrm}.
+ * A {@link DrmSessionManager} that supports playbacks using {@link MediaDrm}.
  */
 @TargetApi(18)
-public class StreamingDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T>,
+public class DefaultDrmSessionManager<T extends ExoMediaCrypto> implements DrmSessionManager<T>,
     DrmSession<T> {
 
   /**
-   * Listener of {@link StreamingDrmSessionManager} events.
+   * Listener of {@link DefaultDrmSessionManager} events.
    */
   public interface EventListener {
 
@@ -60,6 +67,16 @@
      */
     void onDrmSessionManagerError(Exception e);
 
+    /**
+     * Called each time offline keys are restored.
+     */
+    void onDrmKeysRestored();
+
+    /**
+     * Called each time offline keys are removed.
+     */
+    void onDrmKeysRemoved();
+
   }
 
   /**
@@ -67,9 +84,33 @@
    */
   public static final String PLAYREADY_CUSTOM_DATA_KEY = "PRCustomData";
 
+  /** Determines the action to be done after a session acquired. */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({MODE_PLAYBACK, MODE_QUERY, MODE_DOWNLOAD, MODE_RELEASE})
+  public @interface Mode {}
+  /**
+   * Loads and refreshes (if necessary) a license for playback. Supports streaming and offline
+   * licenses.
+   */
+  public static final int MODE_PLAYBACK = 0;
+  /**
+   * Restores an offline license to allow its status to be queried. If the offline license is
+   * expired sets state to {@link #STATE_ERROR}.
+   */
+  public static final int MODE_QUERY = 1;
+  /** Downloads an offline license or renews an existing one. */
+  public static final int MODE_DOWNLOAD = 2;
+  /** Releases an existing offline license. */
+  public static final int MODE_RELEASE = 3;
+
+  private static final String TAG = "OfflineDrmSessionMngr";
+  private static final String CENC_SCHEME_MIME_TYPE = "cenc";
+
   private static final int MSG_PROVISION = 0;
   private static final int MSG_KEYS = 1;
 
+  private static final int MAX_LICENSE_DURATION_TO_RENEW = 60;
+
   private final Handler eventHandler;
   private final EventListener eventListener;
   private final ExoMediaDrm<T> mediaDrm;
@@ -85,14 +126,17 @@
   private HandlerThread requestHandlerThread;
   private Handler postRequestHandler;
 
+  private int mode;
   private int openCount;
   private boolean provisioningInProgress;
   @DrmSession.State
   private int state;
   private T mediaCrypto;
-  private Exception lastException;
-  private SchemeData schemeData;
+  private DrmSessionException lastException;
+  private byte[] schemeInitData;
+  private String schemeMimeType;
   private byte[] sessionId;
+  private byte[] offlineLicenseKeySetId;
 
   /**
    * Instantiates a new instance using the Widevine scheme.
@@ -105,7 +149,7 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
-  public static StreamingDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
+  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newWidevineInstance(
       MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters,
       Handler eventHandler, EventListener eventListener) throws UnsupportedDrmException {
     return newFrameworkInstance(C.WIDEVINE_UUID, callback, optionalKeyRequestParameters,
@@ -125,7 +169,7 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
-  public static StreamingDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
+  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newPlayReadyInstance(
       MediaDrmCallback callback, String customData, Handler eventHandler,
       EventListener eventListener) throws UnsupportedDrmException {
     HashMap<String, String> optionalKeyRequestParameters;
@@ -151,10 +195,10 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @throws UnsupportedDrmException If the specified DRM scheme is not supported.
    */
-  public static StreamingDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
+  public static DefaultDrmSessionManager<FrameworkMediaCrypto> newFrameworkInstance(
       UUID uuid, MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters,
       Handler eventHandler, EventListener eventListener) throws UnsupportedDrmException {
-    return new StreamingDrmSessionManager<>(uuid, FrameworkMediaDrm.newInstance(uuid), callback,
+    return new DefaultDrmSessionManager<>(uuid, FrameworkMediaDrm.newInstance(uuid), callback,
         optionalKeyRequestParameters, eventHandler, eventListener);
   }
 
@@ -168,7 +212,7 @@
    *     null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public StreamingDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
+  public DefaultDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
       HashMap<String, String> optionalKeyRequestParameters, Handler eventHandler,
       EventListener eventListener) {
     this.uuid = uuid;
@@ -179,6 +223,7 @@ public StreamingDrmSessionManager(UUID uuid, ExoMediaDrm<T> mediaDrm, MediaDrmCa
     this.eventListener = eventListener;
     mediaDrm.setOnEventListener(new MediaDrmEventListener());
     state = STATE_CLOSED;
+    mode = MODE_PLAYBACK;
   }
 
   /**
@@ -229,6 +274,37 @@ public final void setPropertyByteArray(String key, byte[] value) {
     mediaDrm.setPropertyByteArray(key, value);
   }
 
+  /**
+   * Sets the mode, which determines the role of sessions acquired from the instance. This must be
+   * called before {@link #acquireSession(Looper, DrmInitData)} is called.
+   *
+   * <p>By default, the mode is {@link #MODE_PLAYBACK} and a streaming license is requested when
+   * required.
+   *
+   * <p>{@code mode} must be one of these:
+   * <ul>
+   * <li>{@link #MODE_PLAYBACK}: If {@code offlineLicenseKeySetId} is null, a streaming license is
+   *     requested otherwise the offline license is restored.
+   * <li>{@link #MODE_QUERY}: {@code offlineLicenseKeySetId} can not be null. The offline license
+   *     is restored.
+   * <li>{@link #MODE_DOWNLOAD}: If {@code offlineLicenseKeySetId} is null, an offline license is
+   *     requested otherwise the offline license is renewed.
+   * <li>{@link #MODE_RELEASE}: {@code offlineLicenseKeySetId} can not be null. The offline license
+   *     is released.
+   * </ul>
+   *
+   * @param mode The mode to be set.
+   * @param offlineLicenseKeySetId The key set id of the license to be used with the given mode.
+   */
+  public void setMode(@Mode int mode, byte[] offlineLicenseKeySetId) {
+    Assertions.checkState(openCount == 0);
+    if (mode == MODE_QUERY || mode == MODE_RELEASE) {
+      Assertions.checkNotNull(offlineLicenseKeySetId);
+    }
+    this.mode = mode;
+    this.offlineLicenseKeySetId = offlineLicenseKeySetId;
+  }
+
   // DrmSessionManager implementation.
 
   @Override
@@ -248,18 +324,28 @@ public final void setPropertyByteArray(String key, byte[] value) {
     requestHandlerThread.start();
     postRequestHandler = new PostRequestHandler(requestHandlerThread.getLooper());
 
-    schemeData = drmInitData.get(uuid);
-    if (schemeData == null) {
-      onError(new IllegalStateException("Media does not support uuid: " + uuid));
-      return this;
-    }
-    if (Util.SDK_INT < 21) {
-      // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
-      byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeData.data, C.WIDEVINE_UUID);
-      if (psshData == null) {
-        // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
-      } else {
-        schemeData = new SchemeData(C.WIDEVINE_UUID, schemeData.mimeType, psshData);
+    if (offlineLicenseKeySetId == null) {
+      SchemeData schemeData = drmInitData.get(uuid);
+      if (schemeData == null) {
+        onError(new IllegalStateException("Media does not support uuid: " + uuid));
+        return this;
+      }
+      schemeInitData = schemeData.data;
+      schemeMimeType = schemeData.mimeType;
+      if (Util.SDK_INT < 21) {
+        // Prior to L the Widevine CDM required data to be extracted from the PSSH atom.
+        byte[] psshData = PsshAtomUtil.parseSchemeSpecificData(schemeInitData, C.WIDEVINE_UUID);
+        if (psshData == null) {
+          // Extraction failed. schemeData isn't a Widevine PSSH atom, so leave it unchanged.
+        } else {
+          schemeInitData = psshData;
+        }
+      }
+      if (Util.SDK_INT < 26 && C.CLEARKEY_UUID.equals(uuid)
+          && (MimeTypes.VIDEO_MP4.equals(schemeMimeType)
+          || MimeTypes.AUDIO_MP4.equals(schemeMimeType))) {
+        // Prior to API level 26 the ClearKey CDM only accepted "cenc" as the scheme for MP4.
+        schemeMimeType = CENC_SCHEME_MIME_TYPE;
       }
     }
     state = STATE_OPENING;
@@ -280,7 +366,8 @@ public void releaseSession(DrmSession<T> session) {
     postRequestHandler = null;
     requestHandlerThread.quit();
     requestHandlerThread = null;
-    schemeData = null;
+    schemeInitData = null;
+    schemeMimeType = null;
     mediaCrypto = null;
     lastException = null;
     if (sessionId != null) {
@@ -314,10 +401,25 @@ public boolean requiresSecureDecoderComponent(String mimeType) {
   }
 
   @Override
-  public final Exception getError() {
+  public final DrmSessionException getError() {
     return state == STATE_ERROR ? lastException : null;
   }
 
+  @Override
+  public Map<String, String> queryKeyStatus() {
+    // User may call this method rightfully even if state == STATE_ERROR. So only check if there is
+    // a sessionId
+    if (sessionId == null) {
+      throw new IllegalStateException();
+    }
+    return mediaDrm.queryKeyStatus(sessionId);
+  }
+
+  @Override
+  public byte[] getOfflineLicenseKeySetId() {
+    return offlineLicenseKeySetId;
+  }
+
   // Internal methods.
 
   private void openInternal(boolean allowProvisioning) {
@@ -325,7 +427,7 @@ private void openInternal(boolean allowProvisioning) {
       sessionId = mediaDrm.openSession();
       mediaCrypto = mediaDrm.createMediaCrypto(uuid, sessionId);
       state = STATE_OPENED;
-      postKeyRequest();
+      doLicense();
     } catch (NotProvisionedException e) {
       if (allowProvisioning) {
         postProvisionRequest();
@@ -363,20 +465,86 @@ private void onProvisionResponse(Object response) {
       if (state == STATE_OPENING) {
         openInternal(false);
       } else {
-        postKeyRequest();
+        doLicense();
       }
     } catch (DeniedByServerException e) {
       onError(e);
     }
   }
 
-  private void postKeyRequest() {
-    KeyRequest keyRequest;
+  private void doLicense() {
+    switch (mode) {
+      case MODE_PLAYBACK:
+      case MODE_QUERY:
+        if (offlineLicenseKeySetId == null) {
+          postKeyRequest(sessionId, MediaDrm.KEY_TYPE_STREAMING);
+        } else {
+          if (restoreKeys()) {
+            long licenseDurationRemainingSec = getLicenseDurationRemainingSec();
+            if (mode == MODE_PLAYBACK
+                && licenseDurationRemainingSec <= MAX_LICENSE_DURATION_TO_RENEW) {
+              Log.d(TAG, "Offline license has expired or will expire soon. "
+                  + "Remaining seconds: " + licenseDurationRemainingSec);
+              postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
+            } else if (licenseDurationRemainingSec <= 0) {
+              onError(new KeysExpiredException());
+            } else {
+              state = STATE_OPENED_WITH_KEYS;
+              if (eventHandler != null && eventListener != null) {
+                eventHandler.post(new Runnable() {
+                  @Override
+                  public void run() {
+                    eventListener.onDrmKeysRestored();
+                  }
+                });
+              }
+            }
+          }
+        }
+        break;
+      case MODE_DOWNLOAD:
+        if (offlineLicenseKeySetId == null) {
+          postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
+        } else {
+          // Renew
+          if (restoreKeys()) {
+            postKeyRequest(sessionId, MediaDrm.KEY_TYPE_OFFLINE);
+          }
+        }
+        break;
+      case MODE_RELEASE:
+        if (restoreKeys()) {
+          postKeyRequest(offlineLicenseKeySetId, MediaDrm.KEY_TYPE_RELEASE);
+        }
+        break;
+    }
+  }
+
+  private boolean restoreKeys() {
     try {
-      keyRequest = mediaDrm.getKeyRequest(sessionId, schemeData.data, schemeData.mimeType,
-          MediaDrm.KEY_TYPE_STREAMING, optionalKeyRequestParameters);
+      mediaDrm.restoreKeys(sessionId, offlineLicenseKeySetId);
+      return true;
+    } catch (Exception e) {
+      Log.e(TAG, "Error trying to restore Widevine keys.", e);
+      onError(e);
+    }
+    return false;
+  }
+
+  private long getLicenseDurationRemainingSec() {
+    if (!C.WIDEVINE_UUID.equals(uuid)) {
+      return Long.MAX_VALUE;
+    }
+    Pair<Long, Long> pair = WidevineUtil.getLicenseDurationRemainingSec(this);
+    return Math.min(pair.first, pair.second);
+  }
+
+  private void postKeyRequest(byte[] scope, int keyType) {
+    try {
+      KeyRequest keyRequest = mediaDrm.getKeyRequest(scope, schemeInitData, schemeMimeType, keyType,
+          optionalKeyRequestParameters);
       postRequestHandler.obtainMessage(MSG_KEYS, keyRequest).sendToTarget();
-    } catch (NotProvisionedException e) {
+    } catch (Exception e) {
       onKeysError(e);
     }
   }
@@ -393,15 +561,31 @@ private void onKeyResponse(Object response) {
     }
 
     try {
-      mediaDrm.provideKeyResponse(sessionId, (byte[]) response);
-      state = STATE_OPENED_WITH_KEYS;
-      if (eventHandler != null && eventListener != null) {
-        eventHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            eventListener.onDrmKeysLoaded();
-          }
-        });
+      if (mode == MODE_RELEASE) {
+        mediaDrm.provideKeyResponse(offlineLicenseKeySetId, (byte[]) response);
+        if (eventHandler != null && eventListener != null) {
+          eventHandler.post(new Runnable() {
+            @Override
+            public void run() {
+              eventListener.onDrmKeysRemoved();
+            }
+          });
+        }
+      } else {
+        byte[] keySetId = mediaDrm.provideKeyResponse(sessionId, (byte[]) response);
+        if ((mode == MODE_DOWNLOAD || (mode == MODE_PLAYBACK && offlineLicenseKeySetId != null))
+            && keySetId != null && keySetId.length != 0) {
+          offlineLicenseKeySetId = keySetId;
+        }
+        state = STATE_OPENED_WITH_KEYS;
+        if (eventHandler != null && eventListener != null) {
+          eventHandler.post(new Runnable() {
+            @Override
+            public void run() {
+              eventListener.onDrmKeysLoaded();
+            }
+          });
+        }
       }
     } catch (Exception e) {
       onKeysError(e);
@@ -417,7 +601,7 @@ private void onKeysError(Exception e) {
   }
 
   private void onError(final Exception e) {
-    lastException = e;
+    lastException = new DrmSessionException(e);
     if (eventHandler != null && eventListener != null) {
       eventHandler.post(new Runnable() {
         @Override
@@ -446,11 +630,16 @@ public void handleMessage(Message msg) {
       }
       switch (msg.what) {
         case MediaDrm.EVENT_KEY_REQUIRED:
-          postKeyRequest();
+          doLicense();
           break;
         case MediaDrm.EVENT_KEY_EXPIRED:
-          state = STATE_OPENED;
-          onError(new KeysExpiredException());
+          // When an already expired key is loaded MediaDrm sends this event immediately. Ignore
+          // this event if the state isn't STATE_OPENED_WITH_KEYS yet which means we're still
+          // waiting for key response.
+          if (state == STATE_OPENED_WITH_KEYS) {
+            state = STATE_OPENED;
+            onError(new KeysExpiredException());
+          }
           break;
         case MediaDrm.EVENT_PROVISION_REQUIRED:
           state = STATE_OPENED;
@@ -466,7 +655,9 @@ public void handleMessage(Message msg) {
     @Override
     public void onEvent(ExoMediaDrm<? extends T> md, byte[] sessionId, int event, int extra,
         byte[] data) {
-      mediaDrmHandler.sendEmptyMessage(event);
+      if (mode == MODE_PLAYBACK) {
+        mediaDrmHandler.sendEmptyMessage(event);
+      }
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
index 6f84395072..538db9e1d9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/DrmSession.java
@@ -16,9 +16,11 @@
 package com.google.android.exoplayer2.drm;
 
 import android.annotation.TargetApi;
+import android.media.MediaDrm;
 import android.support.annotation.IntDef;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Map;
 
 /**
  * A DRM session.
@@ -26,6 +28,15 @@
 @TargetApi(16)
 public interface DrmSession<T extends ExoMediaCrypto> {
 
+  /** Wraps the exception which is the cause of the error state. */
+  class DrmSessionException extends Exception {
+
+    public DrmSessionException(Exception e) {
+      super(e);
+    }
+
+  }
+
   /**
    * The state of the DRM session.
    */
@@ -59,8 +70,7 @@
    * @return One of {@link #STATE_ERROR}, {@link #STATE_CLOSED}, {@link #STATE_OPENING},
    *     {@link #STATE_OPENED} and {@link #STATE_OPENED_WITH_KEYS}.
    */
-  @State
-  int getState();
+  @State int getState();
 
   /**
    * Returns a {@link ExoMediaCrypto} for the open session.
@@ -96,6 +106,26 @@
    *
    * @return An exception if the state is {@link #STATE_ERROR}. Null otherwise.
    */
-  Exception getError();
+  DrmSessionException getError();
+
+  /**
+   * Returns an informative description of the key status for the session. The status is in the form
+   * of {name, value} pairs.
+   *
+   * <p>Since DRM license policies vary by vendor, the specific status field names are determined by
+   * each DRM vendor. Refer to your DRM provider documentation for definitions of the field names
+   * for a particular DRM engine plugin.
+   *
+   * @return A map of key status.
+   * @throws IllegalStateException If called when the session isn't opened.
+   * @see MediaDrm#queryKeyStatus(byte[])
+   */
+  Map<String, String> queryKeyStatus();
+
+  /**
+   * Returns the key set id of the offline license loaded into this session, if there is one. Null
+   * otherwise.
+   */
+  byte[] getOfflineLicenseKeySetId();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java b/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
index 65e41dd91e..f9d5efffb1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/HttpMediaDrmCallback.java
@@ -24,6 +24,8 @@
 import com.google.android.exoplayer2.upstream.DataSourceInputStream;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.HashMap;
@@ -57,21 +59,62 @@ public HttpMediaDrmCallback(String defaultUrl, HttpDataSource.Factory dataSource
   }
 
   /**
+   * @deprecated Use {@link HttpMediaDrmCallback#HttpMediaDrmCallback(String, Factory)}. Request
+   *     properties can be set by calling {@link #setKeyRequestProperty(String, String)}.
    * @param defaultUrl The default license URL.
    * @param dataSourceFactory A factory from which to obtain {@link HttpDataSource} instances.
    * @param keyRequestProperties Request properties to set when making key requests, or null.
    */
+  @Deprecated
   public HttpMediaDrmCallback(String defaultUrl, HttpDataSource.Factory dataSourceFactory,
       Map<String, String> keyRequestProperties) {
     this.dataSourceFactory = dataSourceFactory;
     this.defaultUrl = defaultUrl;
-    this.keyRequestProperties = keyRequestProperties;
+    this.keyRequestProperties = new HashMap<>();
+    if (keyRequestProperties != null) {
+      this.keyRequestProperties.putAll(keyRequestProperties);
+    }
+  }
+
+  /**
+   * Sets a header for key requests made by the callback.
+   *
+   * @param name The name of the header field.
+   * @param value The value of the field.
+   */
+  public void setKeyRequestProperty(String name, String value) {
+    Assertions.checkNotNull(name);
+    Assertions.checkNotNull(value);
+    synchronized (keyRequestProperties) {
+      keyRequestProperties.put(name, value);
+    }
+  }
+
+  /**
+   * Clears a header for key requests made by the callback.
+   *
+   * @param name The name of the header field.
+   */
+  public void clearKeyRequestProperty(String name) {
+    Assertions.checkNotNull(name);
+    synchronized (keyRequestProperties) {
+      keyRequestProperties.remove(name);
+    }
+  }
+
+  /**
+   * Clears all headers for key requests made by the callback.
+   */
+  public void clearAllKeyRequestProperties() {
+    synchronized (keyRequestProperties) {
+      keyRequestProperties.clear();
+    }
   }
 
   @Override
   public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
     String url = request.getDefaultUrl() + "&signedRequest=" + new String(request.getData());
-    return executePost(url, new byte[0], null);
+    return executePost(dataSourceFactory, url, new byte[0], null);
   }
 
   @Override
@@ -85,14 +128,14 @@ public HttpMediaDrmCallback(String defaultUrl, HttpDataSource.Factory dataSource
     if (C.PLAYREADY_UUID.equals(uuid)) {
       requestProperties.putAll(PLAYREADY_KEY_REQUEST_PROPERTIES);
     }
-    if (keyRequestProperties != null) {
+    synchronized (keyRequestProperties) {
       requestProperties.putAll(keyRequestProperties);
     }
-    return executePost(url, request.getData(), requestProperties);
+    return executePost(dataSourceFactory, url, request.getData(), requestProperties);
   }
 
-  private byte[] executePost(String url, byte[] data, Map<String, String> requestProperties)
-      throws IOException {
+  private static byte[] executePost(HttpDataSource.Factory dataSourceFactory, String url,
+      byte[] data, Map<String, String> requestProperties) throws IOException {
     HttpDataSource dataSource = dataSourceFactory.createDataSource();
     if (requestProperties != null) {
       for (Map.Entry<String, String> requestProperty : requestProperties.entrySet()) {
@@ -105,7 +148,7 @@ public HttpMediaDrmCallback(String defaultUrl, HttpDataSource.Factory dataSource
     try {
       return Util.toByteArray(inputStream);
     } finally {
-      inputStream.close();
+      Util.closeQuietly(inputStream);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java b/library/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
new file mode 100644
index 0000000000..ad44574af9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/OfflineLicenseHelper.java
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.exoplayer2.drm;
+
+import android.media.MediaDrm;
+import android.os.ConditionVariable;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager.EventListener;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager.Mode;
+import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
+import com.google.android.exoplayer2.source.dash.DashUtil;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+import java.util.HashMap;
+
+/**
+ * Helper class to download, renew and release offline licenses. It utilizes {@link
+ * DefaultDrmSessionManager}.
+ */
+public final class OfflineLicenseHelper<T extends ExoMediaCrypto> {
+
+  private final ConditionVariable conditionVariable;
+  private final DefaultDrmSessionManager<T> drmSessionManager;
+  private final HandlerThread handlerThread;
+
+  /**
+   * Instantiates a new instance which uses Widevine CDM. Call {@link #releaseResources()} when
+   * you're done with the helper instance.
+   *
+   * @param licenseUrl The default license URL.
+   * @param httpDataSourceFactory A factory from which to obtain {@link HttpDataSource} instances.
+   * @return A new instance which uses Widevine CDM.
+   * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
+   *     instantiated.
+   */
+  public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
+      String licenseUrl, Factory httpDataSourceFactory) throws UnsupportedDrmException {
+    return newWidevineInstance(
+        new HttpMediaDrmCallback(licenseUrl, httpDataSourceFactory), null);
+  }
+
+  /**
+   * Instantiates a new instance which uses Widevine CDM. Call {@link #releaseResources()} when
+   * you're done with the helper instance.
+   *
+   * @param callback Performs key and provisioning requests.
+   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
+   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * @return A new instance which uses Widevine CDM.
+   * @throws UnsupportedDrmException If the Widevine DRM scheme is unsupported or cannot be
+   *     instantiated.
+   * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
+   *     MediaDrmCallback, HashMap, Handler, EventListener)
+   */
+  public static OfflineLicenseHelper<FrameworkMediaCrypto> newWidevineInstance(
+      MediaDrmCallback callback, HashMap<String, String> optionalKeyRequestParameters)
+      throws UnsupportedDrmException {
+    return new OfflineLicenseHelper<>(FrameworkMediaDrm.newInstance(C.WIDEVINE_UUID), callback,
+        optionalKeyRequestParameters);
+  }
+
+  /**
+   * Constructs an instance. Call {@link #releaseResources()} when you're done with it.
+   *
+   * @param mediaDrm An underlying {@link ExoMediaDrm} for use by the manager.
+   * @param callback Performs key and provisioning requests.
+   * @param optionalKeyRequestParameters An optional map of parameters to pass as the last argument
+   *     to {@link MediaDrm#getKeyRequest(byte[], byte[], String, int, HashMap)}. May be null.
+   * @see DefaultDrmSessionManager#DefaultDrmSessionManager(java.util.UUID, ExoMediaDrm,
+   *     MediaDrmCallback, HashMap, Handler, EventListener)
+   */
+  public OfflineLicenseHelper(ExoMediaDrm<T> mediaDrm, MediaDrmCallback callback,
+      HashMap<String, String> optionalKeyRequestParameters) {
+    handlerThread = new HandlerThread("OfflineLicenseHelper");
+    handlerThread.start();
+
+    conditionVariable = new ConditionVariable();
+    EventListener eventListener = new EventListener() {
+      @Override
+      public void onDrmKeysLoaded() {
+        conditionVariable.open();
+      }
+
+      @Override
+      public void onDrmSessionManagerError(Exception e) {
+        conditionVariable.open();
+      }
+
+      @Override
+      public void onDrmKeysRestored() {
+        conditionVariable.open();
+      }
+
+      @Override
+      public void onDrmKeysRemoved() {
+        conditionVariable.open();
+      }
+    };
+    drmSessionManager = new DefaultDrmSessionManager<>(C.WIDEVINE_UUID, mediaDrm, callback,
+        optionalKeyRequestParameters, new Handler(handlerThread.getLooper()), eventListener);
+  }
+
+  /** Releases the used resources. */
+  public void releaseResources() {
+    handlerThread.quit();
+  }
+
+  /**
+   * Downloads an offline license.
+   *
+   * @param dataSource The {@link HttpDataSource} to be used for download.
+   * @param manifestUriString The URI of the manifest to be read.
+   * @return The downloaded offline license key set id.
+   * @throws IOException If an error occurs reading data from the stream.
+   * @throws InterruptedException If the thread has been interrupted.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public byte[] download(HttpDataSource dataSource, String manifestUriString)
+      throws IOException, InterruptedException, DrmSessionException {
+    return download(dataSource, DashUtil.loadManifest(dataSource, manifestUriString));
+  }
+
+  /**
+   * Downloads an offline license.
+   *
+   * @param dataSource The {@link HttpDataSource} to be used for download.
+   * @param dashManifest The {@link DashManifest} of the DASH content.
+   * @return The downloaded offline license key set id.
+   * @throws IOException If an error occurs reading data from the stream.
+   * @throws InterruptedException If the thread has been interrupted.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public byte[] download(HttpDataSource dataSource, DashManifest dashManifest)
+      throws IOException, InterruptedException, DrmSessionException {
+    // Get DrmInitData
+    // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
+    // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
+    if (dashManifest.getPeriodCount() < 1) {
+      return null;
+    }
+    Period period = dashManifest.getPeriod(0);
+    int adaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_VIDEO);
+    if (adaptationSetIndex == C.INDEX_UNSET) {
+      adaptationSetIndex = period.getAdaptationSetIndex(C.TRACK_TYPE_AUDIO);
+      if (adaptationSetIndex == C.INDEX_UNSET) {
+        return null;
+      }
+    }
+    AdaptationSet adaptationSet = period.adaptationSets.get(adaptationSetIndex);
+    if (adaptationSet.representations.isEmpty()) {
+      return null;
+    }
+    Representation representation = adaptationSet.representations.get(0);
+    DrmInitData drmInitData = representation.format.drmInitData;
+    if (drmInitData == null) {
+      Format sampleFormat = DashUtil.loadSampleFormat(dataSource, representation);
+      if (sampleFormat != null) {
+        drmInitData = sampleFormat.drmInitData;
+      }
+      if (drmInitData == null) {
+        return null;
+      }
+    }
+    blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, null, drmInitData);
+    return drmSessionManager.getOfflineLicenseKeySetId();
+  }
+
+  /**
+   * Renews an offline license.
+   *
+   * @param offlineLicenseKeySetId The key set id of the license to be renewed.
+   * @return Renewed offline license key set id.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public byte[] renew(byte[] offlineLicenseKeySetId) throws DrmSessionException {
+    Assertions.checkNotNull(offlineLicenseKeySetId);
+    blockingKeyRequest(DefaultDrmSessionManager.MODE_DOWNLOAD, offlineLicenseKeySetId, null);
+    return drmSessionManager.getOfflineLicenseKeySetId();
+  }
+
+  /**
+   * Releases an offline license.
+   *
+   * @param offlineLicenseKeySetId The key set id of the license to be released.
+   * @throws DrmSessionException Thrown when there is an error during DRM session.
+   */
+  public void release(byte[] offlineLicenseKeySetId) throws DrmSessionException {
+    Assertions.checkNotNull(offlineLicenseKeySetId);
+    blockingKeyRequest(DefaultDrmSessionManager.MODE_RELEASE, offlineLicenseKeySetId, null);
+  }
+
+  /**
+   * Returns license and playback durations remaining in seconds of the given offline license.
+   *
+   * @param offlineLicenseKeySetId The key set id of the license.
+   */
+  public Pair<Long, Long> getLicenseDurationRemainingSec(byte[] offlineLicenseKeySetId)
+      throws DrmSessionException {
+    Assertions.checkNotNull(offlineLicenseKeySetId);
+    DrmSession<T> session = openBlockingKeyRequest(DefaultDrmSessionManager.MODE_QUERY,
+        offlineLicenseKeySetId, null);
+    Pair<Long, Long> licenseDurationRemainingSec =
+        WidevineUtil.getLicenseDurationRemainingSec(drmSessionManager);
+    drmSessionManager.releaseSession(session);
+    return licenseDurationRemainingSec;
+  }
+
+  private void blockingKeyRequest(@Mode int licenseMode, byte[] offlineLicenseKeySetId,
+      DrmInitData drmInitData) throws DrmSessionException {
+    DrmSession<T> session = openBlockingKeyRequest(licenseMode, offlineLicenseKeySetId,
+        drmInitData);
+    DrmSessionException error = session.getError();
+    if (error != null) {
+      throw error;
+    }
+    drmSessionManager.releaseSession(session);
+  }
+
+  private DrmSession<T> openBlockingKeyRequest(@Mode int licenseMode, byte[] offlineLicenseKeySetId,
+      DrmInitData drmInitData) {
+    drmSessionManager.setMode(licenseMode, offlineLicenseKeySetId);
+    conditionVariable.close();
+    DrmSession<T> session = drmSessionManager.acquireSession(handlerThread.getLooper(),
+        drmInitData);
+    // Block current thread until key loading is finished
+    conditionVariable.block();
+    return session;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java b/library/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
index 505750efaa..f0e748d722 100644
--- a/library/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/UnsupportedDrmException.java
@@ -43,8 +43,7 @@
   /**
    * Either {@link #REASON_UNSUPPORTED_SCHEME} or {@link #REASON_INSTANTIATION_ERROR}.
    */
-  @Reason
-  public final int reason;
+  @Reason public final int reason;
 
   /**
    * @param reason {@link #REASON_UNSUPPORTED_SCHEME} or {@link #REASON_INSTANTIATION_ERROR}.
diff --git a/library/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java b/library/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java
new file mode 100644
index 0000000000..fc80cfb6fb
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/drm/WidevineUtil.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.drm;
+
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import java.util.Map;
+
+/**
+ * Utility methods for Widevine.
+ */
+public final class WidevineUtil {
+
+  /** Widevine specific key status field name for the remaining license duration, in seconds. */
+  public static final String PROPERTY_LICENSE_DURATION_REMAINING = "LicenseDurationRemaining";
+  /** Widevine specific key status field name for the remaining playback duration, in seconds. */
+  public static final String PROPERTY_PLAYBACK_DURATION_REMAINING = "PlaybackDurationRemaining";
+
+  private WidevineUtil() {}
+
+  /**
+   * Returns license and playback durations remaining in seconds.
+   *
+   * @return A {@link Pair} consisting of the remaining license and playback durations in seconds.
+   * @throws IllegalStateException If called when a session isn't opened.
+   * @param drmSession
+   */
+  public static Pair<Long, Long> getLicenseDurationRemainingSec(DrmSession drmSession) {
+    Map<String, String> keyStatus = drmSession.queryKeyStatus();
+    return new Pair<>(
+        getDurationRemainingSec(keyStatus, PROPERTY_LICENSE_DURATION_REMAINING),
+        getDurationRemainingSec(keyStatus, PROPERTY_PLAYBACK_DURATION_REMAINING));
+  }
+
+  private static long getDurationRemainingSec(Map<String, String> keyStatus, String property) {
+    if (keyStatus != null) {
+      try {
+        String value = keyStatus.get(property);
+        if (value != null) {
+          return Long.parseLong(value);
+        }
+      } catch (NumberFormatException e) {
+        // do nothing.
+      }
+    }
+    return C.TIME_UNSET;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
index bca5ecf3bd..87355a6c78 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 import java.util.Arrays;
@@ -27,6 +28,8 @@
  */
 public final class DefaultExtractorInput implements ExtractorInput {
 
+  private static final int PEEK_MIN_FREE_SPACE_AFTER_RESIZE = 64 * 1024;
+  private static final int PEEK_MAX_FREE_SPACE = 512 * 1024;
   private static final byte[] SCRATCH_SPACE = new byte[4096];
 
   private final DataSource dataSource;
@@ -46,7 +49,7 @@ public DefaultExtractorInput(DataSource dataSource, long position, long length)
     this.dataSource = dataSource;
     this.position = position;
     this.streamLength = length;
-    peekBuffer = new byte[8 * 1024];
+    peekBuffer = new byte[PEEK_MIN_FREE_SPACE_AFTER_RESIZE];
   }
 
   @Override
@@ -176,7 +179,9 @@ public long getLength() {
   private void ensureSpaceForPeek(int length) {
     int requiredLength = peekBufferPosition + length;
     if (requiredLength > peekBuffer.length) {
-      peekBuffer = Arrays.copyOf(peekBuffer, Math.max(peekBuffer.length * 2, requiredLength));
+      int newPeekCapacity = Util.constrainValue(peekBuffer.length * 2,
+          requiredLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE, requiredLength + PEEK_MAX_FREE_SPACE);
+      peekBuffer = Arrays.copyOf(peekBuffer, newPeekCapacity);
     }
   }
 
@@ -218,7 +223,12 @@ private int readFromPeekBuffer(byte[] target, int offset, int length) {
   private void updatePeekBuffer(int bytesConsumed) {
     peekBufferLength -= bytesConsumed;
     peekBufferPosition = 0;
-    System.arraycopy(peekBuffer, bytesConsumed, peekBuffer, 0, peekBufferLength);
+    byte[] newPeekBuffer = peekBuffer;
+    if (peekBufferLength < peekBuffer.length - PEEK_MAX_FREE_SPACE) {
+      newPeekBuffer = new byte[peekBufferLength + PEEK_MIN_FREE_SPACE_AFTER_RESIZE];
+    }
+    System.arraycopy(peekBuffer, bytesConsumed, newPeekBuffer, 0, peekBufferLength);
+    peekBuffer = newPeekBuffer;
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
index cb9e41aa62..8aff8858a1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
@@ -70,6 +70,8 @@
   private Format downstreamFormat;
 
   // Accessed only by the loading thread (or the consuming thread when there is no loading thread).
+  private boolean pendingFormatAdjustment;
+  private Format lastUnadjustedFormat;
   private long sampleOffsetUs;
   private long totalBytesWritten;
   private Allocation lastAllocation;
@@ -226,13 +228,32 @@ public long getLargestQueuedTimestampUs() {
   }
 
   /**
-   * Attempts to skip to the keyframe before the specified time, if it's present in the buffer.
+   * Attempts to skip to the keyframe before or at the specified time. Succeeds only if the buffer
+   * contains a keyframe with a timestamp of {@code timeUs} or earlier, and if {@code timeUs} falls
+   * within the currently buffered media.
+   * <p>
+   * This method is equivalent to {@code skipToKeyframeBefore(timeUs, false)}.
    *
    * @param timeUs The seek time.
    * @return Whether the skip was successful.
    */
   public boolean skipToKeyframeBefore(long timeUs) {
-    long nextOffset = infoQueue.skipToKeyframeBefore(timeUs);
+    return skipToKeyframeBefore(timeUs, false);
+  }
+
+  /**
+   * Attempts to skip to the keyframe before or at the specified time. Succeeds only if the buffer
+   * contains a keyframe with a timestamp of {@code timeUs} or earlier. If
+   * {@code allowTimeBeyondBuffer} is {@code false} then it is also required that {@code timeUs}
+   * falls within the buffer.
+   *
+   * @param timeUs The seek time.
+   * @param allowTimeBeyondBuffer Whether the skip can succeed if {@code timeUs} is beyond the end
+   *     of the buffer.
+   * @return Whether the skip was successful.
+   */
+  public boolean skipToKeyframeBefore(long timeUs, boolean allowTimeBeyondBuffer) {
+    long nextOffset = infoQueue.skipToKeyframeBefore(timeUs, allowTimeBeyondBuffer);
     if (nextOffset == C.POSITION_UNSET) {
       return false;
     }
@@ -247,38 +268,41 @@ public boolean skipToKeyframeBefore(long timeUs) {
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the
    *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   * @param formatRequired Whether the caller requires that the format of the stream be read even if
+   *     it's not changing. A sample will never be read if set to true, however it is still possible
+   *     for the end of stream or nothing to be read.
    * @param loadingFinished True if an empty queue should be considered the end of the stream.
    * @param decodeOnlyUntilUs If a buffer is read, the {@link C#BUFFER_FLAG_DECODE_ONLY} flag will
    *     be set if the buffer's timestamp is less than this value.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
-  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean loadingFinished,
-      long decodeOnlyUntilUs) {
-    switch (infoQueue.readData(formatHolder, buffer, downstreamFormat, extrasHolder)) {
-      case C.RESULT_NOTHING_READ:
-        if (loadingFinished) {
-          buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
-          return C.RESULT_BUFFER_READ;
-        }
-        return C.RESULT_NOTHING_READ;
+  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired,
+      boolean loadingFinished, long decodeOnlyUntilUs) {
+    int result = infoQueue.readData(formatHolder, buffer, formatRequired, loadingFinished,
+        downstreamFormat, extrasHolder);
+    switch (result) {
       case C.RESULT_FORMAT_READ:
         downstreamFormat = formatHolder.format;
         return C.RESULT_FORMAT_READ;
       case C.RESULT_BUFFER_READ:
-        if (buffer.timeUs < decodeOnlyUntilUs) {
-          buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
-        }
-        // Read encryption data if the sample is encrypted.
-        if (buffer.isEncrypted()) {
-          readEncryptionData(buffer, extrasHolder);
+        if (!buffer.isEndOfStream()) {
+          if (buffer.timeUs < decodeOnlyUntilUs) {
+            buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
+          }
+          // Read encryption data if the sample is encrypted.
+          if (buffer.isEncrypted()) {
+            readEncryptionData(buffer, extrasHolder);
+          }
+          // Write the sample data into the holder.
+          buffer.ensureSpaceForWrite(extrasHolder.size);
+          readData(extrasHolder.offset, buffer.data, extrasHolder.size);
+          // Advance the read head.
+          dropDownstreamTo(extrasHolder.nextOffset);
         }
-        // Write the sample data into the holder.
-        buffer.ensureSpaceForWrite(extrasHolder.size);
-        readData(extrasHolder.offset, buffer.data, extrasHolder.size);
-        // Advance the read head.
-        dropDownstreamTo(extrasHolder.nextOffset);
         return C.RESULT_BUFFER_READ;
+      case C.RESULT_NOTHING_READ:
+        return C.RESULT_NOTHING_READ;
       default:
         throw new IllegalStateException();
     }
@@ -425,23 +449,24 @@ public void setUpstreamFormatChangeListener(UpstreamFormatChangedListener listen
   }
 
   /**
-   * Like {@link #format(Format)}, but with an offset that will be added to the timestamps of
-   * samples subsequently queued to the buffer. The offset is also used to adjust
-   * {@link Format#subsampleOffsetUs} for both the {@link Format} passed and those subsequently
-   * passed to {@link #format(Format)}.
+   * Sets an offset that will be added to the timestamps (and sub-sample timestamps) of samples
+   * subsequently queued to the buffer.
    *
-   * @param format The format.
    * @param sampleOffsetUs The timestamp offset in microseconds.
    */
-  public void formatWithOffset(Format format, long sampleOffsetUs) {
-    this.sampleOffsetUs = sampleOffsetUs;
-    format(format);
+  public void setSampleOffsetUs(long sampleOffsetUs) {
+    if (this.sampleOffsetUs != sampleOffsetUs) {
+      this.sampleOffsetUs = sampleOffsetUs;
+      pendingFormatAdjustment = true;
+    }
   }
 
   @Override
   public void format(Format format) {
     Format adjustedFormat = getAdjustedSampleFormat(format, sampleOffsetUs);
     boolean formatChanged = infoQueue.format(adjustedFormat);
+    lastUnadjustedFormat = format;
+    pendingFormatAdjustment = false;
     if (upstreamFormatChangeListener != null && formatChanged) {
       upstreamFormatChangeListener.onUpstreamFormatChanged(adjustedFormat);
     }
@@ -498,6 +523,9 @@ public void sampleData(ParsableByteArray buffer, int length) {
   @Override
   public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
       byte[] encryptionKey) {
+    if (pendingFormatAdjustment) {
+      format(lastUnadjustedFormat);
+    }
     if (!startWriteOperation()) {
       infoQueue.commitSampleTimestamp(timeUs);
       return;
@@ -732,24 +760,36 @@ public synchronized long getLargestQueuedTimestampUs() {
      *     about the sample, but not its data. The size and absolute position of the data in the
      *     rolling buffer is stored in {@code extrasHolder}, along with an encryption id if present
      *     and the absolute position of the first byte that may still be required after the current
-     *     sample has been read.
+     *     sample has been read. May be null if the caller requires that the format of the stream be
+     *     read even if it's not changing.
+     * @param formatRequired Whether the caller requires that the format of the stream be read even
+     *     if it's not changing. A sample will never be read if set to true, however it is still
+     *     possible for the end of stream or nothing to be read.
+     * @param loadingFinished True if an empty queue should be considered the end of the stream.
      * @param downstreamFormat The current downstream {@link Format}. If the format of the next
      *     sample is different to the current downstream format then a format will be read.
      * @param extrasHolder The holder into which extra sample information should be written.
      * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ}
      *     or {@link C#RESULT_BUFFER_READ}.
      */
+    @SuppressWarnings("ReferenceEquality")
     public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
-        Format downstreamFormat, BufferExtrasHolder extrasHolder) {
+        boolean formatRequired, boolean loadingFinished, Format downstreamFormat,
+        BufferExtrasHolder extrasHolder) {
       if (queueSize == 0) {
-        if (upstreamFormat != null && upstreamFormat != downstreamFormat) {
+        if (loadingFinished) {
+          buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+          return C.RESULT_BUFFER_READ;
+        } else if (upstreamFormat != null
+            && (formatRequired || upstreamFormat != downstreamFormat)) {
           formatHolder.format = upstreamFormat;
           return C.RESULT_FORMAT_READ;
+        } else {
+          return C.RESULT_NOTHING_READ;
         }
-        return C.RESULT_NOTHING_READ;
       }
 
-      if (formats[relativeReadIndex] != downstreamFormat) {
+      if (formatRequired || formats[relativeReadIndex] != downstreamFormat) {
         formatHolder.format = formats[relativeReadIndex];
         return C.RESULT_FORMAT_READ;
       }
@@ -775,20 +815,22 @@ public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer b
     }
 
     /**
-     * Attempts to locate the keyframe before the specified time, if it's present in the buffer.
+     * Attempts to locate the keyframe before or at the specified time. If
+     * {@code allowTimeBeyondBuffer} is {@code false} then it is also required that {@code timeUs}
+     * falls within the buffer.
      *
      * @param timeUs The seek time.
+     * @param allowTimeBeyondBuffer Whether the skip can succeed if {@code timeUs} is beyond the end
+     *     of the buffer.
      * @return The offset of the keyframe's data if the keyframe was present.
      *     {@link C#POSITION_UNSET} otherwise.
      */
-    public synchronized long skipToKeyframeBefore(long timeUs) {
+    public synchronized long skipToKeyframeBefore(long timeUs, boolean allowTimeBeyondBuffer) {
       if (queueSize == 0 || timeUs < timesUs[relativeReadIndex]) {
         return C.POSITION_UNSET;
       }
 
-      int lastWriteIndex = (relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
-      long lastTimeUs = timesUs[lastWriteIndex];
-      if (timeUs > lastTimeUs) {
+      if (timeUs > largestQueuedTimestampUs && !allowTimeBeyondBuffer) {
         return C.POSITION_UNSET;
       }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
index 38b0325cba..de3dfd5266 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/Extractor.java
@@ -102,4 +102,5 @@ int read(ExtractorInput input, PositionHolder seekPosition)
    * Releases all kept resources.
    */
   void release();
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ExtractorOutput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ExtractorOutput.java
index a547f745ca..a59cb1d1f2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ExtractorOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ExtractorOutput.java
@@ -23,17 +23,18 @@
   /**
    * Called by the {@link Extractor} to get the {@link TrackOutput} for a specific track.
    * <p>
-   * The same {@link TrackOutput} is returned if multiple calls are made with the same
-   * {@code trackId}.
+   * The same {@link TrackOutput} is returned if multiple calls are made with the same {@code id}.
    *
-   * @param trackId A track identifier.
+   * @param id A track identifier.
+   * @param type The type of the track. Typically one of the {@link com.google.android.exoplayer2.C}
+   *     {@code TRACK_TYPE_*} constants.
    * @return The {@link TrackOutput} for the given track identifier.
    */
-  TrackOutput track(int trackId);
+  TrackOutput track(int id, int type);
 
   /**
    * Called when all tracks have been identified, meaning no new {@code trackId} values will be
-   * passed to {@link #track(int)}.
+   * passed to {@link #track(int, int)}.
    */
   void endTracks();
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java b/library/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
index 7e2a1b4a23..75d8b4cf2d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/GaplessInfoHolder.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.CommentFrame;
+import com.google.android.exoplayer2.metadata.id3.Id3Decoder.FramePredicate;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -26,6 +27,18 @@
  */
 public final class GaplessInfoHolder {
 
+  /**
+   * A {@link FramePredicate} suitable for use when decoding {@link Metadata} that will be passed
+   * to {@link #setFromMetadata(Metadata)}. Only frames that might contain gapless playback
+   * information are decoded.
+   */
+  public static final FramePredicate GAPLESS_INFO_ID3_FRAME_PREDICATE = new FramePredicate() {
+    @Override
+    public boolean evaluate(int majorVersion, int id0, int id1, int id2, int id3) {
+      return id0 == 'C' && id1 == 'O' && id2 == 'M' && (id3 == 'M' || majorVersion == 2);
+    }
+  };
+
   private static final String GAPLESS_COMMENT_ID = "iTunSMPB";
   private static final Pattern GAPLESS_COMMENT_PATTERN =
       Pattern.compile("^ [0-9a-fA-F]{8} ([0-9a-fA-F]{8}) ([0-9a-fA-F]{8})");
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
index 5b396749ac..218e6ffd82 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.flv;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -183,10 +184,12 @@ private boolean readFlvHeader(ExtractorInput input) throws IOException, Interrup
     boolean hasAudio = (flags & 0x04) != 0;
     boolean hasVideo = (flags & 0x01) != 0;
     if (hasAudio && audioReader == null) {
-      audioReader = new AudioTagPayloadReader(extractorOutput.track(TAG_TYPE_AUDIO));
+      audioReader = new AudioTagPayloadReader(
+          extractorOutput.track(TAG_TYPE_AUDIO, C.TRACK_TYPE_AUDIO));
     }
     if (hasVideo && videoReader == null) {
-      videoReader = new VideoTagPayloadReader(extractorOutput.track(TAG_TYPE_VIDEO));
+      videoReader = new VideoTagPayloadReader(
+          extractorOutput.track(TAG_TYPE_VIDEO, C.TRACK_TYPE_VIDEO));
     }
     if (metadataReader == null) {
       metadataReader = new ScriptTagPayloadReader(null);
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index ccf78e6bc6..51ce819282 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -529,11 +529,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         }
         break;
       case ID_TRACK_ENTRY:
-        if (tracks.get(currentTrack.number) == null && isCodecSupported(currentTrack.codecId)) {
+        if (isCodecSupported(currentTrack.codecId)) {
           currentTrack.initializeOutput(extractorOutput, currentTrack.number);
           tracks.put(currentTrack.number, currentTrack);
-        } else {
-          // We've seen this track entry before, or the codec is unsupported. Do nothing.
         }
         currentTrack = null;
         break;
@@ -675,6 +673,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
           case 3:
             currentTrack.stereoMode = C.STEREO_MODE_TOP_BOTTOM;
             break;
+          case 15:
+            currentTrack.stereoMode = C.STEREO_MODE_STEREO_MESH;
+            break;
           default:
             break;
         }
@@ -1464,6 +1465,7 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
           throw new ParserException("Unrecognized codec identifier.");
       }
 
+      int type;
       Format format;
       @C.SelectionFlags int selectionFlags = 0;
       selectionFlags |= flagDefault ? C.SELECTION_FLAG_DEFAULT : 0;
@@ -1471,10 +1473,12 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
       // TODO: Consider reading the name elements of the tracks and, if present, incorporating them
       // into the trackId passed when creating the formats.
       if (MimeTypes.isAudio(mimeType)) {
+        type = C.TRACK_TYPE_AUDIO;
         format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, maxInputSize, channelCount, sampleRate, pcmEncoding,
             initializationData, drmInitData, selectionFlags, language);
       } else if (MimeTypes.isVideo(mimeType)) {
+        type = C.TRACK_TYPE_VIDEO;
         if (displayUnit == Track.DISPLAY_UNIT_PIXELS) {
           displayWidth = displayWidth == Format.NO_VALUE ? width : displayWidth;
           displayHeight = displayHeight == Format.NO_VALUE ? height : displayHeight;
@@ -1487,17 +1491,19 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
             Format.NO_VALUE, maxInputSize, width, height, Format.NO_VALUE, initializationData,
             Format.NO_VALUE, pixelWidthHeightRatio, projectionData, stereoMode, drmInitData);
       } else if (MimeTypes.APPLICATION_SUBRIP.equals(mimeType)) {
+        type = C.TRACK_TYPE_TEXT;
         format = Format.createTextSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, selectionFlags, language, drmInitData);
       } else if (MimeTypes.APPLICATION_VOBSUB.equals(mimeType)
           || MimeTypes.APPLICATION_PGS.equals(mimeType)) {
+        type = C.TRACK_TYPE_TEXT;
         format = Format.createImageSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, initializationData, language, drmInitData);
       } else {
         throw new ParserException("Unexpected MIME type.");
       }
 
-      this.output = output.track(number);
+      this.output = output.track(number, type);
       this.output.format(format);
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index 9bdefeceaf..b0faad71c0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
@@ -33,6 +34,8 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Extracts data from an MP3 file.
@@ -51,6 +54,23 @@
 
   };
 
+  /**
+   * Flags controlling the behavior of the extractor.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef(flag = true, value = {FLAG_ENABLE_CONSTANT_BITRATE_SEEKING, FLAG_DISABLE_ID3_METADATA})
+  public @interface Flags {}
+  /**
+   * Flag to force enable seeking using a constant bitrate assumption in cases where seeking would
+   * otherwise not be possible.
+   */
+  public static final int FLAG_ENABLE_CONSTANT_BITRATE_SEEKING = 1;
+  /**
+   * Flag to disable parsing of ID3 metadata. Can be set to save memory if ID3 metadata is not
+   * required.
+   */
+  public static final int FLAG_DISABLE_ID3_METADATA = 2;
+
   /**
    * The maximum number of bytes to search when synchronizing, before giving up.
    */
@@ -72,6 +92,7 @@
   private static final int INFO_HEADER = Util.getIntegerCodeForString("Info");
   private static final int VBRI_HEADER = Util.getIntegerCodeForString("VBRI");
 
+  @Flags private final int flags;
   private final long forcedFirstSampleTimestampUs;
   private final ParsableByteArray scratch;
   private final MpegAudioHeader synchronizedHeader;
@@ -93,16 +114,27 @@
    * Constructs a new {@link Mp3Extractor}.
    */
   public Mp3Extractor() {
-    this(C.TIME_UNSET);
+    this(0);
   }
 
   /**
    * Constructs a new {@link Mp3Extractor}.
    *
+   * @param flags Flags that control the extractor's behavior.
+   */
+  public Mp3Extractor(@Flags int flags) {
+    this(flags, C.TIME_UNSET);
+  }
+
+  /**
+   * Constructs a new {@link Mp3Extractor}.
+   *
+   * @param flags Flags that control the extractor's behavior.
    * @param forcedFirstSampleTimestampUs A timestamp to force for the first sample, or
    *     {@link C#TIME_UNSET} if forcing is not required.
    */
-  public Mp3Extractor(long forcedFirstSampleTimestampUs) {
+  public Mp3Extractor(@Flags int flags, long forcedFirstSampleTimestampUs) {
+    this.flags = flags;
     this.forcedFirstSampleTimestampUs = forcedFirstSampleTimestampUs;
     scratch = new ParsableByteArray(SCRATCH_LENGTH);
     synchronizedHeader = new MpegAudioHeader();
@@ -118,7 +150,7 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   @Override
   public void init(ExtractorOutput output) {
     extractorOutput = output;
-    trackOutput = extractorOutput.track(0);
+    trackOutput = extractorOutput.track(0, C.TRACK_TYPE_AUDIO);
     extractorOutput.endTracks();
   }
 
@@ -151,7 +183,8 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
       trackOutput.format(Format.createAudioSampleFormat(null, synchronizedHeader.mimeType, null,
           Format.NO_VALUE, MpegAudioHeader.MAX_FRAME_SIZE_BYTES, synchronizedHeader.channels,
           synchronizedHeader.sampleRate, Format.NO_VALUE, gaplessInfoHolder.encoderDelay,
-          gaplessInfoHolder.encoderPadding, null, null, 0, null, metadata));
+          gaplessInfoHolder.encoderPadding, null, null, 0, null,
+          (flags & FLAG_DISABLE_ID3_METADATA) != 0 ? null : metadata));
     }
     return readSample(input);
   }
@@ -284,7 +317,11 @@ private void peekId3Data(ExtractorInput input) throws IOException, InterruptedEx
         byte[] id3Data = new byte[tagLength];
         System.arraycopy(scratch.data, 0, id3Data, 0, Id3Decoder.ID3_HEADER_LENGTH);
         input.peekFully(id3Data, Id3Decoder.ID3_HEADER_LENGTH, framesLength);
-        metadata = new Id3Decoder().decode(id3Data, tagLength);
+        // We need to parse enough ID3 metadata to retrieve any gapless playback information even
+        // if ID3 metadata parsing is disabled.
+        Id3Decoder.FramePredicate id3FramePredicate = (flags & FLAG_DISABLE_ID3_METADATA) != 0
+            ? GaplessInfoHolder.GAPLESS_INFO_ID3_FRAME_PREDICATE : null;
+        metadata = new Id3Decoder(id3FramePredicate).decode(id3Data, tagLength);
         if (metadata != null) {
           gaplessInfoHolder.setFromMetadata(metadata);
         }
@@ -350,7 +387,8 @@ private Seeker setupSeeker(ExtractorInput input) throws IOException, Interrupted
       }
     }
 
-    if (seeker == null) {
+    if (seeker == null || (!seeker.isSeekable()
+        && (flags & FLAG_ENABLE_CONSTANT_BITRATE_SEEKING) != 0)) {
       // Repopulate the synchronized header in case we had to skip an invalid seeking header, which
       // would give an invalid CBR bitrate.
       input.resetPeekPosition();
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
index 2eac7926e7..cc7e662336 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Atom.java
@@ -127,6 +127,7 @@
   public static final int TYPE_mean = Util.getIntegerCodeForString("mean");
   public static final int TYPE_name = Util.getIntegerCodeForString("name");
   public static final int TYPE_data = Util.getIntegerCodeForString("data");
+  public static final int TYPE_emsg = Util.getIntegerCodeForString("emsg");
   public static final int TYPE_st3d = Util.getIntegerCodeForString("st3d");
   public static final int TYPE_sv3d = Util.getIntegerCodeForString("sv3d");
   public static final int TYPE_proj = Util.getIntegerCodeForString("proj");
@@ -134,6 +135,7 @@
   public static final int TYPE_vp09 = Util.getIntegerCodeForString("vp09");
   public static final int TYPE_vpcC = Util.getIntegerCodeForString("vpcC");
   public static final int TYPE_camm = Util.getIntegerCodeForString("camm");
+  public static final int TYPE_alac = Util.getIntegerCodeForString("alac");
 
   public final int type;
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 9dc0578263..54141f2545 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -332,6 +332,9 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
     }
 
+    // Omit any sample at the end point of an edit for audio tracks.
+    boolean omitClippedSample = track.type == C.TRACK_TYPE_AUDIO;
+
     // Count the number of samples after applying edits.
     int editedSampleCount = 0;
     int nextSampleIndex = 0;
@@ -342,7 +345,8 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         long duration = Util.scaleLargeTimestamp(track.editListDurations[i], track.timescale,
             track.movieTimescale);
         int startIndex = Util.binarySearchCeil(timestamps, mediaTime, true, true);
-        int endIndex = Util.binarySearchCeil(timestamps, mediaTime + duration, true, false);
+        int endIndex = Util.binarySearchCeil(timestamps, mediaTime + duration, omitClippedSample,
+            false);
         editedSampleCount += endIndex - startIndex;
         copyMetadata |= nextSampleIndex != startIndex;
         nextSampleIndex = endIndex;
@@ -365,7 +369,7 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         long endMediaTime = mediaTime + Util.scaleLargeTimestamp(duration, track.timescale,
             track.movieTimescale);
         int startIndex = Util.binarySearchCeil(timestamps, mediaTime, true, true);
-        int endIndex = Util.binarySearchCeil(timestamps, endMediaTime, true, false);
+        int endIndex = Util.binarySearchCeil(timestamps, endMediaTime, omitClippedSample, false);
         if (copyMetadata) {
           int count = endIndex - startIndex;
           System.arraycopy(offsets, startIndex, editedOffsets, sampleIndex, count);
@@ -604,7 +608,7 @@ private static StsdData parseStsd(ParsableByteArray stsd, int trackId, int rotat
           || childAtomType == Atom.TYPE_dtsh || childAtomType == Atom.TYPE_dtsl
           || childAtomType == Atom.TYPE_samr || childAtomType == Atom.TYPE_sawb
           || childAtomType == Atom.TYPE_lpcm || childAtomType == Atom.TYPE_sowt
-          || childAtomType == Atom.TYPE__mp3) {
+          || childAtomType == Atom.TYPE__mp3 || childAtomType == Atom.TYPE_alac) {
         parseAudioSampleEntry(stsd, childAtomType, childStartPosition, childAtomSize, trackId,
             language, isQuickTime, drmInitData, out, i);
       } else if (childAtomType == Atom.TYPE_TTML) {
@@ -716,6 +720,9 @@ private static void parseVideoSampleEntry(ParsableByteArray parent, int atomType
             case 2:
               stereoMode = C.STEREO_MODE_LEFT_RIGHT;
               break;
+            case 3:
+              stereoMode = C.STEREO_MODE_STEREO_MESH;
+              break;
             default:
               break;
           }
@@ -839,6 +846,8 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       mimeType = MimeTypes.AUDIO_RAW;
     } else if (atomType == Atom.TYPE__mp3) {
       mimeType = MimeTypes.AUDIO_MPEG;
+    } else if (atomType == Atom.TYPE_alac) {
+      mimeType = MimeTypes.AUDIO_ALAC;
     }
 
     byte[] initializationData = null;
@@ -876,6 +885,10 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         out.format = Format.createAudioSampleFormat(Integer.toString(trackId), mimeType, null,
             Format.NO_VALUE, Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0,
             language);
+      } else if (childAtomType == Atom.TYPE_alac) {
+        initializationData = new byte[childAtomSize];
+        parent.setPosition(childPosition);
+        parent.readBytes(initializationData, 0, childAtomSize);
       }
       childPosition += childAtomSize;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index c718cd7111..a228a9b775 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -20,6 +20,7 @@
 import android.util.Pair;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
@@ -30,20 +31,22 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer2.extractor.mp4.Atom.LeafAtom;
+import com.google.android.exoplayer2.text.cea.CeaUtil;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Stack;
 import java.util.UUID;
@@ -65,15 +68,13 @@
 
   };
 
-  private static final String TAG = "FragmentedMp4Extractor";
-  private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
-
   /**
    * Flags controlling the behavior of the extractor.
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME,
-      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_SIDELOADED})
+      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_ENABLE_EMSG_TRACK, FLAG_ENABLE_CEA608_TRACK,
+      FLAG_SIDELOADED})
   public @interface Flags {}
   /**
    * Flag to work around an issue in some video streams where every frame is marked as a sync frame.
@@ -87,12 +88,24 @@
    * Flag to ignore any tfdt boxes in the stream.
    */
   public static final int FLAG_WORKAROUND_IGNORE_TFDT_BOX = 2;
+  /**
+   * Flag to indicate that the extractor should output an event message metadata track. Any event
+   * messages in the stream will be delivered as samples to this track.
+   */
+  public static final int FLAG_ENABLE_EMSG_TRACK = 4;
+  /**
+   * Flag to indicate that the extractor should output a CEA-608 text track. Any CEA-608 messages
+   * contained within SEI NAL units in the stream will be delivered as samples to this track.
+   */
+  public static final int FLAG_ENABLE_CEA608_TRACK = 8;
   /**
    * Flag to indicate that the {@link Track} was sideloaded, instead of being declared by the MP4
    * container.
    */
-  private static final int FLAG_SIDELOADED = 4;
+  private static final int FLAG_SIDELOADED = 16;
 
+  private static final String TAG = "FragmentedMp4Extractor";
+  private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
   private static final byte[] PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE =
       new byte[] {-94, 57, 79, 82, 90, -101, 79, 20, -94, 68, 108, 66, 124, 100, -115, -12};
 
@@ -104,8 +117,7 @@
   private static final int STATE_READING_SAMPLE_CONTINUE = 4;
 
   // Workarounds.
-  @Flags
-  private final int flags;
+  @Flags private final int flags;
   private final Track sideloadedTrack;
 
   // Track-linked data bundle, accessible as a whole through trackID.
@@ -113,7 +125,8 @@
 
   // Temporary arrays.
   private final ParsableByteArray nalStartCode;
-  private final ParsableByteArray nalLength;
+  private final ParsableByteArray nalPrefix;
+  private final ParsableByteArray nalBuffer;
   private final ParsableByteArray encryptionSignalByte;
 
   // Adjusts sample timestamps.
@@ -123,6 +136,7 @@
   private final ParsableByteArray atomHeader;
   private final byte[] extendedTypeScratch;
   private final Stack<ContainerAtom> containerAtoms;
+  private final LinkedList<MetadataSampleInfo> pendingMetadataSampleInfos;
 
   private int parserState;
   private int atomType;
@@ -130,21 +144,33 @@
   private int atomHeaderBytesRead;
   private ParsableByteArray atomData;
   private long endOfMdatPosition;
+  private int pendingMetadataSampleBytes;
 
   private long durationUs;
+  private long segmentIndexEarliestPresentationTimeUs;
   private TrackBundle currentTrackBundle;
   private int sampleSize;
   private int sampleBytesWritten;
   private int sampleCurrentNalBytesRemaining;
+  private boolean processSeiNalUnitPayload;
 
   // Extractor output.
   private ExtractorOutput extractorOutput;
+  private TrackOutput eventMessageTrackOutput;
+  private TrackOutput[] cea608TrackOutputs;
 
   // Whether extractorOutput.seekMap has been called.
   private boolean haveOutputSeekMap;
 
   public FragmentedMp4Extractor() {
-    this(0, null);
+    this(0);
+  }
+
+  /**
+   * @param flags Flags that control the extractor's behavior.
+   */
+  public FragmentedMp4Extractor(@Flags int flags) {
+    this(flags, null);
   }
 
   /**
@@ -152,28 +178,31 @@ public FragmentedMp4Extractor() {
    * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
    */
   public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjuster) {
-    this(flags, null, timestampAdjuster);
+    this(flags, timestampAdjuster, null);
   }
 
   /**
    * @param flags Flags that control the extractor's behavior.
+   * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
    * @param sideloadedTrack Sideloaded track information, in the case that the extractor
    *     will not receive a moov box in the input data.
-   * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
    */
-  public FragmentedMp4Extractor(@Flags int flags, Track sideloadedTrack,
-      TimestampAdjuster timestampAdjuster) {
-    this.sideloadedTrack = sideloadedTrack;
+  public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjuster,
+      Track sideloadedTrack) {
     this.flags = flags | (sideloadedTrack != null ? FLAG_SIDELOADED : 0);
     this.timestampAdjuster = timestampAdjuster;
+    this.sideloadedTrack = sideloadedTrack;
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
-    nalLength = new ParsableByteArray(4);
+    nalPrefix = new ParsableByteArray(5);
+    nalBuffer = new ParsableByteArray();
     encryptionSignalByte = new ParsableByteArray(1);
     extendedTypeScratch = new byte[16];
     containerAtoms = new Stack<>();
+    pendingMetadataSampleInfos = new LinkedList<>();
     trackBundles = new SparseArray<>();
     durationUs = C.TIME_UNSET;
+    segmentIndexEarliestPresentationTimeUs = C.TIME_UNSET;
     enterReadingAtomHeaderState();
   }
 
@@ -186,9 +215,10 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   public void init(ExtractorOutput output) {
     extractorOutput = output;
     if (sideloadedTrack != null) {
-      TrackBundle bundle = new TrackBundle(output.track(0));
+      TrackBundle bundle = new TrackBundle(output.track(0, sideloadedTrack.type));
       bundle.init(sideloadedTrack, new DefaultSampleValues(0, 0, 0, 0));
       trackBundles.put(0, bundle);
+      maybeInitExtraTracks();
       extractorOutput.endTracks();
     }
   }
@@ -199,6 +229,8 @@ public void seek(long position, long timeUs) {
     for (int i = 0; i < trackCount; i++) {
       trackBundles.valueAt(i).reset();
     }
+    pendingMetadataSampleInfos.clear();
+    pendingMetadataSampleBytes = 0;
     containerAtoms.clear();
     enterReadingAtomHeaderState();
   }
@@ -257,6 +289,10 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
       atomSize = atomHeader.readUnsignedLongToLong();
     }
 
+    if (atomSize < atomHeaderBytesRead) {
+      throw new ParserException("Atom size less than header length (unsupported).");
+    }
+
     long atomPosition = input.getPosition() - atomHeaderBytesRead;
     if (atomType == Atom.TYPE_moof) {
       // The data positions may be updated when parsing the tfhd/trun.
@@ -332,9 +368,12 @@ private void onLeafAtomRead(LeafAtom leaf, long inputPosition) throws ParserExce
     if (!containerAtoms.isEmpty()) {
       containerAtoms.peek().add(leaf);
     } else if (leaf.type == Atom.TYPE_sidx) {
-      ChunkIndex segmentIndex = parseSidx(leaf.data, inputPosition);
-      extractorOutput.seekMap(segmentIndex);
+      Pair<Long, ChunkIndex> result = parseSidx(leaf.data, inputPosition);
+      segmentIndexEarliestPresentationTimeUs = result.first;
+      extractorOutput.seekMap(result.second);
       haveOutputSeekMap = true;
+    } else if (leaf.type == Atom.TYPE_emsg) {
+      onEmsgLeafAtomRead(leaf.data);
     }
   }
 
@@ -387,18 +426,19 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
       // We need to create the track bundles.
       for (int i = 0; i < trackCount; i++) {
         Track track = tracks.valueAt(i);
-        trackBundles.put(track.id, new TrackBundle(extractorOutput.track(i)));
+        TrackBundle trackBundle = new TrackBundle(extractorOutput.track(i, track.type));
+        trackBundle.init(track, defaultSampleValuesArray.get(track.id));
+        trackBundles.put(track.id, trackBundle);
         durationUs = Math.max(durationUs, track.durationUs);
       }
+      maybeInitExtraTracks();
       extractorOutput.endTracks();
     } else {
       Assertions.checkState(trackBundles.size() == trackCount);
-    }
-
-    // Initialization of tracks and default sample values.
-    for (int i = 0; i < trackCount; i++) {
-      Track track = tracks.valueAt(i);
-      trackBundles.get(track.id).init(track, defaultSampleValuesArray.get(track.id));
+      for (int i = 0; i < trackCount; i++) {
+        Track track = tracks.valueAt(i);
+        trackBundles.get(track.id).init(track, defaultSampleValuesArray.get(track.id));
+      }
     }
   }
 
@@ -413,6 +453,53 @@ private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException
     }
   }
 
+  private void maybeInitExtraTracks() {
+    if ((flags & FLAG_ENABLE_EMSG_TRACK) != 0 && eventMessageTrackOutput == null) {
+      eventMessageTrackOutput = extractorOutput.track(trackBundles.size(), C.TRACK_TYPE_METADATA);
+      eventMessageTrackOutput.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_EMSG,
+          Format.OFFSET_SAMPLE_RELATIVE));
+    }
+    if ((flags & FLAG_ENABLE_CEA608_TRACK) != 0 && cea608TrackOutputs == null) {
+      TrackOutput cea608TrackOutput = extractorOutput.track(trackBundles.size() + 1,
+          C.TRACK_TYPE_TEXT);
+      cea608TrackOutput.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608,
+          null, Format.NO_VALUE, 0, null, null));
+      cea608TrackOutputs = new TrackOutput[] {cea608TrackOutput};
+    }
+  }
+
+  /**
+   * Handles an emsg atom (defined in 23009-1).
+   */
+  private void onEmsgLeafAtomRead(ParsableByteArray atom) {
+    if (eventMessageTrackOutput == null) {
+      return;
+    }
+    // Parse the event's presentation time delta.
+    atom.setPosition(Atom.FULL_HEADER_SIZE);
+    atom.readNullTerminatedString(); // schemeIdUri
+    atom.readNullTerminatedString(); // value
+    long timescale = atom.readUnsignedInt();
+    long presentationTimeDeltaUs =
+        Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MICROS_PER_SECOND, timescale);
+    // Output the sample data.
+    atom.setPosition(Atom.FULL_HEADER_SIZE);
+    int sampleSize = atom.bytesLeft();
+    eventMessageTrackOutput.sampleData(atom, sampleSize);
+    // Output the sample metadata.
+    if (segmentIndexEarliestPresentationTimeUs != C.TIME_UNSET) {
+      // We can output the sample metadata immediately.
+      eventMessageTrackOutput.sampleMetadata(
+          segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs,
+          C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0 /* offset */, null);
+    } else {
+      // We need the first sample timestamp in the segment before we can output the metadata.
+      pendingMetadataSampleInfos.addLast(
+          new MetadataSampleInfo(presentationTimeDeltaUs, sampleSize));
+      pendingMetadataSampleBytes += sampleSize;
+    }
+  }
+
   /**
    * Parses a trex atom (defined in 14496-12).
    */
@@ -624,7 +711,7 @@ private static TrackBundle parseTfhd(ParsableByteArray tfhd,
     DefaultSampleValues defaultSampleValues = trackBundle.defaultSampleValues;
     int defaultSampleDescriptionIndex =
         ((atomFlags & 0x02 /* default_sample_description_index_present */) != 0)
-        ? tfhd.readUnsignedIntToInt() - 1 : defaultSampleValues.sampleDescriptionIndex;
+            ? tfhd.readUnsignedIntToInt() - 1 : defaultSampleValues.sampleDescriptionIndex;
     int defaultSampleDuration = ((atomFlags & 0x08 /* default_sample_duration_present */) != 0)
         ? tfhd.readUnsignedIntToInt() : defaultSampleValues.duration;
     int defaultSampleSize = ((atomFlags & 0x10 /* default_sample_size_present */) != 0)
@@ -828,8 +915,13 @@ private static void parseSgpd(ParsableByteArray sbgp, ParsableByteArray sgpd, Tr
 
   /**
    * Parses a sidx atom (defined in 14496-12).
+   *
+   * @param atom The atom data.
+   * @param inputPosition The input position of the first byte after the atom.
+   * @return A pair consisting of the earliest presentation time in microseconds, and the parsed
+   *     {@link ChunkIndex}.
    */
-  private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
+  private static Pair<Long, ChunkIndex> parseSidx(ParsableByteArray atom, long inputPosition)
       throws ParserException {
     atom.setPosition(Atom.HEADER_SIZE);
     int fullAtom = atom.readInt();
@@ -846,6 +938,8 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
       earliestPresentationTime = atom.readUnsignedLongToLong();
       offset += atom.readUnsignedLongToLong();
     }
+    long earliestPresentationTimeUs = Util.scaleLargeTimestamp(earliestPresentationTime,
+        C.MICROS_PER_SECOND, timescale);
 
     atom.skipBytes(2);
 
@@ -856,7 +950,7 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
     long[] timesUs = new long[referenceCount];
 
     long time = earliestPresentationTime;
-    long timeUs = Util.scaleLargeTimestamp(time, C.MICROS_PER_SECOND, timescale);
+    long timeUs = earliestPresentationTimeUs;
     for (int i = 0; i < referenceCount; i++) {
       int firstInt = atom.readInt();
 
@@ -880,7 +974,8 @@ private static ChunkIndex parseSidx(ParsableByteArray atom, long inputPosition)
       offset += sizes[i];
     }
 
-    return new ChunkIndex(sizes, offsets, durationsUs, timesUs);
+    return Pair.create(earliestPresentationTimeUs,
+        new ChunkIndex(sizes, offsets, durationsUs, timesUs));
   }
 
   private void readEncryptionData(ExtractorInput input) throws IOException, InterruptedException {
@@ -942,13 +1037,9 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
         // We skip bytes preceding the next sample to read.
         int bytesToSkip = (int) (nextDataPosition - input.getPosition());
         if (bytesToSkip < 0) {
-          if (nextDataPosition == currentTrackBundle.fragment.atomPosition) {
-            // Assume the sample data must be contiguous in the mdat with no preceeding data.
-            Log.w(TAG, "Offset to sample data was missing.");
-            bytesToSkip = 0;
-          } else {
-            throw new ParserException("Offset to sample data was negative.");
-          }
+          // Assume the sample data must be contiguous in the mdat with no preceding data.
+          Log.w(TAG, "Ignoring negative offset to sample data.");
+          bytesToSkip = 0;
         }
         input.skipFully(bytesToSkip);
         this.currentTrackBundle = currentTrackBundle;
@@ -976,29 +1067,49 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
     if (track.nalUnitLengthFieldLength != 0) {
       // Zero the top three bytes of the array that we'll use to decode nal unit lengths, in case
       // they're only 1 or 2 bytes long.
-      byte[] nalLengthData = nalLength.data;
-      nalLengthData[0] = 0;
-      nalLengthData[1] = 0;
-      nalLengthData[2] = 0;
-      int nalUnitLengthFieldLength = track.nalUnitLengthFieldLength;
+      byte[] nalPrefixData = nalPrefix.data;
+      nalPrefixData[0] = 0;
+      nalPrefixData[1] = 0;
+      nalPrefixData[2] = 0;
+      int nalUnitPrefixLength = track.nalUnitLengthFieldLength + 1;
       int nalUnitLengthFieldLengthDiff = 4 - track.nalUnitLengthFieldLength;
       // NAL units are length delimited, but the decoder requires start code delimited units.
       // Loop until we've written the sample to the track output, replacing length delimiters with
       // start codes as we encounter them.
       while (sampleBytesWritten < sampleSize) {
         if (sampleCurrentNalBytesRemaining == 0) {
-          // Read the NAL length so that we know where we find the next one.
-          input.readFully(nalLength.data, nalUnitLengthFieldLengthDiff, nalUnitLengthFieldLength);
-          nalLength.setPosition(0);
-          sampleCurrentNalBytesRemaining = nalLength.readUnsignedIntToInt();
+          // Read the NAL length so that we know where we find the next one, and its type.
+          input.readFully(nalPrefixData, nalUnitLengthFieldLengthDiff, nalUnitPrefixLength);
+          nalPrefix.setPosition(0);
+          sampleCurrentNalBytesRemaining = nalPrefix.readUnsignedIntToInt() - 1;
           // Write a start code for the current NAL unit.
           nalStartCode.setPosition(0);
           output.sampleData(nalStartCode, 4);
-          sampleBytesWritten += 4;
+          // Write the NAL unit type byte.
+          output.sampleData(nalPrefix, 1);
+          processSeiNalUnitPayload = cea608TrackOutputs != null
+              && NalUnitUtil.isNalUnitSei(track.format.sampleMimeType, nalPrefixData[4]);
+          sampleBytesWritten += 5;
           sampleSize += nalUnitLengthFieldLengthDiff;
         } else {
-          // Write the payload of the NAL unit.
-          int writtenBytes = output.sampleData(input, sampleCurrentNalBytesRemaining, false);
+          int writtenBytes;
+          if (processSeiNalUnitPayload) {
+            // Read and write the payload of the SEI NAL unit.
+            nalBuffer.reset(sampleCurrentNalBytesRemaining);
+            input.readFully(nalBuffer.data, 0, sampleCurrentNalBytesRemaining);
+            output.sampleData(nalBuffer, sampleCurrentNalBytesRemaining);
+            writtenBytes = sampleCurrentNalBytesRemaining;
+            // Unescape and process the SEI NAL unit.
+            int unescapedLength = NalUnitUtil.unescapeStream(nalBuffer.data, nalBuffer.limit());
+            // If the format is H.265/HEVC the NAL unit header has two bytes so skip one more byte.
+            nalBuffer.setPosition(MimeTypes.VIDEO_H265.equals(track.format.sampleMimeType) ? 1 : 0);
+            nalBuffer.setLimit(unescapedLength);
+            CeaUtil.consume(fragment.getSamplePresentationTime(sampleIndex) * 1000L, nalBuffer,
+                cea608TrackOutputs);
+          } else {
+            // Write the payload of the NAL unit.
+            writtenBytes = output.sampleData(input, sampleCurrentNalBytesRemaining, false);
+          }
           sampleBytesWritten += writtenBytes;
           sampleCurrentNalBytesRemaining -= writtenBytes;
         }
@@ -1025,6 +1136,14 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
     }
     output.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, encryptionKey);
 
+    while (!pendingMetadataSampleInfos.isEmpty()) {
+      MetadataSampleInfo sampleInfo = pendingMetadataSampleInfos.removeFirst();
+      pendingMetadataSampleBytes -= sampleInfo.size;
+      eventMessageTrackOutput.sampleMetadata(
+          sampleTimeUs + sampleInfo.presentationTimeDeltaUs,
+          C.BUFFER_FLAG_KEY_FRAME, sampleInfo.size, pendingMetadataSampleBytes, null);
+    }
+
     currentTrackBundle.currentSampleIndex++;
     currentTrackBundle.currentSampleInTrackRun++;
     if (currentTrackBundle.currentSampleInTrackRun
@@ -1130,7 +1249,7 @@ private static boolean shouldParseLeafAtom(int atom) {
         || atom == Atom.TYPE_trun || atom == Atom.TYPE_pssh || atom == Atom.TYPE_saiz
         || atom == Atom.TYPE_saio || atom == Atom.TYPE_senc || atom == Atom.TYPE_uuid
         || atom == Atom.TYPE_sbgp || atom == Atom.TYPE_sgpd || atom == Atom.TYPE_elst
-        || atom == Atom.TYPE_mehd;
+        || atom == Atom.TYPE_mehd || atom == Atom.TYPE_emsg;
   }
 
   /** Returns whether the extractor should decode a container atom with type {@code atom}. */
@@ -1140,6 +1259,21 @@ private static boolean shouldParseContainerAtom(int atom) {
         || atom == Atom.TYPE_traf || atom == Atom.TYPE_mvex || atom == Atom.TYPE_edts;
   }
 
+  /**
+   * Holds data corresponding to a metadata sample.
+   */
+  private static final class MetadataSampleInfo {
+
+    public final long presentationTimeDeltaUs;
+    public final int size;
+
+    public MetadataSampleInfo(long presentationTimeDeltaUs, int size) {
+      this.presentationTimeDeltaUs = presentationTimeDeltaUs;
+      this.size = size;
+    }
+
+  }
+
   /**
    * Holds data corresponding to a single track.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
index e99dab053b..fed1694925 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/MetadataUtil.java
@@ -188,7 +188,7 @@ private static TextInformationFrame parseTextAttribute(int type, String id,
     if (atomType == Atom.TYPE_data) {
       data.skipBytes(8); // version (1), flags (3), empty (4)
       String value = data.readNullTerminatedString(atomSize - 16);
-      return new TextInformationFrame(id, value);
+      return new TextInformationFrame(id, null, value);
     }
     Log.w(TAG, "Failed to parse text attribute: " + Atom.getAtomTypeString(type));
     return null;
@@ -213,7 +213,7 @@ private static Id3Frame parseUint8Attribute(int type, String id, ParsableByteArr
       value = Math.min(1, value);
     }
     if (value >= 0) {
-      return isTextInformationFrame ? new TextInformationFrame(id, Integer.toString(value))
+      return isTextInformationFrame ? new TextInformationFrame(id, null, Integer.toString(value))
           : new CommentFrame(LANGUAGE_UNDEFINED, id, Integer.toString(value));
     }
     Log.w(TAG, "Failed to parse uint8 attribute: " + Atom.getAtomTypeString(type));
@@ -228,12 +228,12 @@ private static TextInformationFrame parseIndexAndCountAttribute(int type, String
       data.skipBytes(10); // version (1), flags (3), empty (4), empty (2)
       int index = data.readUnsignedShort();
       if (index > 0) {
-        String description = "" + index;
+        String value = "" + index;
         int count = data.readUnsignedShort();
         if (count > 0) {
-          description += "/" + count;
+          value += "/" + count;
         }
-        return new TextInformationFrame(attributeName, description);
+        return new TextInformationFrame(attributeName, null, value);
       }
     }
     Log.w(TAG, "Failed to parse index/count attribute: " + Atom.getAtomTypeString(type));
@@ -245,7 +245,7 @@ private static TextInformationFrame parseStandardGenreAttribute(ParsableByteArra
     String genreString = (0 < genreCode && genreCode <= STANDARD_GENRES.length)
         ? STANDARD_GENRES[genreCode - 1] : null;
     if (genreString != null) {
-      return new TextInformationFrame("TCON", genreString);
+      return new TextInformationFrame("TCON", null, genreString);
     }
     Log.w(TAG, "Failed to parse standard genre code");
     return null;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
index 3759a80fd4..d0e770abdc 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
@@ -83,8 +83,7 @@
   private final ParsableByteArray atomHeader;
   private final Stack<ContainerAtom> containerAtoms;
 
-  @State
-  private int parserState;
+  @State private int parserState;
   private int atomType;
   private long atomSize;
   private int atomHeaderBytesRead;
@@ -344,7 +343,8 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
         continue;
       }
 
-      Mp4Track mp4Track = new Mp4Track(track, trackSampleTable, extractorOutput.track(i));
+      Mp4Track mp4Track = new Mp4Track(track, trackSampleTable,
+          extractorOutput.track(i, track.type));
       // Each sample has up to three bytes of overhead for the start code that replaces its length.
       // Allow ten source samples per output sample, like the platform extractor.
       int maxInputSize = trackSampleTable.maximumSize + 3 * 10;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
index c723704d37..f1c4e99ec1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/mp4/Track.java
@@ -75,8 +75,7 @@
    * One of {@code TRANSFORMATION_*}. Defines the transformation to apply before outputting each
    * sample.
    */
-  @Transformation
-  public final int sampleTransformation;
+  @Transformation public final int sampleTransformation;
 
   /**
    * Track encryption boxes for the different track sample descriptions. Entries may be null.
@@ -94,7 +93,7 @@
   public final long[] editListMediaTimes;
 
   /**
-   * For H264 video tracks, the length in bytes of the NALUnitLength field in each sample. -1 for
+   * For H264 video tracks, the length in bytes of the NALUnitLength field in each sample. 0 for
    * other track types.
    */
   public final int nalUnitLengthFieldLength;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
index 5f41126737..cc3c5de311 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -75,7 +76,7 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
 
   @Override
   public void init(ExtractorOutput output) {
-    TrackOutput trackOutput = output.track(0);
+    TrackOutput trackOutput = output.track(0, C.TRACK_TYPE_AUDIO);
     output.endTracks();
     // TODO: fix the case if sniff() isn't called
     streamReader.init(output, trackOutput);
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
index f6cd29aff2..7840eafce6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
@@ -65,7 +65,7 @@ public RawCcExtractor(Format format) {
   @Override
   public void init(ExtractorOutput output) {
     output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
-    trackOutput = output.track(0);
+    trackOutput = output.track(0, C.TRACK_TYPE_TEXT);
     output.endTracks();
     trackOutput.format(format);
   }
@@ -83,8 +83,11 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     while (true) {
       switch (parserState) {
         case STATE_READING_HEADER:
-          parseHeader(input);
-          parserState = STATE_READING_TIMESTAMP_AND_COUNT;
+          if (parseHeader(input)) {
+            parserState = STATE_READING_TIMESTAMP_AND_COUNT;
+          } else {
+            return RESULT_END_OF_INPUT;
+          }
           break;
         case STATE_READING_TIMESTAMP_AND_COUNT:
           if (parseTimestampAndSampleCount(input)) {
@@ -114,14 +117,18 @@ public void release() {
     // Do nothing
   }
 
-  private void parseHeader(ExtractorInput input) throws IOException, InterruptedException {
+  private boolean parseHeader(ExtractorInput input) throws IOException, InterruptedException {
     dataScratch.reset();
-    input.readFully(dataScratch.data, 0, HEADER_SIZE);
-    if (dataScratch.readInt() != HEADER_ID) {
-      throw new IOException("Input not RawCC");
+    if (input.readFully(dataScratch.data, 0, HEADER_SIZE, true)) {
+      if (dataScratch.readInt() != HEADER_ID) {
+        throw new IOException("Input not RawCC");
+      }
+      version = dataScratch.readUnsignedByte();
+      // no versions use the flag fields yet
+      return true;
+    } else {
+      return false;
     }
-    version = dataScratch.readUnsignedByte();
-    // no versions use the flag fields yet
   }
 
   private boolean parseTimestampAndSampleCount(ExtractorInput input) throws IOException,
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
index 52faa8c673..248161f28f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
@@ -27,7 +27,7 @@
 /**
  * Parses a continuous (E-)AC-3 byte stream and extracts individual samples.
  */
-/* package */ final class Ac3Reader implements ElementaryStreamReader {
+public final class Ac3Reader implements ElementaryStreamReader {
 
   private static final int STATE_FINDING_SYNC = 0;
   private static final int STATE_READING_HEADER = 1;
@@ -39,6 +39,7 @@
   private final ParsableByteArray headerScratchBytes;
   private final String language;
 
+  private String trackFormatId;
   private TrackOutput output;
 
   private int state;
@@ -84,7 +85,9 @@ public void seek() {
 
   @Override
   public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator generator) {
-    output = extractorOutput.track(generator.getNextId());
+    generator.generateNewId();
+    trackFormatId = generator.getFormatId();
+    output = extractorOutput.track(generator.getTrackId(), C.TRACK_TYPE_AUDIO);
   }
 
   @Override
@@ -180,8 +183,9 @@ private void parseHeader() {
       headerScratchBits.skipBits(40);
       isEac3 = headerScratchBits.readBits(5) == 16;
       headerScratchBits.setPosition(headerScratchBits.getPosition() - 45);
-      format = isEac3 ? Ac3Util.parseEac3SyncframeFormat(headerScratchBits, null, language , null)
-          : Ac3Util.parseAc3SyncframeFormat(headerScratchBits, null, language, null);
+      format = isEac3
+          ? Ac3Util.parseEac3SyncframeFormat(headerScratchBits, trackFormatId, language , null)
+          : Ac3Util.parseAc3SyncframeFormat(headerScratchBits, trackFormatId, language, null);
       output.format(format);
     }
     sampleSize = isEac3 ? Ac3Util.parseEAc3SyncframeSize(headerScratchBits.data)
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index 47cb217fc7..7277df5bb8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -33,7 +33,7 @@
 /**
  * Parses a continuous ADTS byte stream and extracts individual frames.
  */
-/* package */ final class AdtsReader implements ElementaryStreamReader {
+public final class AdtsReader implements ElementaryStreamReader {
 
   private static final String TAG = "AdtsReader";
 
@@ -61,6 +61,7 @@
   private final ParsableByteArray id3HeaderBuffer;
   private final String language;
 
+  private String formatId;
   private TrackOutput output;
   private TrackOutput id3Output;
 
@@ -108,11 +109,14 @@ public void seek() {
 
   @Override
   public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-    output = extractorOutput.track(idGenerator.getNextId());
+    idGenerator.generateNewId();
+    formatId = idGenerator.getFormatId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_AUDIO);
     if (exposeId3) {
-      id3Output = extractorOutput.track(idGenerator.getNextId());
-      id3Output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_ID3, null,
-          Format.NO_VALUE, null));
+      idGenerator.generateNewId();
+      id3Output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_METADATA);
+      id3Output.format(Format.createSampleFormat(idGenerator.getFormatId(),
+          MimeTypes.APPLICATION_ID3, null, Format.NO_VALUE, null));
     } else {
       id3Output = new DummyTrackOutput();
     }
@@ -300,7 +304,7 @@ private void parseAdtsHeader() {
       Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
           audioSpecificConfig);
 
-      Format format = Format.createAudioSampleFormat(null, MimeTypes.AUDIO_AAC, null,
+      Format format = Format.createAudioSampleFormat(formatId, MimeTypes.AUDIO_AAC, null,
           Format.NO_VALUE, Format.NO_VALUE, audioParams.second, audioParams.first,
           Collections.singletonList(audioSpecificConfig), null, 0, language);
       // In this class a sample is an access unit, but the MediaFormat sample rate specifies the
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
index 31aa88d11a..e8b664d5ab 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.java
@@ -17,9 +17,15 @@
 
 import android.support.annotation.IntDef;
 import android.util.SparseArray;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * Default implementation for {@link TsPayloadReader.Factory}.
@@ -27,28 +33,47 @@
 public final class DefaultTsPayloadReaderFactory implements TsPayloadReader.Factory {
 
   /**
-   * Flags controlling elementary stream readers behaviour.
+   * Flags controlling elementary stream readers' behavior.
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {FLAG_ALLOW_NON_IDR_KEYFRAMES, FLAG_IGNORE_AAC_STREAM,
-      FLAG_IGNORE_H264_STREAM, FLAG_DETECT_ACCESS_UNITS, FLAG_IGNORE_SPLICE_INFO_STREAM})
+      FLAG_IGNORE_H264_STREAM, FLAG_DETECT_ACCESS_UNITS, FLAG_IGNORE_SPLICE_INFO_STREAM,
+      FLAG_OVERRIDE_CAPTION_DESCRIPTORS})
   public @interface Flags {
   }
   public static final int FLAG_ALLOW_NON_IDR_KEYFRAMES = 1;
-  public static final int FLAG_IGNORE_AAC_STREAM = 2;
-  public static final int FLAG_IGNORE_H264_STREAM = 4;
-  public static final int FLAG_DETECT_ACCESS_UNITS = 8;
-  public static final int FLAG_IGNORE_SPLICE_INFO_STREAM = 16;
+  public static final int FLAG_IGNORE_AAC_STREAM = 1 << 1;
+  public static final int FLAG_IGNORE_H264_STREAM = 1 << 2;
+  public static final int FLAG_DETECT_ACCESS_UNITS = 1 << 3;
+  public static final int FLAG_IGNORE_SPLICE_INFO_STREAM = 1 << 4;
+  public static final int FLAG_OVERRIDE_CAPTION_DESCRIPTORS = 1 << 5;
 
-  @Flags
-  private final int flags;
+  private static final int DESCRIPTOR_TAG_CAPTION_SERVICE = 0x86;
+
+  @Flags private final int flags;
+  private final List<Format> closedCaptionFormats;
 
   public DefaultTsPayloadReaderFactory() {
-    this(0);
+    this(0, Collections.<Format>emptyList());
   }
 
-  public DefaultTsPayloadReaderFactory(@Flags int flags) {
+  /**
+   * @param flags A combination of {@code FLAG_*} values, which control the behavior of the created
+   *     readers.
+   * @param closedCaptionFormats {@link Format}s to be exposed by payload readers for streams with
+   *     embedded closed captions when no caption service descriptors are provided. If
+   *     {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS} is set, {@code closedCaptionFormats} overrides
+   *     any descriptor information. If not set, and {@code closedCaptionFormats} is empty, a
+   *     closed caption track with {@link Format#accessibilityChannel} {@link Format#NO_VALUE} will
+   *     be exposed.
+   */
+  public DefaultTsPayloadReaderFactory(@Flags int flags, List<Format> closedCaptionFormats) {
     this.flags = flags;
+    if (!isSet(FLAG_OVERRIDE_CAPTION_DESCRIPTORS) && closedCaptionFormats.isEmpty()) {
+      closedCaptionFormats = Collections.singletonList(Format.createTextSampleFormat(null,
+          MimeTypes.APPLICATION_CEA608, null, Format.NO_VALUE, 0, null, null));
+    }
+    this.closedCaptionFormats = closedCaptionFormats;
   }
 
   @Override
@@ -74,10 +99,11 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
       case TsExtractor.TS_STREAM_TYPE_H262:
         return new PesReader(new H262Reader());
       case TsExtractor.TS_STREAM_TYPE_H264:
-        return isSet(FLAG_IGNORE_H264_STREAM) ? null : new PesReader(
-            new H264Reader(isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS)));
+        return isSet(FLAG_IGNORE_H264_STREAM) ? null
+            : new PesReader(new H264Reader(buildSeiReader(esInfo),
+                isSet(FLAG_ALLOW_NON_IDR_KEYFRAMES), isSet(FLAG_DETECT_ACCESS_UNITS)));
       case TsExtractor.TS_STREAM_TYPE_H265:
-        return new PesReader(new H265Reader());
+        return new PesReader(new H265Reader(buildSeiReader(esInfo)));
       case TsExtractor.TS_STREAM_TYPE_SPLICE_INFO:
         return isSet(FLAG_IGNORE_SPLICE_INFO_STREAM)
             ? null : new SectionReader(new SpliceInfoSectionReader());
@@ -88,6 +114,55 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
     }
   }
 
+  /**
+   * If {@link #FLAG_OVERRIDE_CAPTION_DESCRIPTORS} is set, returns a {@link SeiReader} for
+   * {@link #closedCaptionFormats}. If unset, parses the PMT descriptor information and returns a
+   * {@link SeiReader} for the declared formats, or {@link #closedCaptionFormats} if the descriptor
+   * is not present.
+   *
+   * @param esInfo The {@link EsInfo} passed to {@link #createPayloadReader(int, EsInfo)}.
+   * @return A {@link SeiReader} for closed caption tracks.
+   */
+  private SeiReader buildSeiReader(EsInfo esInfo) {
+    if (isSet(FLAG_OVERRIDE_CAPTION_DESCRIPTORS)) {
+      return new SeiReader(closedCaptionFormats);
+    }
+    ParsableByteArray scratchDescriptorData = new ParsableByteArray(esInfo.descriptorBytes);
+    List<Format> closedCaptionFormats = this.closedCaptionFormats;
+    while (scratchDescriptorData.bytesLeft() > 0) {
+      int descriptorTag = scratchDescriptorData.readUnsignedByte();
+      int descriptorLength = scratchDescriptorData.readUnsignedByte();
+      int nextDescriptorPosition = scratchDescriptorData.getPosition() + descriptorLength;
+      if (descriptorTag == DESCRIPTOR_TAG_CAPTION_SERVICE) {
+        // Note: see ATSC A/65 for detailed information about the caption service descriptor.
+        closedCaptionFormats = new ArrayList<>();
+        int numberOfServices = scratchDescriptorData.readUnsignedByte() & 0x1F;
+        for (int i = 0; i < numberOfServices; i++) {
+          String language = scratchDescriptorData.readString(3);
+          int captionTypeByte = scratchDescriptorData.readUnsignedByte();
+          boolean isDigital = (captionTypeByte & 0x80) != 0;
+          String mimeType;
+          int accessibilityChannel;
+          if (isDigital) {
+            mimeType = MimeTypes.APPLICATION_CEA708;
+            accessibilityChannel = captionTypeByte & 0x3F;
+          } else {
+            mimeType = MimeTypes.APPLICATION_CEA608;
+            accessibilityChannel = 1;
+          }
+          closedCaptionFormats.add(Format.createTextSampleFormat(null, mimeType, null,
+              Format.NO_VALUE, 0, language, accessibilityChannel, null));
+          // Skip easy_reader(1), wide_aspect_ratio(1), reserved(14).
+          scratchDescriptorData.skipBytes(2);
+        }
+      } else {
+        // Unknown descriptor. Ignore.
+      }
+      scratchDescriptorData.setPosition(nextDescriptorPosition);
+    }
+    return new SeiReader(closedCaptionFormats);
+  }
+
   private boolean isSet(@Flags int flag) {
     return (flags & flag) != 0;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
index 9707685295..df1e8816f0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
@@ -26,7 +26,7 @@
 /**
  * Parses a continuous DTS byte stream and extracts individual samples.
  */
-/* package */ final class DtsReader implements ElementaryStreamReader {
+public final class DtsReader implements ElementaryStreamReader {
 
   private static final int STATE_FINDING_SYNC = 0;
   private static final int STATE_READING_HEADER = 1;
@@ -39,6 +39,7 @@
   private final ParsableByteArray headerScratchBytes;
   private final String language;
 
+  private String formatId;
   private TrackOutput output;
 
   private int state;
@@ -79,7 +80,9 @@ public void seek() {
 
   @Override
   public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-    output = extractorOutput.track(idGenerator.getNextId());
+    idGenerator.generateNewId();
+    formatId = idGenerator.getFormatId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_AUDIO);
   }
 
   @Override
@@ -165,7 +168,7 @@ private boolean skipToNextSync(ParsableByteArray pesBuffer) {
   private void parseHeader() {
     byte[] frameData = headerScratchBytes.data;
     if (format == null) {
-      format = DtsUtil.parseDtsFormat(frameData, null, language, null);
+      format = DtsUtil.parseDtsFormat(frameData, formatId, language, null);
       output.format(format);
     }
     sampleSize = DtsUtil.getDtsFrameSize(frameData);
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
index 02ea6d7c4e..7266f847c4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H262Reader.java
@@ -30,13 +30,14 @@
 /**
  * Parses a continuous H262 byte stream and extracts individual frames.
  */
-/* package */ final class H262Reader implements ElementaryStreamReader {
+public final class H262Reader implements ElementaryStreamReader {
 
   private static final int START_PICTURE = 0x00;
   private static final int START_SEQUENCE_HEADER = 0xB3;
   private static final int START_EXTENSION = 0xB5;
   private static final int START_GROUP = 0xB8;
 
+  private String formatId;
   private TrackOutput output;
 
   // Maps (frame_rate_code - 1) indices to values, as defined in ITU-T H.262 Table 6-4.
@@ -78,7 +79,9 @@ public void seek() {
 
   @Override
   public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-    output = extractorOutput.track(idGenerator.getNextId());
+    idGenerator.generateNewId();
+    formatId = idGenerator.getFormatId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_VIDEO);
   }
 
   @Override
@@ -126,7 +129,7 @@ public void consume(ParsableByteArray data) {
         int bytesAlreadyPassed = lengthToStartCode < 0 ? -lengthToStartCode : 0;
         if (csdBuffer.onStartCode(startCodeValue, bytesAlreadyPassed)) {
           // The csd data is complete, so we can decode and output the media format.
-          Pair<Format, Long> result = parseCsdBuffer(csdBuffer);
+          Pair<Format, Long> result = parseCsdBuffer(csdBuffer, formatId);
           output.format(result.first);
           frameDurationUs = result.second;
           hasOutputFormat = true;
@@ -166,10 +169,11 @@ public void packetFinished() {
    * Parses the {@link Format} and frame duration from a csd buffer.
    *
    * @param csdBuffer The csd buffer.
+   * @param formatId The id for the generated format. May be null.
    * @return A pair consisting of the {@link Format} and the frame duration in microseconds, or
    *     0 if the duration could not be determined.
    */
-  private static Pair<Format, Long> parseCsdBuffer(CsdBuffer csdBuffer) {
+  private static Pair<Format, Long> parseCsdBuffer(CsdBuffer csdBuffer, String formatId) {
     byte[] csdData = Arrays.copyOf(csdBuffer.data, csdBuffer.length);
 
     int firstByte = csdData[4] & 0xFF;
@@ -195,7 +199,7 @@ public void packetFinished() {
         break;
     }
 
-    Format format = Format.createVideoSampleFormat(null, MimeTypes.VIDEO_MPEG2, null,
+    Format format = Format.createVideoSampleFormat(formatId, MimeTypes.VIDEO_MPEG2, null,
         Format.NO_VALUE, Format.NO_VALUE, width, height, Format.NO_VALUE,
         Collections.singletonList(csdData), Format.NO_VALUE, pixelWidthHeightRatio, null);
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
index ed4682d9b9..8206ed7d6d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H264Reader.java
@@ -33,12 +33,13 @@
 /**
  * Parses a continuous H264 byte stream and extracts individual frames.
  */
-/* package */ final class H264Reader implements ElementaryStreamReader {
+public final class H264Reader implements ElementaryStreamReader {
 
   private static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
   private static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
   private static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
 
+  private final SeiReader seiReader;
   private final boolean allowNonIdrKeyframes;
   private final boolean detectAccessUnits;
   private final NalUnitTargetBuffer sps;
@@ -47,8 +48,8 @@
   private long totalBytesWritten;
   private final boolean[] prefixFlags;
 
+  private String formatId;
   private TrackOutput output;
-  private SeiReader seiReader;
   private SampleReader sampleReader;
 
   // State that should not be reset on seek.
@@ -61,15 +62,17 @@
   private final ParsableByteArray seiWrapper;
 
   /**
+   * @param seiReader An SEI reader for consuming closed caption channels.
    * @param allowNonIdrKeyframes Whether to treat samples consisting of non-IDR I slices as
    *     synchronization samples (key-frames).
    * @param detectAccessUnits Whether to split the input stream into access units (samples) based on
    *     slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
    */
-  public H264Reader(boolean allowNonIdrKeyframes, boolean detectAccessUnits) {
-    prefixFlags = new boolean[3];
+  public H264Reader(SeiReader seiReader, boolean allowNonIdrKeyframes, boolean detectAccessUnits) {
+    this.seiReader = seiReader;
     this.allowNonIdrKeyframes = allowNonIdrKeyframes;
     this.detectAccessUnits = detectAccessUnits;
+    prefixFlags = new boolean[3];
     sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
     pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
     sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
@@ -88,9 +91,11 @@ public void seek() {
 
   @Override
   public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-    output = extractorOutput.track(idGenerator.getNextId());
+    idGenerator.generateNewId();
+    formatId = idGenerator.getFormatId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_VIDEO);
     sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
-    seiReader = new SeiReader(extractorOutput.track(idGenerator.getNextId()));
+    seiReader.createTracks(extractorOutput, idGenerator);
   }
 
   @Override
@@ -175,7 +180,7 @@ private void endNalUnit(long position, int offset, int discardPadding, long pesT
           initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
           NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(sps.nalData, 3, sps.nalLength);
           NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(pps.nalData, 3, pps.nalLength);
-          output.format(Format.createVideoSampleFormat(null, MimeTypes.VIDEO_H264, null,
+          output.format(Format.createVideoSampleFormat(formatId, MimeTypes.VIDEO_H264, null,
               Format.NO_VALUE, Format.NO_VALUE, spsData.width, spsData.height, Format.NO_VALUE,
               initializationData, Format.NO_VALUE, spsData.pixelWidthAspectRatio, null));
           hasOutputFormat = true;
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
index a78169a054..712ca8d69c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java
@@ -30,7 +30,7 @@
 /**
  * Parses a continuous H.265 byte stream and extracts individual frames.
  */
-/* package */ final class H265Reader implements ElementaryStreamReader {
+public final class H265Reader implements ElementaryStreamReader {
 
   private static final String TAG = "H265Reader";
 
@@ -44,9 +44,11 @@
   private static final int PREFIX_SEI_NUT = 39;
   private static final int SUFFIX_SEI_NUT = 40;
 
+  private final SeiReader seiReader;
+
+  private String formatId;
   private TrackOutput output;
   private SampleReader sampleReader;
-  private SeiReader seiReader;
 
   // State that should not be reset on seek.
   private boolean hasOutputFormat;
@@ -66,7 +68,11 @@
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
-  public H265Reader() {
+  /**
+   * @param seiReader An SEI reader for consuming closed caption channels.
+   */
+  public H265Reader(SeiReader seiReader) {
+    this.seiReader = seiReader;
     prefixFlags = new boolean[3];
     vps = new NalUnitTargetBuffer(VPS_NUT, 128);
     sps = new NalUnitTargetBuffer(SPS_NUT, 128);
@@ -90,9 +96,11 @@ public void seek() {
 
   @Override
   public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-    output = extractorOutput.track(idGenerator.getNextId());
+    idGenerator.generateNewId();
+    formatId = idGenerator.getFormatId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_VIDEO);
     sampleReader = new SampleReader(output);
-    seiReader = new SeiReader(extractorOutput.track(idGenerator.getNextId()));
+    seiReader.createTracks(extractorOutput, idGenerator);
   }
 
   @Override
@@ -183,7 +191,7 @@ private void endNalUnit(long position, int offset, int discardPadding, long pesT
       sps.endNalUnit(discardPadding);
       pps.endNalUnit(discardPadding);
       if (vps.isCompleted() && sps.isCompleted() && pps.isCompleted()) {
-        output.format(parseMediaFormat(vps, sps, pps));
+        output.format(parseMediaFormat(formatId, vps, sps, pps));
         hasOutputFormat = true;
       }
     }
@@ -205,8 +213,8 @@ private void endNalUnit(long position, int offset, int discardPadding, long pesT
     }
   }
 
-  private static Format parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTargetBuffer sps,
-      NalUnitTargetBuffer pps) {
+  private static Format parseMediaFormat(String formatId, NalUnitTargetBuffer vps,
+      NalUnitTargetBuffer sps, NalUnitTargetBuffer pps) {
     // Build codec-specific data.
     byte[] csd = new byte[vps.nalLength + sps.nalLength + pps.nalLength];
     System.arraycopy(vps.nalData, 0, csd, 0, vps.nalLength);
@@ -311,7 +319,7 @@ private static Format parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTargetBuf
       }
     }
 
-    return Format.createVideoSampleFormat(null, MimeTypes.VIDEO_H265, null, Format.NO_VALUE,
+    return Format.createVideoSampleFormat(formatId, MimeTypes.VIDEO_H265, null, Format.NO_VALUE,
         Format.NO_VALUE, picWidthInLumaSamples, picHeightInLumaSamples, Format.NO_VALUE,
         Collections.singletonList(csd), Format.NO_VALUE, pixelWidthHeightRatio, null);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
index c19bc9d14e..98e1309143 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/Id3Reader.java
@@ -27,7 +27,7 @@
 /**
  * Parses ID3 data and extracts individual text information frames.
  */
-/* package */ final class Id3Reader implements ElementaryStreamReader {
+public final class Id3Reader implements ElementaryStreamReader {
 
   private static final String TAG = "Id3Reader";
 
@@ -56,9 +56,10 @@ public void seek() {
 
   @Override
   public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-    output = extractorOutput.track(idGenerator.getNextId());
-    output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_ID3, null, Format.NO_VALUE,
-        null));
+    idGenerator.generateNewId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_METADATA);
+    output.format(Format.createSampleFormat(idGenerator.getFormatId(), MimeTypes.APPLICATION_ID3,
+        null, Format.NO_VALUE, null));
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
index c67e7ad0ab..82fb84b291 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/MpegAudioReader.java
@@ -26,7 +26,7 @@
 /**
  * Parses a continuous MPEG Audio byte stream and extracts individual frames.
  */
-/* package */ final class MpegAudioReader implements ElementaryStreamReader {
+public final class MpegAudioReader implements ElementaryStreamReader {
 
   private static final int STATE_FINDING_HEADER = 0;
   private static final int STATE_READING_HEADER = 1;
@@ -38,6 +38,7 @@
   private final MpegAudioHeader header;
   private final String language;
 
+  private String formatId;
   private TrackOutput output;
 
   private int state;
@@ -76,7 +77,9 @@ public void seek() {
 
   @Override
   public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-    output = extractorOutput.track(idGenerator.getNextId());
+    idGenerator.generateNewId();
+    formatId = idGenerator.getFormatId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_AUDIO);
   }
 
   @Override
@@ -176,9 +179,9 @@ private void readHeaderRemainder(ParsableByteArray source) {
     frameSize = header.frameSize;
     if (!hasOutputFormat) {
       frameDurationUs = (C.MICROS_PER_SECOND * header.samplesPerFrame) / header.sampleRate;
-      Format format = Format.createAudioSampleFormat(null, header.mimeType, null, Format.NO_VALUE,
-          MpegAudioHeader.MAX_FRAME_SIZE_BYTES, header.channels, header.sampleRate, null, null, 0,
-          language);
+      Format format = Format.createAudioSampleFormat(formatId, header.mimeType, null,
+          Format.NO_VALUE, MpegAudioHeader.MAX_FRAME_SIZE_BYTES, header.channels, header.sampleRate,
+          null, null, 0, language);
       output.format(format);
       hasOutputFormat = true;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
index 598394a870..59696b9dea 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PesReader.java
@@ -16,12 +16,11 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import android.util.Log;
-
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Parses PES packet data and extracts samples.
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
index 5c50ca7bf3..883fb8f880 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
@@ -23,10 +23,10 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.IOException;
 
 /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
index 347c401337..d6e6eadf3f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionPayloadReader.java
@@ -16,10 +16,10 @@
 package com.google.android.exoplayer2.extractor.ts;
 
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Reads section data.
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
index 822f5653c4..d217cfcb7a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SectionReader.java
@@ -17,8 +17,8 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 
 /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
index a2791bcaae..1e5d480ea1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java
@@ -17,59 +17,49 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.text.cea.Cea608Decoder;
+import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
+import com.google.android.exoplayer2.text.cea.CeaUtil;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.util.List;
 
 /**
  * Consumes SEI buffers, outputting contained CEA-608 messages to a {@link TrackOutput}.
  */
 /* package */ final class SeiReader {
 
-  private final TrackOutput output;
+  private final List<Format> closedCaptionFormats;
+  private final TrackOutput[] outputs;
 
-  public SeiReader(TrackOutput output) {
-    this.output = output;
-    output.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608, null,
-        Format.NO_VALUE, 0, null, null));
+  /**
+   * @param closedCaptionFormats A list of formats for the closed caption channels to expose.
+   */
+  public SeiReader(List<Format> closedCaptionFormats) {
+    this.closedCaptionFormats = closedCaptionFormats;
+    outputs = new TrackOutput[closedCaptionFormats.size()];
   }
 
-  public void consume(long pesTimeUs, ParsableByteArray seiBuffer) {
-    int b;
-    while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
-      // Parse payload type.
-      int payloadType = 0;
-      do {
-        b = seiBuffer.readUnsignedByte();
-        payloadType += b;
-      } while (b == 0xFF);
-      // Parse payload size.
-      int payloadSize = 0;
-      do {
-        b = seiBuffer.readUnsignedByte();
-        payloadSize += b;
-      } while (b == 0xFF);
-      // Process the payload.
-      if (Cea608Decoder.isSeiMessageCea608(payloadType, payloadSize, seiBuffer)) {
-        // Ignore country_code (1) + provider_code (2) + user_identifier (4)
-        // + user_data_type_code (1).
-        seiBuffer.skipBytes(8);
-        // Ignore first three bits: reserved (1) + process_cc_data_flag (1) + zero_bit (1).
-        int ccCount = seiBuffer.readUnsignedByte() & 0x1F;
-        // Ignore em_data (1)
-        seiBuffer.skipBytes(1);
-        // Each data packet consists of 24 bits: marker bits (5) + cc_valid (1) + cc_type (2)
-        // + cc_data_1 (8) + cc_data_2 (8).
-        int sampleLength = ccCount * 3;
-        output.sampleData(seiBuffer, sampleLength);
-        output.sampleMetadata(pesTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleLength, 0, null);
-        // Ignore trailing information in SEI, if any.
-        seiBuffer.skipBytes(payloadSize - (10 + ccCount * 3));
-      } else {
-        seiBuffer.skipBytes(payloadSize);
-      }
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    for (int i = 0; i < outputs.length; i++) {
+      idGenerator.generateNewId();
+      TrackOutput output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_TEXT);
+      Format channelFormat = closedCaptionFormats.get(i);
+      String channelMimeType = channelFormat.sampleMimeType;
+      Assertions.checkArgument(MimeTypes.APPLICATION_CEA608.equals(channelMimeType)
+          || MimeTypes.APPLICATION_CEA708.equals(channelMimeType),
+          "Invalid closed caption mime type provided: " + channelMimeType);
+      output.format(Format.createTextSampleFormat(idGenerator.getFormatId(), channelMimeType, null,
+          Format.NO_VALUE, channelFormat.selectionFlags, channelFormat.language,
+          channelFormat.accessibilityChannel, null));
+      outputs[i] = output;
     }
   }
 
+  public void consume(long pesTimeUs, ParsableByteArray seiBuffer) {
+    CeaUtil.consume(pesTimeUs, seiBuffer, outputs);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
index b1e71d6651..27838d4c25 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/SpliceInfoSectionReader.java
@@ -18,31 +18,45 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Parses splice info sections as defined by SCTE35.
  */
 public final class SpliceInfoSectionReader implements SectionPayloadReader {
 
+  private TimestampAdjuster timestampAdjuster;
   private TrackOutput output;
+  private boolean formatDeclared;
 
   @Override
   public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
       TsPayloadReader.TrackIdGenerator idGenerator) {
-    output = extractorOutput.track(idGenerator.getNextId());
-    output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_SCTE35, null,
-        Format.NO_VALUE, null));
+    this.timestampAdjuster = timestampAdjuster;
+    idGenerator.generateNewId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_METADATA);
+    output.format(Format.createSampleFormat(idGenerator.getFormatId(), MimeTypes.APPLICATION_SCTE35,
+        null, Format.NO_VALUE, null));
   }
 
   @Override
   public void consume(ParsableByteArray sectionData) {
+    if (!formatDeclared) {
+      if (timestampAdjuster.getTimestampOffsetUs() == C.TIME_UNSET) {
+        // There is not enough information to initialize the timestamp adjuster.
+        return;
+      }
+      output.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_SCTE35,
+          timestampAdjuster.getTimestampOffsetUs()));
+      formatDeclared = true;
+    }
     int sampleSize = sectionData.bytesLeft();
     output.sampleData(sectionData, sampleSize);
-    output.sampleMetadata(0, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+    output.sampleMetadata(timestampAdjuster.getLastAdjustedTimestampUs(), C.BUFFER_FLAG_KEY_FRAME,
+        sampleSize, 0, null);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index bf5adac500..65b97c8a73 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
+import android.support.annotation.IntDef;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
@@ -25,16 +26,21 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.EsInfo;
 import com.google.android.exoplayer2.extractor.ts.TsPayloadReader.TrackIdGenerator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * Facilitates the extraction of data from the MPEG-2 TS container format.
@@ -53,6 +59,27 @@
 
   };
 
+  /**
+   * Modes for the extractor.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({MODE_NORMAL, MODE_SINGLE_PMT, MODE_HLS})
+  public @interface Mode {}
+
+  /**
+   * Behave as defined in ISO/IEC 13818-1.
+   */
+  public static final int MODE_NORMAL = 0;
+  /**
+   * Assume only one PMT will be contained in the stream, even if more are declared by the PAT.
+   */
+  public static final int MODE_SINGLE_PMT = 1;
+  /**
+   * Enable single PMT mode, map {@link TrackOutput}s by their type (instead of PID) and ignore
+   * continuity counters.
+   */
+  public static final int MODE_HLS = 2;
+
   public static final int TS_STREAM_TYPE_MPA = 0x03;
   public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
   public static final int TS_STREAM_TYPE_AAC = 0x0F;
@@ -78,8 +105,8 @@
   private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
   private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
 
-  private final boolean hlsMode;
-  private final TimestampAdjuster timestampAdjuster;
+  @Mode private final int mode;
+  private final List<TimestampAdjuster> timestampAdjusters;
   private final ParsableByteArray tsPacketBuffer;
   private final ParsableBitArray tsScratch;
   private final SparseIntArray continuityCounters;
@@ -89,31 +116,30 @@
 
   // Accessed only by the loading thread.
   private ExtractorOutput output;
+  private int remainingPmts;
   private boolean tracksEnded;
   private TsPayloadReader id3Reader;
 
   public TsExtractor() {
-    this(new TimestampAdjuster(0));
-  }
-
-  /**
-   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
-   */
-  public TsExtractor(TimestampAdjuster timestampAdjuster) {
-    this(timestampAdjuster, new DefaultTsPayloadReaderFactory(), false);
+    this(MODE_NORMAL, new TimestampAdjuster(0), new DefaultTsPayloadReaderFactory());
   }
 
   /**
+   * @param mode Mode for the extractor. One of {@link #MODE_NORMAL}, {@link #MODE_SINGLE_PMT}
+   *     and {@link #MODE_HLS}.
    * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
    * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
-   * @param hlsMode Whether the extractor should be used in HLS mode. If true, {@link TrackOutput}s
-   *     are mapped by their type (instead of PID) and continuity counters are ignored.
    */
-  public TsExtractor(TimestampAdjuster timestampAdjuster,
-      TsPayloadReader.Factory payloadReaderFactory, boolean hlsMode) {
-    this.timestampAdjuster = timestampAdjuster;
+  public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
+      TsPayloadReader.Factory payloadReaderFactory) {
     this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
-    this.hlsMode = hlsMode;
+    this.mode = mode;
+    if (mode == MODE_SINGLE_PMT || mode == MODE_HLS) {
+      timestampAdjusters = Collections.singletonList(timestampAdjuster);
+    } else {
+      timestampAdjusters = new ArrayList<>();
+      timestampAdjusters.add(timestampAdjuster);
+    }
     tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
     tsScratch = new ParsableBitArray(new byte[3]);
     trackIds = new SparseBooleanArray();
@@ -150,7 +176,10 @@ public void init(ExtractorOutput output) {
 
   @Override
   public void seek(long position, long timeUs) {
-    timestampAdjuster.reset();
+    int timestampAdjustersCount = timestampAdjusters.size();
+    for (int i = 0; i < timestampAdjustersCount; i++) {
+      timestampAdjusters.get(i).reset();
+    }
     tsPacketBuffer.reset();
     continuityCounters.clear();
     // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
@@ -215,7 +244,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     // Discontinuity check.
     boolean discontinuityFound = false;
     int continuityCounter = tsScratch.readBits(4);
-    if (!hlsMode) {
+    if (mode != MODE_HLS) {
       int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
       continuityCounters.put(pid, continuityCounter);
       if (previousCounter == continuityCounter) {
@@ -307,8 +336,12 @@ public void consume(ParsableByteArray sectionData) {
         } else {
           int pid = patScratch.readBits(13);
           tsPayloadReaders.put(pid, new SectionReader(new PmtReader(pid)));
+          remainingPmts++;
         }
       }
+      if (mode != MODE_HLS) {
+        tsPayloadReaders.remove(TS_PAT_PID);
+      }
     }
 
   }
@@ -345,10 +378,22 @@ public void consume(ParsableByteArray sectionData) {
         // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
         return;
       }
-      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12), program_number (16),
-      // reserved (2), version_number (5), current_next_indicator (1), // section_number (8),
+      // TimestampAdjuster assignment.
+      TimestampAdjuster timestampAdjuster;
+      if (mode == MODE_SINGLE_PMT || mode == MODE_HLS || remainingPmts == 1) {
+        timestampAdjuster = timestampAdjusters.get(0);
+      } else {
+        timestampAdjuster = new TimestampAdjuster(
+            timestampAdjusters.get(0).getFirstSampleTimestampUs());
+        timestampAdjusters.add(timestampAdjuster);
+      }
+
+      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12)
+      sectionData.skipBytes(2);
+      int programNumber = sectionData.readUnsignedShort();
+      // reserved (2), version_number (5), current_next_indicator (1), section_number (8),
       // last_section_number (8), reserved (3), PCR_PID (13)
-      sectionData.skipBytes(9);
+      sectionData.skipBytes(5);
 
       // Read program_info_length.
       sectionData.readBytes(pmtScratch, 2);
@@ -358,13 +403,13 @@ public void consume(ParsableByteArray sectionData) {
       // Skip the descriptors.
       sectionData.skipBytes(programInfoLength);
 
-      if (hlsMode && id3Reader == null) {
+      if (mode == MODE_HLS && id3Reader == null) {
         // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
         // appears intermittently during playback. See [Internal: b/20261500].
         EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, new byte[0]);
         id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
         id3Reader.init(timestampAdjuster, output,
-            new TrackIdGenerator(TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
+            new TrackIdGenerator(programNumber, TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
       }
 
       int remainingEntriesLength = sectionData.bytesLeft();
@@ -381,19 +426,20 @@ public void consume(ParsableByteArray sectionData) {
         }
         remainingEntriesLength -= esInfoLength + 5;
 
-        int trackId = hlsMode ? streamType : elementaryPid;
+        int trackId = mode == MODE_HLS ? streamType : elementaryPid;
         if (trackIds.get(trackId)) {
           continue;
         }
         trackIds.put(trackId, true);
 
         TsPayloadReader reader;
-        if (hlsMode && streamType == TS_STREAM_TYPE_ID3) {
+        if (mode == MODE_HLS && streamType == TS_STREAM_TYPE_ID3) {
           reader = id3Reader;
         } else {
           reader = payloadReaderFactory.createPayloadReader(streamType, esInfo);
           if (reader != null) {
-            reader.init(timestampAdjuster, output, new TrackIdGenerator(trackId, MAX_PID_PLUS_ONE));
+            reader.init(timestampAdjuster, output,
+                new TrackIdGenerator(programNumber, trackId, MAX_PID_PLUS_ONE));
           }
         }
 
@@ -401,16 +447,20 @@ public void consume(ParsableByteArray sectionData) {
           tsPayloadReaders.put(elementaryPid, reader);
         }
       }
-      if (hlsMode) {
+      if (mode == MODE_HLS) {
         if (!tracksEnded) {
           output.endTracks();
+          remainingPmts = 0;
+          tracksEnded = true;
         }
       } else {
-        tsPayloadReaders.remove(TS_PAT_PID);
         tsPayloadReaders.remove(pid);
-        output.endTracks();
+        remainingPmts = mode == MODE_SINGLE_PMT ? 0 : remainingPmts - 1;
+        if (remainingPmts == 0) {
+          output.endTracks();
+          tracksEnded = true;
+        }
       }
-      tracksEnded = true;
     }
 
     /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
index 304c8c1282..4169e0f3a0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsPayloadReader.java
@@ -17,9 +17,9 @@
 
 import android.util.SparseArray;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Parses TS packet payload data.
@@ -81,17 +81,63 @@ public EsInfo(int streamType, String language, byte[] descriptorBytes) {
    */
   final class TrackIdGenerator {
 
-    private final int firstId;
-    private final int idIncrement;
-    private int generatedIdCount;
+    private static final int ID_UNSET = Integer.MIN_VALUE;
 
-    public TrackIdGenerator(int firstId, int idIncrement) {
-      this.firstId = firstId;
-      this.idIncrement = idIncrement;
+    private final String formatIdPrefix;
+    private final int firstTrackId;
+    private final int trackIdIncrement;
+    private int trackId;
+    private String formatId;
+
+    public TrackIdGenerator(int firstTrackId, int trackIdIncrement) {
+      this(ID_UNSET, firstTrackId, trackIdIncrement);
+    }
+
+    public TrackIdGenerator(int programNumber, int firstTrackId, int trackIdIncrement) {
+      this.formatIdPrefix = programNumber != ID_UNSET ? programNumber + "/" : "";
+      this.firstTrackId = firstTrackId;
+      this.trackIdIncrement = trackIdIncrement;
+      trackId = ID_UNSET;
+    }
+
+    /**
+     * Generates a new set of track and track format ids. Must be called before {@code get*}
+     * methods.
+     */
+    public void generateNewId() {
+      trackId = trackId == ID_UNSET ? firstTrackId : trackId + trackIdIncrement;
+      formatId = formatIdPrefix + trackId;
+    }
+
+    /**
+     * Returns the last generated track id. Must be called after the first {@link #generateNewId()}
+     * call.
+     *
+     * @return The last generated track id.
+     */
+    public int getTrackId() {
+      maybeThrowUninitializedError();
+      return trackId;
+    }
+
+    /**
+     * Returns the last generated format id, with the format {@code "programNumber/trackId"}. If no
+     * {@code programNumber} was provided, the {@code trackId} alone is used as format id. Must be
+     * called after the first {@link #generateNewId()} call.
+     *
+     * @return The last generated format id, with the format {@code "programNumber/trackId"}. If no
+     *     {@code programNumber} was provided, the {@code trackId} alone is used as
+     *     format id.
+     */
+    public String getFormatId() {
+      maybeThrowUninitializedError();
+      return formatId;
     }
 
-    public int getNextId() {
-      return firstId + idIncrement * generatedIdCount++;
+    private void maybeThrowUninitializedError() {
+      if (trackId == ID_UNSET) {
+        throw new IllegalStateException("generateNewId() must be called before retrieving ids.");
+      }
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
index 3d9f8166ab..cb46aa5519 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
@@ -60,7 +60,7 @@ public boolean sniff(ExtractorInput input) throws IOException, InterruptedExcept
   @Override
   public void init(ExtractorOutput output) {
     extractorOutput = output;
-    trackOutput = output.track(0);
+    trackOutput = output.track(0, C.TRACK_TYPE_AUDIO);
     wavHeader = null;
     output.endTracks();
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
index 166de37c50..6914b2f52c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.mediacodec;
 
 import android.annotation.TargetApi;
+import android.graphics.Point;
 import android.media.MediaCodec;
 import android.media.MediaCodecInfo.AudioCapabilities;
 import android.media.MediaCodecInfo.CodecCapabilities;
@@ -23,6 +24,7 @@
 import android.media.MediaCodecInfo.VideoCapabilities;
 import android.util.Log;
 import android.util.Pair;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
@@ -142,70 +144,68 @@ public boolean isCodecSupported(String codec) {
   }
 
   /**
-   * Whether the decoder supports video with a specified width and height.
+   * Whether the decoder supports video with a given width, height and frame rate.
    * <p>
    * Must not be called if the device SDK version is less than 21.
    *
    * @param width Width in pixels.
    * @param height Height in pixels.
-   * @return Whether the decoder supports video with the given width and height.
+   * @param frameRate Optional frame rate in frames per second. Ignored if set to
+   *     {@link Format#NO_VALUE} or any value less than or equal to 0.
+   * @return Whether the decoder supports video with the given width, height and frame rate.
    */
   @TargetApi(21)
-  public boolean isVideoSizeSupportedV21(int width, int height) {
+  public boolean isVideoSizeAndRateSupportedV21(int width, int height, double frameRate) {
     if (capabilities == null) {
-      logNoSupport("size.caps");
+      logNoSupport("sizeAndRate.caps");
       return false;
     }
     VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();
     if (videoCapabilities == null) {
-      logNoSupport("size.vCaps");
+      logNoSupport("sizeAndRate.vCaps");
       return false;
     }
-    if (!videoCapabilities.isSizeSupported(width, height)) {
+    if (!areSizeAndRateSupported(videoCapabilities, width, height, frameRate)) {
       // Capabilities are known to be inaccurately reported for vertical resolutions on some devices
       // (b/31387661). If the video is vertical and the capabilities indicate support if the width
       // and height are swapped, we assume that the vertical resolution is also supported.
-      if (width >= height || !videoCapabilities.isSizeSupported(height, width)) {
-        logNoSupport("size.support, " + width + "x" + height);
+      if (width >= height
+          || !areSizeAndRateSupported(videoCapabilities, height, width, frameRate)) {
+        logNoSupport("sizeAndRate.support, " + width + "x" + height + "x" + frameRate);
         return false;
       }
-      logAssumedSupport("size.rotated, " + width + "x" + height);
+      logAssumedSupport("sizeAndRate.rotated, " + width + "x" + height + "x" + frameRate);
     }
     return true;
   }
 
   /**
-   * Whether the decoder supports video with a given width, height and frame rate.
+   * Returns the smallest video size greater than or equal to a specified size that also satisfies
+   * the {@link MediaCodec}'s width and height alignment requirements.
    * <p>
    * Must not be called if the device SDK version is less than 21.
    *
    * @param width Width in pixels.
    * @param height Height in pixels.
-   * @param frameRate Frame rate in frames per second.
-   * @return Whether the decoder supports video with the given width, height and frame rate.
+   * @return The smallest video size greater than or equal to the specified size that also satisfies
+   *     the {@link MediaCodec}'s width and height alignment requirements, or null if not a video
+   *     codec.
    */
   @TargetApi(21)
-  public boolean isVideoSizeAndRateSupportedV21(int width, int height, double frameRate) {
+  public Point alignVideoSizeV21(int width, int height) {
     if (capabilities == null) {
-      logNoSupport("sizeAndRate.caps");
-      return false;
+      logNoSupport("align.caps");
+      return null;
     }
     VideoCapabilities videoCapabilities = capabilities.getVideoCapabilities();
     if (videoCapabilities == null) {
-      logNoSupport("sizeAndRate.vCaps");
-      return false;
+      logNoSupport("align.vCaps");
+      return null;
     }
-    if (!videoCapabilities.areSizeAndRateSupported(width, height, frameRate)) {
-      // Capabilities are known to be inaccurately reported for vertical resolutions on some devices
-      // (b/31387661). If the video is vertical and the capabilities indicate support if the width
-      // and height are swapped, we assume that the vertical resolution is also supported.
-      if (width >= height || !videoCapabilities.areSizeAndRateSupported(height, width, frameRate)) {
-        logNoSupport("sizeAndRate.support, " + width + "x" + height + "x" + frameRate);
-        return false;
-      }
-      logAssumedSupport("sizeAndRate.rotated, " + width + "x" + height + "x" + frameRate);
-    }
-    return true;
+    int widthAlignment = videoCapabilities.getWidthAlignment();
+    int heightAlignment = videoCapabilities.getHeightAlignment();
+    return new Point(Util.ceilDivide(width, widthAlignment) * widthAlignment,
+        Util.ceilDivide(height, heightAlignment) * heightAlignment);
   }
 
   /**
@@ -279,6 +279,14 @@ private static boolean isAdaptiveV19(CodecCapabilities capabilities) {
     return capabilities.isFeatureSupported(CodecCapabilities.FEATURE_AdaptivePlayback);
   }
 
+  @TargetApi(21)
+  private static boolean areSizeAndRateSupported(VideoCapabilities capabilities, int width,
+      int height, double frameRate) {
+    return frameRate == Format.NO_VALUE || frameRate <= 0
+        ? capabilities.isSizeSupported(width, height)
+        : capabilities.areSizeAndRateSupported(width, height, frameRate);
+  }
+
   private static boolean isTunneling(CodecCapabilities capabilities) {
     return Util.SDK_INT >= 21 && isTunnelingV21(capabilities);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 6dce2abc2a..3fbbfac652 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -183,6 +183,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private boolean codecNeedsAdaptationWorkaround;
   private boolean codecNeedsEosPropagationWorkaround;
   private boolean codecNeedsEosFlushWorkaround;
+  private boolean codecNeedsEosOutputExceptionWorkaround;
   private boolean codecNeedsMonoChannelCountWorkaround;
   private boolean codecNeedsAdaptationWorkaroundBuffer;
   private boolean shouldSkipAdaptationWorkaroundOutputBuffer;
@@ -201,6 +202,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean waitingForKeys;
+  private boolean waitingForFirstSyncFrame;
 
   protected DecoderCounters decoderCounters;
 
@@ -270,17 +272,20 @@ protected abstract int supportsFormat(MediaCodecSelector mediaCodecSelector, For
    */
   protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
       Format format, boolean requiresSecureDecoder) throws DecoderQueryException {
-    return mediaCodecSelector.getDecoderInfo(format.sampleMimeType, requiresSecureDecoder, false);
+    return mediaCodecSelector.getDecoderInfo(format.sampleMimeType, requiresSecureDecoder);
   }
 
   /**
    * Configures a newly created {@link MediaCodec}.
    *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param codec The {@link MediaCodec} to configure.
    * @param format The format for which the codec is being configured.
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
+   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  protected abstract void configureCodec(MediaCodec codec, Format format, MediaCrypto crypto);
+  protected abstract void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+      MediaCrypto crypto) throws DecoderQueryException;
 
   @SuppressWarnings("deprecation")
   protected final void maybeInitCodec() throws ExoPlaybackException {
@@ -338,6 +343,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     codecNeedsAdaptationWorkaround = codecNeedsAdaptationWorkaround(codecName);
     codecNeedsEosPropagationWorkaround = codecNeedsEosPropagationWorkaround(codecName);
     codecNeedsEosFlushWorkaround = codecNeedsEosFlushWorkaround(codecName);
+    codecNeedsEosOutputExceptionWorkaround = codecNeedsEosOutputExceptionWorkaround(codecName);
     codecNeedsMonoChannelCountWorkaround = codecNeedsMonoChannelCountWorkaround(codecName, format);
     try {
       long codecInitializingTimestamp = SystemClock.elapsedRealtime();
@@ -345,7 +351,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       codec = MediaCodec.createByCodecName(codecName);
       TraceUtil.endSection();
       TraceUtil.beginSection("configureCodec");
-      configureCodec(codec, format, mediaCrypto);
+      configureCodec(decoderInfo, codec, format, mediaCrypto);
       TraceUtil.endSection();
       TraceUtil.beginSection("startCodec");
       codec.start();
@@ -363,6 +369,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
         ? (SystemClock.elapsedRealtime() + MAX_CODEC_HOTSWAP_TIME_MS) : C.TIME_UNSET;
     inputIndex = C.INDEX_UNSET;
     outputIndex = C.INDEX_UNSET;
+    waitingForFirstSyncFrame = true;
     decoderCounters.decoderInitCount++;
   }
 
@@ -473,10 +480,25 @@ protected void onStopped() {
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     if (outputStreamEnded) {
+      renderToEndOfStream();
       return;
     }
     if (format == null) {
-      readFormat();
+      // We don't have a format yet, so try and read one.
+      buffer.clear();
+      int result = readSource(formatHolder, buffer, true);
+      if (result == C.RESULT_FORMAT_READ) {
+        onInputFormatChanged(formatHolder.format);
+      } else if (result == C.RESULT_BUFFER_READ) {
+        // End of stream read having not read a format.
+        Assertions.checkState(buffer.isEndOfStream());
+        inputStreamEnded = true;
+        processEndOfStream();
+        return;
+      } else {
+        // We still don't have a format and can't make progress without one.
+        return;
+      }
     }
     maybeInitCodec();
     if (codec != null) {
@@ -490,24 +512,17 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     decoderCounters.ensureUpdated();
   }
 
-  private void readFormat() throws ExoPlaybackException {
-    int result = readSource(formatHolder, null);
-    if (result == C.RESULT_FORMAT_READ) {
-      onInputFormatChanged(formatHolder.format);
-    }
-  }
-
   protected void flushCodec() throws ExoPlaybackException {
     codecHotswapDeadlineMs = C.TIME_UNSET;
     inputIndex = C.INDEX_UNSET;
     outputIndex = C.INDEX_UNSET;
+    waitingForFirstSyncFrame = true;
     waitingForKeys = false;
     shouldSkipOutputBuffer = false;
     decodeOnlyPresentationTimestamps.clear();
     codecNeedsAdaptationWorkaroundBuffer = false;
     shouldSkipAdaptationWorkaroundOutputBuffer = false;
     if (codecNeedsFlushWorkaround || (codecNeedsEosFlushWorkaround && codecReceivedEos)) {
-      // Workaround framework bugs. See [Internal: b/8347958, b/8578467, b/8543366, b/23361053].
       releaseCodec();
       maybeInitCodec();
     } else if (codecReinitializationState != REINITIALIZATION_STATE_NONE) {
@@ -586,7 +601,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         codecReconfigurationState = RECONFIGURATION_STATE_QUEUE_PENDING;
       }
       adaptiveReconfigurationBytes = buffer.data.position();
-      result = readSource(formatHolder, buffer);
+      result = readSource(formatHolder, buffer, false);
     }
 
     if (result == C.RESULT_NOTHING_READ) {
@@ -630,6 +645,16 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       }
       return false;
     }
+    if (waitingForFirstSyncFrame && !buffer.isKeyFrame()) {
+      buffer.clear();
+      if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {
+        // The buffer we just cleared contained reconfiguration data. We need to re-write this
+        // data into a subsequent buffer (if there is one).
+        codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
+      }
+      return true;
+    }
+    waitingForFirstSyncFrame = false;
     boolean bufferEncrypted = buffer.isEncrypted();
     waitingForKeys = shouldWaitForKeys(bufferEncrypted);
     if (waitingForKeys) {
@@ -763,18 +788,10 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
    *
    * @param codec The {@link MediaCodec} instance.
    * @param outputFormat The new output format.
+   * @throws ExoPlaybackException Thrown if an error occurs handling the new output format.
    */
-  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat) {
-    // Do nothing.
-  }
-
-  /**
-   * Called when the output stream ends, meaning that the last output buffer has been processed and
-   * the {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM} flag has been propagated through the decoder.
-   * <p>
-   * The default implementation is a no-op.
-   */
-  protected void onOutputStreamEnded() {
+  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
+      throws ExoPlaybackException {
     // Do nothing.
   }
 
@@ -849,7 +866,22 @@ protected long getDequeueOutputBufferTimeoutUs() {
   private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException {
     if (outputIndex < 0) {
-      outputIndex = codec.dequeueOutputBuffer(outputBufferInfo, getDequeueOutputBufferTimeoutUs());
+      if (codecNeedsEosOutputExceptionWorkaround && codecReceivedEos) {
+        try {
+          outputIndex = codec.dequeueOutputBuffer(outputBufferInfo,
+              getDequeueOutputBufferTimeoutUs());
+        } catch (IllegalStateException e) {
+          processEndOfStream();
+          if (outputStreamEnded) {
+            // Release the codec, as it's in an error state.
+            releaseCodec();
+          }
+          return false;
+        }
+      } else {
+        outputIndex = codec.dequeueOutputBuffer(outputBufferInfo,
+            getDequeueOutputBufferTimeoutUs());
+      }
       if (outputIndex >= 0) {
         // We've dequeued a buffer.
         if (shouldSkipAdaptationWorkaroundOutputBuffer) {
@@ -888,9 +920,27 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       }
     }
 
-    if (processOutputBuffer(positionUs, elapsedRealtimeUs, codec, outputBuffers[outputIndex],
-        outputIndex, outputBufferInfo.flags, outputBufferInfo.presentationTimeUs,
-        shouldSkipOutputBuffer)) {
+    boolean processedOutputBuffer;
+    if (codecNeedsEosOutputExceptionWorkaround && codecReceivedEos) {
+      try {
+        processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs, codec,
+            outputBuffers[outputIndex], outputIndex, outputBufferInfo.flags,
+            outputBufferInfo.presentationTimeUs, shouldSkipOutputBuffer);
+      } catch (IllegalStateException e) {
+        processEndOfStream();
+        if (outputStreamEnded) {
+          // Release the codec, as it's in an error state.
+          releaseCodec();
+        }
+        return false;
+      }
+    } else {
+      processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs, codec,
+          outputBuffers[outputIndex], outputIndex, outputBufferInfo.flags,
+          outputBufferInfo.presentationTimeUs, shouldSkipOutputBuffer);
+    }
+
+    if (processedOutputBuffer) {
       onProcessedOutputBuffer(outputBufferInfo.presentationTimeUs);
       outputIndex = C.INDEX_UNSET;
       return true;
@@ -902,7 +952,7 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
   /**
    * Processes a new output format.
    */
-  private void processOutputFormat() {
+  private void processOutputFormat() throws ExoPlaybackException {
     MediaFormat format = codec.getOutputFormat();
     if (codecNeedsAdaptationWorkaround
         && format.getInteger(MediaFormat.KEY_WIDTH) == ADAPTATION_WORKAROUND_SLICE_WIDTH_HEIGHT
@@ -958,6 +1008,17 @@ protected abstract boolean processOutputBuffer(long positionUs, long elapsedReal
       MediaCodec codec, ByteBuffer buffer, int bufferIndex, int bufferFlags,
       long bufferPresentationTimeUs, boolean shouldSkip) throws ExoPlaybackException;
 
+  /**
+   * Incrementally renders any remaining output.
+   * <p>
+   * The default implementation is a no-op.
+   *
+   * @throws ExoPlaybackException Thrown if an error occurs rendering remaining output.
+   */
+  protected void renderToEndOfStream() throws ExoPlaybackException {
+    // Do nothing.
+  }
+
   /**
    * Processes an end of stream signal.
    *
@@ -970,7 +1031,7 @@ private void processEndOfStream() throws ExoPlaybackException {
       maybeInitCodec();
     } else {
       outputStreamEnded = true;
-      onOutputStreamEnded();
+      renderToEndOfStream();
     }
   }
 
@@ -992,6 +1053,8 @@ private boolean shouldSkipOutputBuffer(long presentationTimeUs) {
    * <p>
    * If true is returned, the renderer will work around the issue by releasing the decoder and
    * instantiating a new one rather than flushing the current instance.
+   * <p>
+   * See [Internal: b/8347958, b/8543366].
    *
    * @param name The name of the decoder.
    * @return True if the decoder is known to fail when flushed.
@@ -1061,6 +1124,8 @@ private static boolean codecNeedsEosPropagationWorkaround(String name) {
    * <p>
    * If true is returned, the renderer will work around the issue by instantiating a new decoder
    * when this case occurs.
+   * <p>
+   * See [Internal: b/8578467, b/23361053].
    *
    * @param name The name of the decoder.
    * @return True if the decoder is known to behave incorrectly if flushed after receiving an input
@@ -1073,6 +1138,21 @@ private static boolean codecNeedsEosFlushWorkaround(String name) {
                 || "OMX.amlogic.avc.decoder.awesome.secure".equals(name)));
   }
 
+  /**
+   * Returns whether the decoder may throw an {@link IllegalStateException} from
+   * {@link MediaCodec#dequeueOutputBuffer(MediaCodec.BufferInfo, long)} or
+   * {@link MediaCodec#releaseOutputBuffer(int, boolean)} after receiving an input
+   * buffer with {@link MediaCodec#BUFFER_FLAG_END_OF_STREAM} set.
+   * <p>
+   * See [Internal: b/17933838].
+   *
+   * @param name The name of the decoder.
+   * @return True if the decoder may throw an exception after receiving an end-of-stream buffer.
+   */
+  private static boolean codecNeedsEosOutputExceptionWorkaround(String name) {
+    return Util.SDK_INT == 21 && "OMX.google.aac.decoder".equals(name);
+  }
+
   /**
    * Returns whether the decoder is known to set the number of audio channels in the output format
    * to 2 for the given input format, whilst only actually outputting a single channel.
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
index ea8832c39c..bb946d76f9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
@@ -29,9 +29,9 @@
   MediaCodecSelector DEFAULT = new MediaCodecSelector() {
 
     @Override
-    public MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder,
-        boolean requiresTunneling) throws DecoderQueryException {
-      return MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder, requiresTunneling);
+    public MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
+        throws DecoderQueryException {
+      return MediaCodecUtil.getDecoderInfo(mimeType, requiresSecureDecoder);
     }
 
     @Override
@@ -46,13 +46,11 @@ public MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
    *
    * @param mimeType The mime type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
-   * @param requiresTunneling Whether a decoder that supports tunneling is required.
-   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder
-   *     exists.
+   * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder exists.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
-  MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder,
-      boolean requiresTunneling) throws DecoderQueryException;
+  MediaCodecInfo getDecoderInfo(String mimeType, boolean requiresSecureDecoder)
+      throws DecoderQueryException;
 
   /**
    * Selects a decoder to instantiate for audio passthrough.
diff --git a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 14ba309790..a3a2543461 100644
--- a/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -81,9 +81,8 @@ private MediaCodecUtil() {}
   /**
    * Optional call to warm the codec cache for a given mime type.
    * <p>
-   * Calling this method may speed up subsequent calls to
-   * {@link #getDecoderInfo(String, boolean, boolean)} and
-   * {@link #getDecoderInfos(String, boolean)}.
+   * Calling this method may speed up subsequent calls to {@link #getDecoderInfo(String, boolean)}
+   * and {@link #getDecoderInfos(String, boolean)}.
    *
    * @param mimeType The mime type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
@@ -115,26 +114,14 @@ public static MediaCodecInfo getPassthroughDecoderInfo() {
    * @param mimeType The mime type.
    * @param secure Whether the decoder is required to support secure decryption. Always pass false
    *     unless secure decryption really is required.
-   * @param tunneling Whether the decoder is required to support tunneling. Always pass false unless
-   *     tunneling really is required.
    * @return A {@link MediaCodecInfo} describing the decoder, or null if no suitable decoder
    *     exists.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
-  public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boolean tunneling)
+  public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure)
       throws DecoderQueryException {
     List<MediaCodecInfo> decoderInfos = getDecoderInfos(mimeType, secure);
-    if (tunneling) {
-      for (int i = 0; i < decoderInfos.size(); i++) {
-        MediaCodecInfo decoderInfo = decoderInfos.get(i);
-        if (decoderInfo.tunneling) {
-          return decoderInfo;
-        }
-      }
-      return null;
-    } else {
-      return decoderInfos.isEmpty() ? null : decoderInfos.get(0);
-    }
+    return decoderInfos.isEmpty() ? null : decoderInfos.get(0);
   }
 
   /**
@@ -305,7 +292,7 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
   public static int maxH264DecodableFrameSize() throws DecoderQueryException {
     if (maxH264DecodableFrameSize == -1) {
       int result = 0;
-      MediaCodecInfo decoderInfo = getDecoderInfo(MimeTypes.VIDEO_H264, false, false);
+      MediaCodecInfo decoderInfo = getDecoderInfo(MimeTypes.VIDEO_H264, false);
       if (decoderInfo != null) {
         for (CodecProfileLevel profileLevel : decoderInfo.getProfileLevels()) {
           result = Math.max(avcLevelToMaxFrameSize(profileLevel.level), result);
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
index a73311f16b..9137bad4fd 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoder.java
@@ -21,21 +21,12 @@
 public interface MetadataDecoder {
 
   /**
-   * Checks whether the decoder supports a given mime type.
+   * Decodes a {@link Metadata} element from the provided input buffer.
    *
-   * @param mimeType A metadata mime type.
-   * @return Whether the mime type is supported.
-   */
-  boolean canDecode(String mimeType);
-
-  /**
-   * Decodes a metadata object from the provided binary data.
-   *
-   * @param data The raw binary data from which to decode the metadata.
-   * @param size The size of the input data.
+   * @param inputBuffer The input buffer to decode.
    * @return The decoded metadata object.
    * @throws MetadataDecoderException If a problem occurred decoding the data.
    */
-  Metadata decode(byte[] data, int size) throws MetadataDecoderException;
+  Metadata decode(MetadataInputBuffer inputBuffer) throws MetadataDecoderException;
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
new file mode 100644
index 0000000000..414a8269d7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataDecoderFactory.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata;
+
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder;
+import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
+import com.google.android.exoplayer2.metadata.scte35.SpliceInfoDecoder;
+import com.google.android.exoplayer2.util.MimeTypes;
+
+/**
+ * A factory for {@link MetadataDecoder} instances.
+ */
+public interface MetadataDecoderFactory {
+
+  /**
+   * Returns whether the factory is able to instantiate a {@link MetadataDecoder} for the given
+   * {@link Format}.
+   *
+   * @param format The {@link Format}.
+   * @return Whether the factory can instantiate a suitable {@link MetadataDecoder}.
+   */
+  boolean supportsFormat(Format format);
+
+  /**
+   * Creates a {@link MetadataDecoder} for the given {@link Format}.
+   *
+   * @param format The {@link Format}.
+   * @return A new {@link MetadataDecoder}.
+   * @throws IllegalArgumentException If the {@link Format} is not supported.
+   */
+  MetadataDecoder createDecoder(Format format);
+
+  /**
+   * Default {@link MetadataDecoder} implementation.
+   * <p>
+   * The formats supported by this factory are:
+   * <ul>
+   * <li>ID3 ({@link Id3Decoder})</li>
+   * <li>EMSG ({@link EventMessageDecoder})</li>
+   * <li>SCTE-35 ({@link SpliceInfoDecoder})</li>
+   * </ul>
+   */
+  MetadataDecoderFactory DEFAULT = new MetadataDecoderFactory() {
+
+    @Override
+    public boolean supportsFormat(Format format) {
+      return getDecoderClass(format.sampleMimeType) != null;
+    }
+
+    @Override
+    public MetadataDecoder createDecoder(Format format) {
+      try {
+        Class<?> clazz = getDecoderClass(format.sampleMimeType);
+        if (clazz == null) {
+          throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
+        }
+        return clazz.asSubclass(MetadataDecoder.class).getConstructor().newInstance();
+      } catch (Exception e) {
+        throw new IllegalStateException("Unexpected error instantiating decoder", e);
+      }
+    }
+
+    private Class<?> getDecoderClass(String mimeType) {
+      if (mimeType == null) {
+        return null;
+      }
+      try {
+        switch (mimeType) {
+          case MimeTypes.APPLICATION_ID3:
+            return Class.forName("com.google.android.exoplayer2.metadata.id3.Id3Decoder");
+          case MimeTypes.APPLICATION_EMSG:
+            return Class.forName("com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder");
+          case MimeTypes.APPLICATION_SCTE35:
+            return Class.forName("com.google.android.exoplayer2.metadata.scte35.SpliceInfoDecoder");
+          default:
+            return null;
+        }
+      } catch (ClassNotFoundException e) {
+        return null;
+      }
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataInputBuffer.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataInputBuffer.java
new file mode 100644
index 0000000000..a09b565653
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataInputBuffer.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata;
+
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+
+/**
+ * A {@link DecoderInputBuffer} for a {@link MetadataDecoder}.
+ */
+public final class MetadataInputBuffer extends DecoderInputBuffer {
+
+  /**
+   * An offset that must be added to the metadata's timestamps after it's been decoded, or
+   * {@link Format#OFFSET_SAMPLE_RELATIVE} if {@link #timeUs} should be added.
+   */
+  public long subsampleOffsetUs;
+
+  public MetadataInputBuffer() {
+    super(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index ff1364610b..814238970b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -24,9 +24,8 @@
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
-import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.util.Assertions;
-import java.nio.ByteBuffer;
+import java.util.Arrays;
 
 /**
  * A renderer for metadata.
@@ -48,16 +47,23 @@
   }
 
   private static final int MSG_INVOKE_RENDERER = 0;
+  // TODO: Holding multiple pending metadata objects is temporary mitigation against
+  // https://github.com/google/ExoPlayer/issues/1874
+  // It should be removed once this issue has been addressed.
+  private static final int MAX_PENDING_METADATA_COUNT = 5;
 
-  private final MetadataDecoder metadataDecoder;
+  private final MetadataDecoderFactory decoderFactory;
   private final Output output;
   private final Handler outputHandler;
   private final FormatHolder formatHolder;
-  private final DecoderInputBuffer buffer;
+  private final MetadataInputBuffer buffer;
+  private final Metadata[] pendingMetadata;
+  private final long[] pendingMetadataTimestamps;
 
+  private int pendingMetadataIndex;
+  private int pendingMetadataCount;
+  private MetadataDecoder decoder;
   private boolean inputStreamEnded;
-  private long pendingMetadataTimestamp;
-  private Metadata pendingMetadata;
 
   /**
    * @param output The output.
@@ -66,43 +72,68 @@
    *     looper associated with the application's main thread, which can be obtained using
    *     {@link android.app.Activity#getMainLooper()}. Null may be passed if the output should be
    *     called directly on the player's internal rendering thread.
-   * @param metadataDecoder A decoder for the metadata.
    */
-  public MetadataRenderer(Output output, Looper outputLooper, MetadataDecoder metadataDecoder) {
+  public MetadataRenderer(Output output, Looper outputLooper) {
+    this(output, outputLooper, MetadataDecoderFactory.DEFAULT);
+  }
+
+  /**
+   * @param output The output.
+   * @param outputLooper The looper associated with the thread on which the output should be called.
+   *     If the output makes use of standard Android UI components, then this should normally be the
+   *     looper associated with the application's main thread, which can be obtained using
+   *     {@link android.app.Activity#getMainLooper()}. Null may be passed if the output should be
+   *     called directly on the player's internal rendering thread.
+   * @param decoderFactory A factory from which to obtain {@link MetadataDecoder} instances.
+   */
+  public MetadataRenderer(Output output, Looper outputLooper,
+      MetadataDecoderFactory decoderFactory) {
     super(C.TRACK_TYPE_METADATA);
     this.output = Assertions.checkNotNull(output);
     this.outputHandler = outputLooper == null ? null : new Handler(outputLooper, this);
-    this.metadataDecoder = Assertions.checkNotNull(metadataDecoder);
+    this.decoderFactory = Assertions.checkNotNull(decoderFactory);
     formatHolder = new FormatHolder();
-    buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+    buffer = new MetadataInputBuffer();
+    pendingMetadata = new Metadata[MAX_PENDING_METADATA_COUNT];
+    pendingMetadataTimestamps = new long[MAX_PENDING_METADATA_COUNT];
   }
 
   @Override
   public int supportsFormat(Format format) {
-    return metadataDecoder.canDecode(format.sampleMimeType) ? FORMAT_HANDLED
-        : FORMAT_UNSUPPORTED_TYPE;
+    return decoderFactory.supportsFormat(format) ? FORMAT_HANDLED : FORMAT_UNSUPPORTED_TYPE;
+  }
+
+  @Override
+  protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
+    decoder = decoderFactory.createDecoder(formats[0]);
   }
 
   @Override
   protected void onPositionReset(long positionUs, boolean joining) {
-    pendingMetadata = null;
+    flushPendingMetadata();
     inputStreamEnded = false;
   }
 
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    if (!inputStreamEnded && pendingMetadata == null) {
+    if (!inputStreamEnded && pendingMetadataCount < MAX_PENDING_METADATA_COUNT) {
       buffer.clear();
-      int result = readSource(formatHolder, buffer);
+      int result = readSource(formatHolder, buffer, false);
       if (result == C.RESULT_BUFFER_READ) {
         if (buffer.isEndOfStream()) {
           inputStreamEnded = true;
+        } else if (buffer.isDecodeOnly()) {
+          // Do nothing. Note this assumes that all metadata buffers can be decoded independently.
+          // If we ever need to support a metadata format where this is not the case, we'll need to
+          // pass the buffer to the decoder and discard the output.
         } else {
-          pendingMetadataTimestamp = buffer.timeUs;
+          buffer.subsampleOffsetUs = formatHolder.format.subsampleOffsetUs;
+          buffer.flip();
           try {
-            buffer.flip();
-            ByteBuffer bufferData = buffer.data;
-            pendingMetadata = metadataDecoder.decode(bufferData.array(), bufferData.limit());
+            int index = (pendingMetadataIndex + pendingMetadataCount) % MAX_PENDING_METADATA_COUNT;
+            pendingMetadata[index] = decoder.decode(buffer);
+            pendingMetadataTimestamps[index] = buffer.timeUs;
+            pendingMetadataCount++;
           } catch (MetadataDecoderException e) {
             throw ExoPlaybackException.createForRenderer(e, getIndex());
           }
@@ -110,15 +141,18 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       }
     }
 
-    if (pendingMetadata != null && pendingMetadataTimestamp <= positionUs) {
-      invokeRenderer(pendingMetadata);
-      pendingMetadata = null;
+    if (pendingMetadataCount > 0 && pendingMetadataTimestamps[pendingMetadataIndex] <= positionUs) {
+      invokeRenderer(pendingMetadata[pendingMetadataIndex]);
+      pendingMetadata[pendingMetadataIndex] = null;
+      pendingMetadataIndex = (pendingMetadataIndex + 1) % MAX_PENDING_METADATA_COUNT;
+      pendingMetadataCount--;
     }
   }
 
   @Override
   protected void onDisabled() {
-    pendingMetadata = null;
+    flushPendingMetadata();
+    decoder = null;
     super.onDisabled();
   }
 
@@ -140,6 +174,12 @@ private void invokeRenderer(Metadata metadata) {
     }
   }
 
+  private void flushPendingMetadata() {
+    Arrays.fill(pendingMetadata, null);
+    pendingMetadataIndex = 0;
+    pendingMetadataCount = 0;
+  }
+
   @SuppressWarnings("unchecked")
   @Override
   public boolean handleMessage(Message msg) {
@@ -147,8 +187,10 @@ public boolean handleMessage(Message msg) {
       case MSG_INVOKE_RENDERER:
         invokeRendererInternal((Metadata) msg.obj);
         return true;
+      default:
+        // Should never happen.
+        throw new IllegalStateException();
     }
-    return false;
   }
 
   private void invokeRendererInternal(Metadata metadata) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
new file mode 100644
index 0000000000..9d6d0af60c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * An Event Message (emsg) as defined in ISO 23009-1.
+ */
+public final class EventMessage implements Metadata.Entry {
+
+  /**
+   * The message scheme.
+   */
+  public final String schemeIdUri;
+
+  /**
+   * The value for the event.
+   */
+  public final String value;
+
+  /**
+   * The duration of the event in milliseconds.
+   */
+  public final long durationMs;
+
+  /**
+   * The instance identifier.
+   */
+  public final long id;
+
+  /**
+   * The body of the message.
+   */
+  public final byte[] messageData;
+
+  // Lazily initialized hashcode.
+  private int hashCode;
+
+  /**
+   *
+   * @param schemeIdUri The message scheme.
+   * @param value The value for the event.
+   * @param durationMs The duration of the event in milliseconds.
+   * @param id The instance identifier.
+   * @param messageData The body of the message.
+   */
+  public EventMessage(String schemeIdUri, String value, long durationMs, long id,
+      byte[] messageData) {
+    this.schemeIdUri = schemeIdUri;
+    this.value = value;
+    this.durationMs = durationMs;
+    this.id = id;
+    this.messageData = messageData;
+  }
+
+  /* package */ EventMessage(Parcel in) {
+    schemeIdUri = in.readString();
+    value = in.readString();
+    durationMs = in.readLong();
+    id = in.readLong();
+    messageData = in.createByteArray();
+  }
+
+  @Override
+  public int hashCode() {
+    if (hashCode == 0) {
+      int result = 17;
+      result = 31 * result + (schemeIdUri != null ? schemeIdUri.hashCode() : 0);
+      result = 31 * result + (value != null ? value.hashCode() : 0);
+      result = 31 * result + (int) (durationMs ^ (durationMs >>> 32));
+      result = 31 * result + (int) (id ^ (id >>> 32));
+      result = 31 * result + Arrays.hashCode(messageData);
+      hashCode = result;
+    }
+    return hashCode;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    EventMessage other = (EventMessage) obj;
+    return durationMs == other.durationMs && id == other.id
+        && Util.areEqual(schemeIdUri, other.schemeIdUri) && Util.areEqual(value, other.value)
+        && Arrays.equals(messageData, other.messageData);
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(schemeIdUri);
+    dest.writeString(value);
+    dest.writeLong(durationMs);
+    dest.writeLong(id);
+    dest.writeByteArray(messageData);
+  }
+
+  public static final Parcelable.Creator<EventMessage> CREATOR =
+      new Parcelable.Creator<EventMessage>() {
+
+    @Override
+    public EventMessage createFromParcel(Parcel in) {
+      return new EventMessage(in);
+    }
+
+    @Override
+    public EventMessage[] newArray(int size) {
+      return new EventMessage[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
new file mode 100644
index 0000000000..fd6996aa80
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataDecoder;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Decodes Event Message (emsg) atoms, as defined in ISO 23009-1.
+ * <p>
+ * Atom data should be provided to the decoder without the full atom header (i.e. starting from the
+ * first byte of the scheme_id_uri field).
+ */
+public final class EventMessageDecoder implements MetadataDecoder {
+
+  @Override
+  public Metadata decode(MetadataInputBuffer inputBuffer) {
+    ByteBuffer buffer = inputBuffer.data;
+    byte[] data = buffer.array();
+    int size = buffer.limit();
+    ParsableByteArray emsgData = new ParsableByteArray(data, size);
+    String schemeIdUri = emsgData.readNullTerminatedString();
+    String value = emsgData.readNullTerminatedString();
+    long timescale = emsgData.readUnsignedInt();
+    emsgData.skipBytes(4); // presentation_time_delta
+    long durationMs = (emsgData.readUnsignedInt() * 1000) / timescale;
+    long id = emsgData.readUnsignedInt();
+    byte[] messageData = Arrays.copyOfRange(data, emsgData.getPosition(), size);
+    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData));
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
new file mode 100644
index 0000000000..c82f982aa7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterFrame.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * Chapter information ID3 frame.
+ */
+public final class ChapterFrame extends Id3Frame {
+
+  public static final String ID = "CHAP";
+
+  public final String chapterId;
+  public final int startTimeMs;
+  public final int endTimeMs;
+  /**
+   * The byte offset of the start of the chapter, or {@link C#POSITION_UNSET} if not set.
+   */
+  public final long startOffset;
+  /**
+   * The byte offset of the end of the chapter, or {@link C#POSITION_UNSET} if not set.
+   */
+  public final long endOffset;
+  private final Id3Frame[] subFrames;
+
+  public ChapterFrame(String chapterId, int startTimeMs, int endTimeMs, long startOffset,
+      long endOffset, Id3Frame[] subFrames) {
+    super(ID);
+    this.chapterId = chapterId;
+    this.startTimeMs = startTimeMs;
+    this.endTimeMs = endTimeMs;
+    this.startOffset = startOffset;
+    this.endOffset = endOffset;
+    this.subFrames = subFrames;
+  }
+
+  /* package */ ChapterFrame(Parcel in) {
+    super(ID);
+    this.chapterId = in.readString();
+    this.startTimeMs = in.readInt();
+    this.endTimeMs = in.readInt();
+    this.startOffset = in.readLong();
+    this.endOffset = in.readLong();
+    int subFrameCount = in.readInt();
+    subFrames = new Id3Frame[subFrameCount];
+    for (int i = 0; i < subFrameCount; i++) {
+      subFrames[i] = in.readParcelable(Id3Frame.class.getClassLoader());
+    }
+  }
+
+  /**
+   * Returns the number of sub-frames.
+   */
+  public int getSubFrameCount() {
+    return subFrames.length;
+  }
+
+  /**
+   * Returns the sub-frame at {@code index}.
+   */
+  public Id3Frame getSubFrame(int index) {
+    return subFrames[index];
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ChapterFrame other = (ChapterFrame) obj;
+    return startTimeMs == other.startTimeMs
+        && endTimeMs == other.endTimeMs
+        && startOffset == other.startOffset
+        && endOffset == other.endOffset
+        && Util.areEqual(chapterId, other.chapterId)
+        && Arrays.equals(subFrames, other.subFrames);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + startTimeMs;
+    result = 31 * result + endTimeMs;
+    result = 31 * result + (int) startOffset;
+    result = 31 * result + (int) endOffset;
+    result = 31 * result + (chapterId != null ? chapterId.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(chapterId);
+    dest.writeInt(startTimeMs);
+    dest.writeInt(endTimeMs);
+    dest.writeLong(startOffset);
+    dest.writeLong(endOffset);
+    dest.writeInt(subFrames.length);
+    for (Id3Frame subFrame : subFrames) {
+      dest.writeParcelable(subFrame, 0);
+    }
+  }
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  public static final Creator<ChapterFrame> CREATOR = new Creator<ChapterFrame>() {
+
+    @Override
+    public ChapterFrame createFromParcel(Parcel in) {
+      return new ChapterFrame(in);
+    }
+
+    @Override
+    public ChapterFrame[] newArray(int size) {
+      return new ChapterFrame[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
new file mode 100644
index 0000000000..d71d0863c7
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrame.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.id3;
+
+import android.os.Parcel;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+
+/**
+ * Chapter table of contents ID3 frame.
+ */
+public final class ChapterTocFrame extends Id3Frame {
+
+  public static final String ID = "CTOC";
+
+  public final String elementId;
+  public final boolean isRoot;
+  public final boolean isOrdered;
+  public final String[] children;
+  private final Id3Frame[] subFrames;
+
+  public ChapterTocFrame(String elementId, boolean isRoot, boolean isOrdered, String[] children,
+      Id3Frame[] subFrames) {
+    super(ID);
+    this.elementId = elementId;
+    this.isRoot = isRoot;
+    this.isOrdered = isOrdered;
+    this.children = children;
+    this.subFrames = subFrames;
+  }
+
+  /* package */ ChapterTocFrame(Parcel in) {
+    super(ID);
+    this.elementId = in.readString();
+    this.isRoot = in.readByte() != 0;
+    this.isOrdered = in.readByte() != 0;
+    this.children = in.createStringArray();
+    int subFrameCount = in.readInt();
+    subFrames = new Id3Frame[subFrameCount];
+    for (int i = 0; i < subFrameCount; i++) {
+      subFrames[i] = in.readParcelable(Id3Frame.class.getClassLoader());
+    }
+  }
+
+  /**
+   * Returns the number of sub-frames.
+   */
+  public int getSubFrameCount() {
+    return subFrames.length;
+  }
+
+  /**
+   * Returns the sub-frame at {@code index}.
+   */
+  public Id3Frame getSubFrame(int index) {
+    return subFrames[index];
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    ChapterTocFrame other = (ChapterTocFrame) obj;
+    return isRoot == other.isRoot
+        && isOrdered == other.isOrdered
+        && Util.areEqual(elementId, other.elementId)
+        && Arrays.equals(children, other.children)
+        && Arrays.equals(subFrames, other.subFrames);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = 17;
+    result = 31 * result + (isRoot ? 1 : 0);
+    result = 31 * result + (isOrdered ? 1 : 0);
+    result = 31 * result + (elementId != null ? elementId.hashCode() : 0);
+    return result;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(elementId);
+    dest.writeByte((byte) (isRoot ? 1 : 0));
+    dest.writeByte((byte) (isOrdered ? 1 : 0));
+    dest.writeStringArray(children);
+    dest.writeInt(subFrames.length);
+    for (int i = 0; i < subFrames.length; i++) {
+      dest.writeParcelable(subFrames[i], 0);
+    }
+  }
+
+  public static final Creator<ChapterTocFrame> CREATOR = new Creator<ChapterTocFrame>() {
+
+    @Override
+    public ChapterTocFrame createFromParcel(Parcel in) {
+      return new ChapterTocFrame(in);
+    }
+
+    @Override
+    public ChapterTocFrame[] newArray(int size) {
+      return new ChapterTocFrame[size];
+    }
+
+  };
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index d27c4f06e9..cbe6c65030 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -16,12 +16,14 @@
 package com.google.android.exoplayer2.metadata.id3;
 
 import android.util.Log;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
-import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.UnsupportedEncodingException;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -32,6 +34,25 @@
  */
 public final class Id3Decoder implements MetadataDecoder {
 
+  /**
+   * A predicate for determining whether individual frames should be decoded.
+   */
+  public interface FramePredicate {
+
+    /**
+     * Returns whether a frame with the specified parameters should be decoded.
+     *
+     * @param majorVersion The major version of the ID3 tag.
+     * @param id0 The first byte of the frame ID.
+     * @param id1 The second byte of the frame ID.
+     * @param id2 The third byte of the frame ID.
+     * @param id3 The fourth byte of the frame ID.
+     * @return Whether the frame should be decoded.
+     */
+    boolean evaluate(int majorVersion, int id0, int id1, int id2, int id3);
+
+  }
+
   private static final String TAG = "Id3Decoder";
 
   /**
@@ -48,12 +69,32 @@
   private static final int ID3_TEXT_ENCODING_UTF_16BE = 2;
   private static final int ID3_TEXT_ENCODING_UTF_8 = 3;
 
-  @Override
-  public boolean canDecode(String mimeType) {
-    return mimeType.equals(MimeTypes.APPLICATION_ID3);
+  private final FramePredicate framePredicate;
+
+  public Id3Decoder() {
+    this(null);
+  }
+
+  /**
+   * @param framePredicate Determines which frames are decoded. May be null to decode all frames.
+   */
+  public Id3Decoder(FramePredicate framePredicate) {
+    this.framePredicate = framePredicate;
   }
 
   @Override
+  public Metadata decode(MetadataInputBuffer inputBuffer) {
+    ByteBuffer buffer = inputBuffer.data;
+    return decode(buffer.array(), buffer.limit());
+  }
+
+  /**
+   * Decodes ID3 tags.
+   *
+   * @param data The bytes to decode ID3 tags from.
+   * @param size Amount of bytes in {@code data} to read.
+   * @return A {@link Metadata} object containing the decoded ID3 tags.
+   */
   public Metadata decode(byte[] data, int size) {
     List<Id3Frame> id3Frames = new ArrayList<>();
     ParsableByteArray id3Data = new ParsableByteArray(data, size);
@@ -84,7 +125,8 @@ public Metadata decode(byte[] data, int size) {
 
     int frameHeaderSize = id3Header.majorVersion == 2 ? 6 : 10;
     while (id3Data.bytesLeft() >= frameHeaderSize) {
-      Id3Frame frame = decodeFrame(id3Header.majorVersion, id3Data, unsignedIntFrameSizeHack);
+      Id3Frame frame = decodeFrame(id3Header.majorVersion, id3Data, unsignedIntFrameSizeHack,
+          frameHeaderSize, framePredicate);
       if (frame != null) {
         id3Frames.add(frame);
       }
@@ -190,7 +232,7 @@ private static boolean validateV4Frames(ParsableByteArray id3Data,
   }
 
   private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
-      boolean unsignedIntFrameSizeHack)  {
+      boolean unsignedIntFrameSizeHack, int frameHeaderSize, FramePredicate framePredicate) {
     int frameId0 = id3Data.readUnsignedByte();
     int frameId1 = id3Data.readUnsignedByte();
     int frameId2 = id3Data.readUnsignedByte();
@@ -224,6 +266,13 @@ private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
       return null;
     }
 
+    if (framePredicate != null
+        && !framePredicate.evaluate(majorVersion, frameId0, frameId1, frameId2, frameId3)) {
+      // Filtered by the predicate.
+      id3Data.setPosition(nextFramePosition);
+      return null;
+    }
+
     // Frame flags.
     boolean isCompressed = false;
     boolean isEncrypted = false;
@@ -266,6 +315,19 @@ private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
       if (frameId0 == 'T' && frameId1 == 'X' && frameId2 == 'X'
           && (majorVersion == 2 || frameId3 == 'X')) {
         frame = decodeTxxxFrame(id3Data, frameSize);
+      } else if (frameId0 == 'T') {
+        String id = majorVersion == 2
+            ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
+            : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+        frame = decodeTextInformationFrame(id3Data, frameSize, id);
+      } else if (frameId0 == 'W' && frameId1 == 'X' && frameId2 == 'X'
+          && (majorVersion == 2 || frameId3 == 'X')) {
+        frame = decodeWxxxFrame(id3Data, frameSize);
+      } else if (frameId0 == 'W') {
+        String id = majorVersion == 2
+            ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
+            : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
+        frame = decodeUrlLinkFrame(id3Data, frameSize, id);
       } else if (frameId0 == 'P' && frameId1 == 'R' && frameId2 == 'I' && frameId3 == 'V') {
         frame = decodePrivFrame(id3Data, frameSize);
       } else if (frameId0 == 'G' && frameId1 == 'E' && frameId2 == 'O'
@@ -274,14 +336,15 @@ private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
       } else if (majorVersion == 2 ? (frameId0 == 'P' && frameId1 == 'I' && frameId2 == 'C')
           : (frameId0 == 'A' && frameId1 == 'P' && frameId2 == 'I' && frameId3 == 'C')) {
         frame = decodeApicFrame(id3Data, frameSize, majorVersion);
-      } else if (frameId0 == 'T') {
-        String id = majorVersion == 2
-            ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
-            : String.format(Locale.US, "%c%c%c%c", frameId0, frameId1, frameId2, frameId3);
-        frame = decodeTextInformationFrame(id3Data, frameSize, id);
       } else if (frameId0 == 'C' && frameId1 == 'O' && frameId2 == 'M'
           && (frameId3 == 'M' || majorVersion == 2)) {
         frame = decodeCommentFrame(id3Data, frameSize);
+      } else if (frameId0 == 'C' && frameId1 == 'H' && frameId2 == 'A' && frameId3 == 'P') {
+        frame = decodeChapterFrame(id3Data, frameSize, majorVersion, unsignedIntFrameSizeHack,
+            frameHeaderSize, framePredicate);
+      } else if (frameId0 == 'C' && frameId1 == 'T' && frameId2 == 'O' && frameId3 == 'C') {
+        frame = decodeChapterTOCFrame(id3Data, frameSize, majorVersion, unsignedIntFrameSizeHack,
+            frameHeaderSize, framePredicate);
       } else {
         String id = majorVersion == 2
             ? String.format(Locale.US, "%c%c%c", frameId0, frameId1, frameId2)
@@ -297,7 +360,7 @@ private static Id3Frame decodeFrame(int majorVersion, ParsableByteArray id3Data,
     }
   }
 
-  private static TxxxFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSize)
+  private static TextInformationFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSize)
       throws UnsupportedEncodingException {
     int encoding = id3Data.readUnsignedByte();
     String charset = getCharsetName(encoding);
@@ -308,15 +371,83 @@ private static TxxxFrame decodeTxxxFrame(ParsableByteArray id3Data, int frameSiz
     int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
+    String value;
     int valueStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
-    String value = new String(data, valueStartIndex, valueEndIndex - valueStartIndex, charset);
+    if (valueStartIndex < data.length) {
+      int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
+      value = new String(data, valueStartIndex, valueEndIndex - valueStartIndex, charset);
+    } else {
+      value = "";
+    }
+
+    return new TextInformationFrame("TXXX", description, value);
+  }
+
+  private static TextInformationFrame decodeTextInformationFrame(ParsableByteArray id3Data,
+      int frameSize, String id) throws UnsupportedEncodingException {
+    if (frameSize <= 1) {
+      // Frame is empty or contains only the text encoding byte.
+      return new TextInformationFrame(id, null, "");
+    }
+
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int valueEndIndex = indexOfEos(data, 0, encoding);
+    String value = new String(data, 0, valueEndIndex, charset);
 
-    return new TxxxFrame(description, value);
+    return new TextInformationFrame(id, null, value);
+  }
+
+  private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frameSize)
+      throws UnsupportedEncodingException {
+    int encoding = id3Data.readUnsignedByte();
+    String charset = getCharsetName(encoding);
+
+    byte[] data = new byte[frameSize - 1];
+    id3Data.readBytes(data, 0, frameSize - 1);
+
+    int descriptionEndIndex = indexOfEos(data, 0, encoding);
+    String description = new String(data, 0, descriptionEndIndex, charset);
+
+    String url;
+    int urlStartIndex = descriptionEndIndex + delimiterLength(encoding);
+    if (urlStartIndex < data.length) {
+      int urlEndIndex = indexOfZeroByte(data, urlStartIndex);
+      url = new String(data, urlStartIndex, urlEndIndex - urlStartIndex, "ISO-8859-1");
+    } else {
+      url = "";
+    }
+
+    return new UrlLinkFrame("WXXX", description, url);
+  }
+
+  private static UrlLinkFrame decodeUrlLinkFrame(ParsableByteArray id3Data, int frameSize,
+      String id) throws UnsupportedEncodingException {
+    if (frameSize == 0) {
+      // Frame is empty.
+      return new UrlLinkFrame(id, null, "");
+    }
+
+    byte[] data = new byte[frameSize];
+    id3Data.readBytes(data, 0, frameSize);
+
+    int urlEndIndex = indexOfZeroByte(data, 0);
+    String url = new String(data, 0, urlEndIndex, "ISO-8859-1");
+
+    return new UrlLinkFrame(id, null, url);
   }
 
   private static PrivFrame decodePrivFrame(ParsableByteArray id3Data, int frameSize)
       throws UnsupportedEncodingException {
+    if (frameSize == 0) {
+      // Frame is empty.
+      return new PrivFrame("", new byte[0]);
+    }
+
     byte[] data = new byte[frameSize];
     id3Data.readBytes(data, 0, frameSize);
 
@@ -408,25 +539,88 @@ private static CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int fr
     int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
+    String text;
     int textStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    int textEndIndex = indexOfEos(data, textStartIndex, encoding);
-    String text = new String(data, textStartIndex, textEndIndex - textStartIndex, charset);
+    if (textStartIndex < data.length) {
+      int textEndIndex = indexOfEos(data, textStartIndex, encoding);
+      text = new String(data, textStartIndex, textEndIndex - textStartIndex, charset);
+    } else {
+      text = "";
+    }
 
     return new CommentFrame(language, description, text);
   }
 
-  private static TextInformationFrame decodeTextInformationFrame(ParsableByteArray id3Data,
-      int frameSize, String id) throws UnsupportedEncodingException {
-    int encoding = id3Data.readUnsignedByte();
-    String charset = getCharsetName(encoding);
+  private static ChapterFrame decodeChapterFrame(ParsableByteArray id3Data, int frameSize,
+      int majorVersion, boolean unsignedIntFrameSizeHack, int frameHeaderSize,
+      FramePredicate framePredicate) throws UnsupportedEncodingException {
+    int framePosition = id3Data.getPosition();
+    int chapterIdEndIndex = indexOfZeroByte(id3Data.data, framePosition);
+    String chapterId = new String(id3Data.data, framePosition, chapterIdEndIndex - framePosition,
+        "ISO-8859-1");
+    id3Data.setPosition(chapterIdEndIndex + 1);
+
+    int startTime = id3Data.readInt();
+    int endTime = id3Data.readInt();
+    long startOffset = id3Data.readUnsignedInt();
+    if (startOffset == 0xFFFFFFFFL) {
+      startOffset = C.POSITION_UNSET;
+    }
+    long endOffset = id3Data.readUnsignedInt();
+    if (endOffset == 0xFFFFFFFFL) {
+      endOffset = C.POSITION_UNSET;
+    }
 
-    byte[] data = new byte[frameSize - 1];
-    id3Data.readBytes(data, 0, frameSize - 1);
+    ArrayList<Id3Frame> subFrames = new ArrayList<>();
+    int limit = framePosition + frameSize;
+    while (id3Data.getPosition() < limit) {
+      Id3Frame frame = decodeFrame(majorVersion, id3Data, unsignedIntFrameSizeHack,
+          frameHeaderSize, framePredicate);
+      if (frame != null) {
+        subFrames.add(frame);
+      }
+    }
 
-    int descriptionEndIndex = indexOfEos(data, 0, encoding);
-    String description = new String(data, 0, descriptionEndIndex, charset);
+    Id3Frame[] subFrameArray = new Id3Frame[subFrames.size()];
+    subFrames.toArray(subFrameArray);
+    return new ChapterFrame(chapterId, startTime, endTime, startOffset, endOffset, subFrameArray);
+  }
+
+  private static ChapterTocFrame decodeChapterTOCFrame(ParsableByteArray id3Data, int frameSize,
+      int majorVersion, boolean unsignedIntFrameSizeHack, int frameHeaderSize,
+      FramePredicate framePredicate) throws UnsupportedEncodingException {
+    int framePosition = id3Data.getPosition();
+    int elementIdEndIndex = indexOfZeroByte(id3Data.data, framePosition);
+    String elementId = new String(id3Data.data, framePosition, elementIdEndIndex - framePosition,
+        "ISO-8859-1");
+    id3Data.setPosition(elementIdEndIndex + 1);
+
+    int ctocFlags = id3Data.readUnsignedByte();
+    boolean isRoot = (ctocFlags & 0x0002) != 0;
+    boolean isOrdered = (ctocFlags & 0x0001) != 0;
+
+    int childCount = id3Data.readUnsignedByte();
+    String[] children = new String[childCount];
+    for (int i = 0; i < childCount; i++) {
+      int startIndex = id3Data.getPosition();
+      int endIndex = indexOfZeroByte(id3Data.data, startIndex);
+      children[i] = new String(id3Data.data, startIndex, endIndex - startIndex, "ISO-8859-1");
+      id3Data.setPosition(endIndex + 1);
+    }
+
+    ArrayList<Id3Frame> subFrames = new ArrayList<>();
+    int limit = framePosition + frameSize;
+    while (id3Data.getPosition() < limit) {
+      Id3Frame frame = decodeFrame(majorVersion, id3Data, unsignedIntFrameSizeHack,
+          frameHeaderSize, framePredicate);
+      if (frame != null) {
+        subFrames.add(frame);
+      }
+    }
 
-    return new TextInformationFrame(id, description);
+    Id3Frame[] subFrameArray = new Id3Frame[subFrames.size()];
+    subFrames.toArray(subFrameArray);
+    return new ChapterTocFrame(elementId, isRoot, isOrdered, children, subFrameArray);
   }
 
   private static BinaryFrame decodeBinaryFrame(ParsableByteArray id3Data, int frameSize,
@@ -458,6 +652,7 @@ private static int removeUnsynchronization(ParsableByteArray data, int length) {
 
   /**
    * Maps encoding byte from ID3v2 frame to a Charset.
+   *
    * @param encodingByte The value of encoding byte from ID3v2 frame.
    * @return Charset name.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
index b8c061fd0a..6221062e33 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TextInformationFrame.java
@@ -20,20 +20,23 @@
 import com.google.android.exoplayer2.util.Util;
 
 /**
- * Text information ("T000" - "TZZZ", excluding "TXXX") ID3 frame.
+ * Text information ID3 frame.
  */
 public final class TextInformationFrame extends Id3Frame {
 
   public final String description;
+  public final String value;
 
-  public TextInformationFrame(String id, String description) {
+  public TextInformationFrame(String id, String description, String value) {
     super(id);
     this.description = description;
+    this.value = value;
   }
 
   /* package */ TextInformationFrame(Parcel in) {
     super(in.readString());
     description = in.readString();
+    value = in.readString();
   }
 
   @Override
@@ -45,7 +48,8 @@ public boolean equals(Object obj) {
       return false;
     }
     TextInformationFrame other = (TextInformationFrame) obj;
-    return id.equals(other.id) && Util.areEqual(description, other.description);
+    return id.equals(other.id) && Util.areEqual(description, other.description)
+        && Util.areEqual(value, other.value);
   }
 
   @Override
@@ -53,6 +57,7 @@ public int hashCode() {
     int result = 17;
     result = 31 * result + id.hashCode();
     result = 31 * result + (description != null ? description.hashCode() : 0);
+    result = 31 * result + (value != null ? value.hashCode() : 0);
     return result;
   }
 
@@ -60,6 +65,7 @@ public int hashCode() {
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeString(id);
     dest.writeString(description);
+    dest.writeString(value);
   }
 
   public static final Parcelable.Creator<TextInformationFrame> CREATOR =
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TxxxFrame.java b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
similarity index 55%
rename from library/src/main/java/com/google/android/exoplayer2/metadata/id3/TxxxFrame.java
rename to library/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
index 5c24e70ef4..2148b921e1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/id3/TxxxFrame.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/id3/UrlLinkFrame.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2017 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,25 +20,23 @@
 import com.google.android.exoplayer2.util.Util;
 
 /**
- * TXXX (User defined text information) ID3 frame.
+ * Url link ID3 frame.
  */
-public final class TxxxFrame extends Id3Frame {
-
-  public static final String ID = "TXXX";
+public final class UrlLinkFrame extends Id3Frame {
 
   public final String description;
-  public final String value;
+  public final String url;
 
-  public TxxxFrame(String description, String value) {
-    super(ID);
+  public UrlLinkFrame(String id, String description, String url) {
+    super(id);
     this.description = description;
-    this.value = value;
+    this.url = url;
   }
 
-  /* package */ TxxxFrame(Parcel in) {
-    super(ID);
+  /* package */ UrlLinkFrame(Parcel in) {
+    super(in.readString());
     description = in.readString();
-    value = in.readString();
+    url = in.readString();
   }
 
   @Override
@@ -49,36 +47,40 @@ public boolean equals(Object obj) {
     if (obj == null || getClass() != obj.getClass()) {
       return false;
     }
-    TxxxFrame other = (TxxxFrame) obj;
-    return Util.areEqual(description, other.description) && Util.areEqual(value, other.value);
+    UrlLinkFrame other = (UrlLinkFrame) obj;
+    return id.equals(other.id) && Util.areEqual(description, other.description)
+        && Util.areEqual(url, other.url);
   }
 
   @Override
   public int hashCode() {
     int result = 17;
+    result = 31 * result + id.hashCode();
     result = 31 * result + (description != null ? description.hashCode() : 0);
-    result = 31 * result + (value != null ? value.hashCode() : 0);
+    result = 31 * result + (url != null ? url.hashCode() : 0);
     return result;
   }
 
   @Override
   public void writeToParcel(Parcel dest, int flags) {
+    dest.writeString(id);
     dest.writeString(description);
-    dest.writeString(value);
+    dest.writeString(url);
   }
 
-  public static final Parcelable.Creator<TxxxFrame> CREATOR = new Parcelable.Creator<TxxxFrame>() {
+  public static final Parcelable.Creator<UrlLinkFrame> CREATOR =
+      new Parcelable.Creator<UrlLinkFrame>() {
 
-    @Override
-    public TxxxFrame createFromParcel(Parcel in) {
-      return new TxxxFrame(in);
-    }
+        @Override
+        public UrlLinkFrame createFromParcel(Parcel in) {
+          return new UrlLinkFrame(in);
+        }
 
-    @Override
-    public TxxxFrame[] newArray(int size) {
-      return new TxxxFrame[size];
-    }
+        @Override
+        public UrlLinkFrame[] newArray(int size) {
+          return new UrlLinkFrame[size];
+        }
 
-  };
+      };
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
index f75a1b46a4..beb4cb9b88 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/PrivateCommand.java
@@ -26,7 +26,6 @@
 
   public final long ptsAdjustment;
   public final long identifier;
-
   public final byte[] commandBytes;
 
   private PrivateCommand(long identifier, byte[] commandBytes, long ptsAdjustment) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
index 5af0f25481..4050daa1cb 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoder.java
@@ -15,13 +15,14 @@
  */
 package com.google.android.exoplayer2.metadata.scte35;
 
-import android.text.TextUtils;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataDecoderException;
-import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
+import java.nio.ByteBuffer;
 
 /**
  * Decodes splice info sections and produces splice commands.
@@ -37,18 +38,25 @@
   private final ParsableByteArray sectionData;
   private final ParsableBitArray sectionHeader;
 
+  private TimestampAdjuster timestampAdjuster;
+
   public SpliceInfoDecoder() {
     sectionData = new ParsableByteArray();
     sectionHeader = new ParsableBitArray();
   }
 
   @Override
-  public boolean canDecode(String mimeType) {
-    return TextUtils.equals(mimeType, MimeTypes.APPLICATION_SCTE35);
-  }
+  public Metadata decode(MetadataInputBuffer inputBuffer) throws MetadataDecoderException {
+    // Internal timestamps adjustment.
+    if (timestampAdjuster == null
+        || inputBuffer.subsampleOffsetUs != timestampAdjuster.getTimestampOffsetUs()) {
+      timestampAdjuster = new TimestampAdjuster(inputBuffer.timeUs);
+      timestampAdjuster.adjustSampleTimestamp(inputBuffer.timeUs - inputBuffer.subsampleOffsetUs);
+    }
 
-  @Override
-  public Metadata decode(byte[] data, int size) throws MetadataDecoderException {
+    ByteBuffer buffer = inputBuffer.data;
+    byte[] data = buffer.array();
+    int size = buffer.limit();
     sectionData.reset(data, size);
     sectionHeader.reset(data, size);
     // table_id(8), section_syntax_indicator(1), private_indicator(1), reserved(2),
@@ -71,14 +79,18 @@ public Metadata decode(byte[] data, int size) throws MetadataDecoderException {
         command = SpliceScheduleCommand.parseFromSection(sectionData);
         break;
       case TYPE_SPLICE_INSERT:
-        command = SpliceInsertCommand.parseFromSection(sectionData, ptsAdjustment);
+        command = SpliceInsertCommand.parseFromSection(sectionData, ptsAdjustment,
+            timestampAdjuster);
         break;
       case TYPE_TIME_SIGNAL:
-        command = TimeSignalCommand.parseFromSection(sectionData, ptsAdjustment);
+        command = TimeSignalCommand.parseFromSection(sectionData, ptsAdjustment, timestampAdjuster);
         break;
       case TYPE_PRIVATE_COMMAND:
         command = PrivateCommand.parseFromSection(sectionData, spliceCommandLength, ptsAdjustment);
         break;
+      default:
+        // Do nothing.
+        break;
     }
     return command == null ? new Metadata() : new Metadata(command);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
index 1e025aeb35..7ce8b47e2a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/SpliceInsertCommand.java
@@ -19,6 +19,7 @@
 import android.os.Parcelable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -34,6 +35,7 @@
   public final boolean programSpliceFlag;
   public final boolean spliceImmediateFlag;
   public final long programSplicePts;
+  public final long programSplicePlaybackPositionUs;
   public final List<ComponentSplice> componentSpliceList;
   public final boolean autoReturn;
   public final long breakDuration;
@@ -43,14 +45,16 @@
 
   private SpliceInsertCommand(long spliceEventId, boolean spliceEventCancelIndicator,
       boolean outOfNetworkIndicator, boolean programSpliceFlag, boolean spliceImmediateFlag,
-      long programSplicePts, List<ComponentSplice> componentSpliceList, boolean autoReturn,
-      long breakDuration, int uniqueProgramId, int availNum, int availsExpected) {
+      long programSplicePts, long programSplicePlaybackPositionUs,
+      List<ComponentSplice> componentSpliceList, boolean autoReturn, long breakDuration,
+      int uniqueProgramId, int availNum, int availsExpected) {
     this.spliceEventId = spliceEventId;
     this.spliceEventCancelIndicator = spliceEventCancelIndicator;
     this.outOfNetworkIndicator = outOfNetworkIndicator;
     this.programSpliceFlag = programSpliceFlag;
     this.spliceImmediateFlag = spliceImmediateFlag;
     this.programSplicePts = programSplicePts;
+    this.programSplicePlaybackPositionUs = programSplicePlaybackPositionUs;
     this.componentSpliceList = Collections.unmodifiableList(componentSpliceList);
     this.autoReturn = autoReturn;
     this.breakDuration = breakDuration;
@@ -66,6 +70,7 @@ private SpliceInsertCommand(Parcel in) {
     programSpliceFlag = in.readByte() == 1;
     spliceImmediateFlag = in.readByte() == 1;
     programSplicePts = in.readLong();
+    programSplicePlaybackPositionUs = in.readLong();
     int componentSpliceListSize = in.readInt();
     List<ComponentSplice> componentSpliceList = new ArrayList<>(componentSpliceListSize);
     for (int i = 0; i < componentSpliceListSize; i++) {
@@ -80,7 +85,7 @@ private SpliceInsertCommand(Parcel in) {
   }
 
   /* package */ static SpliceInsertCommand parseFromSection(ParsableByteArray sectionData,
-      long ptsAdjustment) {
+      long ptsAdjustment, TimestampAdjuster timestampAdjuster) {
     long spliceEventId = sectionData.readUnsignedInt();
     // splice_event_cancel_indicator(1), reserved(7).
     boolean spliceEventCancelIndicator = (sectionData.readUnsignedByte() & 0x80) != 0;
@@ -88,7 +93,7 @@ private SpliceInsertCommand(Parcel in) {
     boolean programSpliceFlag = false;
     boolean spliceImmediateFlag = false;
     long programSplicePts = C.TIME_UNSET;
-    ArrayList<ComponentSplice> componentSplices = new ArrayList<>();
+    List<ComponentSplice> componentSplices = Collections.emptyList();
     int uniqueProgramId = 0;
     int availNum = 0;
     int availsExpected = 0;
@@ -112,7 +117,8 @@ private SpliceInsertCommand(Parcel in) {
           if (!spliceImmediateFlag) {
             componentSplicePts = TimeSignalCommand.parseSpliceTime(sectionData, ptsAdjustment);
           }
-          componentSplices.add(new ComponentSplice(componentTag, componentSplicePts));
+          componentSplices.add(new ComponentSplice(componentTag, componentSplicePts,
+              timestampAdjuster.adjustTsTimestamp(componentSplicePts)));
         }
       }
       if (durationFlag) {
@@ -125,7 +131,8 @@ private SpliceInsertCommand(Parcel in) {
       availsExpected = sectionData.readUnsignedByte();
     }
     return new SpliceInsertCommand(spliceEventId, spliceEventCancelIndicator, outOfNetworkIndicator,
-        programSpliceFlag, spliceImmediateFlag, programSplicePts, componentSplices, autoReturn,
+        programSpliceFlag, spliceImmediateFlag, programSplicePts,
+        timestampAdjuster.adjustTsTimestamp(programSplicePts), componentSplices, autoReturn,
         duration, uniqueProgramId, availNum, availsExpected);
   }
 
@@ -136,19 +143,23 @@ private SpliceInsertCommand(Parcel in) {
 
     public final int componentTag;
     public final long componentSplicePts;
+    public final long componentSplicePlaybackPositionUs;
 
-    private ComponentSplice(int componentTag, long componentSplicePts) {
+    private ComponentSplice(int componentTag, long componentSplicePts,
+        long componentSplicePlaybackPositionUs) {
       this.componentTag = componentTag;
       this.componentSplicePts = componentSplicePts;
+      this.componentSplicePlaybackPositionUs = componentSplicePlaybackPositionUs;
     }
 
     public void writeToParcel(Parcel dest) {
       dest.writeInt(componentTag);
       dest.writeLong(componentSplicePts);
+      dest.writeLong(componentSplicePlaybackPositionUs);
     }
 
     public static ComponentSplice createFromParcel(Parcel in) {
-      return new ComponentSplice(in.readInt(), in.readLong());
+      return new ComponentSplice(in.readInt(), in.readLong(), in.readLong());
     }
 
   }
@@ -163,6 +174,7 @@ public void writeToParcel(Parcel dest, int flags) {
     dest.writeByte((byte) (programSpliceFlag ? 1 : 0));
     dest.writeByte((byte) (spliceImmediateFlag ? 1 : 0));
     dest.writeLong(programSplicePts);
+    dest.writeLong(programSplicePlaybackPositionUs);
     int componentSpliceListSize = componentSpliceList.size();
     dest.writeInt(componentSpliceListSize);
     for (int i = 0; i < componentSpliceListSize; i++) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
index c31f4dedc8..f756b72d6d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
+++ b/library/src/main/java/com/google/android/exoplayer2/metadata/scte35/TimeSignalCommand.java
@@ -18,6 +18,7 @@
 import android.os.Parcel;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Represents a time signal command as defined in SCTE35, Section 9.3.4.
@@ -25,14 +26,18 @@
 public final class TimeSignalCommand extends SpliceCommand {
 
   public final long ptsTime;
+  public final long playbackPositionUs;
 
-  private TimeSignalCommand(long ptsTime) {
+  private TimeSignalCommand(long ptsTime, long playbackPositionUs) {
     this.ptsTime = ptsTime;
+    this.playbackPositionUs = playbackPositionUs;
   }
 
   /* package */ static TimeSignalCommand parseFromSection(ParsableByteArray sectionData,
-      long ptsAdjustment) {
-    return new TimeSignalCommand(parseSpliceTime(sectionData, ptsAdjustment));
+      long ptsAdjustment, TimestampAdjuster timestampAdjuster) {
+    long ptsTime = parseSpliceTime(sectionData, ptsAdjustment);
+    long playbackPositionUs = timestampAdjuster.adjustTsTimestamp(ptsTime);
+    return new TimeSignalCommand(ptsTime, playbackPositionUs);
   }
 
   /**
@@ -61,6 +66,7 @@ private TimeSignalCommand(long ptsTime) {
   @Override
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeLong(ptsTime);
+    dest.writeLong(playbackPositionUs);
   }
 
   public static final Creator<TimeSignalCommand> CREATOR =
@@ -68,7 +74,7 @@ public void writeToParcel(Parcel dest, int flags) {
 
     @Override
     public TimeSignalCommand createFromParcel(Parcel in) {
-      return new TimeSignalCommand(in.readLong());
+      return new TimeSignalCommand(in.readLong(), in.readLong());
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
new file mode 100644
index 0000000000..102a689742
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+
+/**
+ * Wraps a {@link MediaPeriod} and clips its {@link SampleStream}s to provide a subsequence of their
+ * samples.
+ */
+public final class ClippingMediaPeriod implements MediaPeriod, MediaPeriod.Callback {
+
+  /**
+   * The {@link MediaPeriod} wrapped by this clipping media period.
+   */
+  public final MediaPeriod mediaPeriod;
+
+  private MediaPeriod.Callback callback;
+  private long startUs;
+  private long endUs;
+  private ClippingSampleStream[] sampleStreams;
+  private boolean pendingInitialDiscontinuity;
+
+  /**
+   * Creates a new clipping media period that provides a clipped view of the specified
+   * {@link MediaPeriod}'s sample streams.
+   * <p>
+   * The clipping start/end positions must be specified by calling {@link #setClipping(long, long)}
+   * on the playback thread before preparation completes.
+   *
+   * @param mediaPeriod The media period to clip.
+   */
+  public ClippingMediaPeriod(MediaPeriod mediaPeriod) {
+    this.mediaPeriod = mediaPeriod;
+    startUs = C.TIME_UNSET;
+    endUs = C.TIME_UNSET;
+    sampleStreams = new ClippingSampleStream[0];
+  }
+
+  /**
+   * Sets the clipping start/end times for this period, in microseconds.
+   *
+   * @param startUs The clipping start time, in microseconds.
+   * @param endUs The clipping end time, in microseconds, or {@link C#TIME_END_OF_SOURCE} to
+   *     indicate the end of the period.
+   */
+  public void setClipping(long startUs, long endUs) {
+    this.startUs = startUs;
+    this.endUs = endUs;
+  }
+
+  @Override
+  public void prepare(MediaPeriod.Callback callback) {
+    this.callback = callback;
+    mediaPeriod.prepare(this);
+  }
+
+  @Override
+  public void maybeThrowPrepareError() throws IOException {
+    mediaPeriod.maybeThrowPrepareError();
+  }
+
+  @Override
+  public TrackGroupArray getTrackGroups() {
+    return mediaPeriod.getTrackGroups();
+  }
+
+  @Override
+  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+    sampleStreams = new ClippingSampleStream[streams.length];
+    SampleStream[] internalStreams = new SampleStream[streams.length];
+    for (int i = 0; i < streams.length; i++) {
+      sampleStreams[i] = (ClippingSampleStream) streams[i];
+      internalStreams[i] = sampleStreams[i] != null ? sampleStreams[i].stream : null;
+    }
+    long enablePositionUs = mediaPeriod.selectTracks(selections, mayRetainStreamFlags,
+        internalStreams, streamResetFlags, positionUs + startUs);
+    Assertions.checkState(enablePositionUs == positionUs + startUs
+        || (enablePositionUs >= startUs
+        && (endUs == C.TIME_END_OF_SOURCE || enablePositionUs <= endUs)));
+    for (int i = 0; i < streams.length; i++) {
+      if (internalStreams[i] == null) {
+        sampleStreams[i] = null;
+      } else if (streams[i] == null || sampleStreams[i].stream != internalStreams[i]) {
+        sampleStreams[i] = new ClippingSampleStream(this, internalStreams[i], startUs, endUs,
+            pendingInitialDiscontinuity);
+      }
+      streams[i] = sampleStreams[i];
+    }
+    return enablePositionUs - startUs;
+  }
+
+  @Override
+  public void discardBuffer(long positionUs) {
+    mediaPeriod.discardBuffer(positionUs + startUs);
+  }
+
+  @Override
+  public long readDiscontinuity() {
+    if (pendingInitialDiscontinuity) {
+      for (ClippingSampleStream sampleStream : sampleStreams) {
+        if (sampleStream != null) {
+          sampleStream.clearPendingDiscontinuity();
+        }
+      }
+      pendingInitialDiscontinuity = false;
+      // Always read an initial discontinuity, using mediaPeriod's discontinuity if set.
+      long discontinuityUs = readDiscontinuity();
+      return discontinuityUs != C.TIME_UNSET ? discontinuityUs : 0;
+    }
+    long discontinuityUs = mediaPeriod.readDiscontinuity();
+    if (discontinuityUs == C.TIME_UNSET) {
+      return C.TIME_UNSET;
+    }
+    Assertions.checkState(discontinuityUs >= startUs);
+    Assertions.checkState(endUs == C.TIME_END_OF_SOURCE || discontinuityUs <= endUs);
+    return discontinuityUs - startUs;
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
+    if (bufferedPositionUs == C.TIME_END_OF_SOURCE
+        || (endUs != C.TIME_END_OF_SOURCE && bufferedPositionUs >= endUs)) {
+      return C.TIME_END_OF_SOURCE;
+    }
+    return Math.max(0, bufferedPositionUs - startUs);
+  }
+
+  @Override
+  public long seekToUs(long positionUs) {
+    for (ClippingSampleStream sampleStream : sampleStreams) {
+      if (sampleStream != null) {
+        sampleStream.clearSentEos();
+      }
+    }
+    long seekUs = mediaPeriod.seekToUs(positionUs + startUs);
+    Assertions.checkState(seekUs == positionUs + startUs
+        || (seekUs >= startUs && (endUs == C.TIME_END_OF_SOURCE || seekUs <= endUs)));
+    return seekUs - startUs;
+  }
+
+  @Override
+  public long getNextLoadPositionUs() {
+    long nextLoadPositionUs = mediaPeriod.getNextLoadPositionUs();
+    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE
+        || (endUs != C.TIME_END_OF_SOURCE && nextLoadPositionUs >= endUs)) {
+      return C.TIME_END_OF_SOURCE;
+    }
+    return nextLoadPositionUs - startUs;
+  }
+
+  @Override
+  public boolean continueLoading(long positionUs) {
+    return mediaPeriod.continueLoading(positionUs + startUs);
+  }
+
+  // MediaPeriod.Callback implementation.
+
+  @Override
+  public void onPrepared(MediaPeriod mediaPeriod) {
+    Assertions.checkState(startUs != C.TIME_UNSET && endUs != C.TIME_UNSET);
+    // If the clipping start position is non-zero, the clipping sample streams will adjust
+    // timestamps on buffers they read from the unclipped sample streams. These adjusted buffer
+    // timestamps can be negative, because sample streams provide buffers starting at a key-frame,
+    // which may be before the clipping start point. When the renderer reads a buffer with a
+    // negative timestamp, its offset timestamp can jump backwards compared to the last timestamp
+    // read in the previous period. Renderer implementations may not allow this, so we signal a
+    // discontinuity which resets the renderers before they read the clipping sample stream.
+    pendingInitialDiscontinuity = startUs != 0;
+    callback.onPrepared(this);
+  }
+
+  @Override
+  public void onContinueLoadingRequested(MediaPeriod source) {
+    callback.onContinueLoadingRequested(this);
+  }
+
+  /**
+   * Wraps a {@link SampleStream} and clips its samples.
+   */
+  private static final class ClippingSampleStream implements SampleStream {
+
+    private final MediaPeriod mediaPeriod;
+    private final SampleStream stream;
+    private final long startUs;
+    private final long endUs;
+
+    private boolean pendingDiscontinuity;
+    private boolean sentEos;
+
+    public ClippingSampleStream(MediaPeriod mediaPeriod, SampleStream stream, long startUs,
+        long endUs, boolean pendingDiscontinuity) {
+      this.mediaPeriod = mediaPeriod;
+      this.stream = stream;
+      this.startUs = startUs;
+      this.endUs = endUs;
+      this.pendingDiscontinuity = pendingDiscontinuity;
+    }
+
+    public void clearPendingDiscontinuity() {
+      pendingDiscontinuity = false;
+    }
+
+    public void clearSentEos() {
+      sentEos = false;
+    }
+
+    @Override
+    public boolean isReady() {
+      return stream.isReady();
+    }
+
+    @Override
+    public void maybeThrowError() throws IOException {
+      stream.maybeThrowError();
+    }
+
+    @Override
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
+        boolean requireFormat) {
+      if (pendingDiscontinuity) {
+        return C.RESULT_NOTHING_READ;
+      }
+      if (sentEos) {
+        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
+      }
+      int result = stream.readData(formatHolder, buffer, requireFormat);
+      // TODO: Clear gapless playback metadata if a format was read (if applicable).
+      if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ
+          && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ
+          && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
+        buffer.clear();
+        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+        sentEos = true;
+        return C.RESULT_BUFFER_READ;
+      }
+      if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
+        buffer.timeUs -= startUs;
+      }
+      return result;
+    }
+
+    @Override
+    public void skipToKeyframeBefore(long timeUs) {
+      stream.skipToKeyframeBefore(startUs + timeUs);
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
new file mode 100644
index 0000000000..be15a07726
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+import java.util.ArrayList;
+
+/**
+ * {@link MediaSource} that wraps a source and clips its timeline based on specified start/end
+ * positions. The wrapped source may only have a single period/window and it must not be dynamic
+ * (live).
+ */
+public final class ClippingMediaSource implements MediaSource, MediaSource.Listener {
+
+  private final MediaSource mediaSource;
+  private final long startUs;
+  private final long endUs;
+  private final ArrayList<ClippingMediaPeriod> mediaPeriods;
+
+  private MediaSource.Listener sourceListener;
+  private ClippingTimeline clippingTimeline;
+
+  /**
+   * Creates a new clipping source that wraps the specified source.
+   *
+   * @param mediaSource The single-period, non-dynamic source to wrap.
+   * @param startPositionUs The start position within {@code mediaSource}'s timeline at which to
+   *     start providing samples, in microseconds.
+   * @param endPositionUs The end position within {@code mediaSource}'s timeline at which to stop
+   *     providing samples, in microseconds. Specify {@link C#TIME_END_OF_SOURCE} to provide samples
+   *     from the specified start point up to the end of the source.
+   */
+  public ClippingMediaSource(MediaSource mediaSource, long startPositionUs, long endPositionUs) {
+    Assertions.checkArgument(startPositionUs >= 0);
+    this.mediaSource = Assertions.checkNotNull(mediaSource);
+    startUs = startPositionUs;
+    endUs = endPositionUs;
+    mediaPeriods = new ArrayList<>();
+  }
+
+  @Override
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    this.sourceListener = listener;
+    mediaSource.prepareSource(player, false, this);
+  }
+
+  @Override
+  public void maybeThrowSourceInfoRefreshError() throws IOException {
+    mediaSource.maybeThrowSourceInfoRefreshError();
+  }
+
+  @Override
+  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
+    ClippingMediaPeriod mediaPeriod = new ClippingMediaPeriod(
+        mediaSource.createPeriod(index, allocator, startUs + positionUs));
+    mediaPeriods.add(mediaPeriod);
+    mediaPeriod.setClipping(clippingTimeline.startUs, clippingTimeline.endUs);
+    return mediaPeriod;
+  }
+
+  @Override
+  public void releasePeriod(MediaPeriod mediaPeriod) {
+    Assertions.checkState(mediaPeriods.remove(mediaPeriod));
+    mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
+  }
+
+  @Override
+  public void releaseSource() {
+    mediaSource.releaseSource();
+  }
+
+  // MediaSource.Listener implementation.
+
+  @Override
+  public void onSourceInfoRefreshed(Timeline timeline, Object manifest) {
+    clippingTimeline = new ClippingTimeline(timeline, startUs, endUs);
+    sourceListener.onSourceInfoRefreshed(clippingTimeline, manifest);
+    long startUs = clippingTimeline.startUs;
+    long endUs = clippingTimeline.endUs == C.TIME_UNSET ? C.TIME_END_OF_SOURCE
+        : clippingTimeline.endUs;
+    int count = mediaPeriods.size();
+    for (int i = 0; i < count; i++) {
+      mediaPeriods.get(i).setClipping(startUs, endUs);
+    }
+  }
+
+  /**
+   * Provides a clipped view of a specified timeline.
+   */
+  private static final class ClippingTimeline extends Timeline {
+
+    private final Timeline timeline;
+    private final long startUs;
+    private final long endUs;
+
+    /**
+     * Creates a new clipping timeline that wraps the specified timeline.
+     *
+     * @param timeline The timeline to clip.
+     * @param startUs The number of microseconds to clip from the start of {@code timeline}.
+     * @param endUs The end position in microseconds for the clipped timeline relative to the start
+     *     of {@code timeline}, or {@link C#TIME_END_OF_SOURCE} to clip no samples from the end.
+     */
+    public ClippingTimeline(Timeline timeline, long startUs, long endUs) {
+      Assertions.checkArgument(timeline.getWindowCount() == 1);
+      Assertions.checkArgument(timeline.getPeriodCount() == 1);
+      Window window = timeline.getWindow(0, new Window(), false);
+      Assertions.checkArgument(!window.isDynamic);
+      long resolvedEndUs = endUs == C.TIME_END_OF_SOURCE ? window.durationUs : endUs;
+      if (window.durationUs != C.TIME_UNSET) {
+        Assertions.checkArgument(startUs == 0 || window.isSeekable);
+        Assertions.checkArgument(resolvedEndUs <= window.durationUs);
+        Assertions.checkArgument(startUs <= resolvedEndUs);
+      }
+      Period period = timeline.getPeriod(0, new Period());
+      Assertions.checkArgument(period.getPositionInWindowUs() == 0);
+      this.timeline = timeline;
+      this.startUs = startUs;
+      this.endUs = resolvedEndUs;
+    }
+
+    @Override
+    public int getWindowCount() {
+      return 1;
+    }
+
+    @Override
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
+      window = timeline.getWindow(0, window, setIds, defaultPositionProjectionUs);
+      window.durationUs = endUs != C.TIME_UNSET ? endUs - startUs : C.TIME_UNSET;
+      if (window.defaultPositionUs != C.TIME_UNSET) {
+        window.defaultPositionUs = Math.max(window.defaultPositionUs, startUs);
+        window.defaultPositionUs = endUs == C.TIME_UNSET ? window.defaultPositionUs
+            : Math.min(window.defaultPositionUs, endUs);
+        window.defaultPositionUs -= startUs;
+      }
+      long startMs = C.usToMs(startUs);
+      if (window.presentationStartTimeMs != C.TIME_UNSET) {
+        window.presentationStartTimeMs += startMs;
+      }
+      if (window.windowStartTimeMs != C.TIME_UNSET) {
+        window.windowStartTimeMs += startMs;
+      }
+      return window;
+    }
+
+    @Override
+    public int getPeriodCount() {
+      return 1;
+    }
+
+    @Override
+    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+      period = timeline.getPeriod(0, period, setIds);
+      period.durationUs = endUs != C.TIME_UNSET ? endUs - startUs : C.TIME_UNSET;
+      return period;
+    }
+
+    @Override
+    public int getIndexOfPeriod(Object uid) {
+      return timeline.getIndexOfPeriod(uid);
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/EmptySampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/EmptySampleStream.java
new file mode 100644
index 0000000000..eb94351f61
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/EmptySampleStream.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import java.io.IOException;
+
+/**
+ * An empty {@link SampleStream}.
+ */
+public final class EmptySampleStream implements SampleStream {
+
+  @Override
+  public boolean isReady() {
+    return true;
+  }
+
+  @Override
+  public void maybeThrowError() throws IOException {
+    // Do nothing.
+  }
+
+  @Override
+  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
+      boolean formatRequired) {
+    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+    return C.RESULT_BUFFER_READ;
+  }
+
+  @Override
+  public void skipToKeyframeBefore(long timeUs) {
+    // Do nothing.
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 761f61c58e..37f42aff54 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -40,6 +40,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ConditionVariable;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
 
@@ -62,6 +63,7 @@
   private final ExtractorMediaSource.EventListener eventListener;
   private final MediaSource.Listener sourceListener;
   private final Allocator allocator;
+  private final String customCacheKey;
   private final Loader loader;
   private final ExtractorHolder extractorHolder;
   private final ConditionVariable loadCondition;
@@ -101,11 +103,13 @@
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param sourceListener A listener to notify when the timeline has been loaded.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
    */
   public ExtractorMediaPeriod(Uri uri, DataSource dataSource, Extractor[] extractors,
       int minLoadableRetryCount, Handler eventHandler,
       ExtractorMediaSource.EventListener eventListener, MediaSource.Listener sourceListener,
-      Allocator allocator) {
+      Allocator allocator, String customCacheKey) {
     this.uri = uri;
     this.dataSource = dataSource;
     this.minLoadableRetryCount = minLoadableRetryCount;
@@ -113,6 +117,7 @@ public ExtractorMediaPeriod(Uri uri, DataSource dataSource, Extractor[] extracto
     this.eventListener = eventListener;
     this.sourceListener = sourceListener;
     this.allocator = allocator;
+    this.customCacheKey = customCacheKey;
     loader = new Loader("Loader:ExtractorMediaPeriod");
     extractorHolder = new ExtractorHolder(extractors, this);
     loadCondition = new ConditionVariable();
@@ -229,6 +234,11 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     return positionUs;
   }
 
+  @Override
+  public void discardBuffer(long positionUs) {
+    // Do nothing.
+  }
+
   @Override
   public boolean continueLoading(long playbackPositionUs) {
     if (loadingFinished || (prepared && enabledTrackCount == 0)) {
@@ -320,13 +330,14 @@ public long seekToUs(long positionUs) {
     loader.maybeThrowError();
   }
 
-  /* package */ int readData(int track, FormatHolder formatHolder, DecoderInputBuffer buffer) {
+  /* package */ int readData(int track, FormatHolder formatHolder, DecoderInputBuffer buffer,
+      boolean formatRequired) {
     if (notifyReset || isPendingReset()) {
       return C.RESULT_NOTHING_READ;
     }
 
-    return sampleQueues.valueAt(track).readData(formatHolder, buffer, loadingFinished,
-        lastSeekPositionUs);
+    return sampleQueues.valueAt(track).readData(formatHolder, buffer, formatRequired,
+        loadingFinished, lastSeekPositionUs);
   }
 
   // Loader.Callback implementation.
@@ -343,6 +354,7 @@ public void onLoadCompleted(ExtractingLoadable loadable, long elapsedRealtimeMs,
       sourceListener.onSourceInfoRefreshed(
           new SinglePeriodTimeline(durationUs, seekMap.isSeekable()), null);
     }
+    callback.onContinueLoadingRequested(this);
   }
 
   @Override
@@ -376,7 +388,7 @@ public int onLoadError(ExtractingLoadable loadable, long elapsedRealtimeMs,
   // ExtractorOutput implementation. Called by the loading thread.
 
   @Override
-  public TrackOutput track(int id) {
+  public TrackOutput track(int id, int type) {
     DefaultTrackOutput trackOutput = sampleQueues.get(id);
     if (trackOutput == null) {
       trackOutput = new DefaultTrackOutput(allocator);
@@ -514,7 +526,7 @@ private boolean isPendingReset() {
   }
 
   private boolean isLoadableExceptionFatal(IOException e) {
-    return e instanceof ExtractorMediaSource.UnrecognizedInputFormatException;
+    return e instanceof UnrecognizedInputFormatException;
   }
 
   private void notifyLoadError(final IOException error) {
@@ -547,8 +559,9 @@ public void maybeThrowError() throws IOException {
     }
 
     @Override
-    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
-      return ExtractorMediaPeriod.this.readData(track, formatHolder, buffer);
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
+        boolean formatRequired) {
+      return ExtractorMediaPeriod.this.readData(track, formatHolder, buffer, formatRequired);
     }
 
     @Override
@@ -615,12 +628,12 @@ public void load() throws IOException, InterruptedException {
         ExtractorInput input = null;
         try {
           long position = positionHolder.position;
-          length = dataSource.open(new DataSpec(uri, position, C.LENGTH_UNSET, null));
+          length = dataSource.open(new DataSpec(uri, position, C.LENGTH_UNSET, customCacheKey));
           if (length != C.LENGTH_UNSET) {
             length += position;
           }
           input = new DefaultExtractorInput(dataSource, position, length);
-          Extractor extractor = extractorHolder.selectExtractor(input);
+          Extractor extractor = extractorHolder.selectExtractor(input, dataSource.getUri());
           if (pendingExtractorSeek) {
             extractor.seek(position, seekTimeUs);
             pendingExtractorSeek = false;
@@ -640,7 +653,7 @@ public void load() throws IOException, InterruptedException {
           } else if (input != null) {
             positionHolder.position = input.getPosition();
           }
-          dataSource.close();
+          Util.closeQuietly(dataSource);
         }
       }
     }
@@ -672,13 +685,13 @@ public ExtractorHolder(Extractor[] extractors, ExtractorOutput extractorOutput)
      * later calls.
      *
      * @param input The {@link ExtractorInput} from which data should be read.
+     * @param uri The {@link Uri} of the data.
      * @return An initialized extractor for reading {@code input}.
-     * @throws ExtractorMediaSource.UnrecognizedInputFormatException Thrown if the input format
-     *     could not be detected.
+     * @throws UnrecognizedInputFormatException Thrown if the input format could not be detected.
      * @throws IOException Thrown if the input could not be read.
      * @throws InterruptedException Thrown if the thread was interrupted.
      */
-    public Extractor selectExtractor(ExtractorInput input)
+    public Extractor selectExtractor(ExtractorInput input, Uri uri)
         throws IOException, InterruptedException {
       if (extractor != null) {
         return extractor;
@@ -696,7 +709,8 @@ public Extractor selectExtractor(ExtractorInput input)
         }
       }
       if (extractor == null) {
-        throw new ExtractorMediaSource.UnrecognizedInputFormatException(extractors);
+        throw new UnrecognizedInputFormatException("None of the available extractors ("
+            + Util.getCommaDelimitedSimpleClassNames(extractors) + ") could read the stream.", uri);
       }
       extractor.init(extractorOutput);
       return extractor;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index 559d241598..c560616aae 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -19,7 +19,6 @@
 import android.os.Handler;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -27,7 +26,6 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -57,18 +55,6 @@
 
   }
 
-  /**
-   * Thrown if the input format could not recognized.
-   */
-  public static final class UnrecognizedInputFormatException extends ParserException {
-
-    public UnrecognizedInputFormatException(Extractor[] extractors) {
-      super("None of the available extractors ("
-          + Util.getCommaDelimitedSimpleClassNames(extractors) + ") could read the stream.");
-    }
-
-  }
-
   /**
    * The default minimum number of times to retry loading prior to failing for on-demand streams.
    */
@@ -93,6 +79,7 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
   private final Handler eventHandler;
   private final EventListener eventListener;
   private final Timeline.Period period;
+  private final String customCacheKey;
 
   private MediaSource.Listener sourceListener;
   private Timeline timeline;
@@ -110,7 +97,25 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
   public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
       ExtractorsFactory extractorsFactory, Handler eventHandler, EventListener eventListener) {
     this(uri, dataSourceFactory, extractorsFactory, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, eventHandler,
-        eventListener);
+        eventListener, null);
+  }
+
+  /**
+   * @param uri The {@link Uri} of the media stream.
+   * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
+   * @param extractorsFactory A factory for {@link Extractor}s to process the media stream. If the
+   *     possible formats are known, pass a factory that instantiates extractors for those formats.
+   *     Otherwise, pass a {@link DefaultExtractorsFactory} to use default extractors.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
+   */
+  public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
+      ExtractorsFactory extractorsFactory, Handler eventHandler, EventListener eventListener,
+      String customCacheKey) {
+    this(uri, dataSourceFactory, extractorsFactory, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, eventHandler,
+        eventListener, customCacheKey);
   }
 
   /**
@@ -122,16 +127,19 @@ public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
    * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
+   *     indexing. May be null.
    */
   public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
       ExtractorsFactory extractorsFactory, int minLoadableRetryCount, Handler eventHandler,
-      EventListener eventListener) {
+      EventListener eventListener, String customCacheKey) {
     this.uri = uri;
     this.dataSourceFactory = dataSourceFactory;
     this.extractorsFactory = extractorsFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
+    this.customCacheKey = customCacheKey;
     period = new Timeline.Period();
   }
 
@@ -152,7 +160,7 @@ public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs)
     Assertions.checkArgument(index == 0);
     return new ExtractorMediaPeriod(uri, dataSourceFactory.createDataSource(),
         extractorsFactory.createExtractors(), minLoadableRetryCount, eventHandler, eventListener,
-        this, allocator);
+        this, allocator, customCacheKey);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index f4a9665b10..3b06542855 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import java.io.IOException;
 
@@ -47,6 +48,10 @@
    * <p>
    * {@code callback.onPrepared} is called when preparation completes. If preparation fails,
    * {@link #maybeThrowPrepareError()} will throw an {@link IOException}.
+   * <p>
+   * If preparation succeeds and results in a source timeline change (e.g. the period duration
+   * becoming known), {@link MediaSource.Listener#onSourceInfoRefreshed(Timeline, Object)} will be
+   * called before {@code callback.onPrepared}.
    *
    * @param callback Callback to receive updates from this period, including being notified when
    *     preparation completes.
@@ -99,6 +104,13 @@
   long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs);
 
+  /**
+   * Discards buffered media up to the specified position.
+   *
+   * @param positionUs The position in microseconds.
+   */
+  void discardBuffer(long positionUs);
+
   /**
    * Attempts to read a discontinuity.
    * <p>
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
index 10c56e5576..077b5576c1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
@@ -128,6 +128,13 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     return positionUs;
   }
 
+  @Override
+  public void discardBuffer(long positionUs) {
+    for (MediaPeriod period : enabledPeriods) {
+      period.discardBuffer(positionUs);
+    }
+  }
+
   @Override
   public boolean continueLoading(long positionUs) {
     return sequenceableLoader.continueLoading(positionUs);
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index 417483cebc..6f37165916 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -57,8 +57,7 @@
      * The reason the merge failed. One of {@link #REASON_WINDOWS_ARE_DYNAMIC} and
      * {@link #REASON_PERIOD_COUNT_MISMATCH}.
      */
-    @Reason
-    public final int reason;
+    @Reason public final int reason;
 
     /**
      * @param reason The reason the merge failed. One of {@link #REASON_WINDOWS_ARE_DYNAMIC} and
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
index 39374acb33..e3039878f8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
@@ -29,7 +29,8 @@
    * Returns whether data is available to be read.
    * <p>
    * Note: If the stream has ended then a buffer with the end of stream flag can always be read from
-   * {@link #readData(FormatHolder, DecoderInputBuffer)}. Hence an ended stream is always ready.
+   * {@link #readData(FormatHolder, DecoderInputBuffer, boolean)}. Hence an ended stream is always
+   * ready.
    *
    * @return Whether data is available to be read.
    */
@@ -44,15 +45,25 @@
 
   /**
    * Attempts to read from the stream.
+   * <p>
+   * If the stream has ended then {@link C#BUFFER_FLAG_END_OF_STREAM} flag is set on {@code buffer}
+   * and {@link C#RESULT_BUFFER_READ} is returned. Else if no data is available then
+   * {@link C#RESULT_NOTHING_READ} is returned. Else if the format of the media is changing or if
+   * {@code formatRequired} is set then {@code formatHolder} is populated and
+   * {@link C#RESULT_FORMAT_READ} is returned. Else {@code buffer} is populated and
+   * {@link C#RESULT_BUFFER_READ} is returned.
    *
    * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
    * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
    *     end of the stream. If the end of the stream has been reached, the
    *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+   * @param formatRequired Whether the caller requires that the format of the stream be read even if
+   *     it's not changing. A sample will never be read if set to true, however it is still possible
+   *     for the end of stream or nothing to be read.
    * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
    *     {@link C#RESULT_BUFFER_READ}.
    */
-  int readData(FormatHolder formatHolder, DecoderInputBuffer buffer);
+  int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired);
 
   /**
    * Attempts to skip to the keyframe before the specified time.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java b/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
index 9aebcece9e..f287153719 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.C;
 
+// TODO: Clarify the requirements for implementing this interface [Internal ref: b/36250203].
 /**
  * A loader that can proceed in approximate synchronization with other loaders.
  */
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 1ad448bd12..5b717e51da 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -28,6 +28,7 @@
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -110,6 +111,11 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     return positionUs;
   }
 
+  @Override
+  public void discardBuffer(long positionUs) {
+    // Do nothing.
+  }
+
   @Override
   public boolean continueLoading(long positionUs) {
     if (loadingFinished || loader.isLoading()) {
@@ -204,11 +210,12 @@ public void maybeThrowError() throws IOException {
     }
 
     @Override
-    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
+        boolean requireFormat) {
       if (streamState == STREAM_STATE_END_OF_STREAM) {
         buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
         return C.RESULT_BUFFER_READ;
-      } else if (streamState == STREAM_STATE_SEND_FORMAT) {
+      } else if (requireFormat || streamState == STREAM_STATE_SEND_FORMAT) {
         formatHolder.format = format;
         streamState = STREAM_STATE_SEND_SAMPLE;
         return C.RESULT_FORMAT_READ;
@@ -276,7 +283,7 @@ public void load() throws IOException, InterruptedException {
           result = dataSource.read(sampleData, sampleSize, sampleData.length - sampleSize);
         }
       } finally {
-        dataSource.close();
+        Util.closeQuietly(dataSource);
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/UnrecognizedInputFormatException.java b/library/src/main/java/com/google/android/exoplayer2/source/UnrecognizedInputFormatException.java
new file mode 100644
index 0000000000..508bf0e365
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/UnrecognizedInputFormatException.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.ParserException;
+
+/**
+ * Thrown if the input format was not recognized.
+ */
+public class UnrecognizedInputFormatException extends ParserException {
+
+  /**
+   * The {@link Uri} from which the unrecognized data was read.
+   */
+  public final Uri uri;
+
+  /**
+   * @param message The detail message for the exception.
+   * @param uri The {@link Uri} from which the unrecognized data was read.
+   */
+  public UnrecognizedInputFormatException(String message, Uri uri) {
+    super(message);
+    this.uri = uri;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java
index 0a43ecde63..7a5aeabeb6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java
@@ -21,14 +21,12 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 
 /**
- * A base implementation of {@link MediaChunk}, for chunks that contain a single track.
- * <p>
- * Loaded samples are output to a {@link DefaultTrackOutput}.
+ * A base implementation of {@link MediaChunk} that outputs to a {@link BaseMediaChunkOutput}.
  */
 public abstract class BaseMediaChunk extends MediaChunk {
 
-  private DefaultTrackOutput trackOutput;
-  private int firstSampleIndex;
+  private BaseMediaChunkOutput output;
+  private int[] firstSampleIndices;
 
   /**
    * @param dataSource The source from which the data should be loaded.
@@ -48,29 +46,29 @@ public BaseMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackForm
   }
 
   /**
-   * Initializes the chunk for loading, setting the {@link DefaultTrackOutput} that will receive
+   * Initializes the chunk for loading, setting the {@link BaseMediaChunkOutput} that will receive
    * samples as they are loaded.
    *
-   * @param trackOutput The output that will receive the loaded samples.
+   * @param output The output that will receive the loaded media samples.
    */
-  public void init(DefaultTrackOutput trackOutput) {
-    this.trackOutput = trackOutput;
-    this.firstSampleIndex = trackOutput.getWriteIndex();
+  public void init(BaseMediaChunkOutput output) {
+    this.output = output;
+    firstSampleIndices = output.getWriteIndices();
   }
 
   /**
-   * Returns the index of the first sample in the output that was passed to
-   * {@link #init(DefaultTrackOutput)} that will originate from this chunk.
+   * Returns the index of the first sample in the specified track of the output that will originate
+   * from this chunk.
    */
-  public final int getFirstSampleIndex() {
-    return firstSampleIndex;
+  public final int getFirstSampleIndex(int trackIndex) {
+    return firstSampleIndices[trackIndex];
   }
 
   /**
-   * Returns the track output most recently passed to {@link #init(DefaultTrackOutput)}.
+   * Returns the output most recently passed to {@link #init(BaseMediaChunkOutput)}.
    */
-  protected final DefaultTrackOutput getTrackOutput() {
-    return trackOutput;
+  protected final BaseMediaChunkOutput getOutput() {
+    return output;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkOutput.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkOutput.java
new file mode 100644
index 0000000000..3882a330f9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunkOutput.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.chunk;
+
+import android.util.Log;
+import com.google.android.exoplayer2.extractor.DefaultTrackOutput;
+import com.google.android.exoplayer2.extractor.DummyTrackOutput;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.TrackOutputProvider;
+
+/**
+ * An output for {@link BaseMediaChunk}s.
+ */
+/* package */ final class BaseMediaChunkOutput implements TrackOutputProvider {
+
+  private static final String TAG = "BaseMediaChunkOutput";
+
+  private final int[] trackTypes;
+  private final DefaultTrackOutput[] trackOutputs;
+
+  /**
+   * @param trackTypes The track types of the individual track outputs.
+   * @param trackOutputs The individual track outputs.
+   */
+  public BaseMediaChunkOutput(int[] trackTypes, DefaultTrackOutput[] trackOutputs) {
+    this.trackTypes = trackTypes;
+    this.trackOutputs = trackOutputs;
+  }
+
+  @Override
+  public TrackOutput track(int id, int type) {
+    for (int i = 0; i < trackTypes.length; i++) {
+      if (type == trackTypes[i]) {
+        return trackOutputs[i];
+      }
+    }
+    Log.e(TAG, "Unmatched track of type: " + type);
+    return new DummyTrackOutput();
+  }
+
+  /**
+   * Returns the current absolute write indices of the individual track outputs.
+   */
+  public int[] getWriteIndices() {
+    int[] writeIndices = new int[trackOutputs.length];
+    for (int i = 0; i < trackOutputs.length; i++) {
+      if (trackOutputs[i] != null) {
+        writeIndices[i] = trackOutputs[i].getWriteIndex();
+      }
+    }
+    return writeIndices;
+  }
+
+  /**
+   * Sets an offset that will be added to the timestamps (and sub-sample timestamps) of samples
+   * subsequently written to the track outputs.
+   */
+  public void setSampleOffsetUs(long sampleOffsetUs) {
+    for (DefaultTrackOutput trackOutput : trackOutputs) {
+      if (trackOutput != null) {
+        trackOutput.setSampleOffsetUs(sampleOffsetUs);
+      }
+    }
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
index ed76a505ea..501f4998cf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkExtractorWrapper.java
@@ -15,9 +15,10 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
+import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -30,132 +31,165 @@
 /**
  * An {@link Extractor} wrapper for loading chunks containing a single track.
  * <p>
- * The wrapper allows switching of the {@link SingleTrackMetadataOutput} and {@link TrackOutput}
- * which receive parsed data.
+ * The wrapper allows switching of the {@link TrackOutput} that receives parsed data.
  */
-public final class ChunkExtractorWrapper implements ExtractorOutput, TrackOutput {
+public final class ChunkExtractorWrapper implements ExtractorOutput {
 
   /**
-   * Receives metadata associated with the track as extracted by the wrapped {@link Extractor}.
+   * Provides {@link TrackOutput} instances to be written to by the wrapper.
    */
-  public interface SingleTrackMetadataOutput {
+  public interface TrackOutputProvider {
 
     /**
-     * @see ExtractorOutput#seekMap(SeekMap)
+     * Called to get the {@link TrackOutput} for a specific track.
+     * <p>
+     * The same {@link TrackOutput} is returned if multiple calls are made with the same {@code id}.
+     *
+     * @param id A track identifier.
+     * @param type The type of the track. Typically one of the
+     *     {@link com.google.android.exoplayer2.C} {@code TRACK_TYPE_*} constants.
+     * @return The {@link TrackOutput} for the given track identifier.
      */
-    void seekMap(SeekMap seekMap);
+    TrackOutput track(int id, int type);
 
   }
 
-  private final Extractor extractor;
+  public final Extractor extractor;
+
   private final Format manifestFormat;
-  private final boolean preferManifestDrmInitData;
-  private final boolean resendFormatOnInit;
+  private final SparseArray<BindingTrackOutput> bindingTrackOutputs;
 
   private boolean extractorInitialized;
-  private SingleTrackMetadataOutput metadataOutput;
-  private TrackOutput trackOutput;
-  private Format sentFormat;
-
-  // Accessed only on the loader thread.
-  private boolean seenTrack;
-  private int seenTrackId;
+  private TrackOutputProvider trackOutputProvider;
+  private SeekMap seekMap;
+  private Format[] sampleFormats;
 
   /**
    * @param extractor The extractor to wrap.
    * @param manifestFormat A manifest defined {@link Format} whose data should be merged into any
    *     sample {@link Format} output from the {@link Extractor}.
-   * @param preferManifestDrmInitData Whether {@link DrmInitData} defined in {@code manifestFormat}
-   *     should be preferred when the sample and manifest {@link Format}s are merged.
-   * @param resendFormatOnInit Whether the extractor should resend the previous {@link Format} when
-   *     it is initialized via {@link #init(SingleTrackMetadataOutput, TrackOutput)}.
    */
-  public ChunkExtractorWrapper(Extractor extractor, Format manifestFormat,
-      boolean preferManifestDrmInitData, boolean resendFormatOnInit) {
+  public ChunkExtractorWrapper(Extractor extractor, Format manifestFormat) {
     this.extractor = extractor;
     this.manifestFormat = manifestFormat;
-    this.preferManifestDrmInitData = preferManifestDrmInitData;
-    this.resendFormatOnInit = resendFormatOnInit;
+    bindingTrackOutputs = new SparseArray<>();
+  }
+
+  /**
+   * Returns the {@link SeekMap} most recently output by the extractor, or null.
+   */
+  public SeekMap getSeekMap() {
+    return seekMap;
+  }
+
+  /**
+   * Returns the sample {@link Format}s most recently output by the extractor, or null.
+   */
+  public Format[] getSampleFormats() {
+    return sampleFormats;
   }
 
   /**
-   * Initializes the extractor to output to the provided {@link SingleTrackMetadataOutput} and
-   * {@link TrackOutput} instances, and configures it to receive data from a new chunk.
+   * Initializes the extractor to output to the provided {@link TrackOutput}, and configures it to
+   * receive data from a new chunk.
    *
-   * @param metadataOutput The {@link SingleTrackMetadataOutput} that will receive metadata.
-   * @param trackOutput The {@link TrackOutput} that will receive sample data.
+   * @param trackOutputProvider The provider of {@link TrackOutput}s that will receive sample data.
    */
-  public void init(SingleTrackMetadataOutput metadataOutput, TrackOutput trackOutput) {
-    this.metadataOutput = metadataOutput;
-    this.trackOutput = trackOutput;
+  public void init(TrackOutputProvider trackOutputProvider) {
+    this.trackOutputProvider = trackOutputProvider;
     if (!extractorInitialized) {
       extractor.init(this);
       extractorInitialized = true;
     } else {
       extractor.seek(0, 0);
-      if (resendFormatOnInit && sentFormat != null) {
-        trackOutput.format(sentFormat);
+      for (int i = 0; i < bindingTrackOutputs.size(); i++) {
+        bindingTrackOutputs.valueAt(i).bind(trackOutputProvider);
       }
     }
   }
 
-  /**
-   * Reads from the provided {@link ExtractorInput}.
-   *
-   * @param input The {@link ExtractorInput} from which to read.
-   * @return One of {@link Extractor#RESULT_CONTINUE} and {@link Extractor#RESULT_END_OF_INPUT}.
-   * @throws IOException If an error occurred reading from the source.
-   * @throws InterruptedException If the thread was interrupted.
-   */
-  public int read(ExtractorInput input) throws IOException, InterruptedException {
-    int result = extractor.read(input, null);
-    Assertions.checkState(result != Extractor.RESULT_SEEK);
-    return result;
-  }
-
   // ExtractorOutput implementation.
 
   @Override
-  public TrackOutput track(int id) {
-    Assertions.checkState(!seenTrack || seenTrackId == id);
-    seenTrack = true;
-    seenTrackId = id;
-    return this;
+  public TrackOutput track(int id, int type) {
+    BindingTrackOutput bindingTrackOutput = bindingTrackOutputs.get(id);
+    if (bindingTrackOutput == null) {
+      // Assert that if we're seeing a new track we have not seen endTracks.
+      Assertions.checkState(sampleFormats == null);
+      bindingTrackOutput = new BindingTrackOutput(id, type, manifestFormat);
+      bindingTrackOutput.bind(trackOutputProvider);
+      bindingTrackOutputs.put(id, bindingTrackOutput);
+    }
+    return bindingTrackOutput;
   }
 
   @Override
   public void endTracks() {
-    Assertions.checkState(seenTrack);
+    Format[] sampleFormats = new Format[bindingTrackOutputs.size()];
+    for (int i = 0; i < bindingTrackOutputs.size(); i++) {
+      sampleFormats[i] = bindingTrackOutputs.valueAt(i).sampleFormat;
+    }
+    this.sampleFormats = sampleFormats;
   }
 
   @Override
   public void seekMap(SeekMap seekMap) {
-    metadataOutput.seekMap(seekMap);
+    this.seekMap = seekMap;
   }
 
-  // TrackOutput implementation.
+  // Internal logic.
 
-  @Override
-  public void format(Format format) {
-    sentFormat = format.copyWithManifestFormatInfo(manifestFormat, preferManifestDrmInitData);
-    trackOutput.format(sentFormat);
-  }
+  private static final class BindingTrackOutput implements TrackOutput {
 
-  @Override
-  public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
-      throws IOException, InterruptedException {
-    return trackOutput.sampleData(input, length, allowEndOfInput);
-  }
+    private final int id;
+    private final int type;
+    private final Format manifestFormat;
 
-  @Override
-  public void sampleData(ParsableByteArray data, int length) {
-    trackOutput.sampleData(data, length);
-  }
+    public Format sampleFormat;
+    private TrackOutput trackOutput;
+
+    public BindingTrackOutput(int id, int type, Format manifestFormat) {
+      this.id = id;
+      this.type = type;
+      this.manifestFormat = manifestFormat;
+    }
+
+    public void bind(TrackOutputProvider trackOutputProvider) {
+      if (trackOutputProvider == null) {
+        trackOutput = new DummyTrackOutput();
+        return;
+      }
+      trackOutput = trackOutputProvider.track(id, type);
+      if (trackOutput != null) {
+        trackOutput.format(sampleFormat);
+      }
+    }
+
+    @Override
+    public void format(Format format) {
+      // TODO: This should only happen for the primary track. Additional metadata/text tracks need
+      // to be copied with different manifest derived formats.
+      sampleFormat = format.copyWithManifestFormatInfo(manifestFormat);
+      trackOutput.format(sampleFormat);
+    }
+
+    @Override
+    public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+        throws IOException, InterruptedException {
+      return trackOutput.sampleData(input, length, allowEndOfInput);
+    }
+
+    @Override
+    public void sampleData(ParsableByteArray data, int length) {
+      trackOutput.sampleData(data, length);
+    }
+
+    @Override
+    public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
+        byte[] encryptionKey) {
+      trackOutput.sampleMetadata(timeUs, flags, size, offset, encryptionKey);
+    }
 
-  @Override
-  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
-      byte[] encryptionKey) {
-    trackOutput.sampleMetadata(timeUs, flags, size, offset, encryptionKey);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index 6de7c6ec01..93d86a8de1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -33,30 +33,35 @@
 
 /**
  * A {@link SampleStream} that loads media in {@link Chunk}s, obtained from a {@link ChunkSource}.
+ * May also be configured to expose additional embedded {@link SampleStream}s.
  */
 public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, SequenceableLoader,
     Loader.Callback<Chunk> {
 
-  private final int trackType;
+  private final int primaryTrackType;
+  private final int[] embeddedTrackTypes;
+  private final boolean[] embeddedTracksSelected;
   private final T chunkSource;
   private final SequenceableLoader.Callback<ChunkSampleStream<T>> callback;
   private final EventDispatcher eventDispatcher;
   private final int minLoadableRetryCount;
+  private final Loader loader;
+  private final ChunkHolder nextChunkHolder;
   private final LinkedList<BaseMediaChunk> mediaChunks;
   private final List<BaseMediaChunk> readOnlyMediaChunks;
-  private final DefaultTrackOutput sampleQueue;
-  private final ChunkHolder nextChunkHolder;
-  private final Loader loader;
-
-  private Format downstreamTrackFormat;
+  private final DefaultTrackOutput primarySampleQueue;
+  private final DefaultTrackOutput[] embeddedSampleQueues;
+  private final BaseMediaChunkOutput mediaChunkOutput;
 
-  private long lastSeekPositionUs;
+  private Format primaryDownstreamTrackFormat;
   private long pendingResetPositionUs;
-
-  private boolean loadingFinished;
+  /* package */ long lastSeekPositionUs;
+  /* package */ boolean loadingFinished;
 
   /**
-   * @param trackType The type of the track. One of the {@link C} {@code TRACK_TYPE_*} constants.
+   * @param primaryTrackType The type of the primary track. One of the {@link C}
+   *     {@code TRACK_TYPE_*} constants.
+   * @param embeddedTrackTypes The types of any embedded tracks, or null.
    * @param chunkSource A {@link ChunkSource} from which chunks to load are obtained.
    * @param callback An {@link Callback} for the stream.
    * @param allocator An {@link Allocator} from which allocations can be obtained.
@@ -65,10 +70,11 @@
    *     before propagating an error.
    * @param eventDispatcher A dispatcher to notify of events.
    */
-  public ChunkSampleStream(int trackType, T chunkSource,
-      SequenceableLoader.Callback<ChunkSampleStream<T>> callback, Allocator allocator,
-      long positionUs, int minLoadableRetryCount, EventDispatcher eventDispatcher) {
-    this.trackType = trackType;
+  public ChunkSampleStream(int primaryTrackType, int[] embeddedTrackTypes, T chunkSource,
+      Callback<ChunkSampleStream<T>> callback, Allocator allocator, long positionUs,
+      int minLoadableRetryCount, EventDispatcher eventDispatcher) {
+    this.primaryTrackType = primaryTrackType;
+    this.embeddedTrackTypes = embeddedTrackTypes;
     this.chunkSource = chunkSource;
     this.callback = callback;
     this.eventDispatcher = eventDispatcher;
@@ -77,15 +83,68 @@ public ChunkSampleStream(int trackType, T chunkSource,
     nextChunkHolder = new ChunkHolder();
     mediaChunks = new LinkedList<>();
     readOnlyMediaChunks = Collections.unmodifiableList(mediaChunks);
-    sampleQueue = new DefaultTrackOutput(allocator);
-    lastSeekPositionUs = positionUs;
+
+    int embeddedTrackCount = embeddedTrackTypes == null ? 0 : embeddedTrackTypes.length;
+    embeddedSampleQueues = new DefaultTrackOutput[embeddedTrackCount];
+    embeddedTracksSelected = new boolean[embeddedTrackCount];
+    int[] trackTypes = new int[1 + embeddedTrackCount];
+    DefaultTrackOutput[] sampleQueues = new DefaultTrackOutput[1 + embeddedTrackCount];
+
+    primarySampleQueue = new DefaultTrackOutput(allocator);
+    trackTypes[0] = primaryTrackType;
+    sampleQueues[0] = primarySampleQueue;
+
+    for (int i = 0; i < embeddedTrackCount; i++) {
+      DefaultTrackOutput trackOutput = new DefaultTrackOutput(allocator);
+      embeddedSampleQueues[i] = trackOutput;
+      sampleQueues[i + 1] = trackOutput;
+      trackTypes[i + 1] = embeddedTrackTypes[i];
+    }
+
+    mediaChunkOutput = new BaseMediaChunkOutput(trackTypes, sampleQueues);
     pendingResetPositionUs = positionUs;
+    lastSeekPositionUs = positionUs;
   }
 
   /**
-   * Returns the {@link ChunkSource} used by this stream.
+   * Discards buffered media for embedded tracks that are not currently selected, up to the
+   * specified position.
    *
-   * @return The {@link ChunkSource}.
+   * @param positionUs The position to discard up to, in microseconds.
+   */
+  public void discardUnselectedEmbeddedTracksTo(long positionUs) {
+    for (int i = 0; i < embeddedSampleQueues.length; i++) {
+      if (!embeddedTracksSelected[i]) {
+        embeddedSampleQueues[i].skipToKeyframeBefore(positionUs, true);
+      }
+    }
+  }
+
+  /**
+   * Selects the embedded track, returning a new {@link EmbeddedSampleStream} from which the track's
+   * samples can be consumed. {@link EmbeddedSampleStream#release()} must be called on the returned
+   * stream when the track is no longer required, and before calling this method again to obtain
+   * another stream for the same track.
+   *
+   * @param positionUs The current playback position in microseconds.
+   * @param trackType The type of the embedded track to enable.
+   * @return The {@link EmbeddedSampleStream} for the embedded track.
+   */
+  public EmbeddedSampleStream selectEmbeddedTrack(long positionUs, int trackType) {
+    for (int i = 0; i < embeddedSampleQueues.length; i++) {
+      if (embeddedTrackTypes[i] == trackType) {
+        Assertions.checkState(!embeddedTracksSelected[i]);
+        embeddedTracksSelected[i] = true;
+        embeddedSampleQueues[i].skipToKeyframeBefore(positionUs, true);
+        return new EmbeddedSampleStream(this, embeddedSampleQueues[i], i);
+      }
+    }
+    // Should never happen.
+    throw new IllegalStateException();
+  }
+
+  /**
+   * Returns the {@link ChunkSource} used by this stream.
    */
   public T getChunkSource() {
     return chunkSource;
@@ -110,7 +169,7 @@ public long getBufferedPositionUs() {
       if (lastCompletedMediaChunk != null) {
         bufferedPositionUs = Math.max(bufferedPositionUs, lastCompletedMediaChunk.endTimeUs);
       }
-      return Math.max(bufferedPositionUs, sampleQueue.getLargestQueuedTimestampUs());
+      return Math.max(bufferedPositionUs, primarySampleQueue.getLargestQueuedTimestampUs());
     }
   }
 
@@ -121,14 +180,21 @@ public long getBufferedPositionUs() {
    */
   public void seekToUs(long positionUs) {
     lastSeekPositionUs = positionUs;
-    // If we're not pending a reset, see if we can seek within the sample queue.
-    boolean seekInsideBuffer = !isPendingReset() && sampleQueue.skipToKeyframeBefore(positionUs);
+    // If we're not pending a reset, see if we can seek within the primary sample queue.
+    boolean seekInsideBuffer = !isPendingReset() && primarySampleQueue.skipToKeyframeBefore(
+        positionUs, positionUs < getNextLoadPositionUs());
     if (seekInsideBuffer) {
-      // We succeeded. All we need to do is discard any chunks that we've moved past.
+      // We succeeded. We need to discard any chunks that we've moved past and perform the seek for
+      // any embedded streams as well.
       while (mediaChunks.size() > 1
-          && mediaChunks.get(1).getFirstSampleIndex() <= sampleQueue.getReadIndex()) {
+          && mediaChunks.get(1).getFirstSampleIndex(0) <= primarySampleQueue.getReadIndex()) {
         mediaChunks.removeFirst();
       }
+      // TODO: For this to work correctly, the embedded streams must not discard anything from their
+      // sample queues beyond the current read position of the primary stream.
+      for (DefaultTrackOutput embeddedSampleQueue : embeddedSampleQueues) {
+        embeddedSampleQueue.skipToKeyframeBefore(positionUs);
+      }
     } else {
       // We failed, and need to restart.
       pendingResetPositionUs = positionUs;
@@ -137,7 +203,10 @@ public void seekToUs(long positionUs) {
       if (loader.isLoading()) {
         loader.cancelLoading();
       } else {
-        sampleQueue.reset(true);
+        primarySampleQueue.reset(true);
+        for (DefaultTrackOutput embeddedSampleQueue : embeddedSampleQueues) {
+          embeddedSampleQueue.reset(true);
+        }
       }
     }
   }
@@ -148,7 +217,10 @@ public void seekToUs(long positionUs) {
    * This method should be called when the stream is no longer required.
    */
   public void release() {
-    sampleQueue.disable();
+    primarySampleQueue.disable();
+    for (DefaultTrackOutput embeddedSampleQueue : embeddedSampleQueues) {
+      embeddedSampleQueue.disable();
+    }
     loader.release();
   }
 
@@ -156,7 +228,7 @@ public void release() {
 
   @Override
   public boolean isReady() {
-    return loadingFinished || (!isPendingReset() && !sampleQueue.isEmpty());
+    return loadingFinished || (!isPendingReset() && !primarySampleQueue.isEmpty());
   }
 
   @Override
@@ -168,30 +240,19 @@ public void maybeThrowError() throws IOException {
   }
 
   @Override
-  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
+  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
+      boolean formatRequired) {
     if (isPendingReset()) {
       return C.RESULT_NOTHING_READ;
     }
-
-    while (mediaChunks.size() > 1
-        && mediaChunks.get(1).getFirstSampleIndex() <= sampleQueue.getReadIndex()) {
-      mediaChunks.removeFirst();
-    }
-    BaseMediaChunk currentChunk = mediaChunks.getFirst();
-
-    Format trackFormat = currentChunk.trackFormat;
-    if (!trackFormat.equals(downstreamTrackFormat)) {
-      eventDispatcher.downstreamFormatChanged(trackType, trackFormat,
-          currentChunk.trackSelectionReason, currentChunk.trackSelectionData,
-          currentChunk.startTimeUs);
-    }
-    downstreamTrackFormat = trackFormat;
-    return sampleQueue.readData(formatHolder, buffer, loadingFinished, lastSeekPositionUs);
+    discardDownstreamMediaChunks(primarySampleQueue.getReadIndex());
+    return primarySampleQueue.readData(formatHolder, buffer, formatRequired, loadingFinished,
+        lastSeekPositionUs);
   }
 
   @Override
   public void skipToKeyframeBefore(long timeUs) {
-    sampleQueue.skipToKeyframeBefore(timeUs);
+    primarySampleQueue.skipToKeyframeBefore(timeUs);
   }
 
   // Loader.Callback implementation.
@@ -199,20 +260,25 @@ public void skipToKeyframeBefore(long timeUs) {
   @Override
   public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs) {
     chunkSource.onChunkLoadCompleted(loadable);
-    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, primaryTrackType,
+        loadable.trackFormat, loadable.trackSelectionReason, loadable.trackSelectionData,
+        loadable.startTimeUs, loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs,
+        loadable.bytesLoaded());
     callback.onContinueLoadingRequested(this);
   }
 
   @Override
   public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs,
       boolean released) {
-    eventDispatcher.loadCanceled(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+    eventDispatcher.loadCanceled(loadable.dataSpec, loadable.type, primaryTrackType,
+        loadable.trackFormat, loadable.trackSelectionReason, loadable.trackSelectionData,
+        loadable.startTimeUs, loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs,
+        loadable.bytesLoaded());
     if (!released) {
-      sampleQueue.reset(true);
+      primarySampleQueue.reset(true);
+      for (DefaultTrackOutput embeddedSampleQueue : embeddedSampleQueues) {
+        embeddedSampleQueue.reset(true);
+      }
       callback.onContinueLoadingRequested(this);
     }
   }
@@ -229,16 +295,19 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
       if (isMediaChunk) {
         BaseMediaChunk removed = mediaChunks.removeLast();
         Assertions.checkState(removed == loadable);
-        sampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex());
+        primarySampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex(0));
+        for (int i = 0; i < embeddedSampleQueues.length; i++) {
+          embeddedSampleQueues[i].discardUpstreamSamples(removed.getFirstSampleIndex(i + 1));
+        }
         if (mediaChunks.isEmpty()) {
           pendingResetPositionUs = lastSeekPositionUs;
         }
       }
     }
-    eventDispatcher.loadError(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, bytesLoaded, error,
-        canceled);
+    eventDispatcher.loadError(loadable.dataSpec, loadable.type, primaryTrackType,
+        loadable.trackFormat, loadable.trackSelectionReason, loadable.trackSelectionData,
+        loadable.startTimeUs, loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, bytesLoaded,
+        error, canceled);
     if (canceled) {
       callback.onContinueLoadingRequested(this);
       return Loader.DONT_RETRY;
@@ -274,13 +343,13 @@ public boolean continueLoading(long positionUs) {
     if (isMediaChunk(loadable)) {
       pendingResetPositionUs = C.TIME_UNSET;
       BaseMediaChunk mediaChunk = (BaseMediaChunk) loadable;
-      mediaChunk.init(sampleQueue);
+      mediaChunk.init(mediaChunkOutput);
       mediaChunks.add(mediaChunk);
     }
     long elapsedRealtimeMs = loader.startLoading(loadable, this, minLoadableRetryCount);
-    eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-        loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-        loadable.endTimeUs, elapsedRealtimeMs);
+    eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, primaryTrackType,
+        loadable.trackFormat, loadable.trackSelectionReason, loadable.trackSelectionData,
+        loadable.startTimeUs, loadable.endTimeUs, elapsedRealtimeMs);
     return true;
   }
 
@@ -311,10 +380,25 @@ private boolean isMediaChunk(Chunk chunk) {
     return chunk instanceof BaseMediaChunk;
   }
 
-  private boolean isPendingReset() {
+  /* package */ boolean isPendingReset() {
     return pendingResetPositionUs != C.TIME_UNSET;
   }
 
+  private void discardDownstreamMediaChunks(int primaryStreamReadIndex) {
+    while (mediaChunks.size() > 1
+        && mediaChunks.get(1).getFirstSampleIndex(0) <= primaryStreamReadIndex) {
+      mediaChunks.removeFirst();
+    }
+    BaseMediaChunk currentChunk = mediaChunks.getFirst();
+    Format trackFormat = currentChunk.trackFormat;
+    if (!trackFormat.equals(primaryDownstreamTrackFormat)) {
+      eventDispatcher.downstreamFormatChanged(primaryTrackType, trackFormat,
+          currentChunk.trackSelectionReason, currentChunk.trackSelectionData,
+          currentChunk.startTimeUs);
+    }
+    primaryDownstreamTrackFormat = trackFormat;
+  }
+
   /**
    * Discard upstream media chunks until the queue length is equal to the length specified.
    *
@@ -327,16 +411,67 @@ private boolean discardUpstreamMediaChunks(int queueLength) {
     }
     long startTimeUs = 0;
     long endTimeUs = mediaChunks.getLast().endTimeUs;
-
     BaseMediaChunk removed = null;
     while (mediaChunks.size() > queueLength) {
       removed = mediaChunks.removeLast();
       startTimeUs = removed.startTimeUs;
       loadingFinished = false;
     }
-    sampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex());
-    eventDispatcher.upstreamDiscarded(trackType, startTimeUs, endTimeUs);
+    primarySampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex(0));
+    for (int i = 0; i < embeddedSampleQueues.length; i++) {
+      embeddedSampleQueues[i].discardUpstreamSamples(removed.getFirstSampleIndex(i + 1));
+    }
+    eventDispatcher.upstreamDiscarded(primaryTrackType, startTimeUs, endTimeUs);
     return true;
   }
 
+  /**
+   * A {@link SampleStream} embedded in a {@link ChunkSampleStream}.
+   */
+  public final class EmbeddedSampleStream implements SampleStream {
+
+    public final ChunkSampleStream<T> parent;
+
+    private final DefaultTrackOutput sampleQueue;
+    private final int index;
+
+    public EmbeddedSampleStream(ChunkSampleStream<T> parent, DefaultTrackOutput sampleQueue,
+        int index) {
+      this.parent = parent;
+      this.sampleQueue = sampleQueue;
+      this.index = index;
+    }
+
+    @Override
+    public boolean isReady() {
+      return loadingFinished || (!isPendingReset() && !sampleQueue.isEmpty());
+    }
+
+    @Override
+    public void skipToKeyframeBefore(long timeUs) {
+      sampleQueue.skipToKeyframeBefore(timeUs);
+    }
+
+    @Override
+    public void maybeThrowError() throws IOException {
+      // Do nothing. Errors will be thrown from the primary stream.
+    }
+
+    @Override
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
+        boolean formatRequired) {
+      if (isPendingReset()) {
+        return C.RESULT_NOTHING_READ;
+      }
+      return sampleQueue.readData(formatHolder, buffer, formatRequired, loadingFinished,
+          lastSeekPositionUs);
+    }
+
+    public void release() {
+      Assertions.checkState(embeddedTracksSelected[index]);
+      embeddedTracksSelected[index] = false;
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
index a5af3cc42f..cfbefc0c2e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
@@ -17,25 +17,22 @@
 
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
-import com.google.android.exoplayer2.extractor.DefaultTrackOutput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SingleTrackMetadataOutput;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
  * A {@link BaseMediaChunk} that uses an {@link Extractor} to decode sample data.
  */
-public class ContainerMediaChunk extends BaseMediaChunk implements SingleTrackMetadataOutput {
+public class ContainerMediaChunk extends BaseMediaChunk {
 
   private final int chunkCount;
   private final long sampleOffsetUs;
   private final ChunkExtractorWrapper extractorWrapper;
-  private final Format sampleFormat;
 
   private volatile int bytesLoaded;
   private volatile boolean loadCanceled;
@@ -55,19 +52,15 @@
    *     underlying media are being merged into a single load.
    * @param sampleOffsetUs An offset to add to the sample timestamps parsed by the extractor.
    * @param extractorWrapper A wrapped extractor to use for parsing the data.
-   * @param sampleFormat The {@link Format} of the samples in the chunk, if known. May be null if
-   *     the data is known to define its own sample format.
    */
   public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
       int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
-      int chunkIndex, int chunkCount, long sampleOffsetUs, ChunkExtractorWrapper extractorWrapper,
-      Format sampleFormat) {
+      int chunkIndex, int chunkCount, long sampleOffsetUs, ChunkExtractorWrapper extractorWrapper) {
     super(dataSource, dataSpec, trackFormat, trackSelectionReason, trackSelectionData, startTimeUs,
         endTimeUs, chunkIndex);
     this.chunkCount = chunkCount;
     this.sampleOffsetUs = sampleOffsetUs;
     this.extractorWrapper = extractorWrapper;
-    this.sampleFormat = sampleFormat;
   }
 
   @Override
@@ -85,13 +78,6 @@ public final long bytesLoaded() {
     return bytesLoaded;
   }
 
-  // SingleTrackMetadataOutput implementation.
-
-  @Override
-  public final void seekMap(SeekMap seekMap) {
-    // Do nothing.
-  }
-
   // Loadable implementation.
 
   @Override
@@ -113,22 +99,24 @@ public final void load() throws IOException, InterruptedException {
       ExtractorInput input = new DefaultExtractorInput(dataSource,
           loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
       if (bytesLoaded == 0) {
-        // Set the target to ourselves.
-        DefaultTrackOutput trackOutput = getTrackOutput();
-        trackOutput.formatWithOffset(sampleFormat, sampleOffsetUs);
-        extractorWrapper.init(this, trackOutput);
+        // Configure the output and set it as the target for the extractor wrapper.
+        BaseMediaChunkOutput output = getOutput();
+        output.setSampleOffsetUs(sampleOffsetUs);
+        extractorWrapper.init(output);
       }
       // Load and decode the sample data.
       try {
+        Extractor extractor = extractorWrapper.extractor;
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractorWrapper.read(input);
+          result = extractor.read(input, null);
         }
+        Assertions.checkState(result != Extractor.RESULT_SEEK);
       } finally {
         bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
     loadCompleted = true;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
index 99653d323f..0846e7679d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/DataChunk.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.Arrays;
 
@@ -96,7 +97,7 @@ public final void load() throws IOException, InterruptedException {
         consume(data, limit);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
index 388dc63899..69474aa150 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/InitializationChunk.java
@@ -20,29 +20,19 @@
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TrackOutput;
-import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper.SingleTrackMetadataOutput;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
  * A {@link Chunk} that uses an {@link Extractor} to decode initialization data for single track.
  */
-public final class InitializationChunk extends Chunk implements SingleTrackMetadataOutput,
-    TrackOutput {
+public final class InitializationChunk extends Chunk {
 
   private final ChunkExtractorWrapper extractorWrapper;
 
-  // Initialization results. Set by the loader thread and read by any thread that knows loading
-  // has completed. These variables do not need to be volatile, since a memory barrier must occur
-  // for the reading thread to know that loading has completed.
-  private Format sampleFormat;
-  private SeekMap seekMap;
-
   private volatile int bytesLoaded;
   private volatile boolean loadCanceled;
 
@@ -67,55 +57,6 @@ public long bytesLoaded() {
     return bytesLoaded;
   }
 
-  /**
-   * Returns a {@link Format} parsed from the chunk, or null.
-   * <p>
-   * Should be called after loading has completed.
-   */
-  public Format getSampleFormat() {
-    return sampleFormat;
-  }
-
-  /**
-   * Returns a {@link SeekMap} parsed from the chunk, or null.
-   * <p>
-   * Should be called after loading has completed.
-   */
-  public SeekMap getSeekMap() {
-    return seekMap;
-  }
-
-  // SingleTrackMetadataOutput implementation.
-
-  @Override
-  public void seekMap(SeekMap seekMap) {
-    this.seekMap = seekMap;
-  }
-
-  // TrackOutput implementation.
-
-  @Override
-  public void format(Format format) {
-    this.sampleFormat = format;
-  }
-
-  @Override
-  public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
-      throws IOException, InterruptedException {
-    throw new IllegalStateException("Unexpected sample data in initialization chunk");
-  }
-
-  @Override
-  public void sampleData(ParsableByteArray data, int length) {
-    throw new IllegalStateException("Unexpected sample data in initialization chunk");
-  }
-
-  @Override
-  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
-      byte[] encryptionKey) {
-    throw new IllegalStateException("Unexpected sample data in initialization chunk");
-  }
-
   // Loadable implementation.
 
   @Override
@@ -137,20 +78,21 @@ public void load() throws IOException, InterruptedException {
       ExtractorInput input = new DefaultExtractorInput(dataSource,
           loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
       if (bytesLoaded == 0) {
-        // Set the target to ourselves.
-        extractorWrapper.init(this, this);
+        extractorWrapper.init(null);
       }
       // Load and decode the initialization data.
       try {
+        Extractor extractor = extractorWrapper.extractor;
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractorWrapper.read(input);
+          result = extractor.read(input, null);
         }
+        Assertions.checkState(result != Extractor.RESULT_SEEK);
       } finally {
         bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
       }
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
index 3033566950..a008c9cd84 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
@@ -18,8 +18,8 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
-import com.google.android.exoplayer2.extractor.DefaultTrackOutput;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Util;
@@ -30,6 +30,7 @@
  */
 public final class SingleSampleMediaChunk extends BaseMediaChunk {
 
+  private final int trackType;
   private final Format sampleFormat;
 
   private volatile int bytesLoaded;
@@ -45,15 +46,20 @@
    * @param startTimeUs The start time of the media contained by the chunk, in microseconds.
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
    * @param chunkIndex The index of the chunk.
+   * @param trackType The type of the chunk. Typically one of the {@link C} {@code TRACK_TYPE_*}
+   *     constants.
+   * @param sampleFormat The {@link Format} of the sample in the chunk.
    */
   public SingleSampleMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
       int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
-      int chunkIndex, Format sampleFormat) {
+      int chunkIndex, int trackType, Format sampleFormat) {
     super(dataSource, dataSpec, trackFormat, trackSelectionReason, trackSelectionData, startTimeUs,
         endTimeUs, chunkIndex);
+    this.trackType = trackType;
     this.sampleFormat = sampleFormat;
   }
 
+
   @Override
   public boolean isLoadCompleted() {
     return loadCompleted;
@@ -87,8 +93,10 @@ public void load() throws IOException, InterruptedException {
         length += bytesLoaded;
       }
       ExtractorInput extractorInput = new DefaultExtractorInput(dataSource, bytesLoaded, length);
-      DefaultTrackOutput trackOutput = getTrackOutput();
-      trackOutput.formatWithOffset(sampleFormat, 0);
+      BaseMediaChunkOutput output = getOutput();
+      output.setSampleOffsetUs(0);
+      TrackOutput trackOutput = output.track(0, trackType);
+      trackOutput.format(sampleFormat);
       // Load the sample data.
       int result = 0;
       while (result != C.RESULT_END_OF_INPUT) {
@@ -98,7 +106,7 @@ public void load() throws IOException, InterruptedException {
       int sampleSize = bytesLoaded;
       trackOutput.sampleMetadata(startTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
     } finally {
-      dataSource.close();
+      Util.closeQuietly(dataSource);
     }
     loadCompleted = true;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
index 4c943abb48..72f728092c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
@@ -29,7 +29,8 @@
 
     DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
         DashManifest manifest, int periodIndex, int adaptationSetIndex,
-        TrackSelection trackSelection, long elapsedRealtimeOffsetMs);
+        TrackSelection trackSelection, long elapsedRealtimeOffsetMs,
+        boolean enableEventMessageTrack, boolean enableCea608Track);
 
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index 4a24c7c176..5e0541cb31 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -15,25 +15,30 @@
  */
 package com.google.android.exoplayer2.source.dash;
 
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoader;
+import com.google.android.exoplayer2.source.EmptySampleStream;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.chunk.ChunkSampleStream;
+import com.google.android.exoplayer2.source.chunk.ChunkSampleStream.EmbeddedSampleStream;
 import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
-import com.google.android.exoplayer2.source.dash.manifest.Period;
 import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.source.dash.manifest.SchemeValuePair;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
-import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
 
 /**
@@ -50,21 +55,22 @@
   private final LoaderErrorThrower manifestLoaderErrorThrower;
   private final Allocator allocator;
   private final TrackGroupArray trackGroups;
+  private final EmbeddedTrackInfo[] embeddedTrackInfos;
 
   private Callback callback;
   private ChunkSampleStream<DashChunkSource>[] sampleStreams;
   private CompositeSequenceableLoader sequenceableLoader;
   private DashManifest manifest;
-  private int index;
-  private Period period;
+  private int periodIndex;
+  private List<AdaptationSet> adaptationSets;
 
-  public DashMediaPeriod(int id, DashManifest manifest, int index,
+  public DashMediaPeriod(int id, DashManifest manifest, int periodIndex,
       DashChunkSource.Factory chunkSourceFactory,  int minLoadableRetryCount,
       EventDispatcher eventDispatcher, long elapsedRealtimeOffset,
       LoaderErrorThrower manifestLoaderErrorThrower, Allocator allocator) {
     this.id = id;
     this.manifest = manifest;
-    this.index = index;
+    this.periodIndex = periodIndex;
     this.chunkSourceFactory = chunkSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventDispatcher = eventDispatcher;
@@ -73,17 +79,19 @@ public DashMediaPeriod(int id, DashManifest manifest, int index,
     this.allocator = allocator;
     sampleStreams = newSampleStreamArray(0);
     sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
-    period = manifest.getPeriod(index);
-    trackGroups = buildTrackGroups(period);
+    adaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
+    Pair<TrackGroupArray, EmbeddedTrackInfo[]> result = buildTrackGroups(adaptationSets);
+    trackGroups = result.first;
+    embeddedTrackInfos = result.second;
   }
 
-  public void updateManifest(DashManifest manifest, int index) {
+  public void updateManifest(DashManifest manifest, int periodIndex) {
     this.manifest = manifest;
-    this.index = index;
-    period = manifest.getPeriod(index);
+    this.periodIndex = periodIndex;
+    adaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
     if (sampleStreams != null) {
       for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {
-        sampleStream.getChunkSource().updateManifest(manifest, index);
+        sampleStream.getChunkSource().updateManifest(manifest, periodIndex);
       }
       callback.onContinueLoadingRequested(this);
     }
@@ -114,31 +122,75 @@ public TrackGroupArray getTrackGroups() {
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-    ArrayList<ChunkSampleStream<DashChunkSource>> sampleStreamsList = new ArrayList<>();
+    int adaptationSetCount = adaptationSets.size();
+    HashMap<Integer, ChunkSampleStream<DashChunkSource>> primarySampleStreams = new HashMap<>();
+    // First pass for primary tracks.
     for (int i = 0; i < selections.length; i++) {
-      if (streams[i] != null) {
+      if (streams[i] instanceof ChunkSampleStream) {
         @SuppressWarnings("unchecked")
         ChunkSampleStream<DashChunkSource> stream = (ChunkSampleStream<DashChunkSource>) streams[i];
         if (selections[i] == null || !mayRetainStreamFlags[i]) {
           stream.release();
           streams[i] = null;
         } else {
-          sampleStreamsList.add(stream);
+          int adaptationSetIndex = trackGroups.indexOf(selections[i].getTrackGroup());
+          primarySampleStreams.put(adaptationSetIndex, stream);
         }
       }
       if (streams[i] == null && selections[i] != null) {
-        ChunkSampleStream<DashChunkSource> stream = buildSampleStream(selections[i], positionUs);
-        sampleStreamsList.add(stream);
-        streams[i] = stream;
-        streamResetFlags[i] = true;
+        int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
+        if (trackGroupIndex < adaptationSetCount) {
+          ChunkSampleStream<DashChunkSource> stream = buildSampleStream(trackGroupIndex,
+              selections[i], positionUs);
+          primarySampleStreams.put(trackGroupIndex, stream);
+          streams[i] = stream;
+          streamResetFlags[i] = true;
+        }
+      }
+    }
+    // Second pass for embedded tracks.
+    for (int i = 0; i < selections.length; i++) {
+      if ((streams[i] instanceof EmbeddedSampleStream || streams[i] instanceof EmptySampleStream)
+          && (selections[i] == null || !mayRetainStreamFlags[i])) {
+        // The stream is for an embedded track and is either no longer selected or needs replacing.
+        releaseIfEmbeddedSampleStream(streams[i]);
+        streams[i] = null;
+      }
+      // We need to consider replacing the stream even if it's non-null because the primary stream
+      // may have been replaced, selected or deselected.
+      if (selections[i] != null) {
+        int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
+        if (trackGroupIndex >= adaptationSetCount) {
+          int embeddedTrackIndex = trackGroupIndex - adaptationSetCount;
+          EmbeddedTrackInfo embeddedTrackInfo = embeddedTrackInfos[embeddedTrackIndex];
+          int adaptationSetIndex = embeddedTrackInfo.adaptationSetIndex;
+          ChunkSampleStream<?> primaryStream = primarySampleStreams.get(adaptationSetIndex);
+          SampleStream stream = streams[i];
+          boolean mayRetainStream = primaryStream == null ? stream instanceof EmptySampleStream
+              : (stream instanceof EmbeddedSampleStream
+                  && ((EmbeddedSampleStream) stream).parent == primaryStream);
+          if (!mayRetainStream) {
+            releaseIfEmbeddedSampleStream(stream);
+            streams[i] = primaryStream == null ? new EmptySampleStream()
+                : primaryStream.selectEmbeddedTrack(positionUs, embeddedTrackInfo.trackType);
+            streamResetFlags[i] = true;
+          }
+        }
       }
     }
-    sampleStreams = newSampleStreamArray(sampleStreamsList.size());
-    sampleStreamsList.toArray(sampleStreams);
+    sampleStreams = newSampleStreamArray(primarySampleStreams.size());
+    primarySampleStreams.values().toArray(sampleStreams);
     sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
     return positionUs;
   }
 
+  @Override
+  public void discardBuffer(long positionUs) {
+    for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {
+      sampleStream.discardUnselectedEmbeddedTracksTo(positionUs);
+    }
+  }
+
   @Override
   public boolean continueLoading(long positionUs) {
     return sequenceableLoader.continueLoading(positionUs);
@@ -183,29 +235,98 @@ public void onContinueLoadingRequested(ChunkSampleStream<DashChunkSource> sample
 
   // Internal methods.
 
-  private static TrackGroupArray buildTrackGroups(Period period) {
-    TrackGroup[] trackGroupArray = new TrackGroup[period.adaptationSets.size()];
-    for (int i = 0; i < period.adaptationSets.size(); i++) {
-      AdaptationSet adaptationSet = period.adaptationSets.get(i);
+  private static Pair<TrackGroupArray, EmbeddedTrackInfo[]> buildTrackGroups(
+      List<AdaptationSet> adaptationSets) {
+    int adaptationSetCount = adaptationSets.size();
+    int embeddedTrackCount = getEmbeddedTrackCount(adaptationSets);
+    TrackGroup[] trackGroupArray = new TrackGroup[adaptationSetCount + embeddedTrackCount];
+    EmbeddedTrackInfo[] embeddedTrackInfos = new EmbeddedTrackInfo[embeddedTrackCount];
+
+    int embeddedTrackIndex = 0;
+    for (int i = 0; i < adaptationSetCount; i++) {
+      AdaptationSet adaptationSet = adaptationSets.get(i);
       List<Representation> representations = adaptationSet.representations;
       Format[] formats = new Format[representations.size()];
       for (int j = 0; j < formats.length; j++) {
         formats[j] = representations.get(j).format;
       }
       trackGroupArray[i] = new TrackGroup(formats);
+      if (hasEventMessageTrack(adaptationSet)) {
+        Format format = Format.createSampleFormat(adaptationSet.id + ":emsg",
+            MimeTypes.APPLICATION_EMSG, null, Format.NO_VALUE, null);
+        trackGroupArray[adaptationSetCount + embeddedTrackIndex] = new TrackGroup(format);
+        embeddedTrackInfos[embeddedTrackIndex++] = new EmbeddedTrackInfo(i, C.TRACK_TYPE_METADATA);
+      }
+      if (hasCea608Track(adaptationSet)) {
+        Format format = Format.createTextSampleFormat(adaptationSet.id + ":cea608",
+            MimeTypes.APPLICATION_CEA608, null, Format.NO_VALUE, 0, null, null);
+        trackGroupArray[adaptationSetCount + embeddedTrackIndex] = new TrackGroup(format);
+        embeddedTrackInfos[embeddedTrackIndex++] = new EmbeddedTrackInfo(i, C.TRACK_TYPE_TEXT);
+      }
     }
-    return new TrackGroupArray(trackGroupArray);
+
+    return Pair.create(new TrackGroupArray(trackGroupArray), embeddedTrackInfos);
   }
 
-  private ChunkSampleStream<DashChunkSource> buildSampleStream(TrackSelection selection,
-      long positionUs) {
-    int adaptationSetIndex = trackGroups.indexOf(selection.getTrackGroup());
-    AdaptationSet adaptationSet = period.adaptationSets.get(adaptationSetIndex);
+  private ChunkSampleStream<DashChunkSource> buildSampleStream(int adaptationSetIndex,
+      TrackSelection selection, long positionUs) {
+    AdaptationSet adaptationSet = adaptationSets.get(adaptationSetIndex);
+    int embeddedTrackCount = 0;
+    int[] embeddedTrackTypes = new int[2];
+    boolean enableEventMessageTrack = hasEventMessageTrack(adaptationSet);
+    if (enableEventMessageTrack) {
+      embeddedTrackTypes[embeddedTrackCount++] = C.TRACK_TYPE_METADATA;
+    }
+    boolean enableCea608Track = hasCea608Track(adaptationSet);
+    if (enableCea608Track) {
+      embeddedTrackTypes[embeddedTrackCount++] = C.TRACK_TYPE_TEXT;
+    }
+    if (embeddedTrackCount < embeddedTrackTypes.length) {
+      embeddedTrackTypes = Arrays.copyOf(embeddedTrackTypes, embeddedTrackCount);
+    }
     DashChunkSource chunkSource = chunkSourceFactory.createDashChunkSource(
-        manifestLoaderErrorThrower, manifest, index, adaptationSetIndex, selection,
-        elapsedRealtimeOffset);
-    return new ChunkSampleStream<>(adaptationSet.type, chunkSource, this, allocator, positionUs,
-        minLoadableRetryCount, eventDispatcher);
+        manifestLoaderErrorThrower, manifest, periodIndex, adaptationSetIndex, selection,
+        elapsedRealtimeOffset, enableEventMessageTrack, enableCea608Track);
+    ChunkSampleStream<DashChunkSource> stream = new ChunkSampleStream<>(adaptationSet.type,
+        embeddedTrackTypes, chunkSource, this, allocator, positionUs, minLoadableRetryCount,
+        eventDispatcher);
+    return stream;
+  }
+
+  private static int getEmbeddedTrackCount(List<AdaptationSet> adaptationSets) {
+    int embeddedTrackCount = 0;
+    for (int i = 0; i < adaptationSets.size(); i++) {
+      AdaptationSet adaptationSet = adaptationSets.get(i);
+      if (hasEventMessageTrack(adaptationSet)) {
+        embeddedTrackCount++;
+      }
+      if (hasCea608Track(adaptationSet)) {
+        embeddedTrackCount++;
+      }
+    }
+    return embeddedTrackCount;
+  }
+
+  private static boolean hasEventMessageTrack(AdaptationSet adaptationSet) {
+    List<Representation> representations = adaptationSet.representations;
+    for (int i = 0; i < representations.size(); i++) {
+      Representation representation = representations.get(i);
+      if (!representation.inbandEventStreams.isEmpty()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private static boolean hasCea608Track(AdaptationSet adaptationSet) {
+    List<SchemeValuePair> descriptors = adaptationSet.accessibilityDescriptors;
+    for (int i = 0; i < descriptors.size(); i++) {
+      SchemeValuePair descriptor = descriptors.get(i);
+      if ("urn:scte:dash:cc:cea-608:2015".equals(descriptor.schemeIdUri)) {
+        return true;
+      }
+    }
+    return false;
   }
 
   @SuppressWarnings("unchecked")
@@ -213,4 +334,22 @@ private static TrackGroupArray buildTrackGroups(Period period) {
     return new ChunkSampleStream[length];
   }
 
+  private static void releaseIfEmbeddedSampleStream(SampleStream sampleStream) {
+    if (sampleStream instanceof EmbeddedSampleStream) {
+      ((EmbeddedSampleStream) sampleStream).release();
+    }
+  }
+
+  private static final class EmbeddedTrackInfo {
+
+    public final int adaptationSetIndex;
+    public final int trackType;
+
+    public EmbeddedTrackInfo(int adaptationSetIndex, int trackType) {
+      this.adaptationSetIndex = adaptationSetIndex;
+      this.trackType = trackType;
+    }
+
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index 99845c057e..eec99521f1 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -572,22 +572,28 @@ public static PeriodSeekInfo createPeriodSeekInfo(
       long availableStartTimeUs = 0;
       long availableEndTimeUs = Long.MAX_VALUE;
       boolean isIndexExplicit = false;
+      boolean seenEmptyIndex = false;
       for (int i = 0; i < adaptationSetCount; i++) {
         DashSegmentIndex index = period.adaptationSets.get(i).representations.get(0).getIndex();
         if (index == null) {
           return new PeriodSeekInfo(true, 0, durationUs);
         }
-        int firstSegmentNum = index.getFirstSegmentNum();
-        int lastSegmentNum = index.getLastSegmentNum(durationUs);
         isIndexExplicit |= index.isExplicit();
-        long adaptationSetAvailableStartTimeUs = index.getTimeUs(firstSegmentNum);
-        availableStartTimeUs = Math.max(availableStartTimeUs, adaptationSetAvailableStartTimeUs);
-        if (lastSegmentNum != DashSegmentIndex.INDEX_UNBOUNDED) {
-          long adaptationSetAvailableEndTimeUs = index.getTimeUs(lastSegmentNum)
-              + index.getDurationUs(lastSegmentNum, durationUs);
-          availableEndTimeUs = Math.min(availableEndTimeUs, adaptationSetAvailableEndTimeUs);
-        } else {
-          // The available end time is unmodified, because this index is unbounded.
+        int segmentCount = index.getSegmentCount(durationUs);
+        if (segmentCount == 0) {
+          seenEmptyIndex = true;
+          availableStartTimeUs = 0;
+          availableEndTimeUs = 0;
+        } else if (!seenEmptyIndex) {
+          int firstSegmentNum = index.getFirstSegmentNum();
+          long adaptationSetAvailableStartTimeUs = index.getTimeUs(firstSegmentNum);
+          availableStartTimeUs = Math.max(availableStartTimeUs, adaptationSetAvailableStartTimeUs);
+          if (segmentCount != DashSegmentIndex.INDEX_UNBOUNDED) {
+            int lastSegmentNum = firstSegmentNum + segmentCount - 1;
+            long adaptationSetAvailableEndTimeUs = index.getTimeUs(lastSegmentNum)
+                + index.getDurationUs(lastSegmentNum, durationUs);
+            availableEndTimeUs = Math.min(availableEndTimeUs, adaptationSetAvailableEndTimeUs);
+          }
         }
       }
       return new PeriodSeekInfo(isIndexExplicit, availableStartTimeUs, availableEndTimeUs);
@@ -704,8 +710,8 @@ private long getAdjustedWindowDefaultStartPositionUs(long defaultPositionProject
       // not correspond to the start of a segment in both, but this is an edge case.
       DashSegmentIndex snapIndex = period.adaptationSets.get(videoAdaptationSetIndex)
           .representations.get(0).getIndex();
-      if (snapIndex == null) {
-        // Video adaptation set does not include an index for snapping.
+      if (snapIndex == null || snapIndex.getSegmentCount(periodDurationUs) == 0) {
+        // Video adaptation set does not include a non-empty index for snapping.
         return windowDefaultStartPositionUs;
       }
       int segmentNum = snapIndex.getSegmentNum(defaultStartPositionInPeriodUs, periodDurationUs);
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashSegmentIndex.java
index d002831c4f..2ddc7f4f80 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashSegmentIndex.java
@@ -26,12 +26,10 @@
   int INDEX_UNBOUNDED = -1;
 
   /**
-   * Returns the segment number of the segment containing a given media time.
-   * <p>
-   * If the given media time is outside the range of the index, then the returned segment number is
-   * clamped to {@link #getFirstSegmentNum()} (if the given media time is earlier the start of the
-   * first segment) or {@link #getLastSegmentNum(long)} (if the given media time is later then the
-   * end of the last segment).
+   * Returns {@code getFirstSegmentNum()} if the index has no segments or if the given media time is
+   * earlier than the start of the first segment. Returns {@code getFirstSegmentNum() +
+   * getSegmentCount() - 1} if the given media time is later than the end of the last segment.
+   * Otherwise, returns the segment number of the segment containing the given media time.
    *
    * @param timeUs The time in microseconds.
    * @param periodDurationUs The duration of the enclosing period in microseconds, or
@@ -74,7 +72,7 @@
   int getFirstSegmentNum();
 
   /**
-   * Returns the segment number of the last segment, or {@link #INDEX_UNBOUNDED}.
+   * Returns the number of segments in the index, or {@link #INDEX_UNBOUNDED}.
    * <p>
    * An unbounded index occurs if a dynamic manifest uses SegmentTemplate elements without a
    * SegmentTimeline element, and if the period duration is not yet known. In this case the caller
@@ -82,9 +80,9 @@
    *
    * @param periodDurationUs The duration of the enclosing period in microseconds, or
    *     {@link C#TIME_UNSET} if the period's duration is not yet known.
-   * @return The segment number of the last segment, or {@link #INDEX_UNBOUNDED}.
+   * @return The number of segments in the index, or {@link #INDEX_UNBOUNDED}.
    */
-  int getLastSegmentNum(long periodDurationUs);
+  int getSegmentCount(long periodDurationUs);
 
   /**
    * Returns true if segments are defined explicitly by the index.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
new file mode 100644
index 0000000000..8fca21b2e0
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.extractor.ChunkIndex;
+import com.google.android.exoplayer2.extractor.Extractor;
+import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
+import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
+import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper;
+import com.google.android.exoplayer2.source.chunk.InitializationChunk;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
+import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSourceInputStream;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.io.IOException;
+
+/**
+ * Utility methods for DASH streams.
+ */
+public final class DashUtil {
+
+  /**
+   * Loads a DASH manifest.
+   *
+   * @param dataSource The {@link HttpDataSource} from which the manifest should be read.
+   * @param manifestUriString The URI of the manifest to be read.
+   * @return An instance of {@link DashManifest}.
+   * @throws IOException If an error occurs reading data from the stream.
+   * @see DashManifestParser
+   */
+  public static DashManifest loadManifest(DataSource dataSource, String manifestUriString)
+      throws IOException {
+    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource,
+        new DataSpec(Uri.parse(manifestUriString), DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
+    try {
+      inputStream.open();
+      DashManifestParser parser = new DashManifestParser();
+      return parser.parse(dataSource.getUri(), inputStream);
+    } finally {
+      inputStream.close();
+    }
+  }
+
+  /**
+   * Loads initialization data for the {@code representation} and returns the sample {@link
+   * Format}.
+   *
+   * @param dataSource The source from which the data should be loaded.
+   * @param representation The representation which initialization chunk belongs to.
+   * @return the sample {@link Format} of the given representation.
+   * @throws IOException Thrown when there is an error while loading.
+   * @throws InterruptedException Thrown if the thread was interrupted.
+   */
+  public static Format loadSampleFormat(DataSource dataSource, Representation representation)
+      throws IOException, InterruptedException {
+    ChunkExtractorWrapper extractorWrapper = loadInitializationData(dataSource, representation,
+        false);
+    return extractorWrapper == null ? null : extractorWrapper.getSampleFormats()[0];
+  }
+
+  /**
+   * Loads initialization and index data for the {@code representation} and returns the {@link
+   * ChunkIndex}.
+   *
+   * @param dataSource The source from which the data should be loaded.
+   * @param representation The representation which initialization chunk belongs to.
+   * @return {@link ChunkIndex} of the given representation.
+   * @throws IOException Thrown when there is an error while loading.
+   * @throws InterruptedException Thrown if the thread was interrupted.
+   */
+  public static ChunkIndex loadChunkIndex(DataSource dataSource, Representation representation)
+      throws IOException, InterruptedException {
+    ChunkExtractorWrapper extractorWrapper = loadInitializationData(dataSource, representation,
+        true);
+    return extractorWrapper == null ? null : (ChunkIndex) extractorWrapper.getSeekMap();
+  }
+
+  /**
+   * Loads initialization data for the {@code representation} and optionally index data then
+   * returns a {@link ChunkExtractorWrapper} which contains the output.
+   *
+   * @param dataSource The source from which the data should be loaded.
+   * @param representation The representation which initialization chunk belongs to.
+   * @param loadIndex Whether to load index data too.
+   * @return A {@link ChunkExtractorWrapper} for the {@code representation}, or null if no
+   *     initialization or (if requested) index data exists.
+   * @throws IOException Thrown when there is an error while loading.
+   * @throws InterruptedException Thrown if the thread was interrupted.
+   */
+  private static ChunkExtractorWrapper loadInitializationData(DataSource dataSource,
+      Representation representation, boolean loadIndex)
+      throws IOException, InterruptedException {
+    RangedUri initializationUri = representation.getInitializationUri();
+    if (initializationUri == null) {
+      return null;
+    }
+    ChunkExtractorWrapper extractorWrapper = newWrappedExtractor(representation.format);
+    RangedUri requestUri;
+    if (loadIndex) {
+      RangedUri indexUri = representation.getIndexUri();
+      if (indexUri == null) {
+        return null;
+      }
+      // It's common for initialization and index data to be stored adjacently. Attempt to merge
+      // the two requests together to request both at once.
+      requestUri = initializationUri.attemptMerge(indexUri, representation.baseUrl);
+      if (requestUri == null) {
+        loadInitializationData(dataSource, representation, extractorWrapper, initializationUri);
+        requestUri = indexUri;
+      }
+    } else {
+      requestUri = initializationUri;
+    }
+    loadInitializationData(dataSource, representation, extractorWrapper, requestUri);
+    return extractorWrapper;
+  }
+
+  private static void loadInitializationData(DataSource dataSource,
+      Representation representation, ChunkExtractorWrapper extractorWrapper, RangedUri requestUri)
+      throws IOException, InterruptedException {
+    DataSpec dataSpec = new DataSpec(requestUri.resolveUri(representation.baseUrl),
+        requestUri.start, requestUri.length, representation.getCacheKey());
+    InitializationChunk initializationChunk = new InitializationChunk(dataSource, dataSpec,
+        representation.format, C.SELECTION_REASON_UNKNOWN, null /* trackSelectionData */,
+        extractorWrapper);
+    initializationChunk.load();
+  }
+
+  private static ChunkExtractorWrapper newWrappedExtractor(Format format) {
+    String mimeType = format.containerMimeType;
+    boolean isWebm = mimeType.startsWith(MimeTypes.VIDEO_WEBM)
+        || mimeType.startsWith(MimeTypes.AUDIO_WEBM);
+    Extractor extractor = isWebm ? new MatroskaExtractor() : new FragmentedMp4Extractor();
+    return new ChunkExtractorWrapper(extractor, format);
+  }
+
+  private DashUtil() {}
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
index 9e48bc2c79..40f3448f6a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
@@ -28,9 +28,8 @@
 
   /**
    * @param chunkIndex The {@link ChunkIndex} to wrap.
-   * @param uri The URI where the data is located.
    */
-  public DashWrappingSegmentIndex(ChunkIndex chunkIndex, String uri) {
+  public DashWrappingSegmentIndex(ChunkIndex chunkIndex) {
     this.chunkIndex = chunkIndex;
   }
 
@@ -40,8 +39,8 @@ public int getFirstSegmentNum() {
   }
 
   @Override
-  public int getLastSegmentNum(long periodDurationUs) {
-    return chunkIndex.length - 1;
+  public int getSegmentCount(long periodDurationUs) {
+    return chunkIndex.length;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index 0e3d127796..a6e909ddac 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -34,6 +34,7 @@
 import com.google.android.exoplayer2.source.chunk.InitializationChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.source.chunk.SingleSampleMediaChunk;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
 import com.google.android.exoplayer2.source.dash.manifest.Representation;
@@ -69,11 +70,12 @@ public Factory(DataSource.Factory dataSourceFactory, int maxSegmentsPerLoad) {
     @Override
     public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
         DashManifest manifest, int periodIndex, int adaptationSetIndex,
-        TrackSelection trackSelection, long elapsedRealtimeOffsetMs) {
+        TrackSelection trackSelection, long elapsedRealtimeOffsetMs,
+        boolean enableEventMessageTrack, boolean enableCea608Track) {
       DataSource dataSource = dataSourceFactory.createDataSource();
       return new DefaultDashChunkSource(manifestLoaderErrorThrower, manifest, periodIndex,
           adaptationSetIndex, trackSelection, dataSource, elapsedRealtimeOffsetMs,
-          maxSegmentsPerLoad);
+          maxSegmentsPerLoad, enableEventMessageTrack, enableCea608Track);
     }
 
   }
@@ -105,10 +107,15 @@ public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderEr
    * @param maxSegmentsPerLoad The maximum number of segments to combine into a single request.
    *     Note that segments will only be combined if their {@link Uri}s are the same and if their
    *     data ranges are adjacent.
+   * @param enableEventMessageTrack Whether the chunks generated by the source may output an event
+   *     message track.
+   * @param enableEventMessageTrack Whether the chunks generated by the source may output a CEA-608
+   *     track.
    */
   public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
       DashManifest manifest, int periodIndex, int adaptationSetIndex, TrackSelection trackSelection,
-      DataSource dataSource, long elapsedRealtimeOffsetMs, int maxSegmentsPerLoad) {
+      DataSource dataSource, long elapsedRealtimeOffsetMs, int maxSegmentsPerLoad,
+      boolean enableEventMessageTrack, boolean enableCea608Track) {
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.manifest = manifest;
     this.adaptationSetIndex = adaptationSetIndex;
@@ -119,11 +126,13 @@ public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
     this.maxSegmentsPerLoad = maxSegmentsPerLoad;
 
     long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
-    List<Representation> representations = getRepresentations();
+    AdaptationSet adaptationSet = getAdaptationSet();
+    List<Representation> representations = adaptationSet.representations;
     representationHolders = new RepresentationHolder[trackSelection.length()];
     for (int i = 0; i < representationHolders.length; i++) {
       Representation representation = representations.get(trackSelection.getIndexInTrackGroup(i));
-      representationHolders[i] = new RepresentationHolder(periodDurationUs, representation);
+      representationHolders[i] = new RepresentationHolder(periodDurationUs, representation,
+          enableEventMessageTrack, enableCea608Track, adaptationSet.type);
     }
   }
 
@@ -133,7 +142,7 @@ public void updateManifest(DashManifest newManifest, int newPeriodIndex) {
       manifest = newManifest;
       periodIndex = newPeriodIndex;
       long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
-      List<Representation> representations = getRepresentations();
+      List<Representation> representations = getAdaptationSet().representations;
       for (int i = 0; i < representationHolders.length; i++) {
         Representation representation = representations.get(trackSelection.getIndexInTrackGroup(i));
         representationHolders[i].updateRepresentation(periodDurationUs, representation);
@@ -171,32 +180,37 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
 
     RepresentationHolder representationHolder =
         representationHolders[trackSelection.getSelectedIndex()];
-    Representation selectedRepresentation = representationHolder.representation;
-    DashSegmentIndex segmentIndex = representationHolder.segmentIndex;
-
-    RangedUri pendingInitializationUri = null;
-    RangedUri pendingIndexUri = null;
-    Format sampleFormat = representationHolder.sampleFormat;
-    if (sampleFormat == null) {
-      pendingInitializationUri = selectedRepresentation.getInitializationUri();
-    }
-    if (segmentIndex == null) {
-      pendingIndexUri = selectedRepresentation.getIndexUri();
+
+    if (representationHolder.extractorWrapper != null) {
+      Representation selectedRepresentation = representationHolder.representation;
+      RangedUri pendingInitializationUri = null;
+      RangedUri pendingIndexUri = null;
+      if (representationHolder.extractorWrapper.getSampleFormats() == null) {
+        pendingInitializationUri = selectedRepresentation.getInitializationUri();
+      }
+      if (representationHolder.segmentIndex == null) {
+        pendingIndexUri = selectedRepresentation.getIndexUri();
+      }
+      if (pendingInitializationUri != null || pendingIndexUri != null) {
+        // We have initialization and/or index requests to make.
+        out.chunk = newInitializationChunk(representationHolder, dataSource,
+            trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
+            trackSelection.getSelectionData(), pendingInitializationUri, pendingIndexUri);
+        return;
+      }
     }
-    if (pendingInitializationUri != null || pendingIndexUri != null) {
-      // We have initialization and/or index requests to make.
-      Chunk initializationChunk = newInitializationChunk(representationHolder, dataSource,
-          trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
-          trackSelection.getSelectionData(), pendingInitializationUri, pendingIndexUri);
-      out.chunk = initializationChunk;
+
+    long nowUs = getNowUnixTimeUs();
+    int availableSegmentCount = representationHolder.getSegmentCount();
+    if (availableSegmentCount == 0) {
+      // The index doesn't define any segments.
+      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
       return;
     }
 
-    long nowUs = getNowUnixTimeUs();
     int firstAvailableSegmentNum = representationHolder.getFirstSegmentNum();
-    int lastAvailableSegmentNum = representationHolder.getLastSegmentNum();
-    boolean indexUnbounded = lastAvailableSegmentNum == DashSegmentIndex.INDEX_UNBOUNDED;
-    if (indexUnbounded) {
+    int lastAvailableSegmentNum;
+    if (availableSegmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
       // The index is itself unbounded. We need to use the current time to calculate the range of
       // available segments.
       long liveEdgeTimeUs = nowUs - manifest.availabilityStartTime * 1000;
@@ -210,6 +224,8 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
       // getSegmentNum(liveEdgeTimestampUs) will not be completed yet, so subtract one to get the
       // index of the last completed segment.
       lastAvailableSegmentNum = representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs) - 1;
+    } else {
+      lastAvailableSegmentNum = firstAvailableSegmentNum + availableSegmentCount - 1;
     }
 
     int segmentNum;
@@ -233,10 +249,9 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, Chu
     }
 
     int maxSegmentCount = Math.min(maxSegmentsPerLoad, lastAvailableSegmentNum - segmentNum + 1);
-    Chunk nextMediaChunk = newMediaChunk(representationHolder, dataSource,
-        trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
-        trackSelection.getSelectionData(), sampleFormat, segmentNum, maxSegmentCount);
-    out.chunk = nextMediaChunk;
+    out.chunk = newMediaChunk(representationHolder, dataSource, trackSelection.getSelectedFormat(),
+        trackSelection.getSelectionReason(), trackSelection.getSelectionData(), segmentNum,
+        maxSegmentCount);
   }
 
   @Override
@@ -245,18 +260,13 @@ public void onChunkLoadCompleted(Chunk chunk) {
       InitializationChunk initializationChunk = (InitializationChunk) chunk;
       RepresentationHolder representationHolder =
           representationHolders[trackSelection.indexOf(initializationChunk.trackFormat)];
-      Format sampleFormat = initializationChunk.getSampleFormat();
-      if (sampleFormat != null) {
-        representationHolder.setSampleFormat(sampleFormat);
-      }
       // The null check avoids overwriting an index obtained from the manifest with one obtained
       // from the stream. If the manifest defines an index then the stream shouldn't, but in cases
       // where it does we should ignore it.
       if (representationHolder.segmentIndex == null) {
-        SeekMap seekMap = initializationChunk.getSeekMap();
+        SeekMap seekMap = representationHolder.extractorWrapper.getSeekMap();
         if (seekMap != null) {
-          representationHolder.segmentIndex = new DashWrappingSegmentIndex((ChunkIndex) seekMap,
-              initializationChunk.dataSpec.uri.toString());
+          representationHolder.segmentIndex = new DashWrappingSegmentIndex((ChunkIndex) seekMap);
         }
       }
     }
@@ -273,10 +283,13 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
         && ((InvalidResponseCodeException) e).responseCode == 404) {
       RepresentationHolder representationHolder =
           representationHolders[trackSelection.indexOf(chunk.trackFormat)];
-      int lastAvailableSegmentNum = representationHolder.getLastSegmentNum();
-      if (((MediaChunk) chunk).getNextChunkIndex() > lastAvailableSegmentNum) {
-        missingLastSegment = true;
-        return true;
+      int segmentCount = representationHolder.getSegmentCount();
+      if (segmentCount != DashSegmentIndex.INDEX_UNBOUNDED && segmentCount != 0) {
+        int lastAvailableSegmentNum = representationHolder.getFirstSegmentNum() + segmentCount - 1;
+        if (((MediaChunk) chunk).getNextChunkIndex() > lastAvailableSegmentNum) {
+          missingLastSegment = true;
+          return true;
+        }
       }
     }
     // Blacklist if appropriate.
@@ -286,8 +299,8 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
 
   // Private methods.
 
-  private List<Representation> getRepresentations() {
-    return manifest.getPeriod(periodIndex).adaptationSets.get(adaptationSetIndex).representations;
+  private AdaptationSet getAdaptationSet() {
+    return manifest.getPeriod(periodIndex).adaptationSets.get(adaptationSetIndex);
   }
 
   private long getNowUnixTimeUs() {
@@ -321,7 +334,7 @@ private static Chunk newInitializationChunk(RepresentationHolder representationH
 
   private static Chunk newMediaChunk(RepresentationHolder representationHolder,
       DataSource dataSource, Format trackFormat, int trackSelectionReason,
-      Object trackSelectionData, Format sampleFormat, int firstSegmentNum, int maxSegmentCount) {
+      Object trackSelectionData, int firstSegmentNum, int maxSegmentCount) {
     Representation representation = representationHolder.representation;
     long startTimeUs = representationHolder.getSegmentStartTimeUs(firstSegmentNum);
     RangedUri segmentUri = representationHolder.getSegmentUrl(firstSegmentNum);
@@ -331,7 +344,8 @@ private static Chunk newMediaChunk(RepresentationHolder representationHolder,
       DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(baseUrl),
           segmentUri.start, segmentUri.length, representation.getCacheKey());
       return new SingleSampleMediaChunk(dataSource, dataSpec, trackFormat, trackSelectionReason,
-          trackSelectionData, startTimeUs, endTimeUs, firstSegmentNum, trackFormat);
+          trackSelectionData, startTimeUs, endTimeUs, firstSegmentNum,
+          representationHolder.trackType, trackFormat);
     } else {
       int segmentCount = 1;
       for (int i = 1; i < maxSegmentCount; i++) {
@@ -350,7 +364,7 @@ private static Chunk newMediaChunk(RepresentationHolder representationHolder,
       long sampleOffsetUs = -representation.presentationTimeOffsetUs;
       return new ContainerMediaChunk(dataSource, dataSpec, trackFormat, trackSelectionReason,
           trackSelectionData, startTimeUs, endTimeUs, firstSegmentNum, segmentCount,
-          sampleOffsetUs, representationHolder.extractorWrapper, sampleFormat);
+          sampleOffsetUs, representationHolder.extractorWrapper);
     }
   }
 
@@ -358,45 +372,46 @@ private static Chunk newMediaChunk(RepresentationHolder representationHolder,
 
   protected static final class RepresentationHolder {
 
+    public final int trackType;
     public final ChunkExtractorWrapper extractorWrapper;
 
     public Representation representation;
     public DashSegmentIndex segmentIndex;
-    public Format sampleFormat;
 
     private long periodDurationUs;
     private int segmentNumShift;
 
-    public RepresentationHolder(long periodDurationUs, Representation representation) {
+    public RepresentationHolder(long periodDurationUs, Representation representation,
+        boolean enableEventMessageTrack, boolean enableCea608Track, int trackType) {
       this.periodDurationUs = periodDurationUs;
       this.representation = representation;
+      this.trackType = trackType;
       String containerMimeType = representation.format.containerMimeType;
       if (mimeTypeIsRawText(containerMimeType)) {
         extractorWrapper = null;
       } else {
-        boolean resendFormatOnInit = false;
         Extractor extractor;
         if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
           extractor = new RawCcExtractor(representation.format);
-          resendFormatOnInit = true;
         } else if (mimeTypeIsWebm(containerMimeType)) {
           extractor = new MatroskaExtractor();
         } else {
-          extractor = new FragmentedMp4Extractor();
+          int flags = 0;
+          if (enableEventMessageTrack) {
+            flags |= FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK;
+          }
+          if (enableCea608Track) {
+            flags |= FragmentedMp4Extractor.FLAG_ENABLE_CEA608_TRACK;
+          }
+          extractor = new FragmentedMp4Extractor(flags);
         }
         // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
         // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
-        extractorWrapper = new ChunkExtractorWrapper(extractor,
-            representation.format, true /* preferManifestDrmInitData */,
-            resendFormatOnInit);
+        extractorWrapper = new ChunkExtractorWrapper(extractor, representation.format);
       }
       segmentIndex = representation.getIndex();
     }
 
-    public void setSampleFormat(Format sampleFormat) {
-      this.sampleFormat = sampleFormat;
-    }
-
     public void updateRepresentation(long newPeriodDurationUs, Representation newRepresentation)
         throws BehindLiveWindowException{
       DashSegmentIndex oldIndex = representation.getIndex();
@@ -415,15 +430,20 @@ public void updateRepresentation(long newPeriodDurationUs, Representation newRep
         return;
       }
 
-      int oldIndexLastSegmentNum = oldIndex.getLastSegmentNum(periodDurationUs);
+      int oldIndexSegmentCount = oldIndex.getSegmentCount(periodDurationUs);
+      if (oldIndexSegmentCount == 0) {
+        // Segment numbers cannot shift if the old index was empty.
+        return;
+      }
+
+      int oldIndexLastSegmentNum = oldIndex.getFirstSegmentNum() + oldIndexSegmentCount - 1;
       long oldIndexEndTimeUs = oldIndex.getTimeUs(oldIndexLastSegmentNum)
           + oldIndex.getDurationUs(oldIndexLastSegmentNum, periodDurationUs);
       int newIndexFirstSegmentNum = newIndex.getFirstSegmentNum();
       long newIndexStartTimeUs = newIndex.getTimeUs(newIndexFirstSegmentNum);
       if (oldIndexEndTimeUs == newIndexStartTimeUs) {
         // The new index continues where the old one ended, with no overlap.
-        segmentNumShift += oldIndex.getLastSegmentNum(periodDurationUs) + 1
-            - newIndexFirstSegmentNum;
+        segmentNumShift += oldIndexLastSegmentNum + 1 - newIndexFirstSegmentNum;
       } else if (oldIndexEndTimeUs < newIndexStartTimeUs) {
         // There's a gap between the old index and the new one which means we've slipped behind the
         // live window and can't proceed.
@@ -439,12 +459,8 @@ public int getFirstSegmentNum() {
       return segmentIndex.getFirstSegmentNum() + segmentNumShift;
     }
 
-    public int getLastSegmentNum() {
-      int lastSegmentNum = segmentIndex.getLastSegmentNum(periodDurationUs);
-      if (lastSegmentNum == DashSegmentIndex.INDEX_UNBOUNDED) {
-        return DashSegmentIndex.INDEX_UNBOUNDED;
-      }
-      return lastSegmentNum + segmentNumShift;
+    public int getSegmentCount() {
+      return segmentIndex.getSegmentCount(periodDurationUs);
     }
 
     public long getSegmentStartTimeUs(int segmentNum) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
index 44da52f52c..097676b89f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/AdaptationSet.java
@@ -23,18 +23,49 @@
  */
 public class AdaptationSet {
 
-  public static final int UNSET_ID = -1;
+  /**
+   * Value of {@link #id} indicating no value is set.=
+   */
+  public static final int ID_UNSET = -1;
 
+  /**
+   * A non-negative identifier for the adaptation set that's unique in the scope of its containing
+   * period, or {@link #ID_UNSET} if not specified.
+   */
   public final int id;
 
+  /**
+   * The type of the adaptation set. One of the {@link com.google.android.exoplayer2.C}
+   * {@code TRACK_TYPE_*} constants.
+   */
   public final int type;
 
+  /**
+   * The {@link Representation}s in the adaptation set.
+   */
   public final List<Representation> representations;
 
-  public AdaptationSet(int id, int type, List<Representation> representations) {
+  /**
+   * The accessibility descriptors in the adaptation set.
+   */
+  public final List<SchemeValuePair> accessibilityDescriptors;
+
+  /**
+   * @param id A non-negative identifier for the adaptation set that's unique in the scope of its
+   *     containing period, or {@link #ID_UNSET} if not specified.
+   * @param type The type of the adaptation set. One of the {@link com.google.android.exoplayer2.C}
+   *     {@code TRACK_TYPE_*} constants.
+   * @param representations The {@link Representation}s in the adaptation set.
+   * @param accessibilityDescriptors The accessibility descriptors in the adaptation set.
+   */
+  public AdaptationSet(int id, int type, List<Representation> representations,
+      List<SchemeValuePair> accessibilityDescriptors) {
     this.id = id;
     this.type = type;
     this.representations = Collections.unmodifiableList(representations);
+    this.accessibilityDescriptors = accessibilityDescriptors == null
+        ? Collections.<SchemeValuePair>emptyList()
+        : Collections.unmodifiableList(accessibilityDescriptors);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
index 0c713b949a..eb51c8312d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
@@ -17,7 +17,9 @@
 
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.LinkedList;
 import java.util.List;
 
 /**
@@ -79,4 +81,64 @@ public final long getPeriodDurationUs(int index) {
     return C.msToUs(getPeriodDurationMs(index));
   }
 
+  /**
+   * Creates a copy of this manifest which includes only the representations identified by the given
+   * keys.
+   *
+   * @param representationKeys List of keys for the representations to be included in the copy.
+   * @return A copy of this manifest with the selected representations.
+   * @throws IndexOutOfBoundsException If a key has an invalid index.
+   */
+  public final DashManifest copy(List<RepresentationKey> representationKeys) {
+    LinkedList<RepresentationKey> keys = new LinkedList<>(representationKeys);
+    Collections.sort(keys);
+    keys.add(new RepresentationKey(-1, -1, -1)); // Add a stopper key to the end
+
+    ArrayList<Period> copyPeriods = new ArrayList<>();
+    long shiftMs = 0;
+    for (int periodIndex = 0; periodIndex < getPeriodCount(); periodIndex++) {
+      if (keys.peek().periodIndex != periodIndex) {
+        // No representations selected in this period.
+        long periodDurationMs = getPeriodDurationMs(periodIndex);
+        if (periodDurationMs != C.TIME_UNSET) {
+          shiftMs += periodDurationMs;
+        }
+      } else {
+        Period period = getPeriod(periodIndex);
+        ArrayList<AdaptationSet> copyAdaptationSets =
+            copyAdaptationSets(period.adaptationSets, keys);
+        copyPeriods.add(new Period(period.id, period.startMs - shiftMs, copyAdaptationSets));
+      }
+    }
+    long newDuration = duration != C.TIME_UNSET ? duration - shiftMs : C.TIME_UNSET;
+    return new DashManifest(availabilityStartTime, newDuration, minBufferTime, dynamic,
+        minUpdatePeriod, timeShiftBufferDepth, suggestedPresentationDelay, utcTiming, location,
+        copyPeriods);
+  }
+
+  private static ArrayList<AdaptationSet> copyAdaptationSets(
+      List<AdaptationSet> adaptationSets, LinkedList<RepresentationKey> keys) {
+    RepresentationKey key = keys.poll();
+    int periodIndex = key.periodIndex;
+    ArrayList<AdaptationSet> copyAdaptationSets = new ArrayList<>();
+    do {
+      int adaptationSetIndex = key.adaptationSetIndex;
+      AdaptationSet adaptationSet = adaptationSets.get(adaptationSetIndex);
+
+      List<Representation> representations = adaptationSet.representations;
+      ArrayList<Representation> copyRepresentations = new ArrayList<>();
+      do {
+        Representation representation = representations.get(key.representationIndex);
+        copyRepresentations.add(representation);
+        key = keys.poll();
+      } while(key.periodIndex == periodIndex && key.adaptationSetIndex == adaptationSetIndex);
+
+      copyAdaptationSets.add(new AdaptationSet(adaptationSet.id, adaptationSet.type,
+          copyRepresentations, adaptationSet.accessibilityDescriptors));
+    } while(key.periodIndex == periodIndex);
+    // Add back the last key which doesn't belong to the period being processed
+    keys.addFirst(key);
+    return copyAdaptationSets;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index 7e2ce0de1d..d4338fd812 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -227,7 +227,7 @@ protected Period buildPeriod(String id, long startMs, List<AdaptationSet> adapta
 
   protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       SegmentBase segmentBase) throws XmlPullParserException, IOException {
-    int id = parseInt(xpp, "id", AdaptationSet.UNSET_ID);
+    int id = parseInt(xpp, "id", AdaptationSet.ID_UNSET);
     int contentType = parseContentType(xpp);
 
     String mimeType = xpp.getAttributeValue(null, "mimeType");
@@ -238,9 +238,11 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
     int audioChannels = Format.NO_VALUE;
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate", Format.NO_VALUE);
     String language = xpp.getAttributeValue(null, "lang");
-    int accessibilityChannel = Format.NO_VALUE;
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
+    ArrayList<SchemeValuePair> inbandEventStreams = new ArrayList<>();
+    ArrayList<SchemeValuePair> accessibilityDescriptors = new ArrayList<>();
     List<RepresentationInfo> representationInfos = new ArrayList<>();
+    @C.SelectionFlags int selectionFlags = 0;
 
     boolean seenFirstBaseUrl = false;
     do {
@@ -258,40 +260,45 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
       } else if (XmlPullParserUtil.isStartTag(xpp, "ContentComponent")) {
         language = checkLanguageConsistency(language, xpp.getAttributeValue(null, "lang"));
         contentType = checkContentTypeConsistency(contentType, parseContentType(xpp));
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Role")) {
+        selectionFlags |= parseRole(xpp);
+      } else if (XmlPullParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
+        audioChannels = parseAudioChannelConfiguration(xpp);
+      } else if (XmlPullParserUtil.isStartTag(xpp, "Accessibility")) {
+        accessibilityDescriptors.add(parseAccessibility(xpp));
       } else if (XmlPullParserUtil.isStartTag(xpp, "Representation")) {
         RepresentationInfo representationInfo = parseRepresentation(xpp, baseUrl, mimeType, codecs,
             width, height, frameRate, audioChannels, audioSamplingRate, language,
-            accessibilityChannel, segmentBase);
+            selectionFlags, accessibilityDescriptors, segmentBase);
         contentType = checkContentTypeConsistency(contentType,
             getContentType(representationInfo.format));
         representationInfos.add(representationInfo);
-      } else if (XmlPullParserUtil.isStartTag(xpp, "AudioChannelConfiguration")) {
-        audioChannels = parseAudioChannelConfiguration(xpp);
-      } else if (XmlPullParserUtil.isStartTag(xpp, "Accessibility")) {
-        accessibilityChannel = parseAccessibilityValue(xpp);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentBase")) {
         segmentBase = parseSegmentBase(xpp, (SingleSegmentBase) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
         segmentBase = parseSegmentList(xpp, (SegmentList) segmentBase);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentTemplate")) {
         segmentBase = parseSegmentTemplate(xpp, (SegmentTemplate) segmentBase);
+      } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
+        inbandEventStreams.add(parseInbandEventStream(xpp));
       } else if (XmlPullParserUtil.isStartTag(xpp)) {
         parseAdaptationSetChild(xpp);
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "AdaptationSet"));
 
+    // Build the representations.
     List<Representation> representations = new ArrayList<>(representationInfos.size());
     for (int i = 0; i < representationInfos.size(); i++) {
       representations.add(buildRepresentation(representationInfos.get(i), contentId,
-          drmSchemeDatas));
+          drmSchemeDatas, inbandEventStreams));
     }
 
-    return buildAdaptationSet(id, contentType, representations);
+    return buildAdaptationSet(id, contentType, representations, accessibilityDescriptors);
   }
 
   protected AdaptationSet buildAdaptationSet(int id, int contentType,
-      List<Representation> representations) {
-    return new AdaptationSet(id, contentType, representations);
+      List<Representation> representations, List<SchemeValuePair> accessibilityDescriptors) {
+    return new AdaptationSet(id, contentType, representations, accessibilityDescriptors);
   }
 
   protected int parseContentType(XmlPullParser xpp) {
@@ -311,8 +318,7 @@ protected int getContentType(Format format) {
       return C.TRACK_TYPE_VIDEO;
     } else if (MimeTypes.isAudio(sampleMimeType)) {
       return C.TRACK_TYPE_AUDIO;
-    } else if (mimeTypeIsRawText(sampleMimeType)
-        || MimeTypes.APPLICATION_RAWCC.equals(format.containerMimeType)) {
+    } else if (mimeTypeIsRawText(sampleMimeType)) {
       return C.TRACK_TYPE_TEXT;
     }
     return C.TRACK_TYPE_UNKNOWN;
@@ -329,30 +335,79 @@ protected int getContentType(Format format) {
    */
   protected SchemeData parseContentProtection(XmlPullParser xpp) throws XmlPullParserException,
       IOException {
+    String schemeIdUri = xpp.getAttributeValue(null, "schemeIdUri");
+    boolean isPlayReady = "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95".equals(schemeIdUri);
     byte[] data = null;
     UUID uuid = null;
-    boolean seenPsshElement = false;
     boolean requiresSecureDecoder = false;
     do {
       xpp.next();
-      // The cenc:pssh element is defined in 23001-7:2015.
-      if (XmlPullParserUtil.isStartTag(xpp, "cenc:pssh") && xpp.next() == XmlPullParser.TEXT) {
-        seenPsshElement = true;
+      if (data == null && XmlPullParserUtil.isStartTag(xpp, "cenc:pssh")
+          && xpp.next() == XmlPullParser.TEXT) {
+        // The cenc:pssh element is defined in 23001-7:2015.
         data = Base64.decode(xpp.getText(), Base64.DEFAULT);
         uuid = PsshAtomUtil.parseUuid(data);
+        if (uuid == null) {
+          Log.w(TAG, "Skipping malformed cenc:pssh data");
+          data = null;
+        }
+      } else if (data == null && isPlayReady && XmlPullParserUtil.isStartTag(xpp, "mspr:pro")
+          && xpp.next() == XmlPullParser.TEXT) {
+        // The mspr:pro element is defined in DASH Content Protection using Microsoft PlayReady.
+        data = PsshAtomUtil.buildPsshAtom(C.PLAYREADY_UUID,
+            Base64.decode(xpp.getText(), Base64.DEFAULT));
+        uuid = C.PLAYREADY_UUID;
       } else if (XmlPullParserUtil.isStartTag(xpp, "widevine:license")) {
         String robustnessLevel = xpp.getAttributeValue(null, "robustness_level");
         requiresSecureDecoder = robustnessLevel != null && robustnessLevel.startsWith("HW");
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "ContentProtection"));
-    if (!seenPsshElement) {
-      return null;
-    } else if (uuid != null) {
-      return new SchemeData(uuid, MimeTypes.VIDEO_MP4, data, requiresSecureDecoder);
-    } else {
-      Log.w(TAG, "Skipped unsupported ContentProtection element");
-      return null;
-    }
+    return data != null ? new SchemeData(uuid, MimeTypes.VIDEO_MP4, data, requiresSecureDecoder)
+        : null;
+  }
+
+  /**
+   * Parses an InbandEventStream element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return A {@link SchemeValuePair} parsed from the element.
+   */
+  protected SchemeValuePair parseInbandEventStream(XmlPullParser xpp)
+      throws XmlPullParserException, IOException {
+    return parseSchemeValuePair(xpp, "InbandEventStream");
+  }
+
+  /**
+   * Parses an Accessibility element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return A {@link SchemeValuePair} parsed from the element.
+   */
+  protected SchemeValuePair parseAccessibility(XmlPullParser xpp)
+      throws XmlPullParserException, IOException {
+    return parseSchemeValuePair(xpp, "Accessibility");
+  }
+
+  /**
+   * Parses a Role element.
+   *
+   * @param xpp The parser from which to read.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return {@link C.SelectionFlags} parsed from the element.
+   */
+  protected int parseRole(XmlPullParser xpp) throws XmlPullParserException, IOException {
+    String schemeIdUri = parseString(xpp, "schemeIdUri", null);
+    String value = parseString(xpp, "value", null);
+    do {
+      xpp.next();
+    } while (!XmlPullParserUtil.isEndTag(xpp, "Role"));
+    return "urn:mpeg:dash:role:2011".equals(schemeIdUri) && "main".equals(value)
+        ? C.SELECTION_FLAG_DEFAULT : 0;
   }
 
   /**
@@ -373,7 +428,8 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
       String adaptationSetMimeType, String adaptationSetCodecs, int adaptationSetWidth,
       int adaptationSetHeight, float adaptationSetFrameRate, int adaptationSetAudioChannels,
       int adaptationSetAudioSamplingRate, String adaptationSetLanguage,
-      int adaptationSetAccessibilityChannel, SegmentBase segmentBase)
+      @C.SelectionFlags int adaptationSetSelectionFlags,
+      List<SchemeValuePair> adaptationSetAccessibilityDescriptors, SegmentBase segmentBase)
       throws XmlPullParserException, IOException {
     String id = xpp.getAttributeValue(null, "id");
     int bandwidth = parseInt(xpp, "bandwidth", Format.NO_VALUE);
@@ -386,6 +442,7 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
     int audioChannels = adaptationSetAudioChannels;
     int audioSamplingRate = parseInt(xpp, "audioSamplingRate", adaptationSetAudioSamplingRate);
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
+    ArrayList<SchemeValuePair> inbandEventStreams = new ArrayList<>();
 
     boolean seenFirstBaseUrl = false;
     do {
@@ -408,52 +465,61 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
         if (contentProtection != null) {
           drmSchemeDatas.add(contentProtection);
         }
+      } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
+        inbandEventStreams.add(parseInbandEventStream(xpp));
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Representation"));
 
     Format format = buildFormat(id, mimeType, width, height, frameRate, audioChannels,
-        audioSamplingRate, bandwidth, adaptationSetLanguage, adaptationSetAccessibilityChannel,
-        codecs);
+        audioSamplingRate, bandwidth, adaptationSetLanguage, adaptationSetSelectionFlags,
+        adaptationSetAccessibilityDescriptors, codecs);
     segmentBase = segmentBase != null ? segmentBase : new SingleSegmentBase();
 
-    return new RepresentationInfo(format, baseUrl, segmentBase, drmSchemeDatas);
+    return new RepresentationInfo(format, baseUrl, segmentBase, drmSchemeDatas, inbandEventStreams);
   }
 
   protected Format buildFormat(String id, String containerMimeType, int width, int height,
       float frameRate, int audioChannels, int audioSamplingRate, int bitrate, String language,
-      int accessiblityChannel, String codecs) {
+      @C.SelectionFlags int selectionFlags, List<SchemeValuePair> accessibilityDescriptors,
+      String codecs) {
     String sampleMimeType = getSampleMimeType(containerMimeType, codecs);
     if (sampleMimeType != null) {
       if (MimeTypes.isVideo(sampleMimeType)) {
         return Format.createVideoContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, width, height, frameRate, null);
+            bitrate, width, height, frameRate, null, selectionFlags);
       } else if (MimeTypes.isAudio(sampleMimeType)) {
         return Format.createAudioContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, audioChannels, audioSamplingRate, null, 0, language);
+            bitrate, audioChannels, audioSamplingRate, null, selectionFlags, language);
       } else if (mimeTypeIsRawText(sampleMimeType)) {
+        int accessibilityChannel;
+        if (MimeTypes.APPLICATION_CEA608.equals(sampleMimeType)) {
+          accessibilityChannel = parseCea608AccessibilityChannel(accessibilityDescriptors);
+        } else if (MimeTypes.APPLICATION_CEA708.equals(sampleMimeType)) {
+          accessibilityChannel = parseCea708AccessibilityChannel(accessibilityDescriptors);
+        } else {
+          accessibilityChannel = Format.NO_VALUE;
+        }
         return Format.createTextContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, 0, language, accessiblityChannel);
-      } else if (containerMimeType.equals(MimeTypes.APPLICATION_RAWCC)) {
-        return Format.createTextContainerFormat(id, containerMimeType, sampleMimeType, codecs,
-            bitrate, 0, language, accessiblityChannel);
-      } else {
-        return Format.createContainerFormat(id, containerMimeType, codecs, sampleMimeType, bitrate);
+            bitrate, selectionFlags, language, accessibilityChannel);
       }
-    } else {
-      return Format.createContainerFormat(id, containerMimeType, codecs, sampleMimeType, bitrate);
     }
+    return Format.createContainerFormat(id, containerMimeType, sampleMimeType, codecs, bitrate,
+        selectionFlags, language);
   }
 
   protected Representation buildRepresentation(RepresentationInfo representationInfo,
-      String contentId, ArrayList<SchemeData> extraDrmSchemeDatas) {
+      String contentId, ArrayList<SchemeData> extraDrmSchemeDatas,
+      ArrayList<SchemeValuePair> extraInbandEventStreams) {
     Format format = representationInfo.format;
     ArrayList<SchemeData> drmSchemeDatas = representationInfo.drmSchemeDatas;
     drmSchemeDatas.addAll(extraDrmSchemeDatas);
     if (!drmSchemeDatas.isEmpty()) {
       format = format.copyWithDrmInitData(new DrmInitData(drmSchemeDatas));
     }
+    ArrayList<SchemeValuePair> inbandEventStremas = representationInfo.inbandEventStreams;
+    inbandEventStremas.addAll(extraInbandEventStreams);
     return Representation.newInstance(contentId, Representation.REVISION_ID_DEFAULT, format,
-        representationInfo.baseUrl, representationInfo.segmentBase);
+        representationInfo.baseUrl, representationInfo.segmentBase, inbandEventStremas);
   }
 
   // SegmentBase, SegmentList and SegmentTemplate parsing.
@@ -664,6 +730,14 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
       return MimeTypes.getAudioMediaMimeType(codecs);
     } else if (MimeTypes.isVideo(containerMimeType)) {
       return MimeTypes.getVideoMediaMimeType(codecs);
+    } else if (mimeTypeIsRawText(containerMimeType)) {
+      return containerMimeType;
+    } else if (MimeTypes.APPLICATION_MP4.equals(containerMimeType)) {
+      if ("stpp".equals(codecs)) {
+        return MimeTypes.APPLICATION_TTML;
+      } else if ("wvtt".equals(codecs)) {
+        return MimeTypes.APPLICATION_MP4VTT;
+      }
     } else if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
       if (codecs != null) {
         if (codecs.contains("cea708")) {
@@ -673,14 +747,6 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
         }
       }
       return null;
-    } else if (mimeTypeIsRawText(containerMimeType)) {
-      return containerMimeType;
-    } else if (MimeTypes.APPLICATION_MP4.equals(containerMimeType)) {
-      if ("stpp".equals(codecs)) {
-        return MimeTypes.APPLICATION_TTML;
-      } else if ("wvtt".equals(codecs)) {
-        return MimeTypes.APPLICATION_MP4VTT;
-      }
     }
     return null;
   }
@@ -692,7 +758,11 @@ private static String getSampleMimeType(String containerMimeType, String codecs)
    * @return Whether the mimeType is a text sample mimeType.
    */
   private static boolean mimeTypeIsRawText(String mimeType) {
-    return MimeTypes.isText(mimeType) || MimeTypes.APPLICATION_TTML.equals(mimeType);
+    return MimeTypes.isText(mimeType)
+        || MimeTypes.APPLICATION_TTML.equals(mimeType)
+        || MimeTypes.APPLICATION_MP4VTT.equals(mimeType)
+        || MimeTypes.APPLICATION_CEA708.equals(mimeType)
+        || MimeTypes.APPLICATION_CEA608.equals(mimeType);
   }
 
   /**
@@ -738,52 +808,57 @@ private static int checkContentTypeConsistency(int firstType, int secondType) {
     }
   }
 
-  private static int parseAccessibilityValue(XmlPullParser xpp)
-      throws IOException, XmlPullParserException {
+  /**
+   * Parses a {@link SchemeValuePair} from an element.
+   *
+   * @param xpp The parser from which to read.
+   * @param tag The tag of the element being parsed.
+   * @throws XmlPullParserException If an error occurs parsing the element.
+   * @throws IOException If an error occurs reading the element.
+   * @return The parsed {@link SchemeValuePair}.
+   */
+  protected static SchemeValuePair parseSchemeValuePair(XmlPullParser xpp, String tag)
+      throws XmlPullParserException, IOException {
     String schemeIdUri = parseString(xpp, "schemeIdUri", null);
-    String valueString = parseString(xpp, "value", null);
-    int accessibilityValue;
-    if (schemeIdUri == null || valueString == null) {
-      accessibilityValue = Format.NO_VALUE;
-    } else if ("urn:scte:dash:cc:cea-608:2015".equals(schemeIdUri)) {
-      accessibilityValue = parseCea608AccessibilityChannel(valueString);
-    } else if ("urn:scte:dash:cc:cea-708:2015".equals(schemeIdUri)) {
-      accessibilityValue = parseCea708AccessibilityChannel(valueString);
-    } else {
-      accessibilityValue = Format.NO_VALUE;
-    }
+    String value = parseString(xpp, "value", null);
     do {
       xpp.next();
-    } while (!XmlPullParserUtil.isEndTag(xpp, "Accessibility"));
-    return accessibilityValue;
-  }
-
-  static int parseCea608AccessibilityChannel(String accessibilityValueString) {
-    if (accessibilityValueString == null) {
-      return Format.NO_VALUE;
-    }
-    Matcher accessibilityValueMatcher =
-        CEA_608_ACCESSIBILITY_PATTERN.matcher(accessibilityValueString);
-    if (accessibilityValueMatcher.matches()) {
-      return Integer.parseInt(accessibilityValueMatcher.group(1));
-    } else {
-      Log.w(TAG, "Unable to parse channel number from " + accessibilityValueString);
-      return Format.NO_VALUE;
-    }
-  }
-
-  static int parseCea708AccessibilityChannel(String accessibilityValueString) {
-    if (accessibilityValueString == null) {
-      return Format.NO_VALUE;
+    } while (!XmlPullParserUtil.isEndTag(xpp, tag));
+    return new SchemeValuePair(schemeIdUri, value);
+  }
+
+  protected static int parseCea608AccessibilityChannel(
+      List<SchemeValuePair> accessibilityDescriptors) {
+    for (int i = 0; i < accessibilityDescriptors.size(); i++) {
+      SchemeValuePair descriptor = accessibilityDescriptors.get(i);
+      if ("urn:scte:dash:cc:cea-608:2015".equals(descriptor.schemeIdUri)
+          && descriptor.value != null) {
+        Matcher accessibilityValueMatcher = CEA_608_ACCESSIBILITY_PATTERN.matcher(descriptor.value);
+        if (accessibilityValueMatcher.matches()) {
+          return Integer.parseInt(accessibilityValueMatcher.group(1));
+        } else {
+          Log.w(TAG, "Unable to parse CEA-608 channel number from: " + descriptor.value);
+        }
+      }
     }
-    Matcher accessibilityValueMatcher =
-        CEA_708_ACCESSIBILITY_PATTERN.matcher(accessibilityValueString);
-    if (accessibilityValueMatcher.matches()) {
-      return Integer.parseInt(accessibilityValueMatcher.group(1));
-    } else {
-      Log.w(TAG, "Unable to parse service block number from " + accessibilityValueString);
-      return Format.NO_VALUE;
+    return Format.NO_VALUE;
+  }
+
+  protected static int parseCea708AccessibilityChannel(
+      List<SchemeValuePair> accessibilityDescriptors) {
+    for (int i = 0; i < accessibilityDescriptors.size(); i++) {
+      SchemeValuePair descriptor = accessibilityDescriptors.get(i);
+      if ("urn:scte:dash:cc:cea-708:2015".equals(descriptor.schemeIdUri)
+          && descriptor.value != null) {
+        Matcher accessibilityValueMatcher = CEA_708_ACCESSIBILITY_PATTERN.matcher(descriptor.value);
+        if (accessibilityValueMatcher.matches()) {
+          return Integer.parseInt(accessibilityValueMatcher.group(1));
+        } else {
+          Log.w(TAG, "Unable to parse CEA-708 service block number from: " + descriptor.value);
+        }
+      }
     }
+    return Format.NO_VALUE;
   }
 
   protected static float parseFrameRate(XmlPullParser xpp, float defaultValue) {
@@ -850,13 +925,15 @@ protected static String parseString(XmlPullParser xpp, String name, String defau
     public final String baseUrl;
     public final SegmentBase segmentBase;
     public final ArrayList<SchemeData> drmSchemeDatas;
+    public final ArrayList<SchemeValuePair> inbandEventStreams;
 
     public RepresentationInfo(Format format, String baseUrl, SegmentBase segmentBase,
-        ArrayList<SchemeData> drmSchemeDatas) {
+        ArrayList<SchemeData> drmSchemeDatas, ArrayList<SchemeValuePair> inbandEventStreams) {
       this.format = format;
       this.baseUrl = baseUrl;
       this.segmentBase = segmentBase;
       this.drmSchemeDatas = drmSchemeDatas;
+      this.inbandEventStreams = inbandEventStreams;
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
index f52727c1a8..5960d4d7ba 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
@@ -21,6 +21,8 @@
 import com.google.android.exoplayer2.source.dash.DashSegmentIndex;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.MultiSegmentBase;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import java.util.Collections;
+import java.util.List;
 
 /**
  * A DASH representation.
@@ -60,6 +62,10 @@
    * The offset of the presentation timestamps in the media stream relative to media time.
    */
   public final long presentationTimeOffsetUs;
+  /**
+   * The in-band event streams in the representation. Never null, but may be empty.
+   */
+  public final List<SchemeValuePair> inbandEventStreams;
 
   private final RangedUri initializationUri;
 
@@ -78,6 +84,23 @@ public static Representation newInstance(String contentId, long revisionId, Form
     return newInstance(contentId, revisionId, format, baseUrl, segmentBase, null);
   }
 
+  /**
+   * Constructs a new instance.
+   *
+   * @param contentId Identifies the piece of content to which this representation belongs.
+   * @param revisionId Identifies the revision of the content.
+   * @param format The format of the representation.
+   * @param baseUrl The base URL.
+   * @param segmentBase A segment base element for the representation.
+   * @param inbandEventStreams The in-band event streams in the representation. May be null.
+   * @return The constructed instance.
+   */
+  public static Representation newInstance(String contentId, long revisionId, Format format,
+      String baseUrl, SegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams) {
+    return newInstance(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams,
+        null);
+  }
+
   /**
    * Constructs a new instance.
    *
@@ -86,18 +109,20 @@ public static Representation newInstance(String contentId, long revisionId, Form
    * @param format The format of the representation.
    * @param baseUrl The base URL of the representation.
    * @param segmentBase A segment base element for the representation.
+   * @param inbandEventStreams The in-band event streams in the representation. May be null.
    * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null. This
    *     parameter is ignored if {@code segmentBase} consists of multiple segments.
    * @return The constructed instance.
    */
   public static Representation newInstance(String contentId, long revisionId, Format format,
-      String baseUrl, SegmentBase segmentBase, String customCacheKey) {
+      String baseUrl, SegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams,
+      String customCacheKey) {
     if (segmentBase instanceof SingleSegmentBase) {
       return new SingleSegmentRepresentation(contentId, revisionId, format, baseUrl,
-          (SingleSegmentBase) segmentBase, customCacheKey, C.LENGTH_UNSET);
+          (SingleSegmentBase) segmentBase, inbandEventStreams, customCacheKey, C.LENGTH_UNSET);
     } else if (segmentBase instanceof MultiSegmentBase) {
       return new MultiSegmentRepresentation(contentId, revisionId, format, baseUrl,
-          (MultiSegmentBase) segmentBase);
+          (MultiSegmentBase) segmentBase, inbandEventStreams);
     } else {
       throw new IllegalArgumentException("segmentBase must be of type SingleSegmentBase or "
           + "MultiSegmentBase");
@@ -105,11 +130,14 @@ public static Representation newInstance(String contentId, long revisionId, Form
   }
 
   private Representation(String contentId, long revisionId, Format format, String baseUrl,
-      SegmentBase segmentBase) {
+      SegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams) {
     this.contentId = contentId;
     this.revisionId = revisionId;
     this.format = format;
     this.baseUrl = baseUrl;
+    this.inbandEventStreams = inbandEventStreams == null
+        ? Collections.<SchemeValuePair>emptyList()
+        : Collections.unmodifiableList(inbandEventStreams);
     initializationUri = segmentBase.getInitialization(this);
     presentationTimeOffsetUs = segmentBase.getPresentationTimeOffsetUs();
   }
@@ -167,18 +195,20 @@ public RangedUri getInitializationUri() {
      * @param initializationEnd The offset of the last byte of initialization data.
      * @param indexStart The offset of the first byte of index data.
      * @param indexEnd The offset of the last byte of index data.
+     * @param inbandEventStreams The in-band event streams in the representation. May be null.
      * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or {@link C#LENGTH_UNSET} if unknown.
      */
     public static SingleSegmentRepresentation newInstance(String contentId, long revisionId,
         Format format, String uri, long initializationStart, long initializationEnd,
-        long indexStart, long indexEnd, String customCacheKey, long contentLength) {
+        long indexStart, long indexEnd, List<SchemeValuePair> inbandEventStreams,
+        String customCacheKey, long contentLength) {
       RangedUri rangedUri = new RangedUri(null, initializationStart,
           initializationEnd - initializationStart + 1);
       SingleSegmentBase segmentBase = new SingleSegmentBase(rangedUri, 1, 0, indexStart,
           indexEnd - indexStart + 1);
       return new SingleSegmentRepresentation(contentId, revisionId,
-          format, uri, segmentBase, customCacheKey, contentLength);
+          format, uri, segmentBase, inbandEventStreams, customCacheKey, contentLength);
     }
 
     /**
@@ -187,12 +217,14 @@ public static SingleSegmentRepresentation newInstance(String contentId, long rev
      * @param format The format of the representation.
      * @param baseUrl The base URL of the representation.
      * @param segmentBase The segment base underlying the representation.
+     * @param inbandEventStreams The in-band event streams in the representation. May be null.
      * @param customCacheKey A custom value to be returned from {@link #getCacheKey()}, or null.
      * @param contentLength The content length, or {@link C#LENGTH_UNSET} if unknown.
      */
     public SingleSegmentRepresentation(String contentId, long revisionId, Format format,
-        String baseUrl, SingleSegmentBase segmentBase, String customCacheKey, long contentLength) {
-      super(contentId, revisionId, format, baseUrl, segmentBase);
+        String baseUrl, SingleSegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams,
+        String customCacheKey, long contentLength) {
+      super(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams);
       this.uri = Uri.parse(baseUrl);
       this.indexUri = segmentBase.getIndex();
       this.cacheKey = customCacheKey != null ? customCacheKey
@@ -235,10 +267,11 @@ public String getCacheKey() {
      * @param format The format of the representation.
      * @param baseUrl The base URL of the representation.
      * @param segmentBase The segment base underlying the representation.
+     * @param inbandEventStreams The in-band event streams in the representation. May be null.
      */
     public MultiSegmentRepresentation(String contentId, long revisionId, Format format,
-        String baseUrl, MultiSegmentBase segmentBase) {
-      super(contentId, revisionId, format, baseUrl, segmentBase);
+        String baseUrl, MultiSegmentBase segmentBase, List<SchemeValuePair> inbandEventStreams) {
+      super(contentId, revisionId, format, baseUrl, segmentBase, inbandEventStreams);
       this.segmentBase = segmentBase;
     }
 
@@ -285,8 +318,8 @@ public int getFirstSegmentNum() {
     }
 
     @Override
-    public int getLastSegmentNum(long periodDurationUs) {
-      return segmentBase.getLastSegmentNum(periodDurationUs);
+    public int getSegmentCount(long periodDurationUs) {
+      return segmentBase.getSegmentCount(periodDurationUs);
     }
 
     @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java
new file mode 100644
index 0000000000..51451a83c2
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationKey.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Uniquely identifies a {@link Representation} in a {@link DashManifest}.
+ */
+public final class RepresentationKey implements Parcelable, Comparable<RepresentationKey> {
+
+  public final int periodIndex;
+  public final int adaptationSetIndex;
+  public final int representationIndex;
+
+  public RepresentationKey(int periodIndex, int adaptationSetIndex, int representationIndex) {
+    this.periodIndex = periodIndex;
+    this.adaptationSetIndex = adaptationSetIndex;
+    this.representationIndex = representationIndex;
+  }
+
+  @Override
+  public String toString() {
+    return periodIndex + "." + adaptationSetIndex + "." + representationIndex;
+  }
+
+  // Parcelable implementation.
+
+  @Override
+  public int describeContents() {
+    return 0;
+  }
+
+  @Override
+  public void writeToParcel(Parcel dest, int flags) {
+    dest.writeInt(periodIndex);
+    dest.writeInt(adaptationSetIndex);
+    dest.writeInt(representationIndex);
+  }
+
+  public static final Creator<RepresentationKey> CREATOR =
+      new Creator<RepresentationKey>() {
+        @Override
+        public RepresentationKey createFromParcel(Parcel in) {
+          return new RepresentationKey(in.readInt(), in.readInt(), in.readInt());
+        }
+
+        @Override
+        public RepresentationKey[] newArray(int size) {
+          return new RepresentationKey[size];
+        }
+      };
+
+  // Comparable implementation.
+
+  @Override
+  public int compareTo(RepresentationKey o) {
+    int result = periodIndex - o.periodIndex;
+    if (result == 0) {
+      result = adaptationSetIndex - o.adaptationSetIndex;
+      if (result == 0) {
+        result = representationIndex - o.representationIndex;
+      }
+    }
+    return result;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SchemeValuePair.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SchemeValuePair.java
new file mode 100644
index 0000000000..470bf0f989
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SchemeValuePair.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * A pair consisting of a scheme ID and value.
+ */
+public class SchemeValuePair {
+
+  public final String schemeIdUri;
+  public final String value;
+
+  public SchemeValuePair(String schemeIdUri, String value) {
+    this.schemeIdUri = schemeIdUri;
+    this.value = value;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    SchemeValuePair other = (SchemeValuePair) obj;
+    return Util.areEqual(schemeIdUri, other.schemeIdUri) && Util.areEqual(value, other.value);
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * (schemeIdUri != null ? schemeIdUri.hashCode() : 0)
+        + (value != null ? value.hashCode() : 0);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
index ef319d508d..4f7dc81fc5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
@@ -130,20 +130,24 @@ public MultiSegmentBase(RangedUri initialization, long timescale, long presentat
      */
     public int getSegmentNum(long timeUs, long periodDurationUs) {
       final int firstSegmentNum = getFirstSegmentNum();
-      int lowIndex = firstSegmentNum;
-      int highIndex = getLastSegmentNum(periodDurationUs);
+      final int segmentCount = getSegmentCount(periodDurationUs);
+      if (segmentCount == 0) {
+        return firstSegmentNum;
+      }
       if (segmentTimeline == null) {
         // All segments are of equal duration (with the possible exception of the last one).
         long durationUs = (duration * C.MICROS_PER_SECOND) / timescale;
         int segmentNum = startNumber + (int) (timeUs / durationUs);
         // Ensure we stay within bounds.
-        return segmentNum < lowIndex ? lowIndex
-            : highIndex != DashSegmentIndex.INDEX_UNBOUNDED && segmentNum > highIndex ? highIndex
-            : segmentNum;
+        return segmentNum < firstSegmentNum ? firstSegmentNum
+            : segmentCount == DashSegmentIndex.INDEX_UNBOUNDED ? segmentNum
+            : Math.min(segmentNum, firstSegmentNum + segmentCount - 1);
       } else {
-        // The high index cannot be unbounded. Identify the segment using binary search.
+        // The index cannot be unbounded. Identify the segment using binary search.
+        int lowIndex = firstSegmentNum;
+        int highIndex = firstSegmentNum + segmentCount - 1;
         while (lowIndex <= highIndex) {
-          int midIndex = (lowIndex + highIndex) / 2;
+          int midIndex = lowIndex + (highIndex - lowIndex) / 2;
           long midTimeUs = getSegmentTimeUs(midIndex);
           if (midTimeUs < timeUs) {
             lowIndex = midIndex + 1;
@@ -165,7 +169,9 @@ public final long getSegmentDurationUs(int sequenceNumber, long periodDurationUs
         long duration = segmentTimeline.get(sequenceNumber - startNumber).duration;
         return (duration * C.MICROS_PER_SECOND) / timescale;
       } else {
-        return sequenceNumber == getLastSegmentNum(periodDurationUs)
+        int segmentCount = getSegmentCount(periodDurationUs);
+        return segmentCount != DashSegmentIndex.INDEX_UNBOUNDED
+            && sequenceNumber == (getFirstSegmentNum() + segmentCount - 1)
             ? (periodDurationUs - getSegmentTimeUs(sequenceNumber))
             : ((duration * C.MICROS_PER_SECOND) / timescale);
       }
@@ -201,9 +207,9 @@ public int getFirstSegmentNum() {
     }
 
     /**
-     * @see DashSegmentIndex#getLastSegmentNum(long)
+     * @see DashSegmentIndex#getSegmentCount(long)
      */
-    public abstract int getLastSegmentNum(long periodDurationUs);
+    public abstract int getSegmentCount(long periodDurationUs);
 
     /**
      * @see DashSegmentIndex#isExplicit()
@@ -250,8 +256,8 @@ public RangedUri getSegmentUrl(Representation representation, int sequenceNumber
     }
 
     @Override
-    public int getLastSegmentNum(long periodDurationUs) {
-      return startNumber + mediaSegments.size() - 1;
+    public int getSegmentCount(long periodDurationUs) {
+      return mediaSegments.size();
     }
 
     @Override
@@ -322,14 +328,14 @@ public RangedUri getSegmentUrl(Representation representation, int sequenceNumber
     }
 
     @Override
-    public int getLastSegmentNum(long periodDurationUs) {
+    public int getSegmentCount(long periodDurationUs) {
       if (segmentTimeline != null) {
-        return segmentTimeline.size() + startNumber - 1;
-      } else if (periodDurationUs == C.TIME_UNSET) {
-        return DashSegmentIndex.INDEX_UNBOUNDED;
-      } else {
+        return segmentTimeline.size();
+      } else if (periodDurationUs != C.TIME_UNSET) {
         long durationUs = (duration * C.MICROS_PER_SECOND) / timescale;
-        return startNumber + (int) Util.ceilDivide(periodDurationUs, durationUs) - 1;
+        return (int) Util.ceilDivide(periodDurationUs, durationUs);
+      } else {
+        return DashSegmentIndex.INDEX_UNBOUNDED;
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SingleSegmentIndex.java b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SingleSegmentIndex.java
index 083046d073..4ce49c5ffe 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SingleSegmentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SingleSegmentIndex.java
@@ -57,8 +57,8 @@ public int getFirstSegmentNum() {
   }
 
   @Override
-  public int getLastSegmentNum(long periodDurationUs) {
-    return 0;
+  public int getSegmentCount(long periodDurationUs) {
+    return 1;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsDataSourceFactory.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsDataSourceFactory.java
new file mode 100644
index 0000000000..b90dcb2139
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsDataSourceFactory.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import com.google.android.exoplayer2.upstream.DataSource;
+
+/**
+ * Default implementation of {@link HlsDataSourceFactory}.
+ */
+public final class DefaultHlsDataSourceFactory implements HlsDataSourceFactory {
+
+  private final DataSource.Factory dataSourceFactory;
+
+  /**
+   * @param dataSourceFactory The {@link DataSource.Factory} to use for all data types.
+   */
+  public DefaultHlsDataSourceFactory(DataSource.Factory dataSourceFactory) {
+    this.dataSourceFactory = dataSourceFactory;
+  }
+
+  @Override
+  public DataSource createDataSource(int dataType) {
+    return dataSourceFactory.createDataSource();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index b953fcf79c..ea99dae345 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -19,7 +19,6 @@
 import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.Chunk;
@@ -33,11 +32,13 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Locale;
 
 /**
@@ -80,11 +81,13 @@ public void clear() {
 
   }
 
-  private final DataSource dataSource;
+  private final DataSource mediaDataSource;
+  private final DataSource encryptionDataSource;
   private final TimestampAdjusterProvider timestampAdjusterProvider;
   private final HlsUrl[] variants;
   private final HlsPlaylistTracker playlistTracker;
   private final TrackGroup trackGroup;
+  private final List<Format> muxedCaptionFormats;
 
   private boolean isTimestampMaster;
   private byte[] scratchSpace;
@@ -103,24 +106,28 @@ public void clear() {
   /**
    * @param playlistTracker The {@link HlsPlaylistTracker} from which to obtain media playlists.
    * @param variants The available variants.
-   * @param dataSource A {@link DataSource} suitable for loading the media data.
+   * @param dataSourceFactory An {@link HlsDataSourceFactory} to create {@link DataSource}s for the
+   *     chunks.
    * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If
    *     multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
    *     same provider.
+   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
    */
   public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
-      DataSource dataSource, TimestampAdjusterProvider timestampAdjusterProvider) {
+      HlsDataSourceFactory dataSourceFactory, TimestampAdjusterProvider timestampAdjusterProvider,
+      List<Format> muxedCaptionFormats) {
     this.playlistTracker = playlistTracker;
     this.variants = variants;
-    this.dataSource = dataSource;
     this.timestampAdjusterProvider = timestampAdjusterProvider;
-
+    this.muxedCaptionFormats = muxedCaptionFormats;
     Format[] variantFormats = new Format[variants.length];
     int[] initialTrackSelection = new int[variants.length];
     for (int i = 0; i < variants.length; i++) {
       variantFormats[i] = variants[i].format;
       initialTrackSelection[i] = i;
     }
+    mediaDataSource = dataSourceFactory.createDataSource(C.DATA_TYPE_MEDIA);
+    encryptionDataSource = dataSourceFactory.createDataSource(C.DATA_TYPE_DRM);
     trackGroup = new TrackGroup(variantFormats);
     trackSelection = new InitializationTrackSelection(trackGroup, initialTrackSelection);
   }
@@ -194,15 +201,16 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
 
     // Select the variant.
     trackSelection.updateSelectedTrack(bufferedDurationUs);
-    int newVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
+    int selectedVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
 
-    boolean switchingVariant = oldVariantIndex != newVariantIndex;
-    HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(variants[newVariantIndex]);
-    if (mediaPlaylist == null) {
-      out.playlist = variants[newVariantIndex];
+    boolean switchingVariant = oldVariantIndex != selectedVariantIndex;
+    HlsUrl selectedUrl = variants[selectedVariantIndex];
+    if (!playlistTracker.isSnapshotValid(selectedUrl)) {
+      out.playlist = selectedUrl;
       // Retry when playlist is refreshed.
       return;
     }
+    HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
 
     // Select the chunk.
     int chunkMediaSequence;
@@ -218,8 +226,9 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
         if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null) {
           // We try getting the next chunk without adapting in case that's the reason for falling
           // behind the live window.
-          newVariantIndex = oldVariantIndex;
-          mediaPlaylist = playlistTracker.getPlaylistSnapshot(variants[newVariantIndex]);
+          selectedVariantIndex = oldVariantIndex;
+          selectedUrl = variants[selectedVariantIndex];
+          mediaPlaylist = playlistTracker.getPlaylistSnapshot(selectedUrl);
           chunkMediaSequence = previous.getNextChunkIndex();
         }
       }
@@ -236,7 +245,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
       if (mediaPlaylist.hasEndTag) {
         out.endOfStream = true;
       } else /* Live */ {
-        out.playlist = variants[newVariantIndex];
+        out.playlist = selectedUrl;
       }
       return;
     }
@@ -249,7 +258,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
       Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
       if (!keyUri.equals(encryptionKeyUri)) {
         // Encryption is specified and the key has changed.
-        out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, newVariantIndex,
+        out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, selectedVariantIndex,
             trackSelection.getSelectionReason(), trackSelection.getSelectionData());
         return;
       }
@@ -270,18 +279,19 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
 
     // Compute start time of the next chunk.
     long startTimeUs = mediaPlaylist.startTimeUs + segment.relativeStartTimeUs;
+    int discontinuitySequence = mediaPlaylist.discontinuitySequence
+        + segment.relativeDiscontinuitySequence;
     TimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(
-        segment.discontinuitySequenceNumber, startTimeUs);
+        discontinuitySequence);
 
     // Configure the data source and spec for the chunk.
     Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
     DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
         null);
-    out.chunk = new HlsMediaChunk(dataSource, dataSpec, initDataSpec, variants[newVariantIndex],
-        trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
-        startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence,
-        segment.discontinuitySequenceNumber, isTimestampMaster, timestampAdjuster, previous,
-        encryptionKey, encryptionIv);
+    out.chunk = new HlsMediaChunk(mediaDataSource, dataSpec, initDataSpec, selectedUrl,
+        muxedCaptionFormats, trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
+        startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence, discontinuitySequence,
+        isTimestampMaster, timestampAdjuster, previous, encryptionKey, encryptionIv);
   }
 
   /**
@@ -334,7 +344,7 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
   private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int variantIndex,
       int trackSelectionReason, Object trackSelectionData) {
     DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNSET, null, DataSpec.FLAG_ALLOW_GZIP);
-    return new EncryptionKeyChunk(dataSource, dataSpec, variants[variantIndex].format,
+    return new EncryptionKeyChunk(encryptionDataSource, dataSpec, variants[variantIndex].format,
         trackSelectionReason, trackSelectionData, scratchSpace, iv);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsDataSourceFactory.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsDataSourceFactory.java
new file mode 100644
index 0000000000..30e7af5a0b
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsDataSourceFactory.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSource;
+
+/**
+ * Creates {@link DataSource}s for HLS playlists, encryption and media chunks.
+ */
+public interface HlsDataSourceFactory {
+
+  /**
+   * Creates a {@link DataSource} for the given data type.
+   *
+   * @param dataType The data type for which the {@link DataSource} will be used. One of {@link C}
+   *     {@code .DATA_TYPE_*} constants.
+   * @return A {@link DataSource} for the given data type.
+   */
+  DataSource createDataSource(int dataType);
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsManifest.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsManifest.java
new file mode 100644
index 0000000000..81d63fd4ad
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsManifest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
+
+/**
+ * Holds a master playlist along with a snapshot of one of its media playlists.
+ */
+public final class HlsManifest {
+
+  /**
+   * The master playlist of an HLS stream.
+   */
+  public final HlsMasterPlaylist masterPlaylist;
+  /**
+   * A snapshot of a media playlist referred to by {@link #masterPlaylist}.
+   */
+  public final HlsMediaPlaylist mediaPlaylist;
+
+  /**
+   * @param masterPlaylist The master playlist.
+   * @param mediaPlaylist The media playlist.
+   */
+  HlsManifest(HlsMasterPlaylist masterPlaylist, HlsMediaPlaylist mediaPlaylist) {
+    this.masterPlaylist = masterPlaylist;
+    this.mediaPlaylist = mediaPlaylist;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index f9dba14e0e..6f516923f9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -17,11 +17,10 @@
 
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
 import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer2.extractor.ts.Ac3Extractor;
@@ -37,8 +36,10 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
@@ -56,6 +57,7 @@
   private static final String EC3_FILE_EXTENSION = ".ec3";
   private static final String MP3_FILE_EXTENSION = ".mp3";
   private static final String MP4_FILE_EXTENSION = ".mp4";
+  private static final String M4_FILE_EXTENSION_PREFIX = ".m4";
   private static final String VTT_FILE_EXTENSION = ".vtt";
   private static final String WEBVTT_FILE_EXTENSION = ".webvtt";
 
@@ -79,8 +81,11 @@
   private final boolean isEncrypted;
   private final boolean isMasterTimestampSource;
   private final TimestampAdjuster timestampAdjuster;
-  private final HlsMediaChunk previousChunk;
   private final String lastPathSegment;
+  private final Extractor previousExtractor;
+  private final boolean shouldSpliceIn;
+  private final boolean needNewExtractor;
+  private final List<Format> muxedCaptionFormats;
 
   private final boolean isPackedAudio;
   private final Id3Decoder id3Decoder;
@@ -99,6 +104,7 @@
    * @param dataSpec Defines the data to be loaded.
    * @param initDataSpec Defines the initialization data to be fed to new extractors. May be null.
    * @param hlsUrl The url of the playlist from which this chunk was obtained.
+   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
    * @param trackSelectionReason See {@link #trackSelectionReason}.
    * @param trackSelectionData See {@link #trackSelectionData}.
    * @param startTimeUs The start time of the chunk in microseconds.
@@ -112,18 +118,19 @@
    * @param encryptionIv For AES encryption chunks, the encryption initialization vector.
    */
   public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initDataSpec,
-      HlsUrl hlsUrl, int trackSelectionReason, Object trackSelectionData, long startTimeUs,
-      long endTimeUs, int chunkIndex, int discontinuitySequenceNumber,
-      boolean isMasterTimestampSource, TimestampAdjuster timestampAdjuster,
-      HlsMediaChunk previousChunk, byte[] encryptionKey, byte[] encryptionIv) {
+      HlsUrl hlsUrl, List<Format> muxedCaptionFormats, int trackSelectionReason,
+      Object trackSelectionData, long startTimeUs, long endTimeUs, int chunkIndex,
+      int discontinuitySequenceNumber, boolean isMasterTimestampSource,
+      TimestampAdjuster timestampAdjuster, HlsMediaChunk previousChunk, byte[] encryptionKey,
+      byte[] encryptionIv) {
     super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, hlsUrl.format,
         trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs, chunkIndex);
+    this.discontinuitySequenceNumber = discontinuitySequenceNumber;
     this.initDataSpec = initDataSpec;
     this.hlsUrl = hlsUrl;
+    this.muxedCaptionFormats = muxedCaptionFormats;
     this.isMasterTimestampSource = isMasterTimestampSource;
     this.timestampAdjuster = timestampAdjuster;
-    this.discontinuitySequenceNumber = discontinuitySequenceNumber;
-    this.previousChunk = previousChunk;
     // Note: this.dataSource and dataSource may be different.
     this.isEncrypted = this.dataSource instanceof Aes128DataSource;
     lastPathSegment = dataSpec.uri.getLastPathSegment();
@@ -131,13 +138,19 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
         || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
         || lastPathSegment.endsWith(EC3_FILE_EXTENSION)
         || lastPathSegment.endsWith(MP3_FILE_EXTENSION);
-    if (isPackedAudio) {
-      id3Decoder = previousChunk != null ? previousChunk.id3Decoder : new Id3Decoder();
-      id3Data = previousChunk != null ? previousChunk.id3Data
-          : new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
+    if (previousChunk != null) {
+      id3Decoder = previousChunk.id3Decoder;
+      id3Data = previousChunk.id3Data;
+      previousExtractor = previousChunk.extractor;
+      shouldSpliceIn = previousChunk.hlsUrl != hlsUrl;
+      needNewExtractor = previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
+          || shouldSpliceIn;
     } else {
-      id3Decoder = null;
-      id3Data = null;
+      id3Decoder = isPackedAudio ? new Id3Decoder() : null;
+      id3Data = isPackedAudio ? new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH) : null;
+      previousExtractor = null;
+      shouldSpliceIn = false;
+      needNewExtractor = true;
     }
     initDataSource = dataSource;
     uid = UID_SOURCE.getAndIncrement();
@@ -151,7 +164,7 @@ public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initData
    */
   public void init(HlsSampleStreamWrapper output) {
     extractorOutput = output;
-    output.init(uid, previousChunk != null && previousChunk.hlsUrl != hlsUrl);
+    output.init(uid, shouldSpliceIn);
   }
 
   @Override
@@ -180,7 +193,7 @@ public boolean isLoadCanceled() {
   public void load() throws IOException, InterruptedException {
     if (extractor == null && !isPackedAudio) {
       // See HLS spec, version 20, Section 3.4 for more information on packed audio extraction.
-      extractor = buildExtractorByExtension();
+      extractor = createExtractor();
     }
     maybeLoadInitData();
     if (!loadCanceled) {
@@ -191,8 +204,8 @@ public void load() throws IOException, InterruptedException {
   // Internal loading methods.
 
   private void maybeLoadInitData() throws IOException, InterruptedException {
-    if ((previousChunk != null && previousChunk.extractor == extractor) || initLoadCompleted
-        || initDataSpec == null) {
+    if (previousExtractor == extractor || initLoadCompleted || initDataSpec == null) {
+      // According to spec, for packed audio, initDataSpec is expected to be null.
       return;
     }
     DataSpec initSegmentDataSpec = Util.getRemainderDataSpec(initDataSpec, initSegmentBytesLoaded);
@@ -229,6 +242,9 @@ private void loadMedia() throws IOException, InterruptedException {
     }
     if (!isMasterTimestampSource) {
       timestampAdjuster.waitUntilInitialized();
+    } else if (timestampAdjuster.getFirstSampleTimestampUs() == TimestampAdjuster.DO_NOT_OFFSET) {
+      // We're the master and we haven't set the desired first sample timestamp yet.
+      timestampAdjuster.setFirstSampleTimestampUs(startTimeUs);
     }
     try {
       ExtractorInput input = new DefaultExtractorInput(dataSource,
@@ -236,10 +252,8 @@ private void loadMedia() throws IOException, InterruptedException {
       if (extractor == null) {
         // Media segment format is packed audio.
         long id3Timestamp = peekId3PrivTimestamp(input);
-        if (id3Timestamp == C.TIME_UNSET) {
-          throw new ParserException("ID3 PRIV timestamp missing.");
-        }
-        extractor = buildPackedAudioExtractor(timestampAdjuster.adjustTsTimestamp(id3Timestamp));
+        extractor = buildPackedAudioExtractor(id3Timestamp != C.TIME_UNSET
+            ? timestampAdjuster.adjustTsTimestamp(id3Timestamp) : startTimeUs);
       }
       if (skipLoadedBytes) {
         input.skipFully(bytesLoaded);
@@ -322,27 +336,30 @@ private static DataSource buildDataSource(DataSource dataSource, byte[] encrypti
     return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
   }
 
-  private Extractor buildExtractorByExtension() {
-    // Set the extractor that will read the chunk.
+  private Extractor createExtractor() {
+    // Select the extractor that will read the chunk.
     Extractor extractor;
-    boolean needNewExtractor = previousChunk == null
-        || previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
-        || trackFormat != previousChunk.trackFormat;
     boolean usingNewExtractor = true;
-    if (lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
+    if (MimeTypes.TEXT_VTT.equals(hlsUrl.format.sampleMimeType)
+        || lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
         || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
       extractor = new WebvttExtractor(trackFormat.language, timestampAdjuster);
     } else if (!needNewExtractor) {
       // Only reuse TS and fMP4 extractors.
       usingNewExtractor = false;
-      extractor = previousChunk.extractor;
-    } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)) {
+      extractor = previousExtractor;
+    } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)
+        || lastPathSegment.startsWith(M4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 4)) {
       extractor = new FragmentedMp4Extractor(0, timestampAdjuster);
     } else {
       // MPEG-2 TS segments, but we need a new extractor.
       // This flag ensures the change of pid between streams does not affect the sample queues.
       @DefaultTsPayloadReaderFactory.Flags
       int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
+      if (!muxedCaptionFormats.isEmpty()) {
+        // The playlist declares closed caption renditions, we should ignore descriptors.
+        esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_OVERRIDE_CAPTION_DESCRIPTORS;
+      }
       String codecs = trackFormat.codecs;
       if (!TextUtils.isEmpty(codecs)) {
         // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
@@ -355,8 +372,8 @@ private Extractor buildExtractorByExtension() {
           esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
         }
       }
-      extractor = new TsExtractor(timestampAdjuster,
-          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags), true);
+      extractor = new TsExtractor(TsExtractor.MODE_HLS, timestampAdjuster,
+          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, muxedCaptionFormats));
     }
     if (usingNewExtractor) {
       extractor.init(extractorOutput);
@@ -372,7 +389,7 @@ private Extractor buildPackedAudioExtractor(long startTimeUs) {
         || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
       extractor = new Ac3Extractor(startTimeUs);
     } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
-      extractor = new Mp3Extractor(startTimeUs);
+      extractor = new Mp3Extractor(0, startTimeUs);
     } else {
       throw new IllegalArgumentException("Unkown extension for audio file: " + lastPathSegment);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index 6082372b05..3a833f5468 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -30,10 +30,10 @@
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistTracker;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
-import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.IdentityHashMap;
 import java.util.List;
 
@@ -44,7 +44,7 @@
     HlsPlaylistTracker.PlaylistEventListener {
 
   private final HlsPlaylistTracker playlistTracker;
-  private final DataSource.Factory dataSourceFactory;
+  private final HlsDataSourceFactory dataSourceFactory;
   private final int minLoadableRetryCount;
   private final EventDispatcher eventDispatcher;
   private final Allocator allocator;
@@ -61,7 +61,7 @@
   private HlsSampleStreamWrapper[] enabledSampleStreamWrappers;
   private CompositeSequenceableLoader sequenceableLoader;
 
-  public HlsMediaPeriod(HlsPlaylistTracker playlistTracker, DataSource.Factory dataSourceFactory,
+  public HlsMediaPeriod(HlsPlaylistTracker playlistTracker, HlsDataSourceFactory dataSourceFactory,
       int minLoadableRetryCount, EventDispatcher eventDispatcher, Allocator allocator,
       long positionUs) {
     this.playlistTracker = playlistTracker;
@@ -189,6 +189,11 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     return positionUs;
   }
 
+  @Override
+  public void discardBuffer(long positionUs) {
+    // Do nothing.
+  }
+
   @Override
   public boolean continueLoading(long positionUs) {
     return sequenceableLoader.continueLoading(positionUs);
@@ -317,7 +322,7 @@ private void buildAndPrepareSampleStreamWrappers() {
     HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[selectedVariants.size()];
     selectedVariants.toArray(variants);
     HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT,
-        variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormat);
+        variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormats);
     sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
     sampleStreamWrapper.setIsTimestampMaster(true);
     sampleStreamWrapper.continuePreparing();
@@ -327,7 +332,7 @@ private void buildAndPrepareSampleStreamWrappers() {
     // Build audio stream wrappers.
     for (int i = 0; i < audioRenditions.size(); i++) {
       sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_AUDIO,
-          new HlsUrl[] {audioRenditions.get(i)}, null, null);
+          new HlsUrl[] {audioRenditions.get(i)}, null, Collections.<Format>emptyList());
       sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
       sampleStreamWrapper.continuePreparing();
     }
@@ -336,20 +341,18 @@ private void buildAndPrepareSampleStreamWrappers() {
     for (int i = 0; i < subtitleRenditions.size(); i++) {
       HlsUrl url = subtitleRenditions.get(i);
       sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_TEXT, new HlsUrl[] {url}, null,
-          null);
+          Collections.<Format>emptyList());
       sampleStreamWrapper.prepareSingleTrack(url.format);
       sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
     }
   }
 
   private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[] variants,
-      Format muxedAudioFormat, Format muxedCaptionFormat) {
-    DataSource dataSource = dataSourceFactory.createDataSource();
-    HlsChunkSource defaultChunkSource = new HlsChunkSource(playlistTracker, variants, dataSource,
-        timestampAdjusterProvider);
+      Format muxedAudioFormat, List<Format> muxedCaptionFormats) {
+    HlsChunkSource defaultChunkSource = new HlsChunkSource(playlistTracker, variants,
+        dataSourceFactory, timestampAdjusterProvider, muxedCaptionFormats);
     return new HlsSampleStreamWrapper(trackType, this, defaultChunkSource, allocator,
-        preparePositionUs, muxedAudioFormat, muxedCaptionFormat, minLoadableRetryCount,
-        eventDispatcher);
+        preparePositionUs, muxedAudioFormat, minLoadableRetryCount, eventDispatcher);
   }
 
   private void continuePreparingOrLoading() {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index 869efa6cdc..3cd9f19522 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -44,7 +44,7 @@
   public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
 
   private final Uri manifestUri;
-  private final DataSource.Factory dataSourceFactory;
+  private final HlsDataSourceFactory dataSourceFactory;
   private final int minLoadableRetryCount;
   private final EventDispatcher eventDispatcher;
 
@@ -60,6 +60,13 @@ public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory, Han
   public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
       int minLoadableRetryCount, Handler eventHandler,
       AdaptiveMediaSourceEventListener eventListener) {
+    this(manifestUri, new DefaultHlsDataSourceFactory(dataSourceFactory), minLoadableRetryCount,
+        eventHandler, eventListener);
+  }
+
+  public HlsMediaSource(Uri manifestUri, HlsDataSourceFactory dataSourceFactory,
+      int minLoadableRetryCount, Handler eventHandler,
+      AdaptiveMediaSourceEventListener eventListener) {
     this.manifestUri = manifestUri;
     this.dataSourceFactory = dataSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
@@ -94,26 +101,36 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSource() {
-    playlistTracker.release();
-    playlistTracker = null;
+    if (playlistTracker != null) {
+      playlistTracker.release();
+      playlistTracker = null;
+    }
     sourceListener = null;
   }
 
   @Override
   public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
     SinglePeriodTimeline timeline;
+    long windowDefaultStartPositionUs = playlist.startOffsetUs;
     if (playlistTracker.isLive()) {
-      // TODO: fix windowPositionInPeriodUs when playlist is empty.
+      long periodDurationUs = playlist.hasEndTag ? (playlist.startTimeUs + playlist.durationUs)
+          : C.TIME_UNSET;
       List<HlsMediaPlaylist.Segment> segments = playlist.segments;
-      long windowDefaultStartPositionUs = segments.isEmpty() ? 0
-          : segments.get(Math.max(0, segments.size() - 3)).relativeStartTimeUs;
-      timeline = new SinglePeriodTimeline(C.TIME_UNSET, playlist.durationUs,
+      if (windowDefaultStartPositionUs == C.TIME_UNSET) {
+        windowDefaultStartPositionUs = segments.isEmpty() ? 0
+            : segments.get(Math.max(0, segments.size() - 3)).relativeStartTimeUs;
+      }
+      timeline = new SinglePeriodTimeline(periodDurationUs, playlist.durationUs,
           playlist.startTimeUs, windowDefaultStartPositionUs, true, !playlist.hasEndTag);
     } else /* not live */ {
+      if (windowDefaultStartPositionUs == C.TIME_UNSET) {
+        windowDefaultStartPositionUs = 0;
+      }
       timeline = new SinglePeriodTimeline(playlist.startTimeUs + playlist.durationUs,
-          playlist.durationUs, playlist.startTimeUs, 0, true, false);
+          playlist.durationUs, playlist.startTimeUs, windowDefaultStartPositionUs, true, false);
     }
-    sourceListener.onSourceInfoRefreshed(timeline, playlist);
+    sourceListener.onSourceInfoRefreshed(timeline,
+        new HlsManifest(playlistTracker.getMasterPlaylist(), playlist));
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
index c63cf3e5a4..d8eb7e1ae8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
@@ -26,7 +26,7 @@
 /* package */ final class HlsSampleStream implements SampleStream {
 
   public final int group;
-  
+
   private final HlsSampleStreamWrapper sampleStreamWrapper;
 
   public HlsSampleStream(HlsSampleStreamWrapper sampleStreamWrapper, int group) {
@@ -45,8 +45,8 @@ public void maybeThrowError() throws IOException {
   }
 
   @Override
-  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
-    return sampleStreamWrapper.readData(group, formatHolder, buffer);
+  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean requireFormat) {
+    return sampleStreamWrapper.readData(group, formatHolder, buffer, requireFormat);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index a9bbddb69c..8bd966f177 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -77,7 +77,6 @@
   private final HlsChunkSource chunkSource;
   private final Allocator allocator;
   private final Format muxedAudioFormat;
-  private final Format muxedCaptionFormat;
   private final int minLoadableRetryCount;
   private final Loader loader;
   private final EventDispatcher eventDispatcher;
@@ -112,23 +111,19 @@
    * @param chunkSource A {@link HlsChunkSource} from which chunks to load are obtained.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
    * @param positionUs The position from which to start loading media.
-   * @param muxedAudioFormat If HLS master playlist indicates that the stream contains muxed audio,
-   *     this is the audio {@link Format} as defined by the playlist.
-   * @param muxedCaptionFormat If HLS master playlist indicates that the stream contains muxed
-   *     captions, this is the audio {@link Format} as defined by the playlist.
+   * @param muxedAudioFormat Optional muxed audio {@link Format} as defined by the master playlist.
    * @param minLoadableRetryCount The minimum number of times that the source should retry a load
    *     before propagating an error.
    * @param eventDispatcher A dispatcher to notify of events.
    */
   public HlsSampleStreamWrapper(int trackType, Callback callback, HlsChunkSource chunkSource,
-      Allocator allocator, long positionUs, Format muxedAudioFormat, Format muxedCaptionFormat,
-      int minLoadableRetryCount, EventDispatcher eventDispatcher) {
+      Allocator allocator, long positionUs, Format muxedAudioFormat, int minLoadableRetryCount,
+      EventDispatcher eventDispatcher) {
     this.trackType = trackType;
     this.callback = callback;
     this.chunkSource = chunkSource;
     this.allocator = allocator;
     this.muxedAudioFormat = muxedAudioFormat;
-    this.muxedCaptionFormat = muxedCaptionFormat;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventDispatcher = eventDispatcher;
     loader = new Loader("Loader:HlsSampleStreamWrapper");
@@ -157,7 +152,7 @@ public void continuePreparing() {
    * prepare.
    */
   public void prepareSingleTrack(Format format) {
-    track(0).format(format);
+    track(0, C.TRACK_TYPE_UNKNOWN).format(format);
     sampleQueuesBuilt = true;
     maybeFinishPrepare();
   }
@@ -183,6 +178,7 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
       }
     }
     // Enable new tracks.
+    TrackSelection primaryTrackSelection = null;
     boolean selectedNewTracks = false;
     for (int i = 0; i < selections.length; i++) {
       if (streams[i] == null && selections[i] != null) {
@@ -190,6 +186,7 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
         int group = trackGroups.indexOf(selection.getTrackGroup());
         setTrackGroupEnabledState(group, true);
         if (group == primaryTrackGroupIndex) {
+          primaryTrackSelection = selection;
           chunkSource.selectTracks(selection);
         }
         streams[i] = new HlsSampleStream(this, group);
@@ -206,6 +203,14 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
           sampleQueues.valueAt(i).disable();
         }
       }
+      if (primaryTrackSelection != null && !mediaChunks.isEmpty()) {
+        primaryTrackSelection.updateSelectedTrack(0);
+        int chunkIndex = chunkSource.getTrackGroup().indexOf(mediaChunks.getLast().trackFormat);
+        if (primaryTrackSelection.getSelectedIndexInTrackGroup() != chunkIndex) {
+          // The loaded preparation chunk does match the selection. We discard it.
+          seekTo(lastSeekPositionUs);
+        }
+      }
     }
     // Cancel requests if necessary.
     if (enabledTrackCount == 0) {
@@ -266,15 +271,6 @@ public void release() {
     released = true;
   }
 
-  public long getLargestQueuedTimestampUs() {
-    long largestQueuedTimestampUs = Long.MIN_VALUE;
-    for (int i = 0; i < sampleQueues.size(); i++) {
-      largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs,
-          sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
-    }
-    return largestQueuedTimestampUs;
-  }
-
   public void setIsTimestampMaster(boolean isTimestampMaster) {
     chunkSource.setIsTimestampMaster(isTimestampMaster);
   }
@@ -294,7 +290,8 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
     chunkSource.maybeThrowError();
   }
 
-  /* package */ int readData(int group, FormatHolder formatHolder, DecoderInputBuffer buffer) {
+  /* package */ int readData(int group, FormatHolder formatHolder, DecoderInputBuffer buffer,
+      boolean requireFormat) {
     if (isPendingReset()) {
       return C.RESULT_NOTHING_READ;
     }
@@ -311,8 +308,8 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
     }
     downstreamTrackFormat = trackFormat;
 
-    return sampleQueues.valueAt(group).readData(formatHolder, buffer, loadingFinished,
-        lastSeekPositionUs);
+    return sampleQueues.valueAt(group).readData(formatHolder, buffer, requireFormat,
+        loadingFinished, lastSeekPositionUs);
   }
 
   /* package */ void skipToKeyframeBefore(int group, long timeUs) {
@@ -466,7 +463,7 @@ public void init(int chunkUid, boolean shouldSpliceIn) {
   // ExtractorOutput implementation. Called by the loading thread.
 
   @Override
-  public DefaultTrackOutput track(int id) {
+  public DefaultTrackOutput track(int id, int type) {
     if (sampleQueues.indexOfKey(id) >= 0) {
       return sampleQueues.get(id);
     }
@@ -589,14 +586,8 @@ private void buildTracks() {
         trackGroups[i] = new TrackGroup(formats);
         primaryTrackGroupIndex = i;
       } else {
-        Format trackFormat = null;
-        if (primaryExtractorTrackType == PRIMARY_TYPE_VIDEO) {
-          if (MimeTypes.isAudio(sampleFormat.sampleMimeType)) {
-            trackFormat = muxedAudioFormat;
-          } else if (MimeTypes.APPLICATION_CEA608.equals(sampleFormat.sampleMimeType)) {
-            trackFormat = muxedCaptionFormat;
-          }
-        }
+        Format trackFormat = primaryExtractorTrackType == PRIMARY_TYPE_VIDEO
+            && MimeTypes.isAudio(sampleFormat.sampleMimeType) ? muxedAudioFormat : null;
         trackGroups[i] = new TrackGroup(deriveFormat(trackFormat, sampleFormat));
       }
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
index 624e5fa4f8..85a4276ea2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
@@ -16,7 +16,7 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.util.SparseArray;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 
 /**
  * Provides {@link TimestampAdjuster} instances for use during HLS playbacks.
@@ -36,13 +36,12 @@ public TimestampAdjusterProvider() {
    * a chunk with a given discontinuity sequence.
    *
    * @param discontinuitySequence The chunk's discontinuity sequence.
-   * @param startTimeUs The chunk's start time.
    * @return A {@link TimestampAdjuster}.
    */
-  public TimestampAdjuster getAdjuster(int discontinuitySequence, long startTimeUs) {
+  public TimestampAdjuster getAdjuster(int discontinuitySequence) {
     TimestampAdjuster adjuster = timestampAdjusters.get(discontinuitySequence);
     if (adjuster == null) {
-      adjuster = new TimestampAdjuster(startTimeUs);
+      adjuster = new TimestampAdjuster(TimestampAdjuster.DO_NOT_OFFSET);
       timestampAdjusters.put(discontinuitySequence, adjuster);
     }
     return adjuster;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
index 498dd55004..12ea2c16c7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/WebvttExtractor.java
@@ -24,12 +24,12 @@
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import com.google.android.exoplayer2.text.webvtt.WebvttParserUtil;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.regex.Matcher;
@@ -167,7 +167,7 @@ private void processSample() throws ParserException {
   }
 
   private TrackOutput buildTrackOutput(long subsampleOffsetUs) {
-    TrackOutput trackOutput = output.track(0);
+    TrackOutput trackOutput = output.track(0, C.TRACK_TYPE_TEXT);
     trackOutput.format(Format.createTextSampleFormat(null, MimeTypes.TEXT_VTT, null,
         Format.NO_VALUE, 0, language, null, subsampleOffsetUs));
     output.endTracks();
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
index 4aaec59f7d..5580017805 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
@@ -31,27 +31,18 @@
    */
   public static final class HlsUrl {
 
-    public final String name;
     public final String url;
     public final Format format;
-    public final Format videoFormat;
-    public final Format audioFormat;
-    public final Format[] textFormats;
 
     public static HlsUrl createMediaPlaylistHlsUrl(String baseUri) {
       Format format = Format.createContainerFormat("0", MimeTypes.APPLICATION_M3U8, null, null,
-          Format.NO_VALUE);
-      return new HlsUrl(null, baseUri, format, null, null, null);
+          Format.NO_VALUE, 0, null);
+      return new HlsUrl(baseUri, format);
     }
 
-    public HlsUrl(String name, String url, Format format, Format videoFormat, Format audioFormat,
-        Format[] textFormats) {
-      this.name = name;
+    public HlsUrl(String url, Format format) {
       this.url = url;
       this.format = format;
-      this.videoFormat = videoFormat;
-      this.audioFormat = audioFormat;
-      this.textFormats = textFormats;
     }
 
   }
@@ -61,22 +52,23 @@ public HlsUrl(String name, String url, Format format, Format videoFormat, Format
   public final List<HlsUrl> subtitles;
 
   public final Format muxedAudioFormat;
-  public final Format muxedCaptionFormat;
+  public final List<Format> muxedCaptionFormats;
 
   public HlsMasterPlaylist(String baseUri, List<HlsUrl> variants, List<HlsUrl> audios,
-      List<HlsUrl> subtitles, Format muxedAudioFormat, Format muxedCaptionFormat) {
+      List<HlsUrl> subtitles, Format muxedAudioFormat, List<Format> muxedCaptionFormats) {
     super(baseUri, HlsPlaylist.TYPE_MASTER);
     this.variants = Collections.unmodifiableList(variants);
     this.audios = Collections.unmodifiableList(audios);
     this.subtitles = Collections.unmodifiableList(subtitles);
     this.muxedAudioFormat = muxedAudioFormat;
-    this.muxedCaptionFormat = muxedCaptionFormat;
+    this.muxedCaptionFormats = Collections.unmodifiableList(muxedCaptionFormats);
   }
 
   public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUri) {
     List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUri));
     List<HlsUrl> emptyList = Collections.emptyList();
-    return new HlsMasterPlaylist(null, variant, emptyList, emptyList, null, null);
+    return new HlsMasterPlaylist(null, variant, emptyList, emptyList, null,
+        Collections.<Format>emptyList());
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index fc70ec6de1..9ef28bdb8d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2.source.hls.playlist;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
 import java.util.List;
 
@@ -31,7 +34,7 @@
 
     public final String url;
     public final long durationUs;
-    public final int discontinuitySequenceNumber;
+    public final int relativeDiscontinuitySequence;
     public final long relativeStartTimeUs;
     public final boolean isEncrypted;
     public final String encryptionKeyUri;
@@ -43,12 +46,12 @@ public Segment(String uri, long byterangeOffset, long byterangeLength) {
       this(uri, 0, -1, C.TIME_UNSET, false, null, null, byterangeOffset, byterangeLength);
     }
 
-    public Segment(String uri, long durationUs, int discontinuitySequenceNumber,
+    public Segment(String uri, long durationUs, int relativeDiscontinuitySequence,
         long relativeStartTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
         long byterangeOffset, long byterangeLength) {
       this.url = uri;
       this.durationUs = durationUs;
-      this.discontinuitySequenceNumber = discontinuitySequenceNumber;
+      this.relativeDiscontinuitySequence = relativeDiscontinuitySequence;
       this.relativeStartTimeUs = relativeStartTimeUs;
       this.isEncrypted = isEncrypted;
       this.encryptionKeyUri = encryptionKeyUri;
@@ -65,7 +68,21 @@ public int compareTo(Long relativeStartTimeUs) {
 
   }
 
+  /**
+   * Type of the playlist as specified by #EXT-X-PLAYLIST-TYPE.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({PLAYLIST_TYPE_UNKNOWN, PLAYLIST_TYPE_VOD, PLAYLIST_TYPE_EVENT})
+  public @interface PlaylistType {}
+  public static final int PLAYLIST_TYPE_UNKNOWN = 0;
+  public static final int PLAYLIST_TYPE_VOD = 1;
+  public static final int PLAYLIST_TYPE_EVENT = 2;
+
+  @PlaylistType public final int playlistType;
+  public final long startOffsetUs;
   public final long startTimeUs;
+  public final boolean hasDiscontinuitySequence;
+  public final int discontinuitySequence;
   public final int mediaSequence;
   public final int version;
   public final long targetDurationUs;
@@ -75,11 +92,15 @@ public int compareTo(Long relativeStartTimeUs) {
   public final List<Segment> segments;
   public final long durationUs;
 
-  public HlsMediaPlaylist(String baseUri, long startTimeUs, int mediaSequence,
-      int version, long targetDurationUs, boolean hasEndTag, boolean hasProgramDateTime,
-      Segment initializationSegment, List<Segment> segments) {
+  public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, long startOffsetUs,
+      long startTimeUs, boolean hasDiscontinuitySequence, int discontinuitySequence,
+      int mediaSequence, int version, long targetDurationUs, boolean hasEndTag,
+      boolean hasProgramDateTime, Segment initializationSegment, List<Segment> segments) {
     super(baseUri, HlsPlaylist.TYPE_MEDIA);
+    this.playlistType = playlistType;
     this.startTimeUs = startTimeUs;
+    this.hasDiscontinuitySequence = hasDiscontinuitySequence;
+    this.discontinuitySequence = discontinuitySequence;
     this.mediaSequence = mediaSequence;
     this.version = version;
     this.targetDurationUs = targetDurationUs;
@@ -87,28 +108,68 @@ public HlsMediaPlaylist(String baseUri, long startTimeUs, int mediaSequence,
     this.hasProgramDateTime = hasProgramDateTime;
     this.initializationSegment = initializationSegment;
     this.segments = Collections.unmodifiableList(segments);
-
     if (!segments.isEmpty()) {
       Segment last = segments.get(segments.size() - 1);
       durationUs = last.relativeStartTimeUs + last.durationUs;
     } else {
       durationUs = 0;
     }
+    this.startOffsetUs = startOffsetUs == C.TIME_UNSET ? C.TIME_UNSET
+        : startOffsetUs >= 0 ? startOffsetUs : durationUs + startOffsetUs;
   }
 
+  /**
+   * Returns whether this playlist is newer than {@code other}.
+   *
+   * @param other The playlist to compare.
+   * @return Whether this playlist is newer than {@code other}.
+   */
   public boolean isNewerThan(HlsMediaPlaylist other) {
-    return other == null || mediaSequence > other.mediaSequence
-        || (mediaSequence == other.mediaSequence && segments.size() > other.segments.size())
-        || (hasEndTag && !other.hasEndTag);
+    if (other == null || mediaSequence > other.mediaSequence) {
+      return true;
+    }
+    if (mediaSequence < other.mediaSequence) {
+      return false;
+    }
+    // The media sequences are equal.
+    int segmentCount = segments.size();
+    int otherSegmentCount = other.segments.size();
+    return segmentCount > otherSegmentCount
+        || (segmentCount == otherSegmentCount && hasEndTag && !other.hasEndTag);
   }
 
   public long getEndTimeUs() {
     return startTimeUs + durationUs;
   }
 
-  public HlsMediaPlaylist copyWithStartTimeUs(long startTimeUs) {
-    return new HlsMediaPlaylist(baseUri, startTimeUs, mediaSequence, version, targetDurationUs,
-        hasEndTag, hasProgramDateTime, initializationSegment, segments);
+  /**
+   * Returns a playlist identical to this one except for the start time, the discontinuity sequence
+   * and {@code hasDiscontinuitySequence} values. The first two are set to the specified values,
+   * {@code hasDiscontinuitySequence} is set to true.
+   *
+   * @param startTimeUs The start time for the returned playlist.
+   * @param discontinuitySequence The discontinuity sequence for the returned playlist.
+   * @return The playlist.
+   */
+  public HlsMediaPlaylist copyWith(long startTimeUs, int discontinuitySequence) {
+    return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs, true,
+        discontinuitySequence, mediaSequence, version, targetDurationUs, hasEndTag,
+        hasProgramDateTime, initializationSegment, segments);
+  }
+
+  /**
+   * Returns a playlist identical to this one except that an end tag is added. If an end tag is
+   * already present then the playlist will return itself.
+   *
+   * @return The playlist.
+   */
+  public HlsMediaPlaylist copyWithEndTag() {
+    if (this.hasEndTag) {
+      return this;
+    }
+    return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, startTimeUs,
+        hasDiscontinuitySequence, discontinuitySequence, mediaSequence, version, targetDurationUs,
+        true, hasProgramDateTime, initializationSegment, segments);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
index fb62d9978e..aecd2fb324 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
@@ -34,8 +34,7 @@
   public static final int TYPE_MEDIA = 1;
 
   public final String baseUri;
-  @Type
-  public final int type;
+  @Type public final int type;
 
   protected HlsPlaylist(String baseUri, @Type int type) {
     this.baseUri = baseUri;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 1932caccf7..d24264cae6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.source.UnrecognizedInputFormatException;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -39,16 +40,20 @@
  */
 public final class HlsPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
 
+  private static final String PLAYLIST_HEADER = "#EXTM3U";
+
   private static final String TAG_VERSION = "#EXT-X-VERSION";
+  private static final String TAG_PLAYLIST_TYPE = "#EXT-X-PLAYLIST-TYPE";
   private static final String TAG_STREAM_INF = "#EXT-X-STREAM-INF";
   private static final String TAG_MEDIA = "#EXT-X-MEDIA";
+  private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
   private static final String TAG_DISCONTINUITY = "#EXT-X-DISCONTINUITY";
   private static final String TAG_DISCONTINUITY_SEQUENCE = "#EXT-X-DISCONTINUITY-SEQUENCE";
   private static final String TAG_PROGRAM_DATE_TIME = "#EXT-X-PROGRAM-DATE-TIME";
   private static final String TAG_INIT_SEGMENT = "#EXT-X-MAP";
   private static final String TAG_MEDIA_DURATION = "#EXTINF";
   private static final String TAG_MEDIA_SEQUENCE = "#EXT-X-MEDIA-SEQUENCE";
-  private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
+  private static final String TAG_START = "#EXT-X-START";
   private static final String TAG_ENDLIST = "#EXT-X-ENDLIST";
   private static final String TAG_KEY = "#EXT-X-KEY";
   private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
@@ -70,10 +75,13 @@
   private static final Pattern REGEX_TARGET_DURATION = Pattern.compile(TAG_TARGET_DURATION
       + ":(\\d+)\\b");
   private static final Pattern REGEX_VERSION = Pattern.compile(TAG_VERSION + ":(\\d+)\\b");
+  private static final Pattern REGEX_PLAYLIST_TYPE = Pattern.compile(TAG_PLAYLIST_TYPE
+      + ":(.+)\\b");
   private static final Pattern REGEX_MEDIA_SEQUENCE = Pattern.compile(TAG_MEDIA_SEQUENCE
       + ":(\\d+)\\b");
   private static final Pattern REGEX_MEDIA_DURATION = Pattern.compile(TAG_MEDIA_DURATION
       + ":([\\d\\.]+)\\b");
+  private static final Pattern REGEX_TIME_OFFSET = Pattern.compile("TIME-OFFSET=(-?[\\d\\.]+)\\b");
   private static final Pattern REGEX_BYTERANGE = Pattern.compile(TAG_BYTERANGE
       + ":(\\d+(?:@\\d+)?)\\b");
   private static final Pattern REGEX_ATTR_BYTERANGE =
@@ -86,7 +94,8 @@
       + "|" + TYPE_SUBTITLES + "|" + TYPE_CLOSED_CAPTIONS + ")");
   private static final Pattern REGEX_LANGUAGE = Pattern.compile("LANGUAGE=\"(.+?)\"");
   private static final Pattern REGEX_NAME = Pattern.compile("NAME=\"(.+?)\"");
-  private static final Pattern REGEX_INSTREAM_ID = Pattern.compile("INSTREAM-ID=\"(.+?)\"");
+  private static final Pattern REGEX_INSTREAM_ID =
+      Pattern.compile("INSTREAM-ID=\"((?:CC|SERVICE)\\d+)\"");
   private static final Pattern REGEX_AUTOSELECT = compileBooleanAttrPattern("AUTOSELECT");
   private static final Pattern REGEX_DEFAULT = compileBooleanAttrPattern("DEFAULT");
   private static final Pattern REGEX_FORCED = compileBooleanAttrPattern("FORCED");
@@ -97,6 +106,10 @@ public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
     Queue<String> extraLines = new LinkedList<>();
     String line;
     try {
+      if (!checkPlaylistHeader(reader)) {
+        throw new UnrecognizedInputFormatException("Input does not start with the #EXTM3U header.",
+            uri);
+      }
       while ((line = reader.readLine()) != null) {
         line = line.trim();
         if (line.isEmpty()) {
@@ -119,18 +132,47 @@ public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
         }
       }
     } finally {
-      reader.close();
+      Util.closeQuietly(reader);
     }
     throw new ParserException("Failed to parse the playlist, could not identify any tags.");
   }
 
+  private static boolean checkPlaylistHeader(BufferedReader reader) throws IOException {
+    int last = reader.read();
+    if (last == 0xEF) {
+      if (reader.read() != 0xBB || reader.read() != 0xBF) {
+        return false;
+      }
+      // The playlist contains a Byte Order Mark, which gets discarded.
+      last = reader.read();
+    }
+    last = skipIgnorableWhitespace(reader, true, last);
+    int playlistHeaderLength = PLAYLIST_HEADER.length();
+    for (int i = 0; i < playlistHeaderLength; i++) {
+      if (last != PLAYLIST_HEADER.charAt(i)) {
+        return false;
+      }
+      last = reader.read();
+    }
+    last = skipIgnorableWhitespace(reader, false, last);
+    return Util.isLinebreak(last);
+  }
+
+  private static int skipIgnorableWhitespace(BufferedReader reader, boolean skipLinebreaks, int c)
+      throws IOException {
+    while (c != -1 && Character.isWhitespace(c) && (skipLinebreaks || !Util.isLinebreak(c))) {
+      c = reader.read();
+    }
+    return c;
+  }
+
   private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
     ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> audios = new ArrayList<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> subtitles = new ArrayList<>();
     Format muxedAudioFormat = null;
-    Format muxedCaptionFormat = null;
+    ArrayList<Format> muxedCaptionFormats = new ArrayList<>();
 
     String line;
     while (iterator.hasNext()) {
@@ -138,31 +180,37 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
       if (line.startsWith(TAG_MEDIA)) {
         @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
         String uri = parseOptionalStringAttr(line, REGEX_URI);
-        String name = parseStringAttr(line, REGEX_NAME);
+        String id = parseStringAttr(line, REGEX_NAME);
         String language = parseOptionalStringAttr(line, REGEX_LANGUAGE);
         Format format;
         switch (parseStringAttr(line, REGEX_TYPE)) {
           case TYPE_AUDIO:
-             format = Format.createAudioContainerFormat(name, MimeTypes.APPLICATION_M3U8,
-                null, null, Format.NO_VALUE, Format.NO_VALUE, Format.NO_VALUE, null, selectionFlags,
-                language);
+            format = Format.createAudioContainerFormat(id, MimeTypes.APPLICATION_M3U8, null, null,
+                Format.NO_VALUE, Format.NO_VALUE, Format.NO_VALUE, null, selectionFlags, language);
             if (uri == null) {
               muxedAudioFormat = format;
             } else {
-              audios.add(new HlsMasterPlaylist.HlsUrl(name, uri, format, null, format, null));
+              audios.add(new HlsMasterPlaylist.HlsUrl(uri, format));
             }
             break;
           case TYPE_SUBTITLES:
-            format = Format.createTextContainerFormat(name, MimeTypes.APPLICATION_M3U8,
+            format = Format.createTextContainerFormat(id, MimeTypes.APPLICATION_M3U8,
                 MimeTypes.TEXT_VTT, null, Format.NO_VALUE, selectionFlags, language);
-            subtitles.add(new HlsMasterPlaylist.HlsUrl(name, uri, format, null, format, null));
+            subtitles.add(new HlsMasterPlaylist.HlsUrl(uri, format));
             break;
           case TYPE_CLOSED_CAPTIONS:
-            if ("CC1".equals(parseOptionalStringAttr(line, REGEX_INSTREAM_ID))) {
-              muxedCaptionFormat = Format.createTextContainerFormat(name,
-                  MimeTypes.APPLICATION_M3U8, MimeTypes.APPLICATION_CEA608, null, Format.NO_VALUE,
-                  selectionFlags, language);
+            String instreamId = parseStringAttr(line, REGEX_INSTREAM_ID);
+            String mimeType;
+            int accessibilityChannel;
+            if (instreamId.startsWith("CC")) {
+              mimeType = MimeTypes.APPLICATION_CEA608;
+              accessibilityChannel = Integer.parseInt(instreamId.substring(2));
+            } else /* starts with SERVICE */ {
+              mimeType = MimeTypes.APPLICATION_CEA708;
+              accessibilityChannel = Integer.parseInt(instreamId.substring(7));
             }
+            muxedCaptionFormats.add(Format.createTextContainerFormat(id, null, mimeType, null,
+                Format.NO_VALUE, selectionFlags, language, accessibilityChannel));
             break;
           default:
             // Do nothing.
@@ -188,14 +236,14 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
           height = Format.NO_VALUE;
         }
         line = iterator.next();
-        String name = Integer.toString(variants.size());
-        Format format = Format.createVideoContainerFormat(name, MimeTypes.APPLICATION_M3U8, null,
-            codecs, bitrate, width, height, Format.NO_VALUE, null);
-        variants.add(new HlsMasterPlaylist.HlsUrl(name, line, format, null, null, null));
+        Format format = Format.createVideoContainerFormat(Integer.toString(variants.size()),
+            MimeTypes.APPLICATION_M3U8, null, codecs, bitrate, width, height, Format.NO_VALUE, null,
+            0);
+        variants.add(new HlsMasterPlaylist.HlsUrl(line, format));
       }
     }
     return new HlsMasterPlaylist(baseUri, variants, audios, subtitles, muxedAudioFormat,
-        muxedCaptionFormat);
+        muxedCaptionFormats);
   }
 
   @C.SelectionFlags
@@ -207,6 +255,8 @@ private static int parseSelectionFlags(String line) {
 
   private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
+    @HlsMediaPlaylist.PlaylistType int playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_UNKNOWN;
+    long startOffsetUs = C.TIME_UNSET;
     int mediaSequence = 0;
     int version = 1; // Default version == 1.
     long targetDurationUs = C.TIME_UNSET;
@@ -215,7 +265,9 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     List<Segment> segments = new ArrayList<>();
 
     long segmentDurationUs = 0;
-    int discontinuitySequenceNumber = 0;
+    boolean hasDiscontinuitySequence = false;
+    int playlistDiscontinuitySequence = 0;
+    int relativeDiscontinuitySequence = 0;
     long playlistStartTimeUs = 0;
     long segmentStartTimeUs = 0;
     long segmentByteRangeOffset = 0;
@@ -229,7 +281,18 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     String line;
     while (iterator.hasNext()) {
       line = iterator.next();
-      if (line.startsWith(TAG_INIT_SEGMENT)) {
+      if (line.startsWith(TAG_PLAYLIST_TYPE)) {
+        String playlistTypeString = parseStringAttr(line, REGEX_PLAYLIST_TYPE);
+        if ("VOD".equals(playlistTypeString)) {
+          playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_VOD;
+        } else if ("EVENT".equals(playlistTypeString)) {
+          playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_EVENT;
+        } else {
+          throw new ParserException("Illegal playlist type: " + playlistTypeString);
+        }
+      } else if (line.startsWith(TAG_START)) {
+        startOffsetUs = (long) (parseDoubleAttr(line, REGEX_TIME_OFFSET) * C.MICROS_PER_SECOND);
+      } else if (line.startsWith(TAG_INIT_SEGMENT)) {
         String uri = parseStringAttr(line, REGEX_URI);
         String byteRange = parseOptionalStringAttr(line, REGEX_ATTR_BYTERANGE);
         if (byteRange != null) {
@@ -270,9 +333,10 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
           segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
         }
       } else if (line.startsWith(TAG_DISCONTINUITY_SEQUENCE)) {
-        discontinuitySequenceNumber = Integer.parseInt(line.substring(line.indexOf(':') + 1));
+        hasDiscontinuitySequence = true;
+        playlistDiscontinuitySequence = Integer.parseInt(line.substring(line.indexOf(':') + 1));
       } else if (line.equals(TAG_DISCONTINUITY)) {
-        discontinuitySequenceNumber++;
+        relativeDiscontinuitySequence++;
       } else if (line.startsWith(TAG_PROGRAM_DATE_TIME)) {
         if (playlistStartTimeUs == 0) {
           long programDatetimeUs =
@@ -292,7 +356,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         if (segmentByteRangeLength == C.LENGTH_UNSET) {
           segmentByteRangeOffset = 0;
         }
-        segments.add(new Segment(line, segmentDurationUs, discontinuitySequenceNumber,
+        segments.add(new Segment(line, segmentDurationUs, relativeDiscontinuitySequence,
             segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
             segmentByteRangeOffset, segmentByteRangeLength));
         segmentStartTimeUs += segmentDurationUs;
@@ -305,7 +369,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         hasEndTag = true;
       }
     }
-    return new HlsMediaPlaylist(baseUri, playlistStartTimeUs, mediaSequence, version,
+    return new HlsMediaPlaylist(playlistType, baseUri, startOffsetUs, playlistStartTimeUs,
+        hasDiscontinuitySequence, playlistDiscontinuitySequence, mediaSequence, version,
         targetDurationUs, hasEndTag, playlistStartTimeUs != 0, initializationSegment, segments);
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index d25e5b1d9c..311f279b96 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
+import com.google.android.exoplayer2.source.hls.HlsDataSourceFactory;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
 import com.google.android.exoplayer2.upstream.DataSource;
@@ -81,7 +82,7 @@
   private static final long PRIMARY_URL_KEEPALIVE_MS = 15000;
 
   private final Uri initialPlaylistUri;
-  private final DataSource.Factory dataSourceFactory;
+  private final HlsDataSourceFactory dataSourceFactory;
   private final HlsPlaylistParser playlistParser;
   private final int minRetryCount;
   private final IdentityHashMap<HlsUrl, MediaPlaylistBundle> playlistBundles;
@@ -105,7 +106,7 @@
    *     playlist.
    * @param primaryPlaylistListener A callback for the primary playlist change events.
    */
-  public HlsPlaylistTracker(Uri initialPlaylistUri, DataSource.Factory dataSourceFactory,
+  public HlsPlaylistTracker(Uri initialPlaylistUri, HlsDataSourceFactory dataSourceFactory,
       EventDispatcher eventDispatcher, int minRetryCount,
       PrimaryPlaylistListener primaryPlaylistListener) {
     this.initialPlaylistUri = initialPlaylistUri;
@@ -143,8 +144,8 @@ public void removeListener(PlaylistEventListener listener) {
    */
   public void start() {
     ParsingLoadable<HlsPlaylist> masterPlaylistLoadable = new ParsingLoadable<>(
-        dataSourceFactory.createDataSource(), initialPlaylistUri, C.DATA_TYPE_MANIFEST,
-        playlistParser);
+        dataSourceFactory.createDataSource(C.DATA_TYPE_MANIFEST), initialPlaylistUri,
+        C.DATA_TYPE_MANIFEST, playlistParser);
     initialPlaylistLoader.startLoading(masterPlaylistLoadable, this, minRetryCount);
   }
 
@@ -166,8 +167,24 @@ public HlsMasterPlaylist getMasterPlaylist() {
    *     be null if no snapshot has been loaded yet.
    */
   public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url) {
-    maybeSetPrimaryUrl(url);
-    return playlistBundles.get(url).getPlaylistSnapshot();
+    HlsMediaPlaylist snapshot = playlistBundles.get(url).getPlaylistSnapshot();
+    if (snapshot != null) {
+      maybeSetPrimaryUrl(url);
+    }
+    return snapshot;
+  }
+
+  /**
+   * Returns whether the snapshot of the playlist referenced by the provided {@link HlsUrl} is
+   * valid, meaning all the segments referenced by the playlist are expected to be available. If the
+   * playlist is not valid then some of the segments may no longer be available.
+
+   * @param url The {@link HlsUrl}.
+   * @return Whether the snapshot of the playlist referenced by the provided {@link HlsUrl} is
+   *     valid.
+   */
+  public boolean isSnapshotValid(HlsUrl url) {
+    return playlistBundles.get(url).isSnapshotValid();
   }
 
   /**
@@ -299,7 +316,7 @@ private void createBundles(List<HlsUrl> urls) {
     for (int i = 0; i < listSize; i++) {
       HlsUrl url = urls.get(i);
       MediaPlaylistBundle bundle = new MediaPlaylistBundle(url, currentTimeMs);
-      playlistBundles.put(urls.get(i), bundle);
+      playlistBundles.put(url, bundle);
     }
   }
 
@@ -334,45 +351,71 @@ private void notifyPlaylistBlacklisting(HlsUrl url, long blacklistMs) {
     }
   }
 
-  /**
-   * TODO: Track discontinuities for media playlists that don't include the discontinuity number.
-   */
-  private HlsMediaPlaylist adjustPlaylistTimestamps(HlsMediaPlaylist oldPlaylist,
-      HlsMediaPlaylist newPlaylist) {
-    if (newPlaylist.hasProgramDateTime) {
-      if (newPlaylist.isNewerThan(oldPlaylist)) {
-        return newPlaylist;
+  private HlsMediaPlaylist getLatestPlaylistSnapshot(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    if (!loadedPlaylist.isNewerThan(oldPlaylist)) {
+      if (loadedPlaylist.hasEndTag) {
+        // If the loaded playlist has an end tag but is not newer than the old playlist then we have
+        // an inconsistent state. This is typically caused by the server incorrectly resetting the
+        // media sequence when appending the end tag. We resolve this case as best we can by
+        // returning the old playlist with the end tag appended.
+        return oldPlaylist.copyWithEndTag();
       } else {
         return oldPlaylist;
       }
     }
-    // TODO: Once playlist type support is added, the snapshot's age can be added by using the
-    // target duration.
+    long startTimeUs = getLoadedPlaylistStartTimeUs(oldPlaylist, loadedPlaylist);
+    int discontinuitySequence = getLoadedPlaylistDiscontinuitySequence(oldPlaylist, loadedPlaylist);
+    return loadedPlaylist.copyWith(startTimeUs, discontinuitySequence);
+  }
+
+  private long getLoadedPlaylistStartTimeUs(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    if (loadedPlaylist.hasProgramDateTime) {
+      return loadedPlaylist.startTimeUs;
+    }
     long primarySnapshotStartTimeUs = primaryUrlSnapshot != null
         ? primaryUrlSnapshot.startTimeUs : 0;
     if (oldPlaylist == null) {
-      if (newPlaylist.startTimeUs == primarySnapshotStartTimeUs) {
-        // Playback has just started or is VOD so no adjustment is needed.
-        return newPlaylist;
-      } else {
-        return newPlaylist.copyWithStartTimeUs(primarySnapshotStartTimeUs);
-      }
+      return primarySnapshotStartTimeUs;
     }
-    List<Segment> oldSegments = oldPlaylist.segments;
-    int oldPlaylistSize = oldSegments.size();
-    if (!newPlaylist.isNewerThan(oldPlaylist)) {
-      // Playlist has not changed.
-      return oldPlaylist;
+    int oldPlaylistSize = oldPlaylist.segments.size();
+    Segment firstOldOverlappingSegment = getFirstOldOverlappingSegment(oldPlaylist, loadedPlaylist);
+    if (firstOldOverlappingSegment != null) {
+      return oldPlaylist.startTimeUs + firstOldOverlappingSegment.relativeStartTimeUs;
+    } else if (oldPlaylistSize == loadedPlaylist.mediaSequence - oldPlaylist.mediaSequence) {
+      return oldPlaylist.getEndTimeUs();
+    } else {
+      // No segments overlap, we assume the new playlist start coincides with the primary playlist.
+      return primarySnapshotStartTimeUs;
+    }
+  }
+
+  private int getLoadedPlaylistDiscontinuitySequence(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    if (loadedPlaylist.hasDiscontinuitySequence) {
+      return loadedPlaylist.discontinuitySequence;
+    }
+    // TODO: Improve cross-playlist discontinuity adjustment.
+    int primaryUrlDiscontinuitySequence = primaryUrlSnapshot != null
+        ? primaryUrlSnapshot.discontinuitySequence : 0;
+    if (oldPlaylist == null) {
+      return primaryUrlDiscontinuitySequence;
     }
-    int mediaSequenceOffset = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
-    if (mediaSequenceOffset <= oldPlaylistSize) {
-      long adjustedNewPlaylistStartTimeUs = mediaSequenceOffset == oldPlaylistSize
-          ? oldPlaylist.getEndTimeUs()
-          : oldPlaylist.startTimeUs + oldSegments.get(mediaSequenceOffset).relativeStartTimeUs;
-      return newPlaylist.copyWithStartTimeUs(adjustedNewPlaylistStartTimeUs);
+    Segment firstOldOverlappingSegment = getFirstOldOverlappingSegment(oldPlaylist, loadedPlaylist);
+    if (firstOldOverlappingSegment != null) {
+      return oldPlaylist.discontinuitySequence
+          + firstOldOverlappingSegment.relativeDiscontinuitySequence
+          - loadedPlaylist.segments.get(0).relativeDiscontinuitySequence;
     }
-    // No segments overlap, we assume the new playlist start coincides with the primary playlist.
-    return newPlaylist.copyWithStartTimeUs(primarySnapshotStartTimeUs);
+    return primaryUrlDiscontinuitySequence;
+  }
+
+  private static Segment getFirstOldOverlappingSegment(HlsMediaPlaylist oldPlaylist,
+      HlsMediaPlaylist loadedPlaylist) {
+    int mediaSequenceOffset = loadedPlaylist.mediaSequence - oldPlaylist.mediaSequence;
+    List<Segment> oldSegments = oldPlaylist.segments;
+    return mediaSequenceOffset < oldSegments.size() ? oldSegments.get(mediaSequenceOffset) : null;
   }
 
   /**
@@ -386,14 +429,17 @@ private HlsMediaPlaylist adjustPlaylistTimestamps(HlsMediaPlaylist oldPlaylist,
     private final ParsingLoadable<HlsPlaylist> mediaPlaylistLoadable;
 
     private HlsMediaPlaylist playlistSnapshot;
+    private long lastSnapshotLoadMs;
     private long lastSnapshotAccessTimeMs;
     private long blacklistUntilMs;
+    private boolean pendingRefresh;
 
     public MediaPlaylistBundle(HlsUrl playlistUrl, long initialLastSnapshotAccessTimeMs) {
       this.playlistUrl = playlistUrl;
       lastSnapshotAccessTimeMs = initialLastSnapshotAccessTimeMs;
       mediaPlaylistLoader = new Loader("HlsPlaylistTracker:MediaPlaylist");
-      mediaPlaylistLoadable = new ParsingLoadable<>(dataSourceFactory.createDataSource(),
+      mediaPlaylistLoadable = new ParsingLoadable<>(
+          dataSourceFactory.createDataSource(C.DATA_TYPE_MANIFEST),
           UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url), C.DATA_TYPE_MANIFEST,
           playlistParser);
     }
@@ -403,13 +449,25 @@ public HlsMediaPlaylist getPlaylistSnapshot() {
       return playlistSnapshot;
     }
 
+    public boolean isSnapshotValid() {
+      if (playlistSnapshot == null) {
+        return false;
+      }
+      long currentTimeMs = SystemClock.elapsedRealtime();
+      long snapshotValidityDurationMs = Math.max(30000, C.usToMs(playlistSnapshot.durationUs));
+      return playlistSnapshot.hasEndTag
+          || playlistSnapshot.playlistType == HlsMediaPlaylist.PLAYLIST_TYPE_EVENT
+          || playlistSnapshot.playlistType == HlsMediaPlaylist.PLAYLIST_TYPE_VOD
+          || lastSnapshotLoadMs + snapshotValidityDurationMs > currentTimeMs;
+    }
+
     public void release() {
       mediaPlaylistLoader.release();
     }
 
     public void loadPlaylist() {
       blacklistUntilMs = 0;
-      if (!mediaPlaylistLoader.isLoading()) {
+      if (!pendingRefresh && !mediaPlaylistLoader.isLoading()) {
         mediaPlaylistLoader.startLoading(mediaPlaylistLoadable, this, minRetryCount);
       }
     }
@@ -455,25 +513,27 @@ public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealti
 
     @Override
     public void run() {
+      pendingRefresh = false;
       loadPlaylist();
     }
 
     // Internal methods.
 
-    private void processLoadedPlaylist(HlsMediaPlaylist loadedMediaPlaylist) {
+    private void processLoadedPlaylist(HlsMediaPlaylist loadedPlaylist) {
       HlsMediaPlaylist oldPlaylist = playlistSnapshot;
-      playlistSnapshot = adjustPlaylistTimestamps(oldPlaylist, loadedMediaPlaylist);
+      lastSnapshotLoadMs = SystemClock.elapsedRealtime();
+      playlistSnapshot = getLatestPlaylistSnapshot(oldPlaylist, loadedPlaylist);
       long refreshDelayUs = C.TIME_UNSET;
-      if (oldPlaylist != playlistSnapshot) {
+      if (playlistSnapshot != oldPlaylist) {
         if (onPlaylistUpdated(playlistUrl, playlistSnapshot)) {
           refreshDelayUs = playlistSnapshot.targetDurationUs;
         }
-      } else if (!loadedMediaPlaylist.hasEndTag) {
+      } else if (!playlistSnapshot.hasEndTag) {
         refreshDelayUs = playlistSnapshot.targetDurationUs / 2;
       }
       if (refreshDelayUs != C.TIME_UNSET) {
         // See HLS spec v20, section 6.3.4 for more information on media playlist refreshing.
-        playlistRefreshHandler.postDelayed(this, C.usToMs(refreshDelayUs));
+        pendingRefresh = playlistRefreshHandler.postDelayed(this, C.usToMs(refreshDelayUs));
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index aa197806e2..f2e4c57298 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -101,8 +101,8 @@ public DefaultSsChunkSource(LoaderErrorThrower manifestLoaderErrorThrower, SsMan
           trackEncryptionBoxes, nalUnitLengthFieldLength, null, null);
       FragmentedMp4Extractor extractor = new FragmentedMp4Extractor(
           FragmentedMp4Extractor.FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME
-          | FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_TFDT_BOX, track, null);
-      extractorWrappers[i] = new ChunkExtractorWrapper(extractor, format, false, false);
+          | FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_TFDT_BOX, null, track);
+      extractorWrappers[i] = new ChunkExtractorWrapper(extractor, format);
     }
   }
 
@@ -219,7 +219,7 @@ private static MediaChunk newMediaChunk(Format format, DataSource dataSource, Ur
     long sampleOffsetUs = chunkStartTimeUs;
     return new ContainerMediaChunk(dataSource, dataSpec, format, trackSelectionReason,
         trackSelectionData, chunkStartTimeUs, chunkEndTimeUs, chunkIndex, 1, sampleOffsetUs,
-        extractorWrapper, format);
+        extractorWrapper);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
index fef2480fd6..43cd4a9f8d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
@@ -136,6 +136,11 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     return positionUs;
   }
 
+  @Override
+  public void discardBuffer(long positionUs) {
+    // Do nothing.
+  }
+
   @Override
   public boolean continueLoading(long positionUs) {
     return sequenceableLoader.continueLoading(positionUs);
@@ -185,8 +190,8 @@ public void onContinueLoadingRequested(ChunkSampleStream<SsChunkSource> sampleSt
     int streamElementIndex = trackGroups.indexOf(selection.getTrackGroup());
     SsChunkSource chunkSource = chunkSourceFactory.createChunkSource(manifestLoaderErrorThrower,
         manifest, streamElementIndex, selection, trackEncryptionBoxes);
-    return new ChunkSampleStream<>(manifest.streamElements[streamElementIndex].type, chunkSource,
-        this, allocator, positionUs, minLoadableRetryCount, eventDispatcher);
+    return new ChunkSampleStream<>(manifest.streamElements[streamElementIndex].type, null,
+        chunkSource, this, allocator, positionUs, minLoadableRetryCount, eventDispatcher);
   }
 
   private static TrackGroupArray buildTrackGroups(SsManifest manifest) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
index 844ffc45e6..1bb877eb59 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
@@ -128,8 +128,10 @@ public ProtectionElement(UUID uuid, byte[] data) {
    */
   public static class StreamElement {
 
-    private static final String URL_PLACEHOLDER_START_TIME = "{start time}";
-    private static final String URL_PLACEHOLDER_BITRATE = "{bitrate}";
+    private static final String URL_PLACEHOLDER_START_TIME_1 = "{start time}";
+    private static final String URL_PLACEHOLDER_START_TIME_2 = "{start_time}";
+    private static final String URL_PLACEHOLDER_BITRATE_1 = "{bitrate}";
+    private static final String URL_PLACEHOLDER_BITRATE_2 = "{Bitrate}";
 
     public final int type;
     public final String subType;
@@ -216,9 +218,13 @@ public Uri buildRequestUri(int track, int chunkIndex) {
       Assertions.checkState(formats != null);
       Assertions.checkState(chunkStartTimes != null);
       Assertions.checkState(chunkIndex < chunkStartTimes.size());
+      String bitrateString = Integer.toString(formats[track].bitrate);
+      String startTimeString = chunkStartTimes.get(chunkIndex).toString();
       String chunkUrl = chunkTemplate
-          .replace(URL_PLACEHOLDER_BITRATE, Integer.toString(formats[track].bitrate))
-          .replace(URL_PLACEHOLDER_START_TIME, chunkStartTimes.get(chunkIndex).toString());
+          .replace(URL_PLACEHOLDER_BITRATE_1, bitrateString)
+          .replace(URL_PLACEHOLDER_BITRATE_2, bitrateString)
+          .replace(URL_PLACEHOLDER_START_TIME_1, startTimeString)
+          .replace(URL_PLACEHOLDER_START_TIME_2, startTimeString);
       return UriUtil.resolveToUri(baseUri, chunkUrl);
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
index b17a424ee6..3ca5f8d997 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParser.java
@@ -625,7 +625,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
         List<byte[]> codecSpecificData = buildCodecSpecificData(
             parser.getAttributeValue(null, KEY_CODEC_PRIVATE_DATA));
         format = Format.createVideoContainerFormat(id, MimeTypes.VIDEO_MP4, sampleMimeType, null,
-            bitrate, width, height, Format.NO_VALUE, codecSpecificData);
+            bitrate, width, height, Format.NO_VALUE, codecSpecificData, 0);
       } else if (type == C.TRACK_TYPE_AUDIO) {
         sampleMimeType = sampleMimeType == null ? MimeTypes.AUDIO_AAC : sampleMimeType;
         int channels = parseRequiredInt(parser, KEY_CHANNELS);
@@ -644,8 +644,8 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
         format = Format.createTextContainerFormat(id, MimeTypes.APPLICATION_MP4, sampleMimeType,
             null, bitrate, 0, language);
       } else {
-        format = Format.createContainerFormat(id, MimeTypes.APPLICATION_MP4, null, sampleMimeType,
-            bitrate);
+        format = Format.createContainerFormat(id, MimeTypes.APPLICATION_MP4, sampleMimeType, null,
+            bitrate, 0, null);
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java b/library/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
index b7a75ed679..51f5ad0a64 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/CaptionStyleCompat.java
@@ -94,8 +94,7 @@
    * <li>{@link #EDGE_TYPE_DEPRESSED}
    * </ul>
    */
-  @EdgeType
-  public final int edgeType;
+  @EdgeType public final int edgeType;
 
   /**
    * The preferred edge color, if using an edge type other than {@link #EDGE_TYPE_NONE}.
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
index 1c29f10c84..176b8ea815 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/Cue.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.text;
 
+import android.graphics.Bitmap;
+import android.graphics.Color;
 import android.support.annotation.IntDef;
 import android.text.Layout.Alignment;
 import java.lang.annotation.Retention;
@@ -36,19 +38,23 @@
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, ANCHOR_TYPE_START, ANCHOR_TYPE_MIDDLE, ANCHOR_TYPE_END})
   public @interface AnchorType {}
+
   /**
    * An unset anchor or line type value.
    */
   public static final int TYPE_UNSET = Integer.MIN_VALUE;
+
   /**
    * Anchors the left (for horizontal positions) or top (for vertical positions) edge of the cue
    * box.
    */
   public static final int ANCHOR_TYPE_START = 0;
+
   /**
    * Anchors the middle of the cue box.
    */
   public static final int ANCHOR_TYPE_MIDDLE = 1;
+
   /**
    * Anchors the right (for horizontal positions) or bottom (for vertical positions) edge of the cue
    * box.
@@ -61,23 +67,33 @@
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({TYPE_UNSET, LINE_TYPE_FRACTION, LINE_TYPE_NUMBER})
   public @interface LineType {}
+
   /**
    * Value for {@link #lineType} when {@link #line} is a fractional position.
    */
   public static final int LINE_TYPE_FRACTION = 0;
+
   /**
    * Value for {@link #lineType} when {@link #line} is a line number.
    */
   public static final int LINE_TYPE_NUMBER = 1;
 
   /**
-   * The cue text. Note the {@link CharSequence} may be decorated with styling spans.
+   * The cue text, or null if this is an image cue. Note the {@link CharSequence} may be decorated
+   * with styling spans.
    */
   public final CharSequence text;
+
   /**
    * The alignment of the cue text within the cue box, or null if the alignment is undefined.
    */
   public final Alignment textAlignment;
+
+  /**
+   * The cue image, or null if this is a text cue.
+   */
+  public final Bitmap bitmap;
+
   /**
    * The position of the {@link #lineAnchor} of the cue box within the viewport in the direction
    * orthogonal to the writing direction, or {@link #DIMEN_UNSET}. When set, the interpretation of
@@ -87,6 +103,7 @@
    * fractional vertical position relative to the top of the viewport.
    */
   public final float line;
+
   /**
    * The type of the {@link #line} value.
    * <p>
@@ -112,8 +129,8 @@
    * {@code (line == -2 && lineAnchor == ANCHOR_TYPE_START)} position a cue so that only its first
    * line is visible at the bottom of the viewport.
    */
-  @LineType
-  public final int lineType;
+  @LineType public final int lineType;
+
   /**
    * The cue box anchor positioned by {@link #line}. One of {@link #ANCHOR_TYPE_START},
    * {@link #ANCHOR_TYPE_MIDDLE}, {@link #ANCHOR_TYPE_END} and {@link #TYPE_UNSET}.
@@ -122,8 +139,8 @@
    * and {@link #ANCHOR_TYPE_END} correspond to the top, middle and bottom of the cue box
    * respectively.
    */
-  @AnchorType
-  public final int lineAnchor;
+  @AnchorType public final int lineAnchor;
+
   /**
    * The fractional position of the {@link #positionAnchor} of the cue box within the viewport in
    * the direction orthogonal to {@link #line}, or {@link #DIMEN_UNSET}.
@@ -133,6 +150,7 @@
    * text.
    */
   public final float position;
+
   /**
    * The cue box anchor positioned by {@link #position}. One of {@link #ANCHOR_TYPE_START},
    * {@link #ANCHOR_TYPE_MIDDLE}, {@link #ANCHOR_TYPE_END} and {@link #TYPE_UNSET}.
@@ -141,8 +159,8 @@
    * and {@link #ANCHOR_TYPE_END} correspond to the left, middle and right of the cue box
    * respectively.
    */
-  @AnchorType
-  public final int positionAnchor;
+  @AnchorType public final int positionAnchor;
+
   /**
    * The size of the cue box in the writing direction specified as a fraction of the viewport size
    * in that direction, or {@link #DIMEN_UNSET}.
@@ -150,7 +168,37 @@
   public final float size;
 
   /**
-   * Constructs a cue whose {@link #textAlignment} is null, whose type parameters are set to
+   * Specifies whether or not the {@link #windowColor} property is set.
+   */
+  public final boolean windowColorSet;
+
+  /**
+   * The fill color of the window.
+   */
+  public final int windowColor;
+
+  /**
+   * Creates an image cue.
+   *
+   * @param bitmap See {@link #bitmap}.
+   * @param horizontalPosition The position of the horizontal anchor within the viewport, expressed
+   *     as a fraction of the viewport width.
+   * @param horizontalPositionAnchor The horizontal anchor. One of {@link #ANCHOR_TYPE_START},
+   *     {@link #ANCHOR_TYPE_MIDDLE}, {@link #ANCHOR_TYPE_END} and {@link #TYPE_UNSET}.
+   * @param verticalPosition The position of the vertical anchor within the viewport, expressed as a
+   *     fraction of the viewport height.
+   * @param verticalPositionAnchor The vertical anchor. One of {@link #ANCHOR_TYPE_START},
+   *     {@link #ANCHOR_TYPE_MIDDLE}, {@link #ANCHOR_TYPE_END} and {@link #TYPE_UNSET}.
+   * @param width The width of the cue, expressed as a fraction of the viewport width.
+   */
+  public Cue(Bitmap bitmap, float horizontalPosition, @AnchorType int horizontalPositionAnchor,
+      float verticalPosition, @AnchorType int verticalPositionAnchor, float width) {
+    this(null, null, bitmap, verticalPosition, LINE_TYPE_FRACTION, verticalPositionAnchor,
+        horizontalPosition, horizontalPositionAnchor, width, false, Color.BLACK);
+  }
+
+  /**
+   * Creates a text cue whose {@link #textAlignment} is null, whose type parameters are set to
    * {@link #TYPE_UNSET} and whose dimension parameters are set to {@link #DIMEN_UNSET}.
    *
    * @param text See {@link #text}.
@@ -160,6 +208,8 @@ public Cue(CharSequence text) {
   }
 
   /**
+   * Creates a text cue.
+   *
    * @param text See {@link #text}.
    * @param textAlignment See {@link #textAlignment}.
    * @param line See {@link #line}.
@@ -171,14 +221,45 @@ public Cue(CharSequence text) {
    */
   public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
       @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size) {
+    this(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, size, false,
+        Color.BLACK);
+  }
+
+  /**
+   * Creates a text cue.
+   *
+   * @param text See {@link #text}.
+   * @param textAlignment See {@link #textAlignment}.
+   * @param line See {@link #line}.
+   * @param lineType See {@link #lineType}.
+   * @param lineAnchor See {@link #lineAnchor}.
+   * @param position See {@link #position}.
+   * @param positionAnchor See {@link #positionAnchor}.
+   * @param size See {@link #size}.
+   * @param windowColorSet See {@link #windowColorSet}.
+   * @param windowColor See {@link #windowColor}.
+   */
+  public Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+      @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size,
+      boolean windowColorSet, int windowColor) {
+    this(text, textAlignment, null, line, lineType, lineAnchor, position, positionAnchor, size,
+        windowColorSet, windowColor);
+  }
+
+  private Cue(CharSequence text, Alignment textAlignment, Bitmap bitmap, float line,
+      @LineType int lineType, @AnchorType int lineAnchor, float position,
+      @AnchorType int positionAnchor, float size, boolean windowColorSet, int windowColor) {
     this.text = text;
     this.textAlignment = textAlignment;
+    this.bitmap = bitmap;
     this.line = line;
     this.lineType = lineType;
     this.lineAnchor = lineAnchor;
     this.position = position;
     this.positionAnchor = positionAnchor;
     this.size = size;
+    this.windowColorSet = windowColorSet;
+    this.windowColor = windowColor;
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java b/library/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
index ae3bd309ff..dd25ef8345 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import java.nio.ByteBuffer;
 
@@ -68,6 +69,8 @@ protected final SubtitleDecoderException decode(SubtitleInputBuffer inputBuffer,
       ByteBuffer inputData = inputBuffer.data;
       Subtitle subtitle = decode(inputData.array(), inputData.limit());
       outputBuffer.setContent(inputBuffer.timeUs, subtitle, inputBuffer.subsampleOffsetUs);
+      // Clear BUFFER_FLAG_DECODE_ONLY (see [Internal: b/27893809]).
+      outputBuffer.clearFlag(C.BUFFER_FLAG_DECODE_ONLY);
       return null;
     } catch (SubtitleDecoderException e) {
       return e;
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
index a5d1c0a9c0..077fc8848b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.cea.Cea608Decoder;
+import com.google.android.exoplayer2.text.cea.Cea708Decoder;
 import com.google.android.exoplayer2.text.subrip.SubripDecoder;
 import com.google.android.exoplayer2.text.ttml.TtmlDecoder;
 import com.google.android.exoplayer2.text.tx3g.Tx3gDecoder;
@@ -58,6 +59,7 @@
    * <li>SubRip ({@link SubripDecoder})</li>
    * <li>TX3G ({@link Tx3gDecoder})</li>
    * <li>Cea608 ({@link Cea608Decoder})</li>
+   * <li>Cea708 ({@link Cea708Decoder})</li>
    * </ul>
    */
   SubtitleDecoderFactory DEFAULT = new SubtitleDecoderFactory() {
@@ -74,9 +76,13 @@ public SubtitleDecoder createDecoder(Format format) {
         if (clazz == null) {
           throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
         }
-        if (clazz == Cea608Decoder.class) {
+        if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA608)
+            || format.sampleMimeType.equals(MimeTypes.APPLICATION_MP4CEA608)) {
           return clazz.asSubclass(SubtitleDecoder.class).getConstructor(String.class, Integer.TYPE)
               .newInstance(format.sampleMimeType, format.accessibilityChannel);
+        } else if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA708)) {
+          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(Integer.TYPE)
+              .newInstance(format.accessibilityChannel);
         } else {
           return clazz.asSubclass(SubtitleDecoder.class).getConstructor().newInstance();
         }
@@ -104,6 +110,8 @@ public SubtitleDecoder createDecoder(Format format) {
           case MimeTypes.APPLICATION_CEA608:
           case MimeTypes.APPLICATION_MP4CEA608:
             return Class.forName("com.google.android.exoplayer2.text.cea.Cea608Decoder");
+          case MimeTypes.APPLICATION_CEA708:
+            return Class.forName("com.google.android.exoplayer2.text.cea.Cea708Decoder");
           default:
             return null;
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java b/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
index 8dbde1be5e..a7e05a010a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/TextRenderer.java
@@ -189,10 +189,8 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
           }
         }
         // Try and read the next subtitle from the source.
-        int result = readSource(formatHolder, nextInputBuffer);
+        int result = readSource(formatHolder, nextInputBuffer, false);
         if (result == C.RESULT_BUFFER_READ) {
-          // Clear BUFFER_FLAG_DECODE_ONLY (see [Internal: b/27893809]) and queue the buffer.
-          nextInputBuffer.clearFlag(C.BUFFER_FLAG_DECODE_ONLY);
           if (nextInputBuffer.isEndOfStream()) {
             inputStreamEnded = true;
           } else {
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index 3ae8ded9ba..fe9a5fbc5c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -49,12 +49,6 @@
   private static final int NTSC_CC_FIELD_2 = 0x01;
   private static final int CC_VALID_608_ID = 0x04;
 
-  private static final int PAYLOAD_TYPE_CC = 4;
-  private static final int COUNTRY_CODE = 0xB5;
-  private static final int PROVIDER_CODE = 0x31;
-  private static final int USER_ID = 0x47413934; // "GA94"
-  private static final int USER_DATA_TYPE_CODE = 0x3;
-
   private static final int CC_MODE_UNKNOWN = 0;
   private static final int CC_MODE_ROLL_UP = 1;
   private static final int CC_MODE_POP_ON = 2;
@@ -370,7 +364,7 @@ private boolean handleCtrl(byte cc1, byte cc2) {
     } else if (isPreambleAddressCode(cc1, cc2)) {
       handlePreambleAddressCode(cc1, cc2);
     } else if (isTabCtrlCode(cc1, cc2)) {
-      currentCueBuilder.tab(cc2 - 0x20);
+      currentCueBuilder.setTab(cc2 - 0x20);
     } else if (isMiscCode(cc1, cc2)) {
       handleMiscCode(cc2);
     }
@@ -509,11 +503,14 @@ private void setCaptionMode(int captionMode) {
       return;
     }
 
+    int oldCaptionMode = this.captionMode;
     this.captionMode = captionMode;
+
     // Clear the working memory.
     resetCueBuilders();
-    if (captionMode == CC_MODE_ROLL_UP || captionMode == CC_MODE_UNKNOWN) {
-      // When switching to roll-up or unknown, we also need to clear the caption.
+    if (oldCaptionMode == CC_MODE_PAINT_ON || captionMode == CC_MODE_ROLL_UP
+        || captionMode == CC_MODE_UNKNOWN) {
+      // When switching from paint-on or to roll-up or unknown, we also need to clear the caption.
       cues = null;
     }
   }
@@ -573,31 +570,6 @@ private static boolean isRepeatable(byte cc1) {
     return (cc1 & 0xF0) == 0x10;
   }
 
-  /**
-   * Inspects an sei message to determine whether it contains CEA-608.
-   * <p>
-   * The position of {@code payload} is left unchanged.
-   *
-   * @param payloadType The payload type of the message.
-   * @param payloadLength The length of the payload.
-   * @param payload A {@link ParsableByteArray} containing the payload.
-   * @return Whether the sei message contains CEA-608.
-   */
-  public static boolean isSeiMessageCea608(int payloadType, int payloadLength,
-      ParsableByteArray payload) {
-    if (payloadType != PAYLOAD_TYPE_CC || payloadLength < 8) {
-      return false;
-    }
-    int startPosition = payload.getPosition();
-    int countryCode = payload.readUnsignedByte();
-    int providerCode = payload.readUnsignedShort();
-    int userIdentifier = payload.readInt();
-    int userDataTypeCode = payload.readUnsignedByte();
-    payload.setPosition(startPosition);
-    return countryCode == COUNTRY_CODE && providerCode == PROVIDER_CODE
-        && userIdentifier == USER_ID && userDataTypeCode == USER_DATA_TYPE_CODE;
-  }
-
   private static class CueBuilder {
 
     private static final int POSITION_UNSET = -1;
@@ -677,8 +649,8 @@ public void setIndent(int indent) {
       this.indent = indent;
     }
 
-    public void tab(int tabs) {
-      tabOffset += tabs;
+    public void setTab(int tabs) {
+      tabOffset = tabs;
     }
 
     public void setPreambleStyle(CharacterStyle style) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
new file mode 100644
index 0000000000..e63d1d4118
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Cue.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import android.text.Layout.Alignment;
+import com.google.android.exoplayer2.text.Cue;
+
+/**
+ * A {@link Cue} for CEA-708.
+ */
+/* package */ final class Cea708Cue extends Cue implements Comparable<Cea708Cue> {
+
+  /**
+   * An unset priority.
+   */
+  public static final int PRIORITY_UNSET = -1;
+
+  /**
+   * The priority of the cue box.
+   */
+  public final int priority;
+
+  /**
+   * @param text See {@link #text}.
+   * @param textAlignment See {@link #textAlignment}.
+   * @param line See {@link #line}.
+   * @param lineType See {@link #lineType}.
+   * @param lineAnchor See {@link #lineAnchor}.
+   * @param position See {@link #position}.
+   * @param positionAnchor See {@link #positionAnchor}.
+   * @param size See {@link #size}.
+   * @param windowColorSet See {@link #windowColorSet}.
+   * @param windowColor See {@link #windowColor}.
+   * @param priority See (@link #priority}.
+   */
+  public Cea708Cue(CharSequence text, Alignment textAlignment, float line, @LineType int lineType,
+      @AnchorType int lineAnchor, float position, @AnchorType int positionAnchor, float size,
+      boolean windowColorSet, int windowColor, int priority) {
+    super(text, textAlignment, line, lineType, lineAnchor, position, positionAnchor, size,
+        windowColorSet, windowColor);
+    this.priority = priority;
+  }
+
+  @Override
+  public int compareTo(Cea708Cue other) {
+    if (other.priority < priority) {
+      return -1;
+    } else if (other.priority > priority) {
+      return 1;
+    }
+    return 0;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
new file mode 100644
index 0000000000..8fd70f7a67
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
@@ -0,0 +1,1248 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import android.graphics.Color;
+import android.graphics.Typeface;
+import android.text.Layout.Alignment;
+import android.text.SpannableString;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.style.BackgroundColorSpan;
+import android.text.style.ForegroundColorSpan;
+import android.text.style.StyleSpan;
+import android.text.style.UnderlineSpan;
+import android.util.Log;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.Cue.AnchorType;
+import com.google.android.exoplayer2.text.Subtitle;
+import com.google.android.exoplayer2.text.SubtitleDecoder;
+import com.google.android.exoplayer2.text.SubtitleInputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.ParsableBitArray;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * A {@link SubtitleDecoder} for CEA-708 (also known as "EIA-708").
+ */
+public final class Cea708Decoder extends CeaDecoder {
+
+  private static final String TAG = "Cea708Decoder";
+
+  private static final int NUM_WINDOWS = 8;
+
+  private static final int DTVCC_PACKET_DATA = 0x02;
+  private static final int DTVCC_PACKET_START = 0x03;
+  private static final int CC_VALID_FLAG = 0x04;
+
+  // Base Commands
+  private static final int GROUP_C0_END = 0x1F;  // Miscellaneous Control Codes
+  private static final int GROUP_G0_END = 0x7F;  // ASCII Printable Characters
+  private static final int GROUP_C1_END = 0x9F;  // Captioning Command Control Codes
+  private static final int GROUP_G1_END = 0xFF;  // ISO 8859-1 LATIN-1 Character Set
+
+  // Extended Commands
+  private static final int GROUP_C2_END = 0x1F;  // Extended Control Code Set 1
+  private static final int GROUP_G2_END = 0x7F;  // Extended Miscellaneous Characters
+  private static final int GROUP_C3_END = 0x9F;  // Extended Control Code Set 2
+  private static final int GROUP_G3_END = 0xFF;  // Future Expansion
+
+  // Group C0 Commands
+  private static final int COMMAND_NUL = 0x00;        // Nul
+  private static final int COMMAND_ETX = 0x03;        // EndOfText
+  private static final int COMMAND_BS = 0x08;         // Backspace
+  private static final int COMMAND_FF = 0x0C;         // FormFeed (Flush)
+  private static final int COMMAND_CR = 0x0D;         // CarriageReturn
+  private static final int COMMAND_HCR = 0x0E;        // ClearLine
+  private static final int COMMAND_EXT1 = 0x10;       // Extended Control Code Flag
+  private static final int COMMAND_EXT1_START = 0x11;
+  private static final int COMMAND_EXT1_END = 0x17;
+  private static final int COMMAND_P16_START = 0x18;
+  private static final int COMMAND_P16_END = 0x1F;
+
+  // Group C1 Commands
+  private static final int COMMAND_CW0 = 0x80;  // SetCurrentWindow to 0
+  private static final int COMMAND_CW1 = 0x81;  // SetCurrentWindow to 1
+  private static final int COMMAND_CW2 = 0x82;  // SetCurrentWindow to 2
+  private static final int COMMAND_CW3 = 0x83;  // SetCurrentWindow to 3
+  private static final int COMMAND_CW4 = 0x84;  // SetCurrentWindow to 4
+  private static final int COMMAND_CW5 = 0x85;  // SetCurrentWindow to 5
+  private static final int COMMAND_CW6 = 0x86;  // SetCurrentWindow to 6
+  private static final int COMMAND_CW7 = 0x87;  // SetCurrentWindow to 7
+  private static final int COMMAND_CLW = 0x88;  // ClearWindows (+1 byte)
+  private static final int COMMAND_DSW = 0x89;  // DisplayWindows (+1 byte)
+  private static final int COMMAND_HDW = 0x8A;  // HideWindows (+1 byte)
+  private static final int COMMAND_TGW = 0x8B;  // ToggleWindows (+1 byte)
+  private static final int COMMAND_DLW = 0x8C;  // DeleteWindows (+1 byte)
+  private static final int COMMAND_DLY = 0x8D;  // Delay (+1 byte)
+  private static final int COMMAND_DLC = 0x8E;  // DelayCancel
+  private static final int COMMAND_RST = 0x8F;  // Reset
+  private static final int COMMAND_SPA = 0x90;  // SetPenAttributes (+2 bytes)
+  private static final int COMMAND_SPC = 0x91;  // SetPenColor (+3 bytes)
+  private static final int COMMAND_SPL = 0x92;  // SetPenLocation (+2 bytes)
+  private static final int COMMAND_SWA = 0x97;  // SetWindowAttributes (+4 bytes)
+  private static final int COMMAND_DF0 = 0x98;  // DefineWindow 0 (+6 bytes)
+  private static final int COMMAND_DF1 = 0x99;  // DefineWindow 1 (+6 bytes)
+  private static final int COMMAND_DF2 = 0x9A;  // DefineWindow 2 (+6 bytes)
+  private static final int COMMAND_DF3 = 0x9B;  // DefineWindow 3 (+6 bytes)
+  private static final int COMMAND_DS4 = 0x9C;  // DefineWindow 4 (+6 bytes)
+  private static final int COMMAND_DF5 = 0x9D;  // DefineWindow 5 (+6 bytes)
+  private static final int COMMAND_DF6 = 0x9E;  // DefineWindow 6 (+6 bytes)
+  private static final int COMMAND_DF7 = 0x9F;  // DefineWindow 7 (+6 bytes)
+
+  // G0 Table Special Chars
+  private static final int CHARACTER_MN = 0x7F;  // MusicNote
+
+  // G2 Table Special Chars
+  private static final int CHARACTER_TSP = 0x20;
+  private static final int CHARACTER_NBTSP = 0x21;
+  private static final int CHARACTER_ELLIPSIS = 0x25;
+  private static final int CHARACTER_BIG_CARONS = 0x2A;
+  private static final int CHARACTER_BIG_OE = 0x2C;
+  private static final int CHARACTER_SOLID_BLOCK = 0x30;
+  private static final int CHARACTER_OPEN_SINGLE_QUOTE = 0x31;
+  private static final int CHARACTER_CLOSE_SINGLE_QUOTE = 0x32;
+  private static final int CHARACTER_OPEN_DOUBLE_QUOTE = 0x33;
+  private static final int CHARACTER_CLOSE_DOUBLE_QUOTE = 0x34;
+  private static final int CHARACTER_BOLD_BULLET = 0x35;
+  private static final int CHARACTER_TM = 0x39;
+  private static final int CHARACTER_SMALL_CARONS = 0x3A;
+  private static final int CHARACTER_SMALL_OE = 0x3C;
+  private static final int CHARACTER_SM = 0x3D;
+  private static final int CHARACTER_DIAERESIS_Y = 0x3F;
+  private static final int CHARACTER_ONE_EIGHTH = 0x76;
+  private static final int CHARACTER_THREE_EIGHTHS = 0x77;
+  private static final int CHARACTER_FIVE_EIGHTHS = 0x78;
+  private static final int CHARACTER_SEVEN_EIGHTHS = 0x79;
+  private static final int CHARACTER_VERTICAL_BORDER = 0x7A;
+  private static final int CHARACTER_UPPER_RIGHT_BORDER = 0x7B;
+  private static final int CHARACTER_LOWER_LEFT_BORDER = 0x7C;
+  private static final int CHARACTER_HORIZONTAL_BORDER = 0x7D;
+  private static final int CHARACTER_LOWER_RIGHT_BORDER = 0x7E;
+  private static final int CHARACTER_UPPER_LEFT_BORDER = 0x7F;
+
+  private final ParsableByteArray ccData;
+  private final ParsableBitArray serviceBlockPacket;
+
+  private final int selectedServiceNumber;
+  private final CueBuilder[] cueBuilders;
+
+  private CueBuilder currentCueBuilder;
+  private List<Cue> cues;
+  private List<Cue> lastCues;
+
+  private DtvCcPacket currentDtvCcPacket;
+  private int currentWindow;
+
+  public Cea708Decoder(int accessibilityChannel) {
+    ccData = new ParsableByteArray();
+    serviceBlockPacket = new ParsableBitArray();
+    selectedServiceNumber = (accessibilityChannel == Format.NO_VALUE) ? 1 : accessibilityChannel;
+
+    cueBuilders = new CueBuilder[NUM_WINDOWS];
+    for (int i = 0; i < NUM_WINDOWS; i++) {
+      cueBuilders[i] = new CueBuilder();
+    }
+
+    currentCueBuilder = cueBuilders[0];
+    resetCueBuilders();
+  }
+
+  @Override
+  public String getName() {
+    return "Cea708Decoder";
+  }
+
+  @Override
+  public void flush() {
+    super.flush();
+    cues = null;
+    lastCues = null;
+    currentWindow = 0;
+    currentCueBuilder = cueBuilders[currentWindow];
+    resetCueBuilders();
+    currentDtvCcPacket = null;
+  }
+
+  @Override
+  protected boolean isNewSubtitleDataAvailable() {
+    return cues != lastCues;
+  }
+
+  @Override
+  protected Subtitle createSubtitle() {
+    lastCues = cues;
+    return new CeaSubtitle(cues);
+  }
+
+  @Override
+  protected void decode(SubtitleInputBuffer inputBuffer) {
+    ccData.reset(inputBuffer.data.array(), inputBuffer.data.limit());
+    while (ccData.bytesLeft() >= 3) {
+      int ccTypeAndValid = (ccData.readUnsignedByte() & 0x07);
+
+      int ccType = ccTypeAndValid & (DTVCC_PACKET_DATA | DTVCC_PACKET_START);
+      boolean ccValid = (ccTypeAndValid & CC_VALID_FLAG) == CC_VALID_FLAG;
+      byte ccData1 = (byte) ccData.readUnsignedByte();
+      byte ccData2 = (byte) ccData.readUnsignedByte();
+
+      // Ignore any non-CEA-708 data
+      if (ccType != DTVCC_PACKET_DATA && ccType != DTVCC_PACKET_START) {
+        continue;
+      }
+
+      if (!ccValid) {
+        // This byte-pair isn't valid, ignore it and continue.
+        continue;
+      }
+
+      if (ccType == DTVCC_PACKET_START) {
+        finalizeCurrentPacket();
+
+        int sequenceNumber = (ccData1 & 0xC0) >> 6; // first 2 bits
+        int packetSize = ccData1 & 0x3F; // last 6 bits
+        if (packetSize == 0) {
+          packetSize = 64;
+        }
+
+        currentDtvCcPacket = new DtvCcPacket(sequenceNumber, packetSize);
+        currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++] = ccData2;
+      } else {
+        // The only remaining valid packet type is DTVCC_PACKET_DATA
+        Assertions.checkArgument(ccType == DTVCC_PACKET_DATA);
+
+        if (currentDtvCcPacket == null) {
+          Log.e(TAG, "Encountered DTVCC_PACKET_DATA before DTVCC_PACKET_START");
+          continue;
+        }
+
+        currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++] = ccData1;
+        currentDtvCcPacket.packetData[currentDtvCcPacket.currentIndex++] = ccData2;
+      }
+
+      if (currentDtvCcPacket.currentIndex == (currentDtvCcPacket.packetSize * 2 - 1)) {
+        finalizeCurrentPacket();
+      }
+    }
+  }
+
+  private void finalizeCurrentPacket() {
+    if (currentDtvCcPacket == null) {
+      // No packet to finalize;
+      return;
+    }
+
+    processCurrentPacket();
+    currentDtvCcPacket = null;
+  }
+
+  private void processCurrentPacket() {
+    if (currentDtvCcPacket.currentIndex != (currentDtvCcPacket.packetSize * 2 - 1)) {
+      Log.w(TAG, "DtvCcPacket ended prematurely; size is " + (currentDtvCcPacket.packetSize * 2 - 1)
+          + ", but current index is " + currentDtvCcPacket.currentIndex + " (sequence number "
+          + currentDtvCcPacket.sequenceNumber + "); ignoring packet");
+      return;
+    }
+
+    serviceBlockPacket.reset(currentDtvCcPacket.packetData, currentDtvCcPacket.currentIndex);
+
+    int serviceNumber = serviceBlockPacket.readBits(3);
+    int blockSize = serviceBlockPacket.readBits(5);
+    if (serviceNumber == 7) {
+      // extended service numbers
+      serviceBlockPacket.skipBits(2);
+      serviceNumber += serviceBlockPacket.readBits(6);
+    }
+
+    // Ignore packets in which blockSize is 0
+    if (blockSize == 0) {
+      if (serviceNumber != 0) {
+        Log.w(TAG, "serviceNumber is non-zero (" + serviceNumber + ") when blockSize is 0");
+      }
+      return;
+    }
+
+    if (serviceNumber != selectedServiceNumber) {
+      return;
+    }
+
+    // The cues should be updated if we receive a C0 ETX command, any C1 command, or if after
+    // processing the service block any text has been added to the buffer. See CEA-708-B Section
+    // 8.10.4 for more details.
+    boolean cuesNeedUpdate = false;
+
+    while (serviceBlockPacket.bitsLeft() > 0) {
+      int command = serviceBlockPacket.readBits(8);
+      if (command != COMMAND_EXT1) {
+        if (command <= GROUP_C0_END) {
+          handleC0Command(command);
+          // If the C0 command was an ETX command, the cues are updated in handleC0Command.
+        } else if (command <= GROUP_G0_END) {
+          handleG0Character(command);
+          cuesNeedUpdate = true;
+        } else if (command <= GROUP_C1_END) {
+          handleC1Command(command);
+          cuesNeedUpdate = true;
+        } else if (command <= GROUP_G1_END) {
+          handleG1Character(command);
+          cuesNeedUpdate = true;
+        } else {
+          Log.w(TAG, "Invalid base command: " + command);
+        }
+      } else {
+        // Read the extended command
+        command = serviceBlockPacket.readBits(8);
+        if (command <= GROUP_C2_END) {
+          handleC2Command(command);
+        } else if (command <= GROUP_G2_END) {
+          handleG2Character(command);
+          cuesNeedUpdate = true;
+        } else if (command <= GROUP_C3_END) {
+          handleC3Command(command);
+        } else if (command <= GROUP_G3_END) {
+          handleG3Character(command);
+          cuesNeedUpdate = true;
+        } else {
+          Log.w(TAG, "Invalid extended command: " + command);
+        }
+      }
+    }
+
+    if (cuesNeedUpdate) {
+      cues = getDisplayCues();
+    }
+  }
+
+  private void handleC0Command(int command) {
+    switch (command) {
+      case COMMAND_NUL:
+        // Do nothing.
+        break;
+      case COMMAND_ETX:
+        cues = getDisplayCues();
+        break;
+      case COMMAND_BS:
+        currentCueBuilder.backspace();
+        break;
+      case COMMAND_FF:
+        resetCueBuilders();
+        break;
+      case COMMAND_CR:
+        currentCueBuilder.append('\n');
+        break;
+      case COMMAND_HCR:
+        // TODO: Add support for this command.
+        break;
+      default:
+        if (command >= COMMAND_EXT1_START && command <= COMMAND_EXT1_END) {
+          Log.w(TAG, "Currently unsupported COMMAND_EXT1 Command: " + command);
+          serviceBlockPacket.skipBits(8);
+        } else if (command >= COMMAND_P16_START && command <= COMMAND_P16_END) {
+          Log.w(TAG, "Currently unsupported COMMAND_P16 Command: " + command);
+          serviceBlockPacket.skipBits(16);
+        } else {
+          Log.w(TAG, "Invalid C0 command: " + command);
+        }
+    }
+  }
+
+  private void handleC1Command(int command) {
+    int window;
+    switch (command) {
+      case COMMAND_CW0:
+      case COMMAND_CW1:
+      case COMMAND_CW2:
+      case COMMAND_CW3:
+      case COMMAND_CW4:
+      case COMMAND_CW5:
+      case COMMAND_CW6:
+      case COMMAND_CW7:
+        window = (command - COMMAND_CW0);
+        if (currentWindow != window) {
+          currentWindow = window;
+          currentCueBuilder = cueBuilders[window];
+        }
+        break;
+      case COMMAND_CLW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].clear();
+          }
+        }
+        break;
+      case COMMAND_DSW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].setVisibility(true);
+          }
+        }
+        break;
+      case COMMAND_HDW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].setVisibility(false);
+          }
+        }
+        break;
+      case COMMAND_TGW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            CueBuilder cueBuilder = cueBuilders[NUM_WINDOWS - i];
+            cueBuilder.setVisibility(!cueBuilder.isVisible());
+          }
+        }
+        break;
+      case COMMAND_DLW:
+        for (int i = 1; i <= NUM_WINDOWS; i++) {
+          if (serviceBlockPacket.readBit()) {
+            cueBuilders[NUM_WINDOWS - i].reset();
+          }
+        }
+        break;
+      case COMMAND_DLY:
+        // TODO: Add support for delay commands.
+        serviceBlockPacket.skipBits(8);
+        break;
+      case COMMAND_DLC:
+        // TODO: Add support for delay commands.
+        break;
+      case COMMAND_RST:
+        resetCueBuilders();
+        break;
+      case COMMAND_SPA:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(16);
+        } else {
+          handleSetPenAttributes();
+        }
+        break;
+      case COMMAND_SPC:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(24);
+        } else {
+          handleSetPenColor();
+        }
+        break;
+      case COMMAND_SPL:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(16);
+        } else {
+          handleSetPenLocation();
+        }
+        break;
+      case COMMAND_SWA:
+        if (!currentCueBuilder.isDefined()) {
+          // ignore this command if the current window/cue isn't defined
+          serviceBlockPacket.skipBits(32);
+        } else {
+          handleSetWindowAttributes();
+        }
+        break;
+      case COMMAND_DF0:
+      case COMMAND_DF1:
+      case COMMAND_DF2:
+      case COMMAND_DF3:
+      case COMMAND_DS4:
+      case COMMAND_DF5:
+      case COMMAND_DF6:
+      case COMMAND_DF7:
+        window = (command - COMMAND_DF0);
+        handleDefineWindow(window);
+        // We also set the current window to the newly defined window.
+        if (currentWindow != window) {
+          currentWindow = window;
+          currentCueBuilder = cueBuilders[window];
+        }
+        break;
+      default:
+        Log.w(TAG, "Invalid C1 command: " + command);
+    }
+  }
+
+  private void handleC2Command(int command) {
+    // C2 Table doesn't contain any commands in CEA-708-B, but we do need to skip bytes
+    if (command <= 0x07) {
+      // Do nothing.
+    } else if (command <= 0x0F) {
+      serviceBlockPacket.skipBits(8);
+    } else if (command <= 0x17) {
+      serviceBlockPacket.skipBits(16);
+    } else if (command <= 0x1F) {
+      serviceBlockPacket.skipBits(24);
+    }
+  }
+
+  private void handleC3Command(int command) {
+    // C3 Table doesn't contain any commands in CEA-708-B, but we do need to skip bytes
+    if (command <= 0x87) {
+      serviceBlockPacket.skipBits(32);
+    } else if (command <= 0x8F) {
+      serviceBlockPacket.skipBits(40);
+    } else if (command <= 0x9F) {
+      // 90-9F are variable length codes; the first byte defines the header with the first
+      // 2 bits specifying the type and the last 6 bits specifying the remaining length of the
+      // command in bytes
+      serviceBlockPacket.skipBits(2);
+      int length = serviceBlockPacket.readBits(6);
+      serviceBlockPacket.skipBits(8 * length);
+    }
+  }
+
+  private void handleG0Character(int characterCode) {
+    if (characterCode == CHARACTER_MN) {
+      currentCueBuilder.append('\u266B');
+    } else {
+      currentCueBuilder.append((char) (characterCode & 0xFF));
+    }
+  }
+
+  private void handleG1Character(int characterCode) {
+    currentCueBuilder.append((char) (characterCode & 0xFF));
+  }
+
+  private void handleG2Character(int characterCode) {
+    switch (characterCode) {
+      case CHARACTER_TSP:
+        currentCueBuilder.append('\u0020');
+        break;
+      case CHARACTER_NBTSP:
+        currentCueBuilder.append('\u00A0');
+        break;
+      case CHARACTER_ELLIPSIS:
+        currentCueBuilder.append('\u2026');
+        break;
+      case CHARACTER_BIG_CARONS:
+        currentCueBuilder.append('\u0160');
+        break;
+      case CHARACTER_BIG_OE:
+        currentCueBuilder.append('\u0152');
+        break;
+      case CHARACTER_SOLID_BLOCK:
+        currentCueBuilder.append('\u2588');
+        break;
+      case CHARACTER_OPEN_SINGLE_QUOTE:
+        currentCueBuilder.append('\u2018');
+        break;
+      case CHARACTER_CLOSE_SINGLE_QUOTE:
+        currentCueBuilder.append('\u2019');
+        break;
+      case CHARACTER_OPEN_DOUBLE_QUOTE:
+        currentCueBuilder.append('\u201C');
+        break;
+      case CHARACTER_CLOSE_DOUBLE_QUOTE:
+        currentCueBuilder.append('\u201D');
+        break;
+      case CHARACTER_BOLD_BULLET:
+        currentCueBuilder.append('\u2022');
+        break;
+      case CHARACTER_TM:
+        currentCueBuilder.append('\u2122');
+        break;
+      case CHARACTER_SMALL_CARONS:
+        currentCueBuilder.append('\u0161');
+        break;
+      case CHARACTER_SMALL_OE:
+        currentCueBuilder.append('\u0153');
+        break;
+      case CHARACTER_SM:
+        currentCueBuilder.append('\u2120');
+        break;
+      case CHARACTER_DIAERESIS_Y:
+        currentCueBuilder.append('\u0178');
+        break;
+      case CHARACTER_ONE_EIGHTH:
+        currentCueBuilder.append('\u215B');
+        break;
+      case CHARACTER_THREE_EIGHTHS:
+        currentCueBuilder.append('\u215C');
+        break;
+      case CHARACTER_FIVE_EIGHTHS:
+        currentCueBuilder.append('\u215D');
+        break;
+      case CHARACTER_SEVEN_EIGHTHS:
+        currentCueBuilder.append('\u215E');
+        break;
+      case CHARACTER_VERTICAL_BORDER:
+        currentCueBuilder.append('\u2502');
+        break;
+      case CHARACTER_UPPER_RIGHT_BORDER:
+        currentCueBuilder.append('\u2510');
+        break;
+      case CHARACTER_LOWER_LEFT_BORDER:
+        currentCueBuilder.append('\u2514');
+        break;
+      case CHARACTER_HORIZONTAL_BORDER:
+        currentCueBuilder.append('\u2500');
+        break;
+      case CHARACTER_LOWER_RIGHT_BORDER:
+        currentCueBuilder.append('\u2518');
+        break;
+      case CHARACTER_UPPER_LEFT_BORDER:
+        currentCueBuilder.append('\u250C');
+        break;
+      default:
+        Log.w(TAG, "Invalid G2 character: " + characterCode);
+        // The CEA-708 specification doesn't specify what to do in the case of an unexpected
+        // value in the G2 character range, so we ignore it.
+    }
+  }
+
+  private void handleG3Character(int characterCode) {
+    if (characterCode == 0xA0) {
+      currentCueBuilder.append('\u33C4');
+    } else {
+      Log.w(TAG, "Invalid G3 character: " + characterCode);
+      // Substitute any unsupported G3 character with an underscore as per CEA-708 specification.
+      currentCueBuilder.append('_');
+    }
+  }
+
+  private void handleSetPenAttributes() {
+    // the SetPenAttributes command contains 2 bytes of data
+    // first byte
+    int textTag = serviceBlockPacket.readBits(4);
+    int offset = serviceBlockPacket.readBits(2);
+    int penSize = serviceBlockPacket.readBits(2);
+    // second byte
+    boolean italicsToggle = serviceBlockPacket.readBit();
+    boolean underlineToggle = serviceBlockPacket.readBit();
+    int edgeType = serviceBlockPacket.readBits(3);
+    int fontStyle = serviceBlockPacket.readBits(3);
+
+    currentCueBuilder.setPenAttributes(textTag, offset, penSize, italicsToggle, underlineToggle,
+        edgeType, fontStyle);
+  }
+
+  private void handleSetPenColor() {
+    // the SetPenColor command contains 3 bytes of data
+    // first byte
+    int foregroundO = serviceBlockPacket.readBits(2);
+    int foregroundR = serviceBlockPacket.readBits(2);
+    int foregroundG = serviceBlockPacket.readBits(2);
+    int foregroundB = serviceBlockPacket.readBits(2);
+    int foregroundColor = CueBuilder.getArgbColorFromCeaColor(foregroundR, foregroundG, foregroundB,
+        foregroundO);
+    // second byte
+    int backgroundO = serviceBlockPacket.readBits(2);
+    int backgroundR = serviceBlockPacket.readBits(2);
+    int backgroundG = serviceBlockPacket.readBits(2);
+    int backgroundB = serviceBlockPacket.readBits(2);
+    int backgroundColor = CueBuilder.getArgbColorFromCeaColor(backgroundR, backgroundG, backgroundB,
+        backgroundO);
+    // third byte
+    serviceBlockPacket.skipBits(2); // null padding
+    int edgeR = serviceBlockPacket.readBits(2);
+    int edgeG = serviceBlockPacket.readBits(2);
+    int edgeB = serviceBlockPacket.readBits(2);
+    int edgeColor = CueBuilder.getArgbColorFromCeaColor(edgeR, edgeG, edgeB);
+
+    currentCueBuilder.setPenColor(foregroundColor, backgroundColor, edgeColor);
+  }
+
+  private void handleSetPenLocation() {
+    // the SetPenLocation command contains 2 bytes of data
+    // first byte
+    serviceBlockPacket.skipBits(4);
+    int row = serviceBlockPacket.readBits(4);
+    // second byte
+    serviceBlockPacket.skipBits(2);
+    int column = serviceBlockPacket.readBits(6);
+
+    currentCueBuilder.setPenLocation(row, column);
+  }
+
+  private void handleSetWindowAttributes() {
+    // the SetWindowAttributes command contains 4 bytes of data
+    // first byte
+    int fillO = serviceBlockPacket.readBits(2);
+    int fillR = serviceBlockPacket.readBits(2);
+    int fillG = serviceBlockPacket.readBits(2);
+    int fillB = serviceBlockPacket.readBits(2);
+    int fillColor = CueBuilder.getArgbColorFromCeaColor(fillR, fillG, fillB, fillO);
+    // second byte
+    int borderType = serviceBlockPacket.readBits(2); // only the lower 2 bits of borderType
+    int borderR = serviceBlockPacket.readBits(2);
+    int borderG = serviceBlockPacket.readBits(2);
+    int borderB = serviceBlockPacket.readBits(2);
+    int borderColor = CueBuilder.getArgbColorFromCeaColor(borderR, borderG, borderB);
+    // third byte
+    if (serviceBlockPacket.readBit()) {
+      borderType |= 0x04; // set the top bit of the 3-bit borderType
+    }
+    boolean wordWrapToggle = serviceBlockPacket.readBit();
+    int printDirection = serviceBlockPacket.readBits(2);
+    int scrollDirection = serviceBlockPacket.readBits(2);
+    int justification = serviceBlockPacket.readBits(2);
+    // fourth byte
+    // Note that we don't intend to support display effects
+    serviceBlockPacket.skipBits(8); // effectSpeed(4), effectDirection(2), displayEffect(2)
+
+    currentCueBuilder.setWindowAttributes(fillColor, borderColor, wordWrapToggle, borderType,
+        printDirection, scrollDirection, justification);
+  }
+
+  private void handleDefineWindow(int window) {
+    CueBuilder cueBuilder = cueBuilders[window];
+
+    // the DefineWindow command contains 6 bytes of data
+    // first byte
+    serviceBlockPacket.skipBits(2); // null padding
+    boolean visible = serviceBlockPacket.readBit();
+    boolean rowLock = serviceBlockPacket.readBit();
+    boolean columnLock = serviceBlockPacket.readBit();
+    int priority = serviceBlockPacket.readBits(3);
+    // second byte
+    boolean relativePositioning = serviceBlockPacket.readBit();
+    int verticalAnchor = serviceBlockPacket.readBits(7);
+    // third byte
+    int horizontalAnchor = serviceBlockPacket.readBits(8);
+    // fourth byte
+    int anchorId = serviceBlockPacket.readBits(4);
+    int rowCount = serviceBlockPacket.readBits(4);
+    // fifth byte
+    serviceBlockPacket.skipBits(2); // null padding
+    int columnCount = serviceBlockPacket.readBits(6);
+    // sixth byte
+    serviceBlockPacket.skipBits(2); // null padding
+    int windowStyle = serviceBlockPacket.readBits(3);
+    int penStyle = serviceBlockPacket.readBits(3);
+
+    cueBuilder.defineWindow(visible, rowLock, columnLock, priority, relativePositioning,
+        verticalAnchor, horizontalAnchor, rowCount, columnCount, anchorId, windowStyle, penStyle);
+  }
+
+  private List<Cue> getDisplayCues() {
+    List<Cea708Cue> displayCues = new ArrayList<>();
+    for (int i = 0; i < NUM_WINDOWS; i++) {
+      if (!cueBuilders[i].isEmpty() && cueBuilders[i].isVisible()) {
+        displayCues.add(cueBuilders[i].build());
+      }
+    }
+    Collections.sort(displayCues);
+    return Collections.<Cue>unmodifiableList(displayCues);
+  }
+
+  private void resetCueBuilders() {
+    for (int i = 0; i < NUM_WINDOWS; i++) {
+      cueBuilders[i].reset();
+    }
+  }
+
+  private static final class DtvCcPacket {
+
+    public final int sequenceNumber;
+    public final int packetSize;
+    public final byte[] packetData;
+
+    int currentIndex;
+
+    public DtvCcPacket(int sequenceNumber, int packetSize) {
+      this.sequenceNumber = sequenceNumber;
+      this.packetSize = packetSize;
+      packetData = new byte[2 * packetSize - 1];
+      currentIndex = 0;
+    }
+
+  }
+
+  // TODO: There is a lot of overlap between Cea708Decoder.CueBuilder and Cea608Decoder.CueBuilder
+  // which could be refactored into a separate class.
+  private static final class CueBuilder {
+
+    private static final int RELATIVE_CUE_SIZE = 99;
+    private static final int VERTICAL_SIZE = 74;
+    private static final int HORIZONTAL_SIZE = 209;
+
+    private static final int DEFAULT_PRIORITY = 4;
+
+    private static final int MAXIMUM_ROW_COUNT = 15;
+
+    private static final int JUSTIFICATION_LEFT = 0;
+    private static final int JUSTIFICATION_RIGHT = 1;
+    private static final int JUSTIFICATION_CENTER = 2;
+    private static final int JUSTIFICATION_FULL = 3;
+
+    private static final int DIRECTION_LEFT_TO_RIGHT = 0;
+    private static final int DIRECTION_RIGHT_TO_LEFT = 1;
+    private static final int DIRECTION_TOP_TO_BOTTOM = 2;
+    private static final int DIRECTION_BOTTOM_TO_TOP = 3;
+
+    // TODO: Add other border/edge types when utilized.
+    private static final int BORDER_AND_EDGE_TYPE_NONE = 0;
+    private static final int BORDER_AND_EDGE_TYPE_UNIFORM = 3;
+
+    public static final int COLOR_SOLID_WHITE = getArgbColorFromCeaColor(2, 2, 2, 0);
+    public static final int COLOR_SOLID_BLACK = getArgbColorFromCeaColor(0, 0, 0, 0);
+    public static final int COLOR_TRANSPARENT = getArgbColorFromCeaColor(0, 0, 0, 3);
+
+    // TODO: Add other sizes when utilized.
+    private static final int PEN_SIZE_STANDARD = 1;
+
+    // TODO: Add other pen font styles when utilized.
+    private static final int PEN_FONT_STYLE_DEFAULT = 0;
+    private static final int PEN_FONT_STYLE_MONOSPACED_WITH_SERIFS = 1;
+    private static final int PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITH_SERIFS = 2;
+    private static final int PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS = 3;
+    private static final int PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS = 4;
+
+    // TODO: Add other pen offsets when utilized.
+    private static final int PEN_OFFSET_NORMAL = 1;
+
+    // The window style properties are specified in the CEA-708 specification.
+    private static final int[] WINDOW_STYLE_JUSTIFICATION = new int[]{
+        JUSTIFICATION_LEFT, JUSTIFICATION_LEFT, JUSTIFICATION_LEFT,
+        JUSTIFICATION_LEFT, JUSTIFICATION_LEFT, JUSTIFICATION_CENTER,
+        JUSTIFICATION_LEFT
+    };
+    private static final int[] WINDOW_STYLE_PRINT_DIRECTION = new int[]{
+        DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT,
+        DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT, DIRECTION_LEFT_TO_RIGHT,
+        DIRECTION_TOP_TO_BOTTOM
+    };
+    private static final int[] WINDOW_STYLE_SCROLL_DIRECTION = new int[]{
+        DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP,
+        DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP, DIRECTION_BOTTOM_TO_TOP,
+        DIRECTION_RIGHT_TO_LEFT
+    };
+    private static final boolean[] WINDOW_STYLE_WORD_WRAP = new boolean[]{
+        false, false, false, true, true, true, false
+    };
+    private static final int[] WINDOW_STYLE_FILL = new int[]{
+        COLOR_SOLID_BLACK, COLOR_TRANSPARENT, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK,
+        COLOR_TRANSPARENT, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK
+    };
+
+    // The pen style properties are specified in the CEA-708 specification.
+    private static final int[] PEN_STYLE_FONT_STYLE = new int[]{
+        PEN_FONT_STYLE_DEFAULT, PEN_FONT_STYLE_MONOSPACED_WITH_SERIFS,
+        PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITH_SERIFS, PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS,
+        PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS,
+        PEN_FONT_STYLE_MONOSPACED_WITHOUT_SERIFS,
+        PEN_FONT_STYLE_PROPORTIONALLY_SPACED_WITHOUT_SERIFS
+    };
+    private static final int[] PEN_STYLE_EDGE_TYPE = new int[]{
+        BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE,
+        BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_NONE, BORDER_AND_EDGE_TYPE_UNIFORM,
+        BORDER_AND_EDGE_TYPE_UNIFORM
+    };
+    private static final int[] PEN_STYLE_BACKGROUND = new int[]{
+        COLOR_SOLID_BLACK, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK, COLOR_SOLID_BLACK,
+        COLOR_SOLID_BLACK, COLOR_TRANSPARENT, COLOR_TRANSPARENT};
+
+    private final List<SpannableString> rolledUpCaptions;
+    private final SpannableStringBuilder captionStringBuilder;
+
+    // Window/Cue properties
+    private boolean defined;
+    private boolean visible;
+    private int priority;
+    private boolean relativePositioning;
+    private int verticalAnchor;
+    private int horizontalAnchor;
+    private int anchorId;
+    private int rowCount;
+    private boolean rowLock;
+    private int justification;
+    private int windowStyleId;
+    private int penStyleId;
+    private int windowFillColor;
+
+    // Pen/Text properties
+    private int italicsStartPosition;
+    private int underlineStartPosition;
+    private int foregroundColorStartPosition;
+    private int foregroundColor;
+    private int backgroundColorStartPosition;
+    private int backgroundColor;
+    private int row;
+
+    public CueBuilder() {
+      rolledUpCaptions = new LinkedList<>();
+      captionStringBuilder = new SpannableStringBuilder();
+      reset();
+    }
+
+    public boolean isEmpty() {
+      return !isDefined() || (rolledUpCaptions.isEmpty() && captionStringBuilder.length() == 0);
+    }
+
+    public void reset() {
+      clear();
+
+      defined = false;
+      visible = false;
+      priority = DEFAULT_PRIORITY;
+      relativePositioning = false;
+      verticalAnchor = 0;
+      horizontalAnchor = 0;
+      anchorId = 0;
+      rowCount = MAXIMUM_ROW_COUNT;
+      rowLock = true;
+      justification = JUSTIFICATION_LEFT;
+      windowStyleId = 0;
+      penStyleId = 0;
+      windowFillColor = COLOR_SOLID_BLACK;
+
+      foregroundColor = COLOR_SOLID_WHITE;
+      backgroundColor = COLOR_SOLID_BLACK;
+    }
+
+    public void clear() {
+      rolledUpCaptions.clear();
+      captionStringBuilder.clear();
+      italicsStartPosition = C.POSITION_UNSET;
+      underlineStartPosition = C.POSITION_UNSET;
+      foregroundColorStartPosition = C.POSITION_UNSET;
+      backgroundColorStartPosition = C.POSITION_UNSET;
+      row = 0;
+    }
+
+    public boolean isDefined() {
+      return defined;
+    }
+
+    public void setVisibility(boolean visible) {
+      this.visible = visible;
+    }
+
+    public boolean isVisible() {
+      return visible;
+    }
+
+    public void defineWindow(boolean visible, boolean rowLock, boolean columnLock, int priority,
+        boolean relativePositioning, int verticalAnchor, int horizontalAnchor, int rowCount,
+        int columnCount, int anchorId, int windowStyleId, int penStyleId) {
+      this.defined = true;
+      this.visible = visible;
+      this.rowLock = rowLock;
+      this.priority = priority;
+      this.relativePositioning = relativePositioning;
+      this.verticalAnchor = verticalAnchor;
+      this.horizontalAnchor = horizontalAnchor;
+      this.anchorId = anchorId;
+
+      // Decoders must add one to rowCount to get the desired number of rows.
+      if (this.rowCount != rowCount + 1) {
+        this.rowCount = rowCount + 1;
+
+        // Trim any rolled up captions that are no longer valid, if applicable.
+        while ((rowLock && (rolledUpCaptions.size() >= this.rowCount))
+            || (rolledUpCaptions.size() >= MAXIMUM_ROW_COUNT)) {
+          rolledUpCaptions.remove(0);
+        }
+      }
+
+      // TODO: Add support for column lock and count.
+
+      if (windowStyleId != 0 && this.windowStyleId != windowStyleId) {
+        this.windowStyleId = windowStyleId;
+        // windowStyleId is 1-based.
+        int windowStyleIdIndex = windowStyleId - 1;
+        // Note that Border type and border color are the same for all window styles.
+        setWindowAttributes(WINDOW_STYLE_FILL[windowStyleIdIndex], COLOR_TRANSPARENT,
+            WINDOW_STYLE_WORD_WRAP[windowStyleIdIndex], BORDER_AND_EDGE_TYPE_NONE,
+            WINDOW_STYLE_PRINT_DIRECTION[windowStyleIdIndex],
+            WINDOW_STYLE_SCROLL_DIRECTION[windowStyleIdIndex],
+            WINDOW_STYLE_JUSTIFICATION[windowStyleIdIndex]);
+      }
+
+      if (penStyleId != 0 && this.penStyleId != penStyleId) {
+        this.penStyleId = penStyleId;
+        // penStyleId is 1-based.
+        int penStyleIdIndex = penStyleId - 1;
+        // Note that pen size, offset, italics, underline, foreground color, and foreground
+        // opacity are the same for all pen styles.
+        setPenAttributes(0, PEN_OFFSET_NORMAL, PEN_SIZE_STANDARD, false, false,
+            PEN_STYLE_EDGE_TYPE[penStyleIdIndex], PEN_STYLE_FONT_STYLE[penStyleIdIndex]);
+        setPenColor(COLOR_SOLID_WHITE, PEN_STYLE_BACKGROUND[penStyleIdIndex], COLOR_SOLID_BLACK);
+      }
+    }
+
+
+    public void setWindowAttributes(int fillColor, int borderColor, boolean wordWrapToggle,
+        int borderType, int printDirection, int scrollDirection, int justification) {
+      this.windowFillColor = fillColor;
+      // TODO: Add support for border color and types.
+      // TODO: Add support for word wrap.
+      // TODO: Add support for other scroll directions.
+      // TODO: Add support for other print directions.
+      this.justification = justification;
+
+    }
+
+    public void setPenAttributes(int textTag, int offset, int penSize, boolean italicsToggle,
+        boolean underlineToggle, int edgeType, int fontStyle) {
+      // TODO: Add support for text tags.
+      // TODO: Add support for other offsets.
+      // TODO: Add support for other pen sizes.
+
+      if (italicsStartPosition != C.POSITION_UNSET) {
+        if (!italicsToggle) {
+          captionStringBuilder.setSpan(new StyleSpan(Typeface.ITALIC), italicsStartPosition,
+              captionStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+          italicsStartPosition = C.POSITION_UNSET;
+        }
+      } else if (italicsToggle) {
+        italicsStartPosition = captionStringBuilder.length();
+      }
+
+      if (underlineStartPosition != C.POSITION_UNSET) {
+        if (!underlineToggle) {
+          captionStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition,
+              captionStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+          underlineStartPosition = C.POSITION_UNSET;
+        }
+      } else if (underlineToggle) {
+        underlineStartPosition = captionStringBuilder.length();
+      }
+
+      // TODO: Add support for edge types.
+      // TODO: Add support for other font styles.
+    }
+
+    public void setPenColor(int foregroundColor, int backgroundColor, int edgeColor) {
+      if (foregroundColorStartPosition != C.POSITION_UNSET) {
+        if (this.foregroundColor != foregroundColor) {
+          captionStringBuilder.setSpan(new ForegroundColorSpan(this.foregroundColor),
+              foregroundColorStartPosition, captionStringBuilder.length(),
+              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+      }
+      if (foregroundColor != COLOR_SOLID_WHITE) {
+        foregroundColorStartPosition = captionStringBuilder.length();
+        this.foregroundColor = foregroundColor;
+      }
+
+      if (backgroundColorStartPosition != C.POSITION_UNSET) {
+        if (this.backgroundColor != backgroundColor) {
+          captionStringBuilder.setSpan(new BackgroundColorSpan(this.backgroundColor),
+              backgroundColorStartPosition, captionStringBuilder.length(),
+              Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+      }
+      if (backgroundColor != COLOR_SOLID_BLACK) {
+        backgroundColorStartPosition = captionStringBuilder.length();
+        this.backgroundColor = backgroundColor;
+      }
+
+      // TODO: Add support for edge color.
+    }
+
+    public void setPenLocation(int row, int column) {
+      // TODO: Support moving the pen location with a window properly.
+
+      // Until we support proper pen locations, if we encounter a row that's different from the
+      // previous one, we should append a new line. Otherwise, we'll see strings that should be
+      // on new lines concatenated with the previous, resulting in 2 words being combined, as
+      // well as potentially drawing beyond the width of the window/screen.
+      if (this.row != row) {
+        append('\n');
+      }
+      this.row = row;
+    }
+
+    public void backspace() {
+      int length = captionStringBuilder.length();
+      if (length > 0) {
+        captionStringBuilder.delete(length - 1, length);
+      }
+    }
+
+    public void append(char text) {
+      if (text == '\n') {
+        rolledUpCaptions.add(buildSpannableString());
+        captionStringBuilder.clear();
+
+        if (italicsStartPosition != C.POSITION_UNSET) {
+          italicsStartPosition = 0;
+        }
+        if (underlineStartPosition != C.POSITION_UNSET) {
+          underlineStartPosition = 0;
+        }
+        if (foregroundColorStartPosition != C.POSITION_UNSET) {
+          foregroundColorStartPosition = 0;
+        }
+        if (backgroundColorStartPosition != C.POSITION_UNSET) {
+          backgroundColorStartPosition = 0;
+        }
+
+        while ((rowLock && (rolledUpCaptions.size() >= rowCount))
+            || (rolledUpCaptions.size() >= MAXIMUM_ROW_COUNT)) {
+          rolledUpCaptions.remove(0);
+        }
+      } else {
+        captionStringBuilder.append(text);
+      }
+    }
+
+    public SpannableString buildSpannableString() {
+      SpannableStringBuilder spannableStringBuilder =
+          new SpannableStringBuilder(captionStringBuilder);
+      int length = spannableStringBuilder.length();
+
+      if (length > 0) {
+        if (italicsStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new StyleSpan(Typeface.ITALIC), italicsStartPosition,
+              length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+
+        if (underlineStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new UnderlineSpan(), underlineStartPosition,
+              length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+
+        if (foregroundColorStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new ForegroundColorSpan(foregroundColor),
+              foregroundColorStartPosition, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+
+        if (backgroundColorStartPosition != C.POSITION_UNSET) {
+          spannableStringBuilder.setSpan(new BackgroundColorSpan(backgroundColor),
+              backgroundColorStartPosition, length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        }
+      }
+
+      return new SpannableString(spannableStringBuilder);
+    }
+
+    public Cea708Cue build() {
+      if (isEmpty()) {
+        // The cue is empty.
+        return null;
+      }
+
+      SpannableStringBuilder cueString = new SpannableStringBuilder();
+
+      // Add any rolled up captions, separated by new lines.
+      for (int i = 0; i < rolledUpCaptions.size(); i++) {
+        cueString.append(rolledUpCaptions.get(i));
+        cueString.append('\n');
+      }
+      // Add the current line.
+      cueString.append(buildSpannableString());
+
+      // TODO: Add support for right-to-left languages (i.e. where right would correspond to normal
+      // alignment).
+      Alignment alignment;
+      switch (justification) {
+        case JUSTIFICATION_FULL:
+          // TODO: Add support for full justification.
+        case JUSTIFICATION_LEFT:
+          alignment = Alignment.ALIGN_NORMAL;
+          break;
+        case JUSTIFICATION_RIGHT:
+          alignment = Alignment.ALIGN_OPPOSITE;
+          break;
+        case JUSTIFICATION_CENTER:
+          alignment = Alignment.ALIGN_CENTER;
+          break;
+        default:
+          throw new IllegalArgumentException("Unexpected justification value: " + justification);
+      }
+
+      float position;
+      float line;
+      if (relativePositioning) {
+        position = (float) horizontalAnchor / RELATIVE_CUE_SIZE;
+        line = (float) verticalAnchor / RELATIVE_CUE_SIZE;
+      } else {
+        position = (float) horizontalAnchor / HORIZONTAL_SIZE;
+        line = (float) verticalAnchor / VERTICAL_SIZE;
+      }
+      // Apply screen-edge padding to the line and position.
+      position = (position * 0.9f) + 0.05f;
+      line = (line * 0.9f) + 0.05f;
+
+      // anchorId specifies where the anchor should be placed on the caption cue/window. The 9
+      // possible configurations are as follows:
+      //   0-----1-----2
+      //   |           |
+      //   3     4     5
+      //   |           |
+      //   6-----7-----8
+      @AnchorType int verticalAnchorType;
+      if (anchorId % 3 == 0) {
+        verticalAnchorType = Cue.ANCHOR_TYPE_START;
+      } else if (anchorId % 3 == 1) {
+        verticalAnchorType = Cue.ANCHOR_TYPE_MIDDLE;
+      } else {
+        verticalAnchorType = Cue.ANCHOR_TYPE_END;
+      }
+      // TODO: Add support for right-to-left languages (i.e. where start is on the right).
+      @AnchorType int horizontalAnchorType;
+      if (anchorId / 3 == 0) {
+        horizontalAnchorType = Cue.ANCHOR_TYPE_START;
+      } else if (anchorId / 3 == 1) {
+        horizontalAnchorType = Cue.ANCHOR_TYPE_MIDDLE;
+      } else {
+        horizontalAnchorType = Cue.ANCHOR_TYPE_END;
+      }
+
+      boolean windowColorSet = (windowFillColor != COLOR_SOLID_BLACK);
+
+      return new Cea708Cue(cueString, alignment, line, Cue.LINE_TYPE_FRACTION, verticalAnchorType,
+          position, horizontalAnchorType, Cue.DIMEN_UNSET, windowColorSet, windowFillColor,
+          priority);
+    }
+
+    public static int getArgbColorFromCeaColor(int red, int green, int blue) {
+      return getArgbColorFromCeaColor(red, green, blue, 0);
+    }
+
+    public static int getArgbColorFromCeaColor(int red, int green, int blue, int opacity) {
+      Assertions.checkIndex(red, 0, 4);
+      Assertions.checkIndex(green, 0, 4);
+      Assertions.checkIndex(blue, 0, 4);
+      Assertions.checkIndex(opacity, 0, 4);
+
+      int alpha;
+      switch (opacity) {
+        case 0:
+        case 1:
+          // Note the value of '1' is actually FLASH, but we don't support that.
+          alpha = 255;
+          break;
+        case 2:
+          alpha = 127;
+          break;
+        case 3:
+          alpha = 0;
+          break;
+        default:
+          alpha = 255;
+      }
+
+      // TODO: Add support for the Alternative Minimum Color List or the full 64 RGB combinations.
+
+      // Return values based on the Minimum Color List
+      return Color.argb(alpha,
+          (red > 1 ? 255 : 0),
+          (green > 1 ? 255 : 0),
+          (blue > 1 ? 255 : 0));
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
index ae92d7fab8..fac0982e65 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.text.cea;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Subtitle;
 import com.google.android.exoplayer2.text.SubtitleDecoder;
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
@@ -74,7 +75,13 @@ public SubtitleInputBuffer dequeueInputBuffer() throws SubtitleDecoderException
   public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDecoderException {
     Assertions.checkArgument(inputBuffer != null);
     Assertions.checkArgument(inputBuffer == dequeuedInputBuffer);
-    queuedInputBuffers.add(inputBuffer);
+    if (inputBuffer.isDecodeOnly()) {
+      // We can drop this buffer early (i.e. before it would be decoded) as the CEA formats allow
+      // for decoding to begin mid-stream.
+      releaseInputBuffer(inputBuffer);
+    } else {
+      queuedInputBuffers.add(inputBuffer);
+    }
     dequeuedInputBuffer = null;
   }
 
@@ -109,7 +116,7 @@ public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderExceptio
         Subtitle subtitle = createSubtitle();
         if (!inputBuffer.isDecodeOnly()) {
           SubtitleOutputBuffer outputBuffer = availableOutputBuffers.pollFirst();
-          outputBuffer.setContent(inputBuffer.timeUs, subtitle, 0);
+          outputBuffer.setContent(inputBuffer.timeUs, subtitle, Format.OFFSET_SAMPLE_RELATIVE);
           releaseInputBuffer(inputBuffer);
           return outputBuffer;
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
index 620b2c7d80..7da2054a08 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaSubtitle.java
@@ -15,8 +15,11 @@
  */
 package com.google.android.exoplayer2.text.cea;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.text.Cue;
 import com.google.android.exoplayer2.text.Subtitle;
+import com.google.android.exoplayer2.util.Assertions;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -35,7 +38,7 @@ public CeaSubtitle(List<Cue> cues) {
 
   @Override
   public int getNextEventTimeIndex(long timeUs) {
-    return 0;
+    return timeUs < 0 ? 0 : C.INDEX_UNSET;
   }
 
   @Override
@@ -45,12 +48,13 @@ public int getEventTimeCount() {
 
   @Override
   public long getEventTime(int index) {
+    Assertions.checkArgument(index == 0);
     return 0;
   }
 
   @Override
   public List<Cue> getCues(long timeUs) {
-    return cues;
+    return timeUs >= 0 ? cues : Collections.<Cue>emptyList();
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
new file mode 100644
index 0000000000..130c7461f9
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.cea;
+
+import android.util.Log;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+
+/**
+ * Utility methods for handling CEA-608/708 messages.
+ */
+public final class CeaUtil {
+
+  private static final String TAG = "CeaUtil";
+
+  private static final int PAYLOAD_TYPE_CC = 4;
+  private static final int COUNTRY_CODE = 0xB5;
+  private static final int PROVIDER_CODE = 0x31;
+  private static final int USER_ID = 0x47413934; // "GA94"
+  private static final int USER_DATA_TYPE_CODE = 0x3;
+
+  /**
+   * Consumes the unescaped content of an SEI NAL unit, writing the content of any CEA-608 messages
+   * as samples to all of the provided outputs.
+   *
+   * @param presentationTimeUs The presentation time in microseconds for any samples.
+   * @param seiBuffer The unescaped SEI NAL unit data, excluding the NAL unit start code and type.
+   * @param outputs The outputs to which any samples should be written.
+   */
+  public static void consume(long presentationTimeUs, ParsableByteArray seiBuffer,
+      TrackOutput[] outputs) {
+    while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
+      int payloadType = readNon255TerminatedValue(seiBuffer);
+      int payloadSize = readNon255TerminatedValue(seiBuffer);
+      // Process the payload.
+      if (payloadSize == -1 || payloadSize > seiBuffer.bytesLeft()) {
+        // This might occur if we're trying to read an encrypted SEI NAL unit.
+        Log.w(TAG, "Skipping remainder of malformed SEI NAL unit.");
+        seiBuffer.setPosition(seiBuffer.limit());
+      } else if (isSeiMessageCea608(payloadType, payloadSize, seiBuffer)) {
+        // Ignore country_code (1) + provider_code (2) + user_identifier (4)
+        // + user_data_type_code (1).
+        seiBuffer.skipBytes(8);
+        // Ignore first three bits: reserved (1) + process_cc_data_flag (1) + zero_bit (1).
+        int ccCount = seiBuffer.readUnsignedByte() & 0x1F;
+        // Ignore em_data (1)
+        seiBuffer.skipBytes(1);
+        // Each data packet consists of 24 bits: marker bits (5) + cc_valid (1) + cc_type (2)
+        // + cc_data_1 (8) + cc_data_2 (8).
+        int sampleLength = ccCount * 3;
+        int sampleStartPosition = seiBuffer.getPosition();
+        for (TrackOutput output : outputs) {
+          seiBuffer.setPosition(sampleStartPosition);
+          output.sampleData(seiBuffer, sampleLength);
+          output.sampleMetadata(presentationTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleLength, 0, null);
+        }
+        // Ignore trailing information in SEI, if any.
+        seiBuffer.skipBytes(payloadSize - (10 + ccCount * 3));
+      } else {
+        seiBuffer.skipBytes(payloadSize);
+      }
+    }
+  }
+
+  /**
+   * Reads a value from the provided buffer consisting of zero or more 0xFF bytes followed by a
+   * terminating byte not equal to 0xFF. The returned value is ((0xFF * N) + T), where N is the
+   * number of 0xFF bytes and T is the value of the terminating byte.
+   *
+   * @param buffer The buffer from which to read the value.
+   * @returns The read value, or -1 if the end of the buffer is reached before a value is read.
+   */
+  private static int readNon255TerminatedValue(ParsableByteArray buffer) {
+    int b;
+    int value = 0;
+    do {
+      if (buffer.bytesLeft() == 0) {
+        return -1;
+      }
+      b = buffer.readUnsignedByte();
+      value += b;
+    } while (b == 0xFF);
+    return value;
+  }
+
+  /**
+   * Inspects an sei message to determine whether it contains CEA-608.
+   * <p>
+   * The position of {@code payload} is left unchanged.
+   *
+   * @param payloadType The payload type of the message.
+   * @param payloadLength The length of the payload.
+   * @param payload A {@link ParsableByteArray} containing the payload.
+   * @return Whether the sei message contains CEA-608.
+   */
+  private static boolean isSeiMessageCea608(int payloadType, int payloadLength,
+      ParsableByteArray payload) {
+    if (payloadType != PAYLOAD_TYPE_CC || payloadLength < 8) {
+      return false;
+    }
+    int startPosition = payload.getPosition();
+    int countryCode = payload.readUnsignedByte();
+    int providerCode = payload.readUnsignedShort();
+    int userIdentifier = payload.readInt();
+    int userDataTypeCode = payload.readUnsignedByte();
+    payload.setPosition(startPosition);
+    return countryCode == COUNTRY_CODE && providerCode == PROVIDER_CODE
+        && userIdentifier == USER_ID && userDataTypeCode == USER_DATA_TYPE_CODE;
+  }
+
+  private CeaUtil() {}
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java b/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
index e4c36be03a..90f93d5b21 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlStyle.java
@@ -56,16 +56,11 @@
   private boolean hasFontColor;
   private int backgroundColor;
   private boolean hasBackgroundColor;
-  @OptionalBoolean
-  private int linethrough;
-  @OptionalBoolean
-  private int underline;
-  @OptionalBoolean
-  private int bold;
-  @OptionalBoolean
-  private int italic;
-  @FontSizeUnit
-  private int fontSizeUnit;
+  @OptionalBoolean private int linethrough;
+  @OptionalBoolean private int underline;
+  @OptionalBoolean private int bold;
+  @OptionalBoolean private int italic;
+  @FontSizeUnit private int fontSizeUnit;
   private float fontSize;
   private String id;
   private TtmlStyle inheritableStyle;
@@ -85,8 +80,7 @@ public TtmlStyle() {
    * @return {@link #UNSPECIFIED}, {@link #STYLE_NORMAL}, {@link #STYLE_BOLD}, {@link #STYLE_BOLD}
    *     or {@link #STYLE_BOLD_ITALIC}.
    */
-  @StyleFlags
-  public int getStyle() {
+  @StyleFlags public int getStyle() {
     if (bold == UNSPECIFIED && italic == UNSPECIFIED) {
       return UNSPECIFIED;
     }
@@ -255,8 +249,7 @@ public TtmlStyle setFontSizeUnit(int fontSizeUnit) {
     return this;
   }
 
-  @FontSizeUnit
-  public int getFontSizeUnit() {
+  @FontSizeUnit public int getFontSizeUnit() {
     return fontSizeUnit;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java b/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
index 157174a8f0..10c17e2888 100644
--- a/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
+++ b/library/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
@@ -69,16 +69,11 @@
   private boolean hasFontColor;
   private int backgroundColor;
   private boolean hasBackgroundColor;
-  @OptionalBoolean
-  private int linethrough;
-  @OptionalBoolean
-  private int underline;
-  @OptionalBoolean
-  private int bold;
-  @OptionalBoolean
-  private int italic;
-  @FontSizeUnit
-  private int fontSizeUnit;
+  @OptionalBoolean private int linethrough;
+  @OptionalBoolean private int underline;
+  @OptionalBoolean private int bold;
+  @OptionalBoolean private int italic;
+  @FontSizeUnit private int fontSizeUnit;
   private float fontSize;
   private Layout.Alignment textAlign;
 
@@ -162,8 +157,7 @@ public int getSpecificityScore(String id, String tag, String[] classes, String v
    * @return {@link #UNSPECIFIED}, {@link #STYLE_NORMAL}, {@link #STYLE_BOLD}, {@link #STYLE_BOLD}
    *     or {@link #STYLE_BOLD_ITALIC}.
    */
-  @StyleFlags
-  public int getStyle() {
+  @StyleFlags public int getStyle() {
     if (bold == UNSPECIFIED && italic == UNSPECIFIED) {
       return UNSPECIFIED;
     }
@@ -260,8 +254,7 @@ public WebvttCssStyle setFontSizeUnit(short unit) {
     return this;
   }
 
-  @FontSizeUnit
-  public int getFontSizeUnit() {
+  @FontSizeUnit public int getFontSizeUnit() {
     return fontSizeUnit;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
similarity index 88%
rename from library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
rename to library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index 868303cc5b..dc78e28e56 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -24,13 +24,13 @@
 import java.util.List;
 
 /**
- * A bandwidth based adaptive {@link TrackSelection} for video, whose selected track is updated to
- * be the one of highest quality given the current network conditions and the state of the buffer.
+ * A bandwidth based adaptive {@link TrackSelection}, whose selected track is updated to be the one
+ * of highest quality given the current network conditions and the state of the buffer.
  */
-public class AdaptiveVideoTrackSelection extends BaseTrackSelection {
+public class AdaptiveTrackSelection extends BaseTrackSelection {
 
   /**
-   * Factory for {@link AdaptiveVideoTrackSelection} instances.
+   * Factory for {@link AdaptiveTrackSelection} instances.
    */
   public static final class Factory implements TrackSelection.Factory {
 
@@ -79,8 +79,8 @@ public Factory(BandwidthMeter bandwidthMeter, int maxInitialBitrate,
     }
 
     @Override
-    public AdaptiveVideoTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
-      return new AdaptiveVideoTrackSelection(group, tracks, bandwidthMeter, maxInitialBitrate,
+    public AdaptiveTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
+      return new AdaptiveTrackSelection(group, tracks, bandwidthMeter, maxInitialBitrate,
           minDurationForQualityIncreaseMs, maxDurationForQualityDecreaseMs,
           minDurationToRetainAfterDiscardMs, bandwidthFraction);
     }
@@ -104,12 +104,12 @@ public AdaptiveVideoTrackSelection createTrackSelection(TrackGroup group, int...
   private int reason;
 
   /**
-   * @param group The {@link TrackGroup}. Must not be null.
+   * @param group The {@link TrackGroup}.
    * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-   *     null or empty. May be in any order.
+   *     empty. May be in any order.
    * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
    */
-  public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks,
+  public AdaptiveTrackSelection(TrackGroup group, int[] tracks,
       BandwidthMeter bandwidthMeter) {
     this (group, tracks, bandwidthMeter, DEFAULT_MAX_INITIAL_BITRATE,
         DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
@@ -118,9 +118,9 @@ public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks,
   }
 
   /**
-   * @param group The {@link TrackGroup}. Must not be null.
+   * @param group The {@link TrackGroup}.
    * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be
-   *     null or empty. May be in any order.
+   *     empty. May be in any order.
    * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
    * @param maxInitialBitrate The maximum bitrate in bits per second that should be assumed when a
    *     bandwidth estimate is unavailable.
@@ -136,7 +136,7 @@ public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks,
    *     consider available for use. Setting to a value less than 1 is recommended to account
    *     for inaccuracies in the bandwidth estimator.
    */
-  public AdaptiveVideoTrackSelection(TrackGroup group, int[] tracks, BandwidthMeter bandwidthMeter,
+  public AdaptiveTrackSelection(TrackGroup group, int[] tracks, BandwidthMeter bandwidthMeter,
       int maxInitialBitrate, long minDurationForQualityIncreaseMs,
       long maxDurationForQualityDecreaseMs, long minDurationToRetainAfterDiscardMs,
       float bandwidthFraction) {
@@ -208,15 +208,18 @@ public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk>
     }
     int idealSelectedIndex = determineIdealSelectedIndex(SystemClock.elapsedRealtime());
     Format idealFormat = getFormat(idealSelectedIndex);
-    // Discard from the first SD chunk beyond minDurationToRetainAfterDiscardUs whose resolution and
-    // bitrate are both lower than the ideal track.
+    // If the chunks contain video, discard from the first SD chunk beyond
+    // minDurationToRetainAfterDiscardUs whose resolution and bitrate are both lower than the ideal
+    // track.
     for (int i = 0; i < queueSize; i++) {
       MediaChunk chunk = queue.get(i);
+      Format format = chunk.trackFormat;
       long durationBeforeThisChunkUs = chunk.startTimeUs - playbackPositionUs;
       if (durationBeforeThisChunkUs >= minDurationToRetainAfterDiscardUs
-          && chunk.trackFormat.bitrate < idealFormat.bitrate
-          && chunk.trackFormat.height < idealFormat.height
-          && chunk.trackFormat.height < 720 && chunk.trackFormat.width < 1280) {
+          && format.bitrate < idealFormat.bitrate
+          && format.height != Format.NO_VALUE && format.height < 720
+          && format.width != Format.NO_VALUE && format.width < 1280
+          && format.height < idealFormat.height) {
         return i;
       }
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
index c81ffb441f..054ee7973f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
@@ -148,7 +148,7 @@ public final boolean blacklist(int index, long blacklistDurationMs) {
   }
 
   /**
-   * Returns whether the track at the specified index in the selection is blaclisted.
+   * Returns whether the track at the specified index in the selection is blacklisted.
    *
    * @param index The index of the track in the selection.
    * @param nowMs The current time in the timebase of {@link SystemClock#elapsedRealtime()}.
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 79979401f7..1fa372ca0a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -54,6 +54,7 @@
     public final boolean allowNonSeamlessAdaptiveness;
     public final int maxVideoWidth;
     public final int maxVideoHeight;
+    public final int maxVideoBitrate;
     public final boolean exceedVideoConstraintsIfNecessary;
     public final boolean exceedRendererCapabilitiesIfNecessary;
     public final int viewportWidth;
@@ -68,14 +69,15 @@
      *   <li>Adaptation between different mime types is not allowed.</li>
      *   <li>Non seamless adaptation is allowed.</li>
      *   <li>No max limit for video width/height.</li>
+     *   <li>No max video bitrate.</li>
      *   <li>Video constraints are exceeded if no supported selection can be made otherwise.</li>
      *   <li>Renderer capabilities are exceeded if no supported selection can be made.</li>
      *   <li>No viewport width/height constraints are set.</li>
      * </ul>
      */
     public Parameters() {
-      this(null, null, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, true, true,
-          Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+      this(null, null, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, true,
+          true, Integer.MAX_VALUE, Integer.MAX_VALUE, true);
     }
 
     /**
@@ -88,6 +90,7 @@ public Parameters() {
      * @param allowNonSeamlessAdaptiveness Whether non-seamless adaptation is allowed.
      * @param maxVideoWidth Maximum allowed video width.
      * @param maxVideoHeight Maximum allowed video height.
+     * @param maxVideoBitrate Maximum allowed video bitrate.
      * @param exceedVideoConstraintsIfNecessary Whether to exceed video constraints when no
      *     selection can be made otherwise.
      * @param exceedRendererCapabilitiesIfNecessary Whether to exceed renderer capabilities when no
@@ -98,15 +101,16 @@ public Parameters() {
      */
     public Parameters(String preferredAudioLanguage, String preferredTextLanguage,
         boolean allowMixedMimeAdaptiveness, boolean allowNonSeamlessAdaptiveness,
-        int maxVideoWidth, int maxVideoHeight, boolean exceedVideoConstraintsIfNecessary,
-        boolean exceedRendererCapabilitiesIfNecessary, int viewportWidth, int viewportHeight,
-        boolean orientationMayChange) {
+        int maxVideoWidth, int maxVideoHeight, int maxVideoBitrate,
+        boolean exceedVideoConstraintsIfNecessary, boolean exceedRendererCapabilitiesIfNecessary,
+        int viewportWidth, int viewportHeight, boolean orientationMayChange) {
       this.preferredAudioLanguage = preferredAudioLanguage;
       this.preferredTextLanguage = preferredTextLanguage;
       this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
       this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
       this.maxVideoWidth = maxVideoWidth;
       this.maxVideoHeight = maxVideoHeight;
+      this.maxVideoBitrate = maxVideoBitrate;
       this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
       this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
       this.viewportWidth = viewportWidth;
@@ -130,8 +134,8 @@ public Parameters withPreferredAudioLanguage(String preferredAudioLanguage) {
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, orientationMayChange);
     }
 
     /**
@@ -148,8 +152,8 @@ public Parameters withPreferredTextLanguage(String preferredTextLanguage) {
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, orientationMayChange);
     }
 
     /**
@@ -164,8 +168,8 @@ public Parameters withAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiven
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, orientationMayChange);
     }
 
     /**
@@ -180,8 +184,8 @@ public Parameters withAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdapt
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, orientationMayChange);
     }
 
     /**
@@ -197,8 +201,24 @@ public Parameters withMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, orientationMayChange);
+    }
+
+    /**
+     * Returns a {@link Parameters} instance with the provided max video bitrate.
+     *
+     * @param maxVideoBitrate The max video bitrate.
+     * @return A {@link Parameters} instance with the provided max video bitrate.
+     */
+    public Parameters withMaxVideoBitrate(int maxVideoBitrate) {
+      if (maxVideoBitrate == this.maxVideoBitrate) {
+        return this;
+      }
+      return new Parameters(preferredAudioLanguage, preferredTextLanguage,
+          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, orientationMayChange);
     }
 
     /**
@@ -235,8 +255,8 @@ public Parameters withExceedVideoConstraintsIfNecessary(
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, orientationMayChange);
     }
 
     /**
@@ -255,8 +275,8 @@ public Parameters withExceedRendererCapabilitiesIfNecessary(
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, orientationMayChange);
     }
 
     /**
@@ -275,8 +295,8 @@ public Parameters withViewportSize(int viewportWidth, int viewportHeight,
       }
       return new Parameters(preferredAudioLanguage, preferredTextLanguage,
           allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary, viewportWidth,
-          viewportHeight, orientationMayChange);
+          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
+          viewportWidth, viewportHeight, orientationMayChange);
     }
 
     /**
@@ -319,6 +339,7 @@ public boolean equals(Object obj) {
           && exceedRendererCapabilitiesIfNecessary == other.exceedRendererCapabilitiesIfNecessary
           && orientationMayChange == other.orientationMayChange
           && viewportWidth == other.viewportWidth && viewportHeight == other.viewportHeight
+          && maxVideoBitrate == other.maxVideoBitrate
           && TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
           && TextUtils.equals(preferredTextLanguage, other.preferredTextLanguage);
     }
@@ -331,6 +352,7 @@ public int hashCode() {
       result = 31 * result + (allowNonSeamlessAdaptiveness ? 1 : 0);
       result = 31 * result + maxVideoWidth;
       result = 31 * result + maxVideoHeight;
+      result = 31 * result + maxVideoBitrate;
       result = 31 * result + (exceedVideoConstraintsIfNecessary ? 1 : 0);
       result = 31 * result + (exceedRendererCapabilitiesIfNecessary ? 1 : 0);
       result = 31 * result + (orientationMayChange ? 1 : 0);
@@ -399,18 +421,25 @@ public Parameters getParameters() {
       TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
       throws ExoPlaybackException {
     // Make a track selection for each renderer.
-    TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCapabilities.length];
+    int rendererCount = rendererCapabilities.length;
+    TrackSelection[] rendererTrackSelections = new TrackSelection[rendererCount];
     Parameters params = paramsReference.get();
-    for (int i = 0; i < rendererCapabilities.length; i++) {
+
+    for (int i = 0; i < rendererCount; i++) {
+      if (C.TRACK_TYPE_VIDEO == rendererCapabilities[i].getTrackType()) {
+        rendererTrackSelections[i] = selectVideoTrack(rendererCapabilities[i],
+            rendererTrackGroupArrays[i], rendererFormatSupports[i], params.maxVideoWidth,
+            params.maxVideoHeight, params.maxVideoBitrate, params.allowNonSeamlessAdaptiveness,
+            params.allowMixedMimeAdaptiveness, params.viewportWidth, params.viewportHeight,
+            params.orientationMayChange, adaptiveVideoTrackSelectionFactory,
+            params.exceedVideoConstraintsIfNecessary, params.exceedRendererCapabilitiesIfNecessary);
+      }
+    }
+
+    for (int i = 0; i < rendererCount; i++) {
       switch (rendererCapabilities[i].getTrackType()) {
         case C.TRACK_TYPE_VIDEO:
-          rendererTrackSelections[i] = selectVideoTrack(rendererCapabilities[i],
-              rendererTrackGroupArrays[i], rendererFormatSupports[i], params.maxVideoWidth,
-              params.maxVideoHeight, params.allowNonSeamlessAdaptiveness,
-              params.allowMixedMimeAdaptiveness, params.viewportWidth, params.viewportHeight,
-              params.orientationMayChange, adaptiveVideoTrackSelectionFactory,
-              params.exceedVideoConstraintsIfNecessary,
-              params.exceedRendererCapabilitiesIfNecessary);
+          // Already done. Do nothing.
           break;
         case C.TRACK_TYPE_AUDIO:
           rendererTrackSelections[i] = selectAudioTrack(rendererTrackGroupArrays[i],
@@ -436,30 +465,30 @@ public Parameters getParameters() {
 
   protected TrackSelection selectVideoTrack(RendererCapabilities rendererCapabilities,
       TrackGroupArray groups, int[][] formatSupport, int maxVideoWidth, int maxVideoHeight,
-      boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness, int viewportWidth,
-      int viewportHeight, boolean orientationMayChange,
+      int maxVideoBitrate, boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness,
+      int viewportWidth, int viewportHeight, boolean orientationMayChange,
       TrackSelection.Factory adaptiveVideoTrackSelectionFactory,
       boolean exceedConstraintsIfNecessary, boolean exceedRendererCapabilitiesIfNecessary)
       throws ExoPlaybackException {
     TrackSelection selection = null;
     if (adaptiveVideoTrackSelectionFactory != null) {
       selection = selectAdaptiveVideoTrack(rendererCapabilities, groups, formatSupport,
-          maxVideoWidth, maxVideoHeight, allowNonSeamlessAdaptiveness,
+          maxVideoWidth, maxVideoHeight, maxVideoBitrate, allowNonSeamlessAdaptiveness,
           allowMixedMimeAdaptiveness, viewportWidth, viewportHeight,
           orientationMayChange, adaptiveVideoTrackSelectionFactory);
     }
     if (selection == null) {
       selection = selectFixedVideoTrack(groups, formatSupport, maxVideoWidth, maxVideoHeight,
-          viewportWidth, viewportHeight, orientationMayChange, exceedConstraintsIfNecessary,
-          exceedRendererCapabilitiesIfNecessary);
+          maxVideoBitrate, viewportWidth, viewportHeight, orientationMayChange,
+          exceedConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary);
     }
     return selection;
   }
 
   private static TrackSelection selectAdaptiveVideoTrack(RendererCapabilities rendererCapabilities,
       TrackGroupArray groups, int[][] formatSupport, int maxVideoWidth, int maxVideoHeight,
-      boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness, int viewportWidth,
-      int viewportHeight, boolean orientationMayChange,
+      int maxVideoBitrate, boolean allowNonSeamlessAdaptiveness, boolean allowMixedMimeAdaptiveness,
+      int viewportWidth, int viewportHeight, boolean orientationMayChange,
       TrackSelection.Factory adaptiveVideoTrackSelectionFactory) throws ExoPlaybackException {
     int requiredAdaptiveSupport = allowNonSeamlessAdaptiveness
         ? (RendererCapabilities.ADAPTIVE_NOT_SEAMLESS | RendererCapabilities.ADAPTIVE_SEAMLESS)
@@ -470,7 +499,7 @@ private static TrackSelection selectAdaptiveVideoTrack(RendererCapabilities rend
       TrackGroup group = groups.get(i);
       int[] adaptiveTracks = getAdaptiveTracksForGroup(group, formatSupport[i],
           allowMixedMimeTypes, requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight,
-          viewportWidth, viewportHeight, orientationMayChange);
+          maxVideoBitrate, viewportWidth, viewportHeight, orientationMayChange);
       if (adaptiveTracks.length > 0) {
         return adaptiveVideoTrackSelectionFactory.createTrackSelection(group, adaptiveTracks);
       }
@@ -480,7 +509,8 @@ private static TrackSelection selectAdaptiveVideoTrack(RendererCapabilities rend
 
   private static int[] getAdaptiveTracksForGroup(TrackGroup group, int[] formatSupport,
       boolean allowMixedMimeTypes, int requiredAdaptiveSupport, int maxVideoWidth,
-      int maxVideoHeight, int viewportWidth, int viewportHeight, boolean orientationMayChange) {
+      int maxVideoHeight, int maxVideoBitrate, int viewportWidth, int viewportHeight,
+      boolean orientationMayChange) {
     if (group.length < 2) {
       return NO_TRACKS;
     }
@@ -499,11 +529,10 @@ private static TrackSelection selectAdaptiveVideoTrack(RendererCapabilities rend
       for (int i = 0; i < selectedTrackIndices.size(); i++) {
         int trackIndex = selectedTrackIndices.get(i);
         String sampleMimeType = group.getFormat(trackIndex).sampleMimeType;
-        if (!seenMimeTypes.contains(sampleMimeType)) {
-          seenMimeTypes.add(sampleMimeType);
+        if (seenMimeTypes.add(sampleMimeType)) {
           int countForMimeType = getAdaptiveTrackCountForMimeType(group, formatSupport,
               requiredAdaptiveSupport, sampleMimeType, maxVideoWidth, maxVideoHeight,
-              selectedTrackIndices);
+              maxVideoBitrate, selectedTrackIndices);
           if (countForMimeType > selectedMimeTypeTrackCount) {
             selectedMimeType = sampleMimeType;
             selectedMimeTypeTrackCount = countForMimeType;
@@ -514,19 +543,20 @@ private static TrackSelection selectAdaptiveVideoTrack(RendererCapabilities rend
 
     // Filter by the selected mime type.
     filterAdaptiveTrackCountForMimeType(group, formatSupport, requiredAdaptiveSupport,
-        selectedMimeType, maxVideoWidth, maxVideoHeight, selectedTrackIndices);
+        selectedMimeType, maxVideoWidth, maxVideoHeight, maxVideoBitrate, selectedTrackIndices);
 
     return selectedTrackIndices.size() < 2 ? NO_TRACKS : Util.toArray(selectedTrackIndices);
   }
 
   private static int getAdaptiveTrackCountForMimeType(TrackGroup group, int[] formatSupport,
       int requiredAdaptiveSupport, String mimeType, int maxVideoWidth, int maxVideoHeight,
-      List<Integer> selectedTrackIndices) {
+      int maxVideoBitrate, List<Integer> selectedTrackIndices) {
     int adaptiveTrackCount = 0;
     for (int i = 0; i < selectedTrackIndices.size(); i++) {
       int trackIndex = selectedTrackIndices.get(i);
       if (isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
-          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight)) {
+          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight,
+          maxVideoBitrate)) {
         adaptiveTrackCount++;
       }
     }
@@ -535,31 +565,35 @@ private static int getAdaptiveTrackCountForMimeType(TrackGroup group, int[] form
 
   private static void filterAdaptiveTrackCountForMimeType(TrackGroup group, int[] formatSupport,
       int requiredAdaptiveSupport, String mimeType, int maxVideoWidth, int maxVideoHeight,
-      List<Integer> selectedTrackIndices) {
+      int maxVideoBitrate, List<Integer> selectedTrackIndices) {
     for (int i = selectedTrackIndices.size() - 1; i >= 0; i--) {
       int trackIndex = selectedTrackIndices.get(i);
       if (!isSupportedAdaptiveVideoTrack(group.getFormat(trackIndex), mimeType,
-          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight)) {
+          formatSupport[trackIndex], requiredAdaptiveSupport, maxVideoWidth, maxVideoHeight,
+          maxVideoBitrate)) {
         selectedTrackIndices.remove(i);
       }
     }
   }
 
   private static boolean isSupportedAdaptiveVideoTrack(Format format, String mimeType,
-      int formatSupport, int requiredAdaptiveSupport, int maxVideoWidth, int maxVideoHeight) {
+      int formatSupport, int requiredAdaptiveSupport, int maxVideoWidth, int maxVideoHeight,
+      int maxVideoBitrate) {
     return isSupported(formatSupport, false) && ((formatSupport & requiredAdaptiveSupport) != 0)
         && (mimeType == null || Util.areEqual(format.sampleMimeType, mimeType))
         && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
-        && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
+        && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight)
+        && (format.bitrate == Format.NO_VALUE || format.bitrate <= maxVideoBitrate);
   }
 
   private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
-      int[][] formatSupport, int maxVideoWidth, int maxVideoHeight, int viewportWidth,
-      int viewportHeight, boolean orientationMayChange, boolean exceedConstraintsIfNecessary,
-      boolean exceedRendererCapabilitiesIfNecessary) {
+      int[][] formatSupport, int maxVideoWidth, int maxVideoHeight, int maxVideoBitrate,
+      int viewportWidth, int viewportHeight, boolean orientationMayChange,
+      boolean exceedConstraintsIfNecessary, boolean exceedRendererCapabilitiesIfNecessary) {
     TrackGroup selectedGroup = null;
     int selectedTrackIndex = 0;
     int selectedTrackScore = 0;
+    int selectedBitrate = Format.NO_VALUE;
     int selectedPixelCount = Format.NO_VALUE;
     for (int groupIndex = 0; groupIndex < groups.length; groupIndex++) {
       TrackGroup trackGroup = groups.get(groupIndex);
@@ -571,7 +605,8 @@ private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
           Format format = trackGroup.getFormat(trackIndex);
           boolean isWithinConstraints = selectedTrackIndices.contains(trackIndex)
               && (format.width == Format.NO_VALUE || format.width <= maxVideoWidth)
-              && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight);
+              && (format.height == Format.NO_VALUE || format.height <= maxVideoHeight)
+              && (format.bitrate == Format.NO_VALUE || format.bitrate <= maxVideoBitrate);
           if (!isWithinConstraints && !exceedConstraintsIfNecessary) {
             // Track should not be selected.
             continue;
@@ -582,16 +617,24 @@ private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
           }
           boolean selectTrack = trackScore > selectedTrackScore;
           if (trackScore == selectedTrackScore) {
-            // Use the pixel count as a tie breaker. If we're within constraints prefer a higher
-            // pixel count, else prefer a lower count. If still tied then prefer the first track
-            // (i.e. the one that's already selected).
-            int pixelComparison = comparePixelCounts(format.getPixelCount(), selectedPixelCount);
-            selectTrack = isWithinConstraints ? pixelComparison > 0 : pixelComparison < 0;
+            // Use the pixel count as a tie breaker (or bitrate if pixel counts are tied). If we're
+            // within constraints prefer a higher pixel count (or bitrate), else prefer a lower
+            // count (or bitrate). If still tied then prefer the first track (i.e. the one that's
+            // already selected).
+            int comparisonResult;
+            int formatPixelCount = format.getPixelCount();
+            if (formatPixelCount != selectedPixelCount) {
+              comparisonResult = compareFormatValues(format.getPixelCount(), selectedPixelCount);
+            } else {
+              comparisonResult = compareFormatValues(format.bitrate, selectedBitrate);
+            }
+            selectTrack = isWithinConstraints ? comparisonResult > 0 : comparisonResult < 0;
           }
           if (selectTrack) {
             selectedGroup = trackGroup;
             selectedTrackIndex = trackIndex;
             selectedTrackScore = trackScore;
+            selectedBitrate = format.bitrate;
             selectedPixelCount = format.getPixelCount();
           }
         }
@@ -602,20 +645,19 @@ private static TrackSelection selectFixedVideoTrack(TrackGroupArray groups,
   }
 
   /**
-   * Compares two pixel counts for order. A known pixel count is considered greater than
+   * Compares two format values for order. A known value is considered greater than
    * {@link Format#NO_VALUE}.
    *
-   * @param first The first pixel count.
-   * @param second The second pixel count.
-   * @return A negative integer if the first pixel count is less than the second. Zero if they are
-   *     equal. A positive integer if the first pixel count is greater than the second.
+   * @param first The first value.
+   * @param second The second value.
+   * @return A negative integer if the first value is less than the second. Zero if they are equal.
+   *     A positive integer if the first value is greater than the second.
    */
-  private static int comparePixelCounts(int first, int second) {
+  private static int compareFormatValues(int first, int second) {
     return first == Format.NO_VALUE ? (second == Format.NO_VALUE ? 0 : -1)
         : (second == Format.NO_VALUE ? 1 : (first - second));
   }
 
-
   // Audio track selection implementation.
 
   protected TrackSelection selectAudioTrack(TrackGroupArray groups, int[][] formatSupport,
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
index 77df9a2173..690723cf15 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/MappingTrackSelector.java
@@ -15,12 +15,13 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.util.Pair;
+import android.content.Context;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.RendererConfiguration;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.util.Util;
@@ -82,12 +83,14 @@ public boolean containsTrack(int track) {
 
   private final SparseArray<Map<TrackGroupArray, SelectionOverride>> selectionOverrides;
   private final SparseBooleanArray rendererDisabledFlags;
+  private int tunnelingAudioSessionId;
 
   private MappedTrackInfo currentMappedTrackInfo;
 
   public MappingTrackSelector() {
     selectionOverrides = new SparseArray<>();
     rendererDisabledFlags = new SparseBooleanArray();
+    tunnelingAudioSessionId = C.AUDIO_SESSION_ID_UNSET;
   }
 
   /**
@@ -224,12 +227,28 @@ public final void clearSelectionOverrides() {
     invalidate();
   }
 
+  /**
+   * Enables or disables tunneling. To enable tunneling, pass an audio session id to use when in
+   * tunneling mode. Session ids can be generated using
+   * {@link C#generateAudioSessionIdV21(Context)}. To disable tunneling pass
+   * {@link C#AUDIO_SESSION_ID_UNSET}. Tunneling will only be activated if it's both enabled and
+   * supported by the audio and video renderers for the selected tracks.
+   *
+   * @param tunnelingAudioSessionId The audio session id to use when tunneling, or
+   *     {@link C#AUDIO_SESSION_ID_UNSET} to disable tunneling.
+   */
+  public void setTunnelingAudioSessionId(int tunnelingAudioSessionId) {
+    if (this.tunnelingAudioSessionId != tunnelingAudioSessionId) {
+      this.tunnelingAudioSessionId = tunnelingAudioSessionId;
+      invalidate();
+    }
+  }
+
   // TrackSelector implementation.
 
   @Override
-  public final Pair<TrackSelectionArray, Object> selectTracks(
-      RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
-      throws ExoPlaybackException {
+  public final TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray trackGroups) throws ExoPlaybackException {
     // Structures into which data will be written during the selection. The extra item at the end
     // of each array is to store data associated with track groups that cannot be associated with
     // any renderer.
@@ -297,8 +316,20 @@ public final void clearSelectionOverrides() {
     MappedTrackInfo mappedTrackInfo = new MappedTrackInfo(rendererTrackTypes,
         rendererTrackGroupArrays, mixedMimeTypeAdaptationSupport, rendererFormatSupports,
         unassociatedTrackGroupArray);
-    return Pair.<TrackSelectionArray, Object>create(new TrackSelectionArray(trackSelections),
-        mappedTrackInfo);
+
+    // Initialize the renderer configurations to the default configuration for all renderers with
+    // selections, and null otherwise.
+    RendererConfiguration[] rendererConfigurations =
+        new RendererConfiguration[rendererCapabilities.length];
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      rendererConfigurations[i] = trackSelections[i] != null ? RendererConfiguration.DEFAULT : null;
+    }
+    // Configure audio and video renderers to use tunneling if appropriate.
+    maybeConfigureRenderersForTunneling(rendererCapabilities, rendererTrackGroupArrays,
+        rendererFormatSupports, rendererConfigurations, trackSelections, tunnelingAudioSessionId);
+
+    return new TrackSelectorResult(trackGroups, new TrackSelectionArray(trackSelections),
+        mappedTrackInfo, rendererConfigurations);
   }
 
   @Override
@@ -345,15 +376,16 @@ public final void onSelectionActivated(Object info) {
   private static int findRenderer(RendererCapabilities[] rendererCapabilities, TrackGroup group)
       throws ExoPlaybackException {
     int bestRendererIndex = rendererCapabilities.length;
-    int bestSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
+    int bestFormatSupportLevel = RendererCapabilities.FORMAT_UNSUPPORTED_TYPE;
     for (int rendererIndex = 0; rendererIndex < rendererCapabilities.length; rendererIndex++) {
       RendererCapabilities rendererCapability = rendererCapabilities[rendererIndex];
       for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
-        int trackSupportLevel = rendererCapability.supportsFormat(group.getFormat(trackIndex));
-        if (trackSupportLevel > bestSupportLevel) {
+        int formatSupportLevel = rendererCapability.supportsFormat(group.getFormat(trackIndex))
+            & RendererCapabilities.FORMAT_SUPPORT_MASK;
+        if (formatSupportLevel > bestFormatSupportLevel) {
           bestRendererIndex = rendererIndex;
-          bestSupportLevel = trackSupportLevel;
-          if (bestSupportLevel == RendererCapabilities.FORMAT_HANDLED) {
+          bestFormatSupportLevel = formatSupportLevel;
+          if (bestFormatSupportLevel == RendererCapabilities.FORMAT_HANDLED) {
             // We can't do better.
             return bestRendererIndex;
           }
@@ -400,6 +432,94 @@ private static int findRenderer(RendererCapabilities[] rendererCapabilities, Tra
     return mixedMimeTypeAdaptationSupport;
   }
 
+  /**
+   * Determines whether tunneling should be enabled, replacing {@link RendererConfiguration}s in
+   * {@code rendererConfigurations} with configurations that enable tunneling on the appropriate
+   * renderers if so.
+   *
+   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which
+   *     {@link TrackSelection}s are to be generated.
+   * @param rendererTrackGroupArrays An array of {@link TrackGroupArray}s where each entry
+   *     corresponds to the renderer of equal index in {@code renderers}.
+   * @param rendererFormatSupports Maps every available track to a specific level of support as
+   *     defined by the renderer {@code FORMAT_*} constants.
+   * @param rendererConfigurations The renderer configurations. Configurations may be replaced with
+   *     ones that enable tunneling as a result of this call.
+   * @param trackSelections The renderer track selections.
+   * @param tunnelingAudioSessionId The audio session id to use when tunneling, or
+   *     {@link C#AUDIO_SESSION_ID_UNSET} if tunneling should not be enabled.
+   */
+  private static void maybeConfigureRenderersForTunneling(
+      RendererCapabilities[] rendererCapabilities, TrackGroupArray[] rendererTrackGroupArrays,
+      int[][][] rendererFormatSupports, RendererConfiguration[] rendererConfigurations,
+      TrackSelection[] trackSelections, int tunnelingAudioSessionId) {
+    if (tunnelingAudioSessionId == C.AUDIO_SESSION_ID_UNSET) {
+      return;
+    }
+    // Check whether we can enable tunneling. To enable tunneling we require exactly one audio and
+    // one video renderer to support tunneling and have a selection.
+    int tunnelingAudioRendererIndex = -1;
+    int tunnelingVideoRendererIndex = -1;
+    boolean enableTunneling = true;
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      int rendererType = rendererCapabilities[i].getTrackType();
+      TrackSelection trackSelection = trackSelections[i];
+      if ((rendererType == C.TRACK_TYPE_AUDIO || rendererType == C.TRACK_TYPE_VIDEO)
+          && trackSelection != null) {
+        if (rendererSupportsTunneling(rendererFormatSupports[i], rendererTrackGroupArrays[i],
+            trackSelection)) {
+          if (rendererType == C.TRACK_TYPE_AUDIO) {
+            if (tunnelingAudioRendererIndex != -1) {
+              enableTunneling = false;
+              break;
+            } else {
+              tunnelingAudioRendererIndex = i;
+            }
+          } else {
+            if (tunnelingVideoRendererIndex != -1) {
+              enableTunneling = false;
+              break;
+            } else {
+              tunnelingVideoRendererIndex = i;
+            }
+          }
+        }
+      }
+    }
+    enableTunneling &= tunnelingAudioRendererIndex != -1 && tunnelingVideoRendererIndex != -1;
+    if (enableTunneling) {
+      RendererConfiguration tunnelingRendererConfiguration =
+          new RendererConfiguration(tunnelingAudioSessionId);
+      rendererConfigurations[tunnelingAudioRendererIndex] = tunnelingRendererConfiguration;
+      rendererConfigurations[tunnelingVideoRendererIndex] = tunnelingRendererConfiguration;
+    }
+  }
+
+  /**
+   * Returns whether a renderer supports tunneling for a {@link TrackSelection}.
+   *
+   * @param formatSupport The result of {@link RendererCapabilities#supportsFormat} for each
+   *     track, indexed by group index and track index (in that order).
+   * @param trackGroups The {@link TrackGroupArray}s for the renderer.
+   * @param selection The track selection.
+   * @return Whether the renderer supports tunneling for the {@link TrackSelection}.
+   */
+  private static boolean rendererSupportsTunneling(int[][] formatSupport,
+      TrackGroupArray trackGroups, TrackSelection selection) {
+    if (selection == null) {
+      return false;
+    }
+    int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
+    for (int i = 0; i < selection.length(); i++) {
+      int trackFormatSupport = formatSupport[trackGroupIndex][selection.getIndexInTrackGroup(i)];
+      if ((trackFormatSupport & RendererCapabilities.TUNNELING_SUPPORT_MASK)
+          != RendererCapabilities.TUNNELING_SUPPORTED) {
+        return false;
+      }
+    }
+    return true;
+  }
+
   /**
    * Provides track information for each renderer.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
index 5a9d3923bf..6c9fbfcb00 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelector.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.util.Pair;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.RendererCapabilities;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -47,25 +46,22 @@ public final void init(InvalidationListener listener) {
   }
 
   /**
-   * Generates {@link TrackSelectionArray} for the renderers.
+   * Performs a track selection for renderers.
    *
-   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which
-   *     {@link TrackSelection}s are to be generated.
+   * @param rendererCapabilities The {@link RendererCapabilities} of the renderers for which tracks
+   *     are to be selected.
    * @param trackGroups The available track groups.
-   * @return The track selections, and an implementation specific object that will be returned to
-   *     the selector via {@link #onSelectionActivated(Object)} should the selections be activated.
+   * @return A {@link TrackSelectorResult} describing the track selections.
    * @throws ExoPlaybackException If an error occurs selecting tracks.
    */
-  public abstract Pair<TrackSelectionArray, Object> selectTracks(
-      RendererCapabilities[] rendererCapabilities, TrackGroupArray trackGroups)
-      throws ExoPlaybackException;
+  public abstract TrackSelectorResult selectTracks(RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray trackGroups) throws ExoPlaybackException;
 
   /**
-   * Called when {@link TrackSelectionArray} previously generated by
-   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} are activated.
+   * Called when a {@link TrackSelectorResult} previously generated by
+   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray)} is activated.
    *
-   * @param info The information associated with the selections, or null if the selected tracks are
-   *     being cleared.
+   * @param info The value of {@link TrackSelectorResult#info} in the activated result.
    */
   public abstract void onSelectionActivated(Object info);
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
new file mode 100644
index 0000000000..5cdb157570
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import com.google.android.exoplayer2.RendererConfiguration;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * The result of a {@link TrackSelector} operation.
+ */
+public final class TrackSelectorResult {
+
+  /**
+   * The groups provided to the {@link TrackSelector}.
+   */
+  public final TrackGroupArray groups;
+  /**
+   * A {@link TrackSelectionArray} containing the selection for each renderer.
+   */
+  public final TrackSelectionArray selections;
+  /**
+   * An opaque object that will be returned to {@link TrackSelector#onSelectionActivated(Object)}
+   * should the selections be activated.
+   */
+  public final Object info;
+  /**
+   * A {@link RendererConfiguration} for each renderer, to be used with the selections.
+   */
+  public final RendererConfiguration[] rendererConfigurations;
+
+  /**
+   * @param groups The groups provided to the {@link TrackSelector}.
+   * @param selections A {@link TrackSelectionArray} containing the selection for each renderer.
+   * @param info An opaque object that will be returned to
+   *     {@link TrackSelector#onSelectionActivated(Object)} should the selections be activated.
+   * @param rendererConfigurations A {@link RendererConfiguration} for each renderer, to be used
+   *     with the selections.
+   */
+  public TrackSelectorResult(TrackGroupArray groups, TrackSelectionArray selections, Object info,
+      RendererConfiguration[] rendererConfigurations) {
+    this.groups = groups;
+    this.selections = selections;
+    this.info = info;
+    this.rendererConfigurations = rendererConfigurations;
+  }
+
+  /**
+   * Returns whether this result is equivalent to {@code other} for all renderers.
+   *
+   * @param other The other {@link TrackSelectorResult}. May be null, in which case {@code false}
+   *     will be returned in all cases.
+   * @return Whether this result is equivalent to {@code other} for all renderers.
+   */
+  public boolean isEquivalent(TrackSelectorResult other) {
+    if (other == null) {
+      return false;
+    }
+    for (int i = 0; i < selections.length; i++) {
+      if (!isEquivalent(other, i)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Returns whether this result is equivalent to {@code other} for the renderer at the given index.
+   * The results are equivalent if they have equal track selections and configurations for the
+   * renderer.
+   *
+   * @param other The other {@link TrackSelectorResult}. May be null, in which case {@code false}
+   *     will be returned in all cases.
+   * @param index The renderer index to check for equivalence.
+   * @return Whether this result is equivalent to {@code other} for all renderers.
+   */
+  public boolean isEquivalent(TrackSelectorResult other, int index) {
+    if (other == null) {
+      return false;
+    }
+    return Util.areEqual(selections.get(index), other.selections.get(index))
+        && Util.areEqual(rendererConfigurations[index], other.rendererConfigurations[index]);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index 40e814dab3..dc3c398357 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -735,8 +735,14 @@ public void onStartTrackingTouch(SeekBar seekBar) {
 
     @Override
     public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-      if (fromUser && positionView != null) {
-        positionView.setText(stringForTime(positionValue(progress)));
+      if (fromUser) {
+        long position = positionValue(progress);
+        if (positionView != null) {
+          positionView.setText(stringForTime(position));
+        }
+        if (player != null && !dragging) {
+          seekTo(position);
+        }
       }
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java b/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
index d094266fcc..3349e05eda 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
@@ -65,6 +65,13 @@
  *         <li>Default: {@code true}</li>
  *       </ul>
  *   </li>
+ *   <li><b>{@code default_artwork}</b> - Default artwork to use if no artwork available in audio
+ *       streams.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setDefaultArtwork(Bitmap)}</li>
+ *         <li>Default: {@code null}</li>
+ *       </ul>
+ *   </li>
  *   <li><b>{@code use_controller}</b> - Whether playback controls are displayed.
  *       <ul>
  *         <li>Corresponding method: {@link #setUseController(boolean)}</li>
@@ -179,6 +186,7 @@
   private SimpleExoPlayer player;
   private boolean useController;
   private boolean useArtwork;
+  private Bitmap defaultArtwork;
   private int controllerShowTimeoutMs;
 
   public SimpleExoPlayerView(Context context) {
@@ -194,6 +202,7 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
 
     int playerLayoutId = R.layout.exo_simple_player_view;
     boolean useArtwork = true;
+    int defaultArtworkId = 0;
     boolean useController = true;
     int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
     int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;
@@ -205,6 +214,8 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
         playerLayoutId = a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id,
             playerLayoutId);
         useArtwork = a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork, useArtwork);
+        defaultArtworkId = a.getResourceId(R.styleable.SimpleExoPlayerView_default_artwork,
+            defaultArtworkId);
         useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller, useController);
         surfaceType = a.getInt(R.styleable.SimpleExoPlayerView_surface_type, surfaceType);
         resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode, resizeMode);
@@ -246,6 +257,9 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
     // Artwork view.
     artworkView = (ImageView) findViewById(R.id.exo_artwork);
     this.useArtwork = useArtwork && artworkView != null;
+    if (defaultArtworkId != 0) {
+      defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId);
+    }
 
     // Subtitle view.
     subtitleView = (SubtitleView) findViewById(R.id.exo_subtitles);
@@ -351,6 +365,26 @@ public void setUseArtwork(boolean useArtwork) {
     }
   }
 
+  /**
+   * Returns the default artwork to display.
+   */
+  public Bitmap getDefaultArtwork() {
+    return defaultArtwork;
+  }
+
+  /**
+   * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
+   * present in the media.
+   *
+   * @param defaultArtwork the default artwork to display.
+   */
+  public void setDefaultArtwork(Bitmap defaultArtwork) {
+    if (this.defaultArtwork != defaultArtwork) {
+      this.defaultArtwork = defaultArtwork;
+      updateForCurrentTrackSelections();
+    }
+  }
+
   /**
    * Returns whether the playback controls are enabled.
    */
@@ -569,6 +603,9 @@ private void updateForCurrentTrackSelections() {
           }
         }
       }
+      if (setArtworkFromBitmap(defaultArtwork)) {
+        return;
+      }
     }
     // Artwork disabled or unavailable.
     hideArtwork();
@@ -580,18 +617,23 @@ private boolean setArtworkFromMetadata(Metadata metadata) {
       if (metadataEntry instanceof ApicFrame) {
         byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
         Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
-        if (bitmap != null) {
-          int bitmapWidth = bitmap.getWidth();
-          int bitmapHeight = bitmap.getHeight();
-          if (bitmapWidth > 0 && bitmapHeight > 0) {
-            if (contentFrame != null) {
-              contentFrame.setAspectRatio((float) bitmapWidth / bitmapHeight);
-            }
-            artworkView.setImageBitmap(bitmap);
-            artworkView.setVisibility(VISIBLE);
-            return true;
-          }
+        return setArtworkFromBitmap(bitmap);
+      }
+    }
+    return false;
+  }
+
+  private boolean setArtworkFromBitmap(Bitmap bitmap) {
+    if (bitmap != null) {
+      int bitmapWidth = bitmap.getWidth();
+      int bitmapHeight = bitmap.getHeight();
+      if (bitmapWidth > 0 && bitmapHeight > 0) {
+        if (contentFrame != null) {
+          contentFrame.setAspectRatio((float) bitmapWidth / bitmapHeight);
         }
+        artworkView.setImageBitmap(bitmap);
+        artworkView.setVisibility(VISIBLE);
+        return true;
       }
     }
     return false;
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
index de461ecf0d..d4f09b1721 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java
@@ -18,11 +18,13 @@
 import android.content.Context;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
+import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.Paint.Join;
 import android.graphics.Paint.Style;
+import android.graphics.Rect;
 import android.graphics.RectF;
 import android.text.Layout.Alignment;
 import android.text.StaticLayout;
@@ -65,6 +67,7 @@
   // Previous input variables.
   private CharSequence cueText;
   private Alignment cueTextAlignment;
+  private Bitmap cueBitmap;
   private float cueLine;
   @Cue.LineType
   private int cueLineType;
@@ -93,6 +96,7 @@
   private int textLeft;
   private int textTop;
   private int textPaddingX;
+  private Rect bitmapRect;
 
   @SuppressWarnings("ResourceType")
   public SubtitlePainter(Context context) {
@@ -141,17 +145,28 @@ public SubtitlePainter(Context context) {
   public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style, float textSizePx,
       float bottomPaddingFraction, Canvas canvas, int cueBoxLeft, int cueBoxTop, int cueBoxRight,
       int cueBoxBottom) {
-    CharSequence cueText = cue.text;
-    if (TextUtils.isEmpty(cueText)) {
-      // Nothing to draw.
-      return;
-    }
-    if (!applyEmbeddedStyles) {
-      // Strip out any embedded styling.
-      cueText = cueText.toString();
+    boolean isTextCue = cue.bitmap == null;
+    CharSequence cueText = null;
+    Bitmap cueBitmap = null;
+    int windowColor = Color.BLACK;
+    if (isTextCue) {
+      cueText = cue.text;
+      if (TextUtils.isEmpty(cueText)) {
+        // Nothing to draw.
+        return;
+      }
+      windowColor = cue.windowColorSet ? cue.windowColor : style.windowColor;
+      if (!applyEmbeddedStyles) {
+        // Strip out any embedded styling.
+        cueText = cueText.toString();
+        windowColor = style.windowColor;
+      }
+    } else {
+      cueBitmap = cue.bitmap;
     }
     if (areCharSequencesEqual(this.cueText, cueText)
         && Util.areEqual(this.cueTextAlignment, cue.textAlignment)
+        && this.cueBitmap == cueBitmap
         && this.cueLine == cue.line
         && this.cueLineType == cue.lineType
         && Util.areEqual(this.cueLineAnchor, cue.lineAnchor)
@@ -161,7 +176,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
         && this.applyEmbeddedStyles == applyEmbeddedStyles
         && this.foregroundColor == style.foregroundColor
         && this.backgroundColor == style.backgroundColor
-        && this.windowColor == style.windowColor
+        && this.windowColor == windowColor
         && this.edgeType == style.edgeType
         && this.edgeColor == style.edgeColor
         && Util.areEqual(this.textPaint.getTypeface(), style.typeface)
@@ -172,12 +187,13 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
         && this.parentRight == cueBoxRight
         && this.parentBottom == cueBoxBottom) {
       // We can use the cached layout.
-      drawLayout(canvas);
+      drawLayout(canvas, isTextCue);
       return;
     }
 
     this.cueText = cueText;
     this.cueTextAlignment = cue.textAlignment;
+    this.cueBitmap = cueBitmap;
     this.cueLine = cue.line;
     this.cueLineType = cue.lineType;
     this.cueLineAnchor = cue.lineAnchor;
@@ -187,7 +203,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
     this.applyEmbeddedStyles = applyEmbeddedStyles;
     this.foregroundColor = style.foregroundColor;
     this.backgroundColor = style.backgroundColor;
-    this.windowColor = style.windowColor;
+    this.windowColor = windowColor;
     this.edgeType = style.edgeType;
     this.edgeColor = style.edgeColor;
     this.textPaint.setTypeface(style.typeface);
@@ -198,6 +214,15 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
     this.parentRight = cueBoxRight;
     this.parentBottom = cueBoxBottom;
 
+    if (isTextCue) {
+      setupTextLayout();
+    } else {
+      setupBitmapLayout();
+    }
+    drawLayout(canvas, isTextCue);
+  }
+
+  private void setupTextLayout() {
     int parentWidth = parentRight - parentLeft;
     int parentHeight = parentBottom - parentTop;
 
@@ -233,7 +258,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
       int anchorPosition = Math.round(parentWidth * cuePosition) + parentLeft;
       textLeft = cuePositionAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textWidth
           : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textWidth) / 2
-          : anchorPosition;
+              : anchorPosition;
       textLeft = Math.max(textLeft, parentLeft);
       textRight = Math.min(textLeft + textWidth, parentRight);
     } else {
@@ -241,6 +266,12 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
       textRight = textLeft + textWidth;
     }
 
+    textWidth = textRight - textLeft;
+    if (textWidth <= 0) {
+      Log.w(TAG, "Skipped drawing subtitle cue (invalid horizontal positioning)");
+      return;
+    }
+
     int textTop;
     if (cueLine != Cue.DIMEN_UNSET) {
       int anchorPosition;
@@ -257,7 +288,7 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
       }
       textTop = cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight
           : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2
-          : anchorPosition;
+              : anchorPosition;
       if (textTop + textHeight > parentBottom) {
         textTop = parentBottom - textHeight;
       } else if (textTop < parentTop) {
@@ -267,25 +298,38 @@ public void draw(Cue cue, boolean applyEmbeddedStyles, CaptionStyleCompat style,
       textTop = parentBottom - textHeight - (int) (parentHeight * bottomPaddingFraction);
     }
 
-    textWidth = textRight - textLeft;
-
     // Update the derived drawing variables.
     this.textLayout = new StaticLayout(cueText, textPaint, textWidth, textAlignment, spacingMult,
         spacingAdd, true);
     this.textLeft = textLeft;
     this.textTop = textTop;
     this.textPaddingX = textPaddingX;
+  }
 
-    drawLayout(canvas);
+  private void setupBitmapLayout() {
+    int parentWidth = parentRight - parentLeft;
+    int parentHeight = parentBottom - parentTop;
+    float anchorX = parentLeft + (parentWidth * cuePosition);
+    float anchorY = parentTop + (parentHeight * cueLine);
+    int width = Math.round(parentWidth * cueSize);
+    int height = Math.round(width * ((float) cueBitmap.getHeight() / cueBitmap.getWidth()));
+    int x = Math.round(cueLineAnchor == Cue.ANCHOR_TYPE_END ? (anchorX - width)
+        : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorX - (width / 2)) : anchorX);
+    int y = Math.round(cuePositionAnchor == Cue.ANCHOR_TYPE_END ? (anchorY - height)
+        : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorY - (height / 2)) : anchorY);
+    bitmapRect = new Rect(x, y, x + width, y + height);
   }
 
-  /**
-   * Draws {@link #textLayout} into the provided canvas.
-   *
-   * @param canvas The canvas into which to draw.
-   */
-  private void drawLayout(Canvas canvas) {
-    final StaticLayout layout = textLayout;
+  private void drawLayout(Canvas canvas, boolean isTextCue) {
+    if (isTextCue) {
+      drawTextLayout(canvas);
+    } else {
+      drawBitmapLayout(canvas);
+    }
+  }
+
+  private void drawTextLayout(Canvas canvas) {
+    StaticLayout layout = textLayout;
     if (layout == null) {
       // Nothing to draw.
       return;
@@ -343,6 +387,10 @@ private void drawLayout(Canvas canvas) {
     canvas.restoreToCount(saveCount);
   }
 
+  private void drawBitmapLayout(Canvas canvas) {
+    canvas.drawBitmap(cueBitmap, null, bitmapRect, null);
+  }
+
   /**
    * This method is used instead of {@link TextUtils#equals(CharSequence, CharSequence)} because the
    * latter only checks the text of each sequence, and does not check for equality of styling that
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
index 0ddf17cbe9..4a2354e180 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSource.java
@@ -65,7 +65,7 @@
    * @param buffer The buffer into which the read data should be stored.
    * @param offset The start offset into {@code buffer} at which data should be written.
    * @param readLength The maximum number of bytes to read.
-   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if no data is avaliable
+   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if no data is available
    *     because the end of the opened range has been reached.
    * @throws IOException If an error occurs reading from the source.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index d251446976..d3c63b4454 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -32,7 +32,7 @@
    * The flags that apply to any request for data.
    */
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_ALLOW_GZIP})
+  @IntDef(flag = true, value = {FLAG_ALLOW_GZIP, FLAG_ALLOW_CACHING_UNKNOWN_LENGTH})
   public @interface Flags {}
   /**
    * Permits an underlying network stack to request that the server use gzip compression.
@@ -45,7 +45,12 @@
    * {@link DataSource#open(DataSpec)} will typically be {@link C#LENGTH_UNSET}. The data read from
    * {@link DataSource#read(byte[], int, int)} will be the decompressed data.
    */
-  public static final int FLAG_ALLOW_GZIP = 1;
+  public static final int FLAG_ALLOW_GZIP = 1 << 0;
+
+  /**
+   * Permits content to be cached even if its length can not be resolved.
+   */
+  public static final int FLAG_ALLOW_CACHING_UNKNOWN_LENGTH = 1 << 1;
 
   /**
    * The source from which data should be read.
@@ -76,10 +81,10 @@
    */
   public final String key;
   /**
-   * Request flags. Currently {@link #FLAG_ALLOW_GZIP} is the only supported flag.
+   * Request flags. Currently {@link #FLAG_ALLOW_GZIP} and
+   * {@link #FLAG_ALLOW_CACHING_UNKNOWN_LENGTH} are the only supported flags.
    */
-  @Flags
-  public final int flags;
+  @Flags public final int flags;
 
   /**
    * Construct a {@link DataSpec} for the given uri and with {@link #key} set to null.
@@ -167,6 +172,15 @@ public DataSpec(Uri uri, byte[] postBody, long absoluteStreamPosition, long posi
     this.flags = flags;
   }
 
+  /**
+   * Returns whether the given flag is set.
+   *
+   * @param flag Flag to be checked if it is set.
+   */
+  public boolean isFlagSet(@Flags int flag) {
+    return (this.flags & flag) == flag;
+  }
+
   @Override
   public String toString() {
     return "DataSpec[" + uri + ", " + Arrays.toString(postBody) + ", " + absoluteStreamPosition
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index ae6f1e0691..9d13383a56 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -81,7 +81,7 @@ public DefaultDataSource(Context context, TransferListener<? super DataSource> l
       boolean allowCrossProtocolRedirects) {
     this(context, listener,
         new DefaultHttpDataSource(userAgent, null, listener, connectTimeoutMillis,
-            readTimeoutMillis, allowCrossProtocolRedirects));
+            readTimeoutMillis, allowCrossProtocolRedirects, null));
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index b326c41b18..599cdddeb9 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -32,7 +32,6 @@
 import java.net.NoRouteToHostException;
 import java.net.ProtocolException;
 import java.net.URL;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
@@ -44,8 +43,8 @@
  * <p>
  * By default this implementation will not follow cross-protocol redirects (i.e. redirects from
  * HTTP to HTTPS or vice versa). Cross-protocol redirects can be enabled by using the
- * {@link #DefaultHttpDataSource(String, Predicate, TransferListener, int, int, boolean)}
- * constructor and passing {@code true} as the final argument.
+ * {@link #DefaultHttpDataSource(String, Predicate, TransferListener, int, int, boolean,
+ * RequestProperties)} constructor and passing {@code true} as the second last argument.
  */
 public class DefaultHttpDataSource implements HttpDataSource {
 
@@ -70,7 +69,8 @@
   private final int readTimeoutMillis;
   private final String userAgent;
   private final Predicate<String> contentTypePredicate;
-  private final HashMap<String, String> requestProperties;
+  private final RequestProperties defaultRequestProperties;
+  private final RequestProperties requestProperties;
   private final TransferListener<? super DefaultHttpDataSource> listener;
 
   private DataSpec dataSpec;
@@ -121,7 +121,8 @@ public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePred
   public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
       TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
       int readTimeoutMillis) {
-    this(userAgent, contentTypePredicate, listener, connectTimeoutMillis, readTimeoutMillis, false);
+    this(userAgent, contentTypePredicate, listener, connectTimeoutMillis, readTimeoutMillis, false,
+        null);
   }
 
   /**
@@ -137,17 +138,21 @@ public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePred
    *     as an infinite timeout. Pass {@link #DEFAULT_READ_TIMEOUT_MILLIS} to use the default value.
    * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
    *     to HTTPS and vice versa) are enabled.
+   * @param defaultRequestProperties The default request properties to be sent to the server as
+   *     HTTP headers or {@code null} if not required.
    */
   public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
       TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
-      int readTimeoutMillis, boolean allowCrossProtocolRedirects) {
+      int readTimeoutMillis, boolean allowCrossProtocolRedirects,
+      RequestProperties defaultRequestProperties) {
     this.userAgent = Assertions.checkNotEmpty(userAgent);
     this.contentTypePredicate = contentTypePredicate;
     this.listener = listener;
-    this.requestProperties = new HashMap<>();
+    this.requestProperties = new RequestProperties();
     this.connectTimeoutMillis = connectTimeoutMillis;
     this.readTimeoutMillis = readTimeoutMillis;
     this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;
+    this.defaultRequestProperties = defaultRequestProperties;
   }
 
   @Override
@@ -164,24 +169,18 @@ public Uri getUri() {
   public void setRequestProperty(String name, String value) {
     Assertions.checkNotNull(name);
     Assertions.checkNotNull(value);
-    synchronized (requestProperties) {
-      requestProperties.put(name, value);
-    }
+    requestProperties.set(name, value);
   }
 
   @Override
   public void clearRequestProperty(String name) {
     Assertions.checkNotNull(name);
-    synchronized (requestProperties) {
-      requestProperties.remove(name);
-    }
+    requestProperties.remove(name);
   }
 
   @Override
   public void clearAllRequestProperties() {
-    synchronized (requestProperties) {
-      requestProperties.clear();
-    }
+    requestProperties.clear();
   }
 
   @Override
@@ -230,7 +229,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
 
     // Determine the length of the data to be read, after skipping.
-    if ((dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) == 0) {
+    if (!dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP)) {
       if (dataSpec.length != C.LENGTH_UNSET) {
         bytesToRead = dataSpec.length;
       } else {
@@ -343,7 +342,7 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     byte[] postBody = dataSpec.postBody;
     long position = dataSpec.position;
     long length = dataSpec.length;
-    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+    boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);
 
     if (!allowCrossProtocolRedirects) {
       // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
@@ -394,11 +393,14 @@ private HttpURLConnection makeConnection(URL url, byte[] postBody, long position
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setConnectTimeout(connectTimeoutMillis);
     connection.setReadTimeout(readTimeoutMillis);
-    synchronized (requestProperties) {
-      for (Map.Entry<String, String> property : requestProperties.entrySet()) {
+    if (defaultRequestProperties != null) {
+      for (Map.Entry<String, String> property : defaultRequestProperties.getSnapshot().entrySet()) {
         connection.setRequestProperty(property.getKey(), property.getValue());
       }
     }
+    for (Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {
+      connection.setRequestProperty(property.getKey(), property.getValue());
+    }
     if (!(position == 0 && length == C.LENGTH_UNSET)) {
       String rangeRequest = "bytes=" + position + "-";
       if (length != C.LENGTH_UNSET) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
index dcfed59145..3b3a5a1c16 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.java
@@ -15,10 +15,11 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import com.google.android.exoplayer2.upstream.HttpDataSource.BaseFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 
 /** A {@link Factory} that produces {@link DefaultHttpDataSource} instances. */
-public final class DefaultHttpDataSourceFactory implements Factory {
+public final class DefaultHttpDataSourceFactory extends BaseFactory {
 
   private final String userAgent;
   private final TransferListener<? super DataSource> listener;
@@ -75,8 +76,10 @@ public DefaultHttpDataSourceFactory(String userAgent,
   }
 
   @Override
-  public DefaultHttpDataSource createDataSource() {
+  protected DefaultHttpDataSource createDataSourceInternal(
+      HttpDataSource.RequestProperties defaultRequestProperties) {
     return new DefaultHttpDataSource(userAgent, null, listener, connectTimeoutMillis,
-        readTimeoutMillis, allowCrossProtocolRedirects);
+        readTimeoutMillis, allowCrossProtocolRedirects, defaultRequestProperties);
   }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
index f915ee4e24..3725fc0052 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/HttpDataSource.java
@@ -22,6 +22,8 @@
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -38,6 +40,175 @@
     @Override
     HttpDataSource createDataSource();
 
+    /**
+     * Gets the default request properties used by all {@link HttpDataSource}s created by the
+     * factory. Changes to the properties will be reflected in any future requests made by
+     * {@link HttpDataSource}s created by the factory.
+     *
+     * @return The default request properties of the factory.
+     */
+    RequestProperties getDefaultRequestProperties();
+
+    /**
+     * Sets a default request header for {@link HttpDataSource} instances created by the factory.
+     *
+     * @deprecated Use {@link #getDefaultRequestProperties} instead.
+     * @param name The name of the header field.
+     * @param value The value of the field.
+     */
+    @Deprecated
+    void setDefaultRequestProperty(String name, String value);
+
+    /**
+     * Clears a default request header for {@link HttpDataSource} instances created by the factory.
+     *
+     * @deprecated Use {@link #getDefaultRequestProperties} instead.
+     * @param name The name of the header field.
+     */
+    @Deprecated
+    void clearDefaultRequestProperty(String name);
+
+    /**
+     * Clears all default request headers for all {@link HttpDataSource} instances created by the
+     * factory.
+     *
+     * @deprecated Use {@link #getDefaultRequestProperties} instead.
+     */
+    @Deprecated
+    void clearAllDefaultRequestProperties();
+
+  }
+
+  /**
+   * Stores HTTP request properties (aka HTTP headers) and provides methods to modify the headers
+   * in a thread safe way to avoid the potential of creating snapshots of an inconsistent or
+   * unintended state.
+   */
+  final class RequestProperties {
+
+    private final Map<String, String> requestProperties;
+    private Map<String, String> requestPropertiesSnapshot;
+
+    public RequestProperties() {
+      requestProperties = new HashMap<>();
+    }
+
+    /**
+     * Sets the specified property {@code value} for the specified {@code name}. If a property for
+     * this name previously existed, the old value is replaced by the specified value.
+     *
+     * @param name The name of the request property.
+     * @param value The value of the request property.
+     */
+    public synchronized void set(String name, String value) {
+      requestPropertiesSnapshot = null;
+      requestProperties.put(name, value);
+    }
+
+    /**
+     * Sets the keys and values contained in the map. If a property previously existed, the old
+     * value is replaced by the specified value. If a property previously existed and is not in the
+     * map, the property is left unchanged.
+     *
+     * @param properties The request properties.
+     */
+    public synchronized void set(Map<String, String> properties) {
+      requestPropertiesSnapshot = null;
+      requestProperties.putAll(properties);
+    }
+
+    /**
+     * Removes all properties previously existing and sets the keys and values of the map.
+     *
+     * @param properties The request properties.
+     */
+    public synchronized void clearAndSet(Map<String, String> properties) {
+      requestPropertiesSnapshot = null;
+      requestProperties.clear();
+      requestProperties.putAll(properties);
+    }
+
+    /**
+     * Removes a request property by name.
+     *
+     * @param name The name of the request property to remove.
+     */
+    public synchronized void remove(String name) {
+      requestPropertiesSnapshot = null;
+      requestProperties.remove(name);
+    }
+
+    /**
+     * Clears all request properties.
+     */
+    public synchronized void clear() {
+      requestPropertiesSnapshot = null;
+      requestProperties.clear();
+    }
+
+    /**
+     * Gets a snapshot of the request properties.
+     *
+     * @return A snapshot of the request properties.
+     */
+    public synchronized Map<String, String> getSnapshot() {
+      if (requestPropertiesSnapshot == null) {
+        requestPropertiesSnapshot = Collections.unmodifiableMap(new HashMap<>(requestProperties));
+      }
+      return requestPropertiesSnapshot;
+    }
+
+  }
+
+  /**
+   * Base implementation of {@link Factory} that sets default request properties.
+   */
+  abstract class BaseFactory implements Factory {
+
+    private final RequestProperties defaultRequestProperties;
+
+    public BaseFactory() {
+      defaultRequestProperties = new RequestProperties();
+    }
+
+    @Override
+    public final HttpDataSource createDataSource() {
+      return createDataSourceInternal(defaultRequestProperties);
+    }
+
+    @Override
+    public final RequestProperties getDefaultRequestProperties() {
+      return defaultRequestProperties;
+    }
+
+    @Deprecated
+    @Override
+    public final void setDefaultRequestProperty(String name, String value) {
+      defaultRequestProperties.set(name, value);
+    }
+
+    @Deprecated
+    @Override
+    public final void clearDefaultRequestProperty(String name) {
+      defaultRequestProperties.remove(name);
+    }
+
+    @Deprecated
+    @Override
+    public final void clearAllDefaultRequestProperties() {
+      defaultRequestProperties.clear();
+    }
+
+    /**
+     * Called by {@link #createDataSource()} to create a {@link HttpDataSource} instance.
+     *
+     * @param defaultRequestProperties The default {@code RequestProperties} to be used by the
+     *     {@link HttpDataSource} instance.
+     * @return A {@link HttpDataSource} instance.
+     */
+    protected abstract HttpDataSource createDataSourceInternal(RequestProperties
+        defaultRequestProperties);
+
   }
 
   /**
@@ -67,8 +238,7 @@ public boolean evaluate(String contentType) {
     public static final int TYPE_READ = 2;
     public static final int TYPE_CLOSE = 3;
 
-    @Type
-    public final int type;
+    @Type public final int type;
 
     /**
      * The {@link DataSpec} associated with the current connection.
@@ -150,7 +320,7 @@ public InvalidResponseCodeException(int responseCode, Map<String, List<String>>
   int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException;
 
   /**
-   * Sets the value of a request header field. The value will be used for subsequent connections
+   * Sets the value of a request header. The value will be used for subsequent connections
    * established by the source.
    *
    * @param name The name of the header field.
@@ -159,7 +329,7 @@ public InvalidResponseCodeException(int responseCode, Map<String, List<String>>
   void setRequestProperty(String name, String value);
 
   /**
-   * Clears the value of a request header field. The change will apply to subsequent connections
+   * Clears the value of a request header. The change will apply to subsequent connections
    * established by the source.
    *
    * @param name The name of the header field.
@@ -167,7 +337,7 @@ public InvalidResponseCodeException(int responseCode, Map<String, List<String>>
   void clearRequestProperty(String name);
 
   /**
-   * Clears all request header fields that were set by {@link #setRequestProperty(String, String)}.
+   * Clears all request headers that were set by {@link #setRequestProperty(String, String)}.
    */
   void clearAllRequestProperties();
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java b/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
index 6f0637b334..e66901975f 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
@@ -199,7 +199,7 @@ public void release(Runnable postLoadAction) {
       currentTask.cancel(true);
     }
     if (postLoadAction != null) {
-      downloadExecutorService.submit(postLoadAction);
+      downloadExecutorService.execute(postLoadAction);
     }
     downloadExecutorService.shutdown();
   }
@@ -260,7 +260,7 @@ public void start(long delayMillis) {
       if (delayMillis > 0) {
         sendEmptyMessageDelayed(MSG_START, delayMillis);
       } else {
-        submitToExecutor();
+        execute();
       }
     }
 
@@ -337,7 +337,7 @@ public void handleMessage(Message msg) {
         return;
       }
       if (msg.what == MSG_START) {
-        submitToExecutor();
+        execute();
         return;
       }
       if (msg.what == MSG_FATAL_ERROR) {
@@ -370,9 +370,9 @@ public void handleMessage(Message msg) {
       }
     }
 
-    private void submitToExecutor() {
+    private void execute() {
       currentError = null;
-      downloadExecutorService.submit(currentTask);
+      downloadExecutorService.execute(currentTask);
     }
 
     private void finish() {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
index c23b609704..c25638ac86 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -114,7 +115,7 @@ public final void load() throws IOException, InterruptedException {
       result = parser.parse(dataSource.getUri(), inputStream);
     } finally {
       bytesLoaded = inputStream.bytesRead();
-      inputStream.close();
+      Util.closeQuietly(inputStream);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSourceFactory.java b/library/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSourceFactory.java
new file mode 100644
index 0000000000..daad41a9a6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSourceFactory.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream;
+
+import com.google.android.exoplayer2.upstream.DataSource.Factory;
+import com.google.android.exoplayer2.util.PriorityTaskManager;
+
+/**
+ * A {@link DataSource.Factory} that produces {@link PriorityDataSource} instances.
+ */
+public final class PriorityDataSourceFactory implements Factory {
+
+  private final Factory upstreamFactory;
+  private final PriorityTaskManager priorityTaskManager;
+  private final int priority;
+
+  /**
+   * @param upstreamFactory A {@link DataSource.Factory} to be used to create an upstream {@link
+   *     DataSource} for {@link PriorityDataSource}.
+   * @param priorityTaskManager The priority manager to which PriorityDataSource task is registered.
+   * @param priority The priority of PriorityDataSource task.
+   */
+  public PriorityDataSourceFactory(Factory upstreamFactory, PriorityTaskManager priorityTaskManager,
+      int priority) {
+    this.upstreamFactory = upstreamFactory;
+    this.priorityTaskManager = priorityTaskManager;
+    this.priority = priority;
+  }
+
+  @Override
+  public PriorityDataSource createDataSource() {
+    return new PriorityDataSource(upstreamFactory.createDataSource(), priorityTaskManager,
+        priority);
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
index 8dcfe75670..86ff810142 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
@@ -198,6 +198,18 @@ public CacheException(IOException cause) {
   */
   boolean isCached(String key, long position, long length);
 
+  /**
+   * Returns the length of the cached data block starting from the {@code position} to the block end
+   * up to {@code length} bytes. If the {@code position} isn't cached then -(the length of the gap
+   * to the next cached data up to {@code length} bytes) is returned.
+   *
+   * @param key The cache key for the data.
+   * @param position The starting position of the data.
+   * @param length The maximum length of the data to be returned.
+   * @return the length of the cached or not cached data block length.
+   */
+  long getCachedBytes(String key, long position, long length);
+
   /**
    * Sets the content length for the given key.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index d57f3ee140..33b1ca58b0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -32,6 +32,9 @@
  */
 public final class CacheDataSink implements DataSink {
 
+  /** Default buffer size. */
+  public static final int DEFAULT_BUFFER_SIZE = 20480;
+
   private final Cache cache;
   private final long maxCacheFileSize;
   private final int bufferSize;
@@ -56,13 +59,15 @@ public CacheDataSinkException(IOException cause) {
   }
 
   /**
+   * Constructs a CacheDataSink using the {@link #DEFAULT_BUFFER_SIZE}.
+   *
    * @param cache The cache into which data should be written.
    * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for
    *    a {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
    *    multiple cache files.
    */
   public CacheDataSink(Cache cache, long maxCacheFileSize) {
-    this(cache, maxCacheFileSize, 0);
+    this(cache, maxCacheFileSize, DEFAULT_BUFFER_SIZE);
   }
 
   /**
@@ -81,10 +86,12 @@ public CacheDataSink(Cache cache, long maxCacheFileSize, int bufferSize) {
 
   @Override
   public void open(DataSpec dataSpec) throws CacheDataSinkException {
-    this.dataSpec = dataSpec;
-    if (dataSpec.length == C.LENGTH_UNSET) {
+    if (dataSpec.length == C.LENGTH_UNSET
+        && !dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH)) {
+      this.dataSpec = null;
       return;
     }
+    this.dataSpec = dataSpec;
     dataSpecBytesWritten = 0;
     try {
       openNextOutputStream();
@@ -95,7 +102,7 @@ public void open(DataSpec dataSpec) throws CacheDataSinkException {
 
   @Override
   public void write(byte[] buffer, int offset, int length) throws CacheDataSinkException {
-    if (dataSpec.length == C.LENGTH_UNSET) {
+    if (dataSpec == null) {
       return;
     }
     try {
@@ -119,7 +126,7 @@ public void write(byte[] buffer, int offset, int length) throws CacheDataSinkExc
 
   @Override
   public void close() throws CacheDataSinkException {
-    if (dataSpec == null || dataSpec.length == C.LENGTH_UNSET) {
+    if (dataSpec == null) {
       return;
     }
     try {
@@ -130,8 +137,10 @@ public void close() throws CacheDataSinkException {
   }
 
   private void openNextOutputStream() throws IOException {
+    long maxLength = dataSpec.length == C.LENGTH_UNSET ? maxCacheFileSize
+        : Math.min(dataSpec.length - dataSpecBytesWritten, maxCacheFileSize);
     file = cache.startFile(dataSpec.key, dataSpec.absoluteStreamPosition + dataSpecBytesWritten,
-        Math.min(dataSpec.length - dataSpecBytesWritten, maxCacheFileSize));
+        maxLength);
     underlyingFileOutputStream = new FileOutputStream(file);
     if (bufferSize > 0) {
       if (bufferedOutputStream == null) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
index 0c8c006e2c..0b9ab66508 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
@@ -24,18 +24,27 @@
 
   private final Cache cache;
   private final long maxCacheFileSize;
+  private final int bufferSize;
 
   /**
    * @see CacheDataSink#CacheDataSink(Cache, long)
    */
   public CacheDataSinkFactory(Cache cache, long maxCacheFileSize) {
+    this(cache, maxCacheFileSize, CacheDataSink.DEFAULT_BUFFER_SIZE);
+  }
+
+  /**
+   * @see CacheDataSink#CacheDataSink(Cache, long, int)
+   */
+  public CacheDataSinkFactory(Cache cache, long maxCacheFileSize, int bufferSize) {
     this.cache = cache;
     this.maxCacheFileSize = maxCacheFileSize;
+    this.bufferSize = bufferSize;
   }
 
   @Override
   public DataSink createDataSink() {
-    return new CacheDataSink(cache, maxCacheFileSize);
+    return new CacheDataSink(cache, maxCacheFileSize, bufferSize);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index 4dc5431b47..a2e4382e0c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSource;
@@ -89,7 +90,7 @@
   private final DataSource cacheReadDataSource;
   private final DataSource cacheWriteDataSource;
   private final DataSource upstreamDataSource;
-  private final EventListener eventListener;
+  @Nullable private final EventListener eventListener;
 
   private final boolean blockOnCache;
   private final boolean ignoreCacheOnError;
@@ -142,13 +143,14 @@ public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags,
    * @param cache The cache.
    * @param upstream A {@link DataSource} for reading data not in the cache.
    * @param cacheReadDataSource A {@link DataSource} for reading data from the cache.
-   * @param cacheWriteDataSink A {@link DataSink} for writing data to the cache.
+   * @param cacheWriteDataSink A {@link DataSink} for writing data to the cache. If null, cache is
+   *     accessed read-only.
    * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE} and {@link
    *     #FLAG_IGNORE_CACHE_ON_ERROR} or 0.
    * @param eventListener An optional {@link EventListener} to receive events.
    */
   public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDataSource,
-      DataSink cacheWriteDataSink, @Flags int flags, EventListener eventListener) {
+      DataSink cacheWriteDataSink, @Flags int flags, @Nullable EventListener eventListener) {
     this.cache = cache;
     this.cacheReadDataSource = cacheReadDataSource;
     this.blockOnCache = (flags & FLAG_BLOCK_ON_CACHE) != 0;
@@ -283,7 +285,6 @@ private boolean openNextSource(boolean initial) throws IOException {
       currentDataSource = cacheReadDataSource;
     } else {
       // Data is not cached, and data is not locked, read from upstream with cache backing.
-      lockedSpan = span;
       long length;
       if (span.isOpenEnded()) {
         length = bytesRemaining;
@@ -294,8 +295,13 @@ private boolean openNextSource(boolean initial) throws IOException {
         }
       }
       dataSpec = new DataSpec(uri, readPosition, length, key, flags);
-      currentDataSource = cacheWriteDataSource != null ? cacheWriteDataSource
-          : upstreamDataSource;
+      if (cacheWriteDataSource != null) {
+        currentDataSource = cacheWriteDataSource;
+        lockedSpan = span;
+      } else {
+        currentDataSource = upstreamDataSource;
+        cache.releaseHoleSpan(span);
+      }
     }
 
     currentRequestUnbounded = dataSpec.length == C.LENGTH_UNSET;
@@ -330,16 +336,16 @@ private boolean openNextSource(boolean initial) throws IOException {
     // bytesRemaining == C.LENGTH_UNSET) and got a resolved length from open() request
     if (currentRequestUnbounded && currentBytesRemaining != C.LENGTH_UNSET) {
       bytesRemaining = currentBytesRemaining;
-      // If writing into cache
-      if (lockedSpan != null) {
-        setContentLength(dataSpec.position + bytesRemaining);
-      }
+      setContentLength(dataSpec.position + bytesRemaining);
     }
     return successful;
   }
 
   private void setContentLength(long length) throws IOException {
-    cache.setContentLength(key, length);
+    // If writing into cache
+    if (currentDataSource == cacheWriteDataSource) {
+      cache.setContentLength(key, length);
+    }
   }
 
   private void closeCurrentSource() throws IOException {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
index 125bec5fdc..b6fa3b4e2c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
@@ -65,10 +65,11 @@ public CacheDataSourceFactory(Cache cache, Factory upstreamFactory,
   }
 
   @Override
-  public DataSource createDataSource() {
+  public CacheDataSource createDataSource() {
     return new CacheDataSource(cache, upstreamFactory.createDataSource(),
         cacheReadDataSourceFactory.createDataSource(),
-        cacheWriteDataSinkFactory.createDataSink(), flags, eventListener);
+        cacheWriteDataSinkFactory != null ? cacheWriteDataSinkFactory.createDataSink() : null,
+        flags, eventListener);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
index c744a176ad..fb59d23666 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
@@ -106,43 +106,49 @@ public void addSpan(SimpleCacheSpan span) {
    * which defines the maximum extents of the hole in the cache.
    */
   public SimpleCacheSpan getSpan(long position) {
-    SimpleCacheSpan span = getSpanInternal(position);
-    if (!span.isCached) {
-      SimpleCacheSpan ceilEntry = cachedSpans.ceiling(span);
-      return ceilEntry == null ? SimpleCacheSpan.createOpenHole(key, position)
-          : SimpleCacheSpan.createClosedHole(key, position, ceilEntry.position - position);
+    SimpleCacheSpan lookupSpan = SimpleCacheSpan.createLookup(key, position);
+    SimpleCacheSpan floorSpan = cachedSpans.floor(lookupSpan);
+    if (floorSpan != null && floorSpan.position + floorSpan.length > position) {
+      return floorSpan;
     }
-    return span;
+    SimpleCacheSpan ceilSpan = cachedSpans.ceiling(lookupSpan);
+    return ceilSpan == null ? SimpleCacheSpan.createOpenHole(key, position)
+        : SimpleCacheSpan.createClosedHole(key, position, ceilSpan.position - position);
   }
 
-  /** Queries if a range is entirely available in the cache. */
-  public boolean isCached(long position, long length) {
-    SimpleCacheSpan floorSpan = getSpanInternal(position);
-    if (!floorSpan.isCached) {
+  /**
+   * Returns the length of the cached data block starting from the {@code position} to the block end
+   * up to {@code length} bytes. If the {@code position} isn't cached then -(the length of the gap
+   * to the next cached data up to {@code length} bytes) is returned.
+   *
+   * @param position The starting position of the data.
+   * @param length The maximum length of the data to be returned.
+   * @return the length of the cached or not cached data block length.
+   */
+  public long getCachedBytes(long position, long length) {
+    SimpleCacheSpan span = getSpan(position);
+    if (span.isHoleSpan()) {
       // We don't have a span covering the start of the queried region.
-      return false;
+      return -Math.min(span.isOpenEnded() ? Long.MAX_VALUE : span.length, length);
     }
     long queryEndPosition = position + length;
-    long currentEndPosition = floorSpan.position + floorSpan.length;
-    if (currentEndPosition >= queryEndPosition) {
-      // floorSpan covers the queried region.
-      return true;
-    }
-    for (SimpleCacheSpan next : cachedSpans.tailSet(floorSpan, false)) {
-      if (next.position > currentEndPosition) {
-        // There's a hole in the cache within the queried region.
-        return false;
-      }
-      // We expect currentEndPosition to always equal (next.position + next.length), but
-      // perform a max check anyway to guard against the existence of overlapping spans.
-      currentEndPosition = Math.max(currentEndPosition, next.position + next.length);
-      if (currentEndPosition >= queryEndPosition) {
-        // We've found spans covering the queried region.
-        return true;
+    long currentEndPosition = span.position + span.length;
+    if (currentEndPosition < queryEndPosition) {
+      for (SimpleCacheSpan next : cachedSpans.tailSet(span, false)) {
+        if (next.position > currentEndPosition) {
+          // There's a hole in the cache within the queried region.
+          break;
+        }
+        // We expect currentEndPosition to always equal (next.position + next.length), but
+        // perform a max check anyway to guard against the existence of overlapping spans.
+        currentEndPosition = Math.max(currentEndPosition, next.position + next.length);
+        if (currentEndPosition >= queryEndPosition) {
+          // We've found spans covering the queried region.
+          break;
+        }
       }
     }
-    // We ran out of spans before covering the queried region.
-    return false;
+    return Math.min(currentEndPosition - position, length);
   }
 
   /**
@@ -190,15 +196,4 @@ public int headerHashCode() {
     return result;
   }
 
-  /**
-   * Returns the span containing the position. If there isn't one, it returns the lookup span it
-   * used for searching.
-   */
-  private SimpleCacheSpan getSpanInternal(long position) {
-    SimpleCacheSpan lookupSpan = SimpleCacheSpan.createLookup(key, position);
-    SimpleCacheSpan floorSpan = cachedSpans.floor(lookupSpan);
-    return floorSpan == null || floorSpan.position + floorSpan.length <= position ? lookupSpan
-        : floorSpan;
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
index 9e38dabc31..58cc70d68d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
@@ -67,14 +67,25 @@
   private boolean changed;
   private ReusableBufferedOutputStream bufferedOutputStream;
 
-  /** Creates a CachedContentIndex which works on the index file in the given cacheDir. */
+  /**
+   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
+   *
+   * @param cacheDir Directory where the index file is kept.
+   */
   public CachedContentIndex(File cacheDir) {
     this(cacheDir, null);
   }
 
-  /** Creates a CachedContentIndex which works on the index file in the given cacheDir. */
+  /**
+   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
+   *
+   * @param cacheDir Directory where the index file is kept.
+   * @param secretKey If not null, cache keys will be stored encrypted on filesystem using AES/CBC.
+   *     The key must be 16 bytes long.
+   */
   public CachedContentIndex(File cacheDir, byte[] secretKey) {
     if (secretKey != null) {
+      Assertions.checkArgument(secretKey.length == 16);
       try {
         cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
         secretKeySpec = new SecretKeySpec(secretKey, "AES");
@@ -302,6 +313,9 @@ private void writeFile() throws CacheException {
       }
       output.writeInt(hashCode);
       atomicFile.endWrite(output);
+      // Avoid calling close twice. Duplicate CipherOutputStream.close calls did
+      // not used to be no-ops: https://android-review.googlesource.com/#/c/272799/
+      output = null;
     } catch (IOException e) {
       throw new CacheException(e);
     } finally {
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
new file mode 100644
index 0000000000..0f08ca40f2
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import android.util.Log;
+import com.google.android.exoplayer2.extractor.ChunkIndex;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.NavigableSet;
+import java.util.TreeSet;
+
+/**
+ * Utility class for efficiently tracking regions of data that are stored in a {@link Cache}
+ * for a given cache key.
+ */
+public final class CachedRegionTracker implements Cache.Listener {
+
+  private static final String TAG = "CachedRegionTracker";
+
+  public static final int NOT_CACHED = -1;
+  public static final int CACHED_TO_END = -2;
+
+  private final Cache cache;
+  private final String cacheKey;
+  private final ChunkIndex chunkIndex;
+
+  private final TreeSet<Region> regions;
+  private final Region lookupRegion;
+
+  public CachedRegionTracker(Cache cache, String cacheKey, ChunkIndex chunkIndex) {
+    this.cache = cache;
+    this.cacheKey = cacheKey;
+    this.chunkIndex = chunkIndex;
+    this.regions = new TreeSet<>();
+    this.lookupRegion = new Region(0, 0);
+
+    synchronized (this) {
+      NavigableSet<CacheSpan> cacheSpans = cache.addListener(cacheKey, this);
+      if (cacheSpans != null) {
+        // Merge the spans into regions. mergeSpan is more efficient when merging from high to low,
+        // which is why a descending iterator is used here.
+        Iterator<CacheSpan> spanIterator = cacheSpans.descendingIterator();
+        while (spanIterator.hasNext()) {
+          CacheSpan span = spanIterator.next();
+          mergeSpan(span);
+        }
+      }
+    }
+  }
+
+  public void release() {
+    cache.removeListener(cacheKey, this);
+  }
+
+  /**
+   * When provided with a byte offset, this method locates the cached region within which the
+   * offset falls, and returns the approximate end position in milliseconds of that region. If the
+   * byte offset does not fall within a cached region then {@link #NOT_CACHED} is returned.
+   * If the cached region extends to the end of the stream, {@link #CACHED_TO_END} is returned.
+   *
+   * @param byteOffset The byte offset in the underlying stream.
+   * @return The end position of the corresponding cache region, {@link #NOT_CACHED}, or
+   *     {@link #CACHED_TO_END}.
+   */
+  public synchronized int getRegionEndTimeMs(long byteOffset) {
+    lookupRegion.startOffset = byteOffset;
+    Region floorRegion = regions.floor(lookupRegion);
+    if (floorRegion == null || byteOffset > floorRegion.endOffset
+        || floorRegion.endOffsetIndex == -1) {
+      return NOT_CACHED;
+    }
+    int index = floorRegion.endOffsetIndex;
+    if (index == chunkIndex.length - 1
+        && floorRegion.endOffset == (chunkIndex.offsets[index] + chunkIndex.sizes[index])) {
+      return CACHED_TO_END;
+    }
+    long segmentFractionUs = (chunkIndex.durationsUs[index]
+        * (floorRegion.endOffset - chunkIndex.offsets[index])) / chunkIndex.sizes[index];
+    return (int) ((chunkIndex.timesUs[index] + segmentFractionUs) / 1000);
+  }
+
+  @Override
+  public synchronized void onSpanAdded(Cache cache, CacheSpan span) {
+    mergeSpan(span);
+  }
+
+  @Override
+  public synchronized void onSpanRemoved(Cache cache, CacheSpan span) {
+    Region removedRegion = new Region(span.position, span.position + span.length);
+
+    // Look up a region this span falls into.
+    Region floorRegion = regions.floor(removedRegion);
+    if (floorRegion == null) {
+      Log.e(TAG, "Removed a span we were not aware of");
+      return;
+    }
+
+    // Remove it.
+    regions.remove(floorRegion);
+
+    // Add new floor and ceiling regions, if necessary.
+    if (floorRegion.startOffset < removedRegion.startOffset) {
+      Region newFloorRegion = new Region(floorRegion.startOffset, removedRegion.startOffset);
+
+      int index = Arrays.binarySearch(chunkIndex.offsets, newFloorRegion.endOffset);
+      newFloorRegion.endOffsetIndex = index < 0 ? -index - 2 : index;
+      regions.add(newFloorRegion);
+    }
+
+    if (floorRegion.endOffset > removedRegion.endOffset) {
+      Region newCeilingRegion = new Region(removedRegion.endOffset + 1, floorRegion.endOffset);
+      newCeilingRegion.endOffsetIndex = floorRegion.endOffsetIndex;
+      regions.add(newCeilingRegion);
+    }
+  }
+
+  @Override
+  public void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan) {
+    // Do nothing.
+  }
+
+  private void mergeSpan(CacheSpan span) {
+    Region newRegion = new Region(span.position, span.position + span.length);
+    Region floorRegion = regions.floor(newRegion);
+    Region ceilingRegion = regions.ceiling(newRegion);
+    boolean floorConnects = regionsConnect(floorRegion, newRegion);
+    boolean ceilingConnects = regionsConnect(newRegion, ceilingRegion);
+
+    if (ceilingConnects) {
+      if (floorConnects) {
+        // Extend floorRegion to cover both newRegion and ceilingRegion.
+        floorRegion.endOffset = ceilingRegion.endOffset;
+        floorRegion.endOffsetIndex = ceilingRegion.endOffsetIndex;
+      } else {
+        // Extend newRegion to cover ceilingRegion. Add it.
+        newRegion.endOffset = ceilingRegion.endOffset;
+        newRegion.endOffsetIndex = ceilingRegion.endOffsetIndex;
+        regions.add(newRegion);
+      }
+      regions.remove(ceilingRegion);
+    } else if (floorConnects) {
+      // Extend floorRegion to the right to cover newRegion.
+      floorRegion.endOffset = newRegion.endOffset;
+      int index = floorRegion.endOffsetIndex;
+      while (index < chunkIndex.length - 1
+          && (chunkIndex.offsets[index + 1] <= floorRegion.endOffset)) {
+        index++;
+      }
+      floorRegion.endOffsetIndex = index;
+    } else {
+      // This is a new region.
+      int index = Arrays.binarySearch(chunkIndex.offsets, newRegion.endOffset);
+      newRegion.endOffsetIndex = index < 0 ? -index - 2 : index;
+      regions.add(newRegion);
+    }
+  }
+
+  private boolean regionsConnect(Region lower, Region upper) {
+    return lower != null && upper != null && lower.endOffset == upper.startOffset;
+  }
+
+  private static class Region implements Comparable<Region> {
+
+    /**
+     * The first byte of the region (inclusive).
+     */
+    public long startOffset;
+    /**
+     * End offset of the region (exclusive).
+     */
+    public long endOffset;
+    /**
+     * The index in chunkIndex that contains the end offset. May be -1 if the end offset comes
+     * before the start of the first media chunk (i.e. if the end offset is within the stream
+     * header).
+     */
+    public int endOffsetIndex;
+
+    public Region(long position, long endOffset) {
+      this.startOffset = position;
+      this.endOffset = endOffset;
+    }
+
+    @Override
+    public int compareTo(Region another) {
+      return startOffset < another.startOffset ? -1
+          : startOffset == another.startOffset ? 0 : 1;
+    }
+
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
index e3e887c6ed..14f006c850 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
@@ -354,7 +354,13 @@ private void notifySpanTouched(SimpleCacheSpan oldSpan, CacheSpan newSpan) {
   @Override
   public synchronized boolean isCached(String key, long position, long length) {
     CachedContent cachedContent = index.get(key);
-    return cachedContent != null && cachedContent.isCached(position, length);
+    return cachedContent != null && cachedContent.getCachedBytes(position, length) >= length;
+  }
+
+  @Override
+  public synchronized long getCachedBytes(String key, long position, long length) {
+    CachedContent cachedContent = index.get(key);
+    return cachedContent != null ? cachedContent.getCachedBytes(position, length) : -length;
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
new file mode 100644
index 0000000000..ccf9a5b3f5
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import com.google.android.exoplayer2.upstream.DataSink;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.io.IOException;
+import javax.crypto.Cipher;
+
+/**
+ * A wrapping {@link DataSink} that encrypts the data being consumed.
+ */
+public final class AesCipherDataSink implements DataSink {
+
+  private final DataSink wrappedDataSink;
+  private final byte[] secretKey;
+  private final byte[] scratch;
+
+  private AesFlushingCipher cipher;
+
+  /**
+   * Create an instance whose {@code write} methods have the side effect of overwriting the input
+   * {@code data}. Use this constructor for maximum efficiency in the case that there is no
+   * requirement for the input data arrays to remain unchanged.
+   *
+   * @param secretKey The key data.
+   * @param wrappedDataSink The wrapped {@link DataSink}.
+   */
+  public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink) {
+    this(secretKey, wrappedDataSink, null);
+  }
+
+  /**
+   * Create an instance whose {@code write} methods are free of side effects. Use this constructor
+   * when the input data arrays are required to remain unchanged.
+   *
+   * @param secretKey The key data.
+   * @param wrappedDataSink The wrapped {@link DataSink}.
+   * @param scratch Scratch space. Data is decrypted into this array before being written to the
+   *     wrapped {@link DataSink}. It should be of appropriate size for the expected writes. If a
+   *     write is larger than the size of this array the write will still succeed, but multiple
+   *     cipher calls will be required to complete the operation.
+   */
+  public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink, byte[] scratch) {
+    this.wrappedDataSink = wrappedDataSink;
+    this.secretKey = secretKey;
+    this.scratch = scratch;
+  }
+
+  @Override
+  public void open(DataSpec dataSpec) throws IOException {
+    wrappedDataSink.open(dataSpec);
+    long nonce = CryptoUtil.getFNV64Hash(dataSpec.key);
+    cipher = new AesFlushingCipher(Cipher.ENCRYPT_MODE, secretKey, nonce,
+        dataSpec.absoluteStreamPosition);
+  }
+
+  @Override
+  public void write(byte[] data, int offset, int length) throws IOException {
+    if (scratch == null) {
+      // In-place mode. Writes over the input data.
+      cipher.updateInPlace(data, offset, length);
+      wrappedDataSink.write(data, offset, length);
+    } else {
+      // Use scratch space. The original data remains intact.
+      int bytesProcessed = 0;
+      while (bytesProcessed < length) {
+        int bytesToProcess = Math.min(length - bytesProcessed, scratch.length);
+        cipher.update(data, offset + bytesProcessed, bytesToProcess, scratch, 0);
+        wrappedDataSink.write(scratch, 0, bytesToProcess);
+        bytesProcessed += bytesToProcess;
+      }
+    }
+  }
+
+  @Override
+  public void close() throws IOException {
+    cipher = null;
+    wrappedDataSink.close();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
new file mode 100644
index 0000000000..26ac3b38fa
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.io.IOException;
+import javax.crypto.Cipher;
+
+/**
+ * A {@link DataSource} that decrypts the data read from an upstream source.
+ */
+public final class AesCipherDataSource implements DataSource {
+
+  private final DataSource upstream;
+  private final byte[] secretKey;
+
+  private AesFlushingCipher cipher;
+
+  public AesCipherDataSource(byte[] secretKey, DataSource upstream) {
+    this.upstream = upstream;
+    this.secretKey = secretKey;
+  }
+
+  @Override
+  public long open(DataSpec dataSpec) throws IOException {
+    long dataLength = upstream.open(dataSpec);
+    long nonce = CryptoUtil.getFNV64Hash(dataSpec.key);
+    cipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, secretKey, nonce,
+        dataSpec.absoluteStreamPosition);
+    return dataLength;
+  }
+
+  @Override
+  public int read(byte[] data, int offset, int readLength) throws IOException {
+    if (readLength == 0) {
+      return 0;
+    }
+    int read = upstream.read(data, offset, readLength);
+    if (read == C.RESULT_END_OF_INPUT) {
+      return C.RESULT_END_OF_INPUT;
+    }
+    cipher.updateInPlace(data, offset, read);
+    return read;
+  }
+
+  @Override
+  public void close() throws IOException {
+    cipher = null;
+    upstream.close();
+  }
+
+  @Override
+  public Uri getUri() {
+    return upstream.getUri();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java
new file mode 100644
index 0000000000..e093eb3064
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+import com.google.android.exoplayer2.util.Assertions;
+import java.nio.ByteBuffer;
+import java.security.InvalidAlgorithmParameterException;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import javax.crypto.Cipher;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.ShortBufferException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * A flushing variant of a AES/CTR/NoPadding {@link Cipher}.
+ *
+ * Unlike a regular {@link Cipher}, the update methods of this class are guaranteed to process all
+ * of the bytes input (and hence output the same number of bytes).
+ */
+public final class AesFlushingCipher {
+
+  private final Cipher cipher;
+  private final int blockSize;
+  private final byte[] zerosBlock;
+  private final byte[] flushedBlock;
+
+  private int pendingXorBytes;
+
+  public AesFlushingCipher(int mode, byte[] secretKey, long nonce, long offset) {
+    try {
+      cipher = Cipher.getInstance("AES/CTR/NoPadding");
+      blockSize = cipher.getBlockSize();
+      zerosBlock = new byte[blockSize];
+      flushedBlock = new byte[blockSize];
+      long counter = offset / blockSize;
+      int startPadding = (int) (offset % blockSize);
+      cipher.init(mode, new SecretKeySpec(secretKey, cipher.getAlgorithm().split("/")[0]),
+          new IvParameterSpec(getInitializationVector(nonce, counter)));
+      if (startPadding != 0) {
+        updateInPlace(new byte[startPadding], 0, startPadding);
+      }
+    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException
+        | InvalidAlgorithmParameterException e) {
+      // Should never happen.
+      throw new RuntimeException(e);
+    }
+  }
+
+  public void updateInPlace(byte[] data, int offset, int length) {
+    update(data, offset, length, data, offset);
+  }
+
+  public void update(byte[] in, int inOffset, int length, byte[] out, int outOffset) {
+    // If we previously flushed the cipher by inputting zeros up to a block boundary, then we need
+    // to manually transform the data that actually ended the block. See the comment below for more
+    // details.
+    while (pendingXorBytes > 0) {
+      out[outOffset] = (byte) (in[inOffset] ^ flushedBlock[blockSize - pendingXorBytes]);
+      outOffset++;
+      inOffset++;
+      pendingXorBytes--;
+      length--;
+      if (length == 0) {
+        return;
+      }
+    }
+
+    // Do the bulk of the update.
+    int written = nonFlushingUpdate(in, inOffset, length, out, outOffset);
+    if (length == written) {
+      return;
+    }
+
+    // We need to finish the block to flush out the remaining bytes. We do so by inputting zeros,
+    // so that the corresponding bytes output by the cipher are those that would have been XORed
+    // against the real end-of-block data to transform it. We store these bytes so that we can
+    // perform the transformation manually in the case of a subsequent call to this method with
+    // the real data.
+    int bytesToFlush = length - written;
+    Assertions.checkState(bytesToFlush < blockSize);
+    outOffset += written;
+    pendingXorBytes = blockSize - bytesToFlush;
+    written = nonFlushingUpdate(zerosBlock, 0, pendingXorBytes, flushedBlock, 0);
+    Assertions.checkState(written == blockSize);
+    // The first part of xorBytes contains the flushed data, which we copy out. The remainder
+    // contains the bytes that will be needed for manual transformation in a subsequent call.
+    for (int i = 0; i < bytesToFlush; i++) {
+      out[outOffset++] = flushedBlock[i];
+    }
+  }
+
+  private int nonFlushingUpdate(byte[] in, int inOffset, int length, byte[] out, int outOffset) {
+    try {
+      return cipher.update(in, inOffset, length, out, outOffset);
+    } catch (ShortBufferException e) {
+      // Should never happen.
+      throw new RuntimeException(e);
+    }
+  }
+
+  private byte[] getInitializationVector(long nonce, long counter) {
+    return ByteBuffer.allocate(16).putLong(nonce).putLong(counter).array();
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java
new file mode 100644
index 0000000000..ff8841fa9c
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.crypto;
+
+/**
+ * Utility functions for the crypto package.
+ */
+/* package */ final class CryptoUtil {
+
+  private CryptoUtil() {}
+
+  /**
+   * Returns the hash value of the input as a long using the 64 bit FNV-1a hash function. The hash
+   * values produced by this function are less likely to collide than those produced by
+   * {@link #hashCode()}.
+   */
+  public static long getFNV64Hash(String input) {
+    if (input == null) {
+      return 0;
+    }
+
+    long hash = 0;
+    for (int i = 0; i < input.length(); i++) {
+      hash ^= input.charAt(i);
+      // This is equivalent to hash *= 0x100000001b3 (the FNV magic prime number).
+      hash += (hash << 1) + (hash << 4) + (hash << 5) + (hash << 7) + (hash << 8) + (hash << 40);
+    }
+    return hash;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index 84e1f42707..69d4229186 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -60,17 +60,18 @@
   public static final String AUDIO_AMR_NB = BASE_TYPE_AUDIO + "/3gpp";
   public static final String AUDIO_AMR_WB = BASE_TYPE_AUDIO + "/amr-wb";
   public static final String AUDIO_FLAC = BASE_TYPE_AUDIO + "/x-flac";
+  public static final String AUDIO_ALAC = BASE_TYPE_AUDIO + "/alac";
 
   public static final String TEXT_VTT = BASE_TYPE_TEXT + "/vtt";
 
   public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4";
   public static final String APPLICATION_WEBM = BASE_TYPE_APPLICATION + "/webm";
+  public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
   public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
   public static final String APPLICATION_CEA608 = BASE_TYPE_APPLICATION + "/cea-608";
   public static final String APPLICATION_CEA708 = BASE_TYPE_APPLICATION + "/cea-708";
   public static final String APPLICATION_SUBRIP = BASE_TYPE_APPLICATION + "/x-subrip";
   public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
-  public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
   public static final String APPLICATION_TX3G = BASE_TYPE_APPLICATION + "/x-quicktime-tx3g";
   public static final String APPLICATION_MP4VTT = BASE_TYPE_APPLICATION + "/x-mp4-vtt";
   public static final String APPLICATION_MP4CEA608 = BASE_TYPE_APPLICATION + "/x-mp4-cea-608";
@@ -79,6 +80,7 @@
   public static final String APPLICATION_PGS = BASE_TYPE_APPLICATION + "/pgs";
   public static final String APPLICATION_SCTE35 = BASE_TYPE_APPLICATION + "/x-scte35";
   public static final String APPLICATION_CAMERA_MOTION = BASE_TYPE_APPLICATION + "/x-camera-motion";
+  public static final String APPLICATION_EMSG = BASE_TYPE_APPLICATION + "/x-emsg";
 
   private MimeTypes() {}
 
@@ -216,12 +218,16 @@ public static int getTrackType(String mimeType) {
     } else if (isVideo(mimeType)) {
       return C.TRACK_TYPE_VIDEO;
     } else if (isText(mimeType) || APPLICATION_CEA608.equals(mimeType)
-        || APPLICATION_CEA708.equals(mimeType) || APPLICATION_SUBRIP.equals(mimeType)
-        || APPLICATION_TTML.equals(mimeType) || APPLICATION_TX3G.equals(mimeType)
-        || APPLICATION_MP4VTT.equals(mimeType) || APPLICATION_RAWCC.equals(mimeType)
-        || APPLICATION_VOBSUB.equals(mimeType) || APPLICATION_PGS.equals(mimeType)) {
+        || APPLICATION_CEA708.equals(mimeType) || APPLICATION_MP4CEA608.equals(mimeType)
+        || APPLICATION_SUBRIP.equals(mimeType) || APPLICATION_TTML.equals(mimeType)
+        || APPLICATION_TX3G.equals(mimeType) || APPLICATION_MP4VTT.equals(mimeType)
+        || APPLICATION_RAWCC.equals(mimeType) || APPLICATION_VOBSUB.equals(mimeType)
+        || APPLICATION_PGS.equals(mimeType)) {
       return C.TRACK_TYPE_TEXT;
-    } else if (APPLICATION_ID3.equals(mimeType)) {
+    } else if (APPLICATION_ID3.equals(mimeType)
+        || APPLICATION_EMSG.equals(mimeType)
+        || APPLICATION_SCTE35.equals(mimeType)
+        || APPLICATION_CAMERA_MOTION.equals(mimeType)) {
       return C.TRACK_TYPE_METADATA;
     } else {
       return C.TRACK_TYPE_UNKNOWN;
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java b/library/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java
index a452871afc..ab2fec0db7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java
@@ -103,7 +103,9 @@ public PpsData(int picParameterSetId, int seqParameterSetId,
     2f
   };
 
-  private static final int NAL_UNIT_TYPE_SPS = 7;
+  private static final int H264_NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
+  private static final int H264_NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
+  private static final int H265_NAL_UNIT_TYPE_PREFIX_SEI = 39;
 
   private static final Object scratchEscapePositionsLock = new Object();
 
@@ -176,7 +178,7 @@ public static void discardToSps(ByteBuffer data) {
     while (offset + 1 < length) {
       int value = data.get(offset) & 0xFF;
       if (consecutiveZeros == 3) {
-        if (value == 1 && (data.get(offset + 1) & 0x1F) == NAL_UNIT_TYPE_SPS) {
+        if (value == 1 && (data.get(offset + 1) & 0x1F) == H264_NAL_UNIT_TYPE_SPS) {
           // Copy from this NAL unit onwards to the start of the buffer.
           ByteBuffer offsetData = data.duplicate();
           offsetData.position(offset - 3);
@@ -197,6 +199,21 @@ public static void discardToSps(ByteBuffer data) {
     data.clear();
   }
 
+  /**
+   * Returns whether the NAL unit with the specified header contains supplemental enhancement
+   * information.
+   *
+   * @param mimeType The sample MIME type.
+   * @param nalUnitHeaderFirstByte The first byte of nal_unit().
+   * @return Whether the NAL unit with the specified header is an SEI NAL unit.
+   */
+  public static boolean isNalUnitSei(String mimeType, byte nalUnitHeaderFirstByte) {
+    return (MimeTypes.VIDEO_H264.equals(mimeType)
+        && (nalUnitHeaderFirstByte & 0x1F) == H264_NAL_UNIT_TYPE_SEI)
+        || (MimeTypes.VIDEO_H265.equals(mimeType)
+        && ((nalUnitHeaderFirstByte & 0x7E) >> 1) == H265_NAL_UNIT_TYPE_PREFIX_SEI);
+  }
+
   /**
    * Returns the type of the NAL unit in {@code data} that starts at {@code offset}.
    *
@@ -297,7 +314,8 @@ public static SpsData parseSpsNalUnit(byte[] nalData, int nalOffset, int nalLimi
       int frameCropRightOffset = data.readUnsignedExpGolombCodedInt();
       int frameCropTopOffset = data.readUnsignedExpGolombCodedInt();
       int frameCropBottomOffset = data.readUnsignedExpGolombCodedInt();
-      int cropUnitX, cropUnitY;
+      int cropUnitX;
+      int cropUnitY;
       if (chromaFormatIdc == 0) {
         cropUnitX = 1;
         cropUnitY = 2 - (frameMbsOnlyFlag ? 1 : 0);
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
index b8d635a053..ef4aa05cfe 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/ParsableByteArray.java
@@ -424,11 +424,24 @@ public String readString(int length) {
   }
 
   /**
-   * Reads the next {@code length} bytes as UTF-8 characters. A terminating NUL byte is ignored,
+   * Reads the next {@code length} bytes as characters in the specified {@link Charset}.
+   *
+   * @param length The number of bytes to read.
+   * @param charset The character set of the encoded characters.
+   * @return The string encoded by the bytes in the specified character set.
+   */
+  public String readString(int length, Charset charset) {
+    String result = new String(data, position, length, charset);
+    position += length;
+    return result;
+  }
+
+  /**
+   * Reads the next {@code length} bytes as UTF-8 characters. A terminating NUL byte is discarded,
    * if present.
    *
    * @param length The number of bytes to read.
-   * @return The string encoded by the bytes.
+   * @return The string, not including any terminating NUL byte.
    */
   public String readNullTerminatedString(int length) {
     if (length == 0) {
@@ -439,22 +452,31 @@ public String readNullTerminatedString(int length) {
     if (lastIndex < limit && data[lastIndex] == 0) {
       stringLength--;
     }
-    String result = new String(data, position, stringLength, Charset.defaultCharset());
+    String result = new String(data, position, stringLength);
     position += length;
     return result;
   }
 
   /**
-   * Reads the next {@code length} bytes as characters in the specified {@link Charset}.
+   * Reads up to the next NUL byte (or the limit) as UTF-8 characters.
    *
-   * @param length The number of bytes to read.
-   * @param charset The character set of the encoded characters.
-   * @return The string encoded by the bytes in the specified character set.
+   * @return The string not including any terminating NUL byte, or null if the end of the data has
+   *     already been reached.
    */
-  public String readString(int length, Charset charset) {
-    String result = new String(data, position, length, charset);
-    position += length;
-    return result;
+  public String readNullTerminatedString() {
+    if (bytesLeft() == 0) {
+      return null;
+    }
+    int stringLimit = position;
+    while (stringLimit < limit && data[stringLimit] != 0) {
+      stringLimit++;
+    }
+    String string = new String(data, position, stringLimit - position);
+    position = stringLimit;
+    if (position < limit) {
+      position++;
+    }
+    return string;
   }
 
   /**
@@ -464,15 +486,15 @@ public String readString(int length, Charset charset) {
    * ('\n'), or a carriage return followed immediately by a line feed ('\r\n'). The system's default
    * charset (UTF-8) is used.
    *
-   * @return A String containing the contents of the line, not including any line-termination
-   *     characters, or null if the end of the stream has been reached.
+   * @return The line not including any line-termination characters, or null if the end of the data
+   *     has already been reached.
    */
   public String readLine() {
     if (bytesLeft() == 0) {
       return null;
     }
     int lineLimit = position;
-    while (lineLimit < limit && data[lineLimit] != '\n' && data[lineLimit] != '\r') {
+    while (lineLimit < limit && !Util.isLinebreak(data[lineLimit])) {
       lineLimit++;
     }
     if (lineLimit - position >= 3 && data[position] == (byte) 0xEF
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java b/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java
index a3d1d4d02e..1db3d2c1f4 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStream.java
@@ -67,6 +67,7 @@ public void close() throws IOException {
   public void reset(OutputStream out) {
     Assertions.checkState(closed);
     this.out = out;
+    count = 0;
     closed = false;
   }
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java b/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
index 8b1af1f0c8..c43b1929cb 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
@@ -32,7 +32,7 @@
  * @see <a href="http://en.wikipedia.org/wiki/Moving_average">Wiki: Moving average</a>
  * @see <a href="http://en.wikipedia.org/wiki/Selection_algorithm">Wiki: Selection algorithm</a>
  */
-public final class SlidingPercentile {
+public class SlidingPercentile {
 
   // Orderings.
   private static final Comparator<Sample> INDEX_COMPARATOR = new Comparator<Sample>() {
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java b/library/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
similarity index 64%
rename from library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java
rename to library/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
index 4de4b38897..08e2bd0669 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/TimestampAdjuster.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/TimestampAdjuster.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.extractor;
+package com.google.android.exoplayer2.util;
 
 import com.google.android.exoplayer2.C;
 
@@ -34,21 +34,67 @@
    */
   private static final long MAX_PTS_PLUS_ONE = 0x200000000L;
 
-  private final long firstSampleTimestampUs;
-
+  private long firstSampleTimestampUs;
   private long timestampOffsetUs;
 
   // Volatile to allow isInitialized to be called on a different thread to adjustSampleTimestamp.
   private volatile long lastSampleTimestamp;
 
   /**
-   * @param firstSampleTimestampUs The desired result of the first call to
-   *     {@link #adjustSampleTimestamp(long)}, or {@link #DO_NOT_OFFSET} if presentation timestamps
-   *     should not be offset.
+   * @param firstSampleTimestampUs See {@link #setFirstSampleTimestampUs(long)}.
    */
   public TimestampAdjuster(long firstSampleTimestampUs) {
-    this.firstSampleTimestampUs = firstSampleTimestampUs;
     lastSampleTimestamp = C.TIME_UNSET;
+    setFirstSampleTimestampUs(firstSampleTimestampUs);
+  }
+
+  /**
+   * Sets the desired result of the first call to {@link #adjustSampleTimestamp(long)}. Can only be
+   * called before any timestamps have been adjusted.
+   *
+   * @param firstSampleTimestampUs The first adjusted sample timestamp in microseconds, or
+   *     {@link #DO_NOT_OFFSET} if presentation timestamps should not be offset.
+   */
+  public synchronized void setFirstSampleTimestampUs(long firstSampleTimestampUs) {
+    Assertions.checkState(lastSampleTimestamp == C.TIME_UNSET);
+    this.firstSampleTimestampUs = firstSampleTimestampUs;
+  }
+
+  /**
+   * Returns the first adjusted sample timestamp in microseconds.
+   *
+   * @return The first adjusted sample timestamp in microseconds.
+   */
+  public long getFirstSampleTimestampUs() {
+    return firstSampleTimestampUs;
+  }
+
+  /**
+   * Returns the last adjusted timestamp. If no timestamp has been adjusted, returns
+   * {@code firstSampleTimestampUs} as provided to the constructor. If this value is
+   * {@link #DO_NOT_OFFSET}, returns {@link C#TIME_UNSET}.
+   *
+   * @return The last adjusted timestamp. If not present, {@code firstSampleTimestampUs} is
+   *     returned unless equal to {@link #DO_NOT_OFFSET}, in which case {@link C#TIME_UNSET} is
+   *     returned.
+   */
+  public long getLastAdjustedTimestampUs() {
+    return lastSampleTimestamp != C.TIME_UNSET ? lastSampleTimestamp
+        : firstSampleTimestampUs != DO_NOT_OFFSET ? firstSampleTimestampUs : C.TIME_UNSET;
+  }
+
+  /**
+   * Returns the offset between the input of {@link #adjustSampleTimestamp(long)} and its output.
+   * If {@link #DO_NOT_OFFSET} was provided to the constructor, 0 is returned. If the timestamp
+   * adjuster is yet not initialized, {@link C#TIME_UNSET} is returned.
+   *
+   * @return The offset between {@link #adjustSampleTimestamp(long)}'s input and output.
+   *     {@link C#TIME_UNSET} if the adjuster is not yet initialized and 0 if timestamps should not
+   *     be offset.
+   */
+  public long getTimestampOffsetUs() {
+    return firstSampleTimestampUs == DO_NOT_OFFSET ? 0
+        : lastSampleTimestamp == C.TIME_UNSET ? C.TIME_UNSET : timestampOffsetUs;
   }
 
   /**
@@ -65,6 +111,9 @@ public void reset() {
    * @return The adjusted timestamp in microseconds.
    */
   public long adjustTsTimestamp(long pts) {
+    if (pts == C.TIME_UNSET) {
+      return C.TIME_UNSET;
+    }
     if (lastSampleTimestamp != C.TIME_UNSET) {
       // The wrap count for the current PTS may be closestWrapCount or (closestWrapCount - 1),
       // and we need to snap to the one closest to lastSampleTimestamp.
@@ -85,6 +134,9 @@ public long adjustTsTimestamp(long pts) {
    * @return The adjusted timestamp in microseconds.
    */
   public long adjustSampleTimestamp(long timeUs) {
+    if (timeUs == C.TIME_UNSET) {
+      return C.TIME_UNSET;
+    }
     // Record the adjusted PTS to adjust for wraparound next time.
     if (lastSampleTimestamp != C.TIME_UNSET) {
       lastSampleTimestamp = timeUs;
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
index 4477de7abb..d9282700d7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -36,6 +36,7 @@
 import com.google.android.exoplayer2.upstream.DataSpec;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Method;
@@ -94,7 +95,7 @@
   private static final String TAG = "Util";
   private static final Pattern XS_DATE_TIME_PATTERN = Pattern.compile(
       "(\\d\\d\\d\\d)\\-(\\d\\d)\\-(\\d\\d)[Tt]"
-      + "(\\d\\d):(\\d\\d):(\\d\\d)(\\.(\\d+))?"
+      + "(\\d\\d):(\\d\\d):(\\d\\d)([\\.,](\\d+))?"
       + "([Zz]|((\\+|\\-)(\\d\\d):?(\\d\\d)))?");
   private static final Pattern XS_DURATION_PATTERN =
       Pattern.compile("^(-)?P(([0-9]*)Y)?(([0-9]*)M)?(([0-9]*)D)?"
@@ -254,6 +255,16 @@ public static String normalizeLanguageCode(String language) {
     return value.getBytes(Charset.defaultCharset()); // UTF-8 is the default on Android.
   }
 
+  /**
+   * Returns whether the given character is a carriage return ('\r') or a line feed ('\n').
+   *
+   * @param c The character.
+   * @return Whether the given character is a linebreak.
+   */
+  public static boolean isLinebreak(int c) {
+    return c == '\n' || c == '\r';
+  }
+
   /**
    * Converts text to lower case using {@link Locale#US}.
    *
@@ -757,6 +768,40 @@ public static int getPcmEncoding(int bitDepth) {
     }
   }
 
+  /**
+   * Returns the frame size for audio with {@code channelCount} channels in the specified encoding.
+   *
+   * @param pcmEncoding The encoding of the audio data.
+   * @param channelCount The channel count.
+   * @return The size of one audio frame in bytes.
+   */
+  public static int getPcmFrameSize(@C.PcmEncoding int pcmEncoding, int channelCount) {
+    switch (pcmEncoding) {
+      case C.ENCODING_PCM_8BIT:
+        return channelCount;
+      case C.ENCODING_PCM_16BIT:
+        return channelCount * 2;
+      case C.ENCODING_PCM_24BIT:
+        return channelCount * 3;
+      case C.ENCODING_PCM_32BIT:
+        return channelCount * 4;
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
+  /**
+   * Makes a best guess to infer the type from a {@link Uri}.
+   *
+   * @param uri The {@link Uri}.
+   * @return The content type.
+   */
+  @C.ContentType
+  public static int inferContentType(Uri uri) {
+    String path = uri.getPath();
+    return path == null ? C.TYPE_OTHER : inferContentType(path);
+  }
+
   /**
    * Makes a best guess to infer the type from a file name.
    *
@@ -765,14 +810,14 @@ public static int getPcmEncoding(int bitDepth) {
    */
   @C.ContentType
   public static int inferContentType(String fileName) {
-    if (fileName == null) {
-      return C.TYPE_OTHER;
-    } else if (fileName.endsWith(".mpd")) {
+    fileName = fileName.toLowerCase();
+    if (fileName.endsWith(".mpd")) {
       return C.TYPE_DASH;
-    } else if (fileName.endsWith(".ism") || fileName.endsWith(".isml")) {
-      return C.TYPE_SS;
     } else if (fileName.endsWith(".m3u8")) {
       return C.TYPE_HLS;
+    } else if (fileName.endsWith(".ism") || fileName.endsWith(".isml")
+        || fileName.endsWith(".ism/manifest") || fileName.endsWith(".isml/manifest")) {
+      return C.TYPE_SS;
     } else {
       return C.TYPE_OTHER;
     }
@@ -914,6 +959,24 @@ public static void sneakyThrow(Throwable t) {
     throw (T) t;
   }
 
+  /** Recursively deletes a directory and its content. */
+  public static void recursiveDelete(File fileOrDirectory) {
+    if (fileOrDirectory.isDirectory()) {
+      for (File child : fileOrDirectory.listFiles()) {
+        recursiveDelete(child);
+      }
+    }
+    fileOrDirectory.delete();
+  }
+
+  /** Creates an empty directory in the directory returned by {@link Context#getCacheDir()}. */
+  public static File createTempDirectory(Context context, String prefix) throws IOException {
+    File tempFile = File.createTempFile(prefix, null, context.getCacheDir());
+    tempFile.delete(); // Delete the temp file.
+    tempFile.mkdir(); // Create a directory with the same name.
+    return tempFile;
+  }
+
   /**
    * Returns the result of updating a CRC with the specified bytes in a "most significant bit first"
    * order.
diff --git a/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 2a13953106..059628e0c8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -18,7 +18,9 @@
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.content.Context;
+import android.graphics.Point;
 import android.media.MediaCodec;
+import android.media.MediaCodecInfo.CodecCapabilities;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
 import android.os.Handler;
@@ -28,6 +30,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -54,6 +57,10 @@
   private static final String KEY_CROP_BOTTOM = "crop-bottom";
   private static final String KEY_CROP_TOP = "crop-top";
 
+  // Long edge length in pixels for standard video formats, in decreasing in order.
+  private static final int[] STANDARD_LONG_EDGE_VIDEO_PX = new int[] {
+      1920, 1600, 1440, 1280, 960, 854, 640, 540, 480};
+
   private final VideoFrameReleaseTimeHelper frameReleaseTimeHelper;
   private final EventDispatcher eventDispatcher;
   private final long allowedJoiningTimeMs;
@@ -83,6 +90,10 @@
   private int lastReportedUnappliedRotationDegrees;
   private float lastReportedPixelWidthHeightRatio;
 
+  private boolean tunneling;
+  private int tunnelingAudioSessionId;
+  /* package */ OnFrameRenderedListenerV23 tunnelingOnFrameRenderedListener;
+
   /**
    * @param context A context.
    * @param mediaCodecSelector A decoder selector.
@@ -172,7 +183,7 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
       }
     }
     MediaCodecInfo decoderInfo = mediaCodecSelector.getDecoderInfo(mimeType,
-        requiresSecureDecryption, false);
+        requiresSecureDecryption);
     if (decoderInfo == null) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     }
@@ -180,12 +191,8 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
     boolean decoderCapable = decoderInfo.isCodecSupported(format.codecs);
     if (decoderCapable && format.width > 0 && format.height > 0) {
       if (Util.SDK_INT >= 21) {
-        if (format.frameRate > 0) {
-          decoderCapable = decoderInfo.isVideoSizeAndRateSupportedV21(format.width, format.height,
-              format.frameRate);
-        } else {
-          decoderCapable = decoderInfo.isVideoSizeSupportedV21(format.width, format.height);
-        }
+        decoderCapable = decoderInfo.isVideoSizeAndRateSupportedV21(format.width, format.height,
+            format.frameRate);
       } else {
         decoderCapable = format.width * format.height <= MediaCodecUtil.maxH264DecodableFrameSize();
         if (!decoderCapable) {
@@ -196,13 +203,16 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector, Format forma
     }
 
     int adaptiveSupport = decoderInfo.adaptive ? ADAPTIVE_SEAMLESS : ADAPTIVE_NOT_SEAMLESS;
+    int tunnelingSupport = decoderInfo.tunneling ? TUNNELING_SUPPORTED : TUNNELING_NOT_SUPPORTED;
     int formatSupport = decoderCapable ? FORMAT_HANDLED : FORMAT_EXCEEDS_CAPABILITIES;
-    return adaptiveSupport | formatSupport;
+    return adaptiveSupport | tunnelingSupport | formatSupport;
   }
 
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     super.onEnabled(joining);
+    tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;
+    tunneling = tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET;
     eventDispatcher.enabled(decoderCounters);
     frameReleaseTimeHelper.enable();
   }
@@ -216,7 +226,7 @@ protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     super.onPositionReset(positionUs, joining);
-    renderedFirstFrame = false;
+    clearRenderedFirstFrame();
     consecutiveDroppedFrameCount = 0;
     joiningDeadlineMs = joining && allowedJoiningTimeMs > 0
         ? (SystemClock.elapsedRealtime() + allowedJoiningTimeMs) : C.TIME_UNSET;
@@ -263,6 +273,7 @@ protected void onDisabled() {
     pendingPixelWidthHeightRatio = Format.NO_VALUE;
     clearLastReportedVideoSize();
     frameReleaseTimeHelper.disable();
+    tunnelingOnFrameRenderedListener = null;
     try {
       super.onDisabled();
     } finally {
@@ -287,19 +298,24 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
   }
 
   private void setSurface(Surface surface) throws ExoPlaybackException {
-    // Clear state so that we always call the event listener with the video size and when a frame
-    // is rendered, even if the surface hasn't changed.
-    renderedFirstFrame = false;
-    clearLastReportedVideoSize();
-    // We only need to actually release and reinitialize the codec if the surface has changed.
+    // We only need to update the codec if the surface has changed.
     if (this.surface != surface) {
       this.surface = surface;
       int state = getState();
       if (state == STATE_ENABLED || state == STATE_STARTED) {
-        releaseCodec();
-        maybeInitCodec();
+        MediaCodec codec = getCodec();
+        if (Util.SDK_INT >= 23 && codec != null && surface != null) {
+          setOutputSurfaceV23(codec, surface);
+        } else {
+          releaseCodec();
+          maybeInitCodec();
+        }
       }
     }
+    // Clear state so that we always call the event listener with the video size and when a frame
+    // is rendered, even if the surface hasn't changed.
+    clearRenderedFirstFrame();
+    clearLastReportedVideoSize();
   }
 
   @Override
@@ -308,10 +324,15 @@ protected boolean shouldInitCodec() {
   }
 
   @Override
-  protected void configureCodec(MediaCodec codec, Format format, MediaCrypto crypto) {
-    codecMaxValues = getCodecMaxValues(format, streamFormats);
-    MediaFormat mediaFormat = getMediaFormat(format, codecMaxValues, deviceNeedsAutoFrcWorkaround);
+  protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
+      MediaCrypto crypto) throws DecoderQueryException {
+    codecMaxValues = getCodecMaxValues(codecInfo, format, streamFormats);
+    MediaFormat mediaFormat = getMediaFormat(format, codecMaxValues, deviceNeedsAutoFrcWorkaround,
+        tunnelingAudioSessionId);
     codec.configure(mediaFormat, surface, crypto, 0);
+    if (Util.SDK_INT >= 23 && tunneling) {
+      tunnelingOnFrameRenderedListener = new OnFrameRenderedListenerV23(codec);
+    }
   }
 
   @Override
@@ -328,6 +349,13 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
     pendingRotationDegrees = getRotationDegrees(newFormat);
   }
 
+  @Override
+  protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
+    if (Util.SDK_INT < 23 && tunneling) {
+      maybeNotifyRenderedFirstFrame();
+    }
+  }
+
   @Override
   protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat outputFormat) {
     boolean hasCrop = outputFormat.containsKey(KEY_CROP_RIGHT)
@@ -403,7 +431,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
         bufferPresentationTimeUs, unadjustedFrameReleaseTimeNs);
     earlyUs = (adjustedReleaseTimeNs - systemTimeNs) / 1000;
 
-    if (earlyUs < -30000) {
+    if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
       // We're more than 30ms late rendering the frame.
       dropOutputBuffer(codec, bufferIndex);
       return true;
@@ -437,6 +465,19 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     return false;
   }
 
+  /**
+   * Returns whether the buffer being processed should be dropped.
+   *
+   * @param earlyUs The time until the buffer should be presented in microseconds. A negative value
+   *     indicates that the buffer is late.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   */
+  protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
+    // Drop the frame if we're more than 30ms late rendering the frame.
+    return earlyUs < -30000;
+  }
+
   private void skipOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.beginSection("skipVideoBuffer");
     codec.releaseOutputBuffer(bufferIndex, false);
@@ -465,10 +506,7 @@ private void renderOutputBuffer(MediaCodec codec, int bufferIndex) {
     TraceUtil.endSection();
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
-    if (!renderedFirstFrame) {
-      renderedFirstFrame = true;
-      eventDispatcher.renderedFirstFrame(surface);
-    }
+    maybeNotifyRenderedFirstFrame();
   }
 
   @TargetApi(21)
@@ -479,6 +517,25 @@ private void renderOutputBufferV21(MediaCodec codec, int bufferIndex, long relea
     TraceUtil.endSection();
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
+    maybeNotifyRenderedFirstFrame();
+  }
+
+  private void clearRenderedFirstFrame() {
+    renderedFirstFrame = false;
+    // The first frame notification is triggered by renderOutputBuffer or renderOutputBufferV21 for
+    // non-tunneled playback, onQueueInputBuffer for tunneled playback prior to API level 23, and
+    // OnFrameRenderedListenerV23.onFrameRenderedListener for tunneled playback on API level 23 and
+    // above.
+    if (Util.SDK_INT >= 23 && tunneling) {
+      MediaCodec codec = getCodec();
+      // If codec is null then the listener will be instantiated in configureCodec.
+      if (codec != null) {
+        tunnelingOnFrameRenderedListener = new OnFrameRenderedListenerV23(codec);
+      }
+    }
+  }
+
+  /* package */ void maybeNotifyRenderedFirstFrame() {
     if (!renderedFirstFrame) {
       renderedFirstFrame = true;
       eventDispatcher.renderedFirstFrame(surface);
@@ -517,7 +574,7 @@ private void maybeNotifyDroppedFrames() {
 
   @SuppressLint("InlinedApi")
   private static MediaFormat getMediaFormat(Format format, CodecMaxValues codecMaxValues,
-      boolean deviceNeedsAutoFrcWorkaround) {
+      boolean deviceNeedsAutoFrcWorkaround, int tunnelingAudioSessionId) {
     MediaFormat frameworkMediaFormat = format.getFrameworkMediaFormatV16();
     // Set the maximum adaptive video dimensions.
     frameworkMediaFormat.setInteger(MediaFormat.KEY_MAX_WIDTH, codecMaxValues.width);
@@ -530,36 +587,114 @@ private static MediaFormat getMediaFormat(Format format, CodecMaxValues codecMax
     if (deviceNeedsAutoFrcWorkaround) {
       frameworkMediaFormat.setInteger("auto-frc", 0);
     }
+    // Configure tunneling if enabled.
+    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
+      configureTunnelingV21(frameworkMediaFormat, tunnelingAudioSessionId);
+    }
     return frameworkMediaFormat;
   }
 
+  @TargetApi(23)
+  private static void setOutputSurfaceV23(MediaCodec codec, Surface surface) {
+    codec.setOutputSurface(surface);
+  }
+
+  @TargetApi(21)
+  private static void configureTunnelingV21(MediaFormat mediaFormat, int tunnelingAudioSessionId) {
+    mediaFormat.setFeatureEnabled(CodecCapabilities.FEATURE_TunneledPlayback, true);
+    mediaFormat.setInteger(MediaFormat.KEY_AUDIO_SESSION_ID, tunnelingAudioSessionId);
+  }
+
   /**
    * Returns {@link CodecMaxValues} suitable for configuring a codec for {@code format} in a way
    * that will allow possible adaptation to other compatible formats in {@code streamFormats}.
    *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
    * @param format The format for which the codec is being configured.
    * @param streamFormats The possible stream formats.
    * @return Suitable {@link CodecMaxValues}.
+   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
    */
-  private static CodecMaxValues getCodecMaxValues(Format format, Format[] streamFormats) {
+  private static CodecMaxValues getCodecMaxValues(MediaCodecInfo codecInfo, Format format,
+      Format[] streamFormats) throws DecoderQueryException {
     int maxWidth = format.width;
     int maxHeight = format.height;
     int maxInputSize = getMaxInputSize(format);
+    if (streamFormats.length == 1) {
+      // The single entry in streamFormats must correspond to the format for which the codec is
+      // being configured.
+      return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);
+    }
+    boolean haveUnknownDimensions = false;
     for (Format streamFormat : streamFormats) {
       if (areAdaptationCompatible(format, streamFormat)) {
+        haveUnknownDimensions |= (streamFormat.width == Format.NO_VALUE
+            || streamFormat.height == Format.NO_VALUE);
         maxWidth = Math.max(maxWidth, streamFormat.width);
         maxHeight = Math.max(maxHeight, streamFormat.height);
         maxInputSize = Math.max(maxInputSize, getMaxInputSize(streamFormat));
       }
     }
+    if (haveUnknownDimensions) {
+      Log.w(TAG, "Resolutions unknown. Codec max resolution: " + maxWidth + "x" + maxHeight);
+      Point codecMaxSize = getCodecMaxSize(codecInfo, format);
+      if (codecMaxSize != null) {
+        maxWidth = Math.max(maxWidth, codecMaxSize.x);
+        maxHeight = Math.max(maxHeight, codecMaxSize.y);
+        maxInputSize = Math.max(maxInputSize,
+            getMaxInputSize(format.sampleMimeType, maxWidth, maxHeight));
+        Log.w(TAG, "Codec max resolution adjusted to: " + maxWidth + "x" + maxHeight);
+      }
+    }
     return new CodecMaxValues(maxWidth, maxHeight, maxInputSize);
   }
 
+  /**
+   * Returns a maximum video size to use when configuring a codec for {@code format} in a way
+   * that will allow possible adaptation to other compatible formats that are expected to have the
+   * same aspect ratio, but whose sizes are unknown.
+   *
+   * @param codecInfo Information about the {@link MediaCodec} being configured.
+   * @param format The format for which the codec is being configured.
+   * @return The maximum video size to use, or null if the size of {@code format} should be used.
+   * @throws DecoderQueryException If an error occurs querying {@code codecInfo}.
+   */
+  private static Point getCodecMaxSize(MediaCodecInfo codecInfo, Format format)
+      throws DecoderQueryException {
+    boolean isVerticalVideo = format.height > format.width;
+    int formatLongEdgePx = isVerticalVideo ? format.height : format.width;
+    int formatShortEdgePx = isVerticalVideo ? format.width : format.height;
+    float aspectRatio = (float) formatShortEdgePx / formatLongEdgePx;
+    for (int longEdgePx : STANDARD_LONG_EDGE_VIDEO_PX) {
+      int shortEdgePx = (int) (longEdgePx * aspectRatio);
+      if (longEdgePx <= formatLongEdgePx || shortEdgePx <= formatShortEdgePx) {
+        // Don't return a size not larger than the format for which the codec is being configured.
+        return null;
+      } else if (Util.SDK_INT >= 21) {
+        Point alignedSize = codecInfo.alignVideoSizeV21(isVerticalVideo ? shortEdgePx : longEdgePx,
+            isVerticalVideo ? longEdgePx : shortEdgePx);
+        float frameRate = format.frameRate;
+        if (codecInfo.isVideoSizeAndRateSupportedV21(alignedSize.x, alignedSize.y, frameRate)) {
+          return alignedSize;
+        }
+      } else {
+        // Conservatively assume the codec requires 16px width and height alignment.
+        longEdgePx = Util.ceilDivide(longEdgePx, 16) * 16;
+        shortEdgePx = Util.ceilDivide(shortEdgePx, 16) * 16;
+        if (longEdgePx * shortEdgePx <= MediaCodecUtil.maxH264DecodableFrameSize()) {
+          return new Point(isVerticalVideo ? shortEdgePx : longEdgePx,
+              isVerticalVideo ? longEdgePx : shortEdgePx);
+        }
+      }
+    }
+    return null;
+  }
+
   /**
    * Returns a maximum input size for a given format.
    *
    * @param format The format.
-   * @return An maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
+   * @return A maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
    *     determined.
    */
   private static int getMaxInputSize(Format format) {
@@ -567,8 +702,20 @@ private static int getMaxInputSize(Format format) {
       // The format defines an explicit maximum input size.
       return format.maxInputSize;
     }
+    return getMaxInputSize(format.sampleMimeType, format.width, format.height);
+  }
 
-    if (format.width == Format.NO_VALUE || format.height == Format.NO_VALUE) {
+  /**
+   * Returns a maximum input size for a given mime type, width and height.
+   *
+   * @param sampleMimeType The format mime type.
+   * @param width The width in pixels.
+   * @param height The height in pixels.
+   * @return A maximum input size in bytes, or {@link Format#NO_VALUE} if a maximum could not be
+   *     determined.
+   */
+  private static int getMaxInputSize(String sampleMimeType, int width, int height) {
+    if (width == Format.NO_VALUE || height == Format.NO_VALUE) {
       // We can't infer a maximum input size without video dimensions.
       return Format.NO_VALUE;
     }
@@ -576,10 +723,10 @@ private static int getMaxInputSize(Format format) {
     // Attempt to infer a maximum input size from the format.
     int maxPixels;
     int minCompressionRatio;
-    switch (format.sampleMimeType) {
+    switch (sampleMimeType) {
       case MimeTypes.VIDEO_H263:
       case MimeTypes.VIDEO_MP4V:
-        maxPixels = format.width * format.height;
+        maxPixels = width * height;
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_H264:
@@ -589,17 +736,17 @@ private static int getMaxInputSize(Format format) {
           return Format.NO_VALUE;
         }
         // Round up width/height to an integer number of macroblocks.
-        maxPixels = ((format.width + 15) / 16) * ((format.height + 15) / 16) * 16 * 16;
+        maxPixels = Util.ceilDivide(width, 16) * Util.ceilDivide(height, 16) * 16 * 16;
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_VP8:
         // VPX does not specify a ratio so use the values from the platform's SoftVPX.cpp.
-        maxPixels = format.width * format.height;
+        maxPixels = width * height;
         minCompressionRatio = 2;
         break;
       case MimeTypes.VIDEO_H265:
       case MimeTypes.VIDEO_VP9:
-        maxPixels = format.width * format.height;
+        maxPixels = width * height;
         minCompressionRatio = 4;
         break;
       default:
@@ -668,4 +815,22 @@ public CodecMaxValues(int width, int height, int inputSize) {
 
   }
 
+  @TargetApi(23)
+  private final class OnFrameRenderedListenerV23 implements MediaCodec.OnFrameRenderedListener {
+
+    private OnFrameRenderedListenerV23(MediaCodec codec) {
+      codec.setOnFrameRenderedListener(this, new Handler());
+    }
+
+    @Override
+    public void onFrameRendered(MediaCodec codec, long presentationTimeUs, long nanoTime) {
+      if (this != tunnelingOnFrameRenderedListener) {
+        // Stale event.
+        return;
+      }
+      maybeNotifyRenderedFirstFrame();
+    }
+
+  }
+
 }
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_fastforward.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_fastforward.xml
new file mode 100644
index 0000000000..4b86e109e9
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_fastforward.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M4,18l8.5,-6L4,6v12zM13,6v12l8.5,-6L13,6z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_next.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_next.xml
new file mode 100644
index 0000000000..6305bcbc90
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_next.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M6,18l8.5,-6L6,6v12zM16,6v12h2V6h-2z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_pause.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_pause.xml
new file mode 100644
index 0000000000..45cd68bed6
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_pause.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M6,19h4L10,5L6,5v14zM14,5v14h4L18,5h-4z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_play.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_play.xml
new file mode 100644
index 0000000000..c8c4cdb127
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_play.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M8,5v14l11,-7z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_previous.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_previous.xml
new file mode 100644
index 0000000000..9564a2a350
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_previous.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M6,6h2v12L6,18zM9.5,12l8.5,6L18,6z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-anydpi-v21/exo_controls_rewind.xml b/library/src/main/res/drawable-anydpi-v21/exo_controls_rewind.xml
new file mode 100644
index 0000000000..976b706170
--- /dev/null
+++ b/library/src/main/res/drawable-anydpi-v21/exo_controls_rewind.xml
@@ -0,0 +1,25 @@
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="32dp"
+    android:height="32dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+
+  <path
+      android:fillColor="#FFFFFFFF"
+      android:pathData="M11,18L11,6l-8.5,6 8.5,6zM11.5,12l8.5,6L20,6l-8.5,6z"/>
+
+</vector>
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png
index c65956ab7f..843df84091 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-hdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_next.png b/library/src/main/res/drawable-hdpi/exo_controls_next.png
index 6e27b8161e..c37541472e 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_next.png and b/library/src/main/res/drawable-hdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_pause.png b/library/src/main/res/drawable-hdpi/exo_controls_pause.png
index 1d465a41e4..0a23452746 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_pause.png and b/library/src/main/res/drawable-hdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_play.png b/library/src/main/res/drawable-hdpi/exo_controls_play.png
index 2746d17fb1..e98e2b9cbe 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_play.png and b/library/src/main/res/drawable-hdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_previous.png b/library/src/main/res/drawable-hdpi/exo_controls_previous.png
index 85b3766904..3eae5c883b 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_previous.png and b/library/src/main/res/drawable-hdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-hdpi/exo_controls_rewind.png b/library/src/main/res/drawable-hdpi/exo_controls_rewind.png
index a4ac181777..36537d3b73 100644
Binary files a/library/src/main/res/drawable-hdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-hdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png b/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png
index 1b4d9dbef9..19b9e6015c 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-ldpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_next.png b/library/src/main/res/drawable-ldpi/exo_controls_next.png
index 99927fd27b..d4872037aa 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_next.png and b/library/src/main/res/drawable-ldpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_pause.png b/library/src/main/res/drawable-ldpi/exo_controls_pause.png
index 3b98d66688..616ec42f39 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_pause.png and b/library/src/main/res/drawable-ldpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_play.png b/library/src/main/res/drawable-ldpi/exo_controls_play.png
index e7c19724bb..5d1c702892 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_play.png and b/library/src/main/res/drawable-ldpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_previous.png b/library/src/main/res/drawable-ldpi/exo_controls_previous.png
index df043228d0..930534d312 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_previous.png and b/library/src/main/res/drawable-ldpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-ldpi/exo_controls_rewind.png b/library/src/main/res/drawable-ldpi/exo_controls_rewind.png
index 28843f9fb0..83d71782f6 100644
Binary files a/library/src/main/res/drawable-ldpi/exo_controls_rewind.png and b/library/src/main/res/drawable-ldpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png
index 170dd2daaa..ee3efe1d69 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-mdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_next.png b/library/src/main/res/drawable-mdpi/exo_controls_next.png
index fcd73d90e7..9d4d7469ed 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_next.png and b/library/src/main/res/drawable-mdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_pause.png b/library/src/main/res/drawable-mdpi/exo_controls_pause.png
index 3e6b2a17b5..f54c942201 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_pause.png and b/library/src/main/res/drawable-mdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_play.png b/library/src/main/res/drawable-mdpi/exo_controls_play.png
index 7966bbc516..dd0c142859 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_play.png and b/library/src/main/res/drawable-mdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_previous.png b/library/src/main/res/drawable-mdpi/exo_controls_previous.png
index b653d05b9f..950e213d2f 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_previous.png and b/library/src/main/res/drawable-mdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-mdpi/exo_controls_rewind.png b/library/src/main/res/drawable-mdpi/exo_controls_rewind.png
index 5489180eb1..e75efae189 100644
Binary files a/library/src/main/res/drawable-mdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-mdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png
index 60f7e92181..ead712cfe9 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-xhdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_next.png b/library/src/main/res/drawable-xhdpi/exo_controls_next.png
index 4def965cec..bc1ebf83c5 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_next.png and b/library/src/main/res/drawable-xhdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_pause.png b/library/src/main/res/drawable-xhdpi/exo_controls_pause.png
index 6bd3d482e1..1c868f1831 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_pause.png and b/library/src/main/res/drawable-xhdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_play.png b/library/src/main/res/drawable-xhdpi/exo_controls_play.png
index ccfef18056..f2f934413e 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_play.png and b/library/src/main/res/drawable-xhdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_previous.png b/library/src/main/res/drawable-xhdpi/exo_controls_previous.png
index c4472ae2d9..d197eff873 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_previous.png and b/library/src/main/res/drawable-xhdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png b/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png
index 167d10e58b..3340ef9bd2 100644
Binary files a/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-xhdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png b/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png
index ab9e022fbf..e1c6cae292 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_fastforward.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_next.png b/library/src/main/res/drawable-xxhdpi/exo_controls_next.png
index ce0a14325a..232f09e910 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_next.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_next.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png b/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png
index 9a36b17cb8..50a545db4d 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_pause.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_play.png b/library/src/main/res/drawable-xxhdpi/exo_controls_play.png
index 41f76bbf99..08508c5015 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_play.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_play.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png b/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png
index d4688741b9..f71acc4875 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_previous.png differ
diff --git a/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png b/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png
index 8ebb2ccf30..db0555f9e5 100644
Binary files a/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png and b/library/src/main/res/drawable-xxhdpi/exo_controls_rewind.png differ
diff --git a/library/src/main/res/values/attrs.xml b/library/src/main/res/values/attrs.xml
index b5c01b4575..c73bfb0a3c 100644
--- a/library/src/main/res/values/attrs.xml
+++ b/library/src/main/res/values/attrs.xml
@@ -37,6 +37,7 @@
 
   <declare-styleable name="SimpleExoPlayerView">
     <attr name="use_artwork" format="boolean"/>
+    <attr name="default_artwork" format="reference"/>
     <attr name="use_controller" format="boolean"/>
     <attr name="surface_type"/>
     <attr name="show_timeout"/>
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index c099e2c86e..cb82d0a466 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -18,20 +18,9 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
-        }
-    }
-
-    lintOptions {
-        abortOnError false
-    }
 }
 
 dependencies {
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
index 8c1ee45e0e..fc0701da8d 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTest.java
@@ -15,56 +15,15 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
-import android.annotation.TargetApi;
-import android.media.MediaDrm;
-import android.media.UnsupportedSchemeException;
-import android.net.Uri;
 import android.test.ActivityInstrumentationTestCase2;
-import android.util.Log;
-import android.view.Surface;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.DefaultLoadControl;
-import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.RendererCapabilities;
-import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.decoder.DecoderCounters;
-import com.google.android.exoplayer2.drm.DrmSessionManager;
-import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
-import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
-import com.google.android.exoplayer2.drm.StreamingDrmSessionManager;
-import com.google.android.exoplayer2.drm.UnsupportedDrmException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.playbacktests.util.ActionSchedule;
-import com.google.android.exoplayer2.playbacktests.util.DebugSimpleExoPlayer;
-import com.google.android.exoplayer2.playbacktests.util.DecoderCountersUtil;
-import com.google.android.exoplayer2.playbacktests.util.ExoHostedTest;
 import com.google.android.exoplayer2.playbacktests.util.HostActivity;
-import com.google.android.exoplayer2.playbacktests.util.MetricsLogger;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.TrackGroup;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.source.dash.DashMediaSource;
-import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
-import com.google.android.exoplayer2.trackselection.FixedTrackSelection;
-import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
-import com.google.android.exoplayer2.trackselection.RandomTrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.upstream.BandwidthMeter;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
-import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
-import com.google.android.exoplayer2.upstream.TransferListener;
-import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.UUID;
-import junit.framework.AssertionFailedError;
 
 /**
  * Tests DASH playbacks using {@link ExoPlayer}.
@@ -72,147 +31,6 @@
 public final class DashTest extends ActivityInstrumentationTestCase2<HostActivity> {
 
   private static final String TAG = "DashTest";
-  private static final String VIDEO_TAG = TAG + ":Video";
-  private static final String AUDIO_TAG = TAG + ":Audio";
-  private static final String REPORT_NAME = "GtsExoPlayerTestCases";
-  private static final String REPORT_OBJECT_NAME = "playbacktest";
-  private static final int VIDEO_RENDERER_INDEX = 0;
-  private static final int AUDIO_RENDERER_INDEX = 1;
-
-  private static final long TEST_TIMEOUT_MS = 5 * 60 * 1000;
-  private static final int MIN_LOADABLE_RETRY_COUNT = 10;
-  private static final int MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES = 10;
-  private static final float MAX_DROPPED_VIDEO_FRAME_FRACTION = 0.01f;
-
-  private static final String MANIFEST_URL_PREFIX = "https://storage.googleapis.com/exoplayer-test-"
-      + "media-1/gen-3/screens/dash-vod-single-segment/";
-  // Clear content manifests.
-  private static final String H264_MANIFEST = "manifest-h264.mpd";
-  private static final String H265_MANIFEST = "manifest-h265.mpd";
-  private static final String VP9_MANIFEST = "manifest-vp9.mpd";
-  private static final String H264_23_MANIFEST = "manifest-h264-23.mpd";
-  private static final String H264_24_MANIFEST = "manifest-h264-24.mpd";
-  private static final String H264_29_MANIFEST = "manifest-h264-29.mpd";
-  // Widevine encrypted content manifests.
-  private static final String WIDEVINE_H264_MANIFEST_PREFIX = "manifest-h264-enc";
-  private static final String WIDEVINE_H265_MANIFEST_PREFIX = "manifest-h265-enc";
-  private static final String WIDEVINE_VP9_MANIFEST_PREFIX = "manifest-vp9-enc";
-  private static final String WIDEVINE_H264_23_MANIFEST_PREFIX = "manifest-h264-23-enc";
-  private static final String WIDEVINE_H264_24_MANIFEST_PREFIX = "manifest-h264-24-enc";
-  private static final String WIDEVINE_H264_29_MANIFEST_PREFIX = "manifest-h264-29-enc";
-  private static final String WIDEVINE_L1_SUFFIX = "-hw.mpd";
-  private static final String WIDEVINE_L3_SUFFIX = "-sw.mpd";
-
-  private static final String AAC_AUDIO_REPRESENTATION_ID = "141";
-  private static final String H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "avc-baseline-240";
-  private static final String H264_BASELINE_480P_VIDEO_REPRESENTATION_ID = "avc-baseline-480";
-  private static final String H264_MAIN_240P_VIDEO_REPRESENTATION_ID = "avc-main-240";
-  private static final String H264_MAIN_480P_VIDEO_REPRESENTATION_ID = "avc-main-480";
-  // The highest quality H264 format mandated by the Android CDD.
-  private static final String H264_CDD_FIXED = Util.SDK_INT < 23
-      ? H264_BASELINE_480P_VIDEO_REPRESENTATION_ID : H264_MAIN_480P_VIDEO_REPRESENTATION_ID;
-  // Multiple H264 formats mandated by the Android CDD. Note: The CDD actually mandated main profile
-  // support from API level 23, but we opt to test only from 24 due to known issues on API level 23
-  // when switching between baseline and main profiles on certain devices.
-  private static final String[] H264_CDD_ADAPTIVE = Util.SDK_INT < 24
-      ? new String[] {
-          H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
-          H264_BASELINE_480P_VIDEO_REPRESENTATION_ID}
-      : new String[] {
-          H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
-          H264_BASELINE_480P_VIDEO_REPRESENTATION_ID,
-          H264_MAIN_240P_VIDEO_REPRESENTATION_ID,
-          H264_MAIN_480P_VIDEO_REPRESENTATION_ID};
-
-  private static final String H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID =
-      "avc-baseline-480-23";
-  private static final String H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID =
-      "avc-baseline-480-24";
-  private static final String H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID =
-      "avc-baseline-480-29";
-
-  private static final String H265_BASELINE_288P_VIDEO_REPRESENTATION_ID = "hevc-main-288";
-  private static final String H265_BASELINE_360P_VIDEO_REPRESENTATION_ID = "hevc-main-360";
-  // The highest quality H265 format mandated by the Android CDD.
-  private static final String H265_CDD_FIXED = H265_BASELINE_360P_VIDEO_REPRESENTATION_ID;
-  // Multiple H265 formats mandated by the Android CDD.
-  private static final String[] H265_CDD_ADAPTIVE =
-      new String[] {
-          H265_BASELINE_288P_VIDEO_REPRESENTATION_ID,
-          H265_BASELINE_360P_VIDEO_REPRESENTATION_ID};
-
-  private static final String VORBIS_AUDIO_REPRESENTATION_ID = "4";
-  private static final String VP9_180P_VIDEO_REPRESENTATION_ID = "0";
-  private static final String VP9_360P_VIDEO_REPRESENTATION_ID = "1";
-  // The highest quality VP9 format mandated by the Android CDD.
-  private static final String VP9_CDD_FIXED = VP9_360P_VIDEO_REPRESENTATION_ID;
-  // Multiple VP9 formats mandated by the Android CDD.
-  private static final String[] VP9_CDD_ADAPTIVE =
-      new String[] {
-          VP9_180P_VIDEO_REPRESENTATION_ID,
-          VP9_360P_VIDEO_REPRESENTATION_ID};
-
-  // Widevine encrypted content representation ids.
-  private static final String WIDEVINE_AAC_AUDIO_REPRESENTATION_ID = "0";
-  private static final String WIDEVINE_H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "1";
-  private static final String WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID = "2";
-  private static final String WIDEVINE_H264_MAIN_240P_VIDEO_REPRESENTATION_ID = "3";
-  private static final String WIDEVINE_H264_MAIN_480P_VIDEO_REPRESENTATION_ID = "4";
-  // The highest quality H264 format mandated by the Android CDD.
-  private static final String WIDEVINE_H264_CDD_FIXED = Util.SDK_INT < 23
-      ? WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID
-      : WIDEVINE_H264_MAIN_480P_VIDEO_REPRESENTATION_ID;
-  // Multiple H264 formats mandated by the Android CDD. Note: The CDD actually mandated main profile
-  // support from API level 23, but we opt to test only from 24 due to known issues on API level 23
-  // when switching between baseline and main profiles on certain devices.
-  private static final String[] WIDEVINE_H264_CDD_ADAPTIVE = Util.SDK_INT < 24
-      ? new String[] {
-      WIDEVINE_H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
-      WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID}
-      : new String[] {
-      WIDEVINE_H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
-      WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID,
-      WIDEVINE_H264_MAIN_240P_VIDEO_REPRESENTATION_ID,
-      WIDEVINE_H264_MAIN_480P_VIDEO_REPRESENTATION_ID};
-
-  private static final String WIDEVINE_H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID = "2";
-  private static final String WIDEVINE_H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID = "2";
-  private static final String WIDEVINE_H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID = "2";
-
-  private static final String WIDEVINE_H265_BASELINE_288P_VIDEO_REPRESENTATION_ID = "1";
-  private static final String WIDEVINE_H265_BASELINE_360P_VIDEO_REPRESENTATION_ID = "2";
-  // The highest quality H265 format mandated by the Android CDD.
-  private static final String WIDEVINE_H265_CDD_FIXED =
-      WIDEVINE_H265_BASELINE_360P_VIDEO_REPRESENTATION_ID;
-  // Multiple H265 formats mandated by the Android CDD.
-  private static final String[] WIDEVINE_H265_CDD_ADAPTIVE =
-      new String[] {
-          WIDEVINE_H265_BASELINE_288P_VIDEO_REPRESENTATION_ID,
-          WIDEVINE_H265_BASELINE_360P_VIDEO_REPRESENTATION_ID};
-
-  private static final String WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID = "0";
-  private static final String WIDEVINE_VP9_180P_VIDEO_REPRESENTATION_ID = "1";
-  private static final String WIDEVINE_VP9_360P_VIDEO_REPRESENTATION_ID = "2";
-  // The highest quality VP9 format mandated by the Android CDD.
-  private static final String WIDEVINE_VP9_CDD_FIXED = VP9_360P_VIDEO_REPRESENTATION_ID;
-  // Multiple VP9 formats mandated by the Android CDD.
-  private static final String[] WIDEVINE_VP9_CDD_ADAPTIVE =
-      new String[] {
-          WIDEVINE_VP9_180P_VIDEO_REPRESENTATION_ID,
-          WIDEVINE_VP9_360P_VIDEO_REPRESENTATION_ID};
-
-  private static final String WIDEVINE_LICENSE_URL =
-      "https://proxy.uat.widevine.com/proxy?provider=widevine_test&video_id=";
-  private static final String WIDEVINE_SW_CRYPTO_CONTENT_ID = "exoplayer_test_1";
-  private static final String WIDEVINE_HW_SECURE_DECODE_CONTENT_ID = "exoplayer_test_2";
-  private static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
-  private static final String WIDEVINE_SECURITY_LEVEL_1 = "L1";
-  private static final String WIDEVINE_SECURITY_LEVEL_3 = "L3";
-  private static final String SECURITY_LEVEL_PROPERTY = "securityLevel";
-
-  // Whether adaptive tests should enable video formats beyond those mandated by the Android CDD
-  // if the device advertises support for them.
-  private static final boolean ALLOW_ADDITIONAL_VIDEO_FORMATS = Util.SDK_INT >= 24;
 
   private static final ActionSchedule SEEKING_SCHEDULE = new ActionSchedule.Builder(TAG)
       .delay(10000).seek(15000)
@@ -222,40 +40,54 @@
       .build();
   private static final ActionSchedule RENDERER_DISABLING_SCHEDULE = new ActionSchedule.Builder(TAG)
       // Wait 10 seconds, disable the video renderer, wait another 10 seconds and enable it again.
-      .delay(10000).disableRenderer(VIDEO_RENDERER_INDEX)
-      .delay(10000).enableRenderer(VIDEO_RENDERER_INDEX)
+      .delay(10000).disableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .delay(10000).enableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
       // Ditto for the audio renderer.
-      .delay(10000).disableRenderer(AUDIO_RENDERER_INDEX)
-      .delay(10000).enableRenderer(AUDIO_RENDERER_INDEX)
+      .delay(10000).disableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .delay(10000).enableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
       // Wait 10 seconds, then disable and enable the video renderer 5 times in quick succession.
-      .delay(10000).disableRenderer(VIDEO_RENDERER_INDEX)
-      .enableRenderer(VIDEO_RENDERER_INDEX)
-      .disableRenderer(VIDEO_RENDERER_INDEX)
-      .enableRenderer(VIDEO_RENDERER_INDEX)
-      .disableRenderer(VIDEO_RENDERER_INDEX)
-      .enableRenderer(VIDEO_RENDERER_INDEX)
-      .disableRenderer(VIDEO_RENDERER_INDEX)
-      .enableRenderer(VIDEO_RENDERER_INDEX)
-      .disableRenderer(VIDEO_RENDERER_INDEX)
-      .enableRenderer(VIDEO_RENDERER_INDEX)
+      .delay(10000).disableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .disableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .disableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .disableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .disableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.VIDEO_RENDERER_INDEX)
       // Ditto for the audio renderer.
-      .delay(10000).disableRenderer(AUDIO_RENDERER_INDEX)
-      .enableRenderer(AUDIO_RENDERER_INDEX)
-      .disableRenderer(AUDIO_RENDERER_INDEX)
-      .enableRenderer(AUDIO_RENDERER_INDEX)
-      .disableRenderer(AUDIO_RENDERER_INDEX)
-      .enableRenderer(AUDIO_RENDERER_INDEX)
-      .disableRenderer(AUDIO_RENDERER_INDEX)
-      .enableRenderer(AUDIO_RENDERER_INDEX)
-      .disableRenderer(AUDIO_RENDERER_INDEX)
-      .enableRenderer(AUDIO_RENDERER_INDEX)
+      .delay(10000).disableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .disableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .disableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .disableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .disableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
+      .enableRenderer(DashTestRunner.AUDIO_RENDERER_INDEX)
       .delay(10000).seek(120000)
       .build();
+  
+  private DashTestRunner testRunner;
 
   public DashTest() {
     super(HostActivity.class);
   }
 
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    testRunner = new DashTestRunner(TAG, getActivity(), getInstrumentation());
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    testRunner = null;
+    super.tearDown();
+  }
+
   // H264 CDD.
 
   public void testH264Fixed() {
@@ -263,9 +95,13 @@ public void testH264Fixed() {
       // Pass.
       return;
     }
-    String streamName = "test_h264_fixed";
-    testDashPlayback(getActivity(), streamName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-        MimeTypes.VIDEO_H264, false, H264_CDD_FIXED);
+    testRunner
+        .setStreamName("test_h264_fixed")
+        .setManifestUrl(DashTestData.H264_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID, DashTestData.H264_CDD_FIXED)
+        .run();
   }
 
   public void testH264Adaptive() throws DecoderQueryException {
@@ -273,9 +109,14 @@ public void testH264Adaptive() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_h264_adaptive";
-    testDashPlayback(getActivity(), streamName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-            MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_h264_adaptive")
+        .setManifestUrl(DashTestData.H264_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H264_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testH264AdaptiveWithSeeking() throws DecoderQueryException {
@@ -283,10 +124,16 @@ public void testH264AdaptiveWithSeeking() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_h264_adaptive_with_seeking";
-    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, H264_MANIFEST,
-        AAC_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        H264_CDD_ADAPTIVE);
+    final String streamName = "test_h264_adaptive_with_seeking";
+    testRunner
+        .setStreamName(streamName)
+        .setManifestUrl(DashTestData.H264_MANIFEST)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(SEEKING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H264_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testH264AdaptiveWithRendererDisabling() throws DecoderQueryException {
@@ -294,10 +141,16 @@ public void testH264AdaptiveWithRendererDisabling() throws DecoderQueryException
       // Pass.
       return;
     }
-    String streamName = "test_h264_adaptive_with_renderer_disabling";
-    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false, H264_MANIFEST,
-        AAC_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        H264_CDD_ADAPTIVE);
+    final String streamName = "test_h264_adaptive_with_renderer_disabling";
+    testRunner
+        .setStreamName(streamName)
+        .setManifestUrl(DashTestData.H264_MANIFEST)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(RENDERER_DISABLING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H264_CDD_ADAPTIVE)
+        .run();
   }
 
   // H265 CDD.
@@ -307,9 +160,13 @@ public void testH265Fixed() {
       // Pass.
       return;
     }
-    String streamName = "test_h265_fixed";
-    testDashPlayback(getActivity(), streamName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-        MimeTypes.VIDEO_H265, false, H265_CDD_FIXED);
+    testRunner
+        .setStreamName("test_h265_fixed")
+        .setManifestUrl(DashTestData.H265_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID, DashTestData.H265_CDD_FIXED)
+        .run();
   }
 
   public void testH265Adaptive() throws DecoderQueryException {
@@ -317,9 +174,14 @@ public void testH265Adaptive() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_h265_adaptive";
-    testDashPlayback(getActivity(), streamName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-        MimeTypes.VIDEO_H265, ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_h265_adaptive")
+        .setManifestUrl(DashTestData.H265_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H265_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testH265AdaptiveWithSeeking() throws DecoderQueryException {
@@ -327,10 +189,15 @@ public void testH265AdaptiveWithSeeking() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_h265_adaptive_with_seeking";
-    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, H265_MANIFEST,
-        AAC_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_H265, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        H265_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_h265_adaptive_with_seeking")
+        .setManifestUrl(DashTestData.H265_MANIFEST)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(SEEKING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H265_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testH265AdaptiveWithRendererDisabling() throws DecoderQueryException {
@@ -338,10 +205,15 @@ public void testH265AdaptiveWithRendererDisabling() throws DecoderQueryException
       // Pass.
       return;
     }
-    String streamName = "test_h265_adaptive_with_renderer_disabling";
-    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
-        H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_H265,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_h265_adaptive_with_renderer_disabling")
+        .setManifestUrl(DashTestData.H265_MANIFEST)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(RENDERER_DISABLING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H265_CDD_ADAPTIVE)
+        .run();
   }
 
   // VP9 (CDD).
@@ -351,9 +223,14 @@ public void testVp9Fixed360p() {
       // Pass.
       return;
     }
-    String streamName = "test_vp9_fixed_360p";
-    testDashPlayback(getActivity(), streamName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false,
-        MimeTypes.VIDEO_VP9, false, VP9_CDD_FIXED);
+    testRunner
+        .setStreamName("test_vp9_fixed_360p")
+        .setManifestUrl(DashTestData.VP9_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.VP9_VORBIS_AUDIO_REPRESENTATION_ID,
+            DashTestData.VP9_CDD_FIXED)
+        .run();
   }
 
   public void testVp9Adaptive() throws DecoderQueryException {
@@ -361,9 +238,14 @@ public void testVp9Adaptive() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_vp9_adaptive";
-    testDashPlayback(getActivity(), streamName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false,
-        MimeTypes.VIDEO_VP9, ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_vp9_adaptive")
+        .setManifestUrl(DashTestData.VP9_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setAudioVideoFormats(DashTestData.VP9_VORBIS_AUDIO_REPRESENTATION_ID,
+            DashTestData.VP9_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testVp9AdaptiveWithSeeking() throws DecoderQueryException {
@@ -371,10 +253,15 @@ public void testVp9AdaptiveWithSeeking() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_vp9_adaptive_with_seeking";
-    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, VP9_MANIFEST,
-        VORBIS_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_VP9, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        VP9_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_vp9_adaptive_with_seeking")
+        .setManifestUrl(DashTestData.VP9_MANIFEST)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(SEEKING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.VP9_VORBIS_AUDIO_REPRESENTATION_ID,
+            DashTestData.VP9_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testVp9AdaptiveWithRendererDisabling() throws DecoderQueryException {
@@ -382,10 +269,15 @@ public void testVp9AdaptiveWithRendererDisabling() throws DecoderQueryException
       // Pass.
       return;
     }
-    String streamName = "test_vp9_adaptive_with_renderer_disabling";
-    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
-        VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_VP9,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_vp9_adaptive_with_renderer_disabling")
+        .setManifestUrl(DashTestData.VP9_MANIFEST)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(RENDERER_DISABLING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.VP9_VORBIS_AUDIO_REPRESENTATION_ID,
+            DashTestData.VP9_CDD_ADAPTIVE)
+        .run();
   }
 
   // H264: Other frame-rates for output buffer count assertions.
@@ -396,9 +288,14 @@ public void test23FpsH264Fixed() {
       // Pass.
       return;
     }
-    String streamName = "test_23fps_h264_fixed";
-    testDashPlayback(getActivity(), streamName, H264_23_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        false, MimeTypes.VIDEO_H264, false, H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID);
+    testRunner
+        .setStreamName("test_23fps_h264_fixed")
+        .setManifestUrl(DashTestData.H264_23_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID)
+        .run();
   }
 
   // 24 fps.
@@ -407,9 +304,14 @@ public void test24FpsH264Fixed() {
       // Pass.
       return;
     }
-    String streamName = "test_24fps_h264_fixed";
-    testDashPlayback(getActivity(), streamName, H264_24_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        false, MimeTypes.VIDEO_H264, false, H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID);
+    testRunner
+        .setStreamName("test_24fps_h264_fixed")
+        .setManifestUrl(DashTestData.H264_24_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID)
+        .run();
   }
 
   // 29.97 fps.
@@ -418,9 +320,14 @@ public void test29FpsH264Fixed() {
       // Pass.
       return;
     }
-    String streamName = "test_29fps_h264_fixed";
-    testDashPlayback(getActivity(), streamName, H264_29_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        false, MimeTypes.VIDEO_H264, false, H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
+    testRunner
+        .setStreamName("test_29fps_h264_fixed")
+        .setManifestUrl(DashTestData.H264_29_MANIFEST)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID)
+        .run();
   }
 
   // Widevine encrypted media tests.
@@ -431,10 +338,15 @@ public void testWidevineH264Fixed() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_h264_fixed";
-    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_MANIFEST_PREFIX,
-        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264, false,
-        WIDEVINE_H264_CDD_FIXED);
+    testRunner
+        .setStreamName("test_widevine_h264_fixed")
+        .setManifestUrl(DashTestData.WIDEVINE_H264_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H264)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H264_CDD_FIXED)
+        .run();
   }
 
   public void testWidevineH264Adaptive() throws DecoderQueryException {
@@ -442,10 +354,15 @@ public void testWidevineH264Adaptive() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_h264_adaptive";
-    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_MANIFEST_PREFIX,
-        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H264_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_widevine_h264_adaptive")
+        .setManifestUrl(DashTestData.WIDEVINE_H264_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H264)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H264_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testWidevineH264AdaptiveWithSeeking() throws DecoderQueryException {
@@ -453,10 +370,16 @@ public void testWidevineH264AdaptiveWithSeeking() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_h264_adaptive_with_seeking";
-    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false,
-        WIDEVINE_H264_MANIFEST_PREFIX, WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true,
-        MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H264_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_widevine_h264_adaptive_with_seeking")
+        .setManifestUrl(DashTestData.WIDEVINE_H264_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H264)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(SEEKING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H264_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testWidevineH264AdaptiveWithRendererDisabling() throws DecoderQueryException {
@@ -464,10 +387,16 @@ public void testWidevineH264AdaptiveWithRendererDisabling() throws DecoderQueryE
       // Pass.
       return;
     }
-    String streamName = "test_widevine_h264_adaptive_with_renderer_disabling";
-    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
-        WIDEVINE_H264_MANIFEST_PREFIX, WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true,
-        MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H264_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_widevine_h264_adaptive_with_renderer_disabling")
+        .setManifestUrl(DashTestData.WIDEVINE_H264_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H264)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(RENDERER_DISABLING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H264_CDD_ADAPTIVE)
+        .run();
   }
 
   // H265 CDD.
@@ -477,10 +406,15 @@ public void testWidevineH265Fixed() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_h265_fixed";
-    testDashPlayback(getActivity(), streamName, WIDEVINE_H265_MANIFEST_PREFIX,
-        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H265, false,
-        WIDEVINE_H265_CDD_FIXED);
+    testRunner
+        .setStreamName("test_widevine_h265_fixed")
+        .setManifestUrl(DashTestData.WIDEVINE_H265_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H265)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H265_CDD_FIXED)
+        .run();
   }
 
   public void testWidevineH265Adaptive() throws DecoderQueryException {
@@ -488,10 +422,15 @@ public void testWidevineH265Adaptive() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_h265_adaptive";
-    testDashPlayback(getActivity(), streamName, WIDEVINE_H265_MANIFEST_PREFIX,
-        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H265,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H265_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_widevine_h265_adaptive")
+        .setManifestUrl(DashTestData.WIDEVINE_H265_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H265)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H265_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testWidevineH265AdaptiveWithSeeking() throws DecoderQueryException {
@@ -499,10 +438,16 @@ public void testWidevineH265AdaptiveWithSeeking() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_h265_adaptive_with_seeking";
-    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false,
-        WIDEVINE_H265_MANIFEST_PREFIX, WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true,
-        MimeTypes.VIDEO_H265, ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H265_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_widevine_h265_adaptive_with_seeking")
+        .setManifestUrl(DashTestData.WIDEVINE_H265_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H265)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(SEEKING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H265_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testWidevineH265AdaptiveWithRendererDisabling() throws DecoderQueryException {
@@ -510,10 +455,16 @@ public void testWidevineH265AdaptiveWithRendererDisabling() throws DecoderQueryE
       // Pass.
       return;
     }
-    String streamName = "test_widevine_h265_adaptive_with_renderer_disabling";
-    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
-        WIDEVINE_H265_MANIFEST_PREFIX, WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true,
-        MimeTypes.VIDEO_H265, ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H265_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_widevine_h265_adaptive_with_renderer_disabling")
+        .setManifestUrl(DashTestData.WIDEVINE_H265_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H265)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(RENDERER_DISABLING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H265_CDD_ADAPTIVE)
+        .run();
   }
 
   // VP9 (CDD).
@@ -523,10 +474,15 @@ public void testWidevineVp9Fixed360p() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_vp9_fixed_360p";
-    testDashPlayback(getActivity(), streamName, WIDEVINE_VP9_MANIFEST_PREFIX,
-        WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_VP9, false,
-        WIDEVINE_VP9_CDD_FIXED);
+    testRunner
+        .setStreamName("test_widevine_vp9_fixed_360p")
+        .setManifestUrl(DashTestData.WIDEVINE_VP9_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_VP9)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_VP9_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_VP9_CDD_FIXED)
+        .run();
   }
 
   public void testWidevineVp9Adaptive() throws DecoderQueryException {
@@ -534,10 +490,15 @@ public void testWidevineVp9Adaptive() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_vp9_adaptive";
-    testDashPlayback(getActivity(), streamName, WIDEVINE_VP9_MANIFEST_PREFIX,
-        WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_VP9,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_VP9_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_widevine_vp9_adaptive")
+        .setManifestUrl(DashTestData.WIDEVINE_VP9_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_VP9)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_VP9_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_VP9_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testWidevineVp9AdaptiveWithSeeking() throws DecoderQueryException {
@@ -545,10 +506,16 @@ public void testWidevineVp9AdaptiveWithSeeking() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_vp9_adaptive_with_seeking";
-    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false,
-        WIDEVINE_VP9_MANIFEST_PREFIX, WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID, true,
-        MimeTypes.VIDEO_VP9, ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_VP9_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_widevine_vp9_adaptive_with_seeking")
+        .setManifestUrl(DashTestData.WIDEVINE_VP9_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_VP9)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(SEEKING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_VP9_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_VP9_CDD_ADAPTIVE)
+        .run();
   }
 
   public void testWidevineVp9AdaptiveWithRendererDisabling() throws DecoderQueryException {
@@ -556,10 +523,16 @@ public void testWidevineVp9AdaptiveWithRendererDisabling() throws DecoderQueryEx
       // Pass.
       return;
     }
-    String streamName = "test_widevine_vp9_adaptive_with_renderer_disabling";
-    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
-        WIDEVINE_VP9_MANIFEST_PREFIX, WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID, true,
-        MimeTypes.VIDEO_VP9, ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_VP9_CDD_ADAPTIVE);
+    testRunner
+        .setStreamName("test_widevine_vp9_adaptive_with_renderer_disabling")
+        .setManifestUrl(DashTestData.WIDEVINE_VP9_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_VP9)
+        .setFullPlaybackNoSeeking(false)
+        .setCanIncludeAdditionalVideoFormats(true)
+        .setActionSchedule(RENDERER_DISABLING_SCHEDULE)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_VP9_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_VP9_CDD_ADAPTIVE)
+        .run();
   }
 
   // H264: Other frame-rates for output buffer count assertions.
@@ -570,10 +543,15 @@ public void testWidevine23FpsH264Fixed() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_23fps_h264_fixed";
-    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_23_MANIFEST_PREFIX,
-        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264, false,
-        WIDEVINE_H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID);
+    testRunner
+        .setStreamName("test_widevine_23fps_h264_fixed")
+        .setManifestUrl(DashTestData.WIDEVINE_H264_23_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H264)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID)
+        .run();
   }
 
   // 24 fps.
@@ -582,10 +560,15 @@ public void testWidevine24FpsH264Fixed() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_24fps_h264_fixed";
-    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_24_MANIFEST_PREFIX,
-        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264, false,
-        WIDEVINE_H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID);
+    testRunner
+        .setStreamName("test_widevine_24fps_h264_fixed")
+        .setManifestUrl(DashTestData.WIDEVINE_H264_24_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H264)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID)
+        .run();
   }
 
   // 29.97 fps.
@@ -594,46 +577,21 @@ public void testWidevine29FpsH264Fixed() throws DecoderQueryException {
       // Pass.
       return;
     }
-    String streamName = "test_widevine_29fps_h264_fixed";
-    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_29_MANIFEST_PREFIX,
-        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264, false,
-        WIDEVINE_H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
+    testRunner
+        .setStreamName("test_widevine_29fps_h264_fixed")
+        .setManifestUrl(DashTestData.WIDEVINE_H264_29_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H264)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID)
+        .run();
   }
 
   // Internal.
 
-  private void testDashPlayback(HostActivity activity, String streamName, String manifestFileName,
-      String audioFormat, boolean isWidevineEncrypted, String videoMimeType,
-      boolean canIncludeAdditionalVideoFormats, String... videoFormats) {
-    testDashPlayback(activity, streamName, null, true, manifestFileName, audioFormat,
-        isWidevineEncrypted, videoMimeType, canIncludeAdditionalVideoFormats, videoFormats);
-  }
-
-  private void testDashPlayback(HostActivity activity, String streamName,
-      ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking, String manifestFileName,
-      String audioFormat, boolean isWidevineEncrypted, String videoMimeType,
-      boolean canIncludeAdditionalVideoFormats, String... videoFormats) {
-    MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG,
-        REPORT_NAME, REPORT_OBJECT_NAME);
-    String manifestPath = MANIFEST_URL_PREFIX + manifestFileName;
-    DashHostedTest test = new DashHostedTest(streamName, manifestPath, metricsLogger,
-        fullPlaybackNoSeeking, audioFormat, isWidevineEncrypted, videoMimeType,
-        canIncludeAdditionalVideoFormats, false, actionSchedule, videoFormats);
-    activity.runTest(test, TEST_TIMEOUT_MS);
-    // Retry test exactly once if adaptive test fails due to excessive dropped buffers when playing
-    // non-CDD required formats (b/28220076).
-    if (test.needsCddLimitedRetry) {
-      metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG, REPORT_NAME,
-          REPORT_OBJECT_NAME);
-      test = new DashHostedTest(streamName, manifestPath, metricsLogger, fullPlaybackNoSeeking,
-          audioFormat, isWidevineEncrypted, videoMimeType, false, true, actionSchedule,
-          videoFormats);
-      activity.runTest(test, TEST_TIMEOUT_MS);
-    }
-  }
-
   private static boolean shouldSkipAdaptiveTest(String mimeType) throws DecoderQueryException {
-    MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(mimeType, false, false);
+    MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(mimeType, false);
     assertNotNull(decoderInfo);
     if (decoderInfo.adaptive) {
       return false;
@@ -642,251 +600,4 @@ private static boolean shouldSkipAdaptiveTest(String mimeType) throws DecoderQue
     return true;
   }
 
-  @TargetApi(16)
-  private static class DashHostedTest extends ExoHostedTest {
-
-    private final String streamName;
-    private final String videoMimeType;
-    private final String manifestPath;
-    private final MetricsLogger metricsLogger;
-    private final boolean fullPlaybackNoSeeking;
-    private final boolean isCddLimitedRetry;
-    private final boolean isWidevineEncrypted;
-    private final DashTestTrackSelector trackSelector;
-
-    private boolean needsCddLimitedRetry;
-    private boolean needsSecureVideoDecoder;
-
-    /**
-     * @param streamName The name of the test stream for metric logging.
-     * @param manifestPath The manifest path.
-     * @param metricsLogger Logger to log metrics from the test.
-     * @param fullPlaybackNoSeeking Whether the test will play the entire source with no seeking.
-     * @param audioFormat The audio format.
-     * @param isWidevineEncrypted Whether the video is Widevine encrypted.
-     * @param videoMimeType The video mime type.
-     * @param canIncludeAdditionalVideoFormats Whether to use video formats in addition to those
-     *     listed in the videoFormats argument, if the device is capable of playing them.
-     * @param isCddLimitedRetry Whether this is a CDD limited retry following a previous failure.
-     * @param actionSchedule The action schedule for the test.
-     * @param videoFormats The video formats.
-     */
-    public DashHostedTest(String streamName, String manifestPath, MetricsLogger metricsLogger,
-        boolean fullPlaybackNoSeeking, String audioFormat, boolean isWidevineEncrypted,
-        String videoMimeType, boolean canIncludeAdditionalVideoFormats, boolean isCddLimitedRetry,
-        ActionSchedule actionSchedule, String... videoFormats) {
-      super(TAG, fullPlaybackNoSeeking);
-      Assertions.checkArgument(!(isCddLimitedRetry && canIncludeAdditionalVideoFormats));
-      this.streamName = streamName;
-      this.manifestPath = manifestPath;
-      this.metricsLogger = metricsLogger;
-      this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
-      this.isWidevineEncrypted = isWidevineEncrypted;
-      this.videoMimeType = videoMimeType;
-      this.isCddLimitedRetry = isCddLimitedRetry;
-      trackSelector = new DashTestTrackSelector(audioFormat, videoFormats,
-          canIncludeAdditionalVideoFormats);
-      if (actionSchedule != null) {
-        setSchedule(actionSchedule);
-      }
-    }
-
-    @Override
-    protected MappingTrackSelector buildTrackSelector(HostActivity host,
-        BandwidthMeter bandwidthMeter) {
-      return trackSelector;
-    }
-
-    @Override
-    @TargetApi(18)
-    @SuppressWarnings("ResourceType")
-    protected final StreamingDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(
-        final String userAgent) {
-      StreamingDrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
-      if (isWidevineEncrypted) {
-        try {
-          // Force L3 if secure decoder is not available.
-          boolean forceL3Widevine =
-              MediaCodecUtil.getDecoderInfo(videoMimeType, true, false) == null;
-          MediaDrm mediaDrm = new MediaDrm(WIDEVINE_UUID);
-          String securityProperty = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
-          String widevineContentId = forceL3Widevine ? WIDEVINE_SW_CRYPTO_CONTENT_ID
-              : WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty)
-              ? WIDEVINE_HW_SECURE_DECODE_CONTENT_ID : WIDEVINE_SW_CRYPTO_CONTENT_ID;
-          HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(
-              WIDEVINE_LICENSE_URL + widevineContentId,
-              new DefaultHttpDataSourceFactory(userAgent));
-          drmSessionManager = StreamingDrmSessionManager.newWidevineInstance(drmCallback, null,
-              null, null);
-          if (forceL3Widevine && !WIDEVINE_SECURITY_LEVEL_3.equals(securityProperty)) {
-            drmSessionManager.setPropertyString(SECURITY_LEVEL_PROPERTY, WIDEVINE_SECURITY_LEVEL_3);
-          }
-          // Check if secure video decoder is required.
-          securityProperty = drmSessionManager.getPropertyString(SECURITY_LEVEL_PROPERTY);
-          needsSecureVideoDecoder = WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty);
-        } catch (MediaCodecUtil.DecoderQueryException | UnsupportedSchemeException
-            | UnsupportedDrmException e) {
-          throw new IllegalStateException(e);
-        }
-      }
-      return drmSessionManager;
-    }
-
-    @Override
-    protected SimpleExoPlayer buildExoPlayer(HostActivity host, Surface surface,
-        MappingTrackSelector trackSelector,
-        DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
-      SimpleExoPlayer player = new DebugSimpleExoPlayer(host, trackSelector,
-          new DefaultLoadControl(), drmSessionManager);
-      player.setVideoSurface(surface);
-      return player;
-    }
-
-    @Override
-    protected MediaSource buildSource(HostActivity host, String userAgent,
-        TransferListener<? super DataSource> mediaTransferListener) {
-      DataSource.Factory manifestDataSourceFactory = new DefaultDataSourceFactory(host, userAgent);
-      DataSource.Factory mediaDataSourceFactory = new DefaultDataSourceFactory(host, userAgent,
-          mediaTransferListener);
-      String manifestUrl = manifestPath;
-      manifestUrl += isWidevineEncrypted ? (needsSecureVideoDecoder ? WIDEVINE_L1_SUFFIX
-          : WIDEVINE_L3_SUFFIX) : "";
-      Uri manifestUri = Uri.parse(manifestUrl);
-      DefaultDashChunkSource.Factory chunkSourceFactory = new DefaultDashChunkSource.Factory(
-          mediaDataSourceFactory);
-      return new DashMediaSource(manifestUri, manifestDataSourceFactory, chunkSourceFactory,
-          MIN_LOADABLE_RETRY_COUNT, 0 /* livePresentationDelayMs */, null, null);
-    }
-
-    @Override
-    protected void logMetrics(DecoderCounters audioCounters, DecoderCounters videoCounters) {
-      metricsLogger.logMetric(MetricsLogger.KEY_TEST_NAME, streamName);
-      metricsLogger.logMetric(MetricsLogger.KEY_IS_CDD_LIMITED_RETRY, isCddLimitedRetry);
-      metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_DROPPED_COUNT,
-          videoCounters.droppedOutputBufferCount);
-      metricsLogger.logMetric(MetricsLogger.KEY_MAX_CONSECUTIVE_FRAMES_DROPPED_COUNT,
-          videoCounters.maxConsecutiveDroppedOutputBufferCount);
-      metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_SKIPPED_COUNT,
-          videoCounters.skippedOutputBufferCount);
-      metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_RENDERED_COUNT,
-          videoCounters.renderedOutputBufferCount);
-      metricsLogger.close();
-    }
-
-    @Override
-    protected void assertPassed(DecoderCounters audioCounters, DecoderCounters videoCounters) {
-      if (fullPlaybackNoSeeking) {
-        // We shouldn't have skipped any output buffers.
-        DecoderCountersUtil.assertSkippedOutputBufferCount(AUDIO_TAG, audioCounters, 0);
-        DecoderCountersUtil.assertSkippedOutputBufferCount(VIDEO_TAG, videoCounters, 0);
-        // We allow one fewer output buffer due to the way that MediaCodecRenderer and the
-        // underlying decoders handle the end of stream. This should be tightened up in the future.
-        DecoderCountersUtil.assertTotalOutputBufferCount(AUDIO_TAG, audioCounters,
-            audioCounters.inputBufferCount - 1, audioCounters.inputBufferCount);
-        DecoderCountersUtil.assertTotalOutputBufferCount(VIDEO_TAG, videoCounters,
-            videoCounters.inputBufferCount - 1, videoCounters.inputBufferCount);
-      }
-      try {
-        int droppedFrameLimit = (int) Math.ceil(MAX_DROPPED_VIDEO_FRAME_FRACTION
-            * DecoderCountersUtil.getTotalOutputBuffers(videoCounters));
-        // Assert that performance is acceptable.
-        // Assert that total dropped frames were within limit.
-        DecoderCountersUtil.assertDroppedOutputBufferLimit(VIDEO_TAG, videoCounters,
-            droppedFrameLimit);
-        // Assert that consecutive dropped frames were within limit.
-        DecoderCountersUtil.assertConsecutiveDroppedOutputBufferLimit(VIDEO_TAG, videoCounters,
-            MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES);
-      } catch (AssertionFailedError e) {
-        if (trackSelector.includedAdditionalVideoFormats) {
-          // Retry limiting to CDD mandated formats (b/28220076).
-          Log.e(TAG, "Too many dropped or consecutive dropped frames.", e);
-          needsCddLimitedRetry = true;
-        } else {
-          throw e;
-        }
-      }
-    }
-
-  }
-
-  private static final class DashTestTrackSelector extends MappingTrackSelector {
-
-    private final String audioFormatId;
-    private final String[] videoFormatIds;
-    private final boolean canIncludeAdditionalVideoFormats;
-
-    public boolean includedAdditionalVideoFormats;
-
-    private DashTestTrackSelector(String audioFormatId, String[] videoFormatIds,
-        boolean canIncludeAdditionalVideoFormats) {
-      this.audioFormatId = audioFormatId;
-      this.videoFormatIds = videoFormatIds;
-      this.canIncludeAdditionalVideoFormats = canIncludeAdditionalVideoFormats;
-    }
-
-    @Override
-    protected TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
-        TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
-        throws ExoPlaybackException {
-      Assertions.checkState(rendererCapabilities[VIDEO_RENDERER_INDEX].getTrackType()
-          == C.TRACK_TYPE_VIDEO);
-      Assertions.checkState(rendererCapabilities[AUDIO_RENDERER_INDEX].getTrackType()
-          == C.TRACK_TYPE_AUDIO);
-      Assertions.checkState(rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].length == 1);
-      Assertions.checkState(rendererTrackGroupArrays[AUDIO_RENDERER_INDEX].length == 1);
-      TrackSelection[] selections = new TrackSelection[rendererCapabilities.length];
-      selections[VIDEO_RENDERER_INDEX] = new RandomTrackSelection(
-          rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
-          getTrackIndices(rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
-              rendererFormatSupports[VIDEO_RENDERER_INDEX][0], videoFormatIds,
-              canIncludeAdditionalVideoFormats),
-          0 /* seed */);
-      selections[AUDIO_RENDERER_INDEX] = new FixedTrackSelection(
-          rendererTrackGroupArrays[AUDIO_RENDERER_INDEX].get(0),
-          getTrackIndex(rendererTrackGroupArrays[AUDIO_RENDERER_INDEX].get(0), audioFormatId));
-      includedAdditionalVideoFormats =
-          selections[VIDEO_RENDERER_INDEX].length() > videoFormatIds.length;
-      return selections;
-    }
-
-    private static int[] getTrackIndices(TrackGroup trackGroup, int[] formatSupport,
-        String[] formatIds, boolean canIncludeAdditionalFormats) {
-      List<Integer> trackIndices = new ArrayList<>();
-
-      // Always select explicitly listed representations.
-      for (String formatId : formatIds) {
-        trackIndices.add(getTrackIndex(trackGroup, formatId));
-      }
-
-      // Select additional video representations, if supported by the device.
-      if (canIncludeAdditionalFormats) {
-        for (int i = 0; i < trackGroup.length; i++) {
-          if (!trackIndices.contains(i) && isFormatHandled(formatSupport[i])) {
-            Log.d(TAG, "Adding video format: " + trackGroup.getFormat(i).id);
-            trackIndices.add(i);
-          }
-        }
-      }
-
-      int[] trackIndicesArray = Util.toArray(trackIndices);
-      Arrays.sort(trackIndicesArray);
-      return trackIndicesArray;
-    }
-
-    private static int getTrackIndex(TrackGroup trackGroup, String formatId) {
-      for (int i = 0; i < trackGroup.length; i++) {
-        if (trackGroup.getFormat(i).id.equals(formatId)) {
-          return i;
-        }
-      }
-      throw new IllegalStateException("Format " + formatId + " not found.");
-    }
-
-    private static boolean isFormatHandled(int formatSupport) {
-      return (formatSupport & RendererCapabilities.FORMAT_SUPPORT_MASK)
-          == RendererCapabilities.FORMAT_HANDLED;
-    }
-
-  }
-
 }
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestData.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestData.java
new file mode 100644
index 0000000000..91e0c163b1
--- /dev/null
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestData.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.playbacktests.gts;
+
+import com.google.android.exoplayer2.util.Util;
+
+/**
+ * Test data for {@link DashTest} and {@link DashWidevineOfflineTest).
+ */
+public final class DashTestData {
+
+  private static final String BASE_URL = "https://storage.googleapis.com/exoplayer-test-media-1/"
+      + "gen-4/screens/dash-vod-single-segment/";
+  // Clear content manifests.
+  public static final String H264_MANIFEST = BASE_URL + "manifest-h264.mpd";
+  public static final String H265_MANIFEST = BASE_URL + "manifest-h265.mpd";
+  public static final String VP9_MANIFEST = BASE_URL + "manifest-vp9.mpd";
+  public static final String H264_23_MANIFEST = BASE_URL + "manifest-h264-23.mpd";
+  public static final String H264_24_MANIFEST = BASE_URL + "manifest-h264-24.mpd";
+  public static final String H264_29_MANIFEST = BASE_URL + "manifest-h264-29.mpd";
+  // Widevine encrypted content manifests.
+  public static final String WIDEVINE_H264_MANIFEST = BASE_URL + "manifest-h264-enc.mpd";
+  public static final String WIDEVINE_H265_MANIFEST = BASE_URL + "manifest-h265-enc.mpd";
+  public static final String WIDEVINE_VP9_MANIFEST = BASE_URL + "manifest-vp9-enc.mpd";
+  public static final String WIDEVINE_H264_23_MANIFEST = BASE_URL + "manifest-h264-23-enc.mpd";
+  public static final String WIDEVINE_H264_24_MANIFEST = BASE_URL + "manifest-h264-24-enc.mpd";
+  public static final String WIDEVINE_H264_29_MANIFEST = BASE_URL + "manifest-h264-29-enc.mpd";
+
+  public static final String AAC_AUDIO_REPRESENTATION_ID = "141";
+  public static final String H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "avc-baseline-240";
+  public static final String H264_BASELINE_480P_VIDEO_REPRESENTATION_ID = "avc-baseline-480";
+  public static final String H264_MAIN_240P_VIDEO_REPRESENTATION_ID = "avc-main-240";
+  public static final String H264_MAIN_480P_VIDEO_REPRESENTATION_ID = "avc-main-480";
+  // The highest quality H264 format mandated by the Android CDD.
+  public static final String H264_CDD_FIXED = Util.SDK_INT < 23
+      ? H264_BASELINE_480P_VIDEO_REPRESENTATION_ID : H264_MAIN_480P_VIDEO_REPRESENTATION_ID;
+  // Multiple H264 formats mandated by the Android CDD. Note: The CDD actually mandated main profile
+  // support from API level 23, but we opt to test only from 24 due to known issues on API level 23
+  // when switching between baseline and main profiles on certain devices.
+  public static final String[] H264_CDD_ADAPTIVE = Util.SDK_INT < 24
+      ? new String[] {
+          H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
+          H264_BASELINE_480P_VIDEO_REPRESENTATION_ID}
+      : new String[] {
+          H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
+          H264_BASELINE_480P_VIDEO_REPRESENTATION_ID,
+          H264_MAIN_240P_VIDEO_REPRESENTATION_ID,
+          H264_MAIN_480P_VIDEO_REPRESENTATION_ID};
+
+  public static final String H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID =
+      "avc-baseline-480-23";
+  public static final String H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID =
+      "avc-baseline-480-24";
+  public static final String H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID =
+      "avc-baseline-480-29";
+
+  public static final String H265_BASELINE_288P_VIDEO_REPRESENTATION_ID = "hevc-main-288";
+  public static final String H265_BASELINE_360P_VIDEO_REPRESENTATION_ID = "hevc-main-360";
+  // The highest quality H265 format mandated by the Android CDD.
+  public static final String H265_CDD_FIXED = H265_BASELINE_360P_VIDEO_REPRESENTATION_ID;
+  // Multiple H265 formats mandated by the Android CDD.
+  public static final String[] H265_CDD_ADAPTIVE =
+      new String[] {
+          H265_BASELINE_288P_VIDEO_REPRESENTATION_ID,
+          H265_BASELINE_360P_VIDEO_REPRESENTATION_ID};
+
+  public static final String VP9_VORBIS_AUDIO_REPRESENTATION_ID = "4";
+  public static final String VP9_180P_VIDEO_REPRESENTATION_ID = "0";
+  public static final String VP9_360P_VIDEO_REPRESENTATION_ID = "1";
+  // The highest quality VP9 format mandated by the Android CDD.
+  public static final String VP9_CDD_FIXED = VP9_360P_VIDEO_REPRESENTATION_ID;
+  // Multiple VP9 formats mandated by the Android CDD.
+  public static final String[] VP9_CDD_ADAPTIVE =
+      new String[] {
+          VP9_180P_VIDEO_REPRESENTATION_ID,
+          VP9_360P_VIDEO_REPRESENTATION_ID};
+
+  // Widevine encrypted content representation ids.
+  public static final String WIDEVINE_AAC_AUDIO_REPRESENTATION_ID = "0";
+  public static final String WIDEVINE_H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "2";
+  public static final String WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID = "3";
+  public static final String WIDEVINE_H264_MAIN_240P_VIDEO_REPRESENTATION_ID = "4";
+  public static final String WIDEVINE_H264_MAIN_480P_VIDEO_REPRESENTATION_ID = "5";
+  // The highest quality H264 format mandated by the Android CDD.
+  public static final String WIDEVINE_H264_CDD_FIXED = Util.SDK_INT < 23
+      ? WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID
+      : WIDEVINE_H264_MAIN_480P_VIDEO_REPRESENTATION_ID;
+  // Multiple H264 formats mandated by the Android CDD. Note: The CDD actually mandated main profile
+  // support from API level 23, but we opt to test only from 24 due to known issues on API level 23
+  // when switching between baseline and main profiles on certain devices.
+  public static final String[] WIDEVINE_H264_CDD_ADAPTIVE = Util.SDK_INT < 24
+      ? new String[] {
+          WIDEVINE_H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
+          WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID}
+      : new String[] {
+          WIDEVINE_H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
+          WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID,
+          WIDEVINE_H264_MAIN_240P_VIDEO_REPRESENTATION_ID,
+          WIDEVINE_H264_MAIN_480P_VIDEO_REPRESENTATION_ID};
+
+  public static final String WIDEVINE_H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID = "3";
+  public static final String WIDEVINE_H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID = "3";
+  public static final String WIDEVINE_H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID = "3";
+
+  public static final String WIDEVINE_H265_BASELINE_288P_VIDEO_REPRESENTATION_ID = "2";
+  public static final String WIDEVINE_H265_BASELINE_360P_VIDEO_REPRESENTATION_ID = "3";
+  // The highest quality H265 format mandated by the Android CDD.
+  public static final String WIDEVINE_H265_CDD_FIXED =
+      WIDEVINE_H265_BASELINE_360P_VIDEO_REPRESENTATION_ID;
+  // Multiple H265 formats mandated by the Android CDD.
+  public static final String[] WIDEVINE_H265_CDD_ADAPTIVE =
+      new String[] {
+          WIDEVINE_H265_BASELINE_288P_VIDEO_REPRESENTATION_ID,
+          WIDEVINE_H265_BASELINE_360P_VIDEO_REPRESENTATION_ID};
+
+  public static final String WIDEVINE_VP9_AAC_AUDIO_REPRESENTATION_ID = "0";
+  public static final String WIDEVINE_VP9_180P_VIDEO_REPRESENTATION_ID = "2";
+  public static final String WIDEVINE_VP9_360P_VIDEO_REPRESENTATION_ID = "3";
+  // The highest quality VP9 format mandated by the Android CDD.
+  public static final String WIDEVINE_VP9_CDD_FIXED = WIDEVINE_VP9_360P_VIDEO_REPRESENTATION_ID;
+  // Multiple VP9 formats mandated by the Android CDD.
+  public static final String[] WIDEVINE_VP9_CDD_ADAPTIVE =
+      new String[] {
+          WIDEVINE_VP9_180P_VIDEO_REPRESENTATION_ID,
+          WIDEVINE_VP9_360P_VIDEO_REPRESENTATION_ID};
+
+  private static final String WIDEVINE_LICENSE_URL =
+      "https://proxy.uat.widevine.com/proxy?provider=widevine_test&video_id=";
+  private static final String WIDEVINE_SW_CRYPTO_CONTENT_ID = "exoplayer_test_1";
+  private static final String WIDEVINE_HW_SECURE_DECODE_CONTENT_ID = "exoplayer_test_2";
+
+  public static String getWidevineLicenseUrl(boolean useL1Widevine) {
+    return WIDEVINE_LICENSE_URL
+        + (useL1Widevine ? WIDEVINE_HW_SECURE_DECODE_CONTENT_ID : WIDEVINE_SW_CRYPTO_CONTENT_ID);
+  }
+
+  private DashTestData() {
+  }
+
+}
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
new file mode 100644
index 0000000000..6374fd97a9
--- /dev/null
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
@@ -0,0 +1,459 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.playbacktests.gts;
+
+import static com.google.android.exoplayer2.C.WIDEVINE_UUID;
+
+import android.annotation.TargetApi;
+import android.app.Instrumentation;
+import android.media.MediaDrm;
+import android.media.UnsupportedSchemeException;
+import android.net.Uri;
+import android.util.Log;
+import android.view.Surface;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.DefaultLoadControl;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.decoder.DecoderCounters;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
+import com.google.android.exoplayer2.drm.MediaDrmCallback;
+import com.google.android.exoplayer2.drm.UnsupportedDrmException;
+import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
+import com.google.android.exoplayer2.playbacktests.util.ActionSchedule;
+import com.google.android.exoplayer2.playbacktests.util.DebugSimpleExoPlayer;
+import com.google.android.exoplayer2.playbacktests.util.DecoderCountersUtil;
+import com.google.android.exoplayer2.playbacktests.util.ExoHostedTest;
+import com.google.android.exoplayer2.playbacktests.util.HostActivity;
+import com.google.android.exoplayer2.playbacktests.util.HostActivity.HostedTest;
+import com.google.android.exoplayer2.playbacktests.util.MetricsLogger;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.dash.DashMediaSource;
+import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
+import com.google.android.exoplayer2.trackselection.FixedTrackSelection;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
+import com.google.android.exoplayer2.trackselection.RandomTrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import junit.framework.AssertionFailedError;
+
+/** {@link DashHostedTest} builder. */
+public final class DashTestRunner {
+
+  static final int VIDEO_RENDERER_INDEX = 0;
+  static final int AUDIO_RENDERER_INDEX = 1;
+
+  private static final long TEST_TIMEOUT_MS = 5 * 60 * 1000;
+
+  private static final String REPORT_NAME = "GtsExoPlayerTestCases";
+  private static final String REPORT_OBJECT_NAME = "playbacktest";
+
+  // Whether adaptive tests should enable video formats beyond those mandated by the Android CDD
+  // if the device advertises support for them.
+  private static final boolean ALLOW_ADDITIONAL_VIDEO_FORMATS = Util.SDK_INT >= 24;
+
+  private static final String AUDIO_TAG_SUFFIX = ":Audio";
+  private static final String VIDEO_TAG_SUFFIX = ":Video";
+
+  private static final int MIN_LOADABLE_RETRY_COUNT = 10;
+  private static final int MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES = 10;
+  private static final float MAX_DROPPED_VIDEO_FRAME_FRACTION = 0.01f;
+
+  private static final String WIDEVINE_SECURITY_LEVEL_1 = "L1";
+  private static final String WIDEVINE_SECURITY_LEVEL_3 = "L3";
+  private static final String SECURITY_LEVEL_PROPERTY = "securityLevel";
+
+  private final String tag;
+  private final HostActivity activity;
+  private final Instrumentation instrumentation;
+
+  private String streamName;
+  private boolean fullPlaybackNoSeeking;
+  private String audioFormat;
+  private boolean canIncludeAdditionalVideoFormats;
+  private ActionSchedule actionSchedule;
+  private byte[] offlineLicenseKeySetId;
+  private String[] videoFormats;
+  private String manifestUrl;
+  private boolean useL1Widevine;
+  private String widevineLicenseUrl;
+  private DataSource.Factory dataSourceFactory;
+
+  @TargetApi(18)
+  @SuppressWarnings("ResourceType")
+  public static boolean isL1WidevineAvailable(String mimeType) {
+    try {
+      // Force L3 if secure decoder is not available.
+      if (MediaCodecUtil.getDecoderInfo(mimeType, true) == null) {
+        return false;
+      }
+      MediaDrm mediaDrm = new MediaDrm(WIDEVINE_UUID);
+      String securityProperty = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
+      mediaDrm.release();
+      return WIDEVINE_SECURITY_LEVEL_1.equals(securityProperty);
+    } catch (MediaCodecUtil.DecoderQueryException | UnsupportedSchemeException e) {
+      throw new IllegalStateException(e);
+    }
+  }
+
+  public DashTestRunner(String tag, HostActivity activity, Instrumentation instrumentation) {
+    this.tag = tag;
+    this.activity = activity;
+    this.instrumentation = instrumentation;
+  }
+
+  public DashTestRunner setStreamName(String streamName) {
+    this.streamName = streamName;
+    return this;
+  }
+
+  public DashTestRunner setFullPlaybackNoSeeking(boolean fullPlaybackNoSeeking) {
+    this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
+    return this;
+  }
+
+  public DashTestRunner setCanIncludeAdditionalVideoFormats(
+      boolean canIncludeAdditionalVideoFormats) {
+    this.canIncludeAdditionalVideoFormats = canIncludeAdditionalVideoFormats
+        && ALLOW_ADDITIONAL_VIDEO_FORMATS;
+    return this;
+  }
+
+  public DashTestRunner setActionSchedule(ActionSchedule actionSchedule) {
+    this.actionSchedule = actionSchedule;
+    return this;
+  }
+
+  public DashTestRunner setOfflineLicenseKeySetId(byte[] offlineLicenseKeySetId) {
+    this.offlineLicenseKeySetId = offlineLicenseKeySetId;
+    return this;
+  }
+
+  public DashTestRunner setAudioVideoFormats(String audioFormat, String... videoFormats) {
+    this.audioFormat = audioFormat;
+    this.videoFormats = videoFormats;
+    return this;
+  }
+
+  public DashTestRunner setManifestUrl(String manifestUrl) {
+    this.manifestUrl = manifestUrl;
+    return this;
+  }
+
+  public DashTestRunner setWidevineMimeType(String mimeType) {
+    this.useL1Widevine = isL1WidevineAvailable(mimeType);
+    this.widevineLicenseUrl = DashTestData.getWidevineLicenseUrl(useL1Widevine);
+    return this;
+  }
+
+  public DashTestRunner setDataSourceFactory(DataSource.Factory dataSourceFactory) {
+    this.dataSourceFactory = dataSourceFactory;
+    return this;
+  }
+
+  public void run() {
+    DashHostedTest test = createDashHostedTest(canIncludeAdditionalVideoFormats, false,
+        instrumentation);
+    activity.runTest(test, TEST_TIMEOUT_MS);
+    // Retry test exactly once if adaptive test fails due to excessive dropped buffers when
+    // playing non-CDD required formats (b/28220076).
+    if (test.needsCddLimitedRetry) {
+      activity.runTest(createDashHostedTest(false, true, instrumentation), TEST_TIMEOUT_MS);
+    }
+  }
+
+  private DashHostedTest createDashHostedTest(boolean canIncludeAdditionalVideoFormats,
+      boolean isCddLimitedRetry, Instrumentation instrumentation) {
+    MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(instrumentation, tag,
+        REPORT_NAME, REPORT_OBJECT_NAME);
+    return new DashHostedTest(tag, streamName, manifestUrl, metricsLogger, fullPlaybackNoSeeking,
+        audioFormat, canIncludeAdditionalVideoFormats, isCddLimitedRetry, actionSchedule,
+        offlineLicenseKeySetId, widevineLicenseUrl, useL1Widevine, dataSourceFactory,
+        videoFormats);
+  }
+
+  /**
+   * A {@link HostedTest} for DASH playback tests.
+   */
+  @TargetApi(16)
+  private static final class DashHostedTest extends ExoHostedTest {
+
+    private final String streamName;
+    private final String manifestUrl;
+    private final MetricsLogger metricsLogger;
+    private final boolean fullPlaybackNoSeeking;
+    private final boolean isCddLimitedRetry;
+    private final DashTestTrackSelector trackSelector;
+    private final byte[] offlineLicenseKeySetId;
+    private final String widevineLicenseUrl;
+    private final boolean useL1Widevine;
+    private final DataSource.Factory dataSourceFactory;
+
+    private boolean needsCddLimitedRetry;
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param streamName The name of the test stream for metric logging.
+     * @param manifestUrl The manifest url.
+     * @param metricsLogger Logger to log metrics from the test.
+     * @param fullPlaybackNoSeeking Whether the test will play the entire source with no seeking.
+     * @param audioFormat The audio format.
+     * @param canIncludeAdditionalVideoFormats Whether to use video formats in addition to those
+     *     listed in the videoFormats argument, if the device is capable of playing them.
+     * @param isCddLimitedRetry Whether this is a CDD limited retry following a previous failure.
+     * @param actionSchedule The action schedule for the test.
+     * @param offlineLicenseKeySetId The key set id of the license to be used.
+     * @param widevineLicenseUrl If the video is Widevine encrypted, this is the license url
+     *     otherwise null.
+     * @param useL1Widevine Whether to use L1 Widevine.
+     * @param dataSourceFactory If not null, used to load manifest and media.
+     * @param videoFormats The video formats.
+     */
+    private DashHostedTest(String tag, String streamName, String manifestUrl,
+        MetricsLogger metricsLogger, boolean fullPlaybackNoSeeking, String audioFormat,
+        boolean canIncludeAdditionalVideoFormats, boolean isCddLimitedRetry,
+        ActionSchedule actionSchedule, byte[] offlineLicenseKeySetId, String widevineLicenseUrl,
+        boolean useL1Widevine, DataSource.Factory dataSourceFactory, String... videoFormats) {
+      super(tag, fullPlaybackNoSeeking);
+      Assertions.checkArgument(!(isCddLimitedRetry && canIncludeAdditionalVideoFormats));
+      this.streamName = streamName;
+      this.manifestUrl = manifestUrl;
+      this.metricsLogger = metricsLogger;
+      this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
+      this.isCddLimitedRetry = isCddLimitedRetry;
+      this.offlineLicenseKeySetId = offlineLicenseKeySetId;
+      this.widevineLicenseUrl = widevineLicenseUrl;
+      this.useL1Widevine = useL1Widevine;
+      this.dataSourceFactory = dataSourceFactory;
+      trackSelector = new DashTestTrackSelector(tag, audioFormat, videoFormats,
+          canIncludeAdditionalVideoFormats);
+      if (actionSchedule != null) {
+        setSchedule(actionSchedule);
+      }
+    }
+
+    @Override
+    protected MappingTrackSelector buildTrackSelector(HostActivity host,
+        BandwidthMeter bandwidthMeter) {
+      return trackSelector;
+    }
+
+    @Override
+    protected DefaultDrmSessionManager<FrameworkMediaCrypto> buildDrmSessionManager(
+        final String userAgent) {
+      if (widevineLicenseUrl == null) {
+        return null;
+      }
+      try {
+        MediaDrmCallback drmCallback = new HttpMediaDrmCallback(widevineLicenseUrl,
+            new DefaultHttpDataSourceFactory(userAgent));
+        DefaultDrmSessionManager<FrameworkMediaCrypto> drmSessionManager =
+            DefaultDrmSessionManager.newWidevineInstance(drmCallback, null, null, null);
+        if (!useL1Widevine) {
+          drmSessionManager.setPropertyString(
+              SECURITY_LEVEL_PROPERTY, WIDEVINE_SECURITY_LEVEL_3);
+        }
+        if (offlineLicenseKeySetId != null) {
+          drmSessionManager.setMode(DefaultDrmSessionManager.MODE_PLAYBACK,
+              offlineLicenseKeySetId);
+        }
+        return drmSessionManager;
+      } catch (UnsupportedDrmException e) {
+        throw new IllegalStateException(e);
+      }
+    }
+
+    @Override
+    protected SimpleExoPlayer buildExoPlayer(HostActivity host, Surface surface,
+        MappingTrackSelector trackSelector,
+        DrmSessionManager<FrameworkMediaCrypto> drmSessionManager) {
+      SimpleExoPlayer player = new DebugSimpleExoPlayer(host, trackSelector,
+          new DefaultLoadControl(), drmSessionManager);
+      player.setVideoSurface(surface);
+      return player;
+    }
+
+    @Override
+    protected MediaSource buildSource(HostActivity host, String userAgent,
+        TransferListener<? super DataSource> mediaTransferListener) {
+      DataSource.Factory manifestDataSourceFactory = dataSourceFactory != null
+          ? dataSourceFactory : new DefaultDataSourceFactory(host, userAgent);
+      DataSource.Factory mediaDataSourceFactory = dataSourceFactory != null
+          ? dataSourceFactory
+          : new DefaultDataSourceFactory(host, userAgent, mediaTransferListener);
+      Uri manifestUri = Uri.parse(manifestUrl);
+      DefaultDashChunkSource.Factory chunkSourceFactory = new DefaultDashChunkSource.Factory(
+          mediaDataSourceFactory);
+      return new DashMediaSource(manifestUri, manifestDataSourceFactory, chunkSourceFactory,
+          MIN_LOADABLE_RETRY_COUNT, 0 /* livePresentationDelayMs */, null, null);
+    }
+
+    @Override
+    protected void logMetrics(DecoderCounters audioCounters, DecoderCounters videoCounters) {
+      metricsLogger.logMetric(MetricsLogger.KEY_TEST_NAME, streamName);
+      metricsLogger.logMetric(MetricsLogger.KEY_IS_CDD_LIMITED_RETRY, isCddLimitedRetry);
+      metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_DROPPED_COUNT,
+          videoCounters.droppedOutputBufferCount);
+      metricsLogger.logMetric(MetricsLogger.KEY_MAX_CONSECUTIVE_FRAMES_DROPPED_COUNT,
+          videoCounters.maxConsecutiveDroppedOutputBufferCount);
+      metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_SKIPPED_COUNT,
+          videoCounters.skippedOutputBufferCount);
+      metricsLogger.logMetric(MetricsLogger.KEY_FRAMES_RENDERED_COUNT,
+          videoCounters.renderedOutputBufferCount);
+      metricsLogger.close();
+    }
+
+    @Override
+    protected void assertPassed(DecoderCounters audioCounters, DecoderCounters videoCounters) {
+      if (fullPlaybackNoSeeking) {
+        // We shouldn't have skipped any output buffers.
+        DecoderCountersUtil
+            .assertSkippedOutputBufferCount(tag + AUDIO_TAG_SUFFIX, audioCounters, 0);
+        DecoderCountersUtil
+            .assertSkippedOutputBufferCount(tag + VIDEO_TAG_SUFFIX, videoCounters, 0);
+        // We allow one fewer output buffer due to the way that MediaCodecRenderer and the
+        // underlying decoders handle the end of stream. This should be tightened up in the future.
+        DecoderCountersUtil.assertTotalOutputBufferCount(tag + AUDIO_TAG_SUFFIX, audioCounters,
+            audioCounters.inputBufferCount - 1, audioCounters.inputBufferCount);
+        DecoderCountersUtil.assertTotalOutputBufferCount(tag + VIDEO_TAG_SUFFIX, videoCounters,
+            videoCounters.inputBufferCount - 1, videoCounters.inputBufferCount);
+      }
+      try {
+        int droppedFrameLimit = (int) Math.ceil(MAX_DROPPED_VIDEO_FRAME_FRACTION
+            * DecoderCountersUtil.getTotalOutputBuffers(videoCounters));
+        // Assert that performance is acceptable.
+        // Assert that total dropped frames were within limit.
+        DecoderCountersUtil.assertDroppedOutputBufferLimit(tag + VIDEO_TAG_SUFFIX, videoCounters,
+            droppedFrameLimit);
+        // Assert that consecutive dropped frames were within limit.
+        DecoderCountersUtil.assertConsecutiveDroppedOutputBufferLimit(tag + VIDEO_TAG_SUFFIX,
+            videoCounters, MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES);
+      } catch (AssertionFailedError e) {
+        if (trackSelector.includedAdditionalVideoFormats) {
+          // Retry limiting to CDD mandated formats (b/28220076).
+          Log.e(tag, "Too many dropped or consecutive dropped frames.", e);
+          needsCddLimitedRetry = true;
+        } else {
+          throw e;
+        }
+      }
+    }
+
+  }
+
+  private static final class DashTestTrackSelector extends MappingTrackSelector {
+
+    private final String tag;
+    private final String audioFormatId;
+    private final String[] videoFormatIds;
+    private final boolean canIncludeAdditionalVideoFormats;
+
+    public boolean includedAdditionalVideoFormats;
+
+    private DashTestTrackSelector(String tag, String audioFormatId, String[] videoFormatIds,
+        boolean canIncludeAdditionalVideoFormats) {
+      this.tag = tag;
+      this.audioFormatId = audioFormatId;
+      this.videoFormatIds = videoFormatIds;
+      this.canIncludeAdditionalVideoFormats = canIncludeAdditionalVideoFormats;
+    }
+
+    @Override
+    protected TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
+        TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
+        throws ExoPlaybackException {
+      Assertions.checkState(rendererCapabilities[VIDEO_RENDERER_INDEX].getTrackType()
+          == C.TRACK_TYPE_VIDEO);
+      Assertions.checkState(rendererCapabilities[AUDIO_RENDERER_INDEX].getTrackType()
+          == C.TRACK_TYPE_AUDIO);
+      Assertions.checkState(rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].length == 1);
+      Assertions.checkState(rendererTrackGroupArrays[AUDIO_RENDERER_INDEX].length == 1);
+      TrackSelection[] selections = new TrackSelection[rendererCapabilities.length];
+      selections[VIDEO_RENDERER_INDEX] = new RandomTrackSelection(
+          rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
+          getVideoTrackIndices(rendererTrackGroupArrays[VIDEO_RENDERER_INDEX].get(0),
+              rendererFormatSupports[VIDEO_RENDERER_INDEX][0], videoFormatIds,
+              canIncludeAdditionalVideoFormats),
+          0 /* seed */);
+      selections[AUDIO_RENDERER_INDEX] = new FixedTrackSelection(
+          rendererTrackGroupArrays[AUDIO_RENDERER_INDEX].get(0),
+          getTrackIndex(rendererTrackGroupArrays[AUDIO_RENDERER_INDEX].get(0), audioFormatId));
+      includedAdditionalVideoFormats =
+          selections[VIDEO_RENDERER_INDEX].length() > videoFormatIds.length;
+      return selections;
+    }
+
+    private int[] getVideoTrackIndices(TrackGroup trackGroup, int[] formatSupport,
+        String[] formatIds, boolean canIncludeAdditionalFormats) {
+      List<Integer> trackIndices = new ArrayList<>();
+
+      // Always select explicitly listed representations.
+      for (String formatId : formatIds) {
+        int trackIndex = getTrackIndex(trackGroup, formatId);
+        Log.d(tag, "Adding base video format: "
+            + Format.toLogString(trackGroup.getFormat(trackIndex)));
+        trackIndices.add(trackIndex);
+      }
+
+      // Select additional video representations, if supported by the device.
+      if (canIncludeAdditionalFormats) {
+        for (int i = 0; i < trackGroup.length; i++) {
+          if (!trackIndices.contains(i) && isFormatHandled(formatSupport[i])) {
+            Log.d(tag, "Adding extra video format: "
+                + Format.toLogString(trackGroup.getFormat(i)));
+            trackIndices.add(i);
+          }
+        }
+      }
+
+      int[] trackIndicesArray = Util.toArray(trackIndices);
+      Arrays.sort(trackIndicesArray);
+      return trackIndicesArray;
+    }
+
+    private static int getTrackIndex(TrackGroup trackGroup, String formatId) {
+      for (int i = 0; i < trackGroup.length; i++) {
+        if (trackGroup.getFormat(i).id.equals(formatId)) {
+          return i;
+        }
+      }
+      throw new IllegalStateException("Format " + formatId + " not found.");
+    }
+
+    private static boolean isFormatHandled(int formatSupport) {
+      return (formatSupport & RendererCapabilities.FORMAT_SUPPORT_MASK)
+          == RendererCapabilities.FORMAT_HANDLED;
+    }
+
+  }
+
+}
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
new file mode 100644
index 0000000000..99a6f3bef5
--- /dev/null
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.playbacktests.gts;
+
+import android.media.MediaDrm.MediaDrmStateException;
+import android.test.ActivityInstrumentationTestCase2;
+import android.util.Pair;
+import com.google.android.exoplayer2.drm.DrmSession.DrmSessionException;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.drm.OfflineLicenseHelper;
+import com.google.android.exoplayer2.playbacktests.util.ActionSchedule;
+import com.google.android.exoplayer2.playbacktests.util.HostActivity;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+import junit.framework.Assert;
+
+/**
+ * Tests Widevine encrypted DASH playbacks using offline keys.
+ */
+public final class DashWidevineOfflineTest extends ActivityInstrumentationTestCase2<HostActivity> {
+
+  private static final String TAG = "DashWidevineOfflineTest";
+  private static final String USER_AGENT = "ExoPlayerPlaybackTests";
+
+  private DashTestRunner testRunner;
+  private DefaultHttpDataSourceFactory httpDataSourceFactory;
+  private OfflineLicenseHelper<FrameworkMediaCrypto> offlineLicenseHelper;
+  private byte[] offlineLicenseKeySetId;
+
+  public DashWidevineOfflineTest() {
+    super(HostActivity.class);
+  }
+
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    testRunner = new DashTestRunner(TAG, getActivity(), getInstrumentation())
+        .setStreamName("test_widevine_h264_fixed_offline")
+        .setManifestUrl(DashTestData.WIDEVINE_H264_MANIFEST)
+        .setWidevineMimeType(MimeTypes.VIDEO_H264)
+        .setFullPlaybackNoSeeking(true)
+        .setCanIncludeAdditionalVideoFormats(false)
+        .setAudioVideoFormats(DashTestData.WIDEVINE_AAC_AUDIO_REPRESENTATION_ID,
+            DashTestData.WIDEVINE_H264_CDD_FIXED);
+
+    boolean useL1Widevine = DashTestRunner.isL1WidevineAvailable(MimeTypes.VIDEO_H264);
+    String widevineLicenseUrl = DashTestData.getWidevineLicenseUrl(useL1Widevine);
+    httpDataSourceFactory = new DefaultHttpDataSourceFactory(USER_AGENT);
+    offlineLicenseHelper = OfflineLicenseHelper.newWidevineInstance(widevineLicenseUrl,
+        httpDataSourceFactory);
+  }
+
+  @Override
+  protected void tearDown() throws Exception {
+    testRunner = null;
+    if (offlineLicenseKeySetId != null) {
+      releaseLicense();
+    }
+    if (offlineLicenseHelper != null) {
+      offlineLicenseHelper.releaseResources();
+    }
+    offlineLicenseHelper = null;
+    httpDataSourceFactory = null;
+    super.tearDown();
+  }
+
+  // Offline license tests
+
+  public void testWidevineOfflineLicense() throws Exception {
+    if (Util.SDK_INT < 22) {
+      return; // Pass.
+    }
+    downloadLicense();
+    testRunner.run();
+
+    // Renew license after playback should still work
+    offlineLicenseKeySetId = offlineLicenseHelper.renew(offlineLicenseKeySetId);
+    Assert.assertNotNull(offlineLicenseKeySetId);
+  }
+
+  public void testWidevineOfflineReleasedLicense() throws Throwable {
+    if (Util.SDK_INT < 22) {
+      return; // Pass.
+    }
+    downloadLicense();
+    releaseLicense(); // keySetId no longer valid.
+
+    try {
+      testRunner.run();
+      fail("Playback should fail because the license has been released.");
+    } catch (Throwable e) {
+      // Get the root cause
+      while (true) {
+        Throwable cause = e.getCause();
+        if (cause == null || cause == e) {
+          break;
+        }
+        e = cause;
+      }
+      // It should be a MediaDrmStateException instance
+      if (!(e instanceof MediaDrmStateException)) {
+        throw e;
+      }
+    }
+  }
+
+  public void testWidevineOfflineExpiredLicense() throws Exception {
+    if (Util.SDK_INT < 22) {
+      return; // Pass.
+    }
+    downloadLicense();
+
+    // Wait until the license expires
+    long licenseDuration =
+        offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId).first;
+    assertTrue("License duration should be less than 30 sec. "
+        + "Server settings might have changed.", licenseDuration < 30);
+    while (licenseDuration > 0) {
+      synchronized (this) {
+        wait(licenseDuration * 1000 + 2000);
+      }
+      long previousDuration = licenseDuration;
+      licenseDuration =
+          offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId).first;
+      assertTrue("License duration should be decreasing.", previousDuration > licenseDuration);
+    }
+
+    // DefaultDrmSessionManager should renew the license and stream play fine
+    testRunner.run();
+  }
+
+  public void testWidevineOfflineLicenseExpiresOnPause() throws Exception {
+    if (Util.SDK_INT < 22) {
+      return; // Pass.
+    }
+    downloadLicense();
+
+    // During playback pause until the license expires then continue playback
+    Pair<Long, Long> licenseDurationRemainingSec =
+        offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+    long licenseDuration = licenseDurationRemainingSec.first;
+    assertTrue("License duration should be less than 30 sec. "
+        + "Server settings might have changed.", licenseDuration < 30);
+    ActionSchedule schedule = new ActionSchedule.Builder(TAG)
+        .delay(3000).pause().delay(licenseDuration * 1000 + 2000).play().build();
+
+    // DefaultDrmSessionManager should renew the license and stream play fine
+    testRunner.setActionSchedule(schedule).run();
+  }
+
+  private void downloadLicense() throws InterruptedException, DrmSessionException, IOException {
+    offlineLicenseKeySetId = offlineLicenseHelper.download(
+        httpDataSourceFactory.createDataSource(), DashTestData.WIDEVINE_H264_MANIFEST);
+    Assert.assertNotNull(offlineLicenseKeySetId);
+    Assert.assertTrue(offlineLicenseKeySetId.length > 0);
+    testRunner.setOfflineLicenseKeySetId(offlineLicenseKeySetId);
+  }
+
+  private void releaseLicense() throws DrmSessionException {
+    offlineLicenseHelper.release(offlineLicenseKeySetId);
+    offlineLicenseKeySetId = null;
+  }
+
+}
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java
index e279bc8ae8..c530ab63c1 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/DebugSimpleExoPlayer.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.os.Handler;
 import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.LoadControl;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.SimpleExoPlayer;
@@ -66,16 +67,14 @@ protected void buildVideoRenderers(Context context, Handler mainHandler,
     private int startIndex;
     private int queueSize;
     private int bufferCount;
+    private int minimumInsertIndex;
 
     public DebugMediaCodecVideoRenderer(Context context, MediaCodecSelector mediaCodecSelector,
         long allowedJoiningTimeMs, Handler eventHandler,
         DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
-        VideoRendererEventListener eventListener,
-        int maxDroppedFrameCountToNotify) {
+        VideoRendererEventListener eventListener, int maxDroppedFrameCountToNotify) {
       super(context, mediaCodecSelector, allowedJoiningTimeMs, drmSessionManager, false,
           eventHandler, eventListener, maxDroppedFrameCountToNotify);
-      startIndex = 0;
-      queueSize = 0;
     }
 
     @Override
@@ -90,14 +89,24 @@ protected void flushCodec() throws ExoPlaybackException {
       clearTimestamps();
     }
 
+    @Override
+    protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
+      super.onInputFormatChanged(newFormat);
+      // Ensure timestamps of buffers queued after this format change are never inserted into the
+      // queue of expected output timestamps before those of buffers that have already been queued.
+      minimumInsertIndex = startIndex + queueSize;
+    }
+
     @Override
     protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
+      super.onQueueInputBuffer(buffer);
       insertTimestamp(buffer.timeUs);
       maybeShiftTimestampsList();
     }
 
     @Override
     protected void onProcessedOutputBuffer(long presentationTimeUs) {
+      super.onProcessedOutputBuffer(presentationTimeUs);
       bufferCount++;
       long expectedTimestampUs = dequeueTimestamp();
       if (expectedTimestampUs != presentationTimeUs) {
@@ -111,10 +120,11 @@ private void clearTimestamps() {
       startIndex = 0;
       queueSize = 0;
       bufferCount = 0;
+      minimumInsertIndex = 0;
     }
 
     private void insertTimestamp(long presentationTimeUs) {
-      for (int i = startIndex + queueSize - 1; i >= startIndex; i--) {
+      for (int i = startIndex + queueSize - 1; i >= minimumInsertIndex; i--) {
         if (presentationTimeUs >= timestampsList[i]) {
           timestampsList[i + 1] = presentationTimeUs;
           queueSize++;
@@ -122,20 +132,22 @@ private void insertTimestamp(long presentationTimeUs) {
         }
         timestampsList[i + 1] = timestampsList[i];
       }
-      timestampsList[startIndex] = presentationTimeUs;
+      timestampsList[minimumInsertIndex] = presentationTimeUs;
       queueSize++;
     }
 
     private void maybeShiftTimestampsList() {
       if (startIndex + queueSize == ARRAY_SIZE) {
         System.arraycopy(timestampsList, startIndex, timestampsList, 0, queueSize);
+        minimumInsertIndex -= startIndex;
         startIndex = 0;
       }
     }
 
     private long dequeueTimestamp() {
-      startIndex++;
       queueSize--;
+      startIndex++;
+      minimumInsertIndex = Math.max(minimumInsertIndex, startIndex);
       return timestampsList[startIndex - 1];
     }
 
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java
index dfecdd236a..87c55e9248 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer2/playbacktests/util/ExoHostedTest.java
@@ -34,7 +34,7 @@
 import com.google.android.exoplayer2.playbacktests.util.HostActivity.HostedTest;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.AdaptiveVideoTrackSelection;
+import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
@@ -63,7 +63,8 @@
   public static final long EXPECTED_PLAYING_TIME_MEDIA_DURATION_MS = -2;
   public static final long EXPECTED_PLAYING_TIME_UNSET = -1;
 
-  private final String tag;
+  protected final String tag;
+
   private final boolean failOnPlayerError;
   private final long expectedPlayingTimeMs;
   private final DecoderCounters videoDecoderCounters;
@@ -247,7 +248,7 @@ public void onAudioDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onAudioInputFormatChanged(Format format) {
-    Log.d(tag, "audioFormatChanged [" + format.id + "]");
+    Log.d(tag, "audioFormatChanged [" + Format.toLogString(format) + "]");
   }
 
   @Override
@@ -277,7 +278,7 @@ public void onVideoDecoderInitialized(String decoderName, long elapsedRealtimeMs
 
   @Override
   public void onVideoInputFormatChanged(Format format) {
-    Log.d(tag, "videoFormatChanged [" + format.id + "]");
+    Log.d(tag, "videoFormatChanged [" + Format.toLogString(format) + "]");
   }
 
   @Override
@@ -312,7 +313,7 @@ public void onRenderedFirstFrame(Surface surface) {
   @SuppressWarnings("unused")
   protected MappingTrackSelector buildTrackSelector(HostActivity host,
       BandwidthMeter bandwidthMeter) {
-    return new DefaultTrackSelector(new AdaptiveVideoTrackSelection.Factory(bandwidthMeter));
+    return new DefaultTrackSelector(new AdaptiveTrackSelection.Factory(bandwidthMeter));
   }
 
   @SuppressWarnings("unused")
diff --git a/publish.gradle b/publish.gradle
new file mode 100644
index 0000000000..17214959ab
--- /dev/null
+++ b/publish.gradle
@@ -0,0 +1,24 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply plugin: 'bintray-release'
+
+publish {
+    artifactId = releaseArtifact
+    description = releaseDescription
+    repoName = releaseRepoName
+    userOrg = releaseUserOrg
+    groupId = releaseGroupId
+    version = releaseVersion
+    website = releaseWebsite
+}
diff --git a/settings.gradle b/settings.gradle
index 8500dc6af7..b69c134fc4 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -15,20 +15,21 @@ include ':library'
 include ':testutils'
 include ':demo'
 include ':playbacktests'
+include ':extension-ffmpeg'
+include ':extension-flac'
+include ':extension-gvr'
+include ':extension-okhttp'
 include ':extension-opus'
 include ':extension-vp9'
-include ':extension-okhttp'
-include ':extension-flac'
-include ':extension-ffmpeg'
 // Uncomment the following line to use the Cronet Extension.
 // include ':extension-cronet'
 
-
+project(':extension-ffmpeg').projectDir = new File(settingsDir, 'extensions/ffmpeg')
+project(':extension-flac').projectDir = new File(settingsDir, 'extensions/flac')
+project(':extension-gvr').projectDir = new File(settingsDir, 'extensions/gvr')
+project(':extension-okhttp').projectDir = new File(settingsDir, 'extensions/okhttp')
 project(':extension-opus').projectDir = new File(settingsDir, 'extensions/opus')
 project(':extension-vp9').projectDir = new File(settingsDir, 'extensions/vp9')
-project(':extension-okhttp').projectDir = new File(settingsDir, 'extensions/okhttp')
-project(':extension-flac').projectDir = new File(settingsDir, 'extensions/flac')
-project(':extension-ffmpeg').projectDir = new File(settingsDir, 'extensions/ffmpeg')
 // Uncomment the following line to use the Cronet Extension.
 // See extensions/cronet/README.md for details.
 // project(':extension-cronet').projectDir = new File(settingsDir, 'extensions/cronet')
diff --git a/testutils/build.gradle b/testutils/build.gradle
index 61bb50f74d..a97c743384 100644
--- a/testutils/build.gradle
+++ b/testutils/build.gradle
@@ -1,3 +1,16 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
 apply plugin: 'com.android.library'
 
 android {
@@ -5,16 +18,9 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
+        minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
-
-    buildTypes {
-        release {
-            minifyEnabled false
-            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
-        }
-    }
 }
 
 dependencies {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
index 3716c6d37f..ee8927ea21 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
@@ -47,13 +47,13 @@ public FakeExtractorOutput() {
   }
 
   @Override
-  public FakeTrackOutput track(int trackId) {
-    FakeTrackOutput output = trackOutputs.get(trackId);
+  public FakeTrackOutput track(int id, int type) {
+    FakeTrackOutput output = trackOutputs.get(id);
     if (output == null) {
       Assert.assertFalse(tracksEnded);
       numberOfTracks++;
       output = new FakeTrackOutput();
-      trackOutputs.put(trackId, output);
+      trackOutputs.put(id, output);
     }
     return output;
   }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
index 7f6187f16b..75a4a01923 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.app.Instrumentation;
-import android.content.Context;
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -25,7 +24,6 @@
 import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
-import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Arrays;
@@ -300,21 +298,79 @@ public static FakeExtractorOutput assertOutput(Extractor extractor, String sampl
     return extractorOutput;
   }
 
-  public static void recursiveDelete(File fileOrDirectory) {
-    if (fileOrDirectory.isDirectory()) {
-      for (File child : fileOrDirectory.listFiles()) {
-        recursiveDelete(child);
-      }
-    }
-    fileOrDirectory.delete();
+  /**
+   * Calls {@link #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)} with all
+   * possible combinations of "simulate" parameters.
+   *
+   * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
+   *     class which is to be tested.
+   * @param sampleFile The path to the input sample.
+   * @param instrumentation To be used to load the sample file.
+   * @param expectedThrowable Expected {@link Throwable} class.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   * @see #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)
+   */
+  public static void assertThrows(ExtractorFactory factory, String sampleFile,
+      Instrumentation instrumentation, Class<? extends Throwable> expectedThrowable)
+      throws IOException, InterruptedException {
+    byte[] fileData = getByteArray(instrumentation, sampleFile);
+    assertThrows(factory, fileData, expectedThrowable);
   }
 
-  /** Creates an empty folder in the application specific cache directory. */
-  public static File createTempFolder(Context context) throws IOException {
-    File tempFolder = File.createTempFile("ExoPlayerTest", null, context.getCacheDir());
-    Assert.assertTrue(tempFolder.delete());
-    Assert.assertTrue(tempFolder.mkdir());
-    return tempFolder;
+  /**
+   * Calls {@link #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)} with all
+   * possible combinations of "simulate" parameters.
+   *
+   * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
+   *     class which is to be tested.
+   * @param fileData Content of the input file.
+   * @param expectedThrowable Expected {@link Throwable} class.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   * @see #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)
+   */
+  public static void assertThrows(ExtractorFactory factory, byte[] fileData,
+      Class<? extends Throwable> expectedThrowable) throws IOException, InterruptedException {
+    assertThrows(factory.create(), fileData, expectedThrowable, false, false, false);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true, false, false);
+    assertThrows(factory.create(), fileData, expectedThrowable, false,  true, false);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true,  true, false);
+    assertThrows(factory.create(), fileData, expectedThrowable, false, false,  true);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true, false,  true);
+    assertThrows(factory.create(), fileData, expectedThrowable, false,  true,  true);
+    assertThrows(factory.create(), fileData, expectedThrowable,  true,  true,  true);
+  }
+
+  /**
+   * Asserts {@code extractor} throws {@code expectedThrowable} while consuming {@code sampleFile}.
+   *
+   * @param extractor The {@link Extractor} to be tested.
+   * @param fileData Content of the input file.
+   * @param expectedThrowable Expected {@link Throwable} class.
+   * @param simulateIOErrors If true simulates IOErrors.
+   * @param simulateUnknownLength If true simulates unknown input length.
+   * @param simulatePartialReads If true simulates partial reads.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   */
+  public static void assertThrows(Extractor extractor, byte[] fileData,
+      Class<? extends Throwable> expectedThrowable, boolean simulateIOErrors,
+      boolean simulateUnknownLength, boolean simulatePartialReads) throws IOException,
+      InterruptedException {
+    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(fileData)
+        .setSimulateIOErrors(simulateIOErrors)
+        .setSimulateUnknownLength(simulateUnknownLength)
+        .setSimulatePartialReads(simulatePartialReads).build();
+    try {
+      consumeTestData(extractor, input, 0, true);
+      throw new AssertionError(expectedThrowable.getSimpleName() + " expected but not thrown");
+    } catch (Throwable throwable) {
+      if (expectedThrowable.equals(throwable.getClass())) {
+        return; // Pass!
+      }
+      throw throwable;
+    }
   }
 
 }
