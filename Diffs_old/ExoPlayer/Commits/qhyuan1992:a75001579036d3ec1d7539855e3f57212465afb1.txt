diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
index 27e90bf008..468baaee16 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
@@ -31,10 +31,10 @@
   private final DataSource dataSource;
   private final long streamLength;
 
-  private long position;
-  private byte[] peekBuffer;
-  private int peekBufferPosition;
-  private int peekBufferLength;
+  private long position; // read的position
+  private byte[] peekBuffer; // peek的数据的缓冲区
+  private int peekBufferPosition; // peek的数据在peek数据缓冲区的位置
+  private int peekBufferLength; // peek的数据的长度
 
   /**
    * @param dataSource The wrapped {@link DataSource}.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index 3c471f9a0e..8544b16584 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -199,8 +199,11 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
   }
 
   private final ExtractorHolder extractorHolder;
+  // 内存分配器：分配Allocation
   private final Allocator allocator;
+  // 这个值用于限制Allocator分配的内存的上限，超过上限就wait直到有新的空间
   private final int requestedBufferSize;
+  // trunk集合，键为trunk的id，值为TrackOutput，包含了音频或视频的所有信息
   private final SparseArray<InternalTrackOutput> sampleQueues;
   private final int minLoadableRetryCount;
   private final Uri uri;
@@ -593,7 +596,7 @@ public void onLoadError(Loadable ignored, IOException e) {
   }
 
   // ExtractorOutput implementation.
-
+  // 获得某个轨道的TrackOutput
   @Override
   public TrackOutput track(int id) {
     InternalTrackOutput sampleQueue = sampleQueues.get(id);
@@ -604,11 +607,13 @@ public TrackOutput track(int id) {
     return sampleQueue;
   }
 
+  // 通知track创建完成
   @Override
   public void endTracks() {
     tracksBuilt = true;
   }
 
+  // 通知seek表创建完成
   @Override
   public void seekMap(SeekMap seekMap) {
     this.seekMap = seekMap;
@@ -777,6 +782,7 @@ public void sampleMetadata(long timeUs, int flags, int size, int offset, byte[]
 
   /**
    * Loads the media stream and extracts sample data from it.
+   * Loadable实现，主要实现load方法进行加载
    */
   private static class ExtractingLoadable implements Loadable {
 
@@ -813,6 +819,7 @@ public boolean isLoadCanceled() {
       return loadCanceled;
     }
 
+    // Loadable在load时就是从文件解析音视频字节流的过程
     @Override
     public void load() throws IOException, InterruptedException {
       int result = Extractor.RESULT_CONTINUE;
@@ -831,7 +838,9 @@ public void load() throws IOException, InterruptedException {
             pendingExtractorSeek = false;
           }
           while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+            // allocator分配所有空间大于requestedBufferSize则wait
             allocator.blockWhileTotalBytesAllocatedExceeds(requestedBufferSize);
+            // 解析的过程中 allocator 会分配新的buffer
             result = extractor.read(input, positionHolder);
             // TODO: Implement throttling to stop us from buffering data too often.
           }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
index f13bf07140..ea839347c0 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
@@ -35,10 +35,10 @@
   private static final int INITIAL_SCRATCH_SIZE = 32;
 
   private final Allocator allocator;
-  private final int allocationLength; // 每个Allocation的最大字节数
+  private final int allocationLength; // 每个Allocation的最大字节数，固定长度，64
 
   private final InfoQueue infoQueue; // 维护所有的sample的信息 里面用数组承载所有的sample
-  private final LinkedBlockingDeque<Allocation> dataQueue; // 队列包含所有的sample
+  private final LinkedBlockingDeque<Allocation> dataQueue; // 队列包含所有的sample，Allocation
   private final SampleExtrasHolder extrasHolder;
   private final ParsableByteArray scratch;
 
@@ -48,7 +48,7 @@
   // Accessed only by the loading thread.
   private long totalBytesWritten;
   private Allocation lastAllocation; // 最后一个Allocation
-  private int lastAllocationOffset;
+  private int lastAllocationOffset; // 占用的字节buffer在当前Allocation的偏移
 
   /**
    * @param allocator An {@link Allocator} from which allocations for sample data can be obtained.
@@ -451,16 +451,21 @@ private int prepareForAppend(int length) {
 
     private int capacity;
 
+    // sample的索引和对应的sample在rolling buffer中的position的关系
     private long[] offsets;
+    // sample的索引和对应的sample的大小
     private int[] sizes;
+    // sample的索引和对应的sample的flag：是否是关键帧
     private int[] flags;
+    // sample的索引和对应的sample的pts
     private long[] timesUs;
     private byte[][] encryptionKeys;
 
-    private int queueSize;
-    private int absoluteReadIndex;
-    private int relativeReadIndex;
-    private int relativeWriteIndex;
+    private int queueSize; // 队列中有几个sample；也就是写端的index
+    // 因为在播放过程中总会维持个平衡，读出来的buffer也会被消费
+    private int absoluteReadIndex; // 数组实现的环形队列；这个标识真正的当前sample的索引
+    private int relativeReadIndex; // 在这个数组中的读索引
+    private int relativeWriteIndex; // 在这个数组中的写索引
 
     public InfoQueue() {
       capacity = SAMPLE_CAPACITY_INCREMENT;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java
index eafaaf87a6..fa9b5fc21d 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/FlvExtractor.java
@@ -32,18 +32,18 @@
 
   // Header sizes.
   private static final int FLV_HEADER_SIZE = 9;
-  private static final int FLV_TAG_HEADER_SIZE = 11;
+  private static final int FLV_TAG_HEADER_SIZE = 11; // tag头部，2-4字节表示tag后面的内容
 
   // Parser states.
-  private static final int STATE_READING_FLV_HEADER = 1;
-  private static final int STATE_SKIPPING_TO_TAG_HEADER = 2;
-  private static final int STATE_READING_TAG_HEADER = 3;
-  private static final int STATE_READING_TAG_DATA = 4;
+  private static final int STATE_READING_FLV_HEADER = 1; // 目前在解析FLV文件头
+  private static final int STATE_SKIPPING_TO_TAG_HEADER = 2; // 跳到下一个TAG头
+  private static final int STATE_READING_TAG_HEADER = 3; // 在解析TAG头
+  private static final int STATE_READING_TAG_DATA = 4; // 在解析TAG数据
 
   // Tag types.
-  private static final int TAG_TYPE_AUDIO = 8;
-  private static final int TAG_TYPE_VIDEO = 9;
-  private static final int TAG_TYPE_SCRIPT_DATA = 18;
+  private static final int TAG_TYPE_AUDIO = 8; // 音频
+  private static final int TAG_TYPE_VIDEO = 9; // 视频
+  private static final int TAG_TYPE_SCRIPT_DATA = 18; // 脚本
 
   // FLV container identifier.
   private static final int FLV_TAG = Util.getIntegerCodeForString("FLV");
@@ -59,10 +59,10 @@
 
   // State variables.
   private int parserState;
-  private int bytesToNextTagHeader;
-  public int tagType;
-  public int tagDataSize;
-  public long tagTimestampUs;
+  private int bytesToNextTagHeader; // 到下一个Tag Header的字节数
+  public int tagType; // tag类型
+  public int tagDataSize; // tag的数据区长度
+  public long tagTimestampUs; // tag的时间戳
 
   // Tags readers.
   private AudioTagPayloadReader audioReader;
@@ -179,8 +179,8 @@ private boolean readFlvHeader(ExtractorInput input) throws IOException, Interrup
     if (metadataReader == null) {
       metadataReader = new ScriptTagPayloadReader(null);
     }
-    extractorOutput.endTracks();
-    extractorOutput.seekMap(this);
+    extractorOutput.endTracks(); // track创建完成
+    extractorOutput.seekMap(this); // SeekMap已经创建好了，后面才能根据这个进行seek
 
     // We need to skip any additional content in the FLV header, plus the 4 byte previous tag size.
     bytesToNextTagHeader = headerBuffer.readInt() - FLV_HEADER_SIZE + 4;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
index ef63e3e45e..a1389ed667 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
@@ -26,11 +26,16 @@
 
   private static final int AVAILABLE_EXTRA_CAPACITY = 100;
 
+  // 每个Allocation的size大小
   private final int individualAllocationSize;
+  // 初始化时分配的buffer，包括
   private final byte[] initialAllocationBlock;
 
+  // 分配了的个数
   private int allocatedCount;
+  // 可用的个数，即前availableCount个已经分配了buffer
   private int availableCount;
+  // 池子的总大小
   private Allocation[] availableAllocations;
 
   /**
@@ -80,13 +85,17 @@ public synchronized Allocation allocate() {
     return allocation;
   }
 
+  /**
+   * 释放buffer，Allocation
+   * @param allocation The {@link Allocation} being returned.
+   */
   @Override
   public synchronized void release(Allocation allocation) {
     // Weak sanity check that the allocation probably originated from this pool.
     Assertions.checkArgument(allocation.data == initialAllocationBlock
         || allocation.data.length == individualAllocationSize);
     allocatedCount--;
-    if (availableCount == availableAllocations.length) {
+    if (availableCount == availableAllocations.length) { // 池子满了，扩容
       availableAllocations = Arrays.copyOf(availableAllocations, availableAllocations.length * 2);
     }
     availableAllocations[availableCount++] = allocation;
@@ -96,7 +105,7 @@ public synchronized void release(Allocation allocation) {
 
   @Override
   public synchronized void release(Allocation[] allocations) {
-    if (availableCount + allocations.length >= availableAllocations.length) {
+    if (availableCount + allocations.length >= availableAllocations.length) { // 扩容
       availableAllocations = Arrays.copyOf(
           availableAllocations, Math.max(
               availableAllocations.length * 2,
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java b/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java
index d7f105d720..cd04c9bdf8 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/Loader.java
@@ -28,6 +28,7 @@
 
 /**
  * Manages the background loading of {@link Loadable}s.
+ * Loader用于加载Loadable，Loadable在load时就是从文件解析音视频字节流的过程
  */
 public final class Loader {
 
@@ -44,6 +45,7 @@ public UnexpectedLoaderException(Exception cause) {
 
   /**
    * Interface definition of an object that can be loaded using a {@link Loader}.
+   * 定义了一个[可加载]的资源的基本接口
    */
   public interface Loadable {
 
@@ -219,6 +221,7 @@ public void run() {
         executorThread = Thread.currentThread();
         if (!loadable.isLoadCanceled()) {
           TraceUtil.beginSection(loadable.getClass().getSimpleName() + ".load()");
+          // 子线程load loadable所制定的资源
           loadable.load();
           TraceUtil.endSection();
         }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index 59597a155f..1c9f01d845 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -24,10 +24,10 @@
  */
 public final class ParsableByteArray {
 
-  public byte[] data;
+  public byte[] data; // 数据
 
-  private int position;
-  private int limit;
+  private int position; // 当前为重
+  private int limit;  // 有效范围，可能比data length小
 
   /** Creates a new instance that initially has no backing data. */
   public ParsableByteArray() {}
