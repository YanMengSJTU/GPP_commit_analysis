diff --git a/library/src/androidTest/java/com/google/android/exoplayer/util/ReusableBufferedOutputStreamTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/ReusableBufferedOutputStreamTest.java
new file mode 100644
index 0000000000..9c8a78e0b9
--- /dev/null
+++ b/library/src/androidTest/java/com/google/android/exoplayer/util/ReusableBufferedOutputStreamTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import android.test.MoreAsserts;
+import java.io.ByteArrayOutputStream;
+import junit.framework.TestCase;
+
+/**
+ * Tests {@link ReusableBufferedOutputStream}.
+ */
+public class ReusableBufferedOutputStreamTest extends TestCase {
+
+  private static final byte[] TEST_DATA_1 = "test data 1".getBytes();
+  private static final byte[] TEST_DATA_2 = "2 test data".getBytes();
+
+  public void testReset() throws Exception {
+    ByteArrayOutputStream byteArrayOutputStream1 = new ByteArrayOutputStream(1000);
+    ReusableBufferedOutputStream outputStream = new ReusableBufferedOutputStream(
+        byteArrayOutputStream1, 1000);
+    outputStream.write(TEST_DATA_1);
+    outputStream.close();
+
+    ByteArrayOutputStream byteArrayOutputStream2 = new ByteArrayOutputStream(1000);
+    outputStream.reset(byteArrayOutputStream2);
+    outputStream.write(TEST_DATA_2);
+    outputStream.close();
+
+    MoreAsserts.assertEquals(TEST_DATA_1, byteArrayOutputStream1.toByteArray());
+    MoreAsserts.assertEquals(TEST_DATA_2, byteArrayOutputStream2.toByteArray());
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContentIndex.java b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContentIndex.java
index 66ac8d0b29..966a4ede9c 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContentIndex.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/cache/CachedContentIndex.java
@@ -20,7 +20,9 @@
 import com.google.android.exoplayer.upstream.cache.Cache.CacheException;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.AtomicFile;
+import com.google.android.exoplayer.util.ReusableBufferedOutputStream;
 import com.google.android.exoplayer.util.Util;
+import java.io.BufferedInputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.File;
@@ -59,6 +61,7 @@
   private final Cipher cipher;
   private final SecretKeySpec secretKeySpec;
   private boolean changed;
+  private ReusableBufferedOutputStream bufferedOutputStream;
 
   /** Creates a CachedContentIndex which works on the index file in the given cacheDir. */
   public CachedContentIndex(File cacheDir) {
@@ -207,7 +210,7 @@ public long getContentLength(String key) {
   private boolean readFile() {
     DataInputStream input = null;
     try {
-      InputStream inputStream = atomicFile.openRead();
+      InputStream inputStream = new BufferedInputStream(atomicFile.openRead());
       input = new DataInputStream(inputStream);
       int version = input.readInt();
       if (version != VERSION) {
@@ -255,7 +258,12 @@ private void writeFile() throws CacheException {
     DataOutputStream output = null;
     try {
       OutputStream outputStream = atomicFile.startWrite();
-      output = new DataOutputStream(outputStream);
+      if (bufferedOutputStream == null) {
+        bufferedOutputStream = new ReusableBufferedOutputStream(outputStream);
+      } else {
+        bufferedOutputStream.reset(outputStream);
+      }
+      output = new DataOutputStream(bufferedOutputStream);
       output.writeInt(VERSION);
 
       int flags = cipher != null ? FLAG_ENCRYPTED_INDEX : 0;
@@ -272,7 +280,7 @@ private void writeFile() throws CacheException {
           throw new IllegalStateException(e); // Should never happen.
         }
         output.flush();
-        output = new DataOutputStream(new CipherOutputStream(outputStream, cipher));
+        output = new DataOutputStream(new CipherOutputStream(bufferedOutputStream, cipher));
       }
 
       output.writeInt(keyToContent.size());
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ReusableBufferedOutputStream.java b/library/src/main/java/com/google/android/exoplayer/util/ReusableBufferedOutputStream.java
new file mode 100644
index 0000000000..9ca7547486
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/util/ReusableBufferedOutputStream.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.util;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This is a subclass of {@link BufferedOutputStream} with a {@link #reset(OutputStream)} method
+ * that allows an instance to be re-used with another underlying output stream.
+ */
+public final class ReusableBufferedOutputStream extends BufferedOutputStream {
+
+  private boolean closed;
+
+  public ReusableBufferedOutputStream(OutputStream out) {
+    super(out);
+  }
+
+  public ReusableBufferedOutputStream(OutputStream out, int size) {
+    super(out, size);
+  }
+
+  @Override
+  public void close() throws IOException {
+    closed = true;
+
+    Throwable thrown = null;
+    try {
+      flush();
+    } catch (Throwable e) {
+      thrown = e;
+    }
+    try {
+      out.close();
+    } catch (Throwable e) {
+      if (thrown == null) {
+        thrown = e;
+      }
+    }
+    if (thrown != null) {
+      Util.sneakyThrow(thrown);
+    }
+  }
+
+  /**
+   * Resets this stream and uses the given output stream for writing. This stream must be closed
+   * before resetting.
+   *
+   * @param out New output stream to be used for writing.
+   * @throws IllegalStateException If the stream isn't closed.
+   */
+  public void reset(OutputStream out) {
+    Assertions.checkState(closed);
+    this.out = out;
+    closed = false;
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index b03d0fe8d6..1562edbb1b 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -919,6 +919,19 @@ public static String unescapeFileName(String fileName) {
     return builder.toString();
   }
 
+  /**
+   * A hacky method that always throws {@code t} even if {@code t} is a checked exception,
+   * and is not declared to be thrown.
+   */
+  public static void sneakyThrow(Throwable t) {
+    Util.<RuntimeException>sneakyThrowInternal(t);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T extends Throwable> void sneakyThrowInternal(Throwable t) throws T {
+    throw (T) t;
+  }
+
   /**
    * Returns the result of updating a CRC with the specified bytes in a "most significant bit first"
    * order.
