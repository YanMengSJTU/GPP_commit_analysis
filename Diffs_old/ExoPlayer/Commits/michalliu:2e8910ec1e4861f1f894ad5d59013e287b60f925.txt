diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSink.java
deleted file mode 100644
index 4017c1f028..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSink.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-
-/**
- * A {@link DataSink} for writing to a byte array.
- */
-public final class ByteArrayDataSink implements DataSink {
-
-  private ByteArrayOutputStream stream;
-
-  @Override
-  public void open(DataSpec dataSpec) throws IOException {
-    if (dataSpec.length == C.LENGTH_UNSET) {
-      stream = new ByteArrayOutputStream();
-    } else {
-      Assertions.checkArgument(dataSpec.length <= Integer.MAX_VALUE);
-      stream = new ByteArrayOutputStream((int) dataSpec.length);
-    }
-  }
-
-  @Override
-  public void close() throws IOException {
-    stream.close();
-  }
-
-  @Override
-  public void write(byte[] buffer, int offset, int length) throws IOException {
-    stream.write(buffer, offset, length);
-  }
-
-  /**
-   * Returns the data written to the sink since the last call to {@link #open(DataSpec)}, or null if
-   * {@link #open(DataSpec)} has never been called.
-   */
-  public byte[] getData() {
-    return stream == null ? null : stream.toByteArray();
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
deleted file mode 100644
index e5311e783b..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ByteArrayDataSource.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.IOException;
-
-/**
- * A {@link DataSource} for reading from a byte array.
- */
-public final class ByteArrayDataSource implements DataSource {
-
-  private final byte[] data;
-
-  private Uri uri;
-  private int readPosition;
-  private int bytesRemaining;
-
-  /**
-   * @param data The data to be read.
-   */
-  public ByteArrayDataSource(byte[] data) {
-    Assertions.checkNotNull(data);
-    Assertions.checkArgument(data.length > 0);
-    this.data = data;
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws IOException {
-    uri = dataSpec.uri;
-    readPosition = (int) dataSpec.position;
-    bytesRemaining = (int) ((dataSpec.length == C.LENGTH_UNSET)
-        ? (data.length - dataSpec.position) : dataSpec.length);
-    if (bytesRemaining <= 0 || readPosition + bytesRemaining > data.length) {
-      throw new IOException("Unsatisfiable range: [" + readPosition + ", " + dataSpec.length
-          + "], length: " + data.length);
-    }
-    return bytesRemaining;
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws IOException {
-    if (readLength == 0) {
-      return 0;
-    } else if (bytesRemaining == 0) {
-      return C.RESULT_END_OF_INPUT;
-    }
-
-    readLength = Math.min(readLength, bytesRemaining);
-    System.arraycopy(data, readPosition, buffer, offset, readLength);
-    readPosition += readLength;
-    bytesRemaining -= readLength;
-    return readLength;
-  }
-
-  @Override
-  public Uri getUri() {
-    return uri;
-  }
-
-  @Override
-  public void close() throws IOException {
-    uri = null;
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSink.java
deleted file mode 100644
index 2f49fed5a8..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSink.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import java.io.IOException;
-
-/**
- * A component to which streams of data can be written.
- */
-public interface DataSink {
-
-  /**
-   * A factory for {@link DataSink} instances.
-   */
-  interface Factory {
-
-    /**
-     * Creates a {@link DataSink} instance.
-     */
-    DataSink createDataSink();
-
-  }
-
-  /**
-   * Opens the sink to consume the specified data.
-   *
-   * @param dataSpec Defines the data to be consumed.
-   * @throws IOException If an error occurs opening the sink.
-   */
-  void open(DataSpec dataSpec) throws IOException;
-
-  /**
-   * Consumes the provided data.
-   *
-   * @param buffer The buffer from which data should be consumed.
-   * @param offset The offset of the data to consume in {@code buffer}.
-   * @param length The length of the data to consume, in bytes.
-   * @throws IOException If an error occurs writing to the sink.
-   */
-  void write(byte[] buffer, int offset, int length) throws IOException;
-
-  /**
-   * Closes the sink.
-   *
-   * @throws IOException If an error occurs closing the sink.
-   */
-  void close() throws IOException;
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
deleted file mode 100644
index c20868ef00..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import android.net.Uri;
-import java.io.IOException;
-
-/**
- * A dummy DataSource which provides no data. {@link #open(DataSpec)} throws {@link IOException}.
- */
-public final class DummyDataSource implements DataSource {
-
-  public static final DummyDataSource INSTANCE = new DummyDataSource();
-
-  /** A factory that that produces {@link DummyDataSource}. */
-  public static final Factory FACTORY = new Factory() {
-    @Override
-    public DataSource createDataSource() {
-      return new DummyDataSource();
-    }
-  };
-
-  private DummyDataSource() {}
-
-  @Override
-  public long open(DataSpec dataSpec) throws IOException {
-    throw new IOException("Dummy source");
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws IOException {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public Uri getUri() {
-    return null;
-  }
-
-  @Override
-  public void close() throws IOException {
-    // do nothing.
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
deleted file mode 100644
index 2accbfc584..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-/**
- * A {@link DataSource.Factory} that produces {@link FileDataSource}.
- */
-public final class FileDataSourceFactory implements DataSource.Factory {
-
-  private final TransferListener<? super FileDataSource> listener;
-
-  public FileDataSourceFactory() {
-    this(null);
-  }
-
-  public FileDataSourceFactory(TransferListener<? super FileDataSource> listener) {
-    this.listener = listener;
-  }
-
-  @Override
-  public DataSource createDataSource() {
-    return new FileDataSource(listener);
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java
deleted file mode 100644
index a36ccd11b1..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSource.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.PriorityTaskManager;
-import java.io.IOException;
-
-/**
- * A {@link DataSource} that can be used as part of a task registered with a
- * {@link PriorityTaskManager}.
- * <p>
- * Calls to {@link #open(DataSpec)} and {@link #read(byte[], int, int)} are allowed to proceed only
- * if there are no higher priority tasks registered to the {@link PriorityTaskManager}. If there
- * exists a higher priority task then {@link PriorityTaskManager.PriorityTooLowException} is thrown.
- * <p>
- * Instances of this class are intended to be used as parts of (possibly larger) tasks that are
- * registered with the {@link PriorityTaskManager}, and hence do <em>not</em> register as tasks
- * themselves.
- */
-public final class PriorityDataSource implements DataSource {
-
-  private final DataSource upstream;
-  private final PriorityTaskManager priorityTaskManager;
-  private final int priority;
-
-  /**
-   * @param upstream The upstream {@link DataSource}.
-   * @param priorityTaskManager The priority manager to which the task is registered.
-   * @param priority The priority of the task.
-   */
-  public PriorityDataSource(DataSource upstream, PriorityTaskManager priorityTaskManager,
-      int priority) {
-    this.upstream = Assertions.checkNotNull(upstream);
-    this.priorityTaskManager = Assertions.checkNotNull(priorityTaskManager);
-    this.priority = priority;
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws IOException {
-    priorityTaskManager.proceedOrThrow(priority);
-    return upstream.open(dataSpec);
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int max) throws IOException {
-    priorityTaskManager.proceedOrThrow(priority);
-    return upstream.read(buffer, offset, max);
-  }
-
-  @Override
-  public Uri getUri() {
-    return upstream.getUri();
-  }
-
-  @Override
-  public void close() throws IOException {
-    upstream.close();
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSourceFactory.java
deleted file mode 100644
index daad41a9a6..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/PriorityDataSourceFactory.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import com.google.android.exoplayer2.upstream.DataSource.Factory;
-import com.google.android.exoplayer2.util.PriorityTaskManager;
-
-/**
- * A {@link DataSource.Factory} that produces {@link PriorityDataSource} instances.
- */
-public final class PriorityDataSourceFactory implements Factory {
-
-  private final Factory upstreamFactory;
-  private final PriorityTaskManager priorityTaskManager;
-  private final int priority;
-
-  /**
-   * @param upstreamFactory A {@link DataSource.Factory} to be used to create an upstream {@link
-   *     DataSource} for {@link PriorityDataSource}.
-   * @param priorityTaskManager The priority manager to which PriorityDataSource task is registered.
-   * @param priority The priority of PriorityDataSource task.
-   */
-  public PriorityDataSourceFactory(Factory upstreamFactory, PriorityTaskManager priorityTaskManager,
-      int priority) {
-    this.upstreamFactory = upstreamFactory;
-    this.priorityTaskManager = priorityTaskManager;
-    this.priority = priority;
-  }
-
-  @Override
-  public PriorityDataSource createDataSource() {
-    return new PriorityDataSource(upstreamFactory.createDataSource(), priorityTaskManager,
-        priority);
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
deleted file mode 100644
index 0b7b85b8c3..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import android.content.Context;
-import android.content.res.AssetFileDescriptor;
-import android.content.res.Resources;
-import android.net.Uri;
-import android.text.TextUtils;
-import com.google.android.exoplayer2.C;
-import java.io.EOFException;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * A {@link DataSource} for reading a raw resource inside the APK.
- * <p>
- * URIs supported by this source are of the form {@code rawresource:///rawResourceId}, where
- * rawResourceId is the integer identifier of a raw resource. {@link #buildRawResourceUri(int)} can
- * be used to build {@link Uri}s in this format.
- */
-public final class RawResourceDataSource implements DataSource {
-
-  /**
-   * Thrown when an {@link IOException} is encountered reading from a raw resource.
-   */
-  public static class RawResourceDataSourceException extends IOException {
-    public RawResourceDataSourceException(String message) {
-      super(message);
-    }
-
-    public RawResourceDataSourceException(IOException e) {
-      super(e);
-    }
-  }
-
-  /**
-   * Builds a {@link Uri} for the specified raw resource identifier.
-   *
-   * @param rawResourceId A raw resource identifier (i.e. a constant defined in {@code R.raw}).
-   * @return The corresponding {@link Uri}.
-   */
-  public static Uri buildRawResourceUri(int rawResourceId) {
-    return Uri.parse(RAW_RESOURCE_SCHEME + ":///" + rawResourceId);
-  }
-
-  private static final String RAW_RESOURCE_SCHEME = "rawresource";
-
-  private final Resources resources;
-  private final TransferListener<? super RawResourceDataSource> listener;
-
-  private Uri uri;
-  private AssetFileDescriptor assetFileDescriptor;
-  private InputStream inputStream;
-  private long bytesRemaining;
-  private boolean opened;
-
-  /**
-   * @param context A context.
-   */
-  public RawResourceDataSource(Context context) {
-    this(context, null);
-  }
-
-  /**
-   * @param context A context.
-   * @param listener An optional listener.
-   */
-  public RawResourceDataSource(Context context,
-      TransferListener<? super RawResourceDataSource> listener) {
-    this.resources = context.getResources();
-    this.listener = listener;
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws RawResourceDataSourceException {
-    try {
-      uri = dataSpec.uri;
-      if (!TextUtils.equals(RAW_RESOURCE_SCHEME, uri.getScheme())) {
-        throw new RawResourceDataSourceException("URI must use scheme " + RAW_RESOURCE_SCHEME);
-      }
-
-      int resourceId;
-      try {
-        resourceId = Integer.parseInt(uri.getLastPathSegment());
-      } catch (NumberFormatException e) {
-        throw new RawResourceDataSourceException("Resource identifier must be an integer.");
-      }
-
-      assetFileDescriptor = resources.openRawResourceFd(resourceId);
-      inputStream = new FileInputStream(assetFileDescriptor.getFileDescriptor());
-      inputStream.skip(assetFileDescriptor.getStartOffset());
-      long skipped = inputStream.skip(dataSpec.position);
-      if (skipped < dataSpec.position) {
-        // We expect the skip to be satisfied in full. If it isn't then we're probably trying to
-        // skip beyond the end of the data.
-        throw new EOFException();
-      }
-      if (dataSpec.length != C.LENGTH_UNSET) {
-        bytesRemaining = dataSpec.length;
-      } else {
-        long assetFileDescriptorLength = assetFileDescriptor.getLength();
-        // If the length is UNKNOWN_LENGTH then the asset extends to the end of the file.
-        bytesRemaining = assetFileDescriptorLength == AssetFileDescriptor.UNKNOWN_LENGTH
-            ? C.LENGTH_UNSET : (assetFileDescriptorLength - dataSpec.position);
-      }
-    } catch (IOException e) {
-      throw new RawResourceDataSourceException(e);
-    }
-
-    opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
-
-    return bytesRemaining;
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws RawResourceDataSourceException {
-    if (readLength == 0) {
-      return 0;
-    } else if (bytesRemaining == 0) {
-      return C.RESULT_END_OF_INPUT;
-    }
-
-    int bytesRead;
-    try {
-      int bytesToRead = bytesRemaining == C.LENGTH_UNSET ? readLength
-          : (int) Math.min(bytesRemaining, readLength);
-      bytesRead = inputStream.read(buffer, offset, bytesToRead);
-    } catch (IOException e) {
-      throw new RawResourceDataSourceException(e);
-    }
-
-    if (bytesRead == -1) {
-      if (bytesRemaining != C.LENGTH_UNSET) {
-        // End of stream reached having not read sufficient data.
-        throw new RawResourceDataSourceException(new EOFException());
-      }
-      return C.RESULT_END_OF_INPUT;
-    }
-    if (bytesRemaining != C.LENGTH_UNSET) {
-      bytesRemaining -= bytesRead;
-    }
-    if (listener != null) {
-      listener.onBytesTransferred(this, bytesRead);
-    }
-    return bytesRead;
-  }
-
-  @Override
-  public Uri getUri() {
-    return uri;
-  }
-
-  @Override
-  public void close() throws RawResourceDataSourceException {
-    uri = null;
-    try {
-      if (inputStream != null) {
-        inputStream.close();
-      }
-    } catch (IOException e) {
-      throw new RawResourceDataSourceException(e);
-    } finally {
-      inputStream = null;
-      try {
-        if (assetFileDescriptor != null) {
-          assetFileDescriptor.close();
-        }
-      } catch (IOException e) {
-        throw new RawResourceDataSourceException(e);
-      } finally {
-        assetFileDescriptor = null;
-        if (opened) {
-          opened = false;
-          if (listener != null) {
-            listener.onTransferEnd(this);
-          }
-        }
-      }
-    }
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java
deleted file mode 100644
index 3f76ee59d5..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/TeeDataSource.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.IOException;
-
-/**
- * Tees data into a {@link DataSink} as the data is read.
- */
-public final class TeeDataSource implements DataSource {
-
-  private final DataSource upstream;
-  private final DataSink dataSink;
-
-  /**
-   * @param upstream The upstream {@link DataSource}.
-   * @param dataSink The {@link DataSink} into which data is written.
-   */
-  public TeeDataSource(DataSource upstream, DataSink dataSink) {
-    this.upstream = Assertions.checkNotNull(upstream);
-    this.dataSink = Assertions.checkNotNull(dataSink);
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws IOException {
-    long dataLength = upstream.open(dataSpec);
-    if (dataSpec.length == C.LENGTH_UNSET && dataLength != C.LENGTH_UNSET) {
-      // Reconstruct dataSpec in order to provide the resolved length to the sink.
-      dataSpec = new DataSpec(dataSpec.uri, dataSpec.absoluteStreamPosition, dataSpec.position,
-          dataLength, dataSpec.key, dataSpec.flags);
-    }
-    dataSink.open(dataSpec);
-    return dataLength;
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int max) throws IOException {
-    int num = upstream.read(buffer, offset, max);
-    if (num > 0) {
-      // TODO: Consider continuing even if disk writes fail.
-      dataSink.write(buffer, offset, num);
-    }
-    return num;
-  }
-
-  @Override
-  public Uri getUri() {
-    return upstream.getUri();
-  }
-
-  @Override
-  public void close() throws IOException {
-    try {
-      upstream.close();
-    } finally {
-      dataSink.close();
-    }
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
deleted file mode 100644
index 68a04d9182..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/UdpDataSource.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import java.io.IOException;
-import java.net.DatagramPacket;
-import java.net.DatagramSocket;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.MulticastSocket;
-import java.net.SocketException;
-
-/**
- * A UDP {@link DataSource}.
- */
-public final class UdpDataSource implements DataSource {
-
-  /**
-   * Thrown when an error is encountered when trying to read from a {@link UdpDataSource}.
-   */
-  public static final class UdpDataSourceException extends IOException {
-
-    public UdpDataSourceException(IOException cause) {
-      super(cause);
-    }
-
-  }
-
-  /**
-   * The default maximum datagram packet size, in bytes.
-   */
-  public static final int DEFAULT_MAX_PACKET_SIZE = 2000;
-
-  /**
-   * The default socket timeout, in milliseconds.
-   */
-  public static final int DEAFULT_SOCKET_TIMEOUT_MILLIS = 8 * 1000;
-
-  private final TransferListener<? super UdpDataSource> listener;
-  private final int socketTimeoutMillis;
-  private final byte[] packetBuffer;
-  private final DatagramPacket packet;
-
-  private Uri uri;
-  private DatagramSocket socket;
-  private MulticastSocket multicastSocket;
-  private InetAddress address;
-  private InetSocketAddress socketAddress;
-  private boolean opened;
-
-  private int packetRemaining;
-
-  /**
-   * @param listener An optional listener.
-   */
-  public UdpDataSource(TransferListener<? super UdpDataSource> listener) {
-    this(listener, DEFAULT_MAX_PACKET_SIZE);
-  }
-
-  /**
-   * @param listener An optional listener.
-   * @param maxPacketSize The maximum datagram packet size, in bytes.
-   */
-  public UdpDataSource(TransferListener<? super UdpDataSource> listener, int maxPacketSize) {
-    this(listener, maxPacketSize, DEAFULT_SOCKET_TIMEOUT_MILLIS);
-  }
-
-  /**
-   * @param listener An optional listener.
-   * @param maxPacketSize The maximum datagram packet size, in bytes.
-   * @param socketTimeoutMillis The socket timeout in milliseconds. A timeout of zero is interpreted
-   *     as an infinite timeout.
-   */
-  public UdpDataSource(TransferListener<? super UdpDataSource> listener, int maxPacketSize,
-      int socketTimeoutMillis) {
-    this.listener = listener;
-    this.socketTimeoutMillis = socketTimeoutMillis;
-    packetBuffer = new byte[maxPacketSize];
-    packet = new DatagramPacket(packetBuffer, 0, maxPacketSize);
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws UdpDataSourceException {
-    uri = dataSpec.uri;
-    String host = uri.getHost();
-    int port = uri.getPort();
-
-    try {
-      address = InetAddress.getByName(host);
-      socketAddress = new InetSocketAddress(address, port);
-      if (address.isMulticastAddress()) {
-        multicastSocket = new MulticastSocket(socketAddress);
-        multicastSocket.joinGroup(address);
-        socket = multicastSocket;
-      } else {
-        socket = new DatagramSocket(socketAddress);
-      }
-    } catch (IOException e) {
-      throw new UdpDataSourceException(e);
-    }
-
-    try {
-      socket.setSoTimeout(socketTimeoutMillis);
-    } catch (SocketException e) {
-      throw new UdpDataSourceException(e);
-    }
-
-    opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
-    return C.LENGTH_UNSET;
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws UdpDataSourceException {
-    if (readLength == 0) {
-      return 0;
-    }
-
-    if (packetRemaining == 0) {
-      // We've read all of the data from the current packet. Get another.
-      try {
-        socket.receive(packet);
-      } catch (IOException e) {
-        throw new UdpDataSourceException(e);
-      }
-      packetRemaining = packet.getLength();
-      if (listener != null) {
-        listener.onBytesTransferred(this, packetRemaining);
-      }
-    }
-
-    int packetOffset = packet.getLength() - packetRemaining;
-    int bytesToRead = Math.min(packetRemaining, readLength);
-    System.arraycopy(packetBuffer, packetOffset, buffer, offset, bytesToRead);
-    packetRemaining -= bytesToRead;
-    return bytesToRead;
-  }
-
-  @Override
-  public Uri getUri() {
-    return uri;
-  }
-
-  @Override
-  public void close() {
-    uri = null;
-    if (multicastSocket != null) {
-      try {
-        multicastSocket.leaveGroup(address);
-      } catch (IOException e) {
-        // Do nothing.
-      }
-      multicastSocket = null;
-    }
-    if (socket != null) {
-      socket.close();
-      socket = null;
-    }
-    address = null;
-    socketAddress = null;
-    packetRemaining = 0;
-    if (opened) {
-      opened = false;
-      if (listener != null) {
-        listener.onTransferEnd(this);
-      }
-    }
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
deleted file mode 100644
index 86ff810142..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.NavigableSet;
-import java.util.Set;
-
-/**
- * An interface for cache.
- */
-public interface Cache {
-
-  /**
-   * Listener of {@link Cache} events.
-   */
-  interface Listener {
-
-    /**
-     * Called when a {@link CacheSpan} is added to the cache.
-     *
-     * @param cache The source of the event.
-     * @param span The added {@link CacheSpan}.
-     */
-    void onSpanAdded(Cache cache, CacheSpan span);
-
-    /**
-     * Called when a {@link CacheSpan} is removed from the cache.
-     *
-     * @param cache The source of the event.
-     * @param span The removed {@link CacheSpan}.
-     */
-    void onSpanRemoved(Cache cache, CacheSpan span);
-
-    /**
-     * Called when an existing {@link CacheSpan} is accessed, causing it to be replaced. The new
-     * {@link CacheSpan} is guaranteed to represent the same data as the one it replaces, however
-     * {@link CacheSpan#file} and {@link CacheSpan#lastAccessTimestamp} may have changed.
-     * <p>
-     * Note that for span replacement, {@link #onSpanAdded(Cache, CacheSpan)} and
-     * {@link #onSpanRemoved(Cache, CacheSpan)} are not called in addition to this method.
-     *
-     * @param cache The source of the event.
-     * @param oldSpan The old {@link CacheSpan}, which has been removed from the cache.
-     * @param newSpan The new {@link CacheSpan}, which has been added to the cache.
-     */
-    void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan);
-
-  }
-  
-  /**
-   * Thrown when an error is encountered when writing data.
-   */
-  class CacheException extends IOException {
-
-    public CacheException(String message) {
-      super(message);
-    }
-
-    public CacheException(IOException cause) {
-      super(cause);
-    }
-
-  }
-
-  /**
-   * Registers a listener to listen for changes to a given key.
-   * <p>
-   * No guarantees are made about the thread or threads on which the listener is called, but it is
-   * guaranteed that listener methods will be called in a serial fashion (i.e. one at a time) and in
-   * the same order as events occurred.
-   *
-   * @param key The key to listen to.
-   * @param listener The listener to add.
-   * @return The current spans for the key.
-   */
-  NavigableSet<CacheSpan> addListener(String key, Listener listener);
-
-  /**
-   * Unregisters a listener.
-   *
-   * @param key The key to stop listening to.
-   * @param listener The listener to remove.
-   */
-  void removeListener(String key, Listener listener);
-
-  /**
-   * Returns the cached spans for a given cache key.
-   *
-   * @param key The key for which spans should be returned.
-   * @return The spans for the key. May be null if there are no such spans.
-   */
-  NavigableSet<CacheSpan> getCachedSpans(String key);
-
-  /**
-   * Returns all keys in the cache.
-   *
-   * @return All the keys in the cache.
-   */
-  Set<String> getKeys();
-
-  /**
-   * Returns the total disk space in bytes used by the cache.
-   *
-   * @return The total disk space in bytes.
-   */
-  long getCacheSpace();
-
-  /**
-   * A caller should invoke this method when they require data from a given position for a given
-   * key.
-   * <p>
-   * If there is a cache entry that overlaps the position, then the returned {@link CacheSpan}
-   * defines the file in which the data is stored. {@link CacheSpan#isCached} is true. The caller
-   * may read from the cache file, but does not acquire any locks.
-   * <p>
-   * If there is no cache entry overlapping {@code offset}, then the returned {@link CacheSpan}
-   * defines a hole in the cache starting at {@code position} into which the caller may write as it
-   * obtains the data from some other source. The returned {@link CacheSpan} serves as a lock.
-   * Whilst the caller holds the lock it may write data into the hole. It may split data into
-   * multiple files. When the caller has finished writing a file it should commit it to the cache
-   * by calling {@link #commitFile(File)}. When the caller has finished writing, it must release
-   * the lock by calling {@link #releaseHoleSpan}.
-   *
-   * @param key The key of the data being requested.
-   * @param position The position of the data being requested.
-   * @return The {@link CacheSpan}.
-   * @throws InterruptedException
-   */
-  CacheSpan startReadWrite(String key, long position) throws InterruptedException, CacheException;
-
-  /**
-   * Same as {@link #startReadWrite(String, long)}. However, if the cache entry is locked, then
-   * instead of blocking, this method will return null as the {@link CacheSpan}.
-   *
-   * @param key The key of the data being requested.
-   * @param position The position of the data being requested.
-   * @return The {@link CacheSpan}. Or null if the cache entry is locked.
-   */
-  CacheSpan startReadWriteNonBlocking(String key, long position) throws CacheException;
-
-  /**
-   * Obtains a cache file into which data can be written. Must only be called when holding a
-   * corresponding hole {@link CacheSpan} obtained from {@link #startReadWrite(String, long)}.
-   *
-   * @param key The cache key for the data.
-   * @param position The starting position of the data.
-   * @param maxLength The maximum length of the data to be written. Used only to ensure that there
-   *     is enough space in the cache.
-   * @return The file into which data should be written.
-   */
-  File startFile(String key, long position, long maxLength) throws CacheException;
-
-  /**
-   * Commits a file into the cache. Must only be called when holding a corresponding hole
-   * {@link CacheSpan} obtained from {@link #startReadWrite(String, long)}
-   *
-   * @param file A newly written cache file.
-   */
-  void commitFile(File file) throws CacheException;
-
-  /**
-   * Releases a {@link CacheSpan} obtained from {@link #startReadWrite(String, long)} which
-   * corresponded to a hole in the cache.
-   *
-   * @param holeSpan The {@link CacheSpan} being released.
-   */
-  void releaseHoleSpan(CacheSpan holeSpan);
-
-  /**
-   * Removes a cached {@link CacheSpan} from the cache, deleting the underlying file.
-   *
-   * @param span The {@link CacheSpan} to remove.
-   */
-  void removeSpan(CacheSpan span) throws CacheException;
-
- /**
-  * Queries if a range is entirely available in the cache.
-  *
-  * @param key The cache key for the data.
-  * @param position The starting position of the data.
-  * @param length The length of the data.
-  * @return true if the data is available in the Cache otherwise false;
-  */
-  boolean isCached(String key, long position, long length);
-
-  /**
-   * Returns the length of the cached data block starting from the {@code position} to the block end
-   * up to {@code length} bytes. If the {@code position} isn't cached then -(the length of the gap
-   * to the next cached data up to {@code length} bytes) is returned.
-   *
-   * @param key The cache key for the data.
-   * @param position The starting position of the data.
-   * @param length The maximum length of the data to be returned.
-   * @return the length of the cached or not cached data block length.
-   */
-  long getCachedBytes(String key, long position, long length);
-
-  /**
-   * Sets the content length for the given key.
-   *
-   * @param key The cache key for the data.
-   * @param length The length of the data.
-   */
-  void setContentLength(String key, long length) throws CacheException;
-
-  /**
-   * Returns the content length for the given key if one set, or {@link
-   * com.google.android.exoplayer2.C#LENGTH_UNSET} otherwise.
-   *
-   * @param key The cache key for the data.
-   */
-  long getContentLength(String key);
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
deleted file mode 100644
index 33b1ca58b0..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.upstream.DataSink;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.ReusableBufferedOutputStream;
-import com.google.android.exoplayer2.util.Util;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * Writes data into a cache.
- */
-public final class CacheDataSink implements DataSink {
-
-  /** Default buffer size. */
-  public static final int DEFAULT_BUFFER_SIZE = 20480;
-
-  private final Cache cache;
-  private final long maxCacheFileSize;
-  private final int bufferSize;
-
-  private DataSpec dataSpec;
-  private File file;
-  private OutputStream outputStream;
-  private FileOutputStream underlyingFileOutputStream;
-  private long outputStreamBytesWritten;
-  private long dataSpecBytesWritten;
-  private ReusableBufferedOutputStream bufferedOutputStream;
-
-  /**
-   * Thrown when IOException is encountered when writing data into sink.
-   */
-  public static class CacheDataSinkException extends CacheException {
-
-    public CacheDataSinkException(IOException cause) {
-      super(cause);
-    }
-
-  }
-
-  /**
-   * Constructs a CacheDataSink using the {@link #DEFAULT_BUFFER_SIZE}.
-   *
-   * @param cache The cache into which data should be written.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for
-   *    a {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
-   *    multiple cache files.
-   */
-  public CacheDataSink(Cache cache, long maxCacheFileSize) {
-    this(cache, maxCacheFileSize, DEFAULT_BUFFER_SIZE);
-  }
-
-  /**
-   * @param cache The cache into which data should be written.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the sink is opened for
-   *    a {@link DataSpec} whose size exceeds this value, then the data will be fragmented into
-   *    multiple cache files.
-   * @param bufferSize The buffer size in bytes for writing to a cache file. A zero or negative
-   *    value disables buffering.
-   */
-  public CacheDataSink(Cache cache, long maxCacheFileSize, int bufferSize) {
-    this.cache = Assertions.checkNotNull(cache);
-    this.maxCacheFileSize = maxCacheFileSize;
-    this.bufferSize = bufferSize;
-  }
-
-  @Override
-  public void open(DataSpec dataSpec) throws CacheDataSinkException {
-    if (dataSpec.length == C.LENGTH_UNSET
-        && !dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH)) {
-      this.dataSpec = null;
-      return;
-    }
-    this.dataSpec = dataSpec;
-    dataSpecBytesWritten = 0;
-    try {
-      openNextOutputStream();
-    } catch (IOException e) {
-      throw new CacheDataSinkException(e);
-    }
-  }
-
-  @Override
-  public void write(byte[] buffer, int offset, int length) throws CacheDataSinkException {
-    if (dataSpec == null) {
-      return;
-    }
-    try {
-      int bytesWritten = 0;
-      while (bytesWritten < length) {
-        if (outputStreamBytesWritten == maxCacheFileSize) {
-          closeCurrentOutputStream();
-          openNextOutputStream();
-        }
-        int bytesToWrite = (int) Math.min(length - bytesWritten,
-            maxCacheFileSize - outputStreamBytesWritten);
-        outputStream.write(buffer, offset + bytesWritten, bytesToWrite);
-        bytesWritten += bytesToWrite;
-        outputStreamBytesWritten += bytesToWrite;
-        dataSpecBytesWritten += bytesToWrite;
-      }
-    } catch (IOException e) {
-      throw new CacheDataSinkException(e);
-    }
-  }
-
-  @Override
-  public void close() throws CacheDataSinkException {
-    if (dataSpec == null) {
-      return;
-    }
-    try {
-      closeCurrentOutputStream();
-    } catch (IOException e) {
-      throw new CacheDataSinkException(e);
-    }
-  }
-
-  private void openNextOutputStream() throws IOException {
-    long maxLength = dataSpec.length == C.LENGTH_UNSET ? maxCacheFileSize
-        : Math.min(dataSpec.length - dataSpecBytesWritten, maxCacheFileSize);
-    file = cache.startFile(dataSpec.key, dataSpec.absoluteStreamPosition + dataSpecBytesWritten,
-        maxLength);
-    underlyingFileOutputStream = new FileOutputStream(file);
-    if (bufferSize > 0) {
-      if (bufferedOutputStream == null) {
-        bufferedOutputStream = new ReusableBufferedOutputStream(underlyingFileOutputStream,
-            bufferSize);
-      } else {
-        bufferedOutputStream.reset(underlyingFileOutputStream);
-      }
-      outputStream = bufferedOutputStream;
-    } else {
-      outputStream = underlyingFileOutputStream;
-    }
-    outputStreamBytesWritten = 0;
-  }
-
-  @SuppressWarnings("ThrowFromFinallyBlock")
-  private void closeCurrentOutputStream() throws IOException {
-    if (outputStream == null) {
-      return;
-    }
-
-    boolean success = false;
-    try {
-      outputStream.flush();
-      underlyingFileOutputStream.getFD().sync();
-      success = true;
-    } finally {
-      Util.closeQuietly(outputStream);
-      outputStream = null;
-      File fileToCommit = file;
-      file = null;
-      if (success) {
-        cache.commitFile(fileToCommit);
-      } else {
-        fileToCommit.delete();
-      }
-    }
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
deleted file mode 100644
index 0b9ab66508..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSinkFactory.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import com.google.android.exoplayer2.upstream.DataSink;
-
-/**
- * A {@link DataSink.Factory} that produces {@link CacheDataSink}.
- */
-public final class CacheDataSinkFactory implements DataSink.Factory {
-
-  private final Cache cache;
-  private final long maxCacheFileSize;
-  private final int bufferSize;
-
-  /**
-   * @see CacheDataSink#CacheDataSink(Cache, long)
-   */
-  public CacheDataSinkFactory(Cache cache, long maxCacheFileSize) {
-    this(cache, maxCacheFileSize, CacheDataSink.DEFAULT_BUFFER_SIZE);
-  }
-
-  /**
-   * @see CacheDataSink#CacheDataSink(Cache, long, int)
-   */
-  public CacheDataSinkFactory(Cache cache, long maxCacheFileSize, int bufferSize) {
-    this.cache = cache;
-    this.maxCacheFileSize = maxCacheFileSize;
-    this.bufferSize = bufferSize;
-  }
-
-  @Override
-  public DataSink createDataSink() {
-    return new CacheDataSink(cache, maxCacheFileSize, bufferSize);
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
deleted file mode 100644
index bb2a952b11..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import android.net.Uri;
-import android.support.annotation.IntDef;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.upstream.DataSink;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSourceException;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.upstream.FileDataSource;
-import com.google.android.exoplayer2.upstream.TeeDataSource;
-import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-
-/**
- * A {@link DataSource} that reads and writes a {@link Cache}. Requests are fulfilled from the cache
- * when possible. When data is not cached it is requested from an upstream {@link DataSource} and
- * written into the cache.
- */
-public final class CacheDataSource implements DataSource {
-
-  /**
-   * Default maximum single cache file size.
-   *
-   * @see #CacheDataSource(Cache, DataSource, int)
-   * @see #CacheDataSource(Cache, DataSource, int, long)
-   */
-  public static final long DEFAULT_MAX_CACHE_FILE_SIZE = 2 * 1024 * 1024;
-
-  /**
-   * Flags controlling the cache's behavior.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef(flag = true, value = {FLAG_BLOCK_ON_CACHE, FLAG_IGNORE_CACHE_ON_ERROR,
-      FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS})
-  public @interface Flags {}
-  /**
-   * A flag indicating whether we will block reads if the cache key is locked. If unset then data is
-   * read from upstream if the cache key is locked, regardless of whether the data is cached.
-   */
-  public static final int FLAG_BLOCK_ON_CACHE = 1 << 0;
-
-  /**
-   * A flag indicating whether the cache is bypassed following any cache related error. If set
-   * then cache related exceptions may be thrown for one cycle of open, read and close calls.
-   * Subsequent cycles of these calls will then bypass the cache.
-   */
-  public static final int FLAG_IGNORE_CACHE_ON_ERROR = 1 << 1;
-
-  /**
-   * A flag indicating that the cache should be bypassed for requests whose lengths are unset.
-   */
-  public static final int FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS = 1 << 2;
-
-  /**
-   * Listener of {@link CacheDataSource} events.
-   */
-  public interface EventListener {
-
-    /**
-     * Called when bytes have been read from the cache.
-     *
-     * @param cacheSizeBytes Current cache size in bytes.
-     * @param cachedBytesRead Total bytes read from the cache since this method was last called.
-     */
-    void onCachedBytesRead(long cacheSizeBytes, long cachedBytesRead);
-
-  }
-
-  private final Cache cache;
-  private final DataSource cacheReadDataSource;
-  private final DataSource cacheWriteDataSource;
-  private final DataSource upstreamDataSource;
-  @Nullable private final EventListener eventListener;
-
-  private final boolean blockOnCache;
-  private final boolean ignoreCacheOnError;
-  private final boolean ignoreCacheForUnsetLengthRequests;
-
-  private DataSource currentDataSource;
-  private boolean currentRequestUnbounded;
-  private Uri uri;
-  private int flags;
-  private String key;
-  private long readPosition;
-  private long bytesRemaining;
-  private CacheSpan lockedSpan;
-  private boolean seenCacheError;
-  private boolean currentRequestIgnoresCache;
-  private long totalCachedBytesRead;
-
-  /**
-   * Constructs an instance with default {@link DataSource} and {@link DataSink} instances for
-   * reading and writing the cache.
-   *
-   * @param cache The cache.
-   * @param upstream A {@link DataSource} for reading data not in the cache.
-   */
-  public CacheDataSource(Cache cache, DataSource upstream) {
-    this(cache, upstream, 0, DEFAULT_MAX_CACHE_FILE_SIZE);
-  }
-
-  /**
-   * Constructs an instance with default {@link DataSource} and {@link DataSink} instances for
-   * reading and writing the cache.
-   *
-   * @param cache The cache.
-   * @param upstream A {@link DataSource} for reading data not in the cache.
-   * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE}, {@link #FLAG_IGNORE_CACHE_ON_ERROR}
-   *     and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}, or 0.
-   */
-  public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags) {
-    this(cache, upstream, flags, DEFAULT_MAX_CACHE_FILE_SIZE);
-  }
-
-  /**
-   * Constructs an instance with default {@link DataSource} and {@link DataSink} instances for
-   * reading and writing the cache. The sink is configured to fragment data such that no single
-   * cache file is greater than maxCacheFileSize bytes.
-   *
-   * @param cache The cache.
-   * @param upstream A {@link DataSource} for reading data not in the cache.
-   * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE}, {@link #FLAG_IGNORE_CACHE_ON_ERROR}
-   *     and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}, or 0.
-   * @param maxCacheFileSize The maximum size of a cache file, in bytes. If the cached data size
-   *     exceeds this value, then the data will be fragmented into multiple cache files. The
-   *     finer-grained this is the finer-grained the eviction policy can be.
-   */
-  public CacheDataSource(Cache cache, DataSource upstream, @Flags int flags,
-      long maxCacheFileSize) {
-    this(cache, upstream, new FileDataSource(), new CacheDataSink(cache, maxCacheFileSize),
-        flags, null);
-  }
-
-  /**
-   * Constructs an instance with arbitrary {@link DataSource} and {@link DataSink} instances for
-   * reading and writing the cache. One use of this constructor is to allow data to be transformed
-   * before it is written to disk.
-   *
-   * @param cache The cache.
-   * @param upstream A {@link DataSource} for reading data not in the cache.
-   * @param cacheReadDataSource A {@link DataSource} for reading data from the cache.
-   * @param cacheWriteDataSink A {@link DataSink} for writing data to the cache. If null, cache is
-   *     accessed read-only.
-   * @param flags A combination of {@link #FLAG_BLOCK_ON_CACHE}, {@link #FLAG_IGNORE_CACHE_ON_ERROR}
-   *     and {@link #FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS}, or 0.
-   * @param eventListener An optional {@link EventListener} to receive events.
-   */
-  public CacheDataSource(Cache cache, DataSource upstream, DataSource cacheReadDataSource,
-      DataSink cacheWriteDataSink, @Flags int flags, @Nullable EventListener eventListener) {
-    this.cache = cache;
-    this.cacheReadDataSource = cacheReadDataSource;
-    this.blockOnCache = (flags & FLAG_BLOCK_ON_CACHE) != 0;
-    this.ignoreCacheOnError = (flags & FLAG_IGNORE_CACHE_ON_ERROR) != 0;
-    this.ignoreCacheForUnsetLengthRequests =
-        (flags & FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS) != 0;
-    this.upstreamDataSource = upstream;
-    if (cacheWriteDataSink != null) {
-      this.cacheWriteDataSource = new TeeDataSource(upstream, cacheWriteDataSink);
-    } else {
-      this.cacheWriteDataSource = null;
-    }
-    this.eventListener = eventListener;
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws IOException {
-    try {
-      uri = dataSpec.uri;
-      flags = dataSpec.flags;
-      key = CacheUtil.getKey(dataSpec);
-      readPosition = dataSpec.position;
-      currentRequestIgnoresCache = (ignoreCacheOnError && seenCacheError)
-          || (dataSpec.length == C.LENGTH_UNSET && ignoreCacheForUnsetLengthRequests);
-      if (dataSpec.length != C.LENGTH_UNSET || currentRequestIgnoresCache) {
-        bytesRemaining = dataSpec.length;
-      } else {
-        bytesRemaining = cache.getContentLength(key);
-        if (bytesRemaining != C.LENGTH_UNSET) {
-          bytesRemaining -= dataSpec.position;
-          if (bytesRemaining <= 0) {
-            throw new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE);
-          }
-        }
-      }
-      openNextSource(true);
-      return bytesRemaining;
-    } catch (IOException e) {
-      handleBeforeThrow(e);
-      throw e;
-    }
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws IOException {
-    if (readLength == 0) {
-      return 0;
-    }
-    if (bytesRemaining == 0) {
-      return C.RESULT_END_OF_INPUT;
-    }
-    try {
-      int bytesRead = currentDataSource.read(buffer, offset, readLength);
-      if (bytesRead >= 0) {
-        if (currentDataSource == cacheReadDataSource) {
-          totalCachedBytesRead += bytesRead;
-        }
-        readPosition += bytesRead;
-        if (bytesRemaining != C.LENGTH_UNSET) {
-          bytesRemaining -= bytesRead;
-        }
-      } else {
-        if (currentRequestUnbounded) {
-          // We only do unbounded requests to upstream and only when we don't know the actual stream
-          // length. So we reached the end of stream.
-          setContentLength(readPosition);
-          bytesRemaining = 0;
-        }
-        closeCurrentSource();
-        if (bytesRemaining > 0 || bytesRemaining == C.LENGTH_UNSET) {
-          if (openNextSource(false)) {
-            return read(buffer, offset, readLength);
-          }
-        }
-      }
-      return bytesRead;
-    } catch (IOException e) {
-      handleBeforeThrow(e);
-      throw e;
-    }
-  }
-
-  @Override
-  public Uri getUri() {
-    return currentDataSource == upstreamDataSource ? currentDataSource.getUri() : uri;
-  }
-
-  @Override
-  public void close() throws IOException {
-    uri = null;
-    notifyBytesRead();
-    try {
-      closeCurrentSource();
-    } catch (IOException e) {
-      handleBeforeThrow(e);
-      throw e;
-    }
-  }
-
-  /**
-   * Opens the next source. If the cache contains data spanning the current read position then
-   * {@link #cacheReadDataSource} is opened to read from it. Else {@link #upstreamDataSource} is
-   * opened to read from the upstream source and write into the cache.
-   * @param initial Whether it is the initial open call.
-   */
-  private boolean openNextSource(boolean initial) throws IOException {
-    DataSpec dataSpec;
-    CacheSpan span;
-    if (currentRequestIgnoresCache) {
-      span = null;
-    } else if (blockOnCache) {
-      try {
-        span = cache.startReadWrite(key, readPosition);
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
-      }
-    } else {
-      span = cache.startReadWriteNonBlocking(key, readPosition);
-    }
-
-    if (span == null) {
-      // The data is locked in the cache, or we're ignoring the cache. Bypass the cache and read
-      // from upstream.
-      currentDataSource = upstreamDataSource;
-      dataSpec = new DataSpec(uri, readPosition, bytesRemaining, key, flags);
-    } else if (span.isCached) {
-      // Data is cached, read from cache.
-      Uri fileUri = Uri.fromFile(span.file);
-      long filePosition = readPosition - span.position;
-      long length = span.length - filePosition;
-      if (bytesRemaining != C.LENGTH_UNSET) {
-        length = Math.min(length, bytesRemaining);
-      }
-      dataSpec = new DataSpec(fileUri, readPosition, filePosition, length, key, flags);
-      currentDataSource = cacheReadDataSource;
-    } else {
-      // Data is not cached, and data is not locked, read from upstream with cache backing.
-      long length;
-      if (span.isOpenEnded()) {
-        length = bytesRemaining;
-      } else {
-        length = span.length;
-        if (bytesRemaining != C.LENGTH_UNSET) {
-          length = Math.min(length, bytesRemaining);
-        }
-      }
-      dataSpec = new DataSpec(uri, readPosition, length, key, flags);
-      if (cacheWriteDataSource != null) {
-        currentDataSource = cacheWriteDataSource;
-        lockedSpan = span;
-      } else {
-        currentDataSource = upstreamDataSource;
-        cache.releaseHoleSpan(span);
-      }
-    }
-
-    currentRequestUnbounded = dataSpec.length == C.LENGTH_UNSET;
-    boolean successful = false;
-    long currentBytesRemaining = 0;
-    try {
-      currentBytesRemaining = currentDataSource.open(dataSpec);
-      successful = true;
-    } catch (IOException e) {
-      // if this isn't the initial open call (we had read some bytes) and an unbounded range request
-      // failed because of POSITION_OUT_OF_RANGE then mute the exception. We are trying to find the
-      // end of the stream.
-      if (!initial && currentRequestUnbounded) {
-        Throwable cause = e;
-        while (cause != null) {
-          if (cause instanceof DataSourceException) {
-            int reason = ((DataSourceException) cause).reason;
-            if (reason == DataSourceException.POSITION_OUT_OF_RANGE) {
-              e = null;
-              break;
-            }
-          }
-          cause = cause.getCause();
-        }
-      }
-      if (e != null) {
-        throw e;
-      }
-    }
-
-    // If we did an unbounded request (which means it's to upstream and
-    // bytesRemaining == C.LENGTH_UNSET) and got a resolved length from open() request
-    if (currentRequestUnbounded && currentBytesRemaining != C.LENGTH_UNSET) {
-      bytesRemaining = currentBytesRemaining;
-      setContentLength(dataSpec.position + bytesRemaining);
-    }
-    return successful;
-  }
-
-  private void setContentLength(long length) throws IOException {
-    // If writing into cache
-    if (currentDataSource == cacheWriteDataSource) {
-      cache.setContentLength(key, length);
-    }
-  }
-
-  private void closeCurrentSource() throws IOException {
-    if (currentDataSource == null) {
-      return;
-    }
-    try {
-      currentDataSource.close();
-      currentDataSource = null;
-      currentRequestUnbounded = false;
-    } finally {
-      if (lockedSpan != null) {
-        cache.releaseHoleSpan(lockedSpan);
-        lockedSpan = null;
-      }
-    }
-  }
-
-  private void handleBeforeThrow(IOException exception) {
-    if (currentDataSource == cacheReadDataSource || exception instanceof CacheException) {
-      seenCacheError = true;
-    }
-  }
-
-  private void notifyBytesRead() {
-    if (eventListener != null && totalCachedBytesRead > 0) {
-      eventListener.onCachedBytesRead(cache.getCacheSpace(), totalCachedBytesRead);
-      totalCachedBytesRead = 0;
-    }
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
deleted file mode 100644
index f0285da274..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import com.google.android.exoplayer2.upstream.DataSink;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSource.Factory;
-import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
-import com.google.android.exoplayer2.upstream.cache.CacheDataSource.EventListener;
-
-/**
- * A {@link DataSource.Factory} that produces {@link CacheDataSource}.
- */
-public final class CacheDataSourceFactory implements DataSource.Factory {
-
-  private final Cache cache;
-  private final DataSource.Factory upstreamFactory;
-  private final DataSource.Factory cacheReadDataSourceFactory;
-  private final DataSink.Factory cacheWriteDataSinkFactory;
-  private final int flags;
-  private final EventListener eventListener;
-
-  /**
-   * @see CacheDataSource#CacheDataSource(Cache, DataSource)
-   */
-  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory) {
-    this(cache, upstreamFactory, 0);
-  }
-
-  /**
-   * @see CacheDataSource#CacheDataSource(Cache, DataSource, int)
-   */
-  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory,
-      @CacheDataSource.Flags int flags) {
-    this(cache, upstreamFactory, flags, CacheDataSource.DEFAULT_MAX_CACHE_FILE_SIZE);
-  }
-
-  /**
-   * @see CacheDataSource#CacheDataSource(Cache, DataSource, int, long)
-   */
-  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory,
-      @CacheDataSource.Flags int flags, long maxCacheFileSize) {
-    this(cache, upstreamFactory, new FileDataSourceFactory(),
-        new CacheDataSinkFactory(cache, maxCacheFileSize), flags, null);
-  }
-
-  /**
-   * @see CacheDataSource#CacheDataSource(Cache, DataSource, DataSource, DataSink, int,
-   *     EventListener)
-   */
-  public CacheDataSourceFactory(Cache cache, Factory upstreamFactory,
-      Factory cacheReadDataSourceFactory, DataSink.Factory cacheWriteDataSinkFactory,
-      @CacheDataSource.Flags int flags, EventListener eventListener) {
-    this.cache = cache;
-    this.upstreamFactory = upstreamFactory;
-    this.cacheReadDataSourceFactory = cacheReadDataSourceFactory;
-    this.cacheWriteDataSinkFactory = cacheWriteDataSinkFactory;
-    this.flags = flags;
-    this.eventListener = eventListener;
-  }
-
-  @Override
-  public CacheDataSource createDataSource() {
-    return new CacheDataSource(cache, upstreamFactory.createDataSource(),
-        cacheReadDataSourceFactory.createDataSource(),
-        cacheWriteDataSinkFactory != null ? cacheWriteDataSinkFactory.createDataSink() : null,
-        flags, eventListener);
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java
deleted file mode 100644
index 8944b45033..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheEvictor.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-/**
- * Evicts data from a {@link Cache}. Implementations should call {@link Cache#removeSpan(CacheSpan)}
- * to evict cache entries based on their eviction policies.
- */
-public interface CacheEvictor extends Cache.Listener {
-
-  /**
-   * Called when cache has been initialized.
-   */
-  void onCacheInitialized();
-
-  /**
-   * Called when a writer starts writing to the cache.
-   *
-   * @param cache The source of the event.
-   * @param key The key being written.
-   * @param position The starting position of the data being written.
-   * @param maxLength The maximum length of the data being written.
-   */
-  void onStartFile(Cache cache, String key, long position, long maxLength);
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java
deleted file mode 100644
index 97d55c5fe2..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheSpan.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import android.support.annotation.NonNull;
-import com.google.android.exoplayer2.C;
-import java.io.File;
-
-/**
- * Defines a span of data that may or may not be cached (as indicated by {@link #isCached}).
- */
-public class CacheSpan implements Comparable<CacheSpan> {
-
-  /**
-   * The cache key that uniquely identifies the original stream.
-   */
-  public final String key;
-  /**
-   * The position of the {@link CacheSpan} in the original stream.
-   */
-  public final long position;
-  /**
-   * The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an open-ended hole.
-   */
-  public final long length;
-  /**
-   * Whether the {@link CacheSpan} is cached.
-   */
-  public final boolean isCached;
-  /**
-   * The file corresponding to this {@link CacheSpan}, or null if {@link #isCached} is false.
-   */
-  public final File file;
-  /**
-   * The last access timestamp, or {@link C#TIME_UNSET} if {@link #isCached} is false.
-   */
-  public final long lastAccessTimestamp;
-
-  /**
-   * Creates a hole CacheSpan which isn't cached, has no last access time and no file associated.
-   *
-   * @param key The cache key that uniquely identifies the original stream.
-   * @param position The position of the {@link CacheSpan} in the original stream.
-   * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an
-   *     open-ended hole.
-   */
-  public CacheSpan(String key, long position, long length) {
-    this(key, position, length, C.TIME_UNSET, null);
-  }
-
-  /**
-   * Creates a CacheSpan.
-   *
-   * @param key The cache key that uniquely identifies the original stream.
-   * @param position The position of the {@link CacheSpan} in the original stream.
-   * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an
-   *     open-ended hole.
-   * @param lastAccessTimestamp The last access timestamp, or {@link C#TIME_UNSET} if
-   *     {@link #isCached} is false.
-   * @param file The file corresponding to this {@link CacheSpan}, or null if it's a hole.
-   */
-  public CacheSpan(String key, long position, long length, long lastAccessTimestamp, File file) {
-    this.key = key;
-    this.position = position;
-    this.length = length;
-    this.isCached = file != null;
-    this.file = file;
-    this.lastAccessTimestamp = lastAccessTimestamp;
-  }
-
-  /**
-   * Returns whether this is an open-ended {@link CacheSpan}.
-   */
-  public boolean isOpenEnded() {
-    return length == C.LENGTH_UNSET;
-  }
-
-  /**
-   * Returns whether this is a hole {@link CacheSpan}.
-   */
-  public boolean isHoleSpan() {
-    return !isCached;
-  }
-
-  @Override
-  public int compareTo(@NonNull CacheSpan another) {
-    if (!key.equals(another.key)) {
-      return key.compareTo(another.key);
-    }
-    long startOffsetDiff = position - another.position;
-    return startOffsetDiff == 0 ? 0 : ((startOffsetDiff < 0) ? -1 : 1);
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
deleted file mode 100644
index cf2dedbe54..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.PriorityTaskManager;
-import com.google.android.exoplayer2.util.Util;
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.NavigableSet;
-
-/**
- * Caching related utility methods.
- */
-@SuppressWarnings({"NonAtomicVolatileUpdate", "NonAtomicOperationOnVolatileField"})
-public final class CacheUtil {
-
-  /** Counters used during caching. */
-  public static class CachingCounters {
-    /** The number of bytes already in the cache. */
-    public volatile long alreadyCachedBytes;
-    /** The number of newly cached bytes. */
-    public volatile long newlyCachedBytes;
-    /** The length of the content being cached in bytes, or {@link C#LENGTH_UNSET} if unknown. */
-    public volatile long contentLength = C.LENGTH_UNSET;
-
-    /**
-     * Returns the sum of {@link #alreadyCachedBytes} and {@link #newlyCachedBytes}.
-     */
-    public long totalCachedBytes() {
-      return alreadyCachedBytes + newlyCachedBytes;
-    }
-  }
-
-  /** Default buffer size to be used while caching. */
-  public static final int DEFAULT_BUFFER_SIZE_BYTES = 128 * 1024;
-
-  /**
-   * Generates a cache key out of the given {@link Uri}.
-   *
-   * @param uri Uri of a content which the requested key is for.
-   */
-  public static String generateKey(Uri uri) {
-    return uri.toString();
-  }
-
-  /**
-   * Returns the {@code dataSpec.key} if not null, otherwise generates a cache key out of {@code
-   * dataSpec.uri}
-   *
-   * @param dataSpec Defines a content which the requested key is for.
-   */
-  public static String getKey(DataSpec dataSpec) {
-    return dataSpec.key != null ? dataSpec.key : generateKey(dataSpec.uri);
-  }
-
-  /**
-   * Sets a {@link CachingCounters} to contain the number of bytes already downloaded and the
-   * length for the content defined by a {@code dataSpec}. {@link CachingCounters#newlyCachedBytes}
-   * is reset to 0.
-   *
-   * @param dataSpec Defines the data to be checked.
-   * @param cache A {@link Cache} which has the data.
-   * @param counters The {@link CachingCounters} to update.
-   */
-  public static void getCached(DataSpec dataSpec, Cache cache, CachingCounters counters) {
-    String key = getKey(dataSpec);
-    long start = dataSpec.absoluteStreamPosition;
-    long left = dataSpec.length != C.LENGTH_UNSET ? dataSpec.length : cache.getContentLength(key);
-    counters.contentLength = left;
-    counters.alreadyCachedBytes = 0;
-    counters.newlyCachedBytes = 0;
-    while (left != 0) {
-      long blockLength = cache.getCachedBytes(key, start,
-          left != C.LENGTH_UNSET ? left : Long.MAX_VALUE);
-      if (blockLength > 0) {
-        counters.alreadyCachedBytes += blockLength;
-      } else {
-        blockLength = -blockLength;
-        if (blockLength == Long.MAX_VALUE) {
-          return;
-        }
-      }
-      start += blockLength;
-      left -= left == C.LENGTH_UNSET ? 0 : blockLength;
-    }
-  }
-
-  /**
-   * Caches the data defined by {@code dataSpec}, skipping already cached data. Caching stops early
-   * if the end of the input is reached.
-   *
-   * @param dataSpec Defines the data to be cached.
-   * @param cache A {@link Cache} to store the data.
-   * @param upstream A {@link DataSource} for reading data not in the cache.
-   * @param counters Counters to update during caching.
-   * @throws IOException If an error occurs reading from the source.
-   * @throws InterruptedException If the thread was interrupted.
-   */
-  public static void cache(DataSpec dataSpec, Cache cache, DataSource upstream,
-      CachingCounters counters) throws IOException, InterruptedException {
-    cache(dataSpec, cache, new CacheDataSource(cache, upstream),
-        new byte[DEFAULT_BUFFER_SIZE_BYTES], null, 0, counters, false);
-  }
-
-  /**
-   * Caches the data defined by {@code dataSpec} while skipping already cached data. Caching stops
-   * early if end of input is reached and {@code enableEOFException} is false.
-   *
-   * @param dataSpec Defines the data to be cached.
-   * @param cache A {@link Cache} to store the data.
-   * @param dataSource A {@link CacheDataSource} that works on the {@code cache}.
-   * @param buffer The buffer to be used while caching.
-   * @param priorityTaskManager If not null it's used to check whether it is allowed to proceed with
-   *     caching.
-   * @param priority The priority of this task. Used with {@code priorityTaskManager}.
-   * @param counters Counters to update during caching.
-   * @param enableEOFException Whether to throw an {@link EOFException} if end of input has been
-   *     reached unexpectedly.
-   * @throws IOException If an error occurs reading from the source.
-   * @throws InterruptedException If the thread was interrupted.
-   */
-  public static void cache(DataSpec dataSpec, Cache cache, CacheDataSource dataSource,
-      byte[] buffer, PriorityTaskManager priorityTaskManager, int priority,
-      CachingCounters counters, boolean enableEOFException)
-      throws IOException, InterruptedException {
-    Assertions.checkNotNull(dataSource);
-    Assertions.checkNotNull(buffer);
-
-    if (counters != null) {
-      // Initialize the CachingCounter values.
-      getCached(dataSpec, cache, counters);
-    } else {
-      // Dummy CachingCounters. No need to initialize as they will not be visible to the caller.
-      counters = new CachingCounters();
-    }
-
-    String key = getKey(dataSpec);
-    long start = dataSpec.absoluteStreamPosition;
-    long left = dataSpec.length != C.LENGTH_UNSET ? dataSpec.length : cache.getContentLength(key);
-    while (left != 0) {
-      long blockLength = cache.getCachedBytes(key, start,
-          left != C.LENGTH_UNSET ? left : Long.MAX_VALUE);
-      if (blockLength > 0) {
-        // Skip already cached data.
-      } else {
-        // There is a hole in the cache which is at least "-blockLength" long.
-        blockLength = -blockLength;
-        long read = readAndDiscard(dataSpec, start, blockLength, dataSource, buffer,
-            priorityTaskManager, priority, counters);
-        if (read < blockLength) {
-          // Reached to the end of the data.
-          if (enableEOFException && left != C.LENGTH_UNSET) {
-            throw new EOFException();
-          }
-          break;
-        }
-      }
-      start += blockLength;
-      left -= left == C.LENGTH_UNSET ? 0 : blockLength;
-    }
-  }
-
-  /**
-   * Reads and discards all data specified by the {@code dataSpec}.
-   *
-   * @param dataSpec Defines the data to be read. {@code absoluteStreamPosition} and {@code length}
-   *     fields are overwritten by the following parameters.
-   * @param absoluteStreamPosition The absolute position of the data to be read.
-   * @param length Length of the data to be read, or {@link C#LENGTH_UNSET} if it is unknown.
-   * @param dataSource The {@link DataSource} to read the data from.
-   * @param buffer The buffer to be used while downloading.
-   * @param priorityTaskManager If not null it's used to check whether it is allowed to proceed with
-   *     caching.
-   * @param priority The priority of this task.
-   * @param counters Counters to be set during reading.
-   * @return Number of read bytes, or 0 if no data is available because the end of the opened range
-   *     has been reached.
-   */
-  private static long readAndDiscard(DataSpec dataSpec, long absoluteStreamPosition, long length,
-      DataSource dataSource, byte[] buffer, PriorityTaskManager priorityTaskManager, int priority,
-      CachingCounters counters) throws IOException, InterruptedException {
-    while (true) {
-      if (priorityTaskManager != null) {
-        // Wait for any other thread with higher priority to finish its job.
-        priorityTaskManager.proceed(priority);
-      }
-      try {
-        if (Thread.interrupted()) {
-          throw new InterruptedException();
-        }
-        // Create a new dataSpec setting length to C.LENGTH_UNSET to prevent getting an error in
-        // case the given length exceeds the end of input.
-        dataSpec = new DataSpec(dataSpec.uri, dataSpec.postBody, absoluteStreamPosition,
-            dataSpec.position + absoluteStreamPosition - dataSpec.absoluteStreamPosition,
-            C.LENGTH_UNSET, dataSpec.key,
-            dataSpec.flags | DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
-        long resolvedLength = dataSource.open(dataSpec);
-        if (counters.contentLength == C.LENGTH_UNSET && resolvedLength != C.LENGTH_UNSET) {
-          counters.contentLength = dataSpec.absoluteStreamPosition + resolvedLength;
-        }
-        long totalRead = 0;
-        while (totalRead != length) {
-          if (Thread.interrupted()) {
-            throw new InterruptedException();
-          }
-          int read = dataSource.read(buffer, 0,
-              length != C.LENGTH_UNSET ? (int) Math.min(buffer.length, length - totalRead)
-                  : buffer.length);
-          if (read == C.RESULT_END_OF_INPUT) {
-            if (counters.contentLength == C.LENGTH_UNSET) {
-              counters.contentLength = dataSpec.absoluteStreamPosition + totalRead;
-            }
-            break;
-          }
-          totalRead += read;
-          counters.newlyCachedBytes += read;
-        }
-        return totalRead;
-      } catch (PriorityTaskManager.PriorityTooLowException exception) {
-        // catch and try again
-      } finally {
-        Util.closeQuietly(dataSource);
-      }
-    }
-  }
-
-  /** Removes all of the data in the {@code cache} pointed by the {@code key}. */
-  public static void remove(Cache cache, String key) {
-    NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(key);
-    if (cachedSpans == null) {
-      return;
-    }
-    for (CacheSpan cachedSpan : cachedSpans) {
-      try {
-        cache.removeSpan(cachedSpan);
-      } catch (Cache.CacheException e) {
-        // do nothing
-      }
-    }
-  }
-
-  private CacheUtil() {}
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
deleted file mode 100644
index fb59d23666..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.TreeSet;
-
-/**
- * Defines the cached content for a single stream.
- */
-/*package*/ final class CachedContent {
-
-  /**
-   * The cache file id that uniquely identifies the original stream.
-   */
-  public final int id;
-  /**
-   * The cache key that uniquely identifies the original stream.
-   */
-  public final String key;
-  /**
-   * The cached spans of this content.
-   */
-  private final TreeSet<SimpleCacheSpan> cachedSpans;
-  /**
-   * The length of the original stream, or {@link C#LENGTH_UNSET} if the length is unknown.
-   */
-  private long length;
-
-  /**
-   * Reads an instance from a {@link DataInputStream}.
-   *
-   * @param input Input stream containing values needed to initialize CachedContent instance.
-   * @throws IOException If an error occurs during reading values.
-   */
-  public CachedContent(DataInputStream input) throws IOException {
-    this(input.readInt(), input.readUTF(), input.readLong());
-  }
-
-  /**
-   * Creates a CachedContent.
-   *
-   * @param id The cache file id.
-   * @param key The cache stream key.
-   * @param length The length of the original stream.
-   */
-  public CachedContent(int id, String key, long length) {
-    this.id = id;
-    this.key = key;
-    this.length = length;
-    this.cachedSpans = new TreeSet<>();
-  }
-
-  /**
-   * Writes the instance to a {@link DataOutputStream}.
-   *
-   * @param output Output stream to store the values.
-   * @throws IOException If an error occurs during writing values to output.
-   */
-  public void writeToStream(DataOutputStream output) throws IOException {
-    output.writeInt(id);
-    output.writeUTF(key);
-    output.writeLong(length);
-  }
-
-  /** Returns the length of the content. */
-  public long getLength() {
-    return length;
-  }
-
-  /** Sets the length of the content. */
-  public void setLength(long length) {
-    this.length = length;
-  }
-
-  /** Adds the given {@link SimpleCacheSpan} which contains a part of the content. */
-  public void addSpan(SimpleCacheSpan span) {
-    cachedSpans.add(span);
-  }
-
-  /** Returns a set of all {@link SimpleCacheSpan}s. */
-  public TreeSet<SimpleCacheSpan> getSpans() {
-    return cachedSpans;
-  }
-
-  /**
-   * Returns the span containing the position. If there isn't one, it returns a hole span
-   * which defines the maximum extents of the hole in the cache.
-   */
-  public SimpleCacheSpan getSpan(long position) {
-    SimpleCacheSpan lookupSpan = SimpleCacheSpan.createLookup(key, position);
-    SimpleCacheSpan floorSpan = cachedSpans.floor(lookupSpan);
-    if (floorSpan != null && floorSpan.position + floorSpan.length > position) {
-      return floorSpan;
-    }
-    SimpleCacheSpan ceilSpan = cachedSpans.ceiling(lookupSpan);
-    return ceilSpan == null ? SimpleCacheSpan.createOpenHole(key, position)
-        : SimpleCacheSpan.createClosedHole(key, position, ceilSpan.position - position);
-  }
-
-  /**
-   * Returns the length of the cached data block starting from the {@code position} to the block end
-   * up to {@code length} bytes. If the {@code position} isn't cached then -(the length of the gap
-   * to the next cached data up to {@code length} bytes) is returned.
-   *
-   * @param position The starting position of the data.
-   * @param length The maximum length of the data to be returned.
-   * @return the length of the cached or not cached data block length.
-   */
-  public long getCachedBytes(long position, long length) {
-    SimpleCacheSpan span = getSpan(position);
-    if (span.isHoleSpan()) {
-      // We don't have a span covering the start of the queried region.
-      return -Math.min(span.isOpenEnded() ? Long.MAX_VALUE : span.length, length);
-    }
-    long queryEndPosition = position + length;
-    long currentEndPosition = span.position + span.length;
-    if (currentEndPosition < queryEndPosition) {
-      for (SimpleCacheSpan next : cachedSpans.tailSet(span, false)) {
-        if (next.position > currentEndPosition) {
-          // There's a hole in the cache within the queried region.
-          break;
-        }
-        // We expect currentEndPosition to always equal (next.position + next.length), but
-        // perform a max check anyway to guard against the existence of overlapping spans.
-        currentEndPosition = Math.max(currentEndPosition, next.position + next.length);
-        if (currentEndPosition >= queryEndPosition) {
-          // We've found spans covering the queried region.
-          break;
-        }
-      }
-    }
-    return Math.min(currentEndPosition - position, length);
-  }
-
-  /**
-   * Copies the given span with an updated last access time. Passed span becomes invalid after this
-   * call.
-   *
-   * @param cacheSpan Span to be copied and updated.
-   * @return a span with the updated last access time.
-   * @throws CacheException If renaming of the underlying span file failed.
-   */
-  public SimpleCacheSpan touch(SimpleCacheSpan cacheSpan) throws CacheException {
-    // Remove the old span from the in-memory representation.
-    Assertions.checkState(cachedSpans.remove(cacheSpan));
-    // Obtain a new span with updated last access timestamp.
-    SimpleCacheSpan newCacheSpan = cacheSpan.copyWithUpdatedLastAccessTime(id);
-    // Rename the cache file
-    if (!cacheSpan.file.renameTo(newCacheSpan.file)) {
-      throw new CacheException("Renaming of " + cacheSpan.file + " to " + newCacheSpan.file
-          + " failed.");
-    }
-    // Add the updated span back into the in-memory representation.
-    cachedSpans.add(newCacheSpan);
-    return newCacheSpan;
-  }
-
-  /** Returns whether there are any spans cached. */
-  public boolean isEmpty() {
-    return cachedSpans.isEmpty();
-  }
-
-  /** Removes the given span from cache. */
-  public boolean removeSpan(CacheSpan span) {
-    if (cachedSpans.remove(span)) {
-      span.file.delete();
-      return true;
-    }
-    return false;
-  }
-
-  /** Calculates a hash code for the header of this {@code CachedContent}. */
-  public int headerHashCode() {
-    int result = id;
-    result = 31 * result + key.hashCode();
-    result = 31 * result + (int) (length ^ (length >>> 32));
-    return result;
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
deleted file mode 100644
index 809f15b5a6..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import android.util.Log;
-import android.util.SparseArray;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.AtomicFile;
-import com.google.android.exoplayer2.util.ReusableBufferedOutputStream;
-import com.google.android.exoplayer2.util.Util;
-import java.io.BufferedInputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.security.InvalidAlgorithmParameterException;
-import java.security.InvalidKeyException;
-import java.security.NoSuchAlgorithmException;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.Random;
-import java.util.Set;
-import javax.crypto.Cipher;
-import javax.crypto.CipherInputStream;
-import javax.crypto.CipherOutputStream;
-import javax.crypto.NoSuchPaddingException;
-import javax.crypto.spec.IvParameterSpec;
-import javax.crypto.spec.SecretKeySpec;
-
-/**
- * This class maintains the index of cached content.
- */
-/*package*/ final class CachedContentIndex {
-
-  public static final String FILE_NAME = "cached_content_index.exi";
-
-  private static final int VERSION = 1;
-
-  private static final int FLAG_ENCRYPTED_INDEX = 1;
-
-  private static final String TAG = "CachedContentIndex";
-
-  private final HashMap<String, CachedContent> keyToContent;
-  private final SparseArray<String> idToKey;
-  private final AtomicFile atomicFile;
-  private final Cipher cipher;
-  private final SecretKeySpec secretKeySpec;
-  private final boolean encrypt;
-  private boolean changed;
-  private ReusableBufferedOutputStream bufferedOutputStream;
-
-  /**
-   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
-   *
-   * @param cacheDir Directory where the index file is kept.
-   */
-  public CachedContentIndex(File cacheDir) {
-    this(cacheDir, null);
-  }
-
-  /**
-   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
-   *
-   * @param cacheDir Directory where the index file is kept.
-   * @param secretKey 16 byte AES key for reading and writing the cache index.
-   */
-  public CachedContentIndex(File cacheDir, byte[] secretKey) {
-    this(cacheDir, secretKey, secretKey != null);
-  }
-
-  /**
-   * Creates a CachedContentIndex which works on the index file in the given cacheDir.
-   *
-   * @param cacheDir Directory where the index file is kept.
-   * @param secretKey 16 byte AES key for reading, and optionally writing, the cache index.
-   * @param encrypt When false, a plaintext index will be written.
-   */
-  public CachedContentIndex(File cacheDir, byte[] secretKey, boolean encrypt) {
-    this.encrypt = encrypt;
-    if (secretKey != null) {
-      Assertions.checkArgument(secretKey.length == 16);
-      try {
-        cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
-        secretKeySpec = new SecretKeySpec(secretKey, "AES");
-      } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
-        throw new IllegalStateException(e); // Should never happen.
-      }
-    } else {
-      cipher = null;
-      secretKeySpec = null;
-    }
-    keyToContent = new HashMap<>();
-    idToKey = new SparseArray<>();
-    atomicFile = new AtomicFile(new File(cacheDir, FILE_NAME));
-  }
-
-  /** Loads the index file. */
-  public void load() {
-    Assertions.checkState(!changed);
-    if (!readFile()) {
-      atomicFile.delete();
-      keyToContent.clear();
-      idToKey.clear();
-    }
-  }
-
-  /** Stores the index data to index file if there is a change. */
-  public void store() throws CacheException {
-    if (!changed) {
-      return;
-    }
-    writeFile();
-    changed = false;
-  }
-
-  /**
-   * Adds the given key to the index if it isn't there already.
-   *
-   * @param key The cache key that uniquely identifies the original stream.
-   * @return A new or existing CachedContent instance with the given key.
-   */
-  public CachedContent add(String key) {
-    CachedContent cachedContent = keyToContent.get(key);
-    if (cachedContent == null) {
-      cachedContent = addNew(key, C.LENGTH_UNSET);
-    }
-    return cachedContent;
-  }
-
-  /** Returns a CachedContent instance with the given key or null if there isn't one. */
-  public CachedContent get(String key) {
-    return keyToContent.get(key);
-  }
-
-  /**
-   * Returns a Collection of all CachedContent instances in the index. The collection is backed by
-   * the {@code keyToContent} map, so changes to the map are reflected in the collection, and
-   * vice-versa. If the map is modified while an iteration over the collection is in progress
-   * (except through the iterator's own remove operation), the results of the iteration are
-   * undefined.
-   */
-  public Collection<CachedContent> getAll() {
-    return keyToContent.values();
-  }
-
-  /** Returns an existing or new id assigned to the given key. */
-  public int assignIdForKey(String key) {
-    return add(key).id;
-  }
-
-  /** Returns the key which has the given id assigned. */
-  public String getKeyForId(int id) {
-    return idToKey.get(id);
-  }
-
-  /**
-   * Removes {@link CachedContent} with the given key from index. It shouldn't contain any spans.
-   *
-   * @throws IllegalStateException If {@link CachedContent} isn't empty.
-   */
-  public void removeEmpty(String key) {
-    CachedContent cachedContent = keyToContent.remove(key);
-    if (cachedContent != null) {
-      Assertions.checkState(cachedContent.isEmpty());
-      idToKey.remove(cachedContent.id);
-      changed = true;
-    }
-  }
-
-  /** Removes empty {@link CachedContent} instances from index. */
-  public void removeEmpty() {
-    LinkedList<String> cachedContentToBeRemoved = new LinkedList<>();
-    for (CachedContent cachedContent : keyToContent.values()) {
-      if (cachedContent.isEmpty()) {
-        cachedContentToBeRemoved.add(cachedContent.key);
-      }
-    }
-    for (String key : cachedContentToBeRemoved) {
-      removeEmpty(key);
-    }
-  }
-
-  /**
-   * Returns a set of all content keys. The set is backed by the {@code keyToContent} map, so
-   * changes to the map are reflected in the set, and vice-versa. If the map is modified while an
-   * iteration over the set is in progress (except through the iterator's own remove operation), the
-   * results of the iteration are undefined.
-   */
-  public Set<String> getKeys() {
-    return keyToContent.keySet();
-  }
-
-  /**
-   * Sets the content length for the given key. A new {@link CachedContent} is added if there isn't
-   * one already with the given key.
-   */
-  public void setContentLength(String key, long length) {
-    CachedContent cachedContent = get(key);
-    if (cachedContent != null) {
-      if (cachedContent.getLength() != length) {
-        cachedContent.setLength(length);
-        changed = true;
-      }
-    } else {
-      addNew(key, length);
-    }
-  }
-
-  /**
-   * Returns the content length for the given key if one set, or {@link
-   * com.google.android.exoplayer2.C#LENGTH_UNSET} otherwise.
-   */
-  public long getContentLength(String key) {
-    CachedContent cachedContent = get(key);
-    return cachedContent == null ? C.LENGTH_UNSET : cachedContent.getLength();
-  }
-
-  private boolean readFile() {
-    DataInputStream input = null;
-    try {
-      InputStream inputStream = new BufferedInputStream(atomicFile.openRead());
-      input = new DataInputStream(inputStream);
-      int version = input.readInt();
-      if (version != VERSION) {
-        // Currently there is no other version
-        return false;
-      }
-
-      int flags = input.readInt();
-      if ((flags & FLAG_ENCRYPTED_INDEX) != 0) {
-        if (cipher == null) {
-          return false;
-        }
-        byte[] initializationVector = new byte[16];
-        input.readFully(initializationVector);
-        IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
-        try {
-          cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
-        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
-          throw new IllegalStateException(e);
-        }
-        input = new DataInputStream(new CipherInputStream(inputStream, cipher));
-      } else {
-        if (cipher != null) {
-          changed = true; // Force index to be rewritten encrypted after read.
-        }
-      }
-
-      int count = input.readInt();
-      int hashCode = 0;
-      for (int i = 0; i < count; i++) {
-        CachedContent cachedContent = new CachedContent(input);
-        add(cachedContent);
-        hashCode += cachedContent.headerHashCode();
-      }
-      if (input.readInt() != hashCode) {
-        return false;
-      }
-    } catch (FileNotFoundException e) {
-      return false;
-    } catch (IOException e) {
-      Log.e(TAG, "Error reading cache content index file.", e);
-      return false;
-    } finally {
-      if (input != null) {
-        Util.closeQuietly(input);
-      }
-    }
-    return true;
-  }
-
-  private void writeFile() throws CacheException {
-    DataOutputStream output = null;
-    try {
-      OutputStream outputStream = atomicFile.startWrite();
-      if (bufferedOutputStream == null) {
-        bufferedOutputStream = new ReusableBufferedOutputStream(outputStream);
-      } else {
-        bufferedOutputStream.reset(outputStream);
-      }
-      output = new DataOutputStream(bufferedOutputStream);
-      output.writeInt(VERSION);
-
-      boolean writeEncrypted = encrypt && cipher != null;
-      int flags = writeEncrypted ? FLAG_ENCRYPTED_INDEX : 0;
-      output.writeInt(flags);
-
-      if (writeEncrypted) {
-        byte[] initializationVector = new byte[16];
-        new Random().nextBytes(initializationVector);
-        output.write(initializationVector);
-        IvParameterSpec ivParameterSpec = new IvParameterSpec(initializationVector);
-        try {
-          cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
-        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
-          throw new IllegalStateException(e); // Should never happen.
-        }
-        output.flush();
-        output = new DataOutputStream(new CipherOutputStream(bufferedOutputStream, cipher));
-      }
-
-      output.writeInt(keyToContent.size());
-      int hashCode = 0;
-      for (CachedContent cachedContent : keyToContent.values()) {
-        cachedContent.writeToStream(output);
-        hashCode += cachedContent.headerHashCode();
-      }
-      output.writeInt(hashCode);
-      atomicFile.endWrite(output);
-      // Avoid calling close twice. Duplicate CipherOutputStream.close calls did
-      // not used to be no-ops: https://android-review.googlesource.com/#/c/272799/
-      output = null;
-    } catch (IOException e) {
-      throw new CacheException(e);
-    } finally {
-      Util.closeQuietly(output);
-    }
-  }
-
-  private void add(CachedContent cachedContent) {
-    keyToContent.put(cachedContent.key, cachedContent);
-    idToKey.put(cachedContent.id, cachedContent.key);
-  }
-
-  /** Adds the given CachedContent to the index. */
-  /*package*/ void addNew(CachedContent cachedContent) {
-    add(cachedContent);
-    changed = true;
-  }
-
-  private CachedContent addNew(String key, long length) {
-    int id = getNewId(idToKey);
-    CachedContent cachedContent = new CachedContent(id, key, length);
-    addNew(cachedContent);
-    return cachedContent;
-  }
-
-  /**
-   * Returns an id which isn't used in the given array. If the maximum id in the array is smaller
-   * than {@link java.lang.Integer#MAX_VALUE} it just returns the next bigger integer. Otherwise it
-   * returns the smallest unused non-negative integer.
-   */
-  //@VisibleForTesting
-  public static int getNewId(SparseArray<String> idToKey) {
-    int size = idToKey.size();
-    int id = size == 0 ? 0 : (idToKey.keyAt(size - 1) + 1);
-    if (id < 0) { // In case if we pass max int value.
-      // TODO optimization: defragmentation or binary search?
-      for (id = 0; id < size; id++) {
-        if (id != idToKey.keyAt(id)) {
-          break;
-        }
-      }
-    }
-    return id;
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
deleted file mode 100644
index 9559054f6d..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import android.support.annotation.NonNull;
-import android.util.Log;
-import com.google.android.exoplayer2.extractor.ChunkIndex;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.NavigableSet;
-import java.util.TreeSet;
-
-/**
- * Utility class for efficiently tracking regions of data that are stored in a {@link Cache}
- * for a given cache key.
- */
-public final class CachedRegionTracker implements Cache.Listener {
-
-  private static final String TAG = "CachedRegionTracker";
-
-  public static final int NOT_CACHED = -1;
-  public static final int CACHED_TO_END = -2;
-
-  private final Cache cache;
-  private final String cacheKey;
-  private final ChunkIndex chunkIndex;
-
-  private final TreeSet<Region> regions;
-  private final Region lookupRegion;
-
-  public CachedRegionTracker(Cache cache, String cacheKey, ChunkIndex chunkIndex) {
-    this.cache = cache;
-    this.cacheKey = cacheKey;
-    this.chunkIndex = chunkIndex;
-    this.regions = new TreeSet<>();
-    this.lookupRegion = new Region(0, 0);
-
-    synchronized (this) {
-      NavigableSet<CacheSpan> cacheSpans = cache.addListener(cacheKey, this);
-      if (cacheSpans != null) {
-        // Merge the spans into regions. mergeSpan is more efficient when merging from high to low,
-        // which is why a descending iterator is used here.
-        Iterator<CacheSpan> spanIterator = cacheSpans.descendingIterator();
-        while (spanIterator.hasNext()) {
-          CacheSpan span = spanIterator.next();
-          mergeSpan(span);
-        }
-      }
-    }
-  }
-
-  public void release() {
-    cache.removeListener(cacheKey, this);
-  }
-
-  /**
-   * When provided with a byte offset, this method locates the cached region within which the
-   * offset falls, and returns the approximate end position in milliseconds of that region. If the
-   * byte offset does not fall within a cached region then {@link #NOT_CACHED} is returned.
-   * If the cached region extends to the end of the stream, {@link #CACHED_TO_END} is returned.
-   *
-   * @param byteOffset The byte offset in the underlying stream.
-   * @return The end position of the corresponding cache region, {@link #NOT_CACHED}, or
-   *     {@link #CACHED_TO_END}.
-   */
-  public synchronized int getRegionEndTimeMs(long byteOffset) {
-    lookupRegion.startOffset = byteOffset;
-    Region floorRegion = regions.floor(lookupRegion);
-    if (floorRegion == null || byteOffset > floorRegion.endOffset
-        || floorRegion.endOffsetIndex == -1) {
-      return NOT_CACHED;
-    }
-    int index = floorRegion.endOffsetIndex;
-    if (index == chunkIndex.length - 1
-        && floorRegion.endOffset == (chunkIndex.offsets[index] + chunkIndex.sizes[index])) {
-      return CACHED_TO_END;
-    }
-    long segmentFractionUs = (chunkIndex.durationsUs[index]
-        * (floorRegion.endOffset - chunkIndex.offsets[index])) / chunkIndex.sizes[index];
-    return (int) ((chunkIndex.timesUs[index] + segmentFractionUs) / 1000);
-  }
-
-  @Override
-  public synchronized void onSpanAdded(Cache cache, CacheSpan span) {
-    mergeSpan(span);
-  }
-
-  @Override
-  public synchronized void onSpanRemoved(Cache cache, CacheSpan span) {
-    Region removedRegion = new Region(span.position, span.position + span.length);
-
-    // Look up a region this span falls into.
-    Region floorRegion = regions.floor(removedRegion);
-    if (floorRegion == null) {
-      Log.e(TAG, "Removed a span we were not aware of");
-      return;
-    }
-
-    // Remove it.
-    regions.remove(floorRegion);
-
-    // Add new floor and ceiling regions, if necessary.
-    if (floorRegion.startOffset < removedRegion.startOffset) {
-      Region newFloorRegion = new Region(floorRegion.startOffset, removedRegion.startOffset);
-
-      int index = Arrays.binarySearch(chunkIndex.offsets, newFloorRegion.endOffset);
-      newFloorRegion.endOffsetIndex = index < 0 ? -index - 2 : index;
-      regions.add(newFloorRegion);
-    }
-
-    if (floorRegion.endOffset > removedRegion.endOffset) {
-      Region newCeilingRegion = new Region(removedRegion.endOffset + 1, floorRegion.endOffset);
-      newCeilingRegion.endOffsetIndex = floorRegion.endOffsetIndex;
-      regions.add(newCeilingRegion);
-    }
-  }
-
-  @Override
-  public void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan) {
-    // Do nothing.
-  }
-
-  private void mergeSpan(CacheSpan span) {
-    Region newRegion = new Region(span.position, span.position + span.length);
-    Region floorRegion = regions.floor(newRegion);
-    Region ceilingRegion = regions.ceiling(newRegion);
-    boolean floorConnects = regionsConnect(floorRegion, newRegion);
-    boolean ceilingConnects = regionsConnect(newRegion, ceilingRegion);
-
-    if (ceilingConnects) {
-      if (floorConnects) {
-        // Extend floorRegion to cover both newRegion and ceilingRegion.
-        floorRegion.endOffset = ceilingRegion.endOffset;
-        floorRegion.endOffsetIndex = ceilingRegion.endOffsetIndex;
-      } else {
-        // Extend newRegion to cover ceilingRegion. Add it.
-        newRegion.endOffset = ceilingRegion.endOffset;
-        newRegion.endOffsetIndex = ceilingRegion.endOffsetIndex;
-        regions.add(newRegion);
-      }
-      regions.remove(ceilingRegion);
-    } else if (floorConnects) {
-      // Extend floorRegion to the right to cover newRegion.
-      floorRegion.endOffset = newRegion.endOffset;
-      int index = floorRegion.endOffsetIndex;
-      while (index < chunkIndex.length - 1
-          && (chunkIndex.offsets[index + 1] <= floorRegion.endOffset)) {
-        index++;
-      }
-      floorRegion.endOffsetIndex = index;
-    } else {
-      // This is a new region.
-      int index = Arrays.binarySearch(chunkIndex.offsets, newRegion.endOffset);
-      newRegion.endOffsetIndex = index < 0 ? -index - 2 : index;
-      regions.add(newRegion);
-    }
-  }
-
-  private boolean regionsConnect(Region lower, Region upper) {
-    return lower != null && upper != null && lower.endOffset == upper.startOffset;
-  }
-
-  private static class Region implements Comparable<Region> {
-
-    /**
-     * The first byte of the region (inclusive).
-     */
-    public long startOffset;
-    /**
-     * End offset of the region (exclusive).
-     */
-    public long endOffset;
-    /**
-     * The index in chunkIndex that contains the end offset. May be -1 if the end offset comes
-     * before the start of the first media chunk (i.e. if the end offset is within the stream
-     * header).
-     */
-    public int endOffsetIndex;
-
-    public Region(long position, long endOffset) {
-      this.startOffset = position;
-      this.endOffset = endOffset;
-    }
-
-    @Override
-    public int compareTo(@NonNull Region another) {
-      return startOffset < another.startOffset ? -1
-          : startOffset == another.startOffset ? 0 : 1;
-    }
-
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
deleted file mode 100644
index d2a84f65f4..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictor.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
-import java.util.Comparator;
-import java.util.TreeSet;
-
-/**
- * Evicts least recently used cache files first.
- */
-public final class LeastRecentlyUsedCacheEvictor implements CacheEvictor, Comparator<CacheSpan> {
-
-  private final long maxBytes;
-  private final TreeSet<CacheSpan> leastRecentlyUsed;
-
-  private long currentSize;
-
-  public LeastRecentlyUsedCacheEvictor(long maxBytes) {
-    this.maxBytes = maxBytes;
-    this.leastRecentlyUsed = new TreeSet<>(this);
-  }
-
-  @Override
-  public void onCacheInitialized() {
-    // Do nothing.
-  }
-
-  @Override
-  public void onStartFile(Cache cache, String key, long position, long maxLength) {
-    evictCache(cache, maxLength);
-  }
-
-  @Override
-  public void onSpanAdded(Cache cache, CacheSpan span) {
-    leastRecentlyUsed.add(span);
-    currentSize += span.length;
-    evictCache(cache, 0);
-  }
-
-  @Override
-  public void onSpanRemoved(Cache cache, CacheSpan span) {
-    leastRecentlyUsed.remove(span);
-    currentSize -= span.length;
-  }
-
-  @Override
-  public void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan) {
-    onSpanRemoved(cache, oldSpan);
-    onSpanAdded(cache, newSpan);
-  }
-
-  @Override
-  public int compare(CacheSpan lhs, CacheSpan rhs) {
-    long lastAccessTimestampDelta = lhs.lastAccessTimestamp - rhs.lastAccessTimestamp;
-    if (lastAccessTimestampDelta == 0) {
-      // Use the standard compareTo method as a tie-break.
-      return lhs.compareTo(rhs);
-    }
-    return lhs.lastAccessTimestamp < rhs.lastAccessTimestamp ? -1 : 1;
-  }
-
-  private void evictCache(Cache cache, long requiredSpace) {
-    while (currentSize + requiredSpace > maxBytes) {
-      try {
-        cache.removeSpan(leastRecentlyUsed.first());
-      } catch (CacheException e) {
-        // do nothing.
-      }
-    }
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/NoOpCacheEvictor.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/NoOpCacheEvictor.java
deleted file mode 100644
index b0c8c7e087..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/NoOpCacheEvictor.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-
-/**
- * Evictor that doesn't ever evict cache files.
- *
- * Warning: Using this evictor might have unforeseeable consequences if cache
- * size is not managed elsewhere.
- */
-public final class NoOpCacheEvictor implements CacheEvictor {
-
-  @Override
-  public void onCacheInitialized() {
-    // Do nothing.
-  }
-
-  @Override
-  public void onStartFile(Cache cache, String key, long position, long maxLength) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onSpanAdded(Cache cache, CacheSpan span) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onSpanRemoved(Cache cache, CacheSpan span) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onSpanTouched(Cache cache, CacheSpan oldSpan, CacheSpan newSpan) {
-    // Do nothing.
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
deleted file mode 100644
index 15a5673a4e..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ /dev/null
@@ -1,394 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import android.os.ConditionVariable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.NavigableSet;
-import java.util.Set;
-import java.util.TreeSet;
-
-/**
- * A {@link Cache} implementation that maintains an in-memory representation.
- */
-public final class SimpleCache implements Cache {
-
-  private final File cacheDir;
-  private final CacheEvictor evictor;
-  private final HashMap<String, CacheSpan> lockedSpans;
-  private final CachedContentIndex index;
-  private final HashMap<String, ArrayList<Listener>> listeners;
-  private long totalSpace = 0;
-  private CacheException initializationException;
-
-  /**
-   * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence
-   * the directory cannot be used to store other files.
-   *
-   * @param cacheDir A dedicated cache directory.
-   * @param evictor The evictor to be used.
-   */
-  public SimpleCache(File cacheDir, CacheEvictor evictor) {
-    this(cacheDir, evictor, null);
-  }
-
-  /**
-   * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence
-   * the directory cannot be used to store other files.
-   *
-   * @param cacheDir A dedicated cache directory.
-   * @param evictor The evictor to be used.
-   * @param secretKey If not null, cache keys will be stored encrypted on filesystem using AES/CBC.
-   *     The key must be 16 bytes long.
-   */
-  public SimpleCache(File cacheDir, CacheEvictor evictor, byte[] secretKey) {
-    this(cacheDir, evictor, secretKey, secretKey != null);
-  }
-
-  /**
-   * Constructs the cache. The cache will delete any unrecognized files from the directory. Hence
-   * the directory cannot be used to store other files.
-   *
-   * @param cacheDir A dedicated cache directory.
-   * @param evictor The evictor to be used.
-   * @param secretKey If not null, cache keys will be stored encrypted on filesystem using AES/CBC.
-   *     The key must be 16 bytes long.
-   * @param encrypt When false, a plaintext index will be written.
-   */
-  public SimpleCache(File cacheDir, CacheEvictor evictor, byte[] secretKey, boolean encrypt) {
-    this.cacheDir = cacheDir;
-    this.evictor = evictor;
-    this.lockedSpans = new HashMap<>();
-    this.index = new CachedContentIndex(cacheDir, secretKey, encrypt);
-    this.listeners = new HashMap<>();
-    // Start cache initialization.
-    final ConditionVariable conditionVariable = new ConditionVariable();
-    new Thread("SimpleCache.initialize()") {
-      @Override
-      public void run() {
-        synchronized (SimpleCache.this) {
-          conditionVariable.open();
-          try {
-            initialize();
-          } catch (CacheException e) {
-            initializationException = e;
-          }
-          SimpleCache.this.evictor.onCacheInitialized();
-        }
-      }
-    }.start();
-    conditionVariable.block();
-  }
-
-  @Override
-  public synchronized NavigableSet<CacheSpan> addListener(String key, Listener listener) {
-    ArrayList<Listener> listenersForKey = listeners.get(key);
-    if (listenersForKey == null) {
-      listenersForKey = new ArrayList<>();
-      listeners.put(key, listenersForKey);
-    }
-    listenersForKey.add(listener);
-    return getCachedSpans(key);
-  }
-
-  @Override
-  public synchronized void removeListener(String key, Listener listener) {
-    ArrayList<Listener> listenersForKey = listeners.get(key);
-    if (listenersForKey != null) {
-      listenersForKey.remove(listener);
-      if (listenersForKey.isEmpty()) {
-        listeners.remove(key);
-      }
-    }
-  }
-
-  @Override
-  public synchronized NavigableSet<CacheSpan> getCachedSpans(String key) {
-    CachedContent cachedContent = index.get(key);
-    return cachedContent == null || cachedContent.isEmpty() ? null
-        : new TreeSet<CacheSpan>(cachedContent.getSpans());
-  }
-
-  @Override
-  public synchronized Set<String> getKeys() {
-    return new HashSet<>(index.getKeys());
-  }
-
-  @Override
-  public synchronized long getCacheSpace() {
-    return totalSpace;
-  }
-
-  @Override
-  public synchronized SimpleCacheSpan startReadWrite(String key, long position)
-      throws InterruptedException, CacheException {
-    while (true) {
-      SimpleCacheSpan span = startReadWriteNonBlocking(key, position);
-      if (span != null) {
-        return span;
-      } else {
-        // Write case, lock not available. We'll be woken up when a locked span is released (if the
-        // released lock is for the requested key then we'll be able to make progress) or when a
-        // span is added to the cache (if the span is for the requested key and covers the requested
-        // position, then we'll become a read and be able to make progress).
-        wait();
-      }
-    }
-  }
-
-  @Override
-  public synchronized SimpleCacheSpan startReadWriteNonBlocking(String key, long position)
-      throws CacheException {
-    if (initializationException != null) {
-      throw initializationException;
-    }
-
-    SimpleCacheSpan cacheSpan = getSpan(key, position);
-
-    // Read case.
-    if (cacheSpan.isCached) {
-      // Obtain a new span with updated last access timestamp.
-      SimpleCacheSpan newCacheSpan = index.get(key).touch(cacheSpan);
-      notifySpanTouched(cacheSpan, newCacheSpan);
-      return newCacheSpan;
-    }
-
-    // Write case, lock available.
-    if (!lockedSpans.containsKey(key)) {
-      lockedSpans.put(key, cacheSpan);
-      return cacheSpan;
-    }
-
-    // Write case, lock not available.
-    return null;
-  }
-
-  @Override
-  public synchronized File startFile(String key, long position, long maxLength)
-      throws CacheException {
-    Assertions.checkState(lockedSpans.containsKey(key));
-    if (!cacheDir.exists()) {
-      // For some reason the cache directory doesn't exist. Make a best effort to create it.
-      removeStaleSpansAndCachedContents();
-      cacheDir.mkdirs();
-    }
-    evictor.onStartFile(this, key, position, maxLength);
-    return SimpleCacheSpan.getCacheFile(cacheDir, index.assignIdForKey(key), position,
-        System.currentTimeMillis());
-  }
-
-  @Override
-  public synchronized void commitFile(File file) throws CacheException {
-    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(file, index);
-    Assertions.checkState(span != null);
-    Assertions.checkState(lockedSpans.containsKey(span.key));
-    // If the file doesn't exist, don't add it to the in-memory representation.
-    if (!file.exists()) {
-      return;
-    }
-    // If the file has length 0, delete it and don't add it to the in-memory representation.
-    if (file.length() == 0) {
-      file.delete();
-      return;
-    }
-    // Check if the span conflicts with the set content length
-    Long length = getContentLength(span.key);
-    if (length != C.LENGTH_UNSET) {
-      Assertions.checkState((span.position + span.length) <= length);
-    }
-    addSpan(span);
-    index.store();
-    notifyAll();
-  }
-
-  @Override
-  public synchronized void releaseHoleSpan(CacheSpan holeSpan) {
-    Assertions.checkState(holeSpan == lockedSpans.remove(holeSpan.key));
-    notifyAll();
-  }
-
-  /**
-   * Returns the cache {@link SimpleCacheSpan} corresponding to the provided lookup {@link
-   * SimpleCacheSpan}.
-   *
-   * <p>If the lookup position is contained by an existing entry in the cache, then the returned
-   * {@link SimpleCacheSpan} defines the file in which the data is stored. If the lookup position is
-   * not contained by an existing entry, then the returned {@link SimpleCacheSpan} defines the
-   * maximum extents of the hole in the cache.
-   *
-   * @param key The key of the span being requested.
-   * @param position The position of the span being requested.
-   * @return The corresponding cache {@link SimpleCacheSpan}.
-   */
-  private SimpleCacheSpan getSpan(String key, long position) throws CacheException {
-    CachedContent cachedContent = index.get(key);
-    if (cachedContent == null) {
-      return SimpleCacheSpan.createOpenHole(key, position);
-    }
-    while (true) {
-      SimpleCacheSpan span = cachedContent.getSpan(position);
-      if (span.isCached && !span.file.exists()) {
-        // The file has been deleted from under us. It's likely that other files will have been
-        // deleted too, so scan the whole in-memory representation.
-        removeStaleSpansAndCachedContents();
-        continue;
-      }
-      return span;
-    }
-  }
-
-  /**
-   * Ensures that the cache's in-memory representation has been initialized.
-   */
-  private void initialize() throws CacheException {
-    if (!cacheDir.exists()) {
-      cacheDir.mkdirs();
-      return;
-    }
-
-    index.load();
-
-    File[] files = cacheDir.listFiles();
-    if (files == null) {
-      return;
-    }
-    for (File file : files) {
-      if (file.getName().equals(CachedContentIndex.FILE_NAME)) {
-        continue;
-      }
-      SimpleCacheSpan span = file.length() > 0
-          ? SimpleCacheSpan.createCacheEntry(file, index) : null;
-      if (span != null) {
-        addSpan(span);
-      } else {
-        file.delete();
-      }
-    }
-
-    index.removeEmpty();
-    index.store();
-  }
-
-  /**
-   * Adds a cached span to the in-memory representation.
-   *
-   * @param span The span to be added.
-   */
-  private void addSpan(SimpleCacheSpan span) {
-    index.add(span.key).addSpan(span);
-    totalSpace += span.length;
-    notifySpanAdded(span);
-  }
-
-  private void removeSpan(CacheSpan span, boolean removeEmptyCachedContent) throws CacheException {
-    CachedContent cachedContent = index.get(span.key);
-    if (cachedContent == null || !cachedContent.removeSpan(span)) {
-      return;
-    }
-    totalSpace -= span.length;
-    if (removeEmptyCachedContent && cachedContent.isEmpty()) {
-      index.removeEmpty(cachedContent.key);
-      index.store();
-    }
-    notifySpanRemoved(span);
-  }
-
-  @Override
-  public synchronized void removeSpan(CacheSpan span) throws CacheException {
-    removeSpan(span, true);
-  }
-
-  /**
-   * Scans all of the cached spans in the in-memory representation, removing any for which files
-   * no longer exist.
-   */
-  private void removeStaleSpansAndCachedContents() throws CacheException {
-    LinkedList<CacheSpan> spansToBeRemoved = new LinkedList<>();
-    for (CachedContent cachedContent : index.getAll()) {
-      for (CacheSpan span : cachedContent.getSpans()) {
-        if (!span.file.exists()) {
-          spansToBeRemoved.add(span);
-        }
-      }
-    }
-    for (CacheSpan span : spansToBeRemoved) {
-      // Remove span but not CachedContent to prevent multiple index.store() calls.
-      removeSpan(span, false);
-    }
-    index.removeEmpty();
-    index.store();
-  }
-
-  private void notifySpanRemoved(CacheSpan span) {
-    ArrayList<Listener> keyListeners = listeners.get(span.key);
-    if (keyListeners != null) {
-      for (int i = keyListeners.size() - 1; i >= 0; i--) {
-        keyListeners.get(i).onSpanRemoved(this, span);
-      }
-    }
-    evictor.onSpanRemoved(this, span);
-  }
-
-  private void notifySpanAdded(SimpleCacheSpan span) {
-    ArrayList<Listener> keyListeners = listeners.get(span.key);
-    if (keyListeners != null) {
-      for (int i = keyListeners.size() - 1; i >= 0; i--) {
-        keyListeners.get(i).onSpanAdded(this, span);
-      }
-    }
-    evictor.onSpanAdded(this, span);
-  }
-
-  private void notifySpanTouched(SimpleCacheSpan oldSpan, CacheSpan newSpan) {
-    ArrayList<Listener> keyListeners = listeners.get(oldSpan.key);
-    if (keyListeners != null) {
-      for (int i = keyListeners.size() - 1; i >= 0; i--) {
-        keyListeners.get(i).onSpanTouched(this, oldSpan, newSpan);
-      }
-    }
-    evictor.onSpanTouched(this, oldSpan, newSpan);
-  }
-
-  @Override
-  public synchronized boolean isCached(String key, long position, long length) {
-    CachedContent cachedContent = index.get(key);
-    return cachedContent != null && cachedContent.getCachedBytes(position, length) >= length;
-  }
-
-  @Override
-  public synchronized long getCachedBytes(String key, long position, long length) {
-    CachedContent cachedContent = index.get(key);
-    return cachedContent != null ? cachedContent.getCachedBytes(position, length) : -length;
-  }
-
-  @Override
-  public synchronized void setContentLength(String key, long length) throws CacheException {
-    index.setContentLength(key, length);
-    index.store();
-  }
-
-  @Override
-  public synchronized long getContentLength(String key) {
-    return index.getContentLength(key);
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
deleted file mode 100644
index 8c5b7e26e7..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
-import java.io.File;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * This class stores span metadata in filename.
- */
-/*package*/ final class SimpleCacheSpan extends CacheSpan {
-
-  private static final String SUFFIX = ".v3.exo";
-  private static final Pattern CACHE_FILE_PATTERN_V1 = Pattern.compile(
-      "^(.+)\\.(\\d+)\\.(\\d+)\\.v1\\.exo$", Pattern.DOTALL);
-  private static final Pattern CACHE_FILE_PATTERN_V2 = Pattern.compile(
-      "^(.+)\\.(\\d+)\\.(\\d+)\\.v2\\.exo$", Pattern.DOTALL);
-  private static final Pattern CACHE_FILE_PATTERN_V3 = Pattern.compile(
-      "^(\\d+)\\.(\\d+)\\.(\\d+)\\.v3\\.exo$", Pattern.DOTALL);
-
-  public static File getCacheFile(File cacheDir, int id, long position,
-      long lastAccessTimestamp) {
-    return new File(cacheDir, id + "." + position + "." + lastAccessTimestamp + SUFFIX);
-  }
-
-  public static SimpleCacheSpan createLookup(String key, long position) {
-    return new SimpleCacheSpan(key, position, C.LENGTH_UNSET, C.TIME_UNSET, null);
-  }
-
-  public static SimpleCacheSpan createOpenHole(String key, long position) {
-    return new SimpleCacheSpan(key, position, C.LENGTH_UNSET, C.TIME_UNSET, null);
-  }
-
-  public static SimpleCacheSpan createClosedHole(String key, long position, long length) {
-    return new SimpleCacheSpan(key, position, length, C.TIME_UNSET, null);
-  }
-
-  /**
-   * Creates a cache span from an underlying cache file. Upgrades the file if necessary.
-   *
-   * @param file The cache file.
-   * @param index Cached content index.
-   * @return The span, or null if the file name is not correctly formatted, or if the id is not
-   *     present in the content index.
-   */
-  public static SimpleCacheSpan createCacheEntry(File file, CachedContentIndex index) {
-    String name = file.getName();
-    if (!name.endsWith(SUFFIX)) {
-      file = upgradeFile(file, index);
-      if (file == null) {
-        return null;
-      }
-      name = file.getName();
-    }
-
-    Matcher matcher = CACHE_FILE_PATTERN_V3.matcher(name);
-    if (!matcher.matches()) {
-      return null;
-    }
-    long length = file.length();
-    int id = Integer.parseInt(matcher.group(1));
-    String key = index.getKeyForId(id);
-    return key == null ? null : new SimpleCacheSpan(key, Long.parseLong(matcher.group(2)), length,
-        Long.parseLong(matcher.group(3)), file);
-  }
-
-  private static File upgradeFile(File file, CachedContentIndex index) {
-    String key;
-    String filename = file.getName();
-    Matcher matcher = CACHE_FILE_PATTERN_V2.matcher(filename);
-    if (matcher.matches()) {
-      key = Util.unescapeFileName(matcher.group(1));
-      if (key == null) {
-        return null;
-      }
-    } else {
-      matcher = CACHE_FILE_PATTERN_V1.matcher(filename);
-      if (!matcher.matches()) {
-        return null;
-      }
-      key = matcher.group(1); // Keys were not escaped in version 1.
-    }
-
-    File newCacheFile = getCacheFile(file.getParentFile(), index.assignIdForKey(key),
-        Long.parseLong(matcher.group(2)), Long.parseLong(matcher.group(3)));
-    if (!file.renameTo(newCacheFile)) {
-      return null;
-    }
-    return newCacheFile;
-  }
-
-  private SimpleCacheSpan(String key, long position, long length, long lastAccessTimestamp,
-      File file) {
-    super(key, position, length, lastAccessTimestamp, file);
-  }
-
-  /**
-   * Returns a copy of this CacheSpan whose last access time stamp is set to current time. This
-   * doesn't copy or change the underlying cache file.
-   *
-   * @param id The cache file id.
-   * @return A {@link SimpleCacheSpan} with updated last access time stamp.
-   * @throws IllegalStateException If called on a non-cached span (i.e. {@link #isCached} is false).
-   */
-  public SimpleCacheSpan copyWithUpdatedLastAccessTime(int id) {
-    Assertions.checkState(isCached);
-    long now = System.currentTimeMillis();
-    File newCacheFile = getCacheFile(file.getParentFile(), id, position, now);
-    return new SimpleCacheSpan(key, position, length, now, newCacheFile);
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
deleted file mode 100644
index ccf9a5b3f5..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSink.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.crypto;
-
-import com.google.android.exoplayer2.upstream.DataSink;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import java.io.IOException;
-import javax.crypto.Cipher;
-
-/**
- * A wrapping {@link DataSink} that encrypts the data being consumed.
- */
-public final class AesCipherDataSink implements DataSink {
-
-  private final DataSink wrappedDataSink;
-  private final byte[] secretKey;
-  private final byte[] scratch;
-
-  private AesFlushingCipher cipher;
-
-  /**
-   * Create an instance whose {@code write} methods have the side effect of overwriting the input
-   * {@code data}. Use this constructor for maximum efficiency in the case that there is no
-   * requirement for the input data arrays to remain unchanged.
-   *
-   * @param secretKey The key data.
-   * @param wrappedDataSink The wrapped {@link DataSink}.
-   */
-  public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink) {
-    this(secretKey, wrappedDataSink, null);
-  }
-
-  /**
-   * Create an instance whose {@code write} methods are free of side effects. Use this constructor
-   * when the input data arrays are required to remain unchanged.
-   *
-   * @param secretKey The key data.
-   * @param wrappedDataSink The wrapped {@link DataSink}.
-   * @param scratch Scratch space. Data is decrypted into this array before being written to the
-   *     wrapped {@link DataSink}. It should be of appropriate size for the expected writes. If a
-   *     write is larger than the size of this array the write will still succeed, but multiple
-   *     cipher calls will be required to complete the operation.
-   */
-  public AesCipherDataSink(byte[] secretKey, DataSink wrappedDataSink, byte[] scratch) {
-    this.wrappedDataSink = wrappedDataSink;
-    this.secretKey = secretKey;
-    this.scratch = scratch;
-  }
-
-  @Override
-  public void open(DataSpec dataSpec) throws IOException {
-    wrappedDataSink.open(dataSpec);
-    long nonce = CryptoUtil.getFNV64Hash(dataSpec.key);
-    cipher = new AesFlushingCipher(Cipher.ENCRYPT_MODE, secretKey, nonce,
-        dataSpec.absoluteStreamPosition);
-  }
-
-  @Override
-  public void write(byte[] data, int offset, int length) throws IOException {
-    if (scratch == null) {
-      // In-place mode. Writes over the input data.
-      cipher.updateInPlace(data, offset, length);
-      wrappedDataSink.write(data, offset, length);
-    } else {
-      // Use scratch space. The original data remains intact.
-      int bytesProcessed = 0;
-      while (bytesProcessed < length) {
-        int bytesToProcess = Math.min(length - bytesProcessed, scratch.length);
-        cipher.update(data, offset + bytesProcessed, bytesToProcess, scratch, 0);
-        wrappedDataSink.write(scratch, 0, bytesToProcess);
-        bytesProcessed += bytesToProcess;
-      }
-    }
-  }
-
-  @Override
-  public void close() throws IOException {
-    cipher = null;
-    wrappedDataSink.close();
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
deleted file mode 100644
index 26ac3b38fa..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesCipherDataSource.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.crypto;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import java.io.IOException;
-import javax.crypto.Cipher;
-
-/**
- * A {@link DataSource} that decrypts the data read from an upstream source.
- */
-public final class AesCipherDataSource implements DataSource {
-
-  private final DataSource upstream;
-  private final byte[] secretKey;
-
-  private AesFlushingCipher cipher;
-
-  public AesCipherDataSource(byte[] secretKey, DataSource upstream) {
-    this.upstream = upstream;
-    this.secretKey = secretKey;
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws IOException {
-    long dataLength = upstream.open(dataSpec);
-    long nonce = CryptoUtil.getFNV64Hash(dataSpec.key);
-    cipher = new AesFlushingCipher(Cipher.DECRYPT_MODE, secretKey, nonce,
-        dataSpec.absoluteStreamPosition);
-    return dataLength;
-  }
-
-  @Override
-  public int read(byte[] data, int offset, int readLength) throws IOException {
-    if (readLength == 0) {
-      return 0;
-    }
-    int read = upstream.read(data, offset, readLength);
-    if (read == C.RESULT_END_OF_INPUT) {
-      return C.RESULT_END_OF_INPUT;
-    }
-    cipher.updateInPlace(data, offset, read);
-    return read;
-  }
-
-  @Override
-  public void close() throws IOException {
-    cipher = null;
-    upstream.close();
-  }
-
-  @Override
-  public Uri getUri() {
-    return upstream.getUri();
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java
deleted file mode 100644
index e093eb3064..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipher.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.crypto;
-
-import com.google.android.exoplayer2.util.Assertions;
-import java.nio.ByteBuffer;
-import java.security.InvalidAlgorithmParameterException;
-import java.security.InvalidKeyException;
-import java.security.NoSuchAlgorithmException;
-import javax.crypto.Cipher;
-import javax.crypto.NoSuchPaddingException;
-import javax.crypto.ShortBufferException;
-import javax.crypto.spec.IvParameterSpec;
-import javax.crypto.spec.SecretKeySpec;
-
-/**
- * A flushing variant of a AES/CTR/NoPadding {@link Cipher}.
- *
- * Unlike a regular {@link Cipher}, the update methods of this class are guaranteed to process all
- * of the bytes input (and hence output the same number of bytes).
- */
-public final class AesFlushingCipher {
-
-  private final Cipher cipher;
-  private final int blockSize;
-  private final byte[] zerosBlock;
-  private final byte[] flushedBlock;
-
-  private int pendingXorBytes;
-
-  public AesFlushingCipher(int mode, byte[] secretKey, long nonce, long offset) {
-    try {
-      cipher = Cipher.getInstance("AES/CTR/NoPadding");
-      blockSize = cipher.getBlockSize();
-      zerosBlock = new byte[blockSize];
-      flushedBlock = new byte[blockSize];
-      long counter = offset / blockSize;
-      int startPadding = (int) (offset % blockSize);
-      cipher.init(mode, new SecretKeySpec(secretKey, cipher.getAlgorithm().split("/")[0]),
-          new IvParameterSpec(getInitializationVector(nonce, counter)));
-      if (startPadding != 0) {
-        updateInPlace(new byte[startPadding], 0, startPadding);
-      }
-    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException
-        | InvalidAlgorithmParameterException e) {
-      // Should never happen.
-      throw new RuntimeException(e);
-    }
-  }
-
-  public void updateInPlace(byte[] data, int offset, int length) {
-    update(data, offset, length, data, offset);
-  }
-
-  public void update(byte[] in, int inOffset, int length, byte[] out, int outOffset) {
-    // If we previously flushed the cipher by inputting zeros up to a block boundary, then we need
-    // to manually transform the data that actually ended the block. See the comment below for more
-    // details.
-    while (pendingXorBytes > 0) {
-      out[outOffset] = (byte) (in[inOffset] ^ flushedBlock[blockSize - pendingXorBytes]);
-      outOffset++;
-      inOffset++;
-      pendingXorBytes--;
-      length--;
-      if (length == 0) {
-        return;
-      }
-    }
-
-    // Do the bulk of the update.
-    int written = nonFlushingUpdate(in, inOffset, length, out, outOffset);
-    if (length == written) {
-      return;
-    }
-
-    // We need to finish the block to flush out the remaining bytes. We do so by inputting zeros,
-    // so that the corresponding bytes output by the cipher are those that would have been XORed
-    // against the real end-of-block data to transform it. We store these bytes so that we can
-    // perform the transformation manually in the case of a subsequent call to this method with
-    // the real data.
-    int bytesToFlush = length - written;
-    Assertions.checkState(bytesToFlush < blockSize);
-    outOffset += written;
-    pendingXorBytes = blockSize - bytesToFlush;
-    written = nonFlushingUpdate(zerosBlock, 0, pendingXorBytes, flushedBlock, 0);
-    Assertions.checkState(written == blockSize);
-    // The first part of xorBytes contains the flushed data, which we copy out. The remainder
-    // contains the bytes that will be needed for manual transformation in a subsequent call.
-    for (int i = 0; i < bytesToFlush; i++) {
-      out[outOffset++] = flushedBlock[i];
-    }
-  }
-
-  private int nonFlushingUpdate(byte[] in, int inOffset, int length, byte[] out, int outOffset) {
-    try {
-      return cipher.update(in, inOffset, length, out, outOffset);
-    } catch (ShortBufferException e) {
-      // Should never happen.
-      throw new RuntimeException(e);
-    }
-  }
-
-  private byte[] getInitializationVector(long nonce, long counter) {
-    return ByteBuffer.allocate(16).putLong(nonce).putLong(counter).array();
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java
deleted file mode 100644
index ff8841fa9c..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/crypto/CryptoUtil.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.crypto;
-
-/**
- * Utility functions for the crypto package.
- */
-/* package */ final class CryptoUtil {
-
-  private CryptoUtil() {}
-
-  /**
-   * Returns the hash value of the input as a long using the 64 bit FNV-1a hash function. The hash
-   * values produced by this function are less likely to collide than those produced by
-   * {@link #hashCode()}.
-   */
-  public static long getFNV64Hash(String input) {
-    if (input == null) {
-      return 0;
-    }
-
-    long hash = 0;
-    for (int i = 0; i < input.length(); i++) {
-      hash ^= input.charAt(i);
-      // This is equivalent to hash *= 0x100000001b3 (the FNV magic prime number).
-      hash += (hash << 1) + (hash << 4) + (hash << 5) + (hash << 7) + (hash << 8) + (hash << 40);
-    }
-    return hash;
-  }
-
-}
