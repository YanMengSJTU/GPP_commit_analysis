diff --git a/demo/build.gradle b/demo/build.gradle
index e0874e3147..9cf1f8bb4d 100644
--- a/demo/build.gradle
+++ b/demo/build.gradle
@@ -19,7 +19,7 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 16
+        minSdkVersion 21
         targetSdkVersion project.ext.targetSdkVersion
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index a88a1dd615..28eca8208e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -19,6 +19,8 @@
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
+import com.google.android.exoplayer2.util.TraceUtil;
+
 import java.io.IOException;
 
 /**
@@ -274,10 +276,12 @@ protected final int getIndex() {
    */
   protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buffer,
       boolean formatRequired) {
+      TraceUtil.beginSection("BaseRenderer.readSource");
     int result = stream.readData(formatHolder, buffer, formatRequired);
     if (result == C.RESULT_BUFFER_READ) {
       if (buffer.isEndOfStream()) {
         readEndOfStream = true;
+          TraceUtil.endSection();
         return streamIsFinal ? C.RESULT_BUFFER_READ : C.RESULT_NOTHING_READ;
       }
       buffer.timeUs += streamOffsetUs;
@@ -288,6 +292,7 @@ protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buf
         formatHolder.format = format;
       }
     }
+    TraceUtil.endSection();
     return result;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
index 99c1e34614..322836debf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/DecoderInputBuffer.java
@@ -17,6 +17,8 @@
 
 import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.TraceUtil;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.nio.ByteBuffer;
@@ -111,11 +113,13 @@ public void ensureSpaceForWrite(int length) throws IllegalStateException {
       data = createReplacementByteBuffer(length);
       return;
     }
+    TraceUtil.beginSection("DecoderInputBuffer.ensureSpaceForWrite");
     // Check whether the current buffer is sufficient.
     int capacity = data.capacity();
     int position = data.position();
     int requiredCapacity = position + length;
     if (capacity >= requiredCapacity) {
+      TraceUtil.endSection();
       return;
     }
     // Instantiate a new buffer if possible.
@@ -128,6 +132,7 @@ public void ensureSpaceForWrite(int length) throws IllegalStateException {
     }
     // Set the new buffer.
     data = newData;
+    TraceUtil.endSection();
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
index e7903bc783..9ffa6885fc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
@@ -27,7 +27,7 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-import com.google.android.exoplayer2.util.TraceUtil;
+//import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
 import java.io.EOFException;
 import java.io.IOException;
@@ -298,11 +298,13 @@ public boolean skipToKeyframeBefore(long timeUs, boolean allowTimeBeyondBuffer)
    */
   public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean formatRequired,
       boolean loadingFinished, long decodeOnlyUntilUs) {
+    // TraceUtil.beginSection("DefaultTrackOutput.readData()");
     int result = infoQueue.readData(formatHolder, buffer, formatRequired, loadingFinished,
         downstreamFormat, extrasHolder);
     switch (result) {
       case C.RESULT_FORMAT_READ:
         downstreamFormat = formatHolder.format;
+        // TraceUtil.endSection();
         return C.RESULT_FORMAT_READ;
       case C.RESULT_BUFFER_READ:
         if (!buffer.isEndOfStream()) {
@@ -319,10 +321,13 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolea
           // Advance the read head.
           dropDownstreamTo(extrasHolder.nextOffset);
         }
+        // TraceUtil.endSection();
         return C.RESULT_BUFFER_READ;
       case C.RESULT_NOTHING_READ:
+        // TraceUtil.endSection();
         return C.RESULT_NOTHING_READ;
       default:
+        // TraceUtil.endSection();
         throw new IllegalStateException();
     }
   }
@@ -408,29 +413,30 @@ private void readEncryptionData(DecoderInputBuffer buffer, BufferExtrasHolder ex
    * @param length The number of bytes to read.
    */
   private void readData(long absolutePosition, ByteBuffer target, int length, int format) {
+    // TraceUtil.beginSection("DefaultTrackOutput.readData()(Private)");
     int remaining = length;
-    String logMessage = "";
-    String type;
-    switch(format) {
-      case C.TRACK_TYPE_AUDIO:
-        type = "audio";
-        break;
-      case C.TRACK_TYPE_VIDEO:
-        type = "video";
-        break;
-      case C.TRACK_TYPE_METADATA:
-        type = "metadata";
-        break;
-      case C.TRACK_TYPE_DEFAULT:
-        type = "default";
-        break;
-      case C.TRACK_TYPE_TEXT:
-        type = "text";
-        break;
-      default:
-        type = "unknown";
-        break;
-    }
+//    String logMessage = "";
+//    String type;
+//    switch(format) {
+//      case C.TRACK_TYPE_AUDIO:
+//        type = "audio";
+//        break;
+//      case C.TRACK_TYPE_VIDEO:
+//        type = "video";
+//        break;
+//      case C.TRACK_TYPE_METADATA:
+//        type = "metadata";
+//        break;
+//      case C.TRACK_TYPE_DEFAULT:
+//        type = "default";
+//        break;
+//      case C.TRACK_TYPE_TEXT:
+//        type = "text";
+//        break;
+//      default:
+//        type = "unknown";
+//        break;
+//    }
 
     while (remaining > 0) {
       dropDownstreamTo(absolutePosition);
@@ -445,6 +451,7 @@ private void readData(long absolutePosition, ByteBuffer target, int length, int
     }
 //    logMessage = "readData(allocation -> DecodeInputBuffer.ByteBuffer)[FIN, format=" + type + ", absPos=" + absolutePosition +", len=" + length + ", rem=" + remaining + "]";
 //    Log.d(TAG, logMessage);
+    // TraceUtil.endSection();
   }
 
   /**
@@ -455,6 +462,7 @@ private void readData(long absolutePosition, ByteBuffer target, int length, int
    * @param length The number of bytes to read.
    */
   private void readData(long absolutePosition, byte[] target, int length) {
+    // TraceUtil.beginSection("DefaultTrackOutput.readData[](Private)");
     int bytesRead = 0;
     while (bytesRead < length) {
       dropDownstreamTo(absolutePosition);
@@ -466,6 +474,7 @@ private void readData(long absolutePosition, byte[] target, int length) {
       absolutePosition += toCopy;
       bytesRead += toCopy;
     }
+    // TraceUtil.endSection();
   }
 
   /**
@@ -475,9 +484,8 @@ private void readData(long absolutePosition, byte[] target, int length) {
    * @param absolutePosition The absolute position up to which allocations can be discarded.
    */
   private void dropDownstreamTo(long absolutePosition) {
-    String logMessage = "DefaultTrackOutput.dropDownstreamTo(" + absolutePosition + ")";
-//    Log.d(TAG, logMessage);
-    TraceUtil.beginSection(logMessage);
+//    String logMessage = "DefaultTrackOutput.dropDownstreamTo(" + absolutePosition + ")";
+    // TraceUtil.beginSection(logMessage);
     int relativePosition = (int) (absolutePosition - totalBytesDropped);
     int allocationIndex = relativePosition / allocationLength;
     for (int i = 0; i < allocationIndex; i++) {
@@ -486,7 +494,7 @@ private void dropDownstreamTo(long absolutePosition) {
       allocator.release(remove);
       totalBytesDropped += allocationLength;
     }
-    TraceUtil.endSection();
+    // TraceUtil.endSection();
   }
 
   // Called by the loading thread.
@@ -541,11 +549,11 @@ public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
       length = prepareForAppend(length);
 //      String logMessage = "sampleData<ExtractorInput>(Fetch data from upstream to #" + lastAllocation.id + ")";
 //      Log.d(TAG, logMessage);
-//      TraceUtil.beginSection(logMessage);
+//      // TraceUtil.beginSection(logMessage);
       int bytesAppended = input.read(lastAllocation.data,
           lastAllocation.translateOffset(lastAllocationOffset), length);
-//      TraceUtil.endSection();
-//      String logMessage = "sampleData<ExtractorInput>(New data ID for allocation #" + lastAllocation.id + "): " + String.valueOf(Arrays.hashCode(lastAllocation.data));
+//      // TraceUtil.endSection();
+//      logMessage = "sampleData<ExtractorInput>(New data ID for allocation #" + lastAllocation.id + ", data saved.)";
 //      Log.d(TAG, logMessage);
       if (bytesAppended == C.RESULT_END_OF_INPUT) {
         if (allowEndOfInput) {
@@ -569,17 +577,18 @@ public void sampleData(ParsableByteArray buffer, int length) {
     }
     String logMessage = "sampleData<ParsableByteArray>(upstream -> allocation)[len=" + length + "]";
 //    Log.d(TAG, logMessage);
-    TraceUtil.beginSection(logMessage);
+    // TraceUtil.beginSection(logMessage);
+    int thisAppendLength = 0;
     while (length > 0) {
-      int thisAppendLength = prepareForAppend(length);
+      thisAppendLength = prepareForAppend(length);
       buffer.readBytes(lastAllocation.data, lastAllocation.translateOffset(lastAllocationOffset),
           thisAppendLength);
       lastAllocationOffset += thisAppendLength;
       totalBytesWritten += thisAppendLength;
       length -= thisAppendLength;
     }
-    TraceUtil.endSection();
-    logMessage = "sampleData<ParsableByteArray>(upstream -> allocation)[FIN, lastId=#" + lastAllocation.id + "]";
+    // TraceUtil.endSection();
+//    logMessage = "sampleData<ParsableByteArray>(upstream -> allocation)[FIN, lastId=#" + lastAllocation.id + ", appendLen=" + thisAppendLength + "]";
 //    Log.d(TAG, logMessage);
     endWriteOperation();
   }
@@ -641,10 +650,8 @@ private int prepareForAppend(int length) {
       lastAllocationOffset = 0;
       lastAllocation = allocator.allocate();
       String logMessage = "prepareForAppend(dataQueue enque for #" + lastAllocation.id + "): " + String.valueOf(Arrays.hashCode(lastAllocation.data));
-//      Log.d(TAG, logMessage);
-//      TraceUtil.beginSection(logMessage);
+      Log.d(TAG, logMessage);
       dataQueue.add(lastAllocation);
-//      TraceUtil.endSection();
     }
     return Math.min(length, allocationLength - lastAllocationOffset);
   }
@@ -859,25 +866,31 @@ public synchronized long getLargestQueuedTimestampUs() {
     public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
         boolean formatRequired, boolean loadingFinished, Format downstreamFormat,
         BufferExtrasHolder extrasHolder) {
+      // TraceUtil.beginSection("InfoQueue.readData");
       if (queueSize == 0) {
         if (loadingFinished) {
           buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+          // TraceUtil.endSection();
           return C.RESULT_BUFFER_READ;
         } else if (upstreamFormat != null
             && (formatRequired || upstreamFormat != downstreamFormat)) {
           formatHolder.format = upstreamFormat;
+          // TraceUtil.endSection();
           return C.RESULT_FORMAT_READ;
         } else {
+          // TraceUtil.endSection();
           return C.RESULT_NOTHING_READ;
         }
       }
 
       if (formatRequired || formats[relativeReadIndex] != downstreamFormat) {
         formatHolder.format = formats[relativeReadIndex];
+        // TraceUtil.endSection();
         return C.RESULT_FORMAT_READ;
       }
 
       if (buffer.isFlagsOnly()) {
+        // TraceUtil.endSection();
         return C.RESULT_NOTHING_READ;
       }
 
@@ -899,6 +912,7 @@ public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer b
 
       extrasHolder.nextOffset = queueSize > 0 ? offsets[relativeReadIndex]
           : extrasHolder.offset + extrasHolder.size;
+      // TraceUtil.endSection();
       return C.RESULT_BUFFER_READ;
     }
 
@@ -1005,7 +1019,7 @@ public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlag
       // Increment the write index.
       queueSize++;
       frameCount  = frameCount + 1;
-      Log.d(TAG, "commitSample[format=" + upstreamFormat.sampleMimeType + ", timeUs="+timeUs+", relativeWriteIndex="+relativeWriteIndex+ ", sampleFlags="+sampleFlags+", offset="+offset+", size="+size+", queueSize="+ queueSize + ", frameCount=" + frameCount + "]");
+      Log.d(TAG, "commitSample[format=" + upstreamFormat.sampleMimeType + ", timeUs="+timeUs+", relWrIndex="+relativeWriteIndex+ ", offset="+offset+", size="+size+", queueSize="+ queueSize + ", frameCount=" + frameCount + ", sampleFlags="+sampleFlags+"]");
       if (queueSize == capacity) {
         // Increase the capacity.
         int newCapacity = capacity + SAMPLE_CAPACITY_INCREMENT;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index c25e8bea86..1eb5bc3963 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -42,7 +42,7 @@
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.NalUnitUtil;
-import com.google.android.exoplayer2.util.TraceUtil;
+//import com.google.android.exoplayer2.util.TraceUtil;
 import com.google.android.exoplayer2.util.Util;
 
 import java.lang.annotation.Retention;
@@ -66,6 +66,7 @@
     private static final int NO_SUITABLE_DECODER_ERROR = CUSTOM_ERROR_CODE_BASE + 1;
     private static final int DECODER_QUERY_ERROR = CUSTOM_ERROR_CODE_BASE + 2;
 
+
     /**
      * The mime type for which a decoder was being initialized.
      */
@@ -120,6 +121,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   }
 
   private static final String TAG = "MediaCodecRenderer";
+  private static final long RENDERER_TIMESTAMP_OFFSET_US = 60000000;
 
   private long loopCount;
 
@@ -388,7 +390,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
     codecNeedsMonoChannelCountWorkaround = codecNeedsMonoChannelCountWorkaround(codecName, format);
     try {
       long codecInitializingTimestamp = SystemClock.elapsedRealtime();
-      TraceUtil.beginSection("MediaCodecRenderer.createCodec:" + codecName);
+      // TraceUtil.beginSection("MediaCodecRenderer.createCodec:" + codecName);
       codec = MediaCodec.createByCodecName(codecName);
       TraceUtil.endSection();
       TraceUtil.beginSection("configureCodec");
@@ -396,7 +398,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       TraceUtil.endSection();
       TraceUtil.beginSection("MediaCodecRenderer.startCodec");
       codec.start();
-      TraceUtil.endSection();
+      // TraceUtil.endSection();
       long codecInitializedTimestamp = SystemClock.elapsedRealtime();
       onCodecInitialized(codecName, codecInitializedTimestamp,
           codecInitializedTimestamp - codecInitializingTimestamp);
@@ -549,10 +551,10 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     // We have a format.
     maybeInitCodec();
     if (codec != null) {
-      TraceUtil.beginSection("drainAndFeed - loop " + loopCount + ", rendered:" + decoderCounters.renderedOutputBufferCount + ", skip:"+ decoderCounters.skippedOutputBufferCount + ", drop:" + decoderCounters.droppedOutputBufferCount);
+      // TraceUtil.beginSection("drainAndFeed - loop " + loopCount + ", rendered:" + decoderCounters.renderedOutputBufferCount + ", skip:"+ decoderCounters.skippedOutputBufferCount + ", drop:" + decoderCounters.droppedOutputBufferCount);
       while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
       while (feedInputBuffer()) {}
-      TraceUtil.endSection();
+      // TraceUtil.endSection();
       loopCount++;
     } else {
       skipSource(positionUs);
@@ -608,20 +610,46 @@ protected void flushCodec() throws ExoPlaybackException {
    * @throws ExoPlaybackException If an error occurs feeding the input buffer.
    */
   private boolean feedInputBuffer() throws ExoPlaybackException {
-    String logMessage = "readSource from allocation to decodeInputBuffer.";
+    // Detect buffer type (For source trace only)
+    String type;
+    switch(buffer.format) {
+      case C.TRACK_TYPE_AUDIO:
+        type = "audio";
+        break;
+      case C.TRACK_TYPE_VIDEO:
+        type = "video";
+        break;
+      case C.TRACK_TYPE_METADATA:
+        type = "metadata";
+        break;
+      case C.TRACK_TYPE_DEFAULT:
+        type = "default";
+        break;
+      case C.TRACK_TYPE_TEXT:
+        type = "text";
+        break;
+      default:
+        type = "unknown";
+        break;
+    }
+    String logMessage = "feedInputBuffer for " + type;
 //    Log.d(TAG, logMessage);
-    TraceUtil.beginSection(logMessage);
+    // TraceUtil.beginSection(logMessage);
     if (codec == null || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM
         || inputStreamEnded) {
       // We need to reinitialize the codec or the input stream has ended.
-      TraceUtil.endSection();
+//      logMessage = "feedInputBuffer for " + type + ": (FALSE) reinitialize the codec or the input stream has ended.";
+//      Log.d(TAG, logMessage);
+      // TraceUtil.endSection();
       return false;
     }
 
     if (inputIndex < 0) {
       inputIndex = codec.dequeueInputBuffer(0);
       if (inputIndex < 0) {
-        TraceUtil.endSection();
+//        logMessage = "feedInputBuffer for " + type + ": (FALSE) inputIndex failed.";
+//        Log.d(TAG, logMessage);
+        // TraceUtil.endSection();
         return false;
       }
       buffer.data = inputBuffers[inputIndex];
@@ -639,7 +667,9 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         inputIndex = C.INDEX_UNSET;
       }
       codecReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
-      TraceUtil.endSection();
+//      logMessage = "feedInputBuffer for " + type + ": (FALSE) reinit state wait EOF.";
+//      Log.d(TAG, logMessage);
+      // TraceUtil.endSection();
       return false;
     }
 
@@ -649,7 +679,9 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       codec.queueInputBuffer(inputIndex, 0, ADAPTATION_WORKAROUND_BUFFER.length, 0, 0);
       inputIndex = C.INDEX_UNSET;
       codecReceivedBuffers = true;
-      TraceUtil.endSection();
+//      logMessage = "feedInputBuffer for " + type + ": (TRUE) codec adaptation workaround apply.";
+//      Log.d(TAG, logMessage);
+      // TraceUtil.endSection();
       return true;
     }
 
@@ -669,11 +701,17 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         codecReconfigurationState = RECONFIGURATION_STATE_QUEUE_PENDING;
       }
       adaptiveReconfigurationBytes = buffer.data.position();
+//      logMessage = "Begin read data from allocation to decode input buffer.";
+//      Log.d(TAG, logMessage);
       result = readSource(formatHolder, buffer, false);
+//      logMessage = "Finished read data from allocation to decode input buffer.";
+//      Log.d(TAG, logMessage);
     }
 
     if (result == C.RESULT_NOTHING_READ) {
-      TraceUtil.endSection();
+//      logMessage = "feedInputBuffer for " + type + ": (FALSE) Nothing READ.";
+//      Log.d(TAG, logMessage);
+      // TraceUtil.endSection();
       return false;
     }
     if (result == C.RESULT_FORMAT_READ) {
@@ -684,10 +722,13 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
       }
       onInputFormatChanged(formatHolder.format);
-      TraceUtil.endSection();
+//      logMessage = "feedInputBuffer for " + type + ": (TRUE) Format READ, input format changed.";
+//      Log.d(TAG, logMessage);
+      // TraceUtil.endSection();
       return true;
     }
-
+    Log.d(TAG, type + " ByteBuffer bufferIndex @" + inputIndex + " trying queue.");
+    int previousIndex = inputIndex;
     // We've read a buffer.
     if (buffer.isEndOfStream()) {
       if (codecReconfigurationState == RECONFIGURATION_STATE_QUEUE_PENDING) {
@@ -700,7 +741,9 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       inputStreamEnded = true;
       if (!codecReceivedBuffers) {
         processEndOfStream();
-        TraceUtil.endSection();
+//        logMessage = "feedInputBuffer for " + type + ": (FALSE) codec no buffer received.";
+//        Log.d(TAG, logMessage);
+        // TraceUtil.endSection();
         return false;
       }
       try {
@@ -712,10 +755,13 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
           inputIndex = C.INDEX_UNSET;
         }
       } catch (CryptoException e) {
-        TraceUtil.endSection();
+//        logMessage = "feedInputBuffer for " + type + ": (FALSE) Crypto exception.";
+//        Log.d(TAG, logMessage);
+        // TraceUtil.endSection();
         throw ExoPlaybackException.createForRenderer(e, getIndex());
       }
-      TraceUtil.endSection();
+      // TraceUtil.endSection();
+      Log.d(TAG, type + " ByteBuffer bufferIndex @" + previousIndex + " queued.[EOF, timeUs=" + (buffer.timeUs - RENDERER_TIMESTAMP_OFFSET_US) +"]");
       return false;
     }
     if (waitingForFirstSyncFrame && !buffer.isKeyFrame()) {
@@ -725,20 +771,26 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         // data into a subsequent buffer (if there is one).
         codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
       }
-      TraceUtil.endSection();
+//      logMessage = "feedInputBuffer for " + type + ": (TRUE) Wait for first Keyframe.";
+//      Log.d(TAG, logMessage);
+      // TraceUtil.endSection();
       return true;
     }
     waitingForFirstSyncFrame = false;
     boolean bufferEncrypted = buffer.isEncrypted();
     waitingForKeys = shouldWaitForKeys(bufferEncrypted);
     if (waitingForKeys) {
-      TraceUtil.endSection();
+//      logMessage = "feedInputBuffer for " + type + ": (FALSE) Wait for Keyframe.";
+//      Log.d(TAG, logMessage);
+      // TraceUtil.endSection();
       return false;
     }
     if (codecNeedsDiscardToSpsWorkaround && !bufferEncrypted) {
       NalUnitUtil.discardToSps(buffer.data);
       if (buffer.data.position() == 0) {
-        TraceUtil.endSection();
+//        logMessage = "feedInputBuffer for " + type + ": (TRUE) discardToSps.";
+//        Log.d(TAG, logMessage);
+        // TraceUtil.endSection();
         return true;
       }
       codecNeedsDiscardToSpsWorkaround = false;
@@ -748,31 +800,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       if (buffer.isDecodeOnly()) {
         decodeOnlyPresentationTimestamps.add(presentationTimeUs);
       }
-//      Log.d(TAG, "Queue input bufferIndex @" + inputIndex + " with ByteBuffer: " + buffer.data.hashCode());
       buffer.flip();
-//      Log.d(TAG, "New ByteBuffer bufferIndex @" + inputIndex + " hash: " + buffer.data.hashCode());
-      String type;
-      switch(buffer.format) {
-        case C.TRACK_TYPE_AUDIO:
-          type = "audio";
-          break;
-        case C.TRACK_TYPE_VIDEO:
-          type = "video";
-          break;
-        case C.TRACK_TYPE_METADATA:
-          type = "metadata";
-          break;
-        case C.TRACK_TYPE_DEFAULT:
-          type = "default";
-                  break;
-        case C.TRACK_TYPE_TEXT:
-          type = "text";
-          break;
-        default:
-          type = "unknown";
-          break;
-      }
-      Log.d(TAG, type + " ByteBuffer bufferIndex @" + inputIndex + " queued.[timeUs=" + buffer.timeUs +"]");
       onQueueInputBuffer(buffer);
 
       if (bufferEncrypted) {
@@ -781,16 +809,20 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         codec.queueSecureInputBuffer(inputIndex, 0, cryptoInfo, presentationTimeUs, 0);
       } else {
         codec.queueInputBuffer(inputIndex, 0, buffer.data.limit(), presentationTimeUs, 0);
+
       }
       inputIndex = C.INDEX_UNSET;
       codecReceivedBuffers = true;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
       decoderCounters.inputBufferCount++;
     } catch (CryptoException e) {
-      TraceUtil.endSection();
+//      logMessage = "feedInputBuffer for " + type + ": (FALSE) Crypto exception.";
+//      Log.d(TAG, logMessage);
+      // TraceUtil.endSection();
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
-    TraceUtil.endSection();
+    Log.d(TAG, type + " ByteBuffer bufferIndex @" + previousIndex + " queued.[timeUs=" + (buffer.timeUs - RENDERER_TIMESTAMP_OFFSET_US) +"]");
+    // TraceUtil.endSection();
     return true;
   }
 
@@ -968,6 +1000,8 @@ protected long getDequeueOutputBufferTimeoutUs() {
   @SuppressWarnings("deprecation")
   private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException {
+    String logMessage = "Deque outputBuffer for " + codec.getInputFormat().getString("mime") + ".";
+    Log.d(TAG, logMessage);
     if (outputIndex < 0) {
       if (codecNeedsEosOutputExceptionWorkaround && codecReceivedEos) {
         try {
@@ -986,6 +1020,8 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
             getDequeueOutputBufferTimeoutUs());
       }
       if (outputIndex >= 0) {
+        logMessage = "Release outputBuffer for " + codec.getInputFormat().getString("mime") + ".";
+        Log.d(TAG, logMessage);
         // We've dequeued a buffer.
         if (shouldSkipAdaptationWorkaroundOutputBuffer) {
           shouldSkipAdaptationWorkaroundOutputBuffer = false;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 36842b2450..b2e54901c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -514,6 +514,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     if (!renderedFirstFrame) {
       if (Util.SDK_INT >= 21) {
         renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, System.nanoTime());
+        // renderOutputBufferV21(codec, bufferIndex, System.nanoTime(), bufferPresentationTimeUs);
       } else {
         renderOutputBuffer(codec, bufferIndex, presentationTimeUs);
       }
@@ -547,6 +548,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       // Let the underlying framework time the release.
       if (earlyUs < 50000) {
         renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, adjustedReleaseTimeNs);
+        // renderOutputBufferV21(codec, bufferIndex, adjustedReleaseTimeNs, bufferPresentationTimeUs);
         return true;
       }
     } else {
@@ -616,6 +618,7 @@ protected void dropOutputBuffer(MediaCodec codec, int index, long presentationTi
     if (droppedFrames == maxDroppedFramesToNotify) {
       maybeNotifyDroppedFrames();
     }
+    Log.d(TAG, "Video output buffer @" + bufferIndex + " dropped.");
   }
 
   /**
@@ -631,6 +634,7 @@ protected void renderOutputBuffer(MediaCodec codec, int index, long presentation
     TraceUtil.beginSection("releaseOutputBuffer");
     codec.releaseOutputBuffer(index, true);
     TraceUtil.endSection();
+    Log.d(TAG, "Video output buffer @" + index + " rendered.");
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
     maybeNotifyRenderedFirstFrame();
@@ -649,11 +653,13 @@ protected void renderOutputBuffer(MediaCodec codec, int index, long presentation
   protected void renderOutputBufferV21(MediaCodec codec, int index, long presentationTimeUs,
       long releaseTimeNs) {
     maybeNotifyVideoSizeChanged();
-    String logMessage = "Release video output buffer with bufferIndex @" + bufferIndex + "[rendered=" + (decoderCounters.renderedOutputBufferCount + 1) + "]";
+    String logMessage = "Video output buffer @" + bufferIndex + " start renderer[bufPresentationTimeus=" + (bufferPresentationTimeUs - 60000000) + "]";
     Log.d(TAG, logMessage);
     TraceUtil.beginSection("releaseOutputBuffer");
     codec.releaseOutputBuffer(index, releaseTimeNs);
     TraceUtil.endSection();
+    logMessage = "Released video output buffer with rendered bufferIndex @" + index + "[bufPresentationTimeus=" + (presentationTimeUs - 60000000) + ", rendered=" + (decoderCounters.renderedOutputBufferCount + 1) + "]";
+    Log.d(TAG, logMessage);
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
     maybeNotifyRenderedFirstFrame();
