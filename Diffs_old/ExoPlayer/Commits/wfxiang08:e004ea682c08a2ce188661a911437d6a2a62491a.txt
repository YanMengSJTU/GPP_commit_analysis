diff --git a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index f5244a72b4..307cf12cb0 100644
--- a/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demo/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -69,6 +69,7 @@
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.CookiePolicy;
+import java.net.URL;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.UUID;
@@ -299,8 +300,10 @@ private void initializePlayer() {
       player.setVideoDebugListener(eventLogger);
       player.setId3Output(eventLogger);
 
+      // Player 和 View的结合
       simpleExoPlayerView.setPlayer(player);
 
+      // 如何执行seek操作呢?
       if (isTimelineStatic) {
         if (playerPosition == C.TIME_UNSET) {
           player.seekToDefaultPosition(playerWindow);
@@ -311,6 +314,7 @@ private void initializePlayer() {
 
       // 自动播放
       player.setPlayWhenReady(shouldAutoPlay);
+
       debugViewHelper = new DebugTextViewHelper(player, debugTextView);
       debugViewHelper.start();
       playerNeedsSource = true;
@@ -374,6 +378,7 @@ private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
             new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, eventLogger);
       case C.TYPE_HLS:
         // 如何使用Hls格式的文件呢?
+        uri = Uri.parse("https://d2odow79s717pv.cloudfront.net/test/transcoding/recordings/6755399282198623/hls-low/playlist.m3u8");
         return new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, eventLogger);
       case C.TYPE_OTHER:
         return new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(),
diff --git a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index ee8c6f4343..e7675af5d5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -121,6 +121,7 @@ public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBu
     bufferForPlaybackAfterRebufferUs = bufferForPlaybackAfterRebufferMs * 1000L;
   }
 
+  // 重置内部各种状态
   @Override
   public void onPrepared() {
     reset(false);
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 19686f7551..070b0b9fa0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -200,17 +200,28 @@ public void seekTo(long positionMs) {
 
   @Override
   public void seekTo(int windowIndex, long positionMs) {
+    // 这个如何实施呢?
+    // windowIndex必须有效；并且windowIndex在timeline的合适的位置
     if (windowIndex < 0 || (!timeline.isEmpty() && windowIndex >= timeline.getWindowCount())) {
       throw new IllegalSeekPositionException(timeline, windowIndex, positionMs);
     }
+
     pendingSeekAcks++;
     maskingWindowIndex = windowIndex;
+
+    // 位置不定?
     if (positionMs == C.TIME_UNSET) {
       maskingWindowPositionMs = 0;
       internalPlayer.seekTo(timeline, windowIndex, C.TIME_UNSET);
     } else {
+      // 假定现在: duration知道, timeline也有，那么具体如何实现?
+      // 1. 往后拖
+      // 2. 往前拖
+      //    会触发什么动作？ 对应什么网络请求呢？
       maskingWindowPositionMs = positionMs;
       internalPlayer.seekTo(timeline, windowIndex, C.msToUs(positionMs));
+
+      // 所有的listeners需要处理Position的变化，例如: OKHttp的Cache(因为网络请求的文件是只能读取一次，因此不可能往回rewind)
       for (EventListener listener : listeners) {
         listener.onPositionDiscontinuity();
       }
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 595a666024..8e926a8d91 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -229,10 +229,9 @@ public void setPlayWhenReady(boolean playWhenReady) {
 
   // seekTo操作如何执行呢?
   //  可以seek到之前的某个位置，也可以seek到之后的某个位置；可能导致缓存失效
-  //
+  // 对于当前的需求: Timeline 是唯一的
   public void seekTo(Timeline timeline, int windowIndex, long positionUs) {
-    handler.obtainMessage(MSG_SEEK_TO, new SeekPosition(timeline, windowIndex, positionUs))
-            .sendToTarget();
+    handler.obtainMessage(MSG_SEEK_TO, new SeekPosition(timeline, windowIndex, positionUs)).sendToTarget();
   }
 
   public void stop() {
@@ -566,6 +565,7 @@ private void scheduleNextWork(long thisOperationStartTimeMs, long intervalMs) {
     }
   }
 
+  // 播放器具体执行SeekTo的操作
   private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackException {
     if (timeline == null) {
       pendingInitialSeekCount++;
@@ -573,6 +573,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
       return;
     }
 
+    // 首先定位到具体的<PeriodIndex, PeriodPositionUs>
     Pair<Integer, Long> periodPosition = resolveSeekPosition(seekPosition);
 
     if (periodPosition == null) {
@@ -589,15 +590,18 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
       return;
     }
 
+    // 获取到定位信息
     int periodIndex = periodPosition.first;
     long periodPositionUs = periodPosition.second;
 
     try {
+      // 如果定位信息没有变化，则直接跳过
       if (periodIndex == playbackInfo.periodIndex
               && ((periodPositionUs / 1000) == (playbackInfo.positionUs / 1000))) {
         // Seek position equals the current position. Do nothing.
         return;
       }
+      // 具体如何实施呢?
       periodPositionUs = seekToPeriodPosition(periodIndex, periodPositionUs);
     } finally {
       playbackInfo = new PlaybackInfo(periodIndex, periodPositionUs);
@@ -605,9 +609,11 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
     }
   }
 
-  private long seekToPeriodPosition(int periodIndex, long periodPositionUs)
-          throws ExoPlaybackException {
+  private long seekToPeriodPosition(int periodIndex, long periodPositionUs) throws ExoPlaybackException {
+    // 1. 需要暂停Renders
     stopRenderers();
+
+    // 2. 切换状态: Buffering
     rebuffering = false;
     setState(ExoPlayer.STATE_BUFFERING);
 
@@ -873,12 +879,18 @@ private void maybeThrowPeriodPrepareError() throws IOException {
 
   private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifest)
           throws ExoPlaybackException {
+
+    // TODO: Source的信息改变了
+    // 例如: m3u8文件改变了等
     Timeline oldTimeline = timeline;
     timeline = timelineAndManifest.first;
     Object manifest = timelineAndManifest.second;
 
     int processedInitialSeekCount = 0;
+
+    // 假设不存在oldTimeline
     if (oldTimeline == null) {
+      // 构建: playbackInfo
       if (pendingInitialSeekCount > 0) {
         Pair<Integer, Long> periodPosition = resolveSeekPosition(pendingSeekPosition);
         processedInitialSeekCount = pendingInitialSeekCount;
@@ -901,8 +913,7 @@ private void handleSourceInfoRefreshed(Pair<Timeline, Object> timelineAndManifes
       }
     }
 
-    MediaPeriodHolder periodHolder = playingPeriodHolder != null ? playingPeriodHolder
-            : loadingPeriodHolder;
+    MediaPeriodHolder periodHolder = playingPeriodHolder != null ? playingPeriodHolder : loadingPeriodHolder;
     if (periodHolder == null) {
       // We don't have any period holders, so we're done.
       notifySourceInfoRefresh(manifest, processedInitialSeekCount);
@@ -1039,20 +1050,28 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
       // knowledge of what the future timeline will be). Use the internal timeline.
       seekTimeline = timeline;
     }
+
     // Map the SeekPosition to a position in the corresponding timeline.
+    // 对于 SinglePeriodTimeline， windowIndex == 0
+    // 唯一存在变化的是: seekPosition.windowPositionUs
+    // 定位当前的Period, 以及periodPositionUs
     Pair<Integer, Long> periodPosition;
     try {
-      periodPosition = getPeriodPosition(seekTimeline, seekPosition.windowIndex,
-              seekPosition.windowPositionUs);
+      periodPosition = getPeriodPosition(seekTimeline, seekPosition.windowIndex, seekPosition.windowPositionUs);
     } catch (IndexOutOfBoundsException e) {
       // The window index of the seek position was outside the bounds of the timeline.
-      throw new IllegalSeekPositionException(timeline, seekPosition.windowIndex,
-              seekPosition.windowPositionUs);
+      throw new IllegalSeekPositionException(timeline, seekPosition.windowIndex,  seekPosition.windowPositionUs);
     }
+
+    //
+    // 如果timeline没有改变，那么会发生什么问题呢?
+    //
     if (timeline == seekTimeline) {
       // Our internal timeline is the seek timeline, so the mapped position is correct.
       return periodPosition;
     }
+
+
     // Attempt to find the mapped period in the internal timeline.
     int periodIndex = timeline.getIndexOfPeriod(
             seekTimeline.getPeriod(periodPosition.first, period, true).uid);
@@ -1081,8 +1100,7 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
    * Calls {@link #getPeriodPosition(Timeline, int, long, long)} with a zero default position
    * projection.
    */
-  private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex,
-                                                long windowPositionUs) {
+  private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex, long windowPositionUs) {
     return getPeriodPosition(timeline, windowIndex, windowPositionUs, 0);
   }
 
@@ -1099,19 +1117,26 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
    * is {@link C#TIME_UNSET}, {@code defaultPositionProjectionUs} is non-zero, and the window's
    * position could not be projected by {@code defaultPositionProjectionUs}.
    */
-  private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex,
-                                                long windowPositionUs, long defaultPositionProjectionUs) {
+  private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex, long windowPositionUs, long defaultPositionProjectionUs) {
     Assertions.checkIndex(windowIndex, 0, timeline.getWindowCount());
+
+    // 通过timeline设置当前的播放window
     timeline.getWindow(windowIndex, window, false, defaultPositionProjectionUs);
+
+    // 如果时间未定，则使用window的默认时间
+    // window: [start, ....]
     if (windowPositionUs == C.TIME_UNSET) {
       windowPositionUs = window.getDefaultPositionUs();
       if (windowPositionUs == C.TIME_UNSET) {
         return null;
       }
     }
+
     int periodIndex = window.firstPeriodIndex;
     long periodPositionUs = window.getPositionInFirstPeriodUs() + windowPositionUs;
     long periodDurationUs = timeline.getPeriod(periodIndex, period).getDurationUs();
+
+    // 一个Window可能包含多个Period, 因此定位到合适的Period, 然后返回<PeriodIndex, PeriodPositionUs>
     while (periodDurationUs != C.TIME_UNSET && periodPositionUs >= periodDurationUs
             && periodIndex < window.lastPeriodIndex) {
       periodPositionUs -= periodDurationUs;
diff --git a/library/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/src/main/java/com/google/android/exoplayer2/Timeline.java
index 333dd25cbe..aa37fe99d8 100644
--- a/library/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -16,23 +16,28 @@
 package com.google.android.exoplayer2;
 
 /**
- * A representation of media currently available for playback.
+ * A representation of media currently available for playback. 当前可以播放的Media的表示?
+ *
  * <p>
  * Timeline instances are immutable. For cases where the available media is changing dynamically
  * (e.g. live streams) a timeline provides a snapshot of the media currently available.
  * <p>
- * A timeline consists of related {@link Period}s and {@link Window}s. A period defines a single
- * logical piece of media, for example a media file. A window spans one or more periods, defining
- * the region within those periods that's currently available for playback along with additional
- * information such as whether seeking is supported within the window. Each window defines a default
- * position, which is the position from which playback will start when the player starts playing the
+ * A timeline consists of related {@link Period}s and {@link Window}s.
+ *
+ * A period defines a single logical piece of media, for example a media file.
+ * 一个Period, 例如: 一个ts对应一个时间段
+ * A window spans one or more periods, defining the region within those periods that's currently available for playback along with additional
+ * information such as whether seeking is supported within the window.
+ * window可以跨越多个Periods, 是否支持seeking
+ *
+ * Each window defines a default position, which is the position from which playback will start when the player starts playing the
  * window. The following examples illustrate timelines for various use cases.
  *
  * <h3 id="single-file">Single media file or on-demand stream</h3>
  * <p align="center">
  *   <img src="doc-files/timeline-single-file.svg" alt="Example timeline for a single file">
  * </p>
- * A timeline for a single media file or on-demand stream consists of a single period and window.
+ * A timeline for a single media file or on-demand stream  consists of a single period and window. 单一文件: 一个Period和window
  * The window spans the whole period, indicating that all parts of the media are available for
  * playback. The window's default position is typically at the start of the period (indicated by the
  * black dot in the figure above).
@@ -47,6 +52,7 @@
  * their durations and whether the window is seekable) will often only become known when the player
  * starts buffering the corresponding file or stream.
  *
+ * 有长度限制的直播
  * <h3 id="live-limited">Live stream with limited availability</h3>
  * <p align="center">
  *   <img src="doc-files/timeline-live-limited.svg" alt="Example timeline for a live stream with
@@ -59,6 +65,7 @@
  * the stream is still live. Its default position is typically near to the live edge (indicated by
  * the black dot in the figure above).
  *
+ * 长度未知的直播
  * <h3>Live stream with indefinite availability</h3>
  * <p align="center">
  *   <img src="doc-files/timeline-live-indefinite.svg" alt="Example timeline for a live stream with
@@ -91,9 +98,7 @@
  */
 public abstract class Timeline {
 
-  /**
-   * An empty timeline.
-   */
+  // 空的Timeline, 没有Period, 没有Window
   public static final Timeline EMPTY = new Timeline() {
 
     @Override
@@ -172,8 +177,7 @@ public Window getWindow(int windowIndex, Window window, boolean setIds) {
    *     default start position should be projected.
    * @return The populated {@link Window}, for convenience.
    */
-  public abstract Window getWindow(int windowIndex, Window window, boolean setIds,
-      long defaultPositionProjectionUs);
+  public abstract Window getWindow(int windowIndex, Window window, boolean setIds, long defaultPositionProjectionUs);
 
   /**
    * Returns the number of periods in the timeline.
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index d893d60262..5a7d67ea5e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -90,6 +90,7 @@ public void releaseSource() {
     childSource.releaseSource();
   }
 
+  // 带有重复播放的Timeline
   private static final class LoopingTimeline extends Timeline {
 
     private final Timeline childTimeline;
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index ae367ef14c..731c78bcff 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -21,6 +21,7 @@
 
 /**
  * A {@link Timeline} consisting of a single period and static window.
+ * 只包含1个window和1个period的Timeline
  */
 public final class SinglePeriodTimeline extends Timeline {
 
@@ -74,11 +75,15 @@ public int getWindowCount() {
   }
 
   @Override
-  public Window getWindow(int windowIndex, Window window, boolean setIds,
-      long defaultPositionProjectionUs) {
+  public Window getWindow(int windowIndex, Window window, boolean setIds, long defaultPositionProjectionUs) {
     Assertions.checkIndex(windowIndex, 0, 1);
+
     Object id = setIds ? ID : null;
     long windowDefaultStartPositionUs = this.windowDefaultStartPositionUs;
+
+    //
+    // 正常情况下 isDynamic  == false
+    //
     if (isDynamic) {
       windowDefaultStartPositionUs += defaultPositionProjectionUs;
       if (windowDefaultStartPositionUs > windowDurationUs) {
@@ -86,8 +91,14 @@ public Window getWindow(int windowIndex, Window window, boolean setIds,
         windowDefaultStartPositionUs = C.TIME_UNSET;
       }
     }
-    return window.set(id, C.TIME_UNSET, C.TIME_UNSET, isSeekable, isDynamic,
-        windowDefaultStartPositionUs, windowDurationUs, 0, 0, windowPositionInPeriodUs);
+
+    // 修改window的信息
+    // Object id, long presentationStartTimeMs, long windowStartTimeMs,
+    // boolean isSeekable, boolean isDynamic, long defaultPositionUs, long durationUs,
+    // int firstPeriodIndex, int lastPeriodIndex, long positionInFirstPeriodUs
+    return window.set(id, C.TIME_UNSET, C.TIME_UNSET,
+            isSeekable, isDynamic, windowDefaultStartPositionUs, windowDurationUs,
+            0, 0, windowPositionInPeriodUs);
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 44b6f9b6cf..fd7234d178 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -196,10 +196,18 @@ public void setIsTimestampMaster(boolean isTimestampMaster) {
   public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChunkHolder out) {
 
     int oldVariantIndex = previous == null ? C.INDEX_UNSET : trackGroup.indexOf(previous.trackFormat);
+
     // Use start time of the previous chunk rather than its end time because switching format will
-    // require downloading overlapping segments.
+    // require downloading overlapping segments. TODO: 这个如何理解呢? 为什么要下载Overlapping的Segments?
+    // 如何切换格式?
+
+    // 下一个Chunk该如何选择呢?
+    // 首先判断已近缓存了多少数据
+    //   playbackPositionUs 表示当前playback的位置
+    //
     long bufferedDurationUs = previous == null ? 0 : Math.max(0, previous.startTimeUs - playbackPositionUs);
 
+
     // Select the variant.
     trackSelection.updateSelectedTrack(bufferedDurationUs);
 
@@ -207,6 +215,8 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     int newVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
 
     boolean switchingVariant = oldVariantIndex != newVariantIndex;
+
+    // 获取新的Playlist
     HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(variants[newVariantIndex]);
     if (mediaPlaylist == null) {
       out.playlist = variants[newVariantIndex];
@@ -217,6 +227,9 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
     // Select the chunk.
     int chunkMediaSequence;
     if (previous == null || switchingVariant) {
+
+      // 下一个视频从什么地方开始下载呢?
+      // 为什么需要有一个Overlap的空间呢? TODO:
       // 第一次下载，或者切换: Variants
       long targetPositionUs = previous == null ? playbackPositionUs : previous.startTimeUs;
 
@@ -224,9 +237,12 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
         // If the playlist is too old to contain the chunk, we need to refresh it.
         chunkMediaSequence = mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();
       } else {
+
+        // 普通的VOD点播的视频
         chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
                 targetPositionUs - mediaPlaylist.startTimeUs, true,
                 !playlistTracker.isLive() || previous == null) + mediaPlaylist.mediaSequence;
+
         if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null) {
           // We try getting the next chunk without adapting in case that's the reason for falling
           // behind the live window.
@@ -236,8 +252,12 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
         }
       }
     } else {
+      // 正常下载下一个Segment
       chunkMediaSequence = previous.getNextChunkIndex();
     }
+
+    // 获取有效的: chunkMediaSequence
+
     if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
       fatalError = new BehindLiveWindowException();
       return;
@@ -253,32 +273,16 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
       return;
     }
 
-    // Handle encryption.
+    // 获取有效的Segment
     HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
+    clearEncryptionData();
 
-    // Check if encryption is specified.
-    // 暂时认为都是非加密的
-    if (segment.isEncrypted) {
-      Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.encryptionKeyUri);
-      if (!keyUri.equals(encryptionKeyUri)) {
-        // Encryption is specified and the key has changed.
-        out.chunk = newEncryptionKeyChunk(keyUri, segment.encryptionIV, newVariantIndex,
-                trackSelection.getSelectionReason(), trackSelection.getSelectionData());
-        return;
-      }
-      if (!Util.areEqual(segment.encryptionIV, encryptionIvString)) {
-        setEncryptionData(keyUri, segment.encryptionIV, encryptionKey);
-      }
-    } else {
-      clearEncryptionData();
-    }
-
+    // 构建相关的DataSpec
     DataSpec initDataSpec = null;
     Segment initSegment = mediaPlaylist.initializationSegment;
     if (initSegment != null) {
       Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
-      initDataSpec = new DataSpec(initSegmentUri, initSegment.byterangeOffset,
-              initSegment.byterangeLength, null);
+      initDataSpec = new DataSpec(initSegmentUri, initSegment.byterangeOffset, initSegment.byterangeLength, null);
     }
 
     // Compute start time of the next chunk.
@@ -288,10 +292,11 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChu
 
     // Configure the data source and spec for the chunk.
     Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
-    DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
-            null);
+    DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength, null);
 
     // 选择一个MediaChunk
+    // newVariantIndex 主要通过 trackSelection 来设置
+    // 但是似乎没有没有开始下载?
     out.chunk = new HlsMediaChunk(dataSource, dataSpec, initDataSpec, variants[newVariantIndex],
             trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
             startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence,
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index 832357c689..f68015a024 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -114,6 +114,7 @@ public TrackGroupArray getTrackGroups() {
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
                            SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+
     // Map each selection and stream onto a child period index.
     int[] streamChildIndices = new int[selections.length];
     int[] selectionChildIndices = new int[selections.length];
@@ -224,6 +225,7 @@ public long getBufferedPositionUs() {
   @Override
   public long seekToUs(long positionUs) {
     timestampAdjusterProvider.reset();
+    // 所有的SampleStreamWrapper, seek？
     for (HlsSampleStreamWrapper sampleStreamWrapper : enabledSampleStreamWrappers) {
       sampleStreamWrapper.seekTo(positionUs);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index a4a5ddfe7a..9f01bd40d3 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -65,6 +65,8 @@ public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
     this.manifestUri = manifestUri;
     this.dataSourceFactory = dataSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
+
+    // 如何处理HlsMediaSource呢?
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
   }
 
@@ -73,8 +75,7 @@ public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener l
     Assertions.checkState(playlistTracker == null);
     // 例如:
     //       manifestUri = https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8
-    playlistTracker = new HlsPlaylistTracker(manifestUri, dataSourceFactory, eventDispatcher,
-        minLoadableRetryCount, this);
+    playlistTracker = new HlsPlaylistTracker(manifestUri, dataSourceFactory, eventDispatcher, minLoadableRetryCount, this);
 
     sourceListener = listener;
     playlistTracker.start();
@@ -116,7 +117,11 @@ public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
       timeline = new SinglePeriodTimeline(C.TIME_UNSET, playlist.durationUs,
           playlist.startTimeUs, windowDefaultStartPositionUs, true, !playlist.hasEndTag);
     } else /* not live */ {
+
       // 这个是我们关注的信息
+      // Window/Timeline
+      // XXX: 一个m3u8文件对应一个 SinglePeriodTimeline
+      //
       timeline = new SinglePeriodTimeline(playlist.startTimeUs + playlist.durationUs,
           playlist.durationUs, playlist.startTimeUs, 0, true, false);
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index bf17697fd8..58ffa35c93 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -128,6 +128,8 @@ public HlsSampleStreamWrapper(int trackType, Callback callback, HlsChunkSource c
     this.trackType = trackType;
     this.callback = callback;
     this.chunkSource = chunkSource;
+
+    
     this.allocator = allocator;
     this.muxedAudioFormat = muxedAudioFormat;
     this.muxedCaptionFormat = muxedCaptionFormat;
@@ -223,7 +225,11 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
 
   public void seekTo(long positionUs) {
     lastSeekPositionUs = positionUs;
+
+    // 跳转到什么地方再开始播放？
     pendingResetPositionUs = positionUs;
+
+
     loadingFinished = false;
     mediaChunks.clear();
     if (loader.isLoading()) {
@@ -317,7 +323,8 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
             lastSeekPositionUs);
   }
 
-  /* package */ void skipToKeyframeBefore(int group, long timeUs) {
+  /* package */
+  void skipToKeyframeBefore(int group, long timeUs) {
     sampleQueues.valueAt(group).skipToKeyframeBefore(timeUs);
   }
 
@@ -333,15 +340,20 @@ private boolean finishedReadingChunk(HlsMediaChunk chunk) {
 
   // SequenceableLoader implementation
 
+  // 是否继续加载?
   @Override
   public boolean continueLoading(long positionUs) {
     if (loadingFinished || loader.isLoading()) {
       return false;
     }
 
+    // 继续加载:
+    // 注意这个指定的positionUs
     chunkSource.getNextChunk(mediaChunks.isEmpty() ? null : mediaChunks.getLast(),
             pendingResetPositionUs != C.TIME_UNSET ? pendingResetPositionUs : positionUs,
             nextChunkHolder);
+
+    // 获取下载一个chunk之后?
     boolean endOfStream = nextChunkHolder.endOfStream;
     Chunk loadable = nextChunkHolder.chunk;
     HlsMasterPlaylist.HlsUrl playlistToLoad = nextChunkHolder.playlist;
@@ -352,6 +364,7 @@ public boolean continueLoading(long positionUs) {
       return true;
     }
 
+    // 如果没有可下载的数据，则需要Refresh Hls文件
     if (loadable == null) {
       if (playlistToLoad != null) {
         callback.onPlaylistRefreshRequired(playlistToLoad);
@@ -365,7 +378,12 @@ public boolean continueLoading(long positionUs) {
       mediaChunk.init(this);
       mediaChunks.add(mediaChunk);
     }
+
+    // TODO: 开始下载数据: loadable, 也即是一个HLSChunk, 一个TS文件
     long elapsedRealtimeMs = loader.startLoading(loadable, this, minLoadableRetryCount);
+    // 接下来关注: #onLoadCompleted
+
+    // 通知开始下载
     eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
             loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
             loadable.endTimeUs, elapsedRealtimeMs);
@@ -385,10 +403,17 @@ public long getNextLoadPositionUs() {
 
   @Override
   public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs) {
+
+    // ChunkSource下载完毕
+    // 主要是做一些解密之类的工作，默认情况下可以跳过(主要是为了学习)
     chunkSource.onChunkLoadCompleted(loadable);
+
+
     eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
             loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
             loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+
+    // 是否继续下载呢?
     if (!prepared) {
       continueLoading(lastSeekPositionUs);
     } else {
@@ -402,6 +427,8 @@ public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDura
     eventDispatcher.loadCanceled(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
             loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
             loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+
+    // 下载取消
     if (!released) {
       int sampleQueueCount = sampleQueues.size();
       for (int i = 0; i < sampleQueueCount; i++) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index d29054b154..3c1cb25527 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -94,7 +94,9 @@
 
   @Override
   public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
+    // InputStream 封装成为: BufferedReader, 注意文件的编码，不过m3u8等文件都是英文
     BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
+
     Queue<String> extraLines = new LinkedList<>();
     String line;
 
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index 95bfd85fae..6ede1197ff 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -112,7 +112,9 @@ public HlsPlaylistTracker(Uri initialPlaylistUri, DataSource.Factory dataSourceF
       EventDispatcher eventDispatcher, int minRetryCount,
       PrimaryPlaylistListener primaryPlaylistListener) {
 
+    // Playlist的Uri
     this.initialPlaylistUri = initialPlaylistUri;
+
     this.dataSourceFactory = dataSourceFactory;
     this.eventDispatcher = eventDispatcher;
     this.minRetryCount = minRetryCount;
@@ -153,8 +155,7 @@ public void start() {
     // 下载: Playlist, 并且通过 playlistParser 来解析
     // dataSourceFactory.createDataSource() 指定了网络请求
     ParsingLoadable<HlsPlaylist> masterPlaylistLoadable =
-            new ParsingLoadable<>(dataSourceFactory.createDataSource(),
-                    initialPlaylistUri, C.DATA_TYPE_MANIFEST, playlistParser);
+            new ParsingLoadable<>(dataSourceFactory.createDataSource(), initialPlaylistUri, C.DATA_TYPE_MANIFEST, playlistParser);
 
     // this Loader callback
     initialPlaylistLoader.startLoading(masterPlaylistLoadable, this, minRetryCount);
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
index 50cb125172..3ec3d29984 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveVideoTrackSelection.java
@@ -89,11 +89,21 @@ public AdaptiveVideoTrackSelection createTrackSelection(TrackGroup group, int...
 
   }
 
-  public static final int DEFAULT_MAX_INITIAL_BITRATE = 800000; // 默认是: 800K
+  // 至少下载了: 2000ms，也即是2s；或者512k数据才能有一个稳定的带宽估计，这个2s时间也不短；
+  // 因此一个默认的variant的选择也很重要
+
+  // 默认是: 800K，这个就是为什么刚开始视频会比较模糊
+  // TODO: 提高编码效率, 保证低码率的视频也足够清晰
+  //
+  public static final int DEFAULT_MAX_INITIAL_BITRATE = 800000;
+
+  // 切换高质量的视频：必须至少10s,
   public static final int DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS = 10000;
   public static final int DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS = 25000;
+
   public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;
-  public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f;
+
+  public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f; // 0.75的估算
 
   private final BandwidthMeter bandwidthMeter;
   private final int maxInitialBitrate;
@@ -178,11 +188,14 @@ public void updateSelectedTrack(long bufferedDurationUs) {
           && bufferedDurationUs < minDurationForQualityIncreaseUs) {
         // The ideal track is a higher quality, but we have insufficient buffer to safely switch
         // up. Defer switching up for now.
+        // 要切换到高码率，则需要有足够的buffer时间
         selectedIndex = currentSelectedIndex;
+
       } else if (idealFormat.bitrate < currentFormat.bitrate
           && bufferedDurationUs >= maxDurationForQualityDecreaseUs) {
         // The ideal track is a lower quality, but we have sufficient buffer to defer switching
         // down for now.
+        // 如果我们的高清码率的视频buffer足够多，那么我们也可以不着急切换variant(format)
         selectedIndex = currentSelectedIndex;
       }
     }
@@ -214,11 +227,16 @@ public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk>
     if (queue.isEmpty()) {
       return 0;
     }
+
+    // 评估需要保留的queue的size
     int queueSize = queue.size();
     long bufferedDurationUs = queue.get(queueSize - 1).endTimeUs - playbackPositionUs;
+    // 本来就不够，不能扔
     if (bufferedDurationUs < minDurationToRetainAfterDiscardUs) {
       return queueSize;
     }
+
+
     int idealSelectedIndex = determineIdealSelectedIndex(SystemClock.elapsedRealtime());
     Format idealFormat = getFormat(idealSelectedIndex);
     // Discard from the first SD chunk beyond minDurationToRetainAfterDiscardUs whose resolution and
@@ -226,6 +244,8 @@ public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk>
     for (int i = 0; i < queueSize; i++) {
       MediaChunk chunk = queue.get(i);
       long durationBeforeThisChunkUs = chunk.startTimeUs - playbackPositionUs;
+
+      // 保证有足够的视频，并且chunk中的事情质量不是很高，则可以扔掉部分
       if (durationBeforeThisChunkUs >= minDurationToRetainAfterDiscardUs
           && chunk.trackFormat.bitrate < idealFormat.bitrate
           && chunk.trackFormat.height < idealFormat.height
@@ -254,13 +274,14 @@ private int determineIdealSelectedIndex(long nowMs) {
     int lowestBitrateNonBlacklistedIndex = 0;
     for (int i = 0; i < length; i++) {
       if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {
-        Format format = getFormat(i);
         // formats的码率从高到低变化
+        Format format = getFormat(i);
+
         // 直到找到一个满足带宽需要的Format
         if (format.bitrate <= effectiveBitrate) {
           return i;
         } else {
-          // 满足条件的最小带宽的Format
+          // 不满足条件，但是带宽最小的Format
           lowestBitrateNonBlacklistedIndex = i;
         }
       }
diff --git a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
index c085ee0831..7fa2e4776e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
+++ b/library/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
@@ -45,6 +45,7 @@
 
   /**
    * The {@link Format}s of the selected tracks, in order of decreasing bandwidth.
+   * 所需要的带宽从大到小排列
    */
   private final Format[] formats;
   /**
@@ -71,6 +72,7 @@ public BaseTrackSelection(TrackGroup group, int... tracks) {
       formats[i] = group.getFormat(tracks[i]);
     }
     Arrays.sort(formats, new DecreasingBandwidthComparator());
+
     // Set the format indices in the same order.
     this.tracks = new int[length];
     for (int i = 0; i < length; i++) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index 40e814dab3..f05b43e44e 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -47,7 +47,7 @@
  * The following attributes can be set on a PlaybackControlView when used in a layout XML file:
  * <p>
  * <ul>
- *   <li><b>{@code show_timeout}</b> - The time between the last user interaction and the controls
+ *   <li>自动隐藏控件<b>{@code show_timeout}</b> - The time between the last user interaction and the controls
  *       being automatically hidden, in milliseconds. Use zero if the controls should not
  *       automatically timeout.
  *       <ul>
@@ -55,14 +55,14 @@
  *         <li>Default: {@link #DEFAULT_SHOW_TIMEOUT_MS}</li>
  *       </ul>
  *   </li>
- *   <li><b>{@code rewind_increment}</b> - The duration of the rewind applied when the user taps the
+ *   <li>倒回<b>{@code rewind_increment}</b> - The duration of the rewind applied when the user taps the
  *       rewind button, in milliseconds. Use zero to disable the rewind button.
  *       <ul>
  *         <li>Corresponding method: {@link #setRewindIncrementMs(int)}</li>
  *         <li>Default: {@link #DEFAULT_REWIND_MS}</li>
  *       </ul>
  *   </li>
- *   <li><b>{@code fastforward_increment}</b> - Like {@code rewind_increment}, but for fast forward.
+ *   <li>快进<b>{@code fastforward_increment}</b> - Like {@code rewind_increment}, but for fast forward.
  *       <ul>
  *         <li>Corresponding method: {@link #setFastForwardIncrementMs(int)}</li>
  *         <li>Default: {@link #DEFAULT_FAST_FORWARD_MS}</li>
@@ -181,6 +181,8 @@
 
     @Override
     public boolean dispatchSeek(ExoPlayer player, int windowIndex, long positionMs) {
+      // 如何Dispatch消息呢?
+      // 直接执行seekTo动作
       player.seekTo(windowIndex, positionMs);
       return true;
     }
@@ -241,6 +243,7 @@ public PlaybackControlView(Context context, AttributeSet attrs) {
     this(context, attrs, 0);
   }
 
+  // 通过XML设置个各种参数
   public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
 
@@ -262,6 +265,7 @@ public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr
         a.recycle();
       }
     }
+
     currentWindow = new Timeline.Window();
     formatBuilder = new StringBuilder();
     formatter = new Formatter(formatBuilder, Locale.getDefault());
@@ -499,8 +503,11 @@ private void updateProgress() {
     if (!isVisible() || !isAttachedToWindow) {
       return;
     }
+
+    // 根据player状态更新Control
     long duration = player == null ? 0 : player.getDuration();
     long position = player == null ? 0 : player.getCurrentPosition();
+
     if (durationView != null) {
       durationView.setText(stringForTime(duration));
     }
@@ -579,6 +586,7 @@ private int progressBarValue(long position) {
         : (int) ((position * PROGRESS_BAR_MAX) / duration);
   }
 
+  // 根据progress获取当前的position, 总时间 * 百分比
   private long positionValue(int progress) {
     long duration = player == null ? C.TIME_UNSET : player.getDuration();
     return duration == C.TIME_UNSET ? 0 : ((duration * progress) / PROGRESS_BAR_MAX);
@@ -616,6 +624,8 @@ private void rewind() {
     if (rewindMs <= 0) {
       return;
     }
+
+    // 后退
     seekTo(Math.max(player.getCurrentPosition() - rewindMs, 0));
   }
 
@@ -623,15 +633,21 @@ private void fastForward() {
     if (fastForwardMs <= 0) {
       return;
     }
+    // 快进:
     seekTo(Math.min(player.getCurrentPosition() + fastForwardMs, player.getDuration()));
   }
 
   private void seekTo(long positionMs) {
+
     seekTo(player.getCurrentWindowIndex(), positionMs);
   }
 
   private void seekTo(int windowIndex, long positionMs) {
+    //
+    // windowIndex, positionMS两个参数如何协调呢?
+    //
     boolean dispatched = seekDispatcher.dispatchSeek(player, windowIndex, positionMs);
+
     if (!dispatched) {
       // The seek wasn't dispatched. If the progress bar was dragged by the user to perform the
       // seek then it'll now be in the wrong position. Trigger a progress update to snap it back.
@@ -724,6 +740,7 @@ private static boolean isHandledMediaKey(int keyCode) {
         || keyCode == KeyEvent.KEYCODE_MEDIA_PREVIOUS;
   }
 
+  // 负责处理: Seekbar的进度控制
   private final class ComponentListener implements ExoPlayer.EventListener,
       SeekBar.OnSeekBarChangeListener, OnClickListener {
 
@@ -736,6 +753,7 @@ public void onStartTrackingTouch(SeekBar seekBar) {
     @Override
     public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
       if (fromUser && positionView != null) {
+        // 只更新进度信息，暂不是调整progress
         positionView.setText(stringForTime(positionValue(progress)));
       }
     }
@@ -744,6 +762,7 @@ public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
     public void onStopTrackingTouch(SeekBar seekBar) {
       dragging = false;
       if (player != null) {
+        // 更新进度
         seekTo(positionValue(seekBar.getProgress()));
       }
       hideAfterTimeout();
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
index e2c4b4fab9..eb3218c035 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DataSourceInputStream.java
@@ -84,10 +84,14 @@ public int read(byte[] buffer) throws IOException {
   @Override
   public int read(byte[] buffer, int offset, int length) throws IOException {
     Assertions.checkState(!closed);
+
+    // 确保DataSource被打开
     checkOpened();
 
 
+    // 通过dataSource将底层的实现抽象开来，例如: 文件，URLConnection等
     int bytesRead = dataSource.read(buffer, offset, length);
+
     if (bytesRead == C.RESULT_END_OF_INPUT) {
       return -1;
     } else {
@@ -106,6 +110,9 @@ public void close() throws IOException {
 
   private void checkOpened() throws IOException {
     if (!opened) {
+      // 通过dataSource打开dataSpec
+      // 例如： OKHttpDataSource
+      //
       dataSource.open(dataSpec);
       opened = true;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
index 373af96cd5..417d633aeb 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
@@ -17,13 +17,14 @@
 
 import android.os.Handler;
 import android.os.SystemClock;
+
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.SlidingPercentile;
 
 /**
  * Estimates bandwidth by listening to data transfers. The bandwidth estimate is calculated using
  * a {@link SlidingPercentile} and is updated each time a transfer ends.
- *
+ * <p>
  * 如何评估带宽呢?
  */
 public final class DefaultBandwidthMeter implements BandwidthMeter, TransferListener<Object> {
@@ -33,6 +34,8 @@
    */
   public static final int DEFAULT_MAX_WEIGHT = 2000;
 
+  // 至少下载了: 2000ms，也即是2s；或者512k数据才能有一个稳定的带宽估计，这个2s时间也不短；
+  // 因此一个默认的variant的选择也很重要
   private static final int ELAPSED_MILLIS_FOR_ESTIMATE = 2000;
   private static final int BYTES_TRANSFERRED_FOR_ESTIMATE = 512 * 1024;
 
@@ -60,6 +63,8 @@ public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener,
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
     this.slidingPercentile = new SlidingPercentile(maxWeight);
+
+    // 如何做"带宽"估计呢?
     bitrateEstimate = NO_ESTIMATE;
   }
 
@@ -91,19 +96,30 @@ public synchronized void onTransferEnd(Object source) {
     totalElapsedTimeMs += sampleElapsedTimeMs;
     totalBytesTransferred += sampleBytesTransferred;
 
+    // onTransferStart
+    // onBytesTransferred
+    // onTransferEnd
+    // 再怎么招，都不能再一个ts下载过程中切换variants
+    //
     if (sampleElapsedTimeMs > 0) {
+      // 带宽单位: bit/s
       float bitsPerSecond = (sampleBytesTransferred * 8000) / sampleElapsedTimeMs;
 
+      // 添加sample?
       slidingPercentile.addSample((int) Math.sqrt(sampleBytesTransferred), bitsPerSecond);
 
-      if (totalElapsedTimeMs >= ELAPSED_MILLIS_FOR_ESTIMATE
-          || totalBytesTransferred >= BYTES_TRANSFERRED_FOR_ESTIMATE) {
+      if (totalElapsedTimeMs >= ELAPSED_MILLIS_FOR_ESTIMATE || totalBytesTransferred >= BYTES_TRANSFERRED_FOR_ESTIMATE) {
         float bitrateEstimateFloat = slidingPercentile.getPercentile(0.5f);
-        bitrateEstimate = Float.isNaN(bitrateEstimateFloat) ? NO_ESTIMATE
-            : (long) bitrateEstimateFloat;
+
+        bitrateEstimate = Float.isNaN(bitrateEstimateFloat) ? NO_ESTIMATE : (long) bitrateEstimateFloat;
       }
     }
+
+    // 通知"带宽"变化
+    // 可能我们也需要有一个Debug信息
     notifyBandwidthSample(sampleElapsedTimeMs, sampleBytesTransferred, bitrateEstimate);
+
+    // 开始一个新的阶段，例如: 以前有N个stream, 现在只有N-1个Stream
     if (--streamCount > 0) {
       sampleStartTimeMs = nowMs;
     }
@@ -112,7 +128,7 @@ public synchronized void onTransferEnd(Object source) {
 
   private void notifyBandwidthSample(final int elapsedMs, final long bytes, final long bitrate) {
     if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
+      eventHandler.post(new Runnable() {
         @Override
         public void run() {
           // 带宽变化了，如何处理呢?
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index ae6f1e0691..cc25c9667a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -119,6 +119,8 @@ public long open(DataSpec dataSpec) throws IOException {
     } else {
       dataSource = baseDataSource;
     }
+
+    // 默认的DataSource可以处理各种DataSpec
     // Open the source and return.
     return dataSource.open(dataSpec);
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index eba84a756c..ee37fb1d18 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -18,10 +18,12 @@
 import android.net.Uri;
 import android.text.TextUtils;
 import android.util.Log;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Predicate;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -62,7 +64,7 @@
   private static final int MAX_REDIRECTS = 20; // Same limit as okhttp.
   private static final long MAX_BYTES_TO_DRAIN = 2048;
   private static final Pattern CONTENT_RANGE_HEADER =
-      Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
+          Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
   private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<>();
 
   private final boolean allowCrossProtocolRedirects;
@@ -85,62 +87,62 @@
   private long bytesRead;
 
   /**
-   * @param userAgent The User-Agent string that should be used.
+   * @param userAgent            The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
+   *                             predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
+   *                             {@link #open(DataSpec)}.
    */
   public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate) {
     this(userAgent, contentTypePredicate, null);
   }
 
   /**
-   * @param userAgent The User-Agent string that should be used.
+   * @param userAgent            The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
+   *                             predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
+   *                             {@link #open(DataSpec)}.
+   * @param listener             An optional listener.
    */
   public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-      TransferListener<? super DefaultHttpDataSource> listener) {
+                               TransferListener<? super DefaultHttpDataSource> listener) {
     this(userAgent, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
-        DEFAULT_READ_TIMEOUT_MILLIS);
+            DEFAULT_READ_TIMEOUT_MILLIS);
   }
 
   /**
-   * @param userAgent The User-Agent string that should be used.
+   * @param userAgent            The User-Agent string that should be used.
    * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
+   *                             predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
+   *                             {@link #open(DataSpec)}.
+   * @param listener             An optional listener.
    * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
-   *     interpreted as an infinite timeout.
-   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted
-   *     as an infinite timeout.
+   *                             interpreted as an infinite timeout.
+   * @param readTimeoutMillis    The read timeout, in milliseconds. A timeout of zero is interpreted
+   *                             as an infinite timeout.
    */
   public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-      TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
-      int readTimeoutMillis) {
+                               TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
+                               int readTimeoutMillis) {
     this(userAgent, contentTypePredicate, listener, connectTimeoutMillis, readTimeoutMillis, false);
   }
 
   /**
-   * @param userAgent The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
-   * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
-   *     interpreted as an infinite timeout. Pass {@link #DEFAULT_CONNECT_TIMEOUT_MILLIS} to use
-   *     the default value.
-   * @param readTimeoutMillis The read timeout, in milliseconds. A timeout of zero is interpreted
-   *     as an infinite timeout. Pass {@link #DEFAULT_READ_TIMEOUT_MILLIS} to use the default value.
+   * @param userAgent                   The User-Agent string that should be used.
+   * @param contentTypePredicate        An optional {@link Predicate}. If a content type is rejected by the
+   *                                    predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
+   *                                    {@link #open(DataSpec)}.
+   * @param listener                    An optional listener.
+   * @param connectTimeoutMillis        The connection timeout, in milliseconds. A timeout of zero is
+   *                                    interpreted as an infinite timeout. Pass {@link #DEFAULT_CONNECT_TIMEOUT_MILLIS} to use
+   *                                    the default value.
+   * @param readTimeoutMillis           The read timeout, in milliseconds. A timeout of zero is interpreted
+   *                                    as an infinite timeout. Pass {@link #DEFAULT_READ_TIMEOUT_MILLIS} to use the default value.
    * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
-   *     to HTTPS and vice versa) are enabled.
+   *                                    to HTTPS and vice versa) are enabled.
    */
   public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-      TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
-      int readTimeoutMillis, boolean allowCrossProtocolRedirects) {
+                               TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
+                               int readTimeoutMillis, boolean allowCrossProtocolRedirects) {
     this.userAgent = Assertions.checkNotEmpty(userAgent);
     this.contentTypePredicate = contentTypePredicate;
     this.listener = listener;
@@ -197,7 +199,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
       connection = makeConnection(dataSpec);
     } catch (IOException e) {
       throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-          dataSpec, HttpDataSourceException.TYPE_OPEN);
+              dataSpec, HttpDataSourceException.TYPE_OPEN);
     }
 
     int responseCode;
@@ -206,7 +208,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     } catch (IOException e) {
       closeConnectionQuietly();
       throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-          dataSpec, HttpDataSourceException.TYPE_OPEN);
+              dataSpec, HttpDataSourceException.TYPE_OPEN);
     }
 
     // Check for a valid response code.
@@ -214,7 +216,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
       Map<String, List<String>> headers = connection.getHeaderFields();
       closeConnectionQuietly();
       InvalidResponseCodeException exception =
-          new InvalidResponseCodeException(responseCode, headers, dataSpec);
+              new InvalidResponseCodeException(responseCode, headers, dataSpec);
       if (responseCode == 416) {
         exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
       }
@@ -231,6 +233,9 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     // If we requested a range starting from a non-zero position and received a 200 rather than a
     // 206, then the server does not support partial requests. We'll need to manually skip to the
     // requested position.
+    // Range Request返回的code:
+    // 200
+    // 206的区别
     bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
 
     // Determine the length of the data to be read, after skipping.
@@ -240,7 +245,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
       } else {
         long contentLength = getContentLength(connection);
         bytesToRead = contentLength != C.LENGTH_UNSET ? (contentLength - bytesToSkip)
-            : C.LENGTH_UNSET;
+                : C.LENGTH_UNSET;
       }
     } else {
       // Gzip is enabled. If the server opts to use gzip then the content length in the response
@@ -359,16 +364,16 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
     // We need to handle redirects ourselves to allow cross-protocol redirects.
     int redirectCount = 0;
     while (redirectCount++ <= MAX_REDIRECTS) {
-      HttpURLConnection connection = makeConnection(
-          url, postBody, position, length, allowGzip, false /* followRedirects */);
+      HttpURLConnection connection = makeConnection(url, postBody, position, length, allowGzip, false); /* followRedirects */
+
       int responseCode = connection.getResponseCode();
       if (responseCode == HttpURLConnection.HTTP_MULT_CHOICE
-          || responseCode == HttpURLConnection.HTTP_MOVED_PERM
-          || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
-          || responseCode == HttpURLConnection.HTTP_SEE_OTHER
-          || (postBody == null
+              || responseCode == HttpURLConnection.HTTP_MOVED_PERM
+              || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
+              || responseCode == HttpURLConnection.HTTP_SEE_OTHER
+              || (postBody == null
               && (responseCode == 307 /* HTTP_TEMP_REDIRECT */
-                  || responseCode == 308 /* HTTP_PERM_REDIRECT */))) {
+              || responseCode == 308 /* HTTP_PERM_REDIRECT */))) {
         // For 300, 301, 302, and 303 POST requests follow the redirect and are transformed into
         // GET requests. For 307 and 308 POST requests are not redirected.
         postBody = null;
@@ -387,15 +392,15 @@ private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
   /**
    * Configures a connection and opens it.
    *
-   * @param url The url to connect to.
-   * @param postBody The body data for a POST request.
-   * @param position The byte offset of the requested data.
-   * @param length The length of the requested data, or {@link C#LENGTH_UNSET}.
-   * @param allowGzip Whether to allow the use of gzip.
+   * @param url             The url to connect to.
+   * @param postBody        The body data for a POST request.
+   * @param position        The byte offset of the requested data.
+   * @param length          The length of the requested data, or {@link C#LENGTH_UNSET}.
+   * @param allowGzip       Whether to allow the use of gzip.
    * @param followRedirects Whether to follow redirects.
    */
   private HttpURLConnection makeConnection(URL url, byte[] postBody, long position,
-      long length, boolean allowGzip, boolean followRedirects) throws IOException {
+                                           long length, boolean allowGzip, boolean followRedirects) throws IOException {
     // 新建Connection
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setConnectTimeout(connectTimeoutMillis);
@@ -405,6 +410,9 @@ private HttpURLConnection makeConnection(URL url, byte[] postBody, long position
         connection.setRequestProperty(property.getKey(), property.getValue());
       }
     }
+
+    // connection
+    // Range参数的设置
     if (!(position == 0 && length == C.LENGTH_UNSET)) {
       String rangeRequest = "bytes=" + position + "-";
       if (length != C.LENGTH_UNSET) {
@@ -413,18 +421,23 @@ private HttpURLConnection makeConnection(URL url, byte[] postBody, long position
       connection.setRequestProperty("Range", rangeRequest);
     }
     connection.setRequestProperty("User-Agent", userAgent);
+
+    // 如果不支持Gzip？
     if (!allowGzip) {
       connection.setRequestProperty("Accept-Encoding", "identity");
     }
     connection.setInstanceFollowRedirects(followRedirects);
     connection.setDoOutput(postBody != null);
+
     if (postBody != null) {
       connection.setRequestMethod("POST");
       if (postBody.length == 0) {
         connection.connect();
-      } else  {
+      } else {
         connection.setFixedLengthStreamingMode(postBody.length);
         connection.connect();
+
+        // 连接之后如何设置post body
         OutputStream os = connection.getOutputStream();
         os.write(postBody);
         os.close();
@@ -439,7 +452,7 @@ private HttpURLConnection makeConnection(URL url, byte[] postBody, long position
    * Handles a redirect.
    *
    * @param originalUrl The original URL.
-   * @param location The Location header in the response.
+   * @param location    The Location header in the response.
    * @return The next URL.
    * @throws IOException If redirection isn't possible.
    */
@@ -486,7 +499,7 @@ private static long getContentLength(HttpURLConnection connection) {
       if (matcher.find()) {
         try {
           long contentLengthFromRange =
-              Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
+                  Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
           if (contentLength < 0) {
             // Some proxy servers strip the Content-Length header. Fall back to the length
             // calculated here in this case.
@@ -497,7 +510,7 @@ private static long getContentLength(HttpURLConnection connection) {
             // change one of them to reduce the size of a request, but it is unlikely anybody would
             // increase it.
             Log.w(TAG, "Inconsistent headers [" + contentLengthHeader + "] [" + contentRangeHeader
-                + "]");
+                    + "]");
             contentLength = Math.max(contentLength, contentLengthFromRange);
           }
         } catch (NumberFormatException e) {
@@ -514,7 +527,7 @@ private static long getContentLength(HttpURLConnection connection) {
    * This implementation is based roughly on {@code libcore.io.Streams.skipByReading()}.
    *
    * @throws InterruptedIOException If the thread is interrupted during the operation.
-   * @throws EOFException If the end of the input stream is reached before the bytes are skipped.
+   * @throws EOFException           If the end of the input stream is reached before the bytes are skipped.
    */
   private void skipInternal() throws IOException {
     if (bytesSkipped == bytesToSkip) {
@@ -553,11 +566,11 @@ private void skipInternal() throws IOException {
    * This method blocks until at least one byte of data can be read, the end of the opened range is
    * detected, or an exception is thrown.
    *
-   * @param buffer The buffer into which the read data should be stored.
-   * @param offset The start offset into {@code buffer} at which data should be written.
+   * @param buffer     The buffer into which the read data should be stored.
+   * @param offset     The start offset into {@code buffer} at which data should be written.
    * @param readLength The maximum number of bytes to read.
    * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
-   *     range is reached.
+   * range is reached.
    * @throws IOException If an error occurs reading from the source.
    */
   private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
@@ -595,9 +608,9 @@ private int readInternal(byte[] buffer, int offset, int readLength) throws IOExc
    * unexpected end of input, working around this issue. On other platform API levels, the method
    * does nothing.
    *
-   * @param connection The connection whose {@link InputStream} should be terminated.
+   * @param connection     The connection whose {@link InputStream} should be terminated.
    * @param bytesRemaining The number of bytes remaining to be read from the input stream if its
-   *     length is known. {@link C#LENGTH_UNSET} otherwise.
+   *                       length is known. {@link C#LENGTH_UNSET} otherwise.
    */
   private static void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {
     if (Util.SDK_INT != 19 && Util.SDK_INT != 20) {
@@ -618,8 +631,8 @@ private static void maybeTerminateInputStream(HttpURLConnection connection, long
       }
       String className = inputStream.getClass().getName();
       if (className.equals("com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream")
-          || className.equals(
-          "com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream")) {
+              || className.equals(
+              "com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream")) {
         Class<?> superclass = inputStream.getClass().getSuperclass();
         Method unexpectedEndOfInput = superclass.getDeclaredMethod("unexpectedEndOfInput");
         unexpectedEndOfInput.setAccessible(true);
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java b/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
index 2137fa0c65..265af0e885 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
@@ -157,13 +157,13 @@ public Loader(String threadName) {
    * @throws IllegalStateException If the calling thread does not have an associated {@link Looper}.
    * @return {@link SystemClock#elapsedRealtime} when the load started.
    */
-  public <T extends Loadable> long startLoading(T loadable, Callback<T> callback,
-      int defaultMinRetryCount) {
+  public <T extends Loadable> long startLoading(T loadable, Callback<T> callback, int defaultMinRetryCount) {
     Looper looper = Looper.myLooper();
     Assertions.checkState(looper != null);
     long startTimeMs = SystemClock.elapsedRealtime();
 
     // 创建一个LoadTask
+    // 在当前的线程中开始下载任务
     new LoadTask<>(looper, loadable, callback, defaultMinRetryCount, startTimeMs).start(0);
     return startTimeMs;
   }
@@ -292,6 +292,7 @@ public void cancel(boolean released) {
     public void run() {
       try {
         executorThread = Thread.currentThread();
+        // 只要没有取消，就Load
         if (!loadable.isLoadCanceled()) {
           TraceUtil.beginSection("load:" + loadable.getClass().getSimpleName());
           try {
@@ -302,6 +303,8 @@ public void run() {
             TraceUtil.endSection();
           }
         }
+
+        // 加载成功，则通知下载完毕，下载时间，以及下载时长
         if (!released) {
           sendEmptyMessage(MSG_END_OF_SOURCE);
         }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
index abc7071d25..fcb0fb300d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
@@ -109,15 +109,21 @@ public final boolean isLoadCanceled() {
 
   @Override
   public final void load() throws IOException, InterruptedException {
+    // 如何Load呢?
+    // 1. 通过 dataSource 和 dataSpec, 得到一个InputStream
     DataSourceInputStream inputStream = new DataSourceInputStream(dataSource, dataSpec);
     try {
+      // 2. 打开Stream
       inputStream.open();
 
-      // 如何解析数据呢?
+      // 3. 如何解析数据呢?
       result = parser.parse(dataSource.getUri(), inputStream);
     } finally {
+
       // 读取了多少数据？
       bytesLoaded = inputStream.bytesRead();
+
+      // 这个close很重要
       inputStream.close();
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java b/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
index 8b1af1f0c8..e9d530f387 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/SlidingPercentile.java
@@ -58,6 +58,7 @@ public int compare(Sample a, Sample b) {
   private final int maxWeight;
   private final ArrayList<Sample> samples;
 
+  // 实现对Sample的重复利用；降低GC开销
   private final Sample[] recycledSamples;
 
   private int currentSortOrder;
@@ -79,22 +80,27 @@ public SlidingPercentile(int maxWeight) {
    * Adds a new weighted value.
    *
    * @param weight The weight of the new observation.
-   * @param value The value of the new observation.
+   * @param value  The value of the new observation.
    */
   public void addSample(int weight, float value) {
+
+    // 权重: 和传输的数据量有关
     ensureSortedByIndex();
 
-    Sample newSample = recycledSampleCount > 0 ? recycledSamples[--recycledSampleCount]
-        : new Sample();
+    Sample newSample = recycledSampleCount > 0 ? recycledSamples[--recycledSampleCount] : new Sample();
     newSample.index = nextSampleIndex++;
     newSample.weight = weight;
     newSample.value = value;
     samples.add(newSample);
     totalWeight += weight;
 
+
     while (totalWeight > maxWeight) {
       int excessWeight = totalWeight - maxWeight;
+
       Sample oldestSample = samples.get(0);
+
+      // 删除过期的元素
       if (oldestSample.weight <= excessWeight) {
         totalWeight -= oldestSample.weight;
         samples.remove(0);
@@ -102,6 +108,7 @@ public void addSample(int weight, float value) {
           recycledSamples[recycledSampleCount++] = oldestSample;
         }
       } else {
+        // 降低最旧元素的权重
         oldestSample.weight -= excessWeight;
         totalWeight -= excessWeight;
       }
@@ -118,6 +125,8 @@ public float getPercentile(float percentile) {
     ensureSortedByValue();
     float desiredWeight = percentile * totalWeight;
     int accumulatedWeight = 0;
+
+    // 按照value排序，然后再按照权重来选择一个带宽估计
     for (int i = 0; i < samples.size(); i++) {
       Sample currentSample = samples.get(i);
       accumulatedWeight += currentSample.weight;
@@ -149,6 +158,7 @@ private void ensureSortedByValue() {
     }
   }
 
+  // 权重，value
   private static class Sample {
 
     public int index;
diff --git a/library/src/main/java/com/google/android/exoplayer2/util/UriUtil.java b/library/src/main/java/com/google/android/exoplayer2/util/UriUtil.java
index 6592273d03..83e8f7d7b6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/util/UriUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer2/util/UriUtil.java
@@ -82,6 +82,9 @@ public static Uri resolveToUri(String baseUri, String referenceUri) {
    * @param referenceUri The reference URI to resolve.
    */
   public static String resolve(String baseUri, String referenceUri) {
+    // 实现两个URL的合并操作
+    // BaseURL， 以及一个相对的URL --> 绝对URL
+    //
     StringBuilder uri = new StringBuilder();
 
     // Map null onto empty string, to make the following logic simpler.
