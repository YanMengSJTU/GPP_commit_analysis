diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index 384f54db38..2840ae321d 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -149,6 +149,9 @@ public void clearAllRequestProperties() {
 
   @Override
   public long open(DataSpec dataSpec) throws HttpDataSourceException {
+
+    // DataSpec是否需要做一个限制
+    // 例如: 对于HLS我们就不支持Range下载？ 一般HLS文件比较小，而且一般也不在本地区分码率等，因此就一次搞定
     this.dataSpec = dataSpec;
     this.bytesRead = 0;
     this.bytesSkipped = 0;
@@ -161,6 +164,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
     try {
       // 通过callFactory可以共享底部的Sesion, making http2.0可用
       response = callFactory.newCall(request).execute();
+
       responseByteStream = response.body().byteStream();
     } catch (IOException e) {
       throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
@@ -216,6 +220,7 @@ public long open(DataSpec dataSpec) throws HttpDataSourceException {
   @Override
   public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
     try {
+      // HLS播放时拖放时如何解决的呢?
       skipInternal();
       return readInternal(buffer, offset, readLength);
     } catch (IOException e) {
diff --git a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index fb430a40a7..595a666024 100644
--- a/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -227,6 +227,9 @@ public void setPlayWhenReady(boolean playWhenReady) {
     handler.obtainMessage(MSG_SET_PLAY_WHEN_READY, playWhenReady ? 1 : 0, 0).sendToTarget();
   }
 
+  // seekTo操作如何执行呢?
+  //  可以seek到之前的某个位置，也可以seek到之后的某个位置；可能导致缓存失效
+  //
   public void seekTo(Timeline timeline, int windowIndex, long positionUs) {
     handler.obtainMessage(MSG_SEEK_TO, new SeekPosition(timeline, windowIndex, positionUs))
             .sendToTarget();
@@ -571,6 +574,7 @@ private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackExcepti
     }
 
     Pair<Integer, Long> periodPosition = resolveSeekPosition(seekPosition);
+
     if (periodPosition == null) {
       // The seek position was valid for the timeline that it was performed into, but the
       // timeline has changed and a suitable seek position could not be resolved in the new one.
