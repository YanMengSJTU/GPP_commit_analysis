diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
index 2840ae321d..802665d5bd 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.ext.okhttp;
 
 import android.net.Uri;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSourceException;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -23,6 +24,7 @@
 import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Predicate;
+
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -31,6 +33,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicReference;
+
 import okhttp3.CacheControl;
 import okhttp3.Call;
 import okhttp3.HttpUrl;
@@ -45,372 +48,372 @@
  */
 public class OkHttpDataSource implements HttpDataSource {
 
-  private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<>();
-
-  private final Call.Factory callFactory;
-  private final String userAgent;
-  private final Predicate<String> contentTypePredicate;
-  private final TransferListener<? super OkHttpDataSource> listener;
-  private final CacheControl cacheControl;
-  private final HashMap<String, String> requestProperties;
-
-  private DataSpec dataSpec;
-  private Response response;
-  private InputStream responseByteStream;
-  private boolean opened;
-
-  private long bytesToSkip;
-  private long bytesToRead;
-
-  private long bytesSkipped;
-  private long bytesRead;
-
-  /**
-   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
-   *     by the source.
-   * @param userAgent The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a InvalidContentTypeException} is thrown from {@link #open(DataSpec)}.
-   */
-  public OkHttpDataSource(Call.Factory callFactory, String userAgent,
-      Predicate<String> contentTypePredicate) {
-    this(callFactory, userAgent, contentTypePredicate, null);
-  }
-
-  /**
-   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
-   *     by the source.
-   * @param userAgent The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
-   */
-  public OkHttpDataSource(Call.Factory callFactory, String userAgent,
-      Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener) {
-    this(callFactory, userAgent, contentTypePredicate, listener, null);
-  }
-
-  /**
-   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
-   *     by the source.
-   * @param userAgent The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *     predicate then a {@link InvalidContentTypeException} is thrown from
-   *     {@link #open(DataSpec)}.
-   * @param listener An optional listener.
-   * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
-   */
-  public OkHttpDataSource(Call.Factory callFactory, String userAgent,
-      Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener,
-      CacheControl cacheControl) {
-
-    this.callFactory = Assertions.checkNotNull(callFactory);
-    this.userAgent = Assertions.checkNotEmpty(userAgent);
-    this.contentTypePredicate = contentTypePredicate;
-    this.listener = listener;
-    this.cacheControl = cacheControl;
-    this.requestProperties = new HashMap<>();
-  }
-
-  @Override
-  public Uri getUri() {
-    return response == null ? null : Uri.parse(response.request().url().toString());
-  }
-
-  @Override
-  public Map<String, List<String>> getResponseHeaders() {
-    return response == null ? null : response.headers().toMultimap();
-  }
-
-  @Override
-  public void setRequestProperty(String name, String value) {
-    Assertions.checkNotNull(name);
-    Assertions.checkNotNull(value);
-    synchronized (requestProperties) {
-      requestProperties.put(name, value);
+    private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<>();
+
+    private final Call.Factory callFactory;
+    private final String userAgent;
+    private final Predicate<String> contentTypePredicate;
+    private final TransferListener<? super OkHttpDataSource> listener;
+    private final CacheControl cacheControl;
+    private final HashMap<String, String> requestProperties;
+
+    private DataSpec dataSpec;
+    private Response response;
+    private InputStream responseByteStream;
+    private boolean opened;
+
+    private long bytesToSkip;
+    private long bytesToRead;
+
+    private long bytesSkipped;
+    private long bytesRead;
+
+    /**
+     * @param callFactory          A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+     *                             by the source.
+     * @param userAgent            The User-Agent string that should be used.
+     * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+     *                             predicate then a InvalidContentTypeException} is thrown from {@link #open(DataSpec)}.
+     */
+    public OkHttpDataSource(Call.Factory callFactory, String userAgent,
+                            Predicate<String> contentTypePredicate) {
+        this(callFactory, userAgent, contentTypePredicate, null);
     }
-  }
 
-  @Override
-  public void clearRequestProperty(String name) {
-    Assertions.checkNotNull(name);
-    synchronized (requestProperties) {
-      requestProperties.remove(name);
+    /**
+     * @param callFactory          A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+     *                             by the source.
+     * @param userAgent            The User-Agent string that should be used.
+     * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+     *                             predicate then a {@link InvalidContentTypeException} is thrown from
+     *                             {@link #open(DataSpec)}.
+     * @param listener             An optional listener.
+     */
+    public OkHttpDataSource(Call.Factory callFactory, String userAgent,
+                            Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener) {
+        this(callFactory, userAgent, contentTypePredicate, listener, null);
     }
-  }
 
-  @Override
-  public void clearAllRequestProperties() {
-    synchronized (requestProperties) {
-      requestProperties.clear();
+    /**
+     * @param callFactory          A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+     *                             by the source.
+     * @param userAgent            The User-Agent string that should be used.
+     * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+     *                             predicate then a {@link InvalidContentTypeException} is thrown from
+     *                             {@link #open(DataSpec)}.
+     * @param listener             An optional listener.
+     * @param cacheControl         An optional {@link CacheControl} for setting the Cache-Control header.
+     */
+    public OkHttpDataSource(Call.Factory callFactory, String userAgent,
+                            Predicate<String> contentTypePredicate, TransferListener<? super OkHttpDataSource> listener,
+                            CacheControl cacheControl) {
+
+        this.callFactory = Assertions.checkNotNull(callFactory);
+        this.userAgent = Assertions.checkNotEmpty(userAgent);
+        this.contentTypePredicate = contentTypePredicate;
+        this.listener = listener;
+        this.cacheControl = cacheControl;
+        this.requestProperties = new HashMap<>();
     }
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws HttpDataSourceException {
-
-    // DataSpec是否需要做一个限制
-    // 例如: 对于HLS我们就不支持Range下载？ 一般HLS文件比较小，而且一般也不在本地区分码率等，因此就一次搞定
-    this.dataSpec = dataSpec;
-    this.bytesRead = 0;
-    this.bytesSkipped = 0;
-
-    // 读取Cache
-
-    // 如何创建网络请求呢?
-    Request request = makeRequest(dataSpec);
 
-    try {
-      // 通过callFactory可以共享底部的Sesion, making http2.0可用
-      response = callFactory.newCall(request).execute();
-
-      responseByteStream = response.body().byteStream();
-    } catch (IOException e) {
-      throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-          dataSpec, HttpDataSourceException.TYPE_OPEN);
+    @Override
+    public Uri getUri() {
+        return response == null ? null : Uri.parse(response.request().url().toString());
     }
 
-    int responseCode = response.code();
-
-    // Check for a valid response code.
-    if (!response.isSuccessful()) {
-      Map<String, List<String>> headers = request.headers().toMultimap();
-      closeConnectionQuietly();
-      InvalidResponseCodeException exception = new InvalidResponseCodeException(responseCode, headers, dataSpec);
-      // range有问题
-      if (responseCode == 416) {
-        exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
-      }
-      throw exception;
+    @Override
+    public Map<String, List<String>> getResponseHeaders() {
+        return response == null ? null : response.headers().toMultimap();
     }
 
-    // Check for a valid content type.
-    MediaType mediaType = response.body().contentType();
-    String contentType = mediaType != null ? mediaType.toString() : null;
-    // ContentType格式是否OK？
-    if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
-      closeConnectionQuietly();
-      throw new InvalidContentTypeException(contentType, dataSpec);
+    @Override
+    public void setRequestProperty(String name, String value) {
+        Assertions.checkNotNull(name);
+        Assertions.checkNotNull(value);
+        synchronized (requestProperties) {
+            requestProperties.put(name, value);
+        }
     }
 
-    // If we requested a range starting from a non-zero position and received a 200 rather than a
-    // 206, then the server does not support partial requests. We'll need to manually skip to the
-    // requested position.
-    // 如何兼容responseCode?
-    bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
-
-    // Determine the length of the data to be read, after skipping.
-    if (dataSpec.length != C.LENGTH_UNSET) {
-      bytesToRead = dataSpec.length;
-    } else {
-      long contentLength = response.body().contentLength();
-      bytesToRead = contentLength != -1 ? (contentLength - bytesToSkip) : C.LENGTH_UNSET;
+    @Override
+    public void clearRequestProperty(String name) {
+        Assertions.checkNotNull(name);
+        synchronized (requestProperties) {
+            requestProperties.remove(name);
+        }
     }
 
-    opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
+    @Override
+    public void clearAllRequestProperties() {
+        synchronized (requestProperties) {
+            requestProperties.clear();
+        }
     }
 
-    // TODO：缓存数据
-    return bytesToRead;
-  }
-
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
-    try {
-      // HLS播放时拖放时如何解决的呢?
-      skipInternal();
-      return readInternal(buffer, offset, readLength);
-    } catch (IOException e) {
-      throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_READ);
-    }
-  }
-
-  @Override
-  public void close() throws HttpDataSourceException {
-    if (opened) {
-      opened = false;
-      if (listener != null) {
-        listener.onTransferEnd(this);
-      }
-      closeConnectionQuietly();
-    }
-  }
-
-  /**
-   * Returns the number of bytes that have been skipped since the most recent call to
-   * {@link #open(DataSpec)}.
-   *
-   * @return The number of bytes skipped.
-   */
-  protected final long bytesSkipped() {
-    return bytesSkipped;
-  }
-
-  /**
-   * Returns the number of bytes that have been read since the most recent call to
-   * {@link #open(DataSpec)}.
-   *
-   * @return The number of bytes read.
-   */
-  protected final long bytesRead() {
-    return bytesRead;
-  }
-
-  /**
-   * Returns the number of bytes that are still to be read for the current {@link DataSpec}.
-   * <p>
-   * If the total length of the data being read is known, then this length minus {@code bytesRead()}
-   * is returned. If the total length is unknown, {@link C#LENGTH_UNSET} is returned.
-   *
-   * @return The remaining length, or {@link C#LENGTH_UNSET}.
-   */
-  protected final long bytesRemaining() {
-    return bytesToRead == C.LENGTH_UNSET ? bytesToRead : bytesToRead - bytesRead;
-  }
-
-  /**
-   * Establishes a connection.
-   */
-  private Request makeRequest(DataSpec dataSpec) {
-    // 1. 如何创建Request呢?
-    long position = dataSpec.position;
-    long length = dataSpec.length;
-    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
-
-    HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
-    Request.Builder builder = new Request.Builder().url(url);
-
-    // 2. 缓存控制?
-    if (cacheControl != null) {
-      builder.cacheControl(cacheControl);
+    @Override
+    public long open(DataSpec dataSpec) throws HttpDataSourceException {
+
+        // DataSpec是否需要做一个限制
+        // 例如: 对于HLS我们就不支持Range下载？ 一般HLS文件比较小，而且一般也不在本地区分码率等，因此就一次搞定
+        this.dataSpec = dataSpec;
+        this.bytesRead = 0;
+        this.bytesSkipped = 0;
+
+        // 读取Cache
+
+        // 如何创建网络请求呢?
+        Request request = makeRequest(dataSpec);
+
+        try {
+            // 通过callFactory可以共享底部的Sesion, making http2.0可用
+            response = callFactory.newCall(request).execute();
+
+            responseByteStream = response.body().byteStream();
+        } catch (IOException e) {
+            throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
+                    dataSpec, HttpDataSourceException.TYPE_OPEN);
+        }
+
+        int responseCode = response.code();
+
+        // Check for a valid response code.
+        if (!response.isSuccessful()) {
+            Map<String, List<String>> headers = request.headers().toMultimap();
+            closeConnectionQuietly();
+            InvalidResponseCodeException exception = new InvalidResponseCodeException(responseCode, headers, dataSpec);
+            // range有问题
+            if (responseCode == 416) {
+                exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
+            }
+            throw exception;
+        }
+
+        // Check for a valid content type.
+        MediaType mediaType = response.body().contentType();
+        String contentType = mediaType != null ? mediaType.toString() : null;
+        // ContentType格式是否OK？
+        if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
+            closeConnectionQuietly();
+            throw new InvalidContentTypeException(contentType, dataSpec);
+        }
+
+        // If we requested a range starting from a non-zero position and received a 200 rather than a
+        // 206, then the server does not support partial requests. We'll need to manually skip to the
+        // requested position.
+        // 如何兼容responseCode?
+        bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
+
+        // Determine the length of the data to be read, after skipping.
+        if (dataSpec.length != C.LENGTH_UNSET) {
+            bytesToRead = dataSpec.length;
+        } else {
+            long contentLength = response.body().contentLength();
+            bytesToRead = contentLength != -1 ? (contentLength - bytesToSkip) : C.LENGTH_UNSET;
+        }
+
+        opened = true;
+        if (listener != null) {
+            listener.onTransferStart(this, dataSpec);
+        }
+
+        // TODO：缓存数据
+        return bytesToRead;
     }
 
-    // 3. 添加Http Header
-    synchronized (requestProperties) {
-      for (Map.Entry<String, String> property : requestProperties.entrySet()) {
-        builder.addHeader(property.getKey(), property.getValue());
-      }
+    @Override
+    public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
+        try {
+            // HLS播放时拖放时如何解决的呢?
+            skipInternal();
+            return readInternal(buffer, offset, readLength);
+        } catch (IOException e) {
+            throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_READ);
+        }
     }
 
-    // 4. position & range request
-    if (!(position == 0 && length == C.LENGTH_UNSET)) {
-      String rangeRequest = "bytes=" + position + "-";
-      if (length != C.LENGTH_UNSET) {
-        rangeRequest += (position + length - 1);
-      }
-      builder.addHeader("Range", rangeRequest);
+    @Override
+    public void close() throws HttpDataSourceException {
+        if (opened) {
+            opened = false;
+            if (listener != null) {
+                listener.onTransferEnd(this);
+            }
+            closeConnectionQuietly();
+        }
     }
 
-    // 5. 设置User-Agent等参数
-    //    gzip的控制
-    builder.addHeader("User-Agent", userAgent);
-    if (!allowGzip) {
-      builder.addHeader("Accept-Encoding", "identity");
-    }
-    if (dataSpec.postBody != null) {
-      builder.post(RequestBody.create(null, dataSpec.postBody));
-    }
-    return builder.build();
-  }
-
-  /**
-   * Skips any bytes that need skipping. Else does nothing.
-   * <p>
-   * This implementation is based roughly on {@code libcore.io.Streams.skipByReading()}.
-   *
-   * @throws InterruptedIOException If the thread is interrupted during the operation.
-   * @throws EOFException If the end of the input stream is reached before the bytes are skipped.
-   */
-  private void skipInternal() throws IOException {
-    if (bytesSkipped == bytesToSkip) {
-      return;
+    /**
+     * Returns the number of bytes that have been skipped since the most recent call to
+     * {@link #open(DataSpec)}.
+     *
+     * @return The number of bytes skipped.
+     */
+    protected final long bytesSkipped() {
+        return bytesSkipped;
     }
 
-    // Acquire the shared skip buffer.
-    byte[] skipBuffer = skipBufferReference.getAndSet(null);
-    if (skipBuffer == null) {
-      skipBuffer = new byte[4096];
+    /**
+     * Returns the number of bytes that have been read since the most recent call to
+     * {@link #open(DataSpec)}.
+     *
+     * @return The number of bytes read.
+     */
+    protected final long bytesRead() {
+        return bytesRead;
     }
 
-    // 跳过: bytesToSkip
-    while (bytesSkipped != bytesToSkip) {
-      int readLength = (int) Math.min(bytesToSkip - bytesSkipped, skipBuffer.length);
-      int read = responseByteStream.read(skipBuffer, 0, readLength);
-      if (Thread.interrupted()) {
-        throw new InterruptedIOException();
-      }
-      if (read == -1) {
-        throw new EOFException();
-      }
-      bytesSkipped += read;
-      if (listener != null) {
-        listener.onBytesTransferred(this, read);
-      }
+    /**
+     * Returns the number of bytes that are still to be read for the current {@link DataSpec}.
+     * <p>
+     * If the total length of the data being read is known, then this length minus {@code bytesRead()}
+     * is returned. If the total length is unknown, {@link C#LENGTH_UNSET} is returned.
+     *
+     * @return The remaining length, or {@link C#LENGTH_UNSET}.
+     */
+    protected final long bytesRemaining() {
+        return bytesToRead == C.LENGTH_UNSET ? bytesToRead : bytesToRead - bytesRead;
     }
 
-    // Release the shared skip buffer.
-    skipBufferReference.set(skipBuffer);
-  }
-
-  /**
-   * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
-   * index {@code offset}.
-   * <p>
-   * This method blocks until at least one byte of data can be read, the end of the opened range is
-   * detected, or an exception is thrown.
-   *
-   * @param buffer The buffer into which the read data should be stored.
-   * @param offset The start offset into {@code buffer} at which data should be written.
-   * @param readLength The maximum number of bytes to read.
-   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
-   *     range is reached.
-   * @throws IOException If an error occurs reading from the source.
-   */
-  private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
-    if (readLength == 0) {
-      return 0;
+    /**
+     * Establishes a connection.
+     */
+    private Request makeRequest(DataSpec dataSpec) {
+        // 1. 如何创建Request呢?
+        long position = dataSpec.position;
+        long length = dataSpec.length;
+        boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+
+        HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());
+        Request.Builder builder = new Request.Builder().url(url);
+
+        // 2. 缓存控制?
+        if (cacheControl != null) {
+            builder.cacheControl(cacheControl);
+        }
+
+        // 3. 添加Http Header
+        synchronized (requestProperties) {
+            for (Map.Entry<String, String> property : requestProperties.entrySet()) {
+                builder.addHeader(property.getKey(), property.getValue());
+            }
+        }
+
+        // 4. position & range request
+        if (!(position == 0 && length == C.LENGTH_UNSET)) {
+            String rangeRequest = "bytes=" + position + "-";
+            if (length != C.LENGTH_UNSET) {
+                rangeRequest += (position + length - 1);
+            }
+            builder.addHeader("Range", rangeRequest);
+        }
+
+        // 5. 设置User-Agent等参数
+        //    gzip的控制
+        builder.addHeader("User-Agent", userAgent);
+        if (!allowGzip) {
+            builder.addHeader("Accept-Encoding", "identity");
+        }
+        if (dataSpec.postBody != null) {
+            builder.post(RequestBody.create(null, dataSpec.postBody));
+        }
+        return builder.build();
     }
 
-    // 处理不同的Stream
-    // 有些Stream是有结束标志的；
-    // 有些Stream，例如: 直播，是没有结束标志的
-    if (bytesToRead != C.LENGTH_UNSET) {
-      long bytesRemaining = bytesToRead - bytesRead;
-      if (bytesRemaining == 0) {
-        return C.RESULT_END_OF_INPUT;
-      }
-      readLength = (int) Math.min(readLength, bytesRemaining);
+    /**
+     * Skips any bytes that need skipping. Else does nothing.
+     * <p>
+     * This implementation is based roughly on {@code libcore.io.Streams.skipByReading()}.
+     *
+     * @throws InterruptedIOException If the thread is interrupted during the operation.
+     * @throws EOFException           If the end of the input stream is reached before the bytes are skipped.
+     */
+    private void skipInternal() throws IOException {
+        if (bytesSkipped == bytesToSkip) {
+            return;
+        }
+
+        // Acquire the shared skip buffer.
+        byte[] skipBuffer = skipBufferReference.getAndSet(null);
+        if (skipBuffer == null) {
+            skipBuffer = new byte[4096];
+        }
+
+        // 跳过: bytesToSkip
+        while (bytesSkipped != bytesToSkip) {
+            int readLength = (int) Math.min(bytesToSkip - bytesSkipped, skipBuffer.length);
+            int read = responseByteStream.read(skipBuffer, 0, readLength);
+            if (Thread.interrupted()) {
+                throw new InterruptedIOException();
+            }
+            if (read == -1) {
+                throw new EOFException();
+            }
+            bytesSkipped += read;
+            if (listener != null) {
+                listener.onBytesTransferred(this, read);
+            }
+        }
+
+        // Release the shared skip buffer.
+        skipBufferReference.set(skipBuffer);
     }
 
-    int read = responseByteStream.read(buffer, offset, readLength);
-
-    // 出错？
-    // 直播可以直接返回-1
-    if (read == -1) {
-      if (bytesToRead != C.LENGTH_UNSET) {
-        // End of stream reached having not read sufficient data.
-        throw new EOFException();
-      }
-      return C.RESULT_END_OF_INPUT;
+    /**
+     * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
+     * index {@code offset}.
+     * <p>
+     * This method blocks until at least one byte of data can be read, the end of the opened range is
+     * detected, or an exception is thrown.
+     *
+     * @param buffer     The buffer into which the read data should be stored.
+     * @param offset     The start offset into {@code buffer} at which data should be written.
+     * @param readLength The maximum number of bytes to read.
+     * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
+     * range is reached.
+     * @throws IOException If an error occurs reading from the source.
+     */
+    private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
+        if (readLength == 0) {
+            return 0;
+        }
+
+        // 处理不同的Stream
+        // 有些Stream是有结束标志的；
+        // 有些Stream，例如: 直播，是没有结束标志的
+        if (bytesToRead != C.LENGTH_UNSET) {
+            long bytesRemaining = bytesToRead - bytesRead;
+            if (bytesRemaining == 0) {
+                return C.RESULT_END_OF_INPUT;
+            }
+            readLength = (int) Math.min(readLength, bytesRemaining);
+        }
+
+        int read = responseByteStream.read(buffer, offset, readLength);
+
+        // 出错？
+        // 直播可以直接返回-1
+        if (read == -1) {
+            if (bytesToRead != C.LENGTH_UNSET) {
+                // End of stream reached having not read sufficient data.
+                throw new EOFException();
+            }
+            return C.RESULT_END_OF_INPUT;
+        }
+
+        bytesRead += read;
+        if (listener != null) {
+            listener.onBytesTransferred(this, read);
+        }
+        return read;
     }
 
-    bytesRead += read;
-    if (listener != null) {
-      listener.onBytesTransferred(this, read);
+    /**
+     * Closes the current connection quietly, if there is one.
+     */
+    private void closeConnectionQuietly() {
+        response.body().close();
+        response = null;
+        responseByteStream = null;
     }
-    return read;
-  }
-
-  /**
-   * Closes the current connection quietly, if there is one.
-   */
-  private void closeConnectionQuietly() {
-    response.body().close();
-    response = null;
-    responseByteStream = null;
-  }
 
 }
diff --git a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
index 86525be0b0..ac261f0ab0 100644
--- a/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
+++ b/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource.Factory;
 import com.google.android.exoplayer2.upstream.TransferListener;
+
 import okhttp3.CacheControl;
 import okhttp3.Call;
 
@@ -27,41 +28,41 @@
  */
 public final class OkHttpDataSourceFactory implements Factory {
 
-  private final Call.Factory callFactory;
-  private final String userAgent;
-  private final TransferListener<? super DataSource> listener;
-  private final CacheControl cacheControl;
+    private final Call.Factory callFactory;
+    private final String userAgent;
+    private final TransferListener<? super DataSource> listener;
+    private final CacheControl cacheControl;
 
-  /**
-   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
-   *     by the sources created by the factory.
-   * @param userAgent The User-Agent string that should be used.
-   * @param listener An optional listener.
-   */
-  public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
-      TransferListener<? super DataSource> listener) {
-    this(callFactory, userAgent, listener, null);
-  }
+    /**
+     * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+     *                    by the sources created by the factory.
+     * @param userAgent   The User-Agent string that should be used.
+     * @param listener    An optional listener.
+     */
+    public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
+                                   TransferListener<? super DataSource> listener) {
+        this(callFactory, userAgent, listener, null);
+    }
 
-  /**
-   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
-   *     by the sources created by the factory.
-   * @param userAgent The User-Agent string that should be used.
-   * @param listener An optional listener.
-   * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
-   */
-  public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
-      TransferListener<? super DataSource> listener, CacheControl cacheControl) {
-    this.callFactory = callFactory;
-    this.userAgent = userAgent;
-    this.listener = listener;
-    this.cacheControl = cacheControl;
-  }
+    /**
+     * @param callFactory  A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use
+     *                     by the sources created by the factory.
+     * @param userAgent    The User-Agent string that should be used.
+     * @param listener     An optional listener.
+     * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.
+     */
+    public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
+                                   TransferListener<? super DataSource> listener, CacheControl cacheControl) {
+        this.callFactory = callFactory;
+        this.userAgent = userAgent;
+        this.listener = listener;
+        this.cacheControl = cacheControl;
+    }
 
-  @Override
-  public OkHttpDataSource createDataSource() {
-    // 创建OKHttpDataSource
-    return new OkHttpDataSource(callFactory, userAgent, null, listener, cacheControl);
-  }
+    @Override
+    public OkHttpDataSource createDataSource() {
+        // 创建OKHttpDataSource
+        return new OkHttpDataSource(callFactory, userAgent, null, listener, cacheControl);
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java b/library/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java
index 21bdddf9b8..d293d1eb27 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/BandwidthMeter.java
@@ -20,35 +20,35 @@
  */
 public interface BandwidthMeter {
 
-  /**
-   * A listener of {@link BandwidthMeter} events.
-   */
-  interface EventListener {
-
     /**
-     * Called periodically to indicate that bytes have been transferred.
-     * <p>
-     * Note: The estimated bitrate is typically derived from more information than just
-     * {@code bytes} and {@code elapsedMs}.
-     *
-     * @param elapsedMs The time taken to transfer the bytes, in milliseconds.
-     * @param bytes The number of bytes transferred.
-     * @param bitrate The estimated bitrate in bits/sec, or {@link #NO_ESTIMATE} if an estimate is
-     *     not available.
+     * A listener of {@link BandwidthMeter} events.
      */
-    void onBandwidthSample(int elapsedMs, long bytes, long bitrate);
+    interface EventListener {
+
+        /**
+         * Called periodically to indicate that bytes have been transferred.
+         * <p>
+         * Note: The estimated bitrate is typically derived from more information than just
+         * {@code bytes} and {@code elapsedMs}.
+         *
+         * @param elapsedMs The time taken to transfer the bytes, in milliseconds.
+         * @param bytes     The number of bytes transferred.
+         * @param bitrate   The estimated bitrate in bits/sec, or {@link #NO_ESTIMATE} if an estimate is
+         *                  not available.
+         */
+        void onBandwidthSample(int elapsedMs, long bytes, long bitrate);
 
-  }
+    }
 
-  /**
-   * Indicates no bandwidth estimate is available.
-   */
-  long NO_ESTIMATE = -1;
+    /**
+     * Indicates no bandwidth estimate is available.
+     */
+    long NO_ESTIMATE = -1;
 
-  /**
-   * Returns the estimated bandwidth in bits/sec, or {@link #NO_ESTIMATE} if an estimate is not
-   * available.
-   */
-  long getBitrateEstimate();
+    /**
+     * Returns the estimated bandwidth in bits/sec, or {@link #NO_ESTIMATE} if an estimate is not
+     * available.
+     */
+    long getBitrateEstimate();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
index 417d633aeb..dc9ea2b5bf 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultBandwidthMeter.java
@@ -29,113 +29,113 @@
  */
 public final class DefaultBandwidthMeter implements BandwidthMeter, TransferListener<Object> {
 
-  /**
-   * The default maximum weight for the sliding window.
-   */
-  public static final int DEFAULT_MAX_WEIGHT = 2000;
-
-  // 至少下载了: 2000ms，也即是2s；或者512k数据才能有一个稳定的带宽估计，这个2s时间也不短；
-  // 因此一个默认的variant的选择也很重要
-  private static final int ELAPSED_MILLIS_FOR_ESTIMATE = 2000;
-  private static final int BYTES_TRANSFERRED_FOR_ESTIMATE = 512 * 1024;
-
-  private final Handler eventHandler;
-  private final EventListener eventListener;
-  private final SlidingPercentile slidingPercentile;
-
-  private int streamCount;
-  private long sampleStartTimeMs;
-  private long sampleBytesTransferred;
-
-  private long totalElapsedTimeMs;
-  private long totalBytesTransferred;
-  private long bitrateEstimate;
-
-  public DefaultBandwidthMeter() {
-    this(null, null);
-  }
-
-  public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener) {
-    this(eventHandler, eventListener, DEFAULT_MAX_WEIGHT);
-  }
-
-  public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener, int maxWeight) {
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
-    this.slidingPercentile = new SlidingPercentile(maxWeight);
-
-    // 如何做"带宽"估计呢?
-    bitrateEstimate = NO_ESTIMATE;
-  }
-
-  @Override
-  public synchronized long getBitrateEstimate() {
-    return bitrateEstimate;
-  }
-
-  @Override
-  public synchronized void onTransferStart(Object source, DataSpec dataSpec) {
-    if (streamCount == 0) {
-      sampleStartTimeMs = SystemClock.elapsedRealtime();
+    /**
+     * The default maximum weight for the sliding window.
+     */
+    public static final int DEFAULT_MAX_WEIGHT = 2000;
+
+    // 至少下载了: 2000ms，也即是2s；或者512k数据才能有一个稳定的带宽估计，这个2s时间也不短；
+    // 因此一个默认的variant的选择也很重要
+    private static final int ELAPSED_MILLIS_FOR_ESTIMATE = 2000;
+    private static final int BYTES_TRANSFERRED_FOR_ESTIMATE = 512 * 1024;
+
+    private final Handler eventHandler;
+    private final EventListener eventListener;
+    private final SlidingPercentile slidingPercentile;
+
+    private int streamCount;
+    private long sampleStartTimeMs;
+    private long sampleBytesTransferred;
+
+    private long totalElapsedTimeMs;
+    private long totalBytesTransferred;
+    private long bitrateEstimate;
+
+    public DefaultBandwidthMeter() {
+        this(null, null);
     }
-    streamCount++;
-  }
-
-  @Override
-  public synchronized void onBytesTransferred(Object source, int bytes) {
-    sampleBytesTransferred += bytes;
-  }
-
-  @Override
-  public synchronized void onTransferEnd(Object source) {
-    Assertions.checkState(streamCount > 0);
-
-    // 统计传输时间 + 传输数据流（字节)
-    long nowMs = SystemClock.elapsedRealtime();
-    int sampleElapsedTimeMs = (int) (nowMs - sampleStartTimeMs);
-    totalElapsedTimeMs += sampleElapsedTimeMs;
-    totalBytesTransferred += sampleBytesTransferred;
-
-    // onTransferStart
-    // onBytesTransferred
-    // onTransferEnd
-    // 再怎么招，都不能再一个ts下载过程中切换variants
-    //
-    if (sampleElapsedTimeMs > 0) {
-      // 带宽单位: bit/s
-      float bitsPerSecond = (sampleBytesTransferred * 8000) / sampleElapsedTimeMs;
-
-      // 添加sample?
-      slidingPercentile.addSample((int) Math.sqrt(sampleBytesTransferred), bitsPerSecond);
-
-      if (totalElapsedTimeMs >= ELAPSED_MILLIS_FOR_ESTIMATE || totalBytesTransferred >= BYTES_TRANSFERRED_FOR_ESTIMATE) {
-        float bitrateEstimateFloat = slidingPercentile.getPercentile(0.5f);
-
-        bitrateEstimate = Float.isNaN(bitrateEstimateFloat) ? NO_ESTIMATE : (long) bitrateEstimateFloat;
-      }
+
+    public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener) {
+        this(eventHandler, eventListener, DEFAULT_MAX_WEIGHT);
+    }
+
+    public DefaultBandwidthMeter(Handler eventHandler, EventListener eventListener, int maxWeight) {
+        this.eventHandler = eventHandler;
+        this.eventListener = eventListener;
+        this.slidingPercentile = new SlidingPercentile(maxWeight);
+
+        // 如何做"带宽"估计呢?
+        bitrateEstimate = NO_ESTIMATE;
     }
 
-    // 通知"带宽"变化
-    // 可能我们也需要有一个Debug信息
-    notifyBandwidthSample(sampleElapsedTimeMs, sampleBytesTransferred, bitrateEstimate);
+    @Override
+    public synchronized long getBitrateEstimate() {
+        return bitrateEstimate;
+    }
+
+    @Override
+    public synchronized void onTransferStart(Object source, DataSpec dataSpec) {
+        if (streamCount == 0) {
+            sampleStartTimeMs = SystemClock.elapsedRealtime();
+        }
+        streamCount++;
+    }
 
-    // 开始一个新的阶段，例如: 以前有N个stream, 现在只有N-1个Stream
-    if (--streamCount > 0) {
-      sampleStartTimeMs = nowMs;
+    @Override
+    public synchronized void onBytesTransferred(Object source, int bytes) {
+        sampleBytesTransferred += bytes;
     }
-    sampleBytesTransferred = 0;
-  }
-
-  private void notifyBandwidthSample(final int elapsedMs, final long bytes, final long bitrate) {
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          // 带宽变化了，如何处理呢?
-          eventListener.onBandwidthSample(elapsedMs, bytes, bitrate);
+
+    @Override
+    public synchronized void onTransferEnd(Object source) {
+        Assertions.checkState(streamCount > 0);
+
+        // 统计传输时间 + 传输数据流（字节)
+        long nowMs = SystemClock.elapsedRealtime();
+        int sampleElapsedTimeMs = (int) (nowMs - sampleStartTimeMs);
+        totalElapsedTimeMs += sampleElapsedTimeMs;
+        totalBytesTransferred += sampleBytesTransferred;
+
+        // onTransferStart
+        // onBytesTransferred
+        // onTransferEnd
+        // 再怎么招，都不能再一个ts下载过程中切换variants
+        //
+        if (sampleElapsedTimeMs > 0) {
+            // 带宽单位: bit/s
+            float bitsPerSecond = (sampleBytesTransferred * 8000) / sampleElapsedTimeMs;
+
+            // 添加sample?
+            slidingPercentile.addSample((int) Math.sqrt(sampleBytesTransferred), bitsPerSecond);
+
+            if (totalElapsedTimeMs >= ELAPSED_MILLIS_FOR_ESTIMATE || totalBytesTransferred >= BYTES_TRANSFERRED_FOR_ESTIMATE) {
+                float bitrateEstimateFloat = slidingPercentile.getPercentile(0.5f);
+
+                bitrateEstimate = Float.isNaN(bitrateEstimateFloat) ? NO_ESTIMATE : (long) bitrateEstimateFloat;
+            }
+        }
+
+        // 通知"带宽"变化
+        // 可能我们也需要有一个Debug信息
+        notifyBandwidthSample(sampleElapsedTimeMs, sampleBytesTransferred, bitrateEstimate);
+
+        // 开始一个新的阶段，例如: 以前有N个stream, 现在只有N-1个Stream
+        if (--streamCount > 0) {
+            sampleStartTimeMs = nowMs;
+        }
+        sampleBytesTransferred = 0;
+    }
+
+    private void notifyBandwidthSample(final int elapsedMs, final long bytes, final long bitrate) {
+        if (eventHandler != null && eventListener != null) {
+            eventHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    // 带宽变化了，如何处理呢?
+                    eventListener.onBandwidthSample(elapsedMs, bytes, bitrate);
+                }
+            });
         }
-      });
     }
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
index ee37fb1d18..b43385414d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/upstream/DefaultHttpDataSource.java
@@ -51,613 +51,613 @@
  */
 public class DefaultHttpDataSource implements HttpDataSource {
 
-  /**
-   * The default connection timeout, in milliseconds.
-   */
-  public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 8 * 1000;
-  /**
-   * The default read timeout, in milliseconds.
-   */
-  public static final int DEFAULT_READ_TIMEOUT_MILLIS = 8 * 1000;
-
-  private static final String TAG = "DefaultHttpDataSource";
-  private static final int MAX_REDIRECTS = 20; // Same limit as okhttp.
-  private static final long MAX_BYTES_TO_DRAIN = 2048;
-  private static final Pattern CONTENT_RANGE_HEADER =
-          Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
-  private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<>();
-
-  private final boolean allowCrossProtocolRedirects;
-  private final int connectTimeoutMillis;
-  private final int readTimeoutMillis;
-  private final String userAgent;
-  private final Predicate<String> contentTypePredicate;
-  private final HashMap<String, String> requestProperties;
-  private final TransferListener<? super DefaultHttpDataSource> listener;
-
-  private DataSpec dataSpec;
-  private HttpURLConnection connection;
-  private InputStream inputStream;
-  private boolean opened;
-
-  private long bytesToSkip;
-  private long bytesToRead;
-
-  private long bytesSkipped;
-  private long bytesRead;
-
-  /**
-   * @param userAgent            The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *                             predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *                             {@link #open(DataSpec)}.
-   */
-  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate) {
-    this(userAgent, contentTypePredicate, null);
-  }
-
-  /**
-   * @param userAgent            The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *                             predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *                             {@link #open(DataSpec)}.
-   * @param listener             An optional listener.
-   */
-  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-                               TransferListener<? super DefaultHttpDataSource> listener) {
-    this(userAgent, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
-            DEFAULT_READ_TIMEOUT_MILLIS);
-  }
-
-  /**
-   * @param userAgent            The User-Agent string that should be used.
-   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
-   *                             predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *                             {@link #open(DataSpec)}.
-   * @param listener             An optional listener.
-   * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
-   *                             interpreted as an infinite timeout.
-   * @param readTimeoutMillis    The read timeout, in milliseconds. A timeout of zero is interpreted
-   *                             as an infinite timeout.
-   */
-  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-                               TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
-                               int readTimeoutMillis) {
-    this(userAgent, contentTypePredicate, listener, connectTimeoutMillis, readTimeoutMillis, false);
-  }
-
-  /**
-   * @param userAgent                   The User-Agent string that should be used.
-   * @param contentTypePredicate        An optional {@link Predicate}. If a content type is rejected by the
-   *                                    predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
-   *                                    {@link #open(DataSpec)}.
-   * @param listener                    An optional listener.
-   * @param connectTimeoutMillis        The connection timeout, in milliseconds. A timeout of zero is
-   *                                    interpreted as an infinite timeout. Pass {@link #DEFAULT_CONNECT_TIMEOUT_MILLIS} to use
-   *                                    the default value.
-   * @param readTimeoutMillis           The read timeout, in milliseconds. A timeout of zero is interpreted
-   *                                    as an infinite timeout. Pass {@link #DEFAULT_READ_TIMEOUT_MILLIS} to use the default value.
-   * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
-   *                                    to HTTPS and vice versa) are enabled.
-   */
-  public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
-                               TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
-                               int readTimeoutMillis, boolean allowCrossProtocolRedirects) {
-    this.userAgent = Assertions.checkNotEmpty(userAgent);
-    this.contentTypePredicate = contentTypePredicate;
-    this.listener = listener;
-    this.requestProperties = new HashMap<>();
-    this.connectTimeoutMillis = connectTimeoutMillis;
-    this.readTimeoutMillis = readTimeoutMillis;
-    this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;
-  }
-
-  @Override
-  public Uri getUri() {
-    return connection == null ? null : Uri.parse(connection.getURL().toString());
-  }
-
-  @Override
-  public Map<String, List<String>> getResponseHeaders() {
-    return connection == null ? null : connection.getHeaderFields();
-  }
-
-  @Override
-  public void setRequestProperty(String name, String value) {
-    Assertions.checkNotNull(name);
-    Assertions.checkNotNull(value);
-    synchronized (requestProperties) {
-      requestProperties.put(name, value);
+    /**
+     * The default connection timeout, in milliseconds.
+     */
+    public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 8 * 1000;
+    /**
+     * The default read timeout, in milliseconds.
+     */
+    public static final int DEFAULT_READ_TIMEOUT_MILLIS = 8 * 1000;
+
+    private static final String TAG = "DefaultHttpDataSource";
+    private static final int MAX_REDIRECTS = 20; // Same limit as okhttp.
+    private static final long MAX_BYTES_TO_DRAIN = 2048;
+    private static final Pattern CONTENT_RANGE_HEADER =
+            Pattern.compile("^bytes (\\d+)-(\\d+)/(\\d+)$");
+    private static final AtomicReference<byte[]> skipBufferReference = new AtomicReference<>();
+
+    private final boolean allowCrossProtocolRedirects;
+    private final int connectTimeoutMillis;
+    private final int readTimeoutMillis;
+    private final String userAgent;
+    private final Predicate<String> contentTypePredicate;
+    private final HashMap<String, String> requestProperties;
+    private final TransferListener<? super DefaultHttpDataSource> listener;
+
+    private DataSpec dataSpec;
+    private HttpURLConnection connection;
+    private InputStream inputStream;
+    private boolean opened;
+
+    private long bytesToSkip;
+    private long bytesToRead;
+
+    private long bytesSkipped;
+    private long bytesRead;
+
+    /**
+     * @param userAgent            The User-Agent string that should be used.
+     * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+     *                             predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
+     *                             {@link #open(DataSpec)}.
+     */
+    public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate) {
+        this(userAgent, contentTypePredicate, null);
+    }
+
+    /**
+     * @param userAgent            The User-Agent string that should be used.
+     * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+     *                             predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
+     *                             {@link #open(DataSpec)}.
+     * @param listener             An optional listener.
+     */
+    public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
+                                 TransferListener<? super DefaultHttpDataSource> listener) {
+        this(userAgent, contentTypePredicate, listener, DEFAULT_CONNECT_TIMEOUT_MILLIS,
+                DEFAULT_READ_TIMEOUT_MILLIS);
+    }
+
+    /**
+     * @param userAgent            The User-Agent string that should be used.
+     * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the
+     *                             predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
+     *                             {@link #open(DataSpec)}.
+     * @param listener             An optional listener.
+     * @param connectTimeoutMillis The connection timeout, in milliseconds. A timeout of zero is
+     *                             interpreted as an infinite timeout.
+     * @param readTimeoutMillis    The read timeout, in milliseconds. A timeout of zero is interpreted
+     *                             as an infinite timeout.
+     */
+    public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
+                                 TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
+                                 int readTimeoutMillis) {
+        this(userAgent, contentTypePredicate, listener, connectTimeoutMillis, readTimeoutMillis, false);
+    }
+
+    /**
+     * @param userAgent                   The User-Agent string that should be used.
+     * @param contentTypePredicate        An optional {@link Predicate}. If a content type is rejected by the
+     *                                    predicate then a {@link HttpDataSource.InvalidContentTypeException} is thrown from
+     *                                    {@link #open(DataSpec)}.
+     * @param listener                    An optional listener.
+     * @param connectTimeoutMillis        The connection timeout, in milliseconds. A timeout of zero is
+     *                                    interpreted as an infinite timeout. Pass {@link #DEFAULT_CONNECT_TIMEOUT_MILLIS} to use
+     *                                    the default value.
+     * @param readTimeoutMillis           The read timeout, in milliseconds. A timeout of zero is interpreted
+     *                                    as an infinite timeout. Pass {@link #DEFAULT_READ_TIMEOUT_MILLIS} to use the default value.
+     * @param allowCrossProtocolRedirects Whether cross-protocol redirects (i.e. redirects from HTTP
+     *                                    to HTTPS and vice versa) are enabled.
+     */
+    public DefaultHttpDataSource(String userAgent, Predicate<String> contentTypePredicate,
+                                 TransferListener<? super DefaultHttpDataSource> listener, int connectTimeoutMillis,
+                                 int readTimeoutMillis, boolean allowCrossProtocolRedirects) {
+        this.userAgent = Assertions.checkNotEmpty(userAgent);
+        this.contentTypePredicate = contentTypePredicate;
+        this.listener = listener;
+        this.requestProperties = new HashMap<>();
+        this.connectTimeoutMillis = connectTimeoutMillis;
+        this.readTimeoutMillis = readTimeoutMillis;
+        this.allowCrossProtocolRedirects = allowCrossProtocolRedirects;
+    }
+
+    @Override
+    public Uri getUri() {
+        return connection == null ? null : Uri.parse(connection.getURL().toString());
+    }
+
+    @Override
+    public Map<String, List<String>> getResponseHeaders() {
+        return connection == null ? null : connection.getHeaderFields();
+    }
+
+    @Override
+    public void setRequestProperty(String name, String value) {
+        Assertions.checkNotNull(name);
+        Assertions.checkNotNull(value);
+        synchronized (requestProperties) {
+            requestProperties.put(name, value);
+        }
     }
-  }
 
-  @Override
-  public void clearRequestProperty(String name) {
-    Assertions.checkNotNull(name);
-    synchronized (requestProperties) {
-      requestProperties.remove(name);
+    @Override
+    public void clearRequestProperty(String name) {
+        Assertions.checkNotNull(name);
+        synchronized (requestProperties) {
+            requestProperties.remove(name);
+        }
     }
-  }
 
-  @Override
-  public void clearAllRequestProperties() {
-    synchronized (requestProperties) {
-      requestProperties.clear();
-    }
-  }
-
-  @Override
-  public long open(DataSpec dataSpec) throws HttpDataSourceException {
-    this.dataSpec = dataSpec;
-    this.bytesRead = 0;
-    this.bytesSkipped = 0;
-
-    // 每次创建一个新的连接
-    // Http2.0 vs. Non-2.0
-    // 是否能服用Connection
-    try {
-      connection = makeConnection(dataSpec);
-    } catch (IOException e) {
-      throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-              dataSpec, HttpDataSourceException.TYPE_OPEN);
+    @Override
+    public void clearAllRequestProperties() {
+        synchronized (requestProperties) {
+            requestProperties.clear();
+        }
     }
 
-    int responseCode;
-    try {
-      responseCode = connection.getResponseCode();
-    } catch (IOException e) {
-      closeConnectionQuietly();
-      throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
-              dataSpec, HttpDataSourceException.TYPE_OPEN);
-    }
+    @Override
+    public long open(DataSpec dataSpec) throws HttpDataSourceException {
+        this.dataSpec = dataSpec;
+        this.bytesRead = 0;
+        this.bytesSkipped = 0;
 
-    // Check for a valid response code.
-    if (responseCode < 200 || responseCode > 299) {
-      Map<String, List<String>> headers = connection.getHeaderFields();
-      closeConnectionQuietly();
-      InvalidResponseCodeException exception =
-              new InvalidResponseCodeException(responseCode, headers, dataSpec);
-      if (responseCode == 416) {
-        exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
-      }
-      throw exception;
-    }
+        // 每次创建一个新的连接
+        // Http2.0 vs. Non-2.0
+        // 是否能服用Connection
+        try {
+            connection = makeConnection(dataSpec);
+        } catch (IOException e) {
+            throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
+                    dataSpec, HttpDataSourceException.TYPE_OPEN);
+        }
 
-    // Check for a valid content type.
-    String contentType = connection.getContentType();
-    if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
-      closeConnectionQuietly();
-      throw new InvalidContentTypeException(contentType, dataSpec);
-    }
+        int responseCode;
+        try {
+            responseCode = connection.getResponseCode();
+        } catch (IOException e) {
+            closeConnectionQuietly();
+            throw new HttpDataSourceException("Unable to connect to " + dataSpec.uri.toString(), e,
+                    dataSpec, HttpDataSourceException.TYPE_OPEN);
+        }
 
-    // If we requested a range starting from a non-zero position and received a 200 rather than a
-    // 206, then the server does not support partial requests. We'll need to manually skip to the
-    // requested position.
-    // Range Request返回的code:
-    // 200
-    // 206的区别
-    bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
-
-    // Determine the length of the data to be read, after skipping.
-    if ((dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) == 0) {
-      if (dataSpec.length != C.LENGTH_UNSET) {
-        bytesToRead = dataSpec.length;
-      } else {
-        long contentLength = getContentLength(connection);
-        bytesToRead = contentLength != C.LENGTH_UNSET ? (contentLength - bytesToSkip)
-                : C.LENGTH_UNSET;
-      }
-    } else {
-      // Gzip is enabled. If the server opts to use gzip then the content length in the response
-      // will be that of the compressed data, which isn't what we want. Furthermore, there isn't a
-      // reliable way to determine whether the gzip was used or not. Always use the dataSpec length
-      // in this case.
-      bytesToRead = dataSpec.length;
-    }
+        // Check for a valid response code.
+        if (responseCode < 200 || responseCode > 299) {
+            Map<String, List<String>> headers = connection.getHeaderFields();
+            closeConnectionQuietly();
+            InvalidResponseCodeException exception =
+                    new InvalidResponseCodeException(responseCode, headers, dataSpec);
+            if (responseCode == 416) {
+                exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));
+            }
+            throw exception;
+        }
 
-    try {
-      inputStream = connection.getInputStream();
-    } catch (IOException e) {
-      closeConnectionQuietly();
-      throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_OPEN);
-    }
+        // Check for a valid content type.
+        String contentType = connection.getContentType();
+        if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {
+            closeConnectionQuietly();
+            throw new InvalidContentTypeException(contentType, dataSpec);
+        }
 
-    opened = true;
-    if (listener != null) {
-      listener.onTransferStart(this, dataSpec);
-    }
+        // If we requested a range starting from a non-zero position and received a 200 rather than a
+        // 206, then the server does not support partial requests. We'll need to manually skip to the
+        // requested position.
+        // Range Request返回的code:
+        // 200
+        // 206的区别
+        bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;
+
+        // Determine the length of the data to be read, after skipping.
+        if ((dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) == 0) {
+            if (dataSpec.length != C.LENGTH_UNSET) {
+                bytesToRead = dataSpec.length;
+            } else {
+                long contentLength = getContentLength(connection);
+                bytesToRead = contentLength != C.LENGTH_UNSET ? (contentLength - bytesToSkip)
+                        : C.LENGTH_UNSET;
+            }
+        } else {
+            // Gzip is enabled. If the server opts to use gzip then the content length in the response
+            // will be that of the compressed data, which isn't what we want. Furthermore, there isn't a
+            // reliable way to determine whether the gzip was used or not. Always use the dataSpec length
+            // in this case.
+            bytesToRead = dataSpec.length;
+        }
 
-    return bytesToRead;
-  }
+        try {
+            inputStream = connection.getInputStream();
+        } catch (IOException e) {
+            closeConnectionQuietly();
+            throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_OPEN);
+        }
 
-  @Override
-  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
-    try {
-      skipInternal();
-      return readInternal(buffer, offset, readLength);
-    } catch (IOException e) {
-      throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_READ);
+        opened = true;
+        if (listener != null) {
+            listener.onTransferStart(this, dataSpec);
+        }
+
+        return bytesToRead;
     }
-  }
 
-  @Override
-  public void close() throws HttpDataSourceException {
-    try {
-      if (inputStream != null) {
-        maybeTerminateInputStream(connection, bytesRemaining());
+    @Override
+    public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {
         try {
-          inputStream.close();
+            skipInternal();
+            return readInternal(buffer, offset, readLength);
         } catch (IOException e) {
-          throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_CLOSE);
-        }
-      }
-    } finally {
-      inputStream = null;
-      closeConnectionQuietly();
-      if (opened) {
-        opened = false;
-        if (listener != null) {
-          listener.onTransferEnd(this);
+            throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_READ);
         }
-      }
     }
-  }
-
-  /**
-   * Returns the current connection, or null if the source is not currently opened.
-   *
-   * @return The current open connection, or null.
-   */
-  protected final HttpURLConnection getConnection() {
-    return connection;
-  }
-
-  /**
-   * Returns the number of bytes that have been skipped since the most recent call to
-   * {@link #open(DataSpec)}.
-   *
-   * @return The number of bytes skipped.
-   */
-  protected final long bytesSkipped() {
-    return bytesSkipped;
-  }
-
-  /**
-   * Returns the number of bytes that have been read since the most recent call to
-   * {@link #open(DataSpec)}.
-   *
-   * @return The number of bytes read.
-   */
-  protected final long bytesRead() {
-    return bytesRead;
-  }
-
-  /**
-   * Returns the number of bytes that are still to be read for the current {@link DataSpec}.
-   * <p>
-   * If the total length of the data being read is known, then this length minus {@code bytesRead()}
-   * is returned. If the total length is unknown, {@link C#LENGTH_UNSET} is returned.
-   *
-   * @return The remaining length, or {@link C#LENGTH_UNSET}.
-   */
-  protected final long bytesRemaining() {
-    return bytesToRead == C.LENGTH_UNSET ? bytesToRead : bytesToRead - bytesRead;
-  }
-
-  /**
-   * Establishes a connection, following redirects to do so where permitted.
-   */
-  private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
-    URL url = new URL(dataSpec.uri.toString());
-    byte[] postBody = dataSpec.postBody;
-    long position = dataSpec.position;
-    long length = dataSpec.length;
-    boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
-
-    // 扩协议的跳转
-    if (!allowCrossProtocolRedirects) {
-      // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
-      // automatically. This is the behavior we want, so use it.
-      return makeConnection(url, postBody, position, length, allowGzip, true /* followRedirects */);
+
+    @Override
+    public void close() throws HttpDataSourceException {
+        try {
+            if (inputStream != null) {
+                maybeTerminateInputStream(connection, bytesRemaining());
+                try {
+                    inputStream.close();
+                } catch (IOException e) {
+                    throw new HttpDataSourceException(e, dataSpec, HttpDataSourceException.TYPE_CLOSE);
+                }
+            }
+        } finally {
+            inputStream = null;
+            closeConnectionQuietly();
+            if (opened) {
+                opened = false;
+                if (listener != null) {
+                    listener.onTransferEnd(this);
+                }
+            }
+        }
     }
 
-    // We need to handle redirects ourselves to allow cross-protocol redirects.
-    int redirectCount = 0;
-    while (redirectCount++ <= MAX_REDIRECTS) {
-      HttpURLConnection connection = makeConnection(url, postBody, position, length, allowGzip, false); /* followRedirects */
-
-      int responseCode = connection.getResponseCode();
-      if (responseCode == HttpURLConnection.HTTP_MULT_CHOICE
-              || responseCode == HttpURLConnection.HTTP_MOVED_PERM
-              || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
-              || responseCode == HttpURLConnection.HTTP_SEE_OTHER
-              || (postBody == null
-              && (responseCode == 307 /* HTTP_TEMP_REDIRECT */
-              || responseCode == 308 /* HTTP_PERM_REDIRECT */))) {
-        // For 300, 301, 302, and 303 POST requests follow the redirect and are transformed into
-        // GET requests. For 307 and 308 POST requests are not redirected.
-        postBody = null;
-        String location = connection.getHeaderField("Location");
-        connection.disconnect();
-        url = handleRedirect(url, location);
-      } else {
+    /**
+     * Returns the current connection, or null if the source is not currently opened.
+     *
+     * @return The current open connection, or null.
+     */
+    protected final HttpURLConnection getConnection() {
         return connection;
-      }
     }
 
-    // If we get here we've been redirected more times than are permitted.
-    throw new NoRouteToHostException("Too many redirects: " + redirectCount);
-  }
-
-  /**
-   * Configures a connection and opens it.
-   *
-   * @param url             The url to connect to.
-   * @param postBody        The body data for a POST request.
-   * @param position        The byte offset of the requested data.
-   * @param length          The length of the requested data, or {@link C#LENGTH_UNSET}.
-   * @param allowGzip       Whether to allow the use of gzip.
-   * @param followRedirects Whether to follow redirects.
-   */
-  private HttpURLConnection makeConnection(URL url, byte[] postBody, long position,
-                                           long length, boolean allowGzip, boolean followRedirects) throws IOException {
-    // 新建Connection
-    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    connection.setConnectTimeout(connectTimeoutMillis);
-    connection.setReadTimeout(readTimeoutMillis);
-    synchronized (requestProperties) {
-      for (Map.Entry<String, String> property : requestProperties.entrySet()) {
-        connection.setRequestProperty(property.getKey(), property.getValue());
-      }
-    }
+    /**
+     * Returns the number of bytes that have been skipped since the most recent call to
+     * {@link #open(DataSpec)}.
+     *
+     * @return The number of bytes skipped.
+     */
+    protected final long bytesSkipped() {
+        return bytesSkipped;
+    }
+
+    /**
+     * Returns the number of bytes that have been read since the most recent call to
+     * {@link #open(DataSpec)}.
+     *
+     * @return The number of bytes read.
+     */
+    protected final long bytesRead() {
+        return bytesRead;
+    }
+
+    /**
+     * Returns the number of bytes that are still to be read for the current {@link DataSpec}.
+     * <p>
+     * If the total length of the data being read is known, then this length minus {@code bytesRead()}
+     * is returned. If the total length is unknown, {@link C#LENGTH_UNSET} is returned.
+     *
+     * @return The remaining length, or {@link C#LENGTH_UNSET}.
+     */
+    protected final long bytesRemaining() {
+        return bytesToRead == C.LENGTH_UNSET ? bytesToRead : bytesToRead - bytesRead;
+    }
+
+    /**
+     * Establishes a connection, following redirects to do so where permitted.
+     */
+    private HttpURLConnection makeConnection(DataSpec dataSpec) throws IOException {
+        URL url = new URL(dataSpec.uri.toString());
+        byte[] postBody = dataSpec.postBody;
+        long position = dataSpec.position;
+        long length = dataSpec.length;
+        boolean allowGzip = (dataSpec.flags & DataSpec.FLAG_ALLOW_GZIP) != 0;
+
+        // 扩协议的跳转
+        if (!allowCrossProtocolRedirects) {
+            // HttpURLConnection disallows cross-protocol redirects, but otherwise performs redirection
+            // automatically. This is the behavior we want, so use it.
+            return makeConnection(url, postBody, position, length, allowGzip, true /* followRedirects */);
+        }
 
-    // connection
-    // Range参数的设置
-    if (!(position == 0 && length == C.LENGTH_UNSET)) {
-      String rangeRequest = "bytes=" + position + "-";
-      if (length != C.LENGTH_UNSET) {
-        rangeRequest += (position + length - 1);
-      }
-      connection.setRequestProperty("Range", rangeRequest);
-    }
-    connection.setRequestProperty("User-Agent", userAgent);
+        // We need to handle redirects ourselves to allow cross-protocol redirects.
+        int redirectCount = 0;
+        while (redirectCount++ <= MAX_REDIRECTS) {
+            HttpURLConnection connection = makeConnection(url, postBody, position, length, allowGzip, false); /* followRedirects */
+
+            int responseCode = connection.getResponseCode();
+            if (responseCode == HttpURLConnection.HTTP_MULT_CHOICE
+                    || responseCode == HttpURLConnection.HTTP_MOVED_PERM
+                    || responseCode == HttpURLConnection.HTTP_MOVED_TEMP
+                    || responseCode == HttpURLConnection.HTTP_SEE_OTHER
+                    || (postBody == null
+                    && (responseCode == 307 /* HTTP_TEMP_REDIRECT */
+                    || responseCode == 308 /* HTTP_PERM_REDIRECT */))) {
+                // For 300, 301, 302, and 303 POST requests follow the redirect and are transformed into
+                // GET requests. For 307 and 308 POST requests are not redirected.
+                postBody = null;
+                String location = connection.getHeaderField("Location");
+                connection.disconnect();
+                url = handleRedirect(url, location);
+            } else {
+                return connection;
+            }
+        }
 
-    // 如果不支持Gzip？
-    if (!allowGzip) {
-      connection.setRequestProperty("Accept-Encoding", "identity");
-    }
-    connection.setInstanceFollowRedirects(followRedirects);
-    connection.setDoOutput(postBody != null);
-
-    if (postBody != null) {
-      connection.setRequestMethod("POST");
-      if (postBody.length == 0) {
-        connection.connect();
-      } else {
-        connection.setFixedLengthStreamingMode(postBody.length);
-        connection.connect();
-
-        // 连接之后如何设置post body
-        OutputStream os = connection.getOutputStream();
-        os.write(postBody);
-        os.close();
-      }
-    } else {
-      connection.connect();
-    }
-    return connection;
-  }
-
-  /**
-   * Handles a redirect.
-   *
-   * @param originalUrl The original URL.
-   * @param location    The Location header in the response.
-   * @return The next URL.
-   * @throws IOException If redirection isn't possible.
-   */
-  private static URL handleRedirect(URL originalUrl, String location) throws IOException {
-    if (location == null) {
-      throw new ProtocolException("Null location redirect");
-    }
-    // Form the new url.
-    URL url = new URL(originalUrl, location);
-    // Check that the protocol of the new url is supported.
-    String protocol = url.getProtocol();
-    if (!"https".equals(protocol) && !"http".equals(protocol)) {
-      throw new ProtocolException("Unsupported protocol redirect: " + protocol);
-    }
-    // Currently this method is only called if allowCrossProtocolRedirects is true, and so the code
-    // below isn't required. If we ever decide to handle redirects ourselves when cross-protocol
-    // redirects are disabled, we'll need to uncomment this block of code.
-    // if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {
-    //   throw new ProtocolException("Disallowed cross-protocol redirect ("
-    //       + originalUrl.getProtocol() + " to " + protocol + ")");
-    // }
-    return url;
-  }
-
-  /**
-   * Attempts to extract the length of the content from the response headers of an open connection.
-   *
-   * @param connection The open connection.
-   * @return The extracted length, or {@link C#LENGTH_UNSET}.
-   */
-  private static long getContentLength(HttpURLConnection connection) {
-    long contentLength = C.LENGTH_UNSET;
-    String contentLengthHeader = connection.getHeaderField("Content-Length");
-    if (!TextUtils.isEmpty(contentLengthHeader)) {
-      try {
-        contentLength = Long.parseLong(contentLengthHeader);
-      } catch (NumberFormatException e) {
-        Log.e(TAG, "Unexpected Content-Length [" + contentLengthHeader + "]");
-      }
-    }
-    String contentRangeHeader = connection.getHeaderField("Content-Range");
-    if (!TextUtils.isEmpty(contentRangeHeader)) {
-      Matcher matcher = CONTENT_RANGE_HEADER.matcher(contentRangeHeader);
-      if (matcher.find()) {
-        try {
-          long contentLengthFromRange =
-                  Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
-          if (contentLength < 0) {
-            // Some proxy servers strip the Content-Length header. Fall back to the length
-            // calculated here in this case.
-            contentLength = contentLengthFromRange;
-          } else if (contentLength != contentLengthFromRange) {
-            // If there is a discrepancy between the Content-Length and Content-Range headers,
-            // assume the one with the larger value is correct. We have seen cases where carrier
-            // change one of them to reduce the size of a request, but it is unlikely anybody would
-            // increase it.
-            Log.w(TAG, "Inconsistent headers [" + contentLengthHeader + "] [" + contentRangeHeader
-                    + "]");
-            contentLength = Math.max(contentLength, contentLengthFromRange);
-          }
-        } catch (NumberFormatException e) {
-          Log.e(TAG, "Unexpected Content-Range [" + contentRangeHeader + "]");
-        }
-      }
-    }
-    return contentLength;
-  }
-
-  /**
-   * Skips any bytes that need skipping. Else does nothing.
-   * <p>
-   * This implementation is based roughly on {@code libcore.io.Streams.skipByReading()}.
-   *
-   * @throws InterruptedIOException If the thread is interrupted during the operation.
-   * @throws EOFException           If the end of the input stream is reached before the bytes are skipped.
-   */
-  private void skipInternal() throws IOException {
-    if (bytesSkipped == bytesToSkip) {
-      return;
-    }
+        // If we get here we've been redirected more times than are permitted.
+        throw new NoRouteToHostException("Too many redirects: " + redirectCount);
+    }
+
+    /**
+     * Configures a connection and opens it.
+     *
+     * @param url             The url to connect to.
+     * @param postBody        The body data for a POST request.
+     * @param position        The byte offset of the requested data.
+     * @param length          The length of the requested data, or {@link C#LENGTH_UNSET}.
+     * @param allowGzip       Whether to allow the use of gzip.
+     * @param followRedirects Whether to follow redirects.
+     */
+    private HttpURLConnection makeConnection(URL url, byte[] postBody, long position,
+                                             long length, boolean allowGzip, boolean followRedirects) throws IOException {
+        // 新建Connection
+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+        connection.setConnectTimeout(connectTimeoutMillis);
+        connection.setReadTimeout(readTimeoutMillis);
+        synchronized (requestProperties) {
+            for (Map.Entry<String, String> property : requestProperties.entrySet()) {
+                connection.setRequestProperty(property.getKey(), property.getValue());
+            }
+        }
 
-    // Acquire the shared skip buffer.
-    byte[] skipBuffer = skipBufferReference.getAndSet(null);
-    if (skipBuffer == null) {
-      skipBuffer = new byte[4096];
-    }
+        // connection
+        // Range参数的设置
+        if (!(position == 0 && length == C.LENGTH_UNSET)) {
+            String rangeRequest = "bytes=" + position + "-";
+            if (length != C.LENGTH_UNSET) {
+                rangeRequest += (position + length - 1);
+            }
+            connection.setRequestProperty("Range", rangeRequest);
+        }
+        connection.setRequestProperty("User-Agent", userAgent);
 
-    while (bytesSkipped != bytesToSkip) {
-      int readLength = (int) Math.min(bytesToSkip - bytesSkipped, skipBuffer.length);
-      int read = inputStream.read(skipBuffer, 0, readLength);
-      if (Thread.interrupted()) {
-        throw new InterruptedIOException();
-      }
-      if (read == -1) {
-        throw new EOFException();
-      }
-      bytesSkipped += read;
-      if (listener != null) {
-        listener.onBytesTransferred(this, read);
-      }
+        // 如果不支持Gzip？
+        if (!allowGzip) {
+            connection.setRequestProperty("Accept-Encoding", "identity");
+        }
+        connection.setInstanceFollowRedirects(followRedirects);
+        connection.setDoOutput(postBody != null);
+
+        if (postBody != null) {
+            connection.setRequestMethod("POST");
+            if (postBody.length == 0) {
+                connection.connect();
+            } else {
+                connection.setFixedLengthStreamingMode(postBody.length);
+                connection.connect();
+
+                // 连接之后如何设置post body
+                OutputStream os = connection.getOutputStream();
+                os.write(postBody);
+                os.close();
+            }
+        } else {
+            connection.connect();
+        }
+        return connection;
     }
 
-    // Release the shared skip buffer.
-    skipBufferReference.set(skipBuffer);
-  }
-
-  /**
-   * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
-   * index {@code offset}.
-   * <p>
-   * This method blocks until at least one byte of data can be read, the end of the opened range is
-   * detected, or an exception is thrown.
-   *
-   * @param buffer     The buffer into which the read data should be stored.
-   * @param offset     The start offset into {@code buffer} at which data should be written.
-   * @param readLength The maximum number of bytes to read.
-   * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
-   * range is reached.
-   * @throws IOException If an error occurs reading from the source.
-   */
-  private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
-    if (readLength == 0) {
-      return 0;
-    }
-    if (bytesToRead != C.LENGTH_UNSET) {
-      long bytesRemaining = bytesToRead - bytesRead;
-      if (bytesRemaining == 0) {
-        return C.RESULT_END_OF_INPUT;
-      }
-      readLength = (int) Math.min(readLength, bytesRemaining);
-    }
+    /**
+     * Handles a redirect.
+     *
+     * @param originalUrl The original URL.
+     * @param location    The Location header in the response.
+     * @return The next URL.
+     * @throws IOException If redirection isn't possible.
+     */
+    private static URL handleRedirect(URL originalUrl, String location) throws IOException {
+        if (location == null) {
+            throw new ProtocolException("Null location redirect");
+        }
+        // Form the new url.
+        URL url = new URL(originalUrl, location);
+        // Check that the protocol of the new url is supported.
+        String protocol = url.getProtocol();
+        if (!"https".equals(protocol) && !"http".equals(protocol)) {
+            throw new ProtocolException("Unsupported protocol redirect: " + protocol);
+        }
+        // Currently this method is only called if allowCrossProtocolRedirects is true, and so the code
+        // below isn't required. If we ever decide to handle redirects ourselves when cross-protocol
+        // redirects are disabled, we'll need to uncomment this block of code.
+        // if (!allowCrossProtocolRedirects && !protocol.equals(originalUrl.getProtocol())) {
+        //   throw new ProtocolException("Disallowed cross-protocol redirect ("
+        //       + originalUrl.getProtocol() + " to " + protocol + ")");
+        // }
+        return url;
+    }
+
+    /**
+     * Attempts to extract the length of the content from the response headers of an open connection.
+     *
+     * @param connection The open connection.
+     * @return The extracted length, or {@link C#LENGTH_UNSET}.
+     */
+    private static long getContentLength(HttpURLConnection connection) {
+        long contentLength = C.LENGTH_UNSET;
+        String contentLengthHeader = connection.getHeaderField("Content-Length");
+        if (!TextUtils.isEmpty(contentLengthHeader)) {
+            try {
+                contentLength = Long.parseLong(contentLengthHeader);
+            } catch (NumberFormatException e) {
+                Log.e(TAG, "Unexpected Content-Length [" + contentLengthHeader + "]");
+            }
+        }
+        String contentRangeHeader = connection.getHeaderField("Content-Range");
+        if (!TextUtils.isEmpty(contentRangeHeader)) {
+            Matcher matcher = CONTENT_RANGE_HEADER.matcher(contentRangeHeader);
+            if (matcher.find()) {
+                try {
+                    long contentLengthFromRange =
+                            Long.parseLong(matcher.group(2)) - Long.parseLong(matcher.group(1)) + 1;
+                    if (contentLength < 0) {
+                        // Some proxy servers strip the Content-Length header. Fall back to the length
+                        // calculated here in this case.
+                        contentLength = contentLengthFromRange;
+                    } else if (contentLength != contentLengthFromRange) {
+                        // If there is a discrepancy between the Content-Length and Content-Range headers,
+                        // assume the one with the larger value is correct. We have seen cases where carrier
+                        // change one of them to reduce the size of a request, but it is unlikely anybody would
+                        // increase it.
+                        Log.w(TAG, "Inconsistent headers [" + contentLengthHeader + "] [" + contentRangeHeader
+                                + "]");
+                        contentLength = Math.max(contentLength, contentLengthFromRange);
+                    }
+                } catch (NumberFormatException e) {
+                    Log.e(TAG, "Unexpected Content-Range [" + contentRangeHeader + "]");
+                }
+            }
+        }
+        return contentLength;
+    }
+
+    /**
+     * Skips any bytes that need skipping. Else does nothing.
+     * <p>
+     * This implementation is based roughly on {@code libcore.io.Streams.skipByReading()}.
+     *
+     * @throws InterruptedIOException If the thread is interrupted during the operation.
+     * @throws EOFException           If the end of the input stream is reached before the bytes are skipped.
+     */
+    private void skipInternal() throws IOException {
+        if (bytesSkipped == bytesToSkip) {
+            return;
+        }
 
-    int read = inputStream.read(buffer, offset, readLength);
-    if (read == -1) {
-      if (bytesToRead != C.LENGTH_UNSET) {
-        // End of stream reached having not read sufficient data.
-        throw new EOFException();
-      }
-      return C.RESULT_END_OF_INPUT;
-    }
+        // Acquire the shared skip buffer.
+        byte[] skipBuffer = skipBufferReference.getAndSet(null);
+        if (skipBuffer == null) {
+            skipBuffer = new byte[4096];
+        }
 
-    bytesRead += read;
-    if (listener != null) {
-      listener.onBytesTransferred(this, read);
-    }
-    return read;
-  }
-
-  /**
-   * On platform API levels 19 and 20, okhttp's implementation of {@link InputStream#close} can
-   * block for a long time if the stream has a lot of data remaining. Call this method before
-   * closing the input stream to make a best effort to cause the input stream to encounter an
-   * unexpected end of input, working around this issue. On other platform API levels, the method
-   * does nothing.
-   *
-   * @param connection     The connection whose {@link InputStream} should be terminated.
-   * @param bytesRemaining The number of bytes remaining to be read from the input stream if its
-   *                       length is known. {@link C#LENGTH_UNSET} otherwise.
-   */
-  private static void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {
-    if (Util.SDK_INT != 19 && Util.SDK_INT != 20) {
-      return;
-    }
+        while (bytesSkipped != bytesToSkip) {
+            int readLength = (int) Math.min(bytesToSkip - bytesSkipped, skipBuffer.length);
+            int read = inputStream.read(skipBuffer, 0, readLength);
+            if (Thread.interrupted()) {
+                throw new InterruptedIOException();
+            }
+            if (read == -1) {
+                throw new EOFException();
+            }
+            bytesSkipped += read;
+            if (listener != null) {
+                listener.onBytesTransferred(this, read);
+            }
+        }
+
+        // Release the shared skip buffer.
+        skipBufferReference.set(skipBuffer);
+    }
+
+    /**
+     * Reads up to {@code length} bytes of data and stores them into {@code buffer}, starting at
+     * index {@code offset}.
+     * <p>
+     * This method blocks until at least one byte of data can be read, the end of the opened range is
+     * detected, or an exception is thrown.
+     *
+     * @param buffer     The buffer into which the read data should be stored.
+     * @param offset     The start offset into {@code buffer} at which data should be written.
+     * @param readLength The maximum number of bytes to read.
+     * @return The number of bytes read, or {@link C#RESULT_END_OF_INPUT} if the end of the opened
+     * range is reached.
+     * @throws IOException If an error occurs reading from the source.
+     */
+    private int readInternal(byte[] buffer, int offset, int readLength) throws IOException {
+        if (readLength == 0) {
+            return 0;
+        }
+        if (bytesToRead != C.LENGTH_UNSET) {
+            long bytesRemaining = bytesToRead - bytesRead;
+            if (bytesRemaining == 0) {
+                return C.RESULT_END_OF_INPUT;
+            }
+            readLength = (int) Math.min(readLength, bytesRemaining);
+        }
+
+        int read = inputStream.read(buffer, offset, readLength);
+        if (read == -1) {
+            if (bytesToRead != C.LENGTH_UNSET) {
+                // End of stream reached having not read sufficient data.
+                throw new EOFException();
+            }
+            return C.RESULT_END_OF_INPUT;
+        }
 
-    try {
-      InputStream inputStream = connection.getInputStream();
-      if (bytesRemaining == C.LENGTH_UNSET) {
-        // If the input stream has already ended, do nothing. The socket may be re-used.
-        if (inputStream.read() == -1) {
-          return;
-        }
-      } else if (bytesRemaining <= MAX_BYTES_TO_DRAIN) {
-        // There isn't much data left. Prefer to allow it to drain, which may allow the socket to be
-        // re-used.
-        return;
-      }
-      String className = inputStream.getClass().getName();
-      if (className.equals("com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream")
-              || className.equals(
-              "com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream")) {
-        Class<?> superclass = inputStream.getClass().getSuperclass();
-        Method unexpectedEndOfInput = superclass.getDeclaredMethod("unexpectedEndOfInput");
-        unexpectedEndOfInput.setAccessible(true);
-        unexpectedEndOfInput.invoke(inputStream);
-      }
-    } catch (Exception e) {
-      // If an IOException then the connection didn't ever have an input stream, or it was closed
-      // already. If another type of exception then something went wrong, most likely the device
-      // isn't using okhttp.
+        bytesRead += read;
+        if (listener != null) {
+            listener.onBytesTransferred(this, read);
+        }
+        return read;
+    }
+
+    /**
+     * On platform API levels 19 and 20, okhttp's implementation of {@link InputStream#close} can
+     * block for a long time if the stream has a lot of data remaining. Call this method before
+     * closing the input stream to make a best effort to cause the input stream to encounter an
+     * unexpected end of input, working around this issue. On other platform API levels, the method
+     * does nothing.
+     *
+     * @param connection     The connection whose {@link InputStream} should be terminated.
+     * @param bytesRemaining The number of bytes remaining to be read from the input stream if its
+     *                       length is known. {@link C#LENGTH_UNSET} otherwise.
+     */
+    private static void maybeTerminateInputStream(HttpURLConnection connection, long bytesRemaining) {
+        if (Util.SDK_INT != 19 && Util.SDK_INT != 20) {
+            return;
+        }
+
+        try {
+            InputStream inputStream = connection.getInputStream();
+            if (bytesRemaining == C.LENGTH_UNSET) {
+                // If the input stream has already ended, do nothing. The socket may be re-used.
+                if (inputStream.read() == -1) {
+                    return;
+                }
+            } else if (bytesRemaining <= MAX_BYTES_TO_DRAIN) {
+                // There isn't much data left. Prefer to allow it to drain, which may allow the socket to be
+                // re-used.
+                return;
+            }
+            String className = inputStream.getClass().getName();
+            if (className.equals("com.android.okhttp.internal.http.HttpTransport$ChunkedInputStream")
+                    || className.equals(
+                    "com.android.okhttp.internal.http.HttpTransport$FixedLengthInputStream")) {
+                Class<?> superclass = inputStream.getClass().getSuperclass();
+                Method unexpectedEndOfInput = superclass.getDeclaredMethod("unexpectedEndOfInput");
+                unexpectedEndOfInput.setAccessible(true);
+                unexpectedEndOfInput.invoke(inputStream);
+            }
+        } catch (Exception e) {
+            // If an IOException then the connection didn't ever have an input stream, or it was closed
+            // already. If another type of exception then something went wrong, most likely the device
+            // isn't using okhttp.
+        }
     }
-  }
-
-
-  /**
-   * Closes the current connection quietly, if there is one.
-   */
-  private void closeConnectionQuietly() {
-    if (connection != null) {
-      try {
-        connection.disconnect();
-      } catch (Exception e) {
-        Log.e(TAG, "Unexpected error while disconnecting", e);
-      }
-      connection = null;
+
+
+    /**
+     * Closes the current connection quietly, if there is one.
+     */
+    private void closeConnectionQuietly() {
+        if (connection != null) {
+            try {
+                connection.disconnect();
+            } catch (Exception e) {
+                Log.e(TAG, "Unexpected error while disconnecting", e);
+            }
+            connection = null;
+        }
     }
-  }
 
 }
