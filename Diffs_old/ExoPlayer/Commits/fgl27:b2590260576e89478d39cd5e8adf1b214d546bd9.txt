diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index d1a5f13eb3..fc0b0bb088 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -5,14 +5,6 @@
 * AV1 extension: Uses libgav1 to decode AV1 videos. Android 10 includes an AV1
   decoder, but the older versions of Android require this extension for playback
   of AV1 streams ([#3353](https://github.com/google/ExoPlayer/issues/3353)).
-* UI
-  * Setting `app:played_color` on `PlayerView` and `PlayerControlView` no longer
-    adjusts the colors of the scrubber handle , buffered and unplayed parts of
-    the time bar. These can be set separately using `app:scrubber_color`,
-    `app:buffered_color` and `app_unplayed_color` respectively.
-  * Setting `app:ad_marker_color` on `PlayerView` and `PlayerControlView` no
-    longer adjusts the color of played ad markers. The color of played ad
-    markers can be set separately using `app:played_ad_marker_color`
 * DRM:
   * Inject `DrmSessionManager` into the `MediaSources` instead of `Renderers`
     ([#5619](https://github.com/google/ExoPlayer/issues/5619)).
@@ -27,21 +19,14 @@
 * Remove the `DataSpec.FLAG_ALLOW_ICY_METADATA` flag. Instead, set the header
   `IcyHeaders.REQUEST_HEADER_ENABLE_METADATA_NAME` in the `DataSpec`
   `httpRequestHeaders`.
-* DASH:
-  * Support negative @r values in segment timelines
-    ([#1787](https://github.com/google/ExoPlayer/issues/1787)).
-  * Support `Label` elements
-    ([#6297](https://github.com/google/ExoPlayer/issues/6297)).
-  * Support legacy audio channel configuration
-    ([#6523](https://github.com/google/ExoPlayer/issues/6523)).
+* DASH: Support negative @r values in segment timelines
+  ([#1787](https://github.com/google/ExoPlayer/issues/1787)).
 * Add `allowedCapturePolicy` field to `AudioAttributes` wrapper to allow to
   opt-out of audio recording.
 * Add `DataSpec.httpRequestHeaders` to set HTTP request headers when connecting
   to an HTTP source. `DefaultHttpDataSource`, `CronetDataSource` and
   `OkHttpDataSource` include headers set in the DataSpec when connecting to the
   source.
-* Bypass sniffing in `ProgressiveMediaPeriod` in case a single extractor is
-  provided ([#6325](https://github.com/google/ExoPlayer/issues/6325)).
 * Surface information provided by methods `isHardwareAccelerated`,
   `isSoftwareOnly` and `isVendor` added in Android 10 in `MediaCodecInfo` class
   ([#5839](https://github.com/google/ExoPlayer/issues/5839)).
@@ -92,9 +77,6 @@
   `setEnableWakeLock`, which requires the
   `android.Manifest.permission#WAKE_LOCK` permission
   ([#5846](https://github.com/google/ExoPlayer/issues/5846)).
-* Add `Player.onPlaybackSuppressionReasonChanged` to allow listeners to
-  detect playbacks suppressions (e.g. audio focus loss) directly
-  ([#6203](https://github.com/google/ExoPlayer/issues/6203)).
 * VP9 extension:
   * Rename `VpxVideoSurfaceView` to `VideoDecoderSurfaceView`
     and move it to the core library.
@@ -105,16 +87,35 @@
 * Add `Timeline.Window.isLive` to indicate that a window is a live stream
   ([#2668](https://github.com/google/ExoPlayer/issues/2668) and
   [#5973](https://github.com/google/ExoPlayer/issues/5973)).
-* Expose the raw ICY metadata through `IcyInfo`
-  ([#6476](https://github.com/google/ExoPlayer/issues/6476)).
 * Fail more explicitly when local-file Uris contain invalid parts (e.g.
   fragment) ([#6470](https://github.com/google/ExoPlayer/issues/6470)).
 * Add `MediaPeriod.isLoading` to improve `Player.isLoading` state.
-* Add support for ID3-in-EMSG in HLS streams
-  ([spec](https://aomediacodec.github.io/av1-id3/)).
 * Make show and hide player controls accessible for TalkBack in `PlayerView`.
 * Pass the codec output `MediaFormat` to `VideoFrameMetadataListener`.
 
+### 2.10.6 (2019-10-17) ###
+
+* Add `Player.onPlaybackSuppressionReasonChanged` to allow listeners to
+  detect playbacks suppressions (e.g. transient audio focus loss) directly
+  ([#6203](https://github.com/google/ExoPlayer/issues/6203)).
+* DASH:
+  * Support `Label` elements
+    ([#6297](https://github.com/google/ExoPlayer/issues/6297)).
+  * Support legacy audio channel configuration
+    ([#6523](https://github.com/google/ExoPlayer/issues/6523)).
+* HLS: Add support for ID3 in EMSG when using FMP4 streams
+  ([spec](https://aomediacodec.github.io/av1-id3/)).
+* Metadata: Expose the raw ICY metadata through `IcyInfo`
+  ([#6476](https://github.com/google/ExoPlayer/issues/6476)).
+* UI:
+  * Setting `app:played_color` on `PlayerView` and `PlayerControlView` no longer
+    adjusts the colors of the scrubber handle , buffered and unplayed parts of
+    the time bar. These can be set separately using `app:scrubber_color`,
+    `app:buffered_color` and `app_unplayed_color` respectively.
+  * Setting `app:ad_marker_color` on `PlayerView` and `PlayerControlView` no
+    longer adjusts the color of played ad markers. The color of played ad
+    markers can be set separately using `app:played_ad_marker_color`.
+
 ### 2.10.5 (2019-09-20) ###
 
 * Add `Player.isPlaying` and `EventListener.onIsPlayingChanged` to check whether
diff --git a/build.gradle b/build.gradle
index 1d0b459bf5..a4823b94ee 100644
--- a/build.gradle
+++ b/build.gradle
@@ -17,9 +17,9 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.4.0'
-        classpath 'com.novoda:bintray-release:0.9'
-        classpath 'com.google.android.gms:strict-version-matcher-plugin:1.1.0'
+        classpath 'com.android.tools.build:gradle:3.5.1'
+        classpath 'com.novoda:bintray-release:0.9.1'
+        classpath 'com.google.android.gms:strict-version-matcher-plugin:1.2.0'
     }
 }
 allprojects {
diff --git a/constants.gradle b/constants.gradle
index 21b7bebf48..b9a647064f 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -13,8 +13,8 @@
 // limitations under the License.
 project.ext {
     // ExoPlayer version and version code.
-    releaseVersion = '2.10.5'
-    releaseVersionCode = 2010005
+    releaseVersion = '2.10.6'
+    releaseVersionCode = 2010006
     minSdkVersion = 16
     targetSdkVersion = 28
     compileSdkVersion = 29
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
index d5bc72fbaf..2fd5821928 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer2.BasePlayer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
@@ -68,6 +69,10 @@
  */
 public final class CastPlayer extends BasePlayer {
 
+  static {
+    ExoPlayerLibraryInfo.registerModule("goog.exo.cast");
+  }
+
   private static final String TAG = "CastPlayer";
 
   private static final int RENDERER_COUNT = 3;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index bf64a14225..adc05eb204 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -29,11 +29,11 @@
 
   /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.10.5";
+  public static final String VERSION = "2.10.6";
 
   /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.5";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.10.6";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
@@ -43,7 +43,7 @@
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2010005;
+  public static final int VERSION_INT = 2010006;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index f58893f4eb..e1c070df2a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -1472,7 +1472,8 @@ public Format copyWithVideoSize(int width, int height) {
         exoMediaCryptoType);
   }
 
-  public Format copyWithExoMediaCryptoType(Class<? extends ExoMediaCrypto> exoMediaCryptoType) {
+  public Format copyWithExoMediaCryptoType(
+      @Nullable Class<? extends ExoMediaCrypto> exoMediaCryptoType) {
     return new Format(
         id,
         label,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Player.java b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
index 1c0dd4ca0a..c0039b67c1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -535,16 +535,20 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
   /**
    * Reason why playback is suppressed even if {@link #getPlaybackState()} is {@link #STATE_READY}
    * and {@link #getPlayWhenReady()} is {@code true}. One of {@link
-   * #PLAYBACK_SUPPRESSION_REASON_NONE} or {@link #PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS}.
+   * #PLAYBACK_SUPPRESSION_REASON_NONE} or {@link
+   * #PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS}.
    */
   @Documented
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({PLAYBACK_SUPPRESSION_REASON_NONE, PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS})
+  @IntDef({
+    PLAYBACK_SUPPRESSION_REASON_NONE,
+    PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS
+  })
   @interface PlaybackSuppressionReason {}
   /** Playback is not suppressed. */
   int PLAYBACK_SUPPRESSION_REASON_NONE = 0;
-  /** Playback is suppressed because audio focus is lost or can't be acquired. */
-  int PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS = 1;
+  /** Playback is suppressed due to transient audio focus loss. */
+  int PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS = 1;
 
   /**
    * Repeat modes for playback. One of {@link #REPEAT_MODE_OFF}, {@link #REPEAT_MODE_ONE} or {@link
@@ -669,13 +673,10 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
   int getPlaybackState();
 
   /**
-   * Returns reason why playback is suppressed even if {@link #getPlaybackState()} is {@link
-   * #STATE_READY} and {@link #getPlayWhenReady()} is {@code true}.
-   *
-   * <p>Note that {@link #PLAYBACK_SUPPRESSION_REASON_NONE} indicates that playback is not
-   * suppressed.
+   * Returns the reason why playback is suppressed even though {@link #getPlayWhenReady()} is {@code
+   * true}, or {@link #PLAYBACK_SUPPRESSION_REASON_NONE} if playback is not suppressed.
    *
-   * @return The current {@link PlaybackSuppressionReason}.
+   * @return The current {@link PlaybackSuppressionReason playback suppression reason}.
    */
   @PlaybackSuppressionReason
   int getPlaybackSuppressionReason();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index ab99994267..9e59448c2d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -608,16 +608,14 @@ public void clearVideoTextureView(TextureView textureView) {
   @Override
   public void setOutputBufferRenderer(VideoDecoderOutputBufferRenderer outputBufferRenderer) {
     verifyApplicationThread();
-    removeSurfaceCallbacks();
-    List<PlayerMessage> messages = new ArrayList<>();
+    setVideoSurface(null);
     for (Renderer renderer : renderers) {
       if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
-        messages.add(
-            player
-                .createMessage(renderer)
-                .setType(C.MSG_SET_OUTPUT_BUFFER_RENDERER)
-                .setPayload(outputBufferRenderer)
-                .send());
+        player
+            .createMessage(renderer)
+            .setType(C.MSG_SET_OUTPUT_BUFFER_RENDERER)
+            .setPayload(outputBufferRenderer)
+            .send();
       }
     }
   }
@@ -1454,7 +1452,7 @@ private void updatePlayWhenReady(
     @PlaybackSuppressionReason
     int playbackSuppressionReason =
         playWhenReady && playerCommand != AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY
-            ? Player.PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS
+            ? Player.PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS
             : Player.PLAYBACK_SUPPRESSION_REASON_NONE;
     player.setPlayWhenReady(playWhenReady, playbackSuppressionReason);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
index 717bb2b2e2..1198d1af8b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/icy/IcyInfo.java
@@ -33,7 +33,7 @@
   @Nullable public final String url;
 
   /**
-   * Construct a new IcyInfo from the source metadata string, and optionally a StreamTitle &
+   * Construct a new IcyInfo from the source metadata string, and optionally a StreamTitle and
    * StreamUrl that have been extracted.
    *
    * @param rawMetadata See {@link #rawMetadata}.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
index ec9ddba122..88f6b97e5c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
@@ -666,8 +666,8 @@ private static String getPlaybackSuppressionReasonString(
     switch (playbackSuppressionReason) {
       case Player.PLAYBACK_SUPPRESSION_REASON_NONE:
         return "NONE";
-      case Player.PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS:
-        return "AUDIO_FOCUS_LOSS";
+      case Player.PLAYBACK_SUPPRESSION_REASON_TRANSIENT_AUDIO_FOCUS_LOSS:
+        return "TRANSIENT_AUDIO_FOCUS_LOSS";
       default:
         return "?";
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index e11aa53b0f..30e11f9744 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -336,7 +336,20 @@ public static boolean contains(@NullableType Object[] items, @Nullable Object it
   }
 
   /**
-   * Concatenates two non-null type arrays.
+   * Creates a new array containing {@code original} with {@code newElement} appended.
+   *
+   * @param original The input array.
+   * @param newElement The element to append.
+   * @return The new array.
+   */
+  public static <T> T[] nullSafeArrayAppend(T[] original, T newElement) {
+    @NullableType T[] result = Arrays.copyOf(original, original.length + 1);
+    result[original.length] = newElement;
+    return castNonNullTypeArray(result);
+  }
+
+  /**
+   * Creates a new array containing the concatenation of two non-null type arrays.
    *
    * @param first The first array.
    * @param second The second array.
@@ -1239,9 +1252,9 @@ public static String getUserAgent(Context context, String applicationName) {
    * @param codecs A codec sequence string, as defined in RFC 6381.
    * @param trackType One of {@link C}{@code .TRACK_TYPE_*}.
    * @return A copy of {@code codecs} without the codecs whose track type doesn't match {@code
-   *     trackType}.
+   *     trackType}. If this ends up empty, or {@code codecs} is null, return null.
    */
-  public static @Nullable String getCodecsOfType(String codecs, int trackType) {
+  public static @Nullable String getCodecsOfType(@Nullable String codecs, int trackType) {
     String[] codecArray = splitCodecs(codecs);
     if (codecArray.length == 0) {
       return null;
@@ -1262,9 +1275,9 @@ public static String getUserAgent(Context context, String applicationName) {
    * Splits a codecs sequence string, as defined in RFC 6381, into individual codec strings.
    *
    * @param codecs A codec sequence string, as defined in RFC 6381.
-   * @return The split codecs, or an array of length zero if the input was empty.
+   * @return The split codecs, or an array of length zero if the input was empty or null.
    */
-  public static String[] splitCodecs(String codecs) {
+  public static String[] splitCodecs(@Nullable String codecs) {
     if (TextUtils.isEmpty(codecs)) {
       return new String[0];
     }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
index 2495c8439f..8db6166bb8 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
@@ -185,8 +185,8 @@ public Result createExtractor(
   private Extractor createExtractorByFileExtension(
       Uri uri,
       Format format,
-      List<Format> muxedCaptionFormats,
-      DrmInitData drmInitData,
+      @Nullable List<Format> muxedCaptionFormats,
+      @Nullable DrmInitData drmInitData,
       TimestampAdjuster timestampAdjuster) {
     String lastPathSegment = uri.getLastPathSegment();
     if (lastPathSegment == null) {
@@ -226,7 +226,7 @@ private static TsExtractor createTsExtractor(
       @DefaultTsPayloadReaderFactory.Flags int userProvidedPayloadReaderFactoryFlags,
       boolean exposeCea608WhenMissingDeclarations,
       Format format,
-      List<Format> muxedCaptionFormats,
+      @Nullable List<Format> muxedCaptionFormats,
       TimestampAdjuster timestampAdjuster) {
     @DefaultTsPayloadReaderFactory.Flags
     int payloadReaderFactoryFlags =
@@ -270,26 +270,34 @@ private static TsExtractor createTsExtractor(
   private static FragmentedMp4Extractor createFragmentedMp4Extractor(
       TimestampAdjuster timestampAdjuster,
       Format format,
-      DrmInitData drmInitData,
+      @Nullable DrmInitData drmInitData,
       @Nullable List<Format> muxedCaptionFormats) {
-    boolean isVariant = false;
-    for (int i = 0; i < format.metadata.length(); i++) {
-      Metadata.Entry entry = format.metadata.get(i);
-      if (entry instanceof HlsTrackMetadataEntry) {
-        isVariant = !((HlsTrackMetadataEntry) entry).variantInfos.isEmpty();
-        break;
-      }
-    }
     // Only enable the EMSG TrackOutput if this is the 'variant' track (i.e. the main one) to avoid
     // creating a separate EMSG track for every audio track in a video stream.
     return new FragmentedMp4Extractor(
-        /* flags= */ isVariant ? FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK : 0,
+        /* flags= */ isFmp4Variant(format) ? FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK : 0,
         timestampAdjuster,
         /* sideloadedTrack= */ null,
         drmInitData,
         muxedCaptionFormats != null ? muxedCaptionFormats : Collections.emptyList());
   }
 
+  /** Returns true if this {@code format} represents a 'variant' track (i.e. the main one). */
+  private static boolean isFmp4Variant(Format format) {
+    Metadata metadata = format.metadata;
+    if (metadata == null) {
+      return false;
+    }
+    for (int i = 0; i < metadata.length(); i++) {
+      Metadata.Entry entry = metadata.get(i);
+      if (entry instanceof HlsTrackMetadataEntry) {
+        return !((HlsTrackMetadataEntry) entry).variantInfos.isEmpty();
+      }
+    }
+    return false;
+  }
+
+  @Nullable
   private static Result buildResultForSameExtractorType(
       Extractor previousExtractor, Format format, TimestampAdjuster timestampAdjuster) {
     if (previousExtractor instanceof WebvttExtractor) {
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 26c1a2219b..a55d1ac249 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.id3.Id3Decoder;
 import com.google.android.exoplayer2.metadata.id3.PrivFrame;
@@ -30,6 +31,7 @@
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.UriUtil;
@@ -39,6 +41,9 @@
 import java.math.BigInteger;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /**
  * An HLS {@link MediaChunk}.
@@ -93,7 +98,9 @@ public static HlsMediaChunk createInstance(
             /* key= */ null);
     boolean mediaSegmentEncrypted = mediaSegmentKey != null;
     byte[] mediaSegmentIv =
-        mediaSegmentEncrypted ? getEncryptionIvArray(mediaSegment.encryptionIV) : null;
+        mediaSegmentEncrypted
+            ? getEncryptionIvArray(Assertions.checkNotNull(mediaSegment.encryptionIV))
+            : null;
     DataSource mediaDataSource = buildDataSource(dataSource, mediaSegmentKey, mediaSegmentIv);
 
     // Init segment.
@@ -104,7 +111,9 @@ public static HlsMediaChunk createInstance(
     if (initSegment != null) {
       initSegmentEncrypted = initSegmentKey != null;
       byte[] initSegmentIv =
-          initSegmentEncrypted ? getEncryptionIvArray(initSegment.encryptionIV) : null;
+          initSegmentEncrypted
+              ? getEncryptionIvArray(Assertions.checkNotNull(initSegment.encryptionIV))
+              : null;
       Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
       initDataSpec =
           new DataSpec(
@@ -170,6 +179,7 @@ public static HlsMediaChunk createInstance(
 
   public static final String PRIV_TIMESTAMP_FRAME_OWNER =
       "com.apple.streaming.transportStreamTimestamp";
+  private static final PositionHolder DUMMY_POSITION_HOLDER = new PositionHolder();
 
   private static final AtomicInteger uidSource = new AtomicInteger();
 
@@ -186,8 +196,12 @@ public static HlsMediaChunk createInstance(
   /** The url of the playlist from which this chunk was obtained. */
   public final Uri playlistUrl;
 
-  @Nullable private final DataSource initDataSource;
-  @Nullable private final DataSpec initDataSpec;
+  // These should be final, but can't be due to
+  // https://github.com/typetools/checker-framework/issues/2215
+  @MonotonicNonNull private DataSource initDataSource;
+  @MonotonicNonNull private DataSpec initDataSpec;
+  @MonotonicNonNull private Extractor previousExtractor;
+
   private final boolean isMasterTimestampSource;
   private final boolean hasGapTag;
   private final TimestampAdjuster timestampAdjuster;
@@ -195,15 +209,14 @@ public static HlsMediaChunk createInstance(
   private final HlsExtractorFactory extractorFactory;
   @Nullable private final List<Format> muxedCaptionFormats;
   @Nullable private final DrmInitData drmInitData;
-  @Nullable private final Extractor previousExtractor;
   private final Id3Decoder id3Decoder;
   private final ParsableByteArray scratchId3Data;
   private final boolean mediaSegmentEncrypted;
   private final boolean initSegmentEncrypted;
 
-  private Extractor extractor;
+  @MonotonicNonNull private Extractor extractor;
   private boolean isExtractorReusable;
-  private HlsSampleStreamWrapper output;
+  @MonotonicNonNull private HlsSampleStreamWrapper output;
   // nextLoadPosition refers to the init segment if initDataLoadRequired is true.
   // Otherwise, nextLoadPosition refers to the media segment.
   private int nextLoadPosition;
@@ -217,13 +230,13 @@ private HlsMediaChunk(
       DataSpec dataSpec,
       Format format,
       boolean mediaSegmentEncrypted,
-      DataSource initDataSource,
+      @Nullable DataSource initDataSource,
       @Nullable DataSpec initDataSpec,
       boolean initSegmentEncrypted,
       Uri playlistUrl,
       @Nullable List<Format> muxedCaptionFormats,
       int trackSelectionReason,
-      Object trackSelectionData,
+      @Nullable Object trackSelectionData,
       long startTimeUs,
       long endTimeUs,
       long chunkMediaSequence,
@@ -247,8 +260,12 @@ private HlsMediaChunk(
         chunkMediaSequence);
     this.mediaSegmentEncrypted = mediaSegmentEncrypted;
     this.discontinuitySequenceNumber = discontinuitySequenceNumber;
-    this.initDataSource = initDataSource;
-    this.initDataSpec = initDataSpec;
+    // Workaround for https://github.com/typetools/checker-framework/issues/2215
+    if (initDataSpec != null) {
+      this.initDataSpec = initDataSpec;
+      this.initDataSource = Assertions.checkNotNull(initDataSource);
+      initDataLoadRequired = true;
+    }
     this.initSegmentEncrypted = initSegmentEncrypted;
     this.playlistUrl = playlistUrl;
     this.isMasterTimestampSource = isMasterTimestampSource;
@@ -257,11 +274,13 @@ private HlsMediaChunk(
     this.extractorFactory = extractorFactory;
     this.muxedCaptionFormats = muxedCaptionFormats;
     this.drmInitData = drmInitData;
-    this.previousExtractor = previousExtractor;
+    // Workaround for https://github.com/typetools/checker-framework/issues/2215
+    if (previousExtractor != null) {
+      this.previousExtractor = previousExtractor;
+    }
     this.id3Decoder = id3Decoder;
     this.scratchId3Data = scratchId3Data;
     this.shouldSpliceIn = shouldSpliceIn;
-    initDataLoadRequired = initDataSpec != null;
     uid = uidSource.getAndIncrement();
   }
 
@@ -289,6 +308,8 @@ public void cancelLoad() {
 
   @Override
   public void load() throws IOException, InterruptedException {
+    // output == null means init() hasn't been called.
+    Assertions.checkNotNull(output);
     if (extractor == null && previousExtractor != null) {
       extractor = previousExtractor;
       isExtractorReusable = true;
@@ -306,15 +327,20 @@ public void load() throws IOException, InterruptedException {
 
   // Internal methods.
 
+  @RequiresNonNull("output")
   private void maybeLoadInitData() throws IOException, InterruptedException {
     if (!initDataLoadRequired) {
       return;
     }
+    // initDataLoadRequired =>  initDataSource != null && initDataSpec != null
+    Assertions.checkNotNull(initDataSource);
+    Assertions.checkNotNull(initDataSpec);
     feedDataToExtractor(initDataSource, initDataSpec, initSegmentEncrypted);
     nextLoadPosition = 0;
     initDataLoadRequired = false;
   }
 
+  @RequiresNonNull("output")
   private void loadMedia() throws IOException, InterruptedException {
     if (!isMasterTimestampSource) {
       timestampAdjuster.waitUntilInitialized();
@@ -330,6 +356,7 @@ private void loadMedia() throws IOException, InterruptedException {
    * concludes (because of a thrown exception or because the operation finishes), the number of fed
    * bytes is written to {@code nextLoadPosition}.
    */
+  @RequiresNonNull("output")
   private void feedDataToExtractor(
       DataSource dataSource, DataSpec dataSpec, boolean dataIsEncrypted)
       throws IOException, InterruptedException {
@@ -354,7 +381,7 @@ private void feedDataToExtractor(
       try {
         int result = Extractor.RESULT_CONTINUE;
         while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractor.read(input, /* seekPosition= */ null);
+          result = extractor.read(input, DUMMY_POSITION_HOLDER);
         }
       } finally {
         nextLoadPosition = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
@@ -364,6 +391,8 @@ private void feedDataToExtractor(
     }
   }
 
+  @RequiresNonNull("output")
+  @EnsuresNonNull("extractor")
   private DefaultExtractorInput prepareExtraction(DataSource dataSource, DataSpec dataSpec)
       throws IOException, InterruptedException {
     long bytesToRead = dataSource.open(dataSpec);
@@ -483,10 +512,15 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
   /**
    * If the segment is fully encrypted, returns an {@link Aes128DataSource} that wraps the original
    * in order to decrypt the loaded data. Else returns the original.
+   *
+   * <p>{@code fullSegmentEncryptionKey} & {@code encryptionIv} can either both be null, or neither.
    */
-  private static DataSource buildDataSource(DataSource dataSource, byte[] fullSegmentEncryptionKey,
-      byte[] encryptionIv) {
+  private static DataSource buildDataSource(
+      DataSource dataSource,
+      @Nullable byte[] fullSegmentEncryptionKey,
+      @Nullable byte[] encryptionIv) {
     if (fullSegmentEncryptionKey != null) {
+      Assertions.checkNotNull(encryptionIv);
       return new Aes128DataSource(dataSource, fullSegmentEncryptionKey, encryptionIv);
     }
     return dataSource;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index 749ce74d96..6aaf204c2c 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -65,7 +65,9 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import org.checkerframework.checker.nullness.compatqual.NullableType;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.RequiresNonNull;
 
 /**
  * Loads {@link HlsMediaChunk}s obtained from a {@link HlsChunkSource}, and provides
@@ -127,20 +129,20 @@
   private int[] sampleQueueTrackIds;
   private Set<Integer> sampleQueueMappingDoneByType;
   private SparseIntArray sampleQueueIndicesByType;
-  private TrackOutput emsgUnwrappingTrackOutput;
+  @MonotonicNonNull private TrackOutput emsgUnwrappingTrackOutput;
   private int primarySampleQueueType;
   private int primarySampleQueueIndex;
   private boolean sampleQueuesBuilt;
   private boolean prepared;
   private int enabledTrackGroupCount;
-  private Format upstreamTrackFormat;
-  private Format downstreamTrackFormat;
+  @MonotonicNonNull private Format upstreamTrackFormat;
+  @Nullable private Format downstreamTrackFormat;
   private boolean released;
 
   // Tracks are complicated in HLS. See documentation of buildTracksFromSampleStreams for details.
   // Indexed by track (as exposed by this source).
-  private TrackGroupArray trackGroups;
-  private Set<TrackGroup> optionalTrackGroups;
+  @MonotonicNonNull private TrackGroupArray trackGroups;
+  @MonotonicNonNull private Set<TrackGroup> optionalTrackGroups;
   // Indexed by track group.
   private int[] trackGroupToSampleQueueIndex;
   private int primaryTrackGroupIndex;
@@ -294,15 +296,21 @@ public void unbindSampleQueue(int trackGroupIndex) {
    * @return Whether this wrapper requires the parent {@link HlsMediaPeriod} to perform a seek as
    *     part of the track selection.
    */
-  public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-      SampleStream[] streams, boolean[] streamResetFlags, long positionUs, boolean forceReset) {
+  public boolean selectTracks(
+      TrackSelection[] selections,
+      boolean[] mayRetainStreamFlags,
+      @NullableType SampleStream[] streams,
+      boolean[] streamResetFlags,
+      long positionUs,
+      boolean forceReset) {
     Assertions.checkState(prepared);
     int oldEnabledTrackGroupCount = enabledTrackGroupCount;
     // Deselect old tracks.
     for (int i = 0; i < selections.length; i++) {
-      if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
+      HlsSampleStream stream = (HlsSampleStream) streams[i];
+      if (stream != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
         enabledTrackGroupCount--;
-        ((HlsSampleStream) streams[i]).unbindSampleQueue();
+        stream.unbindSampleQueue();
         streams[i] = null;
       }
     }
@@ -536,7 +544,7 @@ public int readData(int sampleQueueIndex, FormatHolder formatHolder, DecoderInpu
         sampleQueueReaders[sampleQueueIndex].read(
             formatHolder, buffer, requireFormat, loadingFinished, lastSeekPositionUs);
     if (result == C.RESULT_FORMAT_READ) {
-      Format format = formatHolder.format;
+      Format format = Assertions.checkNotNull(formatHolder.format);
       if (sampleQueueIndex == primarySampleQueueIndex) {
         // Fill in primary sample format with information from the track format.
         int chunkUid = sampleQueues[sampleQueueIndex].peekSourceId();
@@ -897,11 +905,11 @@ private SampleQueue createSampleQueue(int id, int type) {
     trackOutput.setUpstreamFormatChangeListener(this);
     sampleQueueTrackIds = Arrays.copyOf(sampleQueueTrackIds, trackCount + 1);
     sampleQueueTrackIds[trackCount] = id;
-    sampleQueues = Arrays.copyOf(sampleQueues, trackCount + 1);
-    sampleQueues[trackCount] = trackOutput;
-    sampleQueueReaders = Arrays.copyOf(sampleQueueReaders, trackCount + 1);
-    sampleQueueReaders[trackCount] =
-        new DecryptableSampleQueueReader(sampleQueues[trackCount], drmSessionManager);
+    sampleQueues = Util.nullSafeArrayAppend(sampleQueues, trackOutput);
+    sampleQueueReaders =
+        Util.nullSafeArrayAppend(
+            sampleQueueReaders,
+            new DecryptableSampleQueueReader(sampleQueues[trackCount], drmSessionManager));
     sampleQueueIsAudioVideoFlags = Arrays.copyOf(sampleQueueIsAudioVideoFlags, trackCount + 1);
     sampleQueueIsAudioVideoFlags[trackCount] =
         type == C.TRACK_TYPE_AUDIO || type == C.TRACK_TYPE_VIDEO;
@@ -945,7 +953,7 @@ public void setSampleOffsetUs(long sampleOffsetUs) {
 
   // Internal methods.
 
-  private void updateSampleStreams(SampleStream[] streams) {
+  private void updateSampleStreams(@NullableType SampleStream[] streams) {
     hlsSampleStreams.clear();
     for (SampleStream stream : streams) {
       if (stream != null) {
@@ -998,6 +1006,7 @@ private void maybeFinishPrepare() {
     }
   }
 
+  @RequiresNonNull("trackGroups")
   private void mapSampleQueuesToMatchTrackGroups() {
     int trackGroupCount = trackGroups.length;
     trackGroupToSampleQueueIndex = new int[trackGroupCount];
@@ -1195,7 +1204,7 @@ private static int getTrackTypeScore(int trackType) {
    * @return The derived track format.
    */
   private static Format deriveFormat(
-      Format playlistFormat, Format sampleFormat, boolean propagateBitrate) {
+      @Nullable Format playlistFormat, Format sampleFormat, boolean propagateBitrate) {
     if (playlistFormat == null) {
       return sampleFormat;
     }
@@ -1383,7 +1392,7 @@ public void sampleMetadata(
         int size,
         int offset,
         @Nullable CryptoData cryptoData) {
-      Assertions.checkState(format != null);
+      Assertions.checkNotNull(format);
       ParsableByteArray sample = getSampleAndTrimBuffer(size, offset);
       ParsableByteArray sampleForDelegate;
       if (Util.areEqual(format.sampleMimeType, delegateFormat.sampleMimeType)) {
