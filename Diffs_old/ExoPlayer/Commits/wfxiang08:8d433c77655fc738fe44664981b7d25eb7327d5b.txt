diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
index cb9e41aa62..a81d510750 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/DefaultTrackOutput.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -36,677 +37,179 @@
  */
 public final class DefaultTrackOutput implements TrackOutput {
 
-  /**
-   * A listener for changes to the upstream format.
-   */
-  public interface UpstreamFormatChangedListener {
+    /**
+     * A listener for changes to the upstream format.
+     */
+    public interface UpstreamFormatChangedListener {
+
+        /**
+         * Called on the loading thread when an upstream format change occurs.
+         *
+         * @param format The new upstream format.
+         */
+        void onUpstreamFormatChanged(Format format);
+
+    }
+
+    private static final int INITIAL_SCRATCH_SIZE = 32;
+
+    private static final int STATE_ENABLED = 0;
+    private static final int STATE_ENABLED_WRITING = 1;
+    private static final int STATE_DISABLED = 2;
+
+    private final Allocator allocator;
+    private final int allocationLength;
+
+    private final InfoQueue infoQueue;
+    private final LinkedBlockingDeque<Allocation> dataQueue;
+    private final BufferExtrasHolder extrasHolder;
+    private final ParsableByteArray scratch;
+    private final AtomicInteger state;
+
+    // Accessed only by the consuming thread.
+    private long totalBytesDropped;
+    private Format downstreamFormat;
+
+    // Accessed only by the loading thread (or the consuming thread when there is no loading thread).
+    private long sampleOffsetUs;
+    private long totalBytesWritten;
+    private Allocation lastAllocation;
+    private int lastAllocationOffset;
+    private boolean needKeyframe;
+    private boolean pendingSplice;
+    private UpstreamFormatChangedListener upstreamFormatChangeListener;
 
     /**
-     * Called on the loading thread when an upstream format change occurs.
-     *
-     * @param format The new upstream format.
+     * @param allocator An {@link Allocator} from which allocations for sample data can be obtained.
      */
-    void onUpstreamFormatChanged(Format format);
-
-  }
-
-  private static final int INITIAL_SCRATCH_SIZE = 32;
-
-  private static final int STATE_ENABLED = 0;
-  private static final int STATE_ENABLED_WRITING = 1;
-  private static final int STATE_DISABLED = 2;
-
-  private final Allocator allocator;
-  private final int allocationLength;
-
-  private final InfoQueue infoQueue;
-  private final LinkedBlockingDeque<Allocation> dataQueue;
-  private final BufferExtrasHolder extrasHolder;
-  private final ParsableByteArray scratch;
-  private final AtomicInteger state;
-
-  // Accessed only by the consuming thread.
-  private long totalBytesDropped;
-  private Format downstreamFormat;
-
-  // Accessed only by the loading thread (or the consuming thread when there is no loading thread).
-  private long sampleOffsetUs;
-  private long totalBytesWritten;
-  private Allocation lastAllocation;
-  private int lastAllocationOffset;
-  private boolean needKeyframe;
-  private boolean pendingSplice;
-  private UpstreamFormatChangedListener upstreamFormatChangeListener;
-
-  /**
-   * @param allocator An {@link Allocator} from which allocations for sample data can be obtained.
-   */
-  public DefaultTrackOutput(Allocator allocator) {
-    this.allocator = allocator;
-    allocationLength = allocator.getIndividualAllocationLength();
-    infoQueue = new InfoQueue();
-    dataQueue = new LinkedBlockingDeque<>();
-    extrasHolder = new BufferExtrasHolder();
-    scratch = new ParsableByteArray(INITIAL_SCRATCH_SIZE);
-    state = new AtomicInteger();
-    lastAllocationOffset = allocationLength;
-    needKeyframe = true;
-  }
-
-  // Called by the consuming thread, but only when there is no loading thread.
-
-  /**
-   * Resets the output.
-   *
-   * @param enable Whether the output should be enabled. False if it should be disabled.
-   */
-  public void reset(boolean enable) {
-    int previousState = state.getAndSet(enable ? STATE_ENABLED : STATE_DISABLED);
-    clearSampleData();
-    infoQueue.resetLargestParsedTimestamps();
-    if (previousState == STATE_DISABLED) {
-      downstreamFormat = null;
-    }
-  }
-
-  /**
-   * Sets a source identifier for subsequent samples.
-   *
-   * @param sourceId The source identifier.
-   */
-  public void sourceId(int sourceId) {
-    infoQueue.sourceId(sourceId);
-  }
-
-  /**
-   * Indicates that samples subsequently queued to the buffer should be spliced into those already
-   * queued.
-   */
-  public void splice() {
-    pendingSplice = true;
-  }
-
-  /**
-   * Returns the current absolute write index.
-   */
-  public int getWriteIndex() {
-    return infoQueue.getWriteIndex();
-  }
-
-  /**
-   * Discards samples from the write side of the buffer.
-   *
-   * @param discardFromIndex The absolute index of the first sample to be discarded.
-   */
-  public void discardUpstreamSamples(int discardFromIndex) {
-    totalBytesWritten = infoQueue.discardUpstreamSamples(discardFromIndex);
-    dropUpstreamFrom(totalBytesWritten);
-  }
-
-  /**
-   * Discards data from the write side of the buffer. Data is discarded from the specified absolute
-   * position. Any allocations that are fully discarded are returned to the allocator.
-   *
-   * @param absolutePosition The absolute position (inclusive) from which to discard data.
-   */
-  private void dropUpstreamFrom(long absolutePosition) {
-    int relativePosition = (int) (absolutePosition - totalBytesDropped);
-    // Calculate the index of the allocation containing the position, and the offset within it.
-    int allocationIndex = relativePosition / allocationLength;
-    int allocationOffset = relativePosition % allocationLength;
-    // We want to discard any allocations after the one at allocationIdnex.
-    int allocationDiscardCount = dataQueue.size() - allocationIndex - 1;
-    if (allocationOffset == 0) {
-      // If the allocation at allocationIndex is empty, we should discard that one too.
-      allocationDiscardCount++;
-    }
-    // Discard the allocations.
-    for (int i = 0; i < allocationDiscardCount; i++) {
-      allocator.release(dataQueue.removeLast());
-    }
-    // Update lastAllocation and lastAllocationOffset to reflect the new position.
-    lastAllocation = dataQueue.peekLast();
-    lastAllocationOffset = allocationOffset == 0 ? allocationLength : allocationOffset;
-  }
-
-  // Called by the consuming thread.
-
-  /**
-   * Disables buffering of sample data and metadata.
-   */
-  public void disable() {
-    if (state.getAndSet(STATE_DISABLED) == STATE_ENABLED) {
-      clearSampleData();
-    }
-  }
-
-  /**
-   * Returns whether the buffer is empty.
-   */
-  public boolean isEmpty() {
-    return infoQueue.isEmpty();
-  }
-
-  /**
-   * Returns the current absolute read index.
-   */
-  public int getReadIndex() {
-    return infoQueue.getReadIndex();
-  }
-
-  /**
-   * Peeks the source id of the next sample, or the current upstream source id if the buffer is
-   * empty.
-   *
-   * @return The source id.
-   */
-  public int peekSourceId() {
-    return infoQueue.peekSourceId();
-  }
-
-  /**
-   * Returns the upstream {@link Format} in which samples are being queued.
-   */
-  public Format getUpstreamFormat() {
-    return infoQueue.getUpstreamFormat();
-  }
-
-  /**
-   * Returns the largest sample timestamp that has been queued since the last {@link #reset}.
-   * <p>
-   * Samples that were discarded by calling {@link #discardUpstreamSamples(int)} are not
-   * considered as having been queued. Samples that were dequeued from the front of the queue are
-   * considered as having been queued.
-   *
-   * @return The largest sample timestamp that has been queued, or {@link Long#MIN_VALUE} if no
-   *     samples have been queued.
-   */
-  public long getLargestQueuedTimestampUs() {
-    return infoQueue.getLargestQueuedTimestampUs();
-  }
-
-  /**
-   * Attempts to skip to the keyframe before the specified time, if it's present in the buffer.
-   *
-   * @param timeUs The seek time.
-   * @return Whether the skip was successful.
-   */
-  public boolean skipToKeyframeBefore(long timeUs) {
-    long nextOffset = infoQueue.skipToKeyframeBefore(timeUs);
-    if (nextOffset == C.POSITION_UNSET) {
-      return false;
-    }
-    dropDownstreamTo(nextOffset);
-    return true;
-  }
-
-  /**
-   * Attempts to read from the queue.
-   *
-   * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
-   * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
-   *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
-   * @param loadingFinished True if an empty queue should be considered the end of the stream.
-   * @param decodeOnlyUntilUs If a buffer is read, the {@link C#BUFFER_FLAG_DECODE_ONLY} flag will
-   *     be set if the buffer's timestamp is less than this value.
-   * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
-   *     {@link C#RESULT_BUFFER_READ}.
-   */
-  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean loadingFinished,
-      long decodeOnlyUntilUs) {
-    switch (infoQueue.readData(formatHolder, buffer, downstreamFormat, extrasHolder)) {
-      case C.RESULT_NOTHING_READ:
-        if (loadingFinished) {
-          buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
-          return C.RESULT_BUFFER_READ;
-        }
-        return C.RESULT_NOTHING_READ;
-      case C.RESULT_FORMAT_READ:
-        downstreamFormat = formatHolder.format;
-        return C.RESULT_FORMAT_READ;
-      case C.RESULT_BUFFER_READ:
-        if (buffer.timeUs < decodeOnlyUntilUs) {
-          buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
-        }
-        // Read encryption data if the sample is encrypted.
-        if (buffer.isEncrypted()) {
-          readEncryptionData(buffer, extrasHolder);
-        }
-        // Write the sample data into the holder.
-        buffer.ensureSpaceForWrite(extrasHolder.size);
-        readData(extrasHolder.offset, buffer.data, extrasHolder.size);
-        // Advance the read head.
-        dropDownstreamTo(extrasHolder.nextOffset);
-        return C.RESULT_BUFFER_READ;
-      default:
-        throw new IllegalStateException();
-    }
-  }
-
-  /**
-   * Reads encryption data for the current sample.
-   * <p>
-   * The encryption data is written into {@link DecoderInputBuffer#cryptoInfo}, and
-   * {@link BufferExtrasHolder#size} is adjusted to subtract the number of bytes that were read. The
-   * same value is added to {@link BufferExtrasHolder#offset}.
-   *
-   * @param buffer The buffer into which the encryption data should be written.
-   * @param extrasHolder The extras holder whose offset should be read and subsequently adjusted.
-   */
-  private void readEncryptionData(DecoderInputBuffer buffer, BufferExtrasHolder extrasHolder) {
-    long offset = extrasHolder.offset;
-
-    // Read the signal byte.
-    scratch.reset(1);
-    readData(offset, scratch.data, 1);
-    offset++;
-    byte signalByte = scratch.data[0];
-    boolean subsampleEncryption = (signalByte & 0x80) != 0;
-    int ivSize = signalByte & 0x7F;
-
-    // Read the initialization vector.
-    if (buffer.cryptoInfo.iv == null) {
-      buffer.cryptoInfo.iv = new byte[16];
-    }
-    readData(offset, buffer.cryptoInfo.iv, ivSize);
-    offset += ivSize;
-
-    // Read the subsample count, if present.
-    int subsampleCount;
-    if (subsampleEncryption) {
-      scratch.reset(2);
-      readData(offset, scratch.data, 2);
-      offset += 2;
-      subsampleCount = scratch.readUnsignedShort();
-    } else {
-      subsampleCount = 1;
-    }
-
-    // Write the clear and encrypted subsample sizes.
-    int[] clearDataSizes = buffer.cryptoInfo.numBytesOfClearData;
-    if (clearDataSizes == null || clearDataSizes.length < subsampleCount) {
-      clearDataSizes = new int[subsampleCount];
-    }
-    int[] encryptedDataSizes = buffer.cryptoInfo.numBytesOfEncryptedData;
-    if (encryptedDataSizes == null || encryptedDataSizes.length < subsampleCount) {
-      encryptedDataSizes = new int[subsampleCount];
-    }
-    if (subsampleEncryption) {
-      int subsampleDataLength = 6 * subsampleCount;
-      scratch.reset(subsampleDataLength);
-      readData(offset, scratch.data, subsampleDataLength);
-      offset += subsampleDataLength;
-      scratch.setPosition(0);
-      for (int i = 0; i < subsampleCount; i++) {
-        clearDataSizes[i] = scratch.readUnsignedShort();
-        encryptedDataSizes[i] = scratch.readUnsignedIntToInt();
-      }
-    } else {
-      clearDataSizes[0] = 0;
-      encryptedDataSizes[0] = extrasHolder.size - (int) (offset - extrasHolder.offset);
-    }
-
-    // Populate the cryptoInfo.
-    buffer.cryptoInfo.set(subsampleCount, clearDataSizes, encryptedDataSizes,
-        extrasHolder.encryptionKeyId, buffer.cryptoInfo.iv, C.CRYPTO_MODE_AES_CTR);
-
-    // Adjust the offset and size to take into account the bytes read.
-    int bytesRead = (int) (offset - extrasHolder.offset);
-    extrasHolder.offset += bytesRead;
-    extrasHolder.size -= bytesRead;
-  }
-
-  /**
-   * Reads data from the front of the rolling buffer.
-   *
-   * @param absolutePosition The absolute position from which data should be read.
-   * @param target The buffer into which data should be written.
-   * @param length The number of bytes to read.
-   */
-  private void readData(long absolutePosition, ByteBuffer target, int length) {
-    int remaining = length;
-    while (remaining > 0) {
-      dropDownstreamTo(absolutePosition);
-      int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
-      int toCopy = Math.min(remaining, allocationLength - positionInAllocation);
-      Allocation allocation = dataQueue.peek();
-      target.put(allocation.data, allocation.translateOffset(positionInAllocation), toCopy);
-      absolutePosition += toCopy;
-      remaining -= toCopy;
-    }
-  }
-
-  /**
-   * Reads data from the front of the rolling buffer.
-   *
-   * @param absolutePosition The absolute position from which data should be read.
-   * @param target The array into which data should be written.
-   * @param length The number of bytes to read.
-   */
-  private void readData(long absolutePosition, byte[] target, int length) {
-    int bytesRead = 0;
-    while (bytesRead < length) {
-      dropDownstreamTo(absolutePosition);
-      int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
-      int toCopy = Math.min(length - bytesRead, allocationLength - positionInAllocation);
-      Allocation allocation = dataQueue.peek();
-      System.arraycopy(allocation.data, allocation.translateOffset(positionInAllocation), target,
-          bytesRead, toCopy);
-      absolutePosition += toCopy;
-      bytesRead += toCopy;
-    }
-  }
-
-  /**
-   * Discard any allocations that hold data prior to the specified absolute position, returning
-   * them to the allocator.
-   *
-   * @param absolutePosition The absolute position up to which allocations can be discarded.
-   */
-  private void dropDownstreamTo(long absolutePosition) {
-    int relativePosition = (int) (absolutePosition - totalBytesDropped);
-    int allocationIndex = relativePosition / allocationLength;
-    for (int i = 0; i < allocationIndex; i++) {
-      allocator.release(dataQueue.remove());
-      totalBytesDropped += allocationLength;
-    }
-  }
-
-  // Called by the loading thread.
-
-  /**
-   * Sets a listener to be notified of changes to the upstream format.
-   *
-   * @param listener The listener.
-   */
-  public void setUpstreamFormatChangeListener(UpstreamFormatChangedListener listener) {
-    upstreamFormatChangeListener = listener;
-  }
-
-  /**
-   * Like {@link #format(Format)}, but with an offset that will be added to the timestamps of
-   * samples subsequently queued to the buffer. The offset is also used to adjust
-   * {@link Format#subsampleOffsetUs} for both the {@link Format} passed and those subsequently
-   * passed to {@link #format(Format)}.
-   *
-   * @param format The format.
-   * @param sampleOffsetUs The timestamp offset in microseconds.
-   */
-  public void formatWithOffset(Format format, long sampleOffsetUs) {
-    this.sampleOffsetUs = sampleOffsetUs;
-    format(format);
-  }
-
-  @Override
-  public void format(Format format) {
-    Format adjustedFormat = getAdjustedSampleFormat(format, sampleOffsetUs);
-    boolean formatChanged = infoQueue.format(adjustedFormat);
-    if (upstreamFormatChangeListener != null && formatChanged) {
-      upstreamFormatChangeListener.onUpstreamFormatChanged(adjustedFormat);
-    }
-  }
-
-  @Override
-  public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
-      throws IOException, InterruptedException {
-    if (!startWriteOperation()) {
-      int bytesSkipped = input.skip(length);
-      if (bytesSkipped == C.RESULT_END_OF_INPUT) {
-        if (allowEndOfInput) {
-          return C.RESULT_END_OF_INPUT;
-        }
-        throw new EOFException();
-      }
-      return bytesSkipped;
-    }
-    try {
-      length = prepareForAppend(length);
-      int bytesAppended = input.read(lastAllocation.data,
-          lastAllocation.translateOffset(lastAllocationOffset), length);
-      if (bytesAppended == C.RESULT_END_OF_INPUT) {
-        if (allowEndOfInput) {
-          return C.RESULT_END_OF_INPUT;
-        }
-        throw new EOFException();
-      }
-      lastAllocationOffset += bytesAppended;
-      totalBytesWritten += bytesAppended;
-      return bytesAppended;
-    } finally {
-      endWriteOperation();
-    }
-  }
-
-  @Override
-  public void sampleData(ParsableByteArray buffer, int length) {
-    if (!startWriteOperation()) {
-      buffer.skipBytes(length);
-      return;
-    }
-    while (length > 0) {
-      int thisAppendLength = prepareForAppend(length);
-      buffer.readBytes(lastAllocation.data, lastAllocation.translateOffset(lastAllocationOffset),
-          thisAppendLength);
-      lastAllocationOffset += thisAppendLength;
-      totalBytesWritten += thisAppendLength;
-      length -= thisAppendLength;
-    }
-    endWriteOperation();
-  }
-
-  @Override
-  public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
-      byte[] encryptionKey) {
-    if (!startWriteOperation()) {
-      infoQueue.commitSampleTimestamp(timeUs);
-      return;
-    }
-    try {
-      if (pendingSplice) {
-        if ((flags & C.BUFFER_FLAG_KEY_FRAME) == 0 || !infoQueue.attemptSplice(timeUs)) {
-          return;
-        }
-        pendingSplice = false;
-      }
-      if (needKeyframe) {
-        if ((flags & C.BUFFER_FLAG_KEY_FRAME) == 0) {
-          return;
-        }
-        needKeyframe = false;
-      }
-      timeUs += sampleOffsetUs;
-      long absoluteOffset = totalBytesWritten - size - offset;
-      infoQueue.commitSample(timeUs, flags, absoluteOffset, size, encryptionKey);
-    } finally {
-      endWriteOperation();
-    }
-  }
-
-  // Private methods.
-
-  private boolean startWriteOperation() {
-    return state.compareAndSet(STATE_ENABLED, STATE_ENABLED_WRITING);
-  }
-
-  private void endWriteOperation() {
-    if (!state.compareAndSet(STATE_ENABLED_WRITING, STATE_ENABLED)) {
-      clearSampleData();
-    }
-  }
-
-  private void clearSampleData() {
-    infoQueue.clearSampleData();
-    allocator.release(dataQueue.toArray(new Allocation[dataQueue.size()]));
-    dataQueue.clear();
-    allocator.trim();
-    totalBytesDropped = 0;
-    totalBytesWritten = 0;
-    lastAllocation = null;
-    lastAllocationOffset = allocationLength;
-    needKeyframe = true;
-  }
-
-  /**
-   * Prepares the rolling sample buffer for an append of up to {@code length} bytes, returning the
-   * number of bytes that can actually be appended.
-   */
-  private int prepareForAppend(int length) {
-    if (lastAllocationOffset == allocationLength) {
-      lastAllocationOffset = 0;
-      lastAllocation = allocator.allocate();
-      dataQueue.add(lastAllocation);
-    }
-    return Math.min(length, allocationLength - lastAllocationOffset);
-  }
-
-  /**
-   * Adjusts a {@link Format} to incorporate a sample offset into {@link Format#subsampleOffsetUs}.
-   *
-   * @param format The {@link Format} to adjust.
-   * @param sampleOffsetUs The offset to apply.
-   * @return The adjusted {@link Format}.
-   */
-  private static Format getAdjustedSampleFormat(Format format, long sampleOffsetUs) {
-    if (format == null) {
-      return null;
-    }
-    if (sampleOffsetUs != 0 && format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {
-      format = format.copyWithSubsampleOffsetUs(format.subsampleOffsetUs + sampleOffsetUs);
-    }
-    return format;
-  }
-
-  /**
-   * Holds information about the samples in the rolling buffer.
-   */
-  private static final class InfoQueue {
-
-    private static final int SAMPLE_CAPACITY_INCREMENT = 1000;
-
-    private int capacity;
-
-    private int[] sourceIds;
-    private long[] offsets;
-    private int[] sizes;
-    private int[] flags;
-    private long[] timesUs;
-    private byte[][] encryptionKeys;
-    private Format[] formats;
-
-    private int queueSize;
-    private int absoluteReadIndex;
-    private int relativeReadIndex;
-    private int relativeWriteIndex;
-
-    private long largestDequeuedTimestampUs;
-    private long largestQueuedTimestampUs;
-    private boolean upstreamFormatRequired;
-    private Format upstreamFormat;
-    private int upstreamSourceId;
-
-    public InfoQueue() {
-      capacity = SAMPLE_CAPACITY_INCREMENT;
-      sourceIds = new int[capacity];
-      offsets = new long[capacity];
-      timesUs = new long[capacity];
-      flags = new int[capacity];
-      sizes = new int[capacity];
-      encryptionKeys = new byte[capacity][];
-      formats = new Format[capacity];
-      largestDequeuedTimestampUs = Long.MIN_VALUE;
-      largestQueuedTimestampUs = Long.MIN_VALUE;
-      upstreamFormatRequired = true;
-    }
-
-    public void clearSampleData() {
-      absoluteReadIndex = 0;
-      relativeReadIndex = 0;
-      relativeWriteIndex = 0;
-      queueSize = 0;
+    public DefaultTrackOutput(Allocator allocator) {
+        this.allocator = allocator;
+        allocationLength = allocator.getIndividualAllocationLength();
+        infoQueue = new InfoQueue();
+        dataQueue = new LinkedBlockingDeque<>();
+        extrasHolder = new BufferExtrasHolder();
+        scratch = new ParsableByteArray(INITIAL_SCRATCH_SIZE);
+        state = new AtomicInteger();
+        lastAllocationOffset = allocationLength;
+        needKeyframe = true;
     }
 
     // Called by the consuming thread, but only when there is no loading thread.
 
-    public void resetLargestParsedTimestamps() {
-      largestDequeuedTimestampUs = Long.MIN_VALUE;
-      largestQueuedTimestampUs = Long.MIN_VALUE;
+    /**
+     * Resets the output.
+     *
+     * @param enable Whether the output should be enabled. False if it should be disabled.
+     */
+    public void reset(boolean enable) {
+        int previousState = state.getAndSet(enable ? STATE_ENABLED : STATE_DISABLED);
+        clearSampleData();
+        infoQueue.resetLargestParsedTimestamps();
+        if (previousState == STATE_DISABLED) {
+            downstreamFormat = null;
+        }
+    }
+
+    /**
+     * Sets a source identifier for subsequent samples.
+     *
+     * @param sourceId The source identifier.
+     */
+    public void sourceId(int sourceId) {
+        infoQueue.sourceId(sourceId);
+    }
+
+    /**
+     * Indicates that samples subsequently queued to the buffer should be spliced into those already
+     * queued.
+     */
+    public void splice() {
+        pendingSplice = true;
     }
 
     /**
      * Returns the current absolute write index.
      */
     public int getWriteIndex() {
-      return absoluteReadIndex + queueSize;
+        return infoQueue.getWriteIndex();
     }
 
     /**
      * Discards samples from the write side of the buffer.
      *
      * @param discardFromIndex The absolute index of the first sample to be discarded.
-     * @return The reduced total number of bytes written, after the samples have been discarded.
      */
-    public long discardUpstreamSamples(int discardFromIndex) {
-      int discardCount = getWriteIndex() - discardFromIndex;
-      Assertions.checkArgument(0 <= discardCount && discardCount <= queueSize);
-
-      if (discardCount == 0) {
-        if (absoluteReadIndex == 0) {
-          // queueSize == absoluteReadIndex == 0, so nothing has been written to the queue.
-          return 0;
-        }
-        int lastWriteIndex = (relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
-        return offsets[lastWriteIndex] + sizes[lastWriteIndex];
-      }
-
-      queueSize -= discardCount;
-      relativeWriteIndex = (relativeWriteIndex + capacity - discardCount) % capacity;
-      // Update the largest queued timestamp, assuming that the timestamps prior to a keyframe are
-      // always less than the timestamp of the keyframe itself, and of subsequent frames.
-      largestQueuedTimestampUs = Long.MIN_VALUE;
-      for (int i = queueSize - 1; i >= 0; i--) {
-        int sampleIndex = (relativeReadIndex + i) % capacity;
-        largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs, timesUs[sampleIndex]);
-        if ((flags[sampleIndex] & C.BUFFER_FLAG_KEY_FRAME) != 0) {
-          break;
-        }
-      }
-      return offsets[relativeWriteIndex];
+    public void discardUpstreamSamples(int discardFromIndex) {
+        totalBytesWritten = infoQueue.discardUpstreamSamples(discardFromIndex);
+        dropUpstreamFrom(totalBytesWritten);
     }
 
-    public void sourceId(int sourceId) {
-      upstreamSourceId = sourceId;
+    /**
+     * Discards data from the write side of the buffer. Data is discarded from the specified absolute
+     * position. Any allocations that are fully discarded are returned to the allocator.
+     *
+     * @param absolutePosition The absolute position (inclusive) from which to discard data.
+     */
+    private void dropUpstreamFrom(long absolutePosition) {
+        int relativePosition = (int) (absolutePosition - totalBytesDropped);
+        // Calculate the index of the allocation containing the position, and the offset within it.
+        int allocationIndex = relativePosition / allocationLength;
+        int allocationOffset = relativePosition % allocationLength;
+        // We want to discard any allocations after the one at allocationIdnex.
+        int allocationDiscardCount = dataQueue.size() - allocationIndex - 1;
+        if (allocationOffset == 0) {
+            // If the allocation at allocationIndex is empty, we should discard that one too.
+            allocationDiscardCount++;
+        }
+        // Discard the allocations.
+        for (int i = 0; i < allocationDiscardCount; i++) {
+            allocator.release(dataQueue.removeLast());
+        }
+        // Update lastAllocation and lastAllocationOffset to reflect the new position.
+        lastAllocation = dataQueue.peekLast();
+        lastAllocationOffset = allocationOffset == 0 ? allocationLength : allocationOffset;
     }
 
     // Called by the consuming thread.
 
     /**
-     * Returns the current absolute read index.
+     * Disables buffering of sample data and metadata.
      */
-    public int getReadIndex() {
-      return absoluteReadIndex;
+    public void disable() {
+        if (state.getAndSet(STATE_DISABLED) == STATE_ENABLED) {
+            clearSampleData();
+        }
     }
 
     /**
-     * Peeks the source id of the next sample, or the current upstream source id if the queue is
-     * empty.
+     * Returns whether the buffer is empty.
      */
-    public int peekSourceId() {
-      return queueSize == 0 ? upstreamSourceId : sourceIds[relativeReadIndex];
+    public boolean isEmpty() {
+        return infoQueue.isEmpty();
     }
 
     /**
-     * Returns whether the queue is empty.
+     * Returns the current absolute read index.
      */
-    public synchronized boolean isEmpty() {
-      return queueSize == 0;
+    public int getReadIndex() {
+        return infoQueue.getReadIndex();
+    }
+
+    /**
+     * Peeks the source id of the next sample, or the current upstream source id if the buffer is
+     * empty.
+     *
+     * @return The source id.
+     */
+    public int peekSourceId() {
+        return infoQueue.peekSourceId();
     }
 
     /**
      * Returns the upstream {@link Format} in which samples are being queued.
      */
-    public synchronized Format getUpstreamFormat() {
-      return upstreamFormatRequired ? null : upstreamFormat;
+    public Format getUpstreamFormat() {
+        return infoQueue.getUpstreamFormat();
     }
 
     /**
@@ -717,221 +220,732 @@ public synchronized Format getUpstreamFormat() {
      * considered as having been queued.
      *
      * @return The largest sample timestamp that has been queued, or {@link Long#MIN_VALUE} if no
-     *     samples have been queued.
+     * samples have been queued.
      */
-    public synchronized long getLargestQueuedTimestampUs() {
-      return Math.max(largestDequeuedTimestampUs, largestQueuedTimestampUs);
+    public long getLargestQueuedTimestampUs() {
+        return infoQueue.getLargestQueuedTimestampUs();
+    }
+
+    /**
+     * Attempts to skip to the keyframe before the specified time, if it's present in the buffer.
+     *
+     * @param timeUs The seek time.
+     * @return Whether the skip was successful.
+     */
+    public boolean skipToKeyframeBefore(long timeUs) {
+        long nextOffset = infoQueue.skipToKeyframeBefore(timeUs);
+        if (nextOffset == C.POSITION_UNSET) {
+            return false;
+        }
+        dropDownstreamTo(nextOffset);
+        return true;
     }
 
     /**
      * Attempts to read from the queue.
      *
-     * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
-     * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
-     *     end of the stream. If a sample is read then the buffer is populated with information
-     *     about the sample, but not its data. The size and absolute position of the data in the
-     *     rolling buffer is stored in {@code extrasHolder}, along with an encryption id if present
-     *     and the absolute position of the first byte that may still be required after the current
-     *     sample has been read.
-     * @param downstreamFormat The current downstream {@link Format}. If the format of the next
-     *     sample is different to the current downstream format then a format will be read.
-     * @param extrasHolder The holder into which extra sample information should be written.
-     * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ}
-     *     or {@link C#RESULT_BUFFER_READ}.
+     * @param formatHolder      A {@link FormatHolder} to populate in the case of reading a format.
+     * @param buffer            A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
+     *                          end of the stream. If the end of the stream has been reached, the
+     *                          {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+     * @param loadingFinished   True if an empty queue should be considered the end of the stream.
+     * @param decodeOnlyUntilUs If a buffer is read, the {@link C#BUFFER_FLAG_DECODE_ONLY} flag will
+     *                          be set if the buffer's timestamp is less than this value.
+     * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
+     * {@link C#RESULT_BUFFER_READ}.
      */
-    public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
-        Format downstreamFormat, BufferExtrasHolder extrasHolder) {
-      if (queueSize == 0) {
-        if (upstreamFormat != null && upstreamFormat != downstreamFormat) {
-          formatHolder.format = upstreamFormat;
-          return C.RESULT_FORMAT_READ;
-        }
-        return C.RESULT_NOTHING_READ;
-      }
-
-      if (formats[relativeReadIndex] != downstreamFormat) {
-        formatHolder.format = formats[relativeReadIndex];
-        return C.RESULT_FORMAT_READ;
-      }
-
-      buffer.timeUs = timesUs[relativeReadIndex];
-      buffer.setFlags(flags[relativeReadIndex]);
-      extrasHolder.size = sizes[relativeReadIndex];
-      extrasHolder.offset = offsets[relativeReadIndex];
-      extrasHolder.encryptionKeyId = encryptionKeys[relativeReadIndex];
-
-      largestDequeuedTimestampUs = Math.max(largestDequeuedTimestampUs, buffer.timeUs);
-      queueSize--;
-      relativeReadIndex++;
-      absoluteReadIndex++;
-      if (relativeReadIndex == capacity) {
-        // Wrap around.
-        relativeReadIndex = 0;
-      }
-
-      extrasHolder.nextOffset = queueSize > 0 ? offsets[relativeReadIndex]
-          : extrasHolder.offset + extrasHolder.size;
-      return C.RESULT_BUFFER_READ;
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean loadingFinished,
+                        long decodeOnlyUntilUs) {
+        switch (infoQueue.readData(formatHolder, buffer, downstreamFormat, extrasHolder)) {
+            case C.RESULT_NOTHING_READ:
+                if (loadingFinished) {
+                    buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+                    return C.RESULT_BUFFER_READ;
+                }
+                return C.RESULT_NOTHING_READ;
+            case C.RESULT_FORMAT_READ:
+                downstreamFormat = formatHolder.format;
+                return C.RESULT_FORMAT_READ;
+            case C.RESULT_BUFFER_READ:
+                if (buffer.timeUs < decodeOnlyUntilUs) {
+                    buffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
+                }
+                // Read encryption data if the sample is encrypted.
+                if (buffer.isEncrypted()) {
+                    readEncryptionData(buffer, extrasHolder);
+                }
+
+                // Write the sample data into the holder.
+                buffer.ensureSpaceForWrite(extrasHolder.size);
+                readData(extrasHolder.offset, buffer.data, extrasHolder.size);
+
+                // Advance the read head.
+                dropDownstreamTo(extrasHolder.nextOffset);
+                return C.RESULT_BUFFER_READ;
+            default:
+                throw new IllegalStateException();
+        }
     }
 
     /**
-     * Attempts to locate the keyframe before the specified time, if it's present in the buffer.
+     * Reads encryption data for the current sample.
+     * <p>
+     * The encryption data is written into {@link DecoderInputBuffer#cryptoInfo}, and
+     * {@link BufferExtrasHolder#size} is adjusted to subtract the number of bytes that were read. The
+     * same value is added to {@link BufferExtrasHolder#offset}.
      *
-     * @param timeUs The seek time.
-     * @return The offset of the keyframe's data if the keyframe was present.
-     *     {@link C#POSITION_UNSET} otherwise.
+     * @param buffer       The buffer into which the encryption data should be written.
+     * @param extrasHolder The extras holder whose offset should be read and subsequently adjusted.
+     */
+    private void readEncryptionData(DecoderInputBuffer buffer, BufferExtrasHolder extrasHolder) {
+        long offset = extrasHolder.offset;
+
+        // Read the signal byte.
+        scratch.reset(1);
+        readData(offset, scratch.data, 1);
+        offset++;
+        byte signalByte = scratch.data[0];
+        boolean subsampleEncryption = (signalByte & 0x80) != 0;
+        int ivSize = signalByte & 0x7F;
+
+        // Read the initialization vector.
+        if (buffer.cryptoInfo.iv == null) {
+            buffer.cryptoInfo.iv = new byte[16];
+        }
+        readData(offset, buffer.cryptoInfo.iv, ivSize);
+        offset += ivSize;
+
+        // Read the subsample count, if present.
+        int subsampleCount;
+        if (subsampleEncryption) {
+            scratch.reset(2);
+            readData(offset, scratch.data, 2);
+            offset += 2;
+            subsampleCount = scratch.readUnsignedShort();
+        } else {
+            subsampleCount = 1;
+        }
+
+        // Write the clear and encrypted subsample sizes.
+        int[] clearDataSizes = buffer.cryptoInfo.numBytesOfClearData;
+        if (clearDataSizes == null || clearDataSizes.length < subsampleCount) {
+            clearDataSizes = new int[subsampleCount];
+        }
+        int[] encryptedDataSizes = buffer.cryptoInfo.numBytesOfEncryptedData;
+        if (encryptedDataSizes == null || encryptedDataSizes.length < subsampleCount) {
+            encryptedDataSizes = new int[subsampleCount];
+        }
+        if (subsampleEncryption) {
+            int subsampleDataLength = 6 * subsampleCount;
+            scratch.reset(subsampleDataLength);
+            readData(offset, scratch.data, subsampleDataLength);
+            offset += subsampleDataLength;
+            scratch.setPosition(0);
+            for (int i = 0; i < subsampleCount; i++) {
+                clearDataSizes[i] = scratch.readUnsignedShort();
+                encryptedDataSizes[i] = scratch.readUnsignedIntToInt();
+            }
+        } else {
+            clearDataSizes[0] = 0;
+            encryptedDataSizes[0] = extrasHolder.size - (int) (offset - extrasHolder.offset);
+        }
+
+        // Populate the cryptoInfo.
+        buffer.cryptoInfo.set(subsampleCount, clearDataSizes, encryptedDataSizes,
+                extrasHolder.encryptionKeyId, buffer.cryptoInfo.iv, C.CRYPTO_MODE_AES_CTR);
+
+        // Adjust the offset and size to take into account the bytes read.
+        int bytesRead = (int) (offset - extrasHolder.offset);
+        extrasHolder.offset += bytesRead;
+        extrasHolder.size -= bytesRead;
+    }
+
+    /**
+     * Reads data from the front of the rolling buffer.
+     *
+     * @param absolutePosition The absolute position from which data should be read.
+     * @param target           The buffer into which data should be written.
+     * @param length           The number of bytes to read.
      */
-    public synchronized long skipToKeyframeBefore(long timeUs) {
-      if (queueSize == 0 || timeUs < timesUs[relativeReadIndex]) {
-        return C.POSITION_UNSET;
-      }
-
-      int lastWriteIndex = (relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
-      long lastTimeUs = timesUs[lastWriteIndex];
-      if (timeUs > lastTimeUs) {
-        return C.POSITION_UNSET;
-      }
-
-      // This could be optimized to use a binary search, however in practice callers to this method
-      // often pass times near to the start of the buffer. Hence it's unclear whether switching to
-      // a binary search would yield any real benefit.
-      int sampleCount = 0;
-      int sampleCountToKeyframe = -1;
-      int searchIndex = relativeReadIndex;
-      while (searchIndex != relativeWriteIndex) {
-        if (timesUs[searchIndex] > timeUs) {
-          // We've gone too far.
-          break;
-        } else if ((flags[searchIndex] & C.BUFFER_FLAG_KEY_FRAME) != 0) {
-          // We've found a keyframe, and we're still before the seek position.
-          sampleCountToKeyframe = sampleCount;
-        }
-        searchIndex = (searchIndex + 1) % capacity;
-        sampleCount++;
-      }
-
-      if (sampleCountToKeyframe == -1) {
-        return C.POSITION_UNSET;
-      }
-
-      queueSize -= sampleCountToKeyframe;
-      relativeReadIndex = (relativeReadIndex + sampleCountToKeyframe) % capacity;
-      absoluteReadIndex += sampleCountToKeyframe;
-      return offsets[relativeReadIndex];
+    private void readData(long absolutePosition, ByteBuffer target, int length) {
+        int remaining = length;
+        while (remaining > 0) {
+            dropDownstreamTo(absolutePosition);
+            int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
+            int toCopy = Math.min(remaining, allocationLength - positionInAllocation);
+
+            // 将allocation中的数据写入: target中
+            Allocation allocation = dataQueue.peek();
+            target.put(allocation.data, allocation.translateOffset(positionInAllocation), toCopy);
+            absolutePosition += toCopy;
+            remaining -= toCopy;
+        }
+    }
+
+    /**
+     * Reads data from the front of the rolling buffer.
+     *
+     * @param absolutePosition The absolute position from which data should be read.
+     * @param target           The array into which data should be written.
+     * @param length           The number of bytes to read.
+     */
+    private void readData(long absolutePosition, byte[] target, int length) {
+        int bytesRead = 0;
+        while (bytesRead < length) {
+            dropDownstreamTo(absolutePosition);
+            int positionInAllocation = (int) (absolutePosition - totalBytesDropped);
+            int toCopy = Math.min(length - bytesRead, allocationLength - positionInAllocation);
+            Allocation allocation = dataQueue.peek();
+            System.arraycopy(allocation.data, allocation.translateOffset(positionInAllocation), target,
+                    bytesRead, toCopy);
+            absolutePosition += toCopy;
+            bytesRead += toCopy;
+        }
+    }
+
+    /**
+     * Discard any allocations that hold data prior to the specified absolute position, returning
+     * them to the allocator.
+     *
+     * @param absolutePosition The absolute position up to which allocations can be discarded.
+     */
+    private void dropDownstreamTo(long absolutePosition) {
+        int relativePosition = (int) (absolutePosition - totalBytesDropped);
+        int allocationIndex = relativePosition / allocationLength;
+        for (int i = 0; i < allocationIndex; i++) {
+            allocator.release(dataQueue.remove());
+            totalBytesDropped += allocationLength;
+        }
     }
 
     // Called by the loading thread.
 
-    public synchronized boolean format(Format format) {
-      if (format == null) {
-        upstreamFormatRequired = true;
-        return false;
-      }
-      upstreamFormatRequired = false;
-      if (Util.areEqual(format, upstreamFormat)) {
-        // Suppress changes between equal formats so we can use referential equality in readData.
-        return false;
-      } else {
-        upstreamFormat = format;
-        return true;
-      }
-    }
-
-    public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlags, long offset,
-        int size, byte[] encryptionKey) {
-      Assertions.checkState(!upstreamFormatRequired);
-      commitSampleTimestamp(timeUs);
-      timesUs[relativeWriteIndex] = timeUs;
-      offsets[relativeWriteIndex] = offset;
-      sizes[relativeWriteIndex] = size;
-      flags[relativeWriteIndex] = sampleFlags;
-      encryptionKeys[relativeWriteIndex] = encryptionKey;
-      formats[relativeWriteIndex] = upstreamFormat;
-      sourceIds[relativeWriteIndex] = upstreamSourceId;
-      // Increment the write index.
-      queueSize++;
-      if (queueSize == capacity) {
-        // Increase the capacity.
-        int newCapacity = capacity + SAMPLE_CAPACITY_INCREMENT;
-        int[] newSourceIds = new int[newCapacity];
-        long[] newOffsets = new long[newCapacity];
-        long[] newTimesUs = new long[newCapacity];
-        int[] newFlags = new int[newCapacity];
-        int[] newSizes = new int[newCapacity];
-        byte[][] newEncryptionKeys = new byte[newCapacity][];
-        Format[] newFormats = new Format[newCapacity];
-        int beforeWrap = capacity - relativeReadIndex;
-        System.arraycopy(offsets, relativeReadIndex, newOffsets, 0, beforeWrap);
-        System.arraycopy(timesUs, relativeReadIndex, newTimesUs, 0, beforeWrap);
-        System.arraycopy(flags, relativeReadIndex, newFlags, 0, beforeWrap);
-        System.arraycopy(sizes, relativeReadIndex, newSizes, 0, beforeWrap);
-        System.arraycopy(encryptionKeys, relativeReadIndex, newEncryptionKeys, 0, beforeWrap);
-        System.arraycopy(formats, relativeReadIndex, newFormats, 0, beforeWrap);
-        System.arraycopy(sourceIds, relativeReadIndex, newSourceIds, 0, beforeWrap);
-        int afterWrap = relativeReadIndex;
-        System.arraycopy(offsets, 0, newOffsets, beforeWrap, afterWrap);
-        System.arraycopy(timesUs, 0, newTimesUs, beforeWrap, afterWrap);
-        System.arraycopy(flags, 0, newFlags, beforeWrap, afterWrap);
-        System.arraycopy(sizes, 0, newSizes, beforeWrap, afterWrap);
-        System.arraycopy(encryptionKeys, 0, newEncryptionKeys, beforeWrap, afterWrap);
-        System.arraycopy(formats, 0, newFormats, beforeWrap, afterWrap);
-        System.arraycopy(sourceIds, 0, newSourceIds, beforeWrap, afterWrap);
-        offsets = newOffsets;
-        timesUs = newTimesUs;
-        flags = newFlags;
-        sizes = newSizes;
-        encryptionKeys = newEncryptionKeys;
-        formats = newFormats;
-        sourceIds = newSourceIds;
-        relativeReadIndex = 0;
-        relativeWriteIndex = capacity;
-        queueSize = capacity;
-        capacity = newCapacity;
-      } else {
-        relativeWriteIndex++;
-        if (relativeWriteIndex == capacity) {
-          // Wrap around.
-          relativeWriteIndex = 0;
-        }
-      }
-    }
-
-    public synchronized void commitSampleTimestamp(long timeUs) {
-      largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs, timeUs);
+    /**
+     * Sets a listener to be notified of changes to the upstream format.
+     *
+     * @param listener The listener.
+     */
+    public void setUpstreamFormatChangeListener(UpstreamFormatChangedListener listener) {
+        upstreamFormatChangeListener = listener;
     }
 
     /**
-     * Attempts to discard samples from the tail of the queue to allow samples starting from the
-     * specified timestamp to be spliced in.
+     * Like {@link #format(Format)}, but with an offset that will be added to the timestamps of
+     * samples subsequently queued to the buffer. The offset is also used to adjust
+     * {@link Format#subsampleOffsetUs} for both the {@link Format} passed and those subsequently
+     * passed to {@link #format(Format)}.
      *
-     * @param timeUs The timestamp at which the splice occurs.
-     * @return Whether the splice was successful.
+     * @param format         The format.
+     * @param sampleOffsetUs The timestamp offset in microseconds.
      */
-    public synchronized boolean attemptSplice(long timeUs) {
-      if (largestDequeuedTimestampUs >= timeUs) {
-        return false;
-      }
-      int retainCount = queueSize;
-      while (retainCount > 0
-          && timesUs[(relativeReadIndex + retainCount - 1) % capacity] >= timeUs) {
-        retainCount--;
-      }
-      discardUpstreamSamples(absoluteReadIndex + retainCount);
-      return true;
-    }
-
-  }
-
-  /**
-   * Holds additional buffer information not held by {@link DecoderInputBuffer}.
-   */
-  private static final class BufferExtrasHolder {
-
-    public int size;
-    public long offset;
-    public long nextOffset;
-    public byte[] encryptionKeyId;
-
-  }
+    public void formatWithOffset(Format format, long sampleOffsetUs) {
+        this.sampleOffsetUs = sampleOffsetUs;
+        format(format);
+    }
+
+    @Override
+    public void format(Format format) {
+        Format adjustedFormat = getAdjustedSampleFormat(format, sampleOffsetUs);
+        boolean formatChanged = infoQueue.format(adjustedFormat);
+        if (upstreamFormatChangeListener != null && formatChanged) {
+            upstreamFormatChangeListener.onUpstreamFormatChanged(adjustedFormat);
+        }
+    }
+
+    @Override
+    public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+            throws IOException, InterruptedException {
+        if (!startWriteOperation()) {
+            int bytesSkipped = input.skip(length);
+            if (bytesSkipped == C.RESULT_END_OF_INPUT) {
+                if (allowEndOfInput) {
+                    return C.RESULT_END_OF_INPUT;
+                }
+                throw new EOFException();
+            }
+            return bytesSkipped;
+        }
+        try {
+            length = prepareForAppend(length);
+            int bytesAppended = input.read(lastAllocation.data,
+                    lastAllocation.translateOffset(lastAllocationOffset), length);
+            if (bytesAppended == C.RESULT_END_OF_INPUT) {
+                if (allowEndOfInput) {
+                    return C.RESULT_END_OF_INPUT;
+                }
+                throw new EOFException();
+            }
+            lastAllocationOffset += bytesAppended;
+            totalBytesWritten += bytesAppended;
+            return bytesAppended;
+        } finally {
+            endWriteOperation();
+        }
+    }
+
+    @Override
+    public void sampleData(ParsableByteArray buffer, int length) {
+        if (!startWriteOperation()) {
+            buffer.skipBytes(length);
+            return;
+        }
+        while (length > 0) {
+            int thisAppendLength = prepareForAppend(length);
+            buffer.readBytes(lastAllocation.data, lastAllocation.translateOffset(lastAllocationOffset),
+                    thisAppendLength);
+            lastAllocationOffset += thisAppendLength;
+            totalBytesWritten += thisAppendLength;
+            length -= thisAppendLength;
+        }
+        endWriteOperation();
+    }
+
+    @Override
+    public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int offset,
+                               byte[] encryptionKey) {
+        if (!startWriteOperation()) {
+            infoQueue.commitSampleTimestamp(timeUs);
+            return;
+        }
+        try {
+            if (pendingSplice) {
+                if ((flags & C.BUFFER_FLAG_KEY_FRAME) == 0 || !infoQueue.attemptSplice(timeUs)) {
+                    return;
+                }
+                pendingSplice = false;
+            }
+            if (needKeyframe) {
+                if ((flags & C.BUFFER_FLAG_KEY_FRAME) == 0) {
+                    return;
+                }
+                needKeyframe = false;
+            }
+            timeUs += sampleOffsetUs;
+            long absoluteOffset = totalBytesWritten - size - offset;
+            infoQueue.commitSample(timeUs, flags, absoluteOffset, size, encryptionKey);
+        } finally {
+            endWriteOperation();
+        }
+    }
+
+    // Private methods.
+
+    private boolean startWriteOperation() {
+        return state.compareAndSet(STATE_ENABLED, STATE_ENABLED_WRITING);
+    }
+
+    private void endWriteOperation() {
+        if (!state.compareAndSet(STATE_ENABLED_WRITING, STATE_ENABLED)) {
+            clearSampleData();
+        }
+    }
+
+    private void clearSampleData() {
+        infoQueue.clearSampleData();
+        allocator.release(dataQueue.toArray(new Allocation[dataQueue.size()]));
+        dataQueue.clear();
+        allocator.trim();
+        totalBytesDropped = 0;
+        totalBytesWritten = 0;
+        lastAllocation = null;
+        lastAllocationOffset = allocationLength;
+        needKeyframe = true;
+    }
+
+    /**
+     * Prepares the rolling sample buffer for an append of up to {@code length} bytes, returning the
+     * number of bytes that can actually be appended.
+     */
+    private int prepareForAppend(int length) {
+        if (lastAllocationOffset == allocationLength) {
+            lastAllocationOffset = 0;
+            lastAllocation = allocator.allocate();
+            dataQueue.add(lastAllocation);
+        }
+        return Math.min(length, allocationLength - lastAllocationOffset);
+    }
+
+    /**
+     * Adjusts a {@link Format} to incorporate a sample offset into {@link Format#subsampleOffsetUs}.
+     *
+     * @param format         The {@link Format} to adjust.
+     * @param sampleOffsetUs The offset to apply.
+     * @return The adjusted {@link Format}.
+     */
+    private static Format getAdjustedSampleFormat(Format format, long sampleOffsetUs) {
+        if (format == null) {
+            return null;
+        }
+        if (sampleOffsetUs != 0 && format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {
+            format = format.copyWithSubsampleOffsetUs(format.subsampleOffsetUs + sampleOffsetUs);
+        }
+        return format;
+    }
+
+    /**
+     * Holds information about the samples in the rolling buffer.
+     */
+    private static final class InfoQueue {
+
+        private static final int SAMPLE_CAPACITY_INCREMENT = 1000;
+
+        private int capacity;
+
+        private int[] sourceIds;
+        private long[] offsets;
+        private int[] sizes;
+        private int[] flags;
+        private long[] timesUs;
+        private byte[][] encryptionKeys;
+        private Format[] formats;
+
+        // Queue的大小
+        private int queueSize;
+        // 对应真实数据的位置
+        private int absoluteReadIndex;
+
+        // 循环Queue, 通过两个指针控制读写
+        private int relativeReadIndex;
+        private int relativeWriteIndex;
+
+        private long largestDequeuedTimestampUs;
+        private long largestQueuedTimestampUs;
+        private boolean upstreamFormatRequired;
+        private Format upstreamFormat;
+        private int upstreamSourceId;
+
+        public InfoQueue() {
+            capacity = SAMPLE_CAPACITY_INCREMENT;
+            sourceIds = new int[capacity];
+            offsets = new long[capacity];
+            timesUs = new long[capacity];
+            flags = new int[capacity];
+            sizes = new int[capacity];
+            encryptionKeys = new byte[capacity][];
+            formats = new Format[capacity];
+            largestDequeuedTimestampUs = Long.MIN_VALUE;
+            largestQueuedTimestampUs = Long.MIN_VALUE;
+            upstreamFormatRequired = true;
+        }
+
+        public void clearSampleData() {
+            absoluteReadIndex = 0;
+            relativeReadIndex = 0;
+            relativeWriteIndex = 0;
+            queueSize = 0;
+        }
+
+        // Called by the consuming thread, but only when there is no loading thread.
+
+        public void resetLargestParsedTimestamps() {
+            largestDequeuedTimestampUs = Long.MIN_VALUE;
+            largestQueuedTimestampUs = Long.MIN_VALUE;
+        }
+
+        /**
+         * Returns the current absolute write index.
+         */
+        public int getWriteIndex() {
+            return absoluteReadIndex + queueSize;
+        }
+
+        /**
+         * Discards samples from the write side of the buffer.
+         *
+         * @param discardFromIndex The absolute index of the first sample to be discarded.
+         * @return The reduced total number of bytes written, after the samples have been discarded.
+         */
+        public long discardUpstreamSamples(int discardFromIndex) {
+            int discardCount = getWriteIndex() - discardFromIndex;
+            Assertions.checkArgument(0 <= discardCount && discardCount <= queueSize);
+
+            if (discardCount == 0) {
+                if (absoluteReadIndex == 0) {
+                    // queueSize == absoluteReadIndex == 0, so nothing has been written to the queue.
+                    return 0;
+                }
+                int lastWriteIndex = (relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
+                return offsets[lastWriteIndex] + sizes[lastWriteIndex];
+            }
+
+            queueSize -= discardCount;
+            relativeWriteIndex = (relativeWriteIndex + capacity - discardCount) % capacity;
+            // Update the largest queued timestamp, assuming that the timestamps prior to a keyframe are
+            // always less than the timestamp of the keyframe itself, and of subsequent frames.
+            largestQueuedTimestampUs = Long.MIN_VALUE;
+            for (int i = queueSize - 1; i >= 0; i--) {
+                int sampleIndex = (relativeReadIndex + i) % capacity;
+                largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs, timesUs[sampleIndex]);
+                if ((flags[sampleIndex] & C.BUFFER_FLAG_KEY_FRAME) != 0) {
+                    break;
+                }
+            }
+            return offsets[relativeWriteIndex];
+        }
+
+        public void sourceId(int sourceId) {
+            upstreamSourceId = sourceId;
+        }
+
+        // Called by the consuming thread.
+
+        /**
+         * Returns the current absolute read index.
+         */
+        public int getReadIndex() {
+            return absoluteReadIndex;
+        }
+
+        /**
+         * Peeks the source id of the next sample, or the current upstream source id if the queue is
+         * empty.
+         */
+        public int peekSourceId() {
+            return queueSize == 0 ? upstreamSourceId : sourceIds[relativeReadIndex];
+        }
+
+        /**
+         * Returns whether the queue is empty.
+         */
+        public synchronized boolean isEmpty() {
+            return queueSize == 0;
+        }
+
+        /**
+         * Returns the upstream {@link Format} in which samples are being queued.
+         */
+        public synchronized Format getUpstreamFormat() {
+            return upstreamFormatRequired ? null : upstreamFormat;
+        }
+
+        /**
+         * Returns the largest sample timestamp that has been queued since the last {@link #reset}.
+         * <p>
+         * Samples that were discarded by calling {@link #discardUpstreamSamples(int)} are not
+         * considered as having been queued. Samples that were dequeued from the front of the queue are
+         * considered as having been queued.
+         *
+         * @return The largest sample timestamp that has been queued, or {@link Long#MIN_VALUE} if no
+         * samples have been queued.
+         */
+        public synchronized long getLargestQueuedTimestampUs() {
+            return Math.max(largestDequeuedTimestampUs, largestQueuedTimestampUs);
+        }
+
+        /**
+         * Attempts to read from the queue.
+         *
+         * @param formatHolder     A {@link FormatHolder} to populate in the case of reading a format.
+         * @param buffer           A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
+         *                         end of the stream. If a sample is read then the buffer is populated with information
+         *                         about the sample, but not its data. The size and absolute position of the data in the
+         *                         rolling buffer is stored in {@code extrasHolder}, along with an encryption id if present
+         *                         and the absolute position of the first byte that may still be required after the current
+         *                         sample has been read.
+         * @param downstreamFormat The current downstream {@link Format}. If the format of the next
+         *                         sample is different to the current downstream format then a format will be read.
+         * @param extrasHolder     The holder into which extra sample information should be written.
+         * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ}
+         * or {@link C#RESULT_BUFFER_READ}.
+         */
+        public synchronized int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
+                                         Format downstreamFormat, BufferExtrasHolder extrasHolder) {
+            if (queueSize == 0) {
+                if (upstreamFormat != null && upstreamFormat != downstreamFormat) {
+                    formatHolder.format = upstreamFormat;
+                    return C.RESULT_FORMAT_READ;
+                }
+                return C.RESULT_NOTHING_READ;
+            }
+
+            if (formats[relativeReadIndex] != downstreamFormat) {
+                formatHolder.format = formats[relativeReadIndex];
+                return C.RESULT_FORMAT_READ;
+            }
+
+            buffer.timeUs = timesUs[relativeReadIndex];
+            buffer.setFlags(flags[relativeReadIndex]);
+            extrasHolder.size = sizes[relativeReadIndex];
+            extrasHolder.offset = offsets[relativeReadIndex];
+            extrasHolder.encryptionKeyId = encryptionKeys[relativeReadIndex];
+
+            largestDequeuedTimestampUs = Math.max(largestDequeuedTimestampUs, buffer.timeUs);
+            queueSize--;
+            relativeReadIndex++;
+            absoluteReadIndex++;
+            if (relativeReadIndex == capacity) {
+                // Wrap around.
+                relativeReadIndex = 0;
+            }
+
+            extrasHolder.nextOffset = queueSize > 0 ? offsets[relativeReadIndex]
+                    : extrasHolder.offset + extrasHolder.size;
+            return C.RESULT_BUFFER_READ;
+        }
+
+        /**
+         * Attempts to locate the keyframe before the specified time, if it's present in the buffer.
+         *
+         * @param timeUs The seek time.
+         * @return The offset of the keyframe's data if the keyframe was present.
+         * {@link C#POSITION_UNSET} otherwise.
+         */
+        public synchronized long skipToKeyframeBefore(long timeUs) {
+            if (queueSize == 0 || timeUs < timesUs[relativeReadIndex]) {
+                return C.POSITION_UNSET;
+            }
+
+            int lastWriteIndex = (relativeWriteIndex == 0 ? capacity : relativeWriteIndex) - 1;
+            long lastTimeUs = timesUs[lastWriteIndex];
+            if (timeUs > lastTimeUs) {
+                return C.POSITION_UNSET;
+            }
+
+            // This could be optimized to use a binary search, however in practice callers to this method
+            // often pass times near to the start of the buffer. Hence it's unclear whether switching to
+            // a binary search would yield any real benefit.
+            int sampleCount = 0;
+            int sampleCountToKeyframe = -1;
+
+            // 要解码 timeUS 这个位置的Frame, 我们需要先定位要之前的IFrame
+            //   IFrame, PFrame, PFrame, (timeUS)
+            int searchIndex = relativeReadIndex;
+            while (searchIndex != relativeWriteIndex) {
+                if (timesUs[searchIndex] > timeUs) {
+                    // We've gone too far.
+                    break;
+                } else if ((flags[searchIndex] & C.BUFFER_FLAG_KEY_FRAME) != 0) {
+                    // We've found a keyframe, and we're still before the seek position.
+                    sampleCountToKeyframe = sampleCount;
+                }
+
+                // 循环Queue
+                searchIndex = (searchIndex + 1) % capacity;
+                sampleCount++;
+            }
+
+            if (sampleCountToKeyframe == -1) {
+                return C.POSITION_UNSET;
+            }
+
+            queueSize -= sampleCountToKeyframe;
+            relativeReadIndex = (relativeReadIndex + sampleCountToKeyframe) % capacity;
+            absoluteReadIndex += sampleCountToKeyframe;
+            return offsets[relativeReadIndex];
+        }
+
+        // Called by the loading thread.
+
+        public synchronized boolean format(Format format) {
+            if (format == null) {
+                upstreamFormatRequired = true;
+                return false;
+            }
+            upstreamFormatRequired = false;
+            if (Util.areEqual(format, upstreamFormat)) {
+                // Suppress changes between equal formats so we can use referential equality in readData.
+                return false;
+            } else {
+                upstreamFormat = format;
+                return true;
+            }
+        }
+
+        public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlags, long offset,
+                                              int size, byte[] encryptionKey) {
+            Assertions.checkState(!upstreamFormatRequired);
+            commitSampleTimestamp(timeUs);
+            timesUs[relativeWriteIndex] = timeUs;
+            offsets[relativeWriteIndex] = offset;
+            sizes[relativeWriteIndex] = size;
+            flags[relativeWriteIndex] = sampleFlags;
+            encryptionKeys[relativeWriteIndex] = encryptionKey;
+            formats[relativeWriteIndex] = upstreamFormat;
+            sourceIds[relativeWriteIndex] = upstreamSourceId;
+            // Increment the write index.
+            queueSize++;
+            if (queueSize == capacity) {
+                // Increase the capacity.
+                int newCapacity = capacity + SAMPLE_CAPACITY_INCREMENT;
+                int[] newSourceIds = new int[newCapacity];
+                long[] newOffsets = new long[newCapacity];
+                long[] newTimesUs = new long[newCapacity];
+                int[] newFlags = new int[newCapacity];
+                int[] newSizes = new int[newCapacity];
+                byte[][] newEncryptionKeys = new byte[newCapacity][];
+                Format[] newFormats = new Format[newCapacity];
+                int beforeWrap = capacity - relativeReadIndex;
+                System.arraycopy(offsets, relativeReadIndex, newOffsets, 0, beforeWrap);
+                System.arraycopy(timesUs, relativeReadIndex, newTimesUs, 0, beforeWrap);
+                System.arraycopy(flags, relativeReadIndex, newFlags, 0, beforeWrap);
+                System.arraycopy(sizes, relativeReadIndex, newSizes, 0, beforeWrap);
+                System.arraycopy(encryptionKeys, relativeReadIndex, newEncryptionKeys, 0, beforeWrap);
+                System.arraycopy(formats, relativeReadIndex, newFormats, 0, beforeWrap);
+                System.arraycopy(sourceIds, relativeReadIndex, newSourceIds, 0, beforeWrap);
+                int afterWrap = relativeReadIndex;
+                System.arraycopy(offsets, 0, newOffsets, beforeWrap, afterWrap);
+                System.arraycopy(timesUs, 0, newTimesUs, beforeWrap, afterWrap);
+                System.arraycopy(flags, 0, newFlags, beforeWrap, afterWrap);
+                System.arraycopy(sizes, 0, newSizes, beforeWrap, afterWrap);
+                System.arraycopy(encryptionKeys, 0, newEncryptionKeys, beforeWrap, afterWrap);
+                System.arraycopy(formats, 0, newFormats, beforeWrap, afterWrap);
+                System.arraycopy(sourceIds, 0, newSourceIds, beforeWrap, afterWrap);
+                offsets = newOffsets;
+                timesUs = newTimesUs;
+                flags = newFlags;
+                sizes = newSizes;
+                encryptionKeys = newEncryptionKeys;
+                formats = newFormats;
+                sourceIds = newSourceIds;
+                relativeReadIndex = 0;
+                relativeWriteIndex = capacity;
+                queueSize = capacity;
+                capacity = newCapacity;
+            } else {
+                relativeWriteIndex++;
+                if (relativeWriteIndex == capacity) {
+                    // Wrap around.
+                    relativeWriteIndex = 0;
+                }
+            }
+        }
+
+        public synchronized void commitSampleTimestamp(long timeUs) {
+            largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs, timeUs);
+        }
+
+        /**
+         * Attempts to discard samples from the tail of the queue to allow samples starting from the
+         * specified timestamp to be spliced in.
+         *
+         * @param timeUs The timestamp at which the splice occurs.
+         * @return Whether the splice was successful.
+         */
+        public synchronized boolean attemptSplice(long timeUs) {
+            if (largestDequeuedTimestampUs >= timeUs) {
+                return false;
+            }
+            int retainCount = queueSize;
+            while (retainCount > 0
+                    && timesUs[(relativeReadIndex + retainCount - 1) % capacity] >= timeUs) {
+                retainCount--;
+            }
+            discardUpstreamSamples(absoluteReadIndex + retainCount);
+            return true;
+        }
+
+    }
+
+    /**
+     * Holds additional buffer information not held by {@link DecoderInputBuffer}.
+     */
+    private static final class BufferExtrasHolder {
+
+        public int size;
+        public long offset;
+        public long nextOffset;
+        public byte[] encryptionKeyId;
+
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index b806da8c48..b1114ff9eb 100644
--- a/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -18,6 +18,7 @@
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -33,6 +34,7 @@
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.IOException;
 import java.util.Arrays;
 
@@ -41,424 +43,437 @@
  */
 public final class TsExtractor implements Extractor {
 
-  /**
-   * Factory for {@link TsExtractor} instances.
-   */
-  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-    @Override
-    public Extractor[] createExtractors() {
-      return new Extractor[] {new TsExtractor()};
-    }
+    /**
+     * Factory for {@link TsExtractor} instances.
+     */
+    public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
 
-  };
-
-  public static final int TS_STREAM_TYPE_MPA = 0x03;
-  public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
-  public static final int TS_STREAM_TYPE_AAC = 0x0F;
-  public static final int TS_STREAM_TYPE_AC3 = 0x81;
-  public static final int TS_STREAM_TYPE_DTS = 0x8A;
-  public static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
-  public static final int TS_STREAM_TYPE_E_AC3 = 0x87;
-  public static final int TS_STREAM_TYPE_H262 = 0x02;
-  public static final int TS_STREAM_TYPE_H264 = 0x1B;
-  public static final int TS_STREAM_TYPE_H265 = 0x24;
-  public static final int TS_STREAM_TYPE_ID3 = 0x15;
-  public static final int TS_STREAM_TYPE_SPLICE_INFO = 0x86;
-
-  private static final int TS_PACKET_SIZE = 188;
-  private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
-  private static final int TS_PAT_PID = 0;
-  private static final int MAX_PID_PLUS_ONE = 0x2000;
-
-  private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
-  private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
-  private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
-
-  private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
-  private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
-
-  private final boolean hlsMode;
-  private final TimestampAdjuster timestampAdjuster;
-  private final ParsableByteArray tsPacketBuffer;
-  private final ParsableBitArray tsScratch;
-  private final SparseIntArray continuityCounters;
-  private final TsPayloadReader.Factory payloadReaderFactory;
-  private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
-  private final SparseBooleanArray trackIds;
-
-  // Accessed only by the loading thread.
-  private ExtractorOutput output;
-  private boolean tracksEnded;
-  private TsPayloadReader id3Reader;
-
-  public TsExtractor() {
-    this(new TimestampAdjuster(0));
-  }
-
-  /**
-   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
-   */
-  public TsExtractor(TimestampAdjuster timestampAdjuster) {
-    this(timestampAdjuster, new DefaultTsPayloadReaderFactory(), false);
-  }
-
-  /**
-   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
-   * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
-   * @param hlsMode Whether the extractor should be used in HLS mode. If true, {@link TrackOutput}s
-   *     are mapped by their type (instead of PID) and continuity counters are ignored.
-   */
-  public TsExtractor(TimestampAdjuster timestampAdjuster,
-      TsPayloadReader.Factory payloadReaderFactory, boolean hlsMode) {
-    this.timestampAdjuster = timestampAdjuster;
-    this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
-    this.hlsMode = hlsMode;
-    tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
-    tsScratch = new ParsableBitArray(new byte[3]);
-    trackIds = new SparseBooleanArray();
-    tsPayloadReaders = new SparseArray<>();
-    continuityCounters = new SparseIntArray();
-    resetPayloadReaders();
-  }
-
-  // Extractor implementation.
-
-  @Override
-  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
-    byte[] buffer = tsPacketBuffer.data;
-    input.peekFully(buffer, 0, BUFFER_SIZE);
-
-    for (int j = 0; j < TS_PACKET_SIZE; j++) {
-      for (int i = 0; true; i++) {
-        if (i == BUFFER_PACKET_COUNT) {
-          input.skipFully(j);
-          return true;
-        }
-        if (buffer[j + i * TS_PACKET_SIZE] != TS_SYNC_BYTE) {
-          break;
+        @Override
+        public Extractor[] createExtractors() {
+            return new Extractor[]{new TsExtractor()};
         }
-      }
-    }
-    return false;
-  }
-
-  @Override
-  public void init(ExtractorOutput output) {
-    this.output = output;
-    output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
-  }
-
-  @Override
-  public void seek(long position, long timeUs) {
-    timestampAdjuster.reset();
-    tsPacketBuffer.reset();
-    continuityCounters.clear();
-    // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
-    resetPayloadReaders();
-  }
-
-  @Override
-  public void release() {
-    // Do nothing
-  }
-
-  @Override
-  public int read(ExtractorInput input, PositionHolder seekPosition)
-      throws IOException, InterruptedException {
-    byte[] data = tsPacketBuffer.data;
-    // Shift bytes to the start of the buffer if there isn't enough space left at the end
-    if (BUFFER_SIZE - tsPacketBuffer.getPosition() < TS_PACKET_SIZE) {
-      int bytesLeft = tsPacketBuffer.bytesLeft();
-      if (bytesLeft > 0) {
-        System.arraycopy(data, tsPacketBuffer.getPosition(), data, 0, bytesLeft);
-      }
-      tsPacketBuffer.reset(data, bytesLeft);
-    }
-    // Read more bytes until there is at least one packet size
-    while (tsPacketBuffer.bytesLeft() < TS_PACKET_SIZE) {
-      int limit = tsPacketBuffer.limit();
-      int read = input.read(data, limit, BUFFER_SIZE - limit);
-      if (read == C.RESULT_END_OF_INPUT) {
-        return RESULT_END_OF_INPUT;
-      }
-      tsPacketBuffer.setLimit(limit + read);
-    }
 
-    // Note: see ISO/IEC 13818-1, section 2.4.3.2 for detailed information on the format of
-    // the header.
-    final int limit = tsPacketBuffer.limit();
-    int position = tsPacketBuffer.getPosition();
-    while (position < limit && data[position] != TS_SYNC_BYTE) {
-      position++;
+    };
+
+    public static final int TS_STREAM_TYPE_MPA = 0x03;
+    public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
+    public static final int TS_STREAM_TYPE_AAC = 0x0F;
+    public static final int TS_STREAM_TYPE_AC3 = 0x81;
+    public static final int TS_STREAM_TYPE_DTS = 0x8A;
+    public static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
+    public static final int TS_STREAM_TYPE_E_AC3 = 0x87;
+    public static final int TS_STREAM_TYPE_H262 = 0x02;
+    public static final int TS_STREAM_TYPE_H264 = 0x1B;
+    public static final int TS_STREAM_TYPE_H265 = 0x24;
+    public static final int TS_STREAM_TYPE_ID3 = 0x15;
+    public static final int TS_STREAM_TYPE_SPLICE_INFO = 0x86;
+
+    private static final int TS_PACKET_SIZE = 188;
+    private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
+    private static final int TS_PAT_PID = 0;
+    private static final int MAX_PID_PLUS_ONE = 0x2000;
+
+    private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
+    private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
+    private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
+
+    private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
+    private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
+
+    private final boolean hlsMode;
+    private final TimestampAdjuster timestampAdjuster;
+    private final ParsableByteArray tsPacketBuffer;
+    private final ParsableBitArray tsScratch;
+    private final SparseIntArray continuityCounters;
+    private final TsPayloadReader.Factory payloadReaderFactory;
+    private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
+    private final SparseBooleanArray trackIds;
+
+    // Accessed only by the loading thread.
+    private ExtractorOutput output;
+    private boolean tracksEnded;
+    private TsPayloadReader id3Reader;
+
+    public TsExtractor() {
+        this(new TimestampAdjuster(0));
     }
-    tsPacketBuffer.setPosition(position);
 
-    int endOfPacket = position + TS_PACKET_SIZE;
-    if (endOfPacket > limit) {
-      return RESULT_CONTINUE;
+    /**
+     * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
+     */
+    public TsExtractor(TimestampAdjuster timestampAdjuster) {
+        this(timestampAdjuster, new DefaultTsPayloadReaderFactory(), false);
     }
 
-    tsPacketBuffer.skipBytes(1);
-    tsPacketBuffer.readBytes(tsScratch, 3);
-    if (tsScratch.readBit()) { // transport_error_indicator
-      // There are uncorrectable errors in this packet.
-      tsPacketBuffer.setPosition(endOfPacket);
-      return RESULT_CONTINUE;
-    }
-    boolean payloadUnitStartIndicator = tsScratch.readBit();
-    tsScratch.skipBits(1); // transport_priority
-    int pid = tsScratch.readBits(13);
-    tsScratch.skipBits(2); // transport_scrambling_control
-    boolean adaptationFieldExists = tsScratch.readBit();
-    boolean payloadExists = tsScratch.readBit();
-
-    // Discontinuity check.
-    boolean discontinuityFound = false;
-    int continuityCounter = tsScratch.readBits(4);
-    if (!hlsMode) {
-      int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
-      continuityCounters.put(pid, continuityCounter);
-      if (previousCounter == continuityCounter) {
-        if (payloadExists) {
-          // Duplicate packet found.
-          tsPacketBuffer.setPosition(endOfPacket);
-          return RESULT_CONTINUE;
-        }
-      } else if (continuityCounter != (previousCounter + 1) % 16) {
-        discontinuityFound = true;
-      }
+    /**
+     * @param timestampAdjuster    A timestamp adjuster for offsetting and scaling sample timestamps.
+     * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
+     * @param hlsMode              Whether the extractor should be used in HLS mode. If true, {@link TrackOutput}s
+     *                             are mapped by their type (instead of PID) and continuity counters are ignored.
+     */
+    public TsExtractor(TimestampAdjuster timestampAdjuster,
+                       TsPayloadReader.Factory payloadReaderFactory, boolean hlsMode) {
+        this.timestampAdjuster = timestampAdjuster;
+        this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
+        this.hlsMode = hlsMode;
+        tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
+        tsScratch = new ParsableBitArray(new byte[3]);
+        trackIds = new SparseBooleanArray();
+        tsPayloadReaders = new SparseArray<>();
+        continuityCounters = new SparseIntArray();
+        resetPayloadReaders();
     }
 
-    // Skip the adaptation field.
-    if (adaptationFieldExists) {
-      int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
-      tsPacketBuffer.skipBytes(adaptationFieldLength);
-    }
+    // Extractor implementation.
 
-    // Read the payload.
-    if (payloadExists) {
-      TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
-      if (payloadReader != null) {
-        if (discontinuityFound) {
-          payloadReader.seek();
+    @Override
+    public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+        byte[] buffer = tsPacketBuffer.data;
+        input.peekFully(buffer, 0, BUFFER_SIZE);
+
+        // 在TS文件内部寻找同步Byte
+        for (int j = 0; j < TS_PACKET_SIZE; j++) {
+            for (int i = 0; true; i++) {
+                if (i == BUFFER_PACKET_COUNT) {
+                    // 定位成功之后，就直接跳过一段数据（最多处理5个Packet)
+                    input.skipFully(j);
+                    return true;
+                }
+
+                // SYNC ..., SYNC, ....,  SYNC 这种模式
+                if (buffer[j + i * TS_PACKET_SIZE] != TS_SYNC_BYTE) {
+                    break;
+                }
+            }
         }
-        tsPacketBuffer.setLimit(endOfPacket);
-        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
-        Assertions.checkState(tsPacketBuffer.getPosition() <= endOfPacket);
-        tsPacketBuffer.setLimit(limit);
-      }
+        return false;
     }
 
-    tsPacketBuffer.setPosition(endOfPacket);
-    return RESULT_CONTINUE;
-  }
-
-  // Internals.
-
-  private void resetPayloadReaders() {
-    trackIds.clear();
-    tsPayloadReaders.clear();
-    SparseArray<TsPayloadReader> initialPayloadReaders =
-        payloadReaderFactory.createInitialPayloadReaders();
-    int initialPayloadReadersSize = initialPayloadReaders.size();
-    for (int i = 0; i < initialPayloadReadersSize; i++) {
-      tsPayloadReaders.put(initialPayloadReaders.keyAt(i), initialPayloadReaders.valueAt(i));
+    @Override
+    public void init(ExtractorOutput output) {
+        this.output = output;
+        output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
     }
-    tsPayloadReaders.put(TS_PAT_PID, new SectionReader(new PatReader()));
-    id3Reader = null;
-  }
 
-  /**
-   * Parses Program Association Table data.
-   */
-  private class PatReader implements SectionPayloadReader {
-
-    private final ParsableBitArray patScratch;
-
-    public PatReader() {
-      patScratch = new ParsableBitArray(new byte[4]);
+    @Override
+    public void seek(long position, long timeUs) {
+        timestampAdjuster.reset();
+        tsPacketBuffer.reset();
+        continuityCounters.clear();
+        // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
+        resetPayloadReaders();
     }
 
     @Override
-    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-        TrackIdGenerator idGenerator) {
-      // Do nothing.
+    public void release() {
+        // Do nothing
     }
 
     @Override
-    public void consume(ParsableByteArray sectionData) {
-      int tableId = sectionData.readUnsignedByte();
-      if (tableId != 0x00 /* program_association_section */) {
-        // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
-        return;
-      }
-      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12),
-      // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
-      // section_number (8), last_section_number (8)
-      sectionData.skipBytes(7);
-
-      int programCount = sectionData.bytesLeft() / 4;
-      for (int i = 0; i < programCount; i++) {
-        sectionData.readBytes(patScratch, 4);
-        int programNumber = patScratch.readBits(16);
-        patScratch.skipBits(3); // reserved (3)
-        if (programNumber == 0) {
-          patScratch.skipBits(13); // network_PID (13)
-        } else {
-          int pid = patScratch.readBits(13);
-          tsPayloadReaders.put(pid, new SectionReader(new PmtReader(pid)));
+    public int read(ExtractorInput input, PositionHolder seekPosition) throws IOException, InterruptedException {
+        // 从input中读取数据，读取指定位置的数据
+        byte[] data = tsPacketBuffer.data;
+
+        // 1. 整理Buffer
+        // Shift bytes to the start of the buffer if there isn't enough space left at the end
+        if (BUFFER_SIZE - tsPacketBuffer.getPosition() < TS_PACKET_SIZE) {
+            int bytesLeft = tsPacketBuffer.bytesLeft();
+            if (bytesLeft > 0) {
+                System.arraycopy(data, tsPacketBuffer.getPosition(), data, 0, bytesLeft);
+            }
+            tsPacketBuffer.reset(data, bytesLeft);
+        }
+        // Read more bytes until there is at least one packet size
+        while (tsPacketBuffer.bytesLeft() < TS_PACKET_SIZE) {
+            int limit = tsPacketBuffer.limit();
+
+            // 可以新读取的数据
+            int read = input.read(data, limit, BUFFER_SIZE - limit);
+
+            // 如果到EOF, 则直接返回EOF； 因为一个TS_PACKET都没有完整读取完毕
+            if (read == C.RESULT_END_OF_INPUT) {
+                return RESULT_END_OF_INPUT;
+            }
+            tsPacketBuffer.setLimit(limit + read);
         }
-      }
-    }
 
-  }
+        // Note: see ISO/IEC 13818-1, section 2.4.3.2 for detailed information on the format of
+        // the header.
+        // 调整position, 让position位于: SYNC_BYTE上
+        final int limit = tsPacketBuffer.limit();
+        int position = tsPacketBuffer.getPosition();
+        while (position < limit && data[position] != TS_SYNC_BYTE) {
+            position++;
+        }
+        tsPacketBuffer.setPosition(position);
 
-  /**
-   * Parses Program Map Table.
-   */
-  private class PmtReader implements SectionPayloadReader {
+        // 如果依然不够一个TS_PACKET, 则需要继续读取数据
+        int endOfPacket = position + TS_PACKET_SIZE;
+        if (endOfPacket > limit) {
+            return RESULT_CONTINUE;
+        }
 
-    private static final int TS_PMT_DESC_REGISTRATION = 0x05;
-    private static final int TS_PMT_DESC_ISO639_LANG = 0x0A;
-    private static final int TS_PMT_DESC_AC3 = 0x6A;
-    private static final int TS_PMT_DESC_EAC3 = 0x7A;
-    private static final int TS_PMT_DESC_DTS = 0x7B;
+        tsPacketBuffer.skipBytes(1);
+        tsPacketBuffer.readBytes(tsScratch, 3);
+        if (tsScratch.readBit()) { // transport_error_indicator
+            // There are uncorrectable errors in this packet.
+            tsPacketBuffer.setPosition(endOfPacket);
+            return RESULT_CONTINUE;
+        }
 
-    private final ParsableBitArray pmtScratch;
-    private final int pid;
+        boolean payloadUnitStartIndicator = tsScratch.readBit();
+        tsScratch.skipBits(1); // transport_priority
+        int pid = tsScratch.readBits(13);
+        tsScratch.skipBits(2); // transport_scrambling_control
+        boolean adaptationFieldExists = tsScratch.readBit();
+        boolean payloadExists = tsScratch.readBit();
+
+        // Discontinuity check.
+        boolean discontinuityFound = false;
+        int continuityCounter = tsScratch.readBits(4);
+        if (!hlsMode) {
+            int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
+            continuityCounters.put(pid, continuityCounter);
+            if (previousCounter == continuityCounter) {
+                if (payloadExists) {
+                    // Duplicate packet found.
+                    tsPacketBuffer.setPosition(endOfPacket);
+                    return RESULT_CONTINUE;
+                }
+            } else if (continuityCounter != (previousCounter + 1) % 16) {
+                discontinuityFound = true;
+            }
+        }
 
-    public PmtReader(int pid) {
-      pmtScratch = new ParsableBitArray(new byte[5]);
-      this.pid = pid;
-    }
+        // Skip the adaptation field.
+        if (adaptationFieldExists) {
+            int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
+            tsPacketBuffer.skipBytes(adaptationFieldLength);
+        }
 
-    @Override
-    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-        TrackIdGenerator idGenerator) {
-      // Do nothing.
+        // Read the payload.
+        if (payloadExists) {
+            TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
+            if (payloadReader != null) {
+                if (discontinuityFound) {
+                    payloadReader.seek();
+                }
+                tsPacketBuffer.setLimit(endOfPacket);
+                payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
+                Assertions.checkState(tsPacketBuffer.getPosition() <= endOfPacket);
+                tsPacketBuffer.setLimit(limit);
+            }
+        }
+
+        tsPacketBuffer.setPosition(endOfPacket);
+        return RESULT_CONTINUE;
     }
 
-    @Override
-    public void consume(ParsableByteArray sectionData) {
-      int tableId = sectionData.readUnsignedByte();
-      if (tableId != 0x02 /* TS_program_map_section */) {
-        // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
-        return;
-      }
-      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12), program_number (16),
-      // reserved (2), version_number (5), current_next_indicator (1), // section_number (8),
-      // last_section_number (8), reserved (3), PCR_PID (13)
-      sectionData.skipBytes(9);
-
-      // Read program_info_length.
-      sectionData.readBytes(pmtScratch, 2);
-      pmtScratch.skipBits(4);
-      int programInfoLength = pmtScratch.readBits(12);
-
-      // Skip the descriptors.
-      sectionData.skipBytes(programInfoLength);
-
-      if (hlsMode && id3Reader == null) {
-        // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
-        // appears intermittently during playback. See [Internal: b/20261500].
-        EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, new byte[0]);
-        id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
-        id3Reader.init(timestampAdjuster, output,
-            new TrackIdGenerator(TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
-      }
-
-      int remainingEntriesLength = sectionData.bytesLeft();
-      while (remainingEntriesLength > 0) {
-        sectionData.readBytes(pmtScratch, 5);
-        int streamType = pmtScratch.readBits(8);
-        pmtScratch.skipBits(3); // reserved
-        int elementaryPid = pmtScratch.readBits(13);
-        pmtScratch.skipBits(4); // reserved
-        int esInfoLength = pmtScratch.readBits(12); // ES_info_length.
-        EsInfo esInfo = readEsInfo(sectionData, esInfoLength);
-        if (streamType == 0x06) {
-          streamType = esInfo.streamType;
-        }
-        remainingEntriesLength -= esInfoLength + 5;
+    // Internals.
 
-        int trackId = hlsMode ? streamType : elementaryPid;
-        if (trackIds.get(trackId)) {
-          continue;
+    private void resetPayloadReaders() {
+        trackIds.clear();
+        tsPayloadReaders.clear();
+        SparseArray<TsPayloadReader> initialPayloadReaders =
+                payloadReaderFactory.createInitialPayloadReaders();
+        int initialPayloadReadersSize = initialPayloadReaders.size();
+        for (int i = 0; i < initialPayloadReadersSize; i++) {
+            tsPayloadReaders.put(initialPayloadReaders.keyAt(i), initialPayloadReaders.valueAt(i));
         }
-        trackIds.put(trackId, true);
-
-        TsPayloadReader reader;
-        if (hlsMode && streamType == TS_STREAM_TYPE_ID3) {
-          reader = id3Reader;
-        } else {
-          reader = payloadReaderFactory.createPayloadReader(streamType, esInfo);
-          if (reader != null) {
-            reader.init(timestampAdjuster, output, new TrackIdGenerator(trackId, MAX_PID_PLUS_ONE));
-          }
+        tsPayloadReaders.put(TS_PAT_PID, new SectionReader(new PatReader()));
+        id3Reader = null;
+    }
+
+    /**
+     * Parses Program Association Table data.
+     */
+    private class PatReader implements SectionPayloadReader {
+
+        private final ParsableBitArray patScratch;
+
+        public PatReader() {
+            patScratch = new ParsableBitArray(new byte[4]);
         }
 
-        if (reader != null) {
-          tsPayloadReaders.put(elementaryPid, reader);
+        @Override
+        public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+                         TrackIdGenerator idGenerator) {
+            // Do nothing.
         }
-      }
-      if (hlsMode) {
-        if (!tracksEnded) {
-          output.endTracks();
+
+        @Override
+        public void consume(ParsableByteArray sectionData) {
+            int tableId = sectionData.readUnsignedByte();
+            if (tableId != 0x00 /* program_association_section */) {
+                // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
+                return;
+            }
+            // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12),
+            // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
+            // section_number (8), last_section_number (8)
+            sectionData.skipBytes(7);
+
+            int programCount = sectionData.bytesLeft() / 4;
+            for (int i = 0; i < programCount; i++) {
+                sectionData.readBytes(patScratch, 4);
+                int programNumber = patScratch.readBits(16);
+                patScratch.skipBits(3); // reserved (3)
+                if (programNumber == 0) {
+                    patScratch.skipBits(13); // network_PID (13)
+                } else {
+                    int pid = patScratch.readBits(13);
+                    tsPayloadReaders.put(pid, new SectionReader(new PmtReader(pid)));
+                }
+            }
         }
-      } else {
-        tsPayloadReaders.remove(TS_PAT_PID);
-        tsPayloadReaders.remove(pid);
-        output.endTracks();
-      }
-      tracksEnded = true;
+
     }
 
     /**
-     * Returns the stream info read from the available descriptors. Sets {@code data}'s position to
-     * the end of the descriptors.
-     *
-     * @param data A buffer with its position set to the start of the first descriptor.
-     * @param length The length of descriptors to read from the current position in {@code data}.
-     * @return The stream info read from the available descriptors.
+     * Parses Program Map Table.
      */
-    private EsInfo readEsInfo(ParsableByteArray data, int length) {
-      int descriptorsStartPosition = data.getPosition();
-      int descriptorsEndPosition = descriptorsStartPosition + length;
-      int streamType = -1;
-      String language = null;
-      while (data.getPosition() < descriptorsEndPosition) {
-        int descriptorTag = data.readUnsignedByte();
-        int descriptorLength = data.readUnsignedByte();
-        int positionOfNextDescriptor = data.getPosition() + descriptorLength;
-        if (descriptorTag == TS_PMT_DESC_REGISTRATION) { // registration_descriptor
-          long formatIdentifier = data.readUnsignedInt();
-          if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
-            streamType = TS_STREAM_TYPE_AC3;
-          } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
-            streamType = TS_STREAM_TYPE_E_AC3;
-          } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
-            streamType = TS_STREAM_TYPE_H265;
-          }
-        } else if (descriptorTag == TS_PMT_DESC_AC3) { // AC-3_descriptor in DVB (ETSI EN 300 468)
-          streamType = TS_STREAM_TYPE_AC3;
-        } else if (descriptorTag == TS_PMT_DESC_EAC3) { // enhanced_AC-3_descriptor
-          streamType = TS_STREAM_TYPE_E_AC3;
-        } else if (descriptorTag == TS_PMT_DESC_DTS) { // DTS_descriptor
-          streamType = TS_STREAM_TYPE_DTS;
-        } else if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
-          language = new String(data.data, data.getPosition(), 3).trim();
-          // Audio type is ignored.
+    private class PmtReader implements SectionPayloadReader {
+
+        private static final int TS_PMT_DESC_REGISTRATION = 0x05;
+        private static final int TS_PMT_DESC_ISO639_LANG = 0x0A;
+        private static final int TS_PMT_DESC_AC3 = 0x6A;
+        private static final int TS_PMT_DESC_EAC3 = 0x7A;
+        private static final int TS_PMT_DESC_DTS = 0x7B;
+
+        private final ParsableBitArray pmtScratch;
+        private final int pid;
+
+        public PmtReader(int pid) {
+            pmtScratch = new ParsableBitArray(new byte[5]);
+            this.pid = pid;
         }
-        // Skip unused bytes of current descriptor.
-        data.skipBytes(positionOfNextDescriptor - data.getPosition());
-      }
-      data.setPosition(descriptorsEndPosition);
-      return new EsInfo(streamType, language,
-          Arrays.copyOfRange(data.data, descriptorsStartPosition, descriptorsEndPosition));
-    }
 
-  }
+        @Override
+        public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+                         TrackIdGenerator idGenerator) {
+            // Do nothing.
+        }
+
+        @Override
+        public void consume(ParsableByteArray sectionData) {
+            int tableId = sectionData.readUnsignedByte();
+            if (tableId != 0x02 /* TS_program_map_section */) {
+                // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
+                return;
+            }
+            // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12), program_number (16),
+            // reserved (2), version_number (5), current_next_indicator (1), // section_number (8),
+            // last_section_number (8), reserved (3), PCR_PID (13)
+            sectionData.skipBytes(9);
+
+            // Read program_info_length.
+            sectionData.readBytes(pmtScratch, 2);
+            pmtScratch.skipBits(4);
+            int programInfoLength = pmtScratch.readBits(12);
+
+            // Skip the descriptors.
+            sectionData.skipBytes(programInfoLength);
+
+            if (hlsMode && id3Reader == null) {
+                // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
+                // appears intermittently during playback. See [Internal: b/20261500].
+                EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, new byte[0]);
+                id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo);
+                id3Reader.init(timestampAdjuster, output,
+                        new TrackIdGenerator(TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
+            }
+
+            int remainingEntriesLength = sectionData.bytesLeft();
+            while (remainingEntriesLength > 0) {
+                sectionData.readBytes(pmtScratch, 5);
+                int streamType = pmtScratch.readBits(8);
+                pmtScratch.skipBits(3); // reserved
+                int elementaryPid = pmtScratch.readBits(13);
+                pmtScratch.skipBits(4); // reserved
+                int esInfoLength = pmtScratch.readBits(12); // ES_info_length.
+                EsInfo esInfo = readEsInfo(sectionData, esInfoLength);
+                if (streamType == 0x06) {
+                    streamType = esInfo.streamType;
+                }
+                remainingEntriesLength -= esInfoLength + 5;
+
+                int trackId = hlsMode ? streamType : elementaryPid;
+                if (trackIds.get(trackId)) {
+                    continue;
+                }
+                trackIds.put(trackId, true);
+
+                TsPayloadReader reader;
+                if (hlsMode && streamType == TS_STREAM_TYPE_ID3) {
+                    reader = id3Reader;
+                } else {
+                    reader = payloadReaderFactory.createPayloadReader(streamType, esInfo);
+                    if (reader != null) {
+                        reader.init(timestampAdjuster, output, new TrackIdGenerator(trackId, MAX_PID_PLUS_ONE));
+                    }
+                }
+
+                if (reader != null) {
+                    tsPayloadReaders.put(elementaryPid, reader);
+                }
+            }
+            if (hlsMode) {
+                if (!tracksEnded) {
+                    output.endTracks();
+                }
+            } else {
+                tsPayloadReaders.remove(TS_PAT_PID);
+                tsPayloadReaders.remove(pid);
+                output.endTracks();
+            }
+            tracksEnded = true;
+        }
+
+        /**
+         * Returns the stream info read from the available descriptors. Sets {@code data}'s position to
+         * the end of the descriptors.
+         *
+         * @param data   A buffer with its position set to the start of the first descriptor.
+         * @param length The length of descriptors to read from the current position in {@code data}.
+         * @return The stream info read from the available descriptors.
+         */
+        private EsInfo readEsInfo(ParsableByteArray data, int length) {
+            int descriptorsStartPosition = data.getPosition();
+            int descriptorsEndPosition = descriptorsStartPosition + length;
+            int streamType = -1;
+            String language = null;
+            while (data.getPosition() < descriptorsEndPosition) {
+                int descriptorTag = data.readUnsignedByte();
+                int descriptorLength = data.readUnsignedByte();
+                int positionOfNextDescriptor = data.getPosition() + descriptorLength;
+                if (descriptorTag == TS_PMT_DESC_REGISTRATION) { // registration_descriptor
+                    long formatIdentifier = data.readUnsignedInt();
+                    if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
+                        streamType = TS_STREAM_TYPE_AC3;
+                    } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
+                        streamType = TS_STREAM_TYPE_E_AC3;
+                    } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
+                        streamType = TS_STREAM_TYPE_H265;
+                    }
+                } else if (descriptorTag == TS_PMT_DESC_AC3) { // AC-3_descriptor in DVB (ETSI EN 300 468)
+                    streamType = TS_STREAM_TYPE_AC3;
+                } else if (descriptorTag == TS_PMT_DESC_EAC3) { // enhanced_AC-3_descriptor
+                    streamType = TS_STREAM_TYPE_E_AC3;
+                } else if (descriptorTag == TS_PMT_DESC_DTS) { // DTS_descriptor
+                    streamType = TS_STREAM_TYPE_DTS;
+                } else if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
+                    language = new String(data.data, data.getPosition(), 3).trim();
+                    // Audio type is ignored.
+                }
+                // Skip unused bytes of current descriptor.
+                data.skipBytes(positionOfNextDescriptor - data.getPosition());
+            }
+            data.setPosition(descriptorsEndPosition);
+            return new EsInfo(streamType, language,
+                    Arrays.copyOfRange(data.data, descriptorsStartPosition, descriptorsEndPosition));
+        }
+
+    }
 
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index f4a9665b10..a55a469796 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
+
 import java.io.IOException;
 
 /**
@@ -24,141 +25,141 @@
  */
 public interface MediaPeriod extends SequenceableLoader {
 
-  /**
-   * A callback to be notified of {@link MediaPeriod} events.
-   */
-  interface Callback extends SequenceableLoader.Callback<MediaPeriod> {
+    /**
+     * A callback to be notified of {@link MediaPeriod} events.
+     */
+    interface Callback extends SequenceableLoader.Callback<MediaPeriod> {
+
+        /**
+         * Called when preparation completes.
+         * <p>
+         * Called on the playback thread. After invoking this method, the {@link MediaPeriod} can expect
+         * for {@link #selectTracks(TrackSelection[], boolean[], SampleStream[], boolean[], long)} to be
+         * called with the initial track selection.
+         *
+         * @param mediaPeriod The prepared {@link MediaPeriod}.
+         */
+        void onPrepared(MediaPeriod mediaPeriod);
+
+    }
+
+    /**
+     * Prepares this media period asynchronously.
+     * <p>
+     * {@code callback.onPrepared} is called when preparation completes. If preparation fails,
+     * {@link #maybeThrowPrepareError()} will throw an {@link IOException}.
+     *
+     * @param callback Callback to receive updates from this period, including being notified when
+     *                 preparation completes.
+     */
+    void prepare(Callback callback);
+
+    /**
+     * Throws an error that's preventing the period from becoming prepared. Does nothing if no such
+     * error exists.
+     * <p>
+     * This method should only be called before the period has completed preparation.
+     *
+     * @throws IOException The underlying error.
+     */
+    void maybeThrowPrepareError() throws IOException;
+
+    /**
+     * Returns the {@link TrackGroup}s exposed by the period.
+     * <p>
+     * This method should only be called after the period has been prepared.
+     *
+     * @return The {@link TrackGroup}s.
+     */
+    TrackGroupArray getTrackGroups();
+
+    /**
+     * Performs a track selection.
+     * <p>
+     * The call receives track {@code selections} for each renderer, {@code mayRetainStreamFlags}
+     * indicating whether the existing {@code SampleStream} can be retained for each selection, and
+     * the existing {@code stream}s themselves. The call will update {@code streams} to reflect the
+     * provided selections, clearing, setting and replacing entries as required. If an existing sample
+     * stream is retained but with the requirement that the consuming renderer be reset, then the
+     * corresponding flag in {@code streamResetFlags} will be set to true. This flag will also be set
+     * if a new sample stream is created.
+     * <p>
+     * This method should only be called after the period has been prepared.
+     *
+     * @param selections           The renderer track selections.
+     * @param mayRetainStreamFlags Flags indicating whether the existing sample stream can be retained
+     *                             for each selection. A {@code true} value indicates that the selection is unchanged, and
+     *                             that the caller does not require that the sample stream be recreated.
+     * @param streams              The existing sample streams, which will be updated to reflect the provided
+     *                             selections.
+     * @param streamResetFlags     Will be updated to indicate new sample streams, and sample streams that
+     *                             have been retained but with the requirement that the consuming renderer be reset.
+     * @param positionUs           The current playback position in microseconds.
+     * @return The actual position at which the tracks were enabled, in microseconds.
+     */
+    long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+                      SampleStream[] streams, boolean[] streamResetFlags, long positionUs);
+
+    /**
+     * Attempts to read a discontinuity.
+     * <p>
+     * After this method has returned a value other than {@link C#TIME_UNSET}, all
+     * {@link SampleStream}s provided by the period are guaranteed to start from a key frame.
+     *
+     * @return If a discontinuity was read then the playback position in microseconds after the
+     * discontinuity. Else {@link C#TIME_UNSET}.
+     */
+    long readDiscontinuity();
+
+    /**
+     * Returns an estimate of the position up to which data is buffered for the enabled tracks.
+     * <p>
+     * This method should only be called when at least one track is selected.
+     *
+     * @return An estimate of the absolute position in microseconds up to which data is buffered, or
+     * {@link C#TIME_END_OF_SOURCE} if the track is fully buffered.
+     */
+    long getBufferedPositionUs();
+
+    /**
+     * Attempts to seek to the specified position in microseconds.
+     * <p>
+     * After this method has been called, all {@link SampleStream}s provided by the period are
+     * guaranteed to start from a key frame.
+     * <p>
+     * This method should only be called when at least one track is selected.
+     *
+     * @param positionUs The seek position in microseconds.
+     * @return The actual position to which the period was seeked, in microseconds.
+     */
+    long seekToUs(long positionUs);
+
+    // SequenceableLoader interface. Overridden to provide more specific documentation.
+
+    /**
+     * Returns the next load time, or {@link C#TIME_END_OF_SOURCE} if loading has finished.
+     * <p>
+     * This method should only be called after the period has been prepared. It may be called when no
+     * tracks are selected.
+     */
+    @Override
+    long getNextLoadPositionUs();
 
     /**
-     * Called when preparation completes.
+     * Attempts to continue loading.
+     * <p>
+     * This method may be called both during and after the period has been prepared.
      * <p>
-     * Called on the playback thread. After invoking this method, the {@link MediaPeriod} can expect
-     * for {@link #selectTracks(TrackSelection[], boolean[], SampleStream[], boolean[], long)} to be
-     * called with the initial track selection.
+     * A period may call {@link Callback#onContinueLoadingRequested(SequenceableLoader)} on the
+     * {@link Callback} passed to {@link #prepare(Callback)} to request that this method be called
+     * when the period is permitted to continue loading data. A period may do this both during and
+     * after preparation.
      *
-     * @param mediaPeriod The prepared {@link MediaPeriod}.
+     * @param positionUs The current playback position.
+     * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return
+     * a different value than prior to the call. False otherwise.
      */
-    void onPrepared(MediaPeriod mediaPeriod);
-
-  }
-
-  /**
-   * Prepares this media period asynchronously.
-   * <p>
-   * {@code callback.onPrepared} is called when preparation completes. If preparation fails,
-   * {@link #maybeThrowPrepareError()} will throw an {@link IOException}.
-   *
-   * @param callback Callback to receive updates from this period, including being notified when
-   *     preparation completes.
-   */
-  void prepare(Callback callback);
-
-  /**
-   * Throws an error that's preventing the period from becoming prepared. Does nothing if no such
-   * error exists.
-   * <p>
-   * This method should only be called before the period has completed preparation.
-   *
-   * @throws IOException The underlying error.
-   */
-  void maybeThrowPrepareError() throws IOException;
-
-  /**
-   * Returns the {@link TrackGroup}s exposed by the period.
-   * <p>
-   * This method should only be called after the period has been prepared.
-   *
-   * @return The {@link TrackGroup}s.
-   */
-  TrackGroupArray getTrackGroups();
-
-  /**
-   * Performs a track selection.
-   * <p>
-   * The call receives track {@code selections} for each renderer, {@code mayRetainStreamFlags}
-   * indicating whether the existing {@code SampleStream} can be retained for each selection, and
-   * the existing {@code stream}s themselves. The call will update {@code streams} to reflect the
-   * provided selections, clearing, setting and replacing entries as required. If an existing sample
-   * stream is retained but with the requirement that the consuming renderer be reset, then the
-   * corresponding flag in {@code streamResetFlags} will be set to true. This flag will also be set
-   * if a new sample stream is created.
-   * <p>
-   * This method should only be called after the period has been prepared.
-   *
-   * @param selections The renderer track selections.
-   * @param mayRetainStreamFlags Flags indicating whether the existing sample stream can be retained
-   *     for each selection. A {@code true} value indicates that the selection is unchanged, and
-   *     that the caller does not require that the sample stream be recreated.
-   * @param streams The existing sample streams, which will be updated to reflect the provided
-   *     selections.
-   * @param streamResetFlags Will be updated to indicate new sample streams, and sample streams that
-   *     have been retained but with the requirement that the consuming renderer be reset.
-   * @param positionUs The current playback position in microseconds.
-   * @return The actual position at which the tracks were enabled, in microseconds.
-   */
-  long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-      SampleStream[] streams, boolean[] streamResetFlags, long positionUs);
-
-  /**
-   * Attempts to read a discontinuity.
-   * <p>
-   * After this method has returned a value other than {@link C#TIME_UNSET}, all
-   * {@link SampleStream}s provided by the period are guaranteed to start from a key frame.
-   *
-   * @return If a discontinuity was read then the playback position in microseconds after the
-   *     discontinuity. Else {@link C#TIME_UNSET}.
-   */
-  long readDiscontinuity();
-
-  /**
-   * Returns an estimate of the position up to which data is buffered for the enabled tracks.
-   * <p>
-   * This method should only be called when at least one track is selected.
-   *
-   * @return An estimate of the absolute position in microseconds up to which data is buffered, or
-   *     {@link C#TIME_END_OF_SOURCE} if the track is fully buffered.
-   */
-  long getBufferedPositionUs();
-
-  /**
-   * Attempts to seek to the specified position in microseconds.
-   * <p>
-   * After this method has been called, all {@link SampleStream}s provided by the period are
-   * guaranteed to start from a key frame.
-   * <p>
-   * This method should only be called when at least one track is selected.
-   *
-   * @param positionUs The seek position in microseconds.
-   * @return The actual position to which the period was seeked, in microseconds.
-   */
-  long seekToUs(long positionUs);
-
-  // SequenceableLoader interface. Overridden to provide more specific documentation.
-
-  /**
-   * Returns the next load time, or {@link C#TIME_END_OF_SOURCE} if loading has finished.
-   * <p>
-   * This method should only be called after the period has been prepared. It may be called when no
-   * tracks are selected.
-   */
-  @Override
-  long getNextLoadPositionUs();
-
-  /**
-   * Attempts to continue loading.
-   * <p>
-   * This method may be called both during and after the period has been prepared.
-   * <p>
-   * A period may call {@link Callback#onContinueLoadingRequested(SequenceableLoader)} on the
-   * {@link Callback} passed to {@link #prepare(Callback)} to request that this method be called
-   * when the period is permitted to continue loading data. A period may do this both during and
-   * after preparation.
-   *
-   * @param positionUs The current playback position.
-   * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return
-   *     a different value than prior to the call. False otherwise.
-   */
-  @Override
-  boolean continueLoading(long positionUs);
+    @Override
+    boolean continueLoading(long positionUs);
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index f013e790f7..50de1c96a2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
+
 import java.io.IOException;
 
 /**
@@ -25,63 +26,63 @@
  */
 public interface MediaSource {
 
-  /**
-   * Listener for source events.
-   */
-  interface Listener {
-
     /**
-     * Called when manifest and/or timeline has been refreshed.
-     *
-     * @param timeline The source's timeline.
-     * @param manifest The loaded manifest.
+     * Listener for source events.
      */
-    void onSourceInfoRefreshed(Timeline timeline, Object manifest);
+    interface Listener {
 
-  }
+        /**
+         * Called when manifest and/or timeline has been refreshed.
+         *
+         * @param timeline The source's timeline.
+         * @param manifest The loaded manifest.
+         */
+        void onSourceInfoRefreshed(Timeline timeline, Object manifest);
 
-  /**
-   * Starts preparation of the source.
-   *
-   * @param player The player for which this source is being prepared.
-   * @param isTopLevelSource Whether this source has been passed directly to
-   *     {@link ExoPlayer#prepare(MediaSource)} or
-   *     {@link ExoPlayer#prepare(MediaSource, boolean, boolean)}. If {@code false}, this source is
-   *     being prepared by another source (e.g. {@link ConcatenatingMediaSource}) for composition.
-   * @param listener The listener for source events.
-   */
-  void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener);
+    }
 
-  /**
-   * Throws any pending error encountered while loading or refreshing source information.
-   */
-  void maybeThrowSourceInfoRefreshError() throws IOException;
+    /**
+     * Starts preparation of the source.
+     *
+     * @param player           The player for which this source is being prepared.
+     * @param isTopLevelSource Whether this source has been passed directly to
+     *                         {@link ExoPlayer#prepare(MediaSource)} or
+     *                         {@link ExoPlayer#prepare(MediaSource, boolean, boolean)}. If {@code false}, this source is
+     *                         being prepared by another source (e.g. {@link ConcatenatingMediaSource}) for composition.
+     * @param listener         The listener for source events.
+     */
+    void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener);
 
-  /**
-   * Returns a new {@link MediaPeriod} corresponding to the period at the specified {@code index}.
-   * This method may be called multiple times with the same index without an intervening call to
-   * {@link #releasePeriod(MediaPeriod)}.
-   *
-   * @param index The index of the period.
-   * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
-   * @param positionUs The player's current playback position.
-   * @return A new {@link MediaPeriod}.
-   */
-  MediaPeriod createPeriod(int index, Allocator allocator, long positionUs);
+    /**
+     * Throws any pending error encountered while loading or refreshing source information.
+     */
+    void maybeThrowSourceInfoRefreshError() throws IOException;
 
-  /**
-   * Releases the period.
-   *
-   * @param mediaPeriod The period to release.
-   */
-  void releasePeriod(MediaPeriod mediaPeriod);
+    /**
+     * Returns a new {@link MediaPeriod} corresponding to the period at the specified {@code index}.
+     * This method may be called multiple times with the same index without an intervening call to
+     * {@link #releasePeriod(MediaPeriod)}.
+     *
+     * @param index      The index of the period.
+     * @param allocator  An {@link Allocator} from which to obtain media buffer allocations.
+     * @param positionUs The player's current playback position.
+     * @return A new {@link MediaPeriod}.
+     */
+    MediaPeriod createPeriod(int index, Allocator allocator, long positionUs);
+
+    /**
+     * Releases the period.
+     *
+     * @param mediaPeriod The period to release.
+     */
+    void releasePeriod(MediaPeriod mediaPeriod);
 
-  /**
-   * Releases the source.
-   * <p>
-   * This method should be called when the source is no longer required. It may be called in any
-   * state.
-   */
-  void releaseSource();
+    /**
+     * Releases the source.
+     * <p>
+     * This method should be called when the source is no longer required. It may be called in any
+     * state.
+     */
+    void releaseSource();
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
index 39374acb33..396238504d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SampleStream.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+
 import java.io.IOException;
 
 /**
@@ -25,40 +26,40 @@
  */
 public interface SampleStream {
 
-  /**
-   * Returns whether data is available to be read.
-   * <p>
-   * Note: If the stream has ended then a buffer with the end of stream flag can always be read from
-   * {@link #readData(FormatHolder, DecoderInputBuffer)}. Hence an ended stream is always ready.
-   *
-   * @return Whether data is available to be read.
-   */
-  boolean isReady();
+    /**
+     * Returns whether data is available to be read.
+     * <p>
+     * Note: If the stream has ended then a buffer with the end of stream flag can always be read from
+     * {@link #readData(FormatHolder, DecoderInputBuffer)}. Hence an ended stream is always ready.
+     *
+     * @return Whether data is available to be read.
+     */
+    boolean isReady();
 
-  /**
-   * Throws an error that's preventing data from being read. Does nothing if no such error exists.
-   *
-   * @throws IOException The underlying error.
-   */
-  void maybeThrowError() throws IOException;
+    /**
+     * Throws an error that's preventing data from being read. Does nothing if no such error exists.
+     *
+     * @throws IOException The underlying error.
+     */
+    void maybeThrowError() throws IOException;
 
-  /**
-   * Attempts to read from the stream.
-   *
-   * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
-   * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
-   *     end of the stream. If the end of the stream has been reached, the
-   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
-   * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
-   *     {@link C#RESULT_BUFFER_READ}.
-   */
-  int readData(FormatHolder formatHolder, DecoderInputBuffer buffer);
+    /**
+     * Attempts to read from the stream.
+     *
+     * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
+     * @param buffer       A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
+     *                     end of the stream. If the end of the stream has been reached, the
+     *                     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
+     * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
+     * {@link C#RESULT_BUFFER_READ}.
+     */
+    int readData(FormatHolder formatHolder, DecoderInputBuffer buffer);
 
-  /**
-   * Attempts to skip to the keyframe before the specified time.
-   *
-   * @param timeUs The specified time.
-   */
-  void skipToKeyframeBefore(long timeUs);
+    /**
+     * Attempts to skip to the keyframe before the specified time.
+     *
+     * @param timeUs The specified time.
+     */
+    void skipToKeyframeBefore(long timeUs);
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java b/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
index 9aebcece9e..6e932b6617 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
@@ -22,31 +22,31 @@
  */
 public interface SequenceableLoader {
 
-  /**
-   * A callback to be notified of {@link SequenceableLoader} events.
-   */
-  interface Callback<T extends SequenceableLoader> {
+    /**
+     * A callback to be notified of {@link SequenceableLoader} events.
+     */
+    interface Callback<T extends SequenceableLoader> {
+
+        /**
+         * Called by the loader to indicate that it wishes for its {@link #continueLoading(long)} method
+         * to be called when it can continue to load data. Called on the playback thread.
+         */
+        void onContinueLoadingRequested(T source);
+
+    }
+
+    /**
+     * Returns the next load time, or {@link C#TIME_END_OF_SOURCE} if loading has finished.
+     */
+    long getNextLoadPositionUs();
 
     /**
-     * Called by the loader to indicate that it wishes for its {@link #continueLoading(long)} method
-     * to be called when it can continue to load data. Called on the playback thread.
+     * Attempts to continue loading.
+     *
+     * @param positionUs The current playback position.
+     * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return
+     * a different value than prior to the call. False otherwise.
      */
-    void onContinueLoadingRequested(T source);
-
-  }
-
-  /**
-   * Returns the next load time, or {@link C#TIME_END_OF_SOURCE} if loading has finished.
-   */
-  long getNextLoadPositionUs();
-
-  /**
-   * Attempts to continue loading.
-   *
-   * @param positionUs The current playback position.
-   * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return
-   *     a different value than prior to the call. False otherwise.
-   */
-  boolean continueLoading(long positionUs);
+    boolean continueLoading(long positionUs);
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index 731c78bcff..8437f6301c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -22,100 +22,102 @@
 /**
  * A {@link Timeline} consisting of a single period and static window.
  * 只包含1个window和1个period的Timeline
+ * <p>
+ * 在点播场景中基本上都是这个实现
  */
 public final class SinglePeriodTimeline extends Timeline {
 
-  private static final Object ID = new Object();
+    private static final Object ID = new Object();
 
-  private final long periodDurationUs;
-  private final long windowDurationUs;
-  private final long windowPositionInPeriodUs;
-  private final long windowDefaultStartPositionUs;
-  private final boolean isSeekable;
-  private final boolean isDynamic;
+    private final long periodDurationUs;
+    private final long windowDurationUs;
+    private final long windowPositionInPeriodUs;
+    private final long windowDefaultStartPositionUs;
+    private final boolean isSeekable;
+    private final boolean isDynamic;
 
-  /**
-   * Creates a timeline of one period of known duration, and a static window starting at zero and
-   * extending to that duration.
-   *
-   * @param durationUs The duration of the period, in microseconds.
-   * @param isSeekable Whether seeking is supported within the period.
-   */
-  public SinglePeriodTimeline(long durationUs, boolean isSeekable) {
-    this(durationUs, durationUs, 0, 0, isSeekable, false);
-  }
+    /**
+     * Creates a timeline of one period of known duration, and a static window starting at zero and
+     * extending to that duration.
+     *
+     * @param durationUs The duration of the period, in microseconds.
+     * @param isSeekable Whether seeking is supported within the period.
+     */
+    public SinglePeriodTimeline(long durationUs, boolean isSeekable) {
+        this(durationUs, durationUs, 0, 0, isSeekable, false);
+    }
 
-  /**
-   * Creates a timeline with one period of known duration, and a window of known duration starting
-   * at a specified position in the period.
-   *
-   * @param periodDurationUs The duration of the period in microseconds.
-   * @param windowDurationUs The duration of the window in microseconds.
-   * @param windowPositionInPeriodUs The position of the start of the window in the period, in
-   *     microseconds.
-   * @param windowDefaultStartPositionUs The default position relative to the start of the window at
-   *     which to begin playback, in microseconds.
-   * @param isSeekable Whether seeking is supported within the window.
-   * @param isDynamic Whether the window may change when the timeline is updated.
-   */
-  public SinglePeriodTimeline(long periodDurationUs, long windowDurationUs,
-      long windowPositionInPeriodUs, long windowDefaultStartPositionUs, boolean isSeekable,
-      boolean isDynamic) {
-    this.periodDurationUs = periodDurationUs;
-    this.windowDurationUs = windowDurationUs;
-    this.windowPositionInPeriodUs = windowPositionInPeriodUs;
-    this.windowDefaultStartPositionUs = windowDefaultStartPositionUs;
-    this.isSeekable = isSeekable;
-    this.isDynamic = isDynamic;
-  }
+    /**
+     * Creates a timeline with one period of known duration, and a window of known duration starting
+     * at a specified position in the period.
+     *
+     * @param periodDurationUs             The duration of the period in microseconds.
+     * @param windowDurationUs             The duration of the window in microseconds.
+     * @param windowPositionInPeriodUs     The position of the start of the window in the period, in
+     *                                     microseconds.
+     * @param windowDefaultStartPositionUs The default position relative to the start of the window at
+     *                                     which to begin playback, in microseconds.
+     * @param isSeekable                   Whether seeking is supported within the window.
+     * @param isDynamic                    Whether the window may change when the timeline is updated.
+     */
+    public SinglePeriodTimeline(long periodDurationUs, long windowDurationUs,
+                                long windowPositionInPeriodUs, long windowDefaultStartPositionUs, boolean isSeekable,
+                                boolean isDynamic) {
+        this.periodDurationUs = periodDurationUs;
+        this.windowDurationUs = windowDurationUs;
+        this.windowPositionInPeriodUs = windowPositionInPeriodUs;
+        this.windowDefaultStartPositionUs = windowDefaultStartPositionUs;
+        this.isSeekable = isSeekable;
+        this.isDynamic = isDynamic;
+    }
 
-  @Override
-  public int getWindowCount() {
-    return 1;
-  }
+    @Override
+    public int getWindowCount() {
+        return 1;
+    }
 
-  @Override
-  public Window getWindow(int windowIndex, Window window, boolean setIds, long defaultPositionProjectionUs) {
-    Assertions.checkIndex(windowIndex, 0, 1);
+    @Override
+    public Window getWindow(int windowIndex, Window window, boolean setIds, long defaultPositionProjectionUs) {
+        Assertions.checkIndex(windowIndex, 0, 1);
 
-    Object id = setIds ? ID : null;
-    long windowDefaultStartPositionUs = this.windowDefaultStartPositionUs;
+        Object id = setIds ? ID : null;
+        long windowDefaultStartPositionUs = this.windowDefaultStartPositionUs;
 
-    //
-    // 正常情况下 isDynamic  == false
-    //
-    if (isDynamic) {
-      windowDefaultStartPositionUs += defaultPositionProjectionUs;
-      if (windowDefaultStartPositionUs > windowDurationUs) {
-        // The projection takes us beyond the end of the live window.
-        windowDefaultStartPositionUs = C.TIME_UNSET;
-      }
-    }
+        //
+        // 正常情况下 isDynamic  == false
+        //
+        if (isDynamic) {
+            windowDefaultStartPositionUs += defaultPositionProjectionUs;
+            if (windowDefaultStartPositionUs > windowDurationUs) {
+                // The projection takes us beyond the end of the live window.
+                windowDefaultStartPositionUs = C.TIME_UNSET;
+            }
+        }
 
-    // 修改window的信息
-    // Object id, long presentationStartTimeMs, long windowStartTimeMs,
-    // boolean isSeekable, boolean isDynamic, long defaultPositionUs, long durationUs,
-    // int firstPeriodIndex, int lastPeriodIndex, long positionInFirstPeriodUs
-    return window.set(id, C.TIME_UNSET, C.TIME_UNSET,
-            isSeekable, isDynamic, windowDefaultStartPositionUs, windowDurationUs,
-            0, 0, windowPositionInPeriodUs);
-  }
+        // 修改window的信息
+        // Object id, long presentationStartTimeMs, long windowStartTimeMs,
+        // boolean isSeekable, boolean isDynamic, long defaultPositionUs, long durationUs,
+        // int firstPeriodIndex, int lastPeriodIndex, long positionInFirstPeriodUs
+        return window.set(id, C.TIME_UNSET, C.TIME_UNSET,
+                isSeekable, isDynamic, windowDefaultStartPositionUs, windowDurationUs,
+                0, 0, windowPositionInPeriodUs);
+    }
 
-  @Override
-  public int getPeriodCount() {
-    return 1;
-  }
+    @Override
+    public int getPeriodCount() {
+        return 1;
+    }
 
-  @Override
-  public Period getPeriod(int periodIndex, Period period, boolean setIds) {
-    Assertions.checkIndex(periodIndex, 0, 1);
-    Object id = setIds ? ID : null;
-    return period.set(id, id, 0, periodDurationUs, -windowPositionInPeriodUs);
-  }
+    @Override
+    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+        Assertions.checkIndex(periodIndex, 0, 1);
+        Object id = setIds ? ID : null;
+        return period.set(id, id, 0, periodDurationUs, -windowPositionInPeriodUs);
+    }
 
-  @Override
-  public int getIndexOfPeriod(Object uid) {
-    return ID.equals(uid) ? 0 : C.INDEX_UNSET;
-  }
+    @Override
+    public int getIndexOfPeriod(Object uid) {
+        return ID.equals(uid) ? 0 : C.INDEX_UNSET;
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 1ad448bd12..4131734b5d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.os.Handler;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
@@ -28,6 +29,7 @@
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
 import com.google.android.exoplayer2.util.Assertions;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -35,251 +37,252 @@
 /**
  * A {@link MediaPeriod} with a single sample.
  */
-/* package */ final class SingleSampleMediaPeriod implements MediaPeriod,
-    Loader.Callback<SingleSampleMediaPeriod.SourceLoadable>  {
-
-  /**
-   * The initial size of the allocation used to hold the sample data.
-   */
-  private static final int INITIAL_SAMPLE_SIZE = 1024;
-
-  private final Uri uri;
-  private final DataSource.Factory dataSourceFactory;
-  private final int minLoadableRetryCount;
-  private final Handler eventHandler;
-  private final EventListener eventListener;
-  private final int eventSourceId;
-  private final TrackGroupArray tracks;
-  private final ArrayList<SampleStreamImpl> sampleStreams;
-  /* package */ final Loader loader;
-  /* package */ final Format format;
-
-  /* package */ boolean loadingFinished;
-  /* package */ byte[] sampleData;
-  /* package */ int sampleSize;
-
-  public SingleSampleMediaPeriod(Uri uri, DataSource.Factory dataSourceFactory, Format format,
-      int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
-      int eventSourceId) {
-    this.uri = uri;
-    this.dataSourceFactory = dataSourceFactory;
-    this.format = format;
-    this.minLoadableRetryCount = minLoadableRetryCount;
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
-    this.eventSourceId = eventSourceId;
-    tracks = new TrackGroupArray(new TrackGroup(format));
-    sampleStreams = new ArrayList<>();
-    loader = new Loader("Loader:SingleSampleMediaPeriod");
-  }
-
-  public void release() {
-    loader.release();
-  }
-
-  @Override
-  public void prepare(Callback callback) {
-    callback.onPrepared(this);
-  }
-
-  @Override
-  public void maybeThrowPrepareError() throws IOException {
-    loader.maybeThrowError();
-  }
-
-  @Override
-  public TrackGroupArray getTrackGroups() {
-    return tracks;
-  }
-
-  @Override
-  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-    for (int i = 0; i < selections.length; i++) {
-      if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
-        sampleStreams.remove(streams[i]);
-        streams[i] = null;
-      }
-      if (streams[i] == null && selections[i] != null) {
-        SampleStreamImpl stream = new SampleStreamImpl();
-        sampleStreams.add(stream);
-        streams[i] = stream;
-        streamResetFlags[i] = true;
-      }
-    }
-    return positionUs;
-  }
+/* package */
+final class SingleSampleMediaPeriod implements MediaPeriod,
+        Loader.Callback<SingleSampleMediaPeriod.SourceLoadable> {
 
-  @Override
-  public boolean continueLoading(long positionUs) {
-    if (loadingFinished || loader.isLoading()) {
-      return false;
-    }
-    loader.startLoading(new SourceLoadable(uri, dataSourceFactory.createDataSource()), this,
-        minLoadableRetryCount);
-    return true;
-  }
-
-  @Override
-  public long readDiscontinuity() {
-    return C.TIME_UNSET;
-  }
-
-  @Override
-  public long getNextLoadPositionUs() {
-    return loadingFinished || loader.isLoading() ? C.TIME_END_OF_SOURCE : 0;
-  }
-
-  @Override
-  public long getBufferedPositionUs() {
-    return loadingFinished ? C.TIME_END_OF_SOURCE : 0;
-  }
-
-  @Override
-  public long seekToUs(long positionUs) {
-    for (int i = 0; i < sampleStreams.size(); i++) {
-      sampleStreams.get(i).seekToUs(positionUs);
-    }
-    return positionUs;
-  }
-
-  // Loader.Callback implementation.
-
-  @Override
-  public void onLoadCompleted(SourceLoadable loadable, long elapsedRealtimeMs,
-      long loadDurationMs) {
-    sampleSize = loadable.sampleSize;
-    sampleData = loadable.sampleData;
-    loadingFinished = true;
-  }
-
-  @Override
-  public void onLoadCanceled(SourceLoadable loadable, long elapsedRealtimeMs, long loadDurationMs,
-      boolean released) {
-    // Do nothing.
-  }
-
-  @Override
-  public int onLoadError(SourceLoadable loadable, long elapsedRealtimeMs, long loadDurationMs,
-      IOException error) {
-    notifyLoadError(error);
-    return Loader.RETRY;
-  }
-
-  // Internal methods.
-
-  private void notifyLoadError(final IOException e) {
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          eventListener.onLoadError(eventSourceId, e);
-        }
-      });
-    }
-  }
+    /**
+     * The initial size of the allocation used to hold the sample data.
+     */
+    private static final int INITIAL_SAMPLE_SIZE = 1024;
 
-  private final class SampleStreamImpl implements SampleStream {
+    private final Uri uri;
+    private final DataSource.Factory dataSourceFactory;
+    private final int minLoadableRetryCount;
+    private final Handler eventHandler;
+    private final EventListener eventListener;
+    private final int eventSourceId;
+    private final TrackGroupArray tracks;
+    private final ArrayList<SampleStreamImpl> sampleStreams;
+    /* package */ final Loader loader;
+    /* package */ final Format format;
+
+    /* package */ boolean loadingFinished;
+    /* package */ byte[] sampleData;
+    /* package */ int sampleSize;
+
+    public SingleSampleMediaPeriod(Uri uri, DataSource.Factory dataSourceFactory, Format format,
+                                   int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
+                                   int eventSourceId) {
+        this.uri = uri;
+        this.dataSourceFactory = dataSourceFactory;
+        this.format = format;
+        this.minLoadableRetryCount = minLoadableRetryCount;
+        this.eventHandler = eventHandler;
+        this.eventListener = eventListener;
+        this.eventSourceId = eventSourceId;
+        tracks = new TrackGroupArray(new TrackGroup(format));
+        sampleStreams = new ArrayList<>();
+        loader = new Loader("Loader:SingleSampleMediaPeriod");
+    }
 
-    private static final int STREAM_STATE_SEND_FORMAT = 0;
-    private static final int STREAM_STATE_SEND_SAMPLE = 1;
-    private static final int STREAM_STATE_END_OF_STREAM = 2;
+    public void release() {
+        loader.release();
+    }
 
-    private int streamState;
+    @Override
+    public void prepare(Callback callback) {
+        callback.onPrepared(this);
+    }
 
-    public void seekToUs(long positionUs) {
-      if (streamState == STREAM_STATE_END_OF_STREAM) {
-        streamState = STREAM_STATE_SEND_SAMPLE;
-      }
+    @Override
+    public void maybeThrowPrepareError() throws IOException {
+        loader.maybeThrowError();
     }
 
     @Override
-    public boolean isReady() {
-      return loadingFinished;
+    public TrackGroupArray getTrackGroups() {
+        return tracks;
     }
 
     @Override
-    public void maybeThrowError() throws IOException {
-      loader.maybeThrowError();
+    public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+                             SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+        for (int i = 0; i < selections.length; i++) {
+            if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
+                sampleStreams.remove(streams[i]);
+                streams[i] = null;
+            }
+            if (streams[i] == null && selections[i] != null) {
+                SampleStreamImpl stream = new SampleStreamImpl();
+                sampleStreams.add(stream);
+                streams[i] = stream;
+                streamResetFlags[i] = true;
+            }
+        }
+        return positionUs;
     }
 
     @Override
-    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
-      if (streamState == STREAM_STATE_END_OF_STREAM) {
-        buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
-        return C.RESULT_BUFFER_READ;
-      } else if (streamState == STREAM_STATE_SEND_FORMAT) {
-        formatHolder.format = format;
-        streamState = STREAM_STATE_SEND_SAMPLE;
-        return C.RESULT_FORMAT_READ;
-      }
-
-      Assertions.checkState(streamState == STREAM_STATE_SEND_SAMPLE);
-      if (!loadingFinished) {
-        return C.RESULT_NOTHING_READ;
-      } else {
-        buffer.timeUs = 0;
-        buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
-        buffer.ensureSpaceForWrite(sampleSize);
-        buffer.data.put(sampleData, 0, sampleSize);
-        streamState = STREAM_STATE_END_OF_STREAM;
-        return C.RESULT_BUFFER_READ;
-      }
+    public boolean continueLoading(long positionUs) {
+        if (loadingFinished || loader.isLoading()) {
+            return false;
+        }
+        loader.startLoading(new SourceLoadable(uri, dataSourceFactory.createDataSource()), this,
+                minLoadableRetryCount);
+        return true;
     }
 
     @Override
-    public void skipToKeyframeBefore(long timeUs) {
-      // Do nothing.
+    public long readDiscontinuity() {
+        return C.TIME_UNSET;
     }
 
-  }
+    @Override
+    public long getNextLoadPositionUs() {
+        return loadingFinished || loader.isLoading() ? C.TIME_END_OF_SOURCE : 0;
+    }
 
-  /* package */ static final class SourceLoadable implements Loadable {
+    @Override
+    public long getBufferedPositionUs() {
+        return loadingFinished ? C.TIME_END_OF_SOURCE : 0;
+    }
 
-    private final Uri uri;
-    private final DataSource dataSource;
+    @Override
+    public long seekToUs(long positionUs) {
+        for (int i = 0; i < sampleStreams.size(); i++) {
+            sampleStreams.get(i).seekToUs(positionUs);
+        }
+        return positionUs;
+    }
 
-    private int sampleSize;
-    private byte[] sampleData;
+    // Loader.Callback implementation.
 
-    public SourceLoadable(Uri uri, DataSource dataSource) {
-      this.uri = uri;
-      this.dataSource = dataSource;
+    @Override
+    public void onLoadCompleted(SourceLoadable loadable, long elapsedRealtimeMs,
+                                long loadDurationMs) {
+        sampleSize = loadable.sampleSize;
+        sampleData = loadable.sampleData;
+        loadingFinished = true;
     }
 
     @Override
-    public void cancelLoad() {
-      // Never happens.
+    public void onLoadCanceled(SourceLoadable loadable, long elapsedRealtimeMs, long loadDurationMs,
+                               boolean released) {
+        // Do nothing.
     }
 
     @Override
-    public boolean isLoadCanceled() {
-      return false;
+    public int onLoadError(SourceLoadable loadable, long elapsedRealtimeMs, long loadDurationMs,
+                           IOException error) {
+        notifyLoadError(error);
+        return Loader.RETRY;
     }
 
-    @Override
-    public void load() throws IOException, InterruptedException {
-      // We always load from the beginning, so reset the sampleSize to 0.
-      sampleSize = 0;
-      try {
-        // Create and open the input.
-        dataSource.open(new DataSpec(uri));
-        // Load the sample data.
-        int result = 0;
-        while (result != C.RESULT_END_OF_INPUT) {
-          sampleSize += result;
-          if (sampleData == null) {
-            sampleData = new byte[INITIAL_SAMPLE_SIZE];
-          } else if (sampleSize == sampleData.length) {
-            sampleData = Arrays.copyOf(sampleData, sampleData.length * 2);
-          }
-          result = dataSource.read(sampleData, sampleSize, sampleData.length - sampleSize);
+    // Internal methods.
+
+    private void notifyLoadError(final IOException e) {
+        if (eventHandler != null && eventListener != null) {
+            eventHandler.post(new Runnable() {
+                @Override
+                public void run() {
+                    eventListener.onLoadError(eventSourceId, e);
+                }
+            });
         }
-      } finally {
-        dataSource.close();
-      }
     }
 
-  }
+    private final class SampleStreamImpl implements SampleStream {
+
+        private static final int STREAM_STATE_SEND_FORMAT = 0;
+        private static final int STREAM_STATE_SEND_SAMPLE = 1;
+        private static final int STREAM_STATE_END_OF_STREAM = 2;
+
+        private int streamState;
+
+        public void seekToUs(long positionUs) {
+            if (streamState == STREAM_STATE_END_OF_STREAM) {
+                streamState = STREAM_STATE_SEND_SAMPLE;
+            }
+        }
+
+        @Override
+        public boolean isReady() {
+            return loadingFinished;
+        }
+
+        @Override
+        public void maybeThrowError() throws IOException {
+            loader.maybeThrowError();
+        }
+
+        @Override
+        public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
+            if (streamState == STREAM_STATE_END_OF_STREAM) {
+                buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
+                return C.RESULT_BUFFER_READ;
+            } else if (streamState == STREAM_STATE_SEND_FORMAT) {
+                formatHolder.format = format;
+                streamState = STREAM_STATE_SEND_SAMPLE;
+                return C.RESULT_FORMAT_READ;
+            }
+
+            Assertions.checkState(streamState == STREAM_STATE_SEND_SAMPLE);
+            if (!loadingFinished) {
+                return C.RESULT_NOTHING_READ;
+            } else {
+                buffer.timeUs = 0;
+                buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
+                buffer.ensureSpaceForWrite(sampleSize);
+                buffer.data.put(sampleData, 0, sampleSize);
+                streamState = STREAM_STATE_END_OF_STREAM;
+                return C.RESULT_BUFFER_READ;
+            }
+        }
+
+        @Override
+        public void skipToKeyframeBefore(long timeUs) {
+            // Do nothing.
+        }
+
+    }
+
+    /* package */ static final class SourceLoadable implements Loadable {
+
+        private final Uri uri;
+        private final DataSource dataSource;
+
+        private int sampleSize;
+        private byte[] sampleData;
+
+        public SourceLoadable(Uri uri, DataSource dataSource) {
+            this.uri = uri;
+            this.dataSource = dataSource;
+        }
+
+        @Override
+        public void cancelLoad() {
+            // Never happens.
+        }
+
+        @Override
+        public boolean isLoadCanceled() {
+            return false;
+        }
+
+        @Override
+        public void load() throws IOException, InterruptedException {
+            // We always load from the beginning, so reset the sampleSize to 0.
+            sampleSize = 0;
+            try {
+                // Create and open the input.
+                dataSource.open(new DataSpec(uri));
+                // Load the sample data.
+                int result = 0;
+                while (result != C.RESULT_END_OF_INPUT) {
+                    sampleSize += result;
+                    if (sampleData == null) {
+                        sampleData = new byte[INITIAL_SAMPLE_SIZE];
+                    } else if (sampleSize == sampleData.length) {
+                        sampleData = Arrays.copyOf(sampleData, sampleData.length * 2);
+                    }
+                    result = dataSource.read(sampleData, sampleSize, sampleData.length - sampleSize);
+                }
+            } finally {
+                dataSource.close();
+            }
+        }
+
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index f6ee84a6f4..73a79f1671 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -17,12 +17,14 @@
 
 import android.net.Uri;
 import android.os.Handler;
+
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
+
 import java.io.IOException;
 
 /**
@@ -30,85 +32,85 @@
  */
 public final class SingleSampleMediaSource implements MediaSource {
 
-  /**
-   * Listener of {@link SingleSampleMediaSource} events.
-   */
-  public interface EventListener {
+    /**
+     * Listener of {@link SingleSampleMediaSource} events.
+     */
+    public interface EventListener {
+
+        /**
+         * Called when an error occurs loading media data.
+         *
+         * @param sourceId The id of the reporting {@link SingleSampleMediaSource}.
+         * @param e        The cause of the failure.
+         */
+        void onLoadError(int sourceId, IOException e);
+
+    }
 
     /**
-     * Called when an error occurs loading media data.
-     *
-     * @param sourceId The id of the reporting {@link SingleSampleMediaSource}.
-     * @param e The cause of the failure.
+     * The default minimum number of times to retry loading data prior to failing.
      */
-    void onLoadError(int sourceId, IOException e);
-
-  }
-
-  /**
-   * The default minimum number of times to retry loading data prior to failing.
-   */
-  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
-
-  private final Uri uri;
-  private final DataSource.Factory dataSourceFactory;
-  private final Format format;
-  private final int minLoadableRetryCount;
-  private final Handler eventHandler;
-  private final EventListener eventListener;
-  private final int eventSourceId;
-  private final Timeline timeline;
-
-  public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
-      long durationUs) {
-    this(uri, dataSourceFactory, format, durationUs, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
-  }
-
-  public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
-      long durationUs, int minLoadableRetryCount) {
-    this(uri, dataSourceFactory, format, durationUs, minLoadableRetryCount, null, null, 0);
-  }
-
-  public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
-      long durationUs, int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
-      int eventSourceId) {
-    this.uri = uri;
-    this.dataSourceFactory = dataSourceFactory;
-    this.format = format;
-    this.minLoadableRetryCount = minLoadableRetryCount;
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
-    this.eventSourceId = eventSourceId;
-    timeline = new SinglePeriodTimeline(durationUs, true);
-  }
-
-  // MediaSource implementation.
-
-  @Override
-  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
-    listener.onSourceInfoRefreshed(timeline, null);
-  }
-
-  @Override
-  public void maybeThrowSourceInfoRefreshError() throws IOException {
-    // Do nothing.
-  }
-
-  @Override
-  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
-    Assertions.checkArgument(index == 0);
-    return new SingleSampleMediaPeriod(uri, dataSourceFactory, format, minLoadableRetryCount,
-        eventHandler, eventListener, eventSourceId);
-  }
-
-  @Override
-  public void releasePeriod(MediaPeriod mediaPeriod) {
-    ((SingleSampleMediaPeriod) mediaPeriod).release();
-  }
-
-  @Override
-  public void releaseSource() {
-    // Do nothing.
-  }
+    public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
+
+    private final Uri uri;
+    private final DataSource.Factory dataSourceFactory;
+    private final Format format;
+    private final int minLoadableRetryCount;
+    private final Handler eventHandler;
+    private final EventListener eventListener;
+    private final int eventSourceId;
+    private final Timeline timeline;
+
+    public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
+                                   long durationUs) {
+        this(uri, dataSourceFactory, format, durationUs, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
+    }
+
+    public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
+                                   long durationUs, int minLoadableRetryCount) {
+        this(uri, dataSourceFactory, format, durationUs, minLoadableRetryCount, null, null, 0);
+    }
+
+    public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
+                                   long durationUs, int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
+                                   int eventSourceId) {
+        this.uri = uri;
+        this.dataSourceFactory = dataSourceFactory;
+        this.format = format;
+        this.minLoadableRetryCount = minLoadableRetryCount;
+        this.eventHandler = eventHandler;
+        this.eventListener = eventListener;
+        this.eventSourceId = eventSourceId;
+        timeline = new SinglePeriodTimeline(durationUs, true);
+    }
+
+    // MediaSource implementation.
+
+    @Override
+    public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+        listener.onSourceInfoRefreshed(timeline, null);
+    }
+
+    @Override
+    public void maybeThrowSourceInfoRefreshError() throws IOException {
+        // Do nothing.
+    }
+
+    @Override
+    public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
+        Assertions.checkArgument(index == 0);
+        return new SingleSampleMediaPeriod(uri, dataSourceFactory, format, minLoadableRetryCount,
+                eventHandler, eventListener, eventSourceId);
+    }
+
+    @Override
+    public void releasePeriod(MediaPeriod mediaPeriod) {
+        ((SingleSampleMediaPeriod) mediaPeriod).release();
+    }
+
+    @Override
+    public void releaseSource() {
+        // Do nothing.
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java b/library/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java
index 03b74bba0a..e0fb83acd6 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java
@@ -18,10 +18,12 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.util.Assertions;
+
 import java.util.Arrays;
 
 // TODO: Add an allowMultipleStreams boolean to indicate where the one stream per group restriction
 // does not apply.
+
 /**
  * Defines a group of tracks exposed by a {@link MediaPeriod}.
  * <p>
@@ -32,70 +34,70 @@
 // 内部管理一系列的: Format
 public final class TrackGroup {
 
-  /**
-   * The number of tracks in the group.
-   */
-  public final int length;
-
-  private final Format[] formats;
+    /**
+     * The number of tracks in the group.
+     */
+    public final int length;
 
-  // Lazily initialized hashcode.
-  private int hashCode;
+    private final Format[] formats;
 
-  /**
-   * @param formats The track formats. Must not be null or contain null elements.
-   */
-  public TrackGroup(Format... formats) {
-    Assertions.checkState(formats.length > 0);
-    this.formats = formats;
-    this.length = formats.length;
-  }
+    // Lazily initialized hashcode.
+    private int hashCode;
 
-  /**
-   * Returns the format of the track at a given index.
-   *
-   * @param index The index of the track.
-   * @return The track's format.
-   */
-  public Format getFormat(int index) {
-    return formats[index];
-  }
+    /**
+     * @param formats The track formats. Must not be null or contain null elements.
+     */
+    public TrackGroup(Format... formats) {
+        Assertions.checkState(formats.length > 0);
+        this.formats = formats;
+        this.length = formats.length;
+    }
 
-  /**
-   * Returns the index of the track with the given format in the group.
-   *
-   * @param format The format.
-   * @return The index of the track, or {@link C#INDEX_UNSET} if no such track exists.
-   */
-  public int indexOf(Format format) {
-    for (int i = 0; i < formats.length; i++) {
-      if (format == formats[i]) {
-        return i;
-      }
+    /**
+     * Returns the format of the track at a given index.
+     *
+     * @param index The index of the track.
+     * @return The track's format.
+     */
+    public Format getFormat(int index) {
+        return formats[index];
     }
-    return C.INDEX_UNSET;
-  }
 
-  @Override
-  public int hashCode() {
-    if (hashCode == 0) {
-      int result = 17;
-      result = 31 * result + Arrays.hashCode(formats);
-      hashCode = result;
+    /**
+     * Returns the index of the track with the given format in the group.
+     *
+     * @param format The format.
+     * @return The index of the track, or {@link C#INDEX_UNSET} if no such track exists.
+     */
+    public int indexOf(Format format) {
+        for (int i = 0; i < formats.length; i++) {
+            if (format == formats[i]) {
+                return i;
+            }
+        }
+        return C.INDEX_UNSET;
     }
-    return hashCode;
-  }
 
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
+    @Override
+    public int hashCode() {
+        if (hashCode == 0) {
+            int result = 17;
+            result = 31 * result + Arrays.hashCode(formats);
+            hashCode = result;
+        }
+        return hashCode;
     }
-    if (obj == null || getClass() != obj.getClass()) {
-      return false;
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        TrackGroup other = (TrackGroup) obj;
+        return length == other.length && Arrays.equals(formats, other.formats);
     }
-    TrackGroup other = (TrackGroup) obj;
-    return length == other.length && Arrays.equals(formats, other.formats);
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java b/library/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
index 394cec891b..c2dea38eab 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source;
 
 import com.google.android.exoplayer2.C;
+
 import java.util.Arrays;
 
 /**
@@ -23,72 +24,72 @@
  */
 public final class TrackGroupArray {
 
-  /**
-   * The empty array.
-   */
-  public static final TrackGroupArray EMPTY = new TrackGroupArray();
-
-  /**
-   * The number of groups in the array. Greater than or equal to zero.
-   */
-  public final int length;
+    /**
+     * The empty array.
+     */
+    public static final TrackGroupArray EMPTY = new TrackGroupArray();
 
-  private final TrackGroup[] trackGroups;
+    /**
+     * The number of groups in the array. Greater than or equal to zero.
+     */
+    public final int length;
 
-  // Lazily initialized hashcode.
-  private int hashCode;
+    private final TrackGroup[] trackGroups;
 
-  /**
-   * @param trackGroups The groups. Must not be null or contain null elements, but may be empty.
-   */
-  public TrackGroupArray(TrackGroup... trackGroups) {
-    this.trackGroups = trackGroups;
-    this.length = trackGroups.length;
-  }
+    // Lazily initialized hashcode.
+    private int hashCode;
 
-  /**
-   * Returns the group at a given index.
-   *
-   * @param index The index of the group.
-   * @return The group.
-   */
-  public TrackGroup get(int index) {
-    return trackGroups[index];
-  }
+    /**
+     * @param trackGroups The groups. Must not be null or contain null elements, but may be empty.
+     */
+    public TrackGroupArray(TrackGroup... trackGroups) {
+        this.trackGroups = trackGroups;
+        this.length = trackGroups.length;
+    }
 
-  /**
-   * Returns the index of a group within the array.
-   *
-   * @param group The group.
-   * @return The index of the group, or {@link C#INDEX_UNSET} if no such group exists.
-   */
-  public int indexOf(TrackGroup group) {
-    for (int i = 0; i < length; i++) {
-      if (trackGroups[i] == group) {
-        return i;
-      }
+    /**
+     * Returns the group at a given index.
+     *
+     * @param index The index of the group.
+     * @return The group.
+     */
+    public TrackGroup get(int index) {
+        return trackGroups[index];
     }
-    return C.INDEX_UNSET;
-  }
 
-  @Override
-  public int hashCode() {
-    if (hashCode == 0) {
-      hashCode = Arrays.hashCode(trackGroups);
+    /**
+     * Returns the index of a group within the array.
+     *
+     * @param group The group.
+     * @return The index of the group, or {@link C#INDEX_UNSET} if no such group exists.
+     */
+    public int indexOf(TrackGroup group) {
+        for (int i = 0; i < length; i++) {
+            if (trackGroups[i] == group) {
+                return i;
+            }
+        }
+        return C.INDEX_UNSET;
     }
-    return hashCode;
-  }
 
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
+    @Override
+    public int hashCode() {
+        if (hashCode == 0) {
+            hashCode = Arrays.hashCode(trackGroups);
+        }
+        return hashCode;
     }
-    if (obj == null || getClass() != obj.getClass()) {
-      return false;
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null || getClass() != obj.getClass()) {
+            return false;
+        }
+        TrackGroupArray other = (TrackGroupArray) obj;
+        return length == other.length && Arrays.equals(trackGroups, other.trackGroups);
     }
-    TrackGroupArray other = (TrackGroupArray) obj;
-    return length == other.length && Arrays.equals(trackGroups, other.trackGroups);
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index fd7234d178..41c1ce991b 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -48,421 +48,421 @@
 /* package */
 class HlsChunkSource {
 
-  /**
-   * Chunk holder that allows the scheduling of retries.
-   */
-  public static final class HlsChunkHolder {
+    /**
+     * Chunk holder that allows the scheduling of retries.
+     */
+    public static final class HlsChunkHolder {
+
+        public HlsChunkHolder() {
+            clear();
+        }
+
+        /**
+         * The chunk to be loaded next.
+         */
+        public Chunk chunk;
+
+        /**
+         * Indicates that the end of the stream has been reached.
+         */
+        public boolean endOfStream;
+
+        /**
+         * Indicates that the chunk source is waiting for the referred playlist to be refreshed.
+         */
+        public HlsUrl playlist;
+
+        /**
+         * Clears the holder.
+         */
+        public void clear() {
+            chunk = null;
+            endOfStream = false;
+            playlist = null;
+        }
 
-    public HlsChunkHolder() {
-      clear();
     }
 
+    private final DataSource dataSource;
+    private final TimestampAdjusterProvider timestampAdjusterProvider;
+
+    // 不同的分辨率情况下的variants
+    private final HlsUrl[] variants;
+
+    // 当前的播放列表
+    private final HlsPlaylistTracker playlistTracker;
+    private final TrackGroup trackGroup;
+
+    private boolean isTimestampMaster;
+    private byte[] scratchSpace;
+    private IOException fatalError;
+
+    private Uri encryptionKeyUri;
+    private byte[] encryptionKey;
+    private String encryptionIvString;
+    private byte[] encryptionIv;
+
+    // Note: The track group in the selection is typically *not* equal to trackGroup. This is due to
+    // the way in which HlsSampleStreamWrapper generates track groups. Use only index based methods
+    // in TrackSelection to avoid unexpected behavior.
+    private TrackSelection trackSelection;
+
     /**
-     * The chunk to be loaded next.
+     * @param playlistTracker           The {@link HlsPlaylistTracker} from which to obtain media playlists.
+     * @param variants                  The available variants.
+     * @param dataSource                A {@link DataSource} suitable for loading the media data.
+     * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If
+     *                                  multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
+     *                                  same provider.
      */
-    public Chunk chunk;
+    public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
+                          DataSource dataSource, TimestampAdjusterProvider timestampAdjusterProvider) {
+        this.playlistTracker = playlistTracker;
+        this.variants = variants;
+        this.dataSource = dataSource;
+        this.timestampAdjusterProvider = timestampAdjusterProvider;
+
+        // variants --> variantFormats --> TrackGroup
+        Format[] variantFormats = new Format[variants.length];
+        int[] initialTrackSelection = new int[variants.length];
+        for (int i = 0; i < variants.length; i++) {
+            variantFormats[i] = variants[i].format;
+            initialTrackSelection[i] = i;
+        }
+        trackGroup = new TrackGroup(variantFormats);
+
+        trackSelection = new InitializationTrackSelection(trackGroup, initialTrackSelection);
+    }
 
     /**
-     * Indicates that the end of the stream has been reached.
+     * If the source is currently having difficulty providing chunks, then this method throws the
+     * underlying error. Otherwise does nothing.
+     *
+     * @throws IOException The underlying error.
      */
-    public boolean endOfStream;
+    public void maybeThrowError() throws IOException {
+        if (fatalError != null) {
+            throw fatalError;
+        }
+    }
 
     /**
-     * Indicates that the chunk source is waiting for the referred playlist to be refreshed.
+     * Returns the track group exposed by the source.
      */
-    public HlsUrl playlist;
+    public TrackGroup getTrackGroup() {
+        return trackGroup;
+    }
 
     /**
-     * Clears the holder.
+     * Selects tracks for use.
+     *
+     * @param trackSelection The track selection.
      */
-    public void clear() {
-      chunk = null;
-      endOfStream = false;
-      playlist = null;
+    public void selectTracks(TrackSelection trackSelection) {
+        this.trackSelection = trackSelection;
     }
 
-  }
-
-  private final DataSource dataSource;
-  private final TimestampAdjusterProvider timestampAdjusterProvider;
-
-  // 不同的分辨率情况下的variants
-  private final HlsUrl[] variants;
-
-  // 当前的播放列表
-  private final HlsPlaylistTracker playlistTracker;
-  private final TrackGroup trackGroup;
-
-  private boolean isTimestampMaster;
-  private byte[] scratchSpace;
-  private IOException fatalError;
-
-  private Uri encryptionKeyUri;
-  private byte[] encryptionKey;
-  private String encryptionIvString;
-  private byte[] encryptionIv;
-
-  // Note: The track group in the selection is typically *not* equal to trackGroup. This is due to
-  // the way in which HlsSampleStreamWrapper generates track groups. Use only index based methods
-  // in TrackSelection to avoid unexpected behavior.
-  private TrackSelection trackSelection;
-
-  /**
-   * @param playlistTracker           The {@link HlsPlaylistTracker} from which to obtain media playlists.
-   * @param variants                  The available variants.
-   * @param dataSource                A {@link DataSource} suitable for loading the media data.
-   * @param timestampAdjusterProvider A provider of {@link TimestampAdjuster} instances. If
-   *                                  multiple {@link HlsChunkSource}s are used for a single playback, they should all share the
-   *                                  same provider.
-   */
-  public HlsChunkSource(HlsPlaylistTracker playlistTracker, HlsUrl[] variants,
-                        DataSource dataSource, TimestampAdjusterProvider timestampAdjusterProvider) {
-    this.playlistTracker = playlistTracker;
-    this.variants = variants;
-    this.dataSource = dataSource;
-    this.timestampAdjusterProvider = timestampAdjusterProvider;
-
-    // variants --> variantFormats --> TrackGroup
-    Format[] variantFormats = new Format[variants.length];
-    int[] initialTrackSelection = new int[variants.length];
-    for (int i = 0; i < variants.length; i++) {
-      variantFormats[i] = variants[i].format;
-      initialTrackSelection[i] = i;
-    }
-    trackGroup = new TrackGroup(variantFormats);
-
-    trackSelection = new InitializationTrackSelection(trackGroup, initialTrackSelection);
-  }
-
-  /**
-   * If the source is currently having difficulty providing chunks, then this method throws the
-   * underlying error. Otherwise does nothing.
-   *
-   * @throws IOException The underlying error.
-   */
-  public void maybeThrowError() throws IOException {
-    if (fatalError != null) {
-      throw fatalError;
+    /**
+     * Resets the source.
+     */
+    public void reset() {
+        fatalError = null;
     }
-  }
-
-  /**
-   * Returns the track group exposed by the source.
-   */
-  public TrackGroup getTrackGroup() {
-    return trackGroup;
-  }
-
-  /**
-   * Selects tracks for use.
-   *
-   * @param trackSelection The track selection.
-   */
-  public void selectTracks(TrackSelection trackSelection) {
-    this.trackSelection = trackSelection;
-  }
-
-  /**
-   * Resets the source.
-   */
-  public void reset() {
-    fatalError = null;
-  }
-
-  /**
-   * Sets whether this chunk source is responsible for initializing timestamp adjusters.
-   *
-   * @param isTimestampMaster True if this chunk source is responsible for initializing timestamp
-   *                          adjusters.
-   */
-  public void setIsTimestampMaster(boolean isTimestampMaster) {
-    this.isTimestampMaster = isTimestampMaster;
-  }
-
-  /**
-   * Returns the next chunk to load.
-   * <p>
-   * If a chunk is available then {@link HlsChunkHolder#chunk} is set. If the end of the stream has
-   * been reached then {@link HlsChunkHolder#endOfStream} is set. If a chunk is not available but
-   * the end of the stream has not been reached, {@link HlsChunkHolder#playlist} is set to
-   * contain the {@link HlsUrl} that refers to the playlist that needs refreshing.
-   *
-   * @param previous           The most recently loaded media chunk.
-   * @param playbackPositionUs The current playback position. If {@code previous} is null then this
-   *                           parameter is the position from which playback is expected to start (or restart) and hence
-   *                           should be interpreted as a seek position.
-   * @param out                A holder to populate.
-   */
-  public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChunkHolder out) {
-
-    int oldVariantIndex = previous == null ? C.INDEX_UNSET : trackGroup.indexOf(previous.trackFormat);
-
-    // Use start time of the previous chunk rather than its end time because switching format will
-    // require downloading overlapping segments. TODO: 这个如何理解呢? 为什么要下载Overlapping的Segments?
-    // 如何切换格式?
-
-    // 下一个Chunk该如何选择呢?
-    // 首先判断已近缓存了多少数据
-    //   playbackPositionUs 表示当前playback的位置
-    //
-    long bufferedDurationUs = previous == null ? 0 : Math.max(0, previous.startTimeUs - playbackPositionUs);
-
-
-    // Select the variant.
-    trackSelection.updateSelectedTrack(bufferedDurationUs);
-
-    // 选择variant
-    int newVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
-
-    boolean switchingVariant = oldVariantIndex != newVariantIndex;
-
-    // 获取新的Playlist
-    HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(variants[newVariantIndex]);
-    if (mediaPlaylist == null) {
-      out.playlist = variants[newVariantIndex];
-      // Retry when playlist is refreshed.
-      return;
+
+    /**
+     * Sets whether this chunk source is responsible for initializing timestamp adjusters.
+     *
+     * @param isTimestampMaster True if this chunk source is responsible for initializing timestamp
+     *                          adjusters.
+     */
+    public void setIsTimestampMaster(boolean isTimestampMaster) {
+        this.isTimestampMaster = isTimestampMaster;
     }
 
-    // Select the chunk.
-    int chunkMediaSequence;
-    if (previous == null || switchingVariant) {
-
-      // 下一个视频从什么地方开始下载呢?
-      // 为什么需要有一个Overlap的空间呢? TODO:
-      // 第一次下载，或者切换: Variants
-      long targetPositionUs = previous == null ? playbackPositionUs : previous.startTimeUs;
-
-      if (!mediaPlaylist.hasEndTag && targetPositionUs > mediaPlaylist.getEndTimeUs()) {
-        // If the playlist is too old to contain the chunk, we need to refresh it.
-        chunkMediaSequence = mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();
-      } else {
-
-        // 普通的VOD点播的视频
-        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
-                targetPositionUs - mediaPlaylist.startTimeUs, true,
-                !playlistTracker.isLive() || previous == null) + mediaPlaylist.mediaSequence;
-
-        if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null) {
-          // We try getting the next chunk without adapting in case that's the reason for falling
-          // behind the live window.
-          newVariantIndex = oldVariantIndex;
-          mediaPlaylist = playlistTracker.getPlaylistSnapshot(variants[newVariantIndex]);
-          chunkMediaSequence = previous.getNextChunkIndex();
+    /**
+     * Returns the next chunk to load.
+     * <p>
+     * If a chunk is available then {@link HlsChunkHolder#chunk} is set. If the end of the stream has
+     * been reached then {@link HlsChunkHolder#endOfStream} is set. If a chunk is not available but
+     * the end of the stream has not been reached, {@link HlsChunkHolder#playlist} is set to
+     * contain the {@link HlsUrl} that refers to the playlist that needs refreshing.
+     *
+     * @param previous           The most recently loaded media chunk.
+     * @param playbackPositionUs The current playback position. If {@code previous} is null then this
+     *                           parameter is the position from which playback is expected to start (or restart) and hence
+     *                           should be interpreted as a seek position.
+     * @param out                A holder to populate.
+     */
+    public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, HlsChunkHolder out) {
+
+        int oldVariantIndex = previous == null ? C.INDEX_UNSET : trackGroup.indexOf(previous.trackFormat);
+
+        // Use start time of the previous chunk rather than its end time because switching format will
+        // require downloading overlapping segments. TODO: 这个如何理解呢? 为什么要下载Overlapping的Segments?
+        // 如何切换格式?
+
+        // 下一个Chunk该如何选择呢?
+        // 首先判断已近缓存了多少数据
+        //   playbackPositionUs 表示当前playback的位置
+        //
+        long bufferedDurationUs = previous == null ? 0 : Math.max(0, previous.startTimeUs - playbackPositionUs);
+
+
+        // Select the variant.
+        trackSelection.updateSelectedTrack(bufferedDurationUs);
+
+        // 选择variant
+        int newVariantIndex = trackSelection.getSelectedIndexInTrackGroup();
+
+        boolean switchingVariant = oldVariantIndex != newVariantIndex;
+
+        // 获取新的Playlist
+        HlsMediaPlaylist mediaPlaylist = playlistTracker.getPlaylistSnapshot(variants[newVariantIndex]);
+        if (mediaPlaylist == null) {
+            out.playlist = variants[newVariantIndex];
+            // Retry when playlist is refreshed.
+            return;
         }
-      }
-    } else {
-      // 正常下载下一个Segment
-      chunkMediaSequence = previous.getNextChunkIndex();
-    }
 
-    // 获取有效的: chunkMediaSequence
+        // Select the chunk.
+        int chunkMediaSequence;
+        if (previous == null || switchingVariant) {
+
+            // 下一个视频从什么地方开始下载呢?
+            // 为什么需要有一个Overlap的空间呢? TODO:
+            // 第一次下载，或者切换: Variants
+            long targetPositionUs = previous == null ? playbackPositionUs : previous.startTimeUs;
+
+            if (!mediaPlaylist.hasEndTag && targetPositionUs > mediaPlaylist.getEndTimeUs()) {
+                // If the playlist is too old to contain the chunk, we need to refresh it.
+                chunkMediaSequence = mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();
+            } else {
+
+                // 普通的VOD点播的视频
+                chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
+                        targetPositionUs - mediaPlaylist.startTimeUs, true,
+                        !playlistTracker.isLive() || previous == null) + mediaPlaylist.mediaSequence;
+
+                if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null) {
+                    // We try getting the next chunk without adapting in case that's the reason for falling
+                    // behind the live window.
+                    newVariantIndex = oldVariantIndex;
+                    mediaPlaylist = playlistTracker.getPlaylistSnapshot(variants[newVariantIndex]);
+                    chunkMediaSequence = previous.getNextChunkIndex();
+                }
+            }
+        } else {
+            // 正常下载下一个Segment
+            chunkMediaSequence = previous.getNextChunkIndex();
+        }
 
-    if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
-      fatalError = new BehindLiveWindowException();
-      return;
-    }
+        // 获取有效的: chunkMediaSequence
 
-    int chunkIndex = chunkMediaSequence - mediaPlaylist.mediaSequence;
-    if (chunkIndex >= mediaPlaylist.segments.size()) {
-      if (mediaPlaylist.hasEndTag) {
-        out.endOfStream = true;
-      } else /* Live */ {
-        out.playlist = variants[newVariantIndex];
-      }
-      return;
-    }
+        if (chunkMediaSequence < mediaPlaylist.mediaSequence) {
+            fatalError = new BehindLiveWindowException();
+            return;
+        }
 
-    // 获取有效的Segment
-    HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
-    clearEncryptionData();
+        int chunkIndex = chunkMediaSequence - mediaPlaylist.mediaSequence;
+        if (chunkIndex >= mediaPlaylist.segments.size()) {
+            if (mediaPlaylist.hasEndTag) {
+                out.endOfStream = true;
+            } else /* Live */ {
+                out.playlist = variants[newVariantIndex];
+            }
+            return;
+        }
 
-    // 构建相关的DataSpec
-    DataSpec initDataSpec = null;
-    Segment initSegment = mediaPlaylist.initializationSegment;
-    if (initSegment != null) {
-      Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
-      initDataSpec = new DataSpec(initSegmentUri, initSegment.byterangeOffset, initSegment.byterangeLength, null);
-    }
+        // 获取有效的Segment
+        HlsMediaPlaylist.Segment segment = mediaPlaylist.segments.get(chunkIndex);
+        clearEncryptionData();
 
-    // Compute start time of the next chunk.
-    long startTimeUs = mediaPlaylist.startTimeUs + segment.relativeStartTimeUs;
-    TimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(
-            segment.discontinuitySequenceNumber, startTimeUs);
-
-    // Configure the data source and spec for the chunk.
-    Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
-    DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength, null);
-
-    // 选择一个MediaChunk
-    // newVariantIndex 主要通过 trackSelection 来设置
-    // 但是似乎没有没有开始下载?
-    out.chunk = new HlsMediaChunk(dataSource, dataSpec, initDataSpec, variants[newVariantIndex],
-            trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
-            startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence,
-            segment.discontinuitySequenceNumber, isTimestampMaster, timestampAdjuster, previous,
-            encryptionKey, encryptionIv);
-  }
-
-  /**
-   * Called when the {@link HlsSampleStreamWrapper} has finished loading a chunk obtained from this
-   * source.
-   *
-   * @param chunk The chunk whose load has been completed.
-   */
-  public void onChunkLoadCompleted(Chunk chunk) {
-
-    // 加载完毕，是否需要解密呢?
-    // 暂不考虑这个逻辑
-    if (chunk instanceof EncryptionKeyChunk) {
-      EncryptionKeyChunk encryptionKeyChunk = (EncryptionKeyChunk) chunk;
-      scratchSpace = encryptionKeyChunk.getDataHolder();
-      setEncryptionData(encryptionKeyChunk.dataSpec.uri, encryptionKeyChunk.iv,
-              encryptionKeyChunk.getResult());
-    }
-  }
-
-  /**
-   * Called when the {@link HlsSampleStreamWrapper} encounters an error loading a chunk obtained
-   * from this source.
-   *
-   * @param chunk      The chunk whose load encountered the error.
-   * @param cancelable Whether the load can be canceled.
-   * @param error      The error.
-   * @return Whether the load should be canceled.
-   */
-  public boolean onChunkLoadError(Chunk chunk, boolean cancelable, IOException error) {
-    return cancelable && ChunkedTrackBlacklistUtil.maybeBlacklistTrack(trackSelection,
-            trackSelection.indexOf(trackGroup.indexOf(chunk.trackFormat)), error);
-  }
-
-  /**
-   * Called when a playlist is blacklisted.
-   *
-   * @param url         The url that references the blacklisted playlist.
-   * @param blacklistMs The amount of milliseconds for which the playlist was blacklisted.
-   */
-  public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
-    int trackGroupIndex = trackGroup.indexOf(url.format);
-    if (trackGroupIndex != C.INDEX_UNSET) {
-      int trackSelectionIndex = trackSelection.indexOf(trackGroupIndex);
-      if (trackSelectionIndex != C.INDEX_UNSET) {
-        trackSelection.blacklist(trackSelectionIndex, blacklistMs);
-      }
+        // 构建相关的DataSpec
+        DataSpec initDataSpec = null;
+        Segment initSegment = mediaPlaylist.initializationSegment;
+        if (initSegment != null) {
+            Uri initSegmentUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, initSegment.url);
+            initDataSpec = new DataSpec(initSegmentUri, initSegment.byterangeOffset, initSegment.byterangeLength, null);
+        }
+
+        // Compute start time of the next chunk.
+        long startTimeUs = mediaPlaylist.startTimeUs + segment.relativeStartTimeUs;
+        TimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(
+                segment.discontinuitySequenceNumber, startTimeUs);
+
+        // Configure the data source and spec for the chunk.
+        Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
+        DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength, null);
+
+        // 选择一个MediaChunk
+        // newVariantIndex 主要通过 trackSelection 来设置
+        // 但是似乎没有没有开始下载?
+        out.chunk = new HlsMediaChunk(dataSource, dataSpec, initDataSpec, variants[newVariantIndex],
+                trackSelection.getSelectionReason(), trackSelection.getSelectionData(),
+                startTimeUs, startTimeUs + segment.durationUs, chunkMediaSequence,
+                segment.discontinuitySequenceNumber, isTimestampMaster, timestampAdjuster, previous,
+                encryptionKey, encryptionIv);
     }
-  }
-
-  // Private methods.
-
-  private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int variantIndex,
-                                                   int trackSelectionReason, Object trackSelectionData) {
-    DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNSET, null, DataSpec.FLAG_ALLOW_GZIP);
-    return new EncryptionKeyChunk(dataSource, dataSpec, variants[variantIndex].format,
-            trackSelectionReason, trackSelectionData, scratchSpace, iv);
-  }
-
-  private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
-    String trimmedIv;
-    if (iv.toLowerCase(Locale.getDefault()).startsWith("0x")) {
-      trimmedIv = iv.substring(2);
-    } else {
-      trimmedIv = iv;
+
+    /**
+     * Called when the {@link HlsSampleStreamWrapper} has finished loading a chunk obtained from this
+     * source.
+     *
+     * @param chunk The chunk whose load has been completed.
+     */
+    public void onChunkLoadCompleted(Chunk chunk) {
+
+        // 加载完毕，是否需要解密呢?
+        // 暂不考虑这个逻辑
+        if (chunk instanceof EncryptionKeyChunk) {
+            EncryptionKeyChunk encryptionKeyChunk = (EncryptionKeyChunk) chunk;
+            scratchSpace = encryptionKeyChunk.getDataHolder();
+            setEncryptionData(encryptionKeyChunk.dataSpec.uri, encryptionKeyChunk.iv,
+                    encryptionKeyChunk.getResult());
+        }
     }
 
-    byte[] ivData = new BigInteger(trimmedIv, 16).toByteArray();
-    byte[] ivDataWithPadding = new byte[16];
-    int offset = ivData.length > 16 ? ivData.length - 16 : 0;
-    System.arraycopy(ivData, offset, ivDataWithPadding, ivDataWithPadding.length - ivData.length
-            + offset, ivData.length - offset);
-
-    encryptionKeyUri = keyUri;
-    encryptionKey = secretKey;
-    encryptionIvString = iv;
-    encryptionIv = ivDataWithPadding;
-  }
-
-  private void clearEncryptionData() {
-    encryptionKeyUri = null;
-    encryptionKey = null;
-    encryptionIvString = null;
-    encryptionIv = null;
-  }
-
-  // Private classes.
-
-  /**
-   * A {@link TrackSelection} to use for initialization.
-   */
-  private static final class InitializationTrackSelection extends BaseTrackSelection {
-
-    private int selectedIndex;
-
-    // 如何选择初始的Track呢?
-    public InitializationTrackSelection(TrackGroup group, int[] tracks) {
-      super(group, tracks);
-      selectedIndex = indexOf(group.getFormat(0));
+    /**
+     * Called when the {@link HlsSampleStreamWrapper} encounters an error loading a chunk obtained
+     * from this source.
+     *
+     * @param chunk      The chunk whose load encountered the error.
+     * @param cancelable Whether the load can be canceled.
+     * @param error      The error.
+     * @return Whether the load should be canceled.
+     */
+    public boolean onChunkLoadError(Chunk chunk, boolean cancelable, IOException error) {
+        return cancelable && ChunkedTrackBlacklistUtil.maybeBlacklistTrack(trackSelection,
+                trackSelection.indexOf(trackGroup.indexOf(chunk.trackFormat)), error);
     }
 
-    @Override
-    public void updateSelectedTrack(long bufferedDurationUs) {
-      long nowMs = SystemClock.elapsedRealtime();
-
-      // 如果当前的Track OK，则直接返回
-      if (!isBlacklisted(selectedIndex, nowMs)) {
-        return;
-      }
-
-      // 选择一个新的Index
-      // Try from lowest bitrate to highest.
-      for (int i = length - 1; i >= 0; i--) {
-        if (!isBlacklisted(i, nowMs)) {
-          selectedIndex = i;
-          return;
+    /**
+     * Called when a playlist is blacklisted.
+     *
+     * @param url         The url that references the blacklisted playlist.
+     * @param blacklistMs The amount of milliseconds for which the playlist was blacklisted.
+     */
+    public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
+        int trackGroupIndex = trackGroup.indexOf(url.format);
+        if (trackGroupIndex != C.INDEX_UNSET) {
+            int trackSelectionIndex = trackSelection.indexOf(trackGroupIndex);
+            if (trackSelectionIndex != C.INDEX_UNSET) {
+                trackSelection.blacklist(trackSelectionIndex, blacklistMs);
+            }
         }
-      }
-      // Should never happen.
-      throw new IllegalStateException();
     }
 
-    @Override
-    public int getSelectedIndex() {
-      return selectedIndex;
+    // Private methods.
+
+    private EncryptionKeyChunk newEncryptionKeyChunk(Uri keyUri, String iv, int variantIndex,
+                                                     int trackSelectionReason, Object trackSelectionData) {
+        DataSpec dataSpec = new DataSpec(keyUri, 0, C.LENGTH_UNSET, null, DataSpec.FLAG_ALLOW_GZIP);
+        return new EncryptionKeyChunk(dataSource, dataSpec, variants[variantIndex].format,
+                trackSelectionReason, trackSelectionData, scratchSpace, iv);
     }
 
-    @Override
-    public int getSelectionReason() {
-      return C.SELECTION_REASON_UNKNOWN;
+    private void setEncryptionData(Uri keyUri, String iv, byte[] secretKey) {
+        String trimmedIv;
+        if (iv.toLowerCase(Locale.getDefault()).startsWith("0x")) {
+            trimmedIv = iv.substring(2);
+        } else {
+            trimmedIv = iv;
+        }
+
+        byte[] ivData = new BigInteger(trimmedIv, 16).toByteArray();
+        byte[] ivDataWithPadding = new byte[16];
+        int offset = ivData.length > 16 ? ivData.length - 16 : 0;
+        System.arraycopy(ivData, offset, ivDataWithPadding, ivDataWithPadding.length - ivData.length
+                + offset, ivData.length - offset);
+
+        encryptionKeyUri = keyUri;
+        encryptionKey = secretKey;
+        encryptionIvString = iv;
+        encryptionIv = ivDataWithPadding;
     }
 
-    @Override
-    public Object getSelectionData() {
-      return null;
+    private void clearEncryptionData() {
+        encryptionKeyUri = null;
+        encryptionKey = null;
+        encryptionIvString = null;
+        encryptionIv = null;
     }
 
-  }
+    // Private classes.
+
+    /**
+     * A {@link TrackSelection} to use for initialization.
+     */
+    private static final class InitializationTrackSelection extends BaseTrackSelection {
+
+        private int selectedIndex;
 
-  private static final class EncryptionKeyChunk extends DataChunk {
+        // 如何选择初始的Track呢?
+        public InitializationTrackSelection(TrackGroup group, int[] tracks) {
+            super(group, tracks);
+            selectedIndex = indexOf(group.getFormat(0));
+        }
+
+        @Override
+        public void updateSelectedTrack(long bufferedDurationUs) {
+            long nowMs = SystemClock.elapsedRealtime();
+
+            // 如果当前的Track OK，则直接返回
+            if (!isBlacklisted(selectedIndex, nowMs)) {
+                return;
+            }
+
+            // 选择一个新的Index
+            // Try from lowest bitrate to highest.
+            for (int i = length - 1; i >= 0; i--) {
+                if (!isBlacklisted(i, nowMs)) {
+                    selectedIndex = i;
+                    return;
+                }
+            }
+            // Should never happen.
+            throw new IllegalStateException();
+        }
 
-    public final String iv;
+        @Override
+        public int getSelectedIndex() {
+            return selectedIndex;
+        }
 
-    private byte[] result;
+        @Override
+        public int getSelectionReason() {
+            return C.SELECTION_REASON_UNKNOWN;
+        }
 
-    public EncryptionKeyChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-                              int trackSelectionReason, Object trackSelectionData, byte[] scratchSpace, String iv) {
-      super(dataSource, dataSpec, C.DATA_TYPE_DRM, trackFormat, trackSelectionReason,
-              trackSelectionData, scratchSpace);
-      this.iv = iv;
-    }
+        @Override
+        public Object getSelectionData() {
+            return null;
+        }
 
-    @Override
-    protected void consume(byte[] data, int limit) throws IOException {
-      result = Arrays.copyOf(data, limit);
     }
 
-    public byte[] getResult() {
-      return result;
-    }
+    private static final class EncryptionKeyChunk extends DataChunk {
 
-  }
+        public final String iv;
+
+        private byte[] result;
+
+        public EncryptionKeyChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
+                                  int trackSelectionReason, Object trackSelectionData, byte[] scratchSpace, String iv) {
+            super(dataSource, dataSpec, C.DATA_TYPE_DRM, trackFormat, trackSelectionReason,
+                    trackSelectionData, scratchSpace);
+            this.iv = iv;
+        }
+
+        @Override
+        protected void consume(byte[] data, int limit) throws IOException {
+            result = Arrays.copyOf(data, limit);
+        }
+
+        public byte[] getResult() {
+            return result;
+        }
+
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 960edf9e4a..e0c79971c0 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -49,342 +49,342 @@
 /* package */
 final class HlsMediaChunk extends MediaChunk {
 
-  private static final AtomicInteger UID_SOURCE = new AtomicInteger();
-
-  private static final String PRIV_TIMESTAMP_FRAME_OWNER =
-          "com.apple.streaming.transportStreamTimestamp";
-
-  private static final String AAC_FILE_EXTENSION = ".aac";
-  private static final String AC3_FILE_EXTENSION = ".ac3";
-  private static final String EC3_FILE_EXTENSION = ".ec3";
-  private static final String MP3_FILE_EXTENSION = ".mp3";
-  private static final String MP4_FILE_EXTENSION = ".mp4";
-  private static final String VTT_FILE_EXTENSION = ".vtt";
-  private static final String WEBVTT_FILE_EXTENSION = ".webvtt";
-
-  /**
-   * A unique identifier for the chunk.
-   */
-  public final int uid;
-
-  /**
-   * The discontinuity sequence number of the chunk.
-   */
-  public final int discontinuitySequenceNumber;
-
-  /**
-   * The url of the playlist from which this chunk was obtained.
-   */
-  public final HlsUrl hlsUrl;
-
-  private final DataSource initDataSource;
-  private final DataSpec initDataSpec;
-  private final boolean isEncrypted;
-  private final boolean isMasterTimestampSource;
-  private final TimestampAdjuster timestampAdjuster;
-  private final HlsMediaChunk previousChunk;
-  private final String lastPathSegment;
-
-  private final boolean isPackedAudio;
-  private final Id3Decoder id3Decoder;
-  private final ParsableByteArray id3Data;
-
-  private Extractor extractor;
-  private int initSegmentBytesLoaded;
-  private int bytesLoaded;
-  private boolean initLoadCompleted;
-  private HlsSampleStreamWrapper extractorOutput;
-  private volatile boolean loadCanceled;
-  private volatile boolean loadCompleted;
-
-  /**
-   * @param dataSource                  The source from which the data should be loaded.
-   * @param dataSpec                    Defines the data to be loaded.
-   * @param initDataSpec                Defines the initialization data to be fed to new extractors. May be null.
-   * @param hlsUrl                      The url of the playlist from which this chunk was obtained.
-   * @param trackSelectionReason        See {@link #trackSelectionReason}.
-   * @param trackSelectionData          See {@link #trackSelectionData}.
-   * @param startTimeUs                 The start time of the chunk in microseconds.
-   * @param endTimeUs                   The end time of the chunk in microseconds.
-   * @param chunkIndex                  The media sequence number of the chunk.
-   * @param discontinuitySequenceNumber The discontinuity sequence number of the chunk.
-   * @param isMasterTimestampSource     True if the chunk can initialize the timestamp adjuster.
-   * @param timestampAdjuster           Adjuster corresponding to the provided discontinuity sequence number.
-   * @param previousChunk               The {@link HlsMediaChunk} that preceded this one. May be null.
-   * @param encryptionKey               For AES encryption chunks, the encryption key.
-   * @param encryptionIv                For AES encryption chunks, the encryption initialization vector.
-   */
-  public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initDataSpec,
-                       HlsUrl hlsUrl, int trackSelectionReason, Object trackSelectionData, long startTimeUs,
-                       long endTimeUs, int chunkIndex, int discontinuitySequenceNumber,
-                       boolean isMasterTimestampSource, TimestampAdjuster timestampAdjuster,
-                       HlsMediaChunk previousChunk, byte[] encryptionKey, byte[] encryptionIv) {
-    super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, hlsUrl.format,
-            trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs, chunkIndex);
-    this.initDataSpec = initDataSpec;
-    this.hlsUrl = hlsUrl;
-    this.isMasterTimestampSource = isMasterTimestampSource;
-    this.timestampAdjuster = timestampAdjuster;
-    this.discontinuitySequenceNumber = discontinuitySequenceNumber;
-    this.previousChunk = previousChunk;
-    // Note: this.dataSource and dataSource may be different.
-    this.isEncrypted = this.dataSource instanceof Aes128DataSource;
-    lastPathSegment = dataSpec.uri.getLastPathSegment();
-    isPackedAudio = lastPathSegment.endsWith(AAC_FILE_EXTENSION)
-            || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
-            || lastPathSegment.endsWith(EC3_FILE_EXTENSION)
-            || lastPathSegment.endsWith(MP3_FILE_EXTENSION);
-    if (isPackedAudio) {
-      id3Decoder = previousChunk != null ? previousChunk.id3Decoder : new Id3Decoder();
-      id3Data = previousChunk != null ? previousChunk.id3Data
-              : new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
-    } else {
-      id3Decoder = null;
-      id3Data = null;
-    }
-    initDataSource = dataSource;
-    uid = UID_SOURCE.getAndIncrement();
-  }
-
-  /**
-   * Initializes the chunk for loading, setting the {@link HlsSampleStreamWrapper} that will receive
-   * samples as they are loaded.
-   *
-   * @param output The output that will receive the loaded samples.
-   */
-  public void init(HlsSampleStreamWrapper output) {
-    extractorOutput = output;
-    output.init(uid, previousChunk != null && previousChunk.hlsUrl != hlsUrl);
-  }
-
-  @Override
-  public boolean isLoadCompleted() {
-    return loadCompleted;
-  }
-
-  @Override
-  public long bytesLoaded() {
-    return bytesLoaded;
-  }
-
-  // Loadable implementation
-
-  @Override
-  public void cancelLoad() {
-    loadCanceled = true;
-  }
-
-  @Override
-  public boolean isLoadCanceled() {
-    return loadCanceled;
-  }
-
-  @Override
-  public void load() throws IOException, InterruptedException {
-    if (extractor == null && !isPackedAudio) {
-      // See HLS spec, version 20, Section 3.4 for more information on packed audio extraction.
-      extractor = buildExtractorByExtension();
+    private static final AtomicInteger UID_SOURCE = new AtomicInteger();
+
+    private static final String PRIV_TIMESTAMP_FRAME_OWNER =
+            "com.apple.streaming.transportStreamTimestamp";
+
+    private static final String AAC_FILE_EXTENSION = ".aac";
+    private static final String AC3_FILE_EXTENSION = ".ac3";
+    private static final String EC3_FILE_EXTENSION = ".ec3";
+    private static final String MP3_FILE_EXTENSION = ".mp3";
+    private static final String MP4_FILE_EXTENSION = ".mp4";
+    private static final String VTT_FILE_EXTENSION = ".vtt";
+    private static final String WEBVTT_FILE_EXTENSION = ".webvtt";
+
+    /**
+     * A unique identifier for the chunk.
+     */
+    public final int uid;
+
+    /**
+     * The discontinuity sequence number of the chunk.
+     */
+    public final int discontinuitySequenceNumber;
+
+    /**
+     * The url of the playlist from which this chunk was obtained.
+     */
+    public final HlsUrl hlsUrl;
+
+    private final DataSource initDataSource;
+    private final DataSpec initDataSpec;
+    private final boolean isEncrypted;
+    private final boolean isMasterTimestampSource;
+    private final TimestampAdjuster timestampAdjuster;
+    private final HlsMediaChunk previousChunk;
+    private final String lastPathSegment;
+
+    private final boolean isPackedAudio;
+    private final Id3Decoder id3Decoder;
+    private final ParsableByteArray id3Data;
+
+    private Extractor extractor;
+    private int initSegmentBytesLoaded;
+    private int bytesLoaded;
+    private boolean initLoadCompleted;
+    private HlsSampleStreamWrapper extractorOutput;
+    private volatile boolean loadCanceled;
+    private volatile boolean loadCompleted;
+
+    /**
+     * @param dataSource                  The source from which the data should be loaded.
+     * @param dataSpec                    Defines the data to be loaded.
+     * @param initDataSpec                Defines the initialization data to be fed to new extractors. May be null.
+     * @param hlsUrl                      The url of the playlist from which this chunk was obtained.
+     * @param trackSelectionReason        See {@link #trackSelectionReason}.
+     * @param trackSelectionData          See {@link #trackSelectionData}.
+     * @param startTimeUs                 The start time of the chunk in microseconds.
+     * @param endTimeUs                   The end time of the chunk in microseconds.
+     * @param chunkIndex                  The media sequence number of the chunk.
+     * @param discontinuitySequenceNumber The discontinuity sequence number of the chunk.
+     * @param isMasterTimestampSource     True if the chunk can initialize the timestamp adjuster.
+     * @param timestampAdjuster           Adjuster corresponding to the provided discontinuity sequence number.
+     * @param previousChunk               The {@link HlsMediaChunk} that preceded this one. May be null.
+     * @param encryptionKey               For AES encryption chunks, the encryption key.
+     * @param encryptionIv                For AES encryption chunks, the encryption initialization vector.
+     */
+    public HlsMediaChunk(DataSource dataSource, DataSpec dataSpec, DataSpec initDataSpec,
+                         HlsUrl hlsUrl, int trackSelectionReason, Object trackSelectionData, long startTimeUs,
+                         long endTimeUs, int chunkIndex, int discontinuitySequenceNumber,
+                         boolean isMasterTimestampSource, TimestampAdjuster timestampAdjuster,
+                         HlsMediaChunk previousChunk, byte[] encryptionKey, byte[] encryptionIv) {
+        super(buildDataSource(dataSource, encryptionKey, encryptionIv), dataSpec, hlsUrl.format,
+                trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs, chunkIndex);
+        this.initDataSpec = initDataSpec;
+        this.hlsUrl = hlsUrl;
+        this.isMasterTimestampSource = isMasterTimestampSource;
+        this.timestampAdjuster = timestampAdjuster;
+        this.discontinuitySequenceNumber = discontinuitySequenceNumber;
+        this.previousChunk = previousChunk;
+        // Note: this.dataSource and dataSource may be different.
+        this.isEncrypted = this.dataSource instanceof Aes128DataSource;
+        lastPathSegment = dataSpec.uri.getLastPathSegment();
+        isPackedAudio = lastPathSegment.endsWith(AAC_FILE_EXTENSION)
+                || lastPathSegment.endsWith(AC3_FILE_EXTENSION)
+                || lastPathSegment.endsWith(EC3_FILE_EXTENSION)
+                || lastPathSegment.endsWith(MP3_FILE_EXTENSION);
+        if (isPackedAudio) {
+            id3Decoder = previousChunk != null ? previousChunk.id3Decoder : new Id3Decoder();
+            id3Data = previousChunk != null ? previousChunk.id3Data
+                    : new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
+        } else {
+            id3Decoder = null;
+            id3Data = null;
+        }
+        initDataSource = dataSource;
+        uid = UID_SOURCE.getAndIncrement();
     }
-    maybeLoadInitData();
-    if (!loadCanceled) {
-      loadMedia();
+
+    /**
+     * Initializes the chunk for loading, setting the {@link HlsSampleStreamWrapper} that will receive
+     * samples as they are loaded.
+     *
+     * @param output The output that will receive the loaded samples.
+     */
+    public void init(HlsSampleStreamWrapper output) {
+        extractorOutput = output;
+        output.init(uid, previousChunk != null && previousChunk.hlsUrl != hlsUrl);
     }
-  }
 
-  // Internal loading methods.
+    @Override
+    public boolean isLoadCompleted() {
+        return loadCompleted;
+    }
 
-  private void maybeLoadInitData() throws IOException, InterruptedException {
-    if ((previousChunk != null && previousChunk.extractor == extractor) || initLoadCompleted
-            || initDataSpec == null) {
-      return;
+    @Override
+    public long bytesLoaded() {
+        return bytesLoaded;
     }
-    DataSpec initSegmentDataSpec = Util.getRemainderDataSpec(initDataSpec, initSegmentBytesLoaded);
-    try {
-      ExtractorInput input = new DefaultExtractorInput(initDataSource,
-              initSegmentDataSpec.absoluteStreamPosition, initDataSource.open(initSegmentDataSpec));
-      try {
-        int result = Extractor.RESULT_CONTINUE;
-        while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractor.read(input, null);
-        }
-      } finally {
-        initSegmentBytesLoaded = (int) (input.getPosition() - initDataSpec.absoluteStreamPosition);
-      }
-    } finally {
-      Util.closeQuietly(dataSource);
+
+    // Loadable implementation
+
+    @Override
+    public void cancelLoad() {
+        loadCanceled = true;
     }
-    initLoadCompleted = true;
-  }
-
-  private void loadMedia() throws IOException, InterruptedException {
-    // If we previously fed part of this chunk to the extractor, we need to skip it this time. For
-    // encrypted content we need to skip the data by reading it through the source, so as to ensure
-    // correct decryption of the remainder of the chunk. For clear content, we can request the
-    // remainder of the chunk directly.
-    DataSpec loadDataSpec;
-    boolean skipLoadedBytes;
-    if (isEncrypted) {
-      loadDataSpec = dataSpec;
-      skipLoadedBytes = bytesLoaded != 0;
-    } else {
-      loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
-      skipLoadedBytes = false;
+
+    @Override
+    public boolean isLoadCanceled() {
+        return loadCanceled;
     }
-    if (!isMasterTimestampSource) {
-      timestampAdjuster.waitUntilInitialized();
+
+    @Override
+    public void load() throws IOException, InterruptedException {
+        if (extractor == null && !isPackedAudio) {
+            // See HLS spec, version 20, Section 3.4 for more information on packed audio extraction.
+            extractor = buildExtractorByExtension();
+        }
+        maybeLoadInitData();
+        if (!loadCanceled) {
+            loadMedia();
+        }
     }
 
-    // 如何加载文件呢?
-    try {
-      ExtractorInput input = new DefaultExtractorInput(dataSource,
-              loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
+    // Internal loading methods.
 
-      if (extractor == null) {
-        // Media segment format is packed audio.
-        long id3Timestamp = peekId3PrivTimestamp(input);
-        if (id3Timestamp == C.TIME_UNSET) {
-          throw new ParserException("ID3 PRIV timestamp missing.");
+    private void maybeLoadInitData() throws IOException, InterruptedException {
+        if ((previousChunk != null && previousChunk.extractor == extractor) || initLoadCompleted
+                || initDataSpec == null) {
+            return;
         }
-        extractor = buildPackedAudioExtractor(timestampAdjuster.adjustTsTimestamp(id3Timestamp));
-      }
-      if (skipLoadedBytes) {
-        input.skipFully(bytesLoaded);
-      }
-
-      try {
-        int result = Extractor.RESULT_CONTINUE;
-        while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
-          result = extractor.read(input, null);
+        DataSpec initSegmentDataSpec = Util.getRemainderDataSpec(initDataSpec, initSegmentBytesLoaded);
+        try {
+            ExtractorInput input = new DefaultExtractorInput(initDataSource,
+                    initSegmentDataSpec.absoluteStreamPosition, initDataSource.open(initSegmentDataSpec));
+            try {
+                int result = Extractor.RESULT_CONTINUE;
+                while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+                    result = extractor.read(input, null);
+                }
+            } finally {
+                initSegmentBytesLoaded = (int) (input.getPosition() - initDataSpec.absoluteStreamPosition);
+            }
+        } finally {
+            Util.closeQuietly(dataSource);
         }
-      } finally {
-        bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
-      }
-    } finally {
-      Util.closeQuietly(dataSource);
-    }
-    loadCompleted = true;
-  }
-
-  /**
-   * Peek the presentation timestamp of the first sample in the chunk from an ID3 PRIV as defined
-   * in the HLS spec, version 20, Section 3.4. Returns {@link C#TIME_UNSET} if the frame is not
-   * found. This method only modifies the peek position.
-   *
-   * @param input The {@link ExtractorInput} to obtain the PRIV frame from.
-   * @return The parsed, adjusted timestamp in microseconds
-   * @throws IOException          If an error occurred peeking from the input.
-   * @throws InterruptedException If the thread was interrupted.
-   */
-  private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, InterruptedException {
-    input.resetPeekPosition();
-    if (!input.peekFully(id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH, true)) {
-      return C.TIME_UNSET;
-    }
-    id3Data.reset(Id3Decoder.ID3_HEADER_LENGTH);
-    int id = id3Data.readUnsignedInt24();
-    if (id != Id3Decoder.ID3_TAG) {
-      return C.TIME_UNSET;
+        initLoadCompleted = true;
     }
-    id3Data.skipBytes(3); // version(2), flags(1).
-    int id3Size = id3Data.readSynchSafeInt();
-    int requiredCapacity = id3Size + Id3Decoder.ID3_HEADER_LENGTH;
-    if (requiredCapacity > id3Data.capacity()) {
-      byte[] data = id3Data.data;
-      id3Data.reset(requiredCapacity);
-      System.arraycopy(data, 0, id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
-    }
-    if (!input.peekFully(id3Data.data, Id3Decoder.ID3_HEADER_LENGTH, id3Size, true)) {
-      return C.TIME_UNSET;
-    }
-    Metadata metadata = id3Decoder.decode(id3Data.data, id3Size);
-    if (metadata == null) {
-      return C.TIME_UNSET;
+
+    private void loadMedia() throws IOException, InterruptedException {
+        // If we previously fed part of this chunk to the extractor, we need to skip it this time. For
+        // encrypted content we need to skip the data by reading it through the source, so as to ensure
+        // correct decryption of the remainder of the chunk. For clear content, we can request the
+        // remainder of the chunk directly.
+        DataSpec loadDataSpec;
+        boolean skipLoadedBytes;
+        if (isEncrypted) {
+            loadDataSpec = dataSpec;
+            skipLoadedBytes = bytesLoaded != 0;
+        } else {
+            loadDataSpec = Util.getRemainderDataSpec(dataSpec, bytesLoaded);
+            skipLoadedBytes = false;
+        }
+        if (!isMasterTimestampSource) {
+            timestampAdjuster.waitUntilInitialized();
+        }
+
+        // 如何加载文件呢?
+        try {
+            ExtractorInput input = new DefaultExtractorInput(dataSource,
+                    loadDataSpec.absoluteStreamPosition, dataSource.open(loadDataSpec));
+
+            if (extractor == null) {
+                // Media segment format is packed audio.
+                long id3Timestamp = peekId3PrivTimestamp(input);
+                if (id3Timestamp == C.TIME_UNSET) {
+                    throw new ParserException("ID3 PRIV timestamp missing.");
+                }
+                extractor = buildPackedAudioExtractor(timestampAdjuster.adjustTsTimestamp(id3Timestamp));
+            }
+            if (skipLoadedBytes) {
+                input.skipFully(bytesLoaded);
+            }
+
+            try {
+                int result = Extractor.RESULT_CONTINUE;
+                while (result == Extractor.RESULT_CONTINUE && !loadCanceled) {
+                    result = extractor.read(input, null);
+                }
+            } finally {
+                bytesLoaded = (int) (input.getPosition() - dataSpec.absoluteStreamPosition);
+            }
+        } finally {
+            Util.closeQuietly(dataSource);
+        }
+        loadCompleted = true;
     }
-    int metadataLength = metadata.length();
-    for (int i = 0; i < metadataLength; i++) {
-      Metadata.Entry frame = metadata.get(i);
-      if (frame instanceof PrivFrame) {
-        PrivFrame privFrame = (PrivFrame) frame;
-        if (PRIV_TIMESTAMP_FRAME_OWNER.equals(privFrame.owner)) {
-          System.arraycopy(privFrame.privateData, 0, id3Data.data, 0, 8 /* timestamp size */);
-          id3Data.reset(8);
-          return id3Data.readLong();
+
+    /**
+     * Peek the presentation timestamp of the first sample in the chunk from an ID3 PRIV as defined
+     * in the HLS spec, version 20, Section 3.4. Returns {@link C#TIME_UNSET} if the frame is not
+     * found. This method only modifies the peek position.
+     *
+     * @param input The {@link ExtractorInput} to obtain the PRIV frame from.
+     * @return The parsed, adjusted timestamp in microseconds
+     * @throws IOException          If an error occurred peeking from the input.
+     * @throws InterruptedException If the thread was interrupted.
+     */
+    private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, InterruptedException {
+        input.resetPeekPosition();
+        if (!input.peekFully(id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH, true)) {
+            return C.TIME_UNSET;
+        }
+        id3Data.reset(Id3Decoder.ID3_HEADER_LENGTH);
+        int id = id3Data.readUnsignedInt24();
+        if (id != Id3Decoder.ID3_TAG) {
+            return C.TIME_UNSET;
+        }
+        id3Data.skipBytes(3); // version(2), flags(1).
+        int id3Size = id3Data.readSynchSafeInt();
+        int requiredCapacity = id3Size + Id3Decoder.ID3_HEADER_LENGTH;
+        if (requiredCapacity > id3Data.capacity()) {
+            byte[] data = id3Data.data;
+            id3Data.reset(requiredCapacity);
+            System.arraycopy(data, 0, id3Data.data, 0, Id3Decoder.ID3_HEADER_LENGTH);
+        }
+        if (!input.peekFully(id3Data.data, Id3Decoder.ID3_HEADER_LENGTH, id3Size, true)) {
+            return C.TIME_UNSET;
+        }
+        Metadata metadata = id3Decoder.decode(id3Data.data, id3Size);
+        if (metadata == null) {
+            return C.TIME_UNSET;
         }
-      }
+        int metadataLength = metadata.length();
+        for (int i = 0; i < metadataLength; i++) {
+            Metadata.Entry frame = metadata.get(i);
+            if (frame instanceof PrivFrame) {
+                PrivFrame privFrame = (PrivFrame) frame;
+                if (PRIV_TIMESTAMP_FRAME_OWNER.equals(privFrame.owner)) {
+                    System.arraycopy(privFrame.privateData, 0, id3Data.data, 0, 8 /* timestamp size */);
+                    id3Data.reset(8);
+                    return id3Data.readLong();
+                }
+            }
+        }
+        return C.TIME_UNSET;
     }
-    return C.TIME_UNSET;
-  }
-
-  // Internal factory methods.
-
-  /**
-   * If the content is encrypted, returns an {@link Aes128DataSource} that wraps the original in
-   * order to decrypt the loaded data. Else returns the original.
-   */
-  private static DataSource buildDataSource(DataSource dataSource, byte[] encryptionKey,
-                                            byte[] encryptionIv) {
-    if (encryptionKey == null || encryptionIv == null) {
-      return dataSource;
+
+    // Internal factory methods.
+
+    /**
+     * If the content is encrypted, returns an {@link Aes128DataSource} that wraps the original in
+     * order to decrypt the loaded data. Else returns the original.
+     */
+    private static DataSource buildDataSource(DataSource dataSource, byte[] encryptionKey,
+                                              byte[] encryptionIv) {
+        if (encryptionKey == null || encryptionIv == null) {
+            return dataSource;
+        }
+        return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
     }
-    return new Aes128DataSource(dataSource, encryptionKey, encryptionIv);
-  }
-
-  private Extractor buildExtractorByExtension() {
-    // Set the extractor that will read the chunk.
-    Extractor extractor;
-    boolean needNewExtractor = previousChunk == null
-            || previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
-            || trackFormat != previousChunk.trackFormat;
-    boolean usingNewExtractor = true;
-    if (lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
-            || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
-      extractor = new WebvttExtractor(trackFormat.language, timestampAdjuster);
-    } else if (!needNewExtractor) {
-      // Only reuse TS and fMP4 extractors.
-      usingNewExtractor = false;
-      extractor = previousChunk.extractor;
-    } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)) {
-      extractor = new FragmentedMp4Extractor(0, timestampAdjuster);
-    } else {
-      // MPEG-2 TS segments, but we need a new extractor.
-      // This flag ensures the change of pid between streams does not affect the sample queues.
-      @DefaultTsPayloadReaderFactory.Flags
-      int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
-      String codecs = trackFormat.codecs;
-      if (!TextUtils.isEmpty(codecs)) {
-        // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
-        // exist. If we know from the codec attribute that they don't exist, then we can
-        // explicitly ignore them even if they're declared.
-        if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
-          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_AAC_STREAM;
+
+    private Extractor buildExtractorByExtension() {
+        // Set the extractor that will read the chunk.
+        Extractor extractor;
+        boolean needNewExtractor = previousChunk == null
+                || previousChunk.discontinuitySequenceNumber != discontinuitySequenceNumber
+                || trackFormat != previousChunk.trackFormat;
+        boolean usingNewExtractor = true;
+        if (lastPathSegment.endsWith(WEBVTT_FILE_EXTENSION)
+                || lastPathSegment.endsWith(VTT_FILE_EXTENSION)) {
+            extractor = new WebvttExtractor(trackFormat.language, timestampAdjuster);
+        } else if (!needNewExtractor) {
+            // Only reuse TS and fMP4 extractors.
+            usingNewExtractor = false;
+            extractor = previousChunk.extractor;
+        } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)) {
+            extractor = new FragmentedMp4Extractor(0, timestampAdjuster);
+        } else {
+            // MPEG-2 TS segments, but we need a new extractor.
+            // This flag ensures the change of pid between streams does not affect the sample queues.
+            @DefaultTsPayloadReaderFactory.Flags
+            int esReaderFactoryFlags = DefaultTsPayloadReaderFactory.FLAG_IGNORE_SPLICE_INFO_STREAM;
+            String codecs = trackFormat.codecs;
+            if (!TextUtils.isEmpty(codecs)) {
+                // Sometimes AAC and H264 streams are declared in TS chunks even though they don't really
+                // exist. If we know from the codec attribute that they don't exist, then we can
+                // explicitly ignore them even if they're declared.
+                if (!MimeTypes.AUDIO_AAC.equals(MimeTypes.getAudioMediaMimeType(codecs))) {
+                    esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_AAC_STREAM;
+                }
+                if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
+                    esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
+                }
+            }
+            extractor = new TsExtractor(timestampAdjuster,
+                    new DefaultTsPayloadReaderFactory(esReaderFactoryFlags), true);
         }
-        if (!MimeTypes.VIDEO_H264.equals(MimeTypes.getVideoMediaMimeType(codecs))) {
-          esReaderFactoryFlags |= DefaultTsPayloadReaderFactory.FLAG_IGNORE_H264_STREAM;
+        if (usingNewExtractor) {
+            extractor.init(extractorOutput);
         }
-      }
-      extractor = new TsExtractor(timestampAdjuster,
-              new DefaultTsPayloadReaderFactory(esReaderFactoryFlags), true);
-    }
-    if (usingNewExtractor) {
-      extractor.init(extractorOutput);
+        return extractor;
     }
-    return extractor;
-  }
-
-  private Extractor buildPackedAudioExtractor(long startTimeUs) {
-    Extractor extractor;
-    if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
-      extractor = new AdtsExtractor(startTimeUs);
-    } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
-            || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
-      extractor = new Ac3Extractor(startTimeUs);
-    } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
-      extractor = new Mp3Extractor(startTimeUs);
-    } else {
-      throw new IllegalArgumentException("Unkown extension for audio file: " + lastPathSegment);
+
+    private Extractor buildPackedAudioExtractor(long startTimeUs) {
+        Extractor extractor;
+        if (lastPathSegment.endsWith(AAC_FILE_EXTENSION)) {
+            extractor = new AdtsExtractor(startTimeUs);
+        } else if (lastPathSegment.endsWith(AC3_FILE_EXTENSION)
+                || lastPathSegment.endsWith(EC3_FILE_EXTENSION)) {
+            extractor = new Ac3Extractor(startTimeUs);
+        } else if (lastPathSegment.endsWith(MP3_FILE_EXTENSION)) {
+            extractor = new Mp3Extractor(startTimeUs);
+        } else {
+            throw new IllegalArgumentException("Unkown extension for audio file: " + lastPathSegment);
+        }
+        extractor.init(extractorOutput);
+        return extractor;
     }
-    extractor.init(extractorOutput);
-    return extractor;
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index f68015a024..fdcbd2339c 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -47,341 +47,341 @@
 public final class HlsMediaPeriod implements MediaPeriod, HlsSampleStreamWrapper.Callback,
         HlsPlaylistTracker.PlaylistEventListener {
 
-  private final HlsPlaylistTracker playlistTracker;
-  private final DataSource.Factory dataSourceFactory;
-  private final int minLoadableRetryCount;
-  private final EventDispatcher eventDispatcher;
-  private final Allocator allocator;
-  private final IdentityHashMap<SampleStream, Integer> streamWrapperIndices;
-  private final TimestampAdjusterProvider timestampAdjusterProvider;
-  private final Handler continueLoadingHandler;
-  private final long preparePositionUs;
-
-  private Callback callback;
-  private int pendingPrepareCount;
-  private boolean seenFirstTrackSelection;
-  private TrackGroupArray trackGroups;
-  private HlsSampleStreamWrapper[] sampleStreamWrappers;
-  private HlsSampleStreamWrapper[] enabledSampleStreamWrappers;
-  private CompositeSequenceableLoader sequenceableLoader;
-
-  public HlsMediaPeriod(HlsPlaylistTracker playlistTracker, DataSource.Factory dataSourceFactory,
-                        int minLoadableRetryCount, EventDispatcher eventDispatcher, Allocator allocator,
-                        long positionUs) {
-
-    this.playlistTracker = playlistTracker;
-    this.dataSourceFactory = dataSourceFactory;
-    this.minLoadableRetryCount = minLoadableRetryCount;
-    this.eventDispatcher = eventDispatcher;
-    this.allocator = allocator;
-    streamWrapperIndices = new IdentityHashMap<>();
-    timestampAdjusterProvider = new TimestampAdjusterProvider();
-    continueLoadingHandler = new Handler();
-    preparePositionUs = positionUs;
-  }
-
-  public void release() {
-    playlistTracker.removeListener(this);
-    continueLoadingHandler.removeCallbacksAndMessages(null);
-    if (sampleStreamWrappers != null) {
-      for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
-        sampleStreamWrapper.release();
-      }
+    private final HlsPlaylistTracker playlistTracker;
+    private final DataSource.Factory dataSourceFactory;
+    private final int minLoadableRetryCount;
+    private final EventDispatcher eventDispatcher;
+    private final Allocator allocator;
+    private final IdentityHashMap<SampleStream, Integer> streamWrapperIndices;
+    private final TimestampAdjusterProvider timestampAdjusterProvider;
+    private final Handler continueLoadingHandler;
+    private final long preparePositionUs;
+
+    private Callback callback;
+    private int pendingPrepareCount;
+    private boolean seenFirstTrackSelection;
+    private TrackGroupArray trackGroups;
+    private HlsSampleStreamWrapper[] sampleStreamWrappers;
+    private HlsSampleStreamWrapper[] enabledSampleStreamWrappers;
+    private CompositeSequenceableLoader sequenceableLoader;
+
+    public HlsMediaPeriod(HlsPlaylistTracker playlistTracker, DataSource.Factory dataSourceFactory,
+                          int minLoadableRetryCount, EventDispatcher eventDispatcher, Allocator allocator,
+                          long positionUs) {
+
+        this.playlistTracker = playlistTracker;
+        this.dataSourceFactory = dataSourceFactory;
+        this.minLoadableRetryCount = minLoadableRetryCount;
+        this.eventDispatcher = eventDispatcher;
+        this.allocator = allocator;
+        streamWrapperIndices = new IdentityHashMap<>();
+        timestampAdjusterProvider = new TimestampAdjusterProvider();
+        continueLoadingHandler = new Handler();
+        preparePositionUs = positionUs;
     }
-  }
-
-  @Override
-  public void prepare(Callback callback) {
-    playlistTracker.addListener(this);
-    this.callback = callback;
-    buildAndPrepareSampleStreamWrappers();
-  }
-
-  @Override
-  public void maybeThrowPrepareError() throws IOException {
-    if (sampleStreamWrappers != null) {
-      for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
-        sampleStreamWrapper.maybeThrowPrepareError();
-      }
-    }
-  }
-
-  @Override
-  public TrackGroupArray getTrackGroups() {
-    return trackGroups;
-  }
-
-  @Override
-  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-                           SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-
-    // Map each selection and stream onto a child period index.
-    int[] streamChildIndices = new int[selections.length];
-    int[] selectionChildIndices = new int[selections.length];
-    for (int i = 0; i < selections.length; i++) {
-      streamChildIndices[i] = streams[i] == null ? C.INDEX_UNSET
-              : streamWrapperIndices.get(streams[i]);
-      selectionChildIndices[i] = C.INDEX_UNSET;
-      if (selections[i] != null) {
-        TrackGroup trackGroup = selections[i].getTrackGroup();
-        for (int j = 0; j < sampleStreamWrappers.length; j++) {
-          if (sampleStreamWrappers[j].getTrackGroups().indexOf(trackGroup) != C.INDEX_UNSET) {
-            selectionChildIndices[i] = j;
-            break;
-          }
-        }
-      }
-    }
-    boolean selectedNewTracks = false;
-    streamWrapperIndices.clear();
-    // Select tracks for each child, copying the resulting streams back into a new streams array.
-    SampleStream[] newStreams = new SampleStream[selections.length];
-    SampleStream[] childStreams = new SampleStream[selections.length];
-    TrackSelection[] childSelections = new TrackSelection[selections.length];
-    ArrayList<HlsSampleStreamWrapper> enabledSampleStreamWrapperList = new ArrayList<>(
-            sampleStreamWrappers.length);
-    for (int i = 0; i < sampleStreamWrappers.length; i++) {
-      for (int j = 0; j < selections.length; j++) {
-        childStreams[j] = streamChildIndices[j] == i ? streams[j] : null;
-        childSelections[j] = selectionChildIndices[j] == i ? selections[j] : null;
-      }
-      selectedNewTracks |= sampleStreamWrappers[i].selectTracks(childSelections,
-              mayRetainStreamFlags, childStreams, streamResetFlags, !seenFirstTrackSelection);
-      boolean wrapperEnabled = false;
-      for (int j = 0; j < selections.length; j++) {
-        if (selectionChildIndices[j] == i) {
-          // Assert that the child provided a stream for the selection.
-          Assertions.checkState(childStreams[j] != null);
-          newStreams[j] = childStreams[j];
-          wrapperEnabled = true;
-          streamWrapperIndices.put(childStreams[j], i);
-        } else if (streamChildIndices[j] == i) {
-          // Assert that the child cleared any previous stream.
-          Assertions.checkState(childStreams[j] == null);
+
+    public void release() {
+        playlistTracker.removeListener(this);
+        continueLoadingHandler.removeCallbacksAndMessages(null);
+        if (sampleStreamWrappers != null) {
+            for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
+                sampleStreamWrapper.release();
+            }
         }
-      }
-      if (wrapperEnabled) {
-        enabledSampleStreamWrapperList.add(sampleStreamWrappers[i]);
-      }
     }
-    // Copy the new streams back into the streams array.
-    System.arraycopy(newStreams, 0, streams, 0, newStreams.length);
-    // Update the local state.
-    enabledSampleStreamWrappers = new HlsSampleStreamWrapper[enabledSampleStreamWrapperList.size()];
-    enabledSampleStreamWrapperList.toArray(enabledSampleStreamWrappers);
-
-    // The first enabled sample stream wrapper is responsible for intializing the timestamp
-    // adjuster. This way, if present, variants are responsible. Otherwise, audio renditions are.
-    // If only subtitles are present, then text renditions are used for timestamp adjustment
-    // initialization.
-    if (enabledSampleStreamWrappers.length > 0) {
-      enabledSampleStreamWrappers[0].setIsTimestampMaster(true);
-      for (int i = 1; i < enabledSampleStreamWrappers.length; i++) {
-        enabledSampleStreamWrappers[i].setIsTimestampMaster(false);
-      }
+
+    @Override
+    public void prepare(Callback callback) {
+        playlistTracker.addListener(this);
+        this.callback = callback;
+        buildAndPrepareSampleStreamWrappers();
     }
 
-    sequenceableLoader = new CompositeSequenceableLoader(enabledSampleStreamWrappers);
-    if (seenFirstTrackSelection && selectedNewTracks) {
-      seekToUs(positionUs);
-      // We'll need to reset renderers consuming from all streams due to the seek.
-      for (int i = 0; i < selections.length; i++) {
-        if (streams[i] != null) {
-          streamResetFlags[i] = true;
+    @Override
+    public void maybeThrowPrepareError() throws IOException {
+        if (sampleStreamWrappers != null) {
+            for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
+                sampleStreamWrapper.maybeThrowPrepareError();
+            }
         }
-      }
     }
-    seenFirstTrackSelection = true;
-    return positionUs;
-  }
-
-  @Override
-  public boolean continueLoading(long positionUs) {
-    return sequenceableLoader.continueLoading(positionUs);
-  }
-
-  @Override
-  public long getNextLoadPositionUs() {
-    return sequenceableLoader.getNextLoadPositionUs();
-  }
-
-  @Override
-  public long readDiscontinuity() {
-    return C.TIME_UNSET;
-  }
-
-  @Override
-  public long getBufferedPositionUs() {
-    long bufferedPositionUs = Long.MAX_VALUE;
-    for (HlsSampleStreamWrapper sampleStreamWrapper : enabledSampleStreamWrappers) {
-      long rendererBufferedPositionUs = sampleStreamWrapper.getBufferedPositionUs();
-      if (rendererBufferedPositionUs != C.TIME_END_OF_SOURCE) {
-        bufferedPositionUs = Math.min(bufferedPositionUs, rendererBufferedPositionUs);
-      }
+
+    @Override
+    public TrackGroupArray getTrackGroups() {
+        return trackGroups;
     }
-    return bufferedPositionUs == Long.MAX_VALUE ? C.TIME_END_OF_SOURCE : bufferedPositionUs;
-  }
-
-  @Override
-  public long seekToUs(long positionUs) {
-    timestampAdjusterProvider.reset();
-    // 所有的SampleStreamWrapper, seek？
-    for (HlsSampleStreamWrapper sampleStreamWrapper : enabledSampleStreamWrappers) {
-      sampleStreamWrapper.seekTo(positionUs);
+
+    @Override
+    public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+                             SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+
+        // Map each selection and stream onto a child period index.
+        int[] streamChildIndices = new int[selections.length];
+        int[] selectionChildIndices = new int[selections.length];
+
+        for (int i = 0; i < selections.length; i++) {
+            streamChildIndices[i] = streams[i] == null ? C.INDEX_UNSET : streamWrapperIndices.get(streams[i]);
+            selectionChildIndices[i] = C.INDEX_UNSET;
+            if (selections[i] != null) {
+                TrackGroup trackGroup = selections[i].getTrackGroup();
+                for (int j = 0; j < sampleStreamWrappers.length; j++) {
+                    if (sampleStreamWrappers[j].getTrackGroups().indexOf(trackGroup) != C.INDEX_UNSET) {
+                        selectionChildIndices[i] = j;
+                        break;
+                    }
+                }
+            }
+        }
+        boolean selectedNewTracks = false;
+        streamWrapperIndices.clear();
+        // Select tracks for each child, copying the resulting streams back into a new streams array.
+        SampleStream[] newStreams = new SampleStream[selections.length];
+        SampleStream[] childStreams = new SampleStream[selections.length];
+        TrackSelection[] childSelections = new TrackSelection[selections.length];
+        ArrayList<HlsSampleStreamWrapper> enabledSampleStreamWrapperList = new ArrayList<>(
+                sampleStreamWrappers.length);
+        for (int i = 0; i < sampleStreamWrappers.length; i++) {
+            for (int j = 0; j < selections.length; j++) {
+                childStreams[j] = streamChildIndices[j] == i ? streams[j] : null;
+                childSelections[j] = selectionChildIndices[j] == i ? selections[j] : null;
+            }
+            selectedNewTracks |= sampleStreamWrappers[i].selectTracks(childSelections,
+                    mayRetainStreamFlags, childStreams, streamResetFlags, !seenFirstTrackSelection);
+            boolean wrapperEnabled = false;
+            for (int j = 0; j < selections.length; j++) {
+                if (selectionChildIndices[j] == i) {
+                    // Assert that the child provided a stream for the selection.
+                    Assertions.checkState(childStreams[j] != null);
+                    newStreams[j] = childStreams[j];
+                    wrapperEnabled = true;
+                    streamWrapperIndices.put(childStreams[j], i);
+                } else if (streamChildIndices[j] == i) {
+                    // Assert that the child cleared any previous stream.
+                    Assertions.checkState(childStreams[j] == null);
+                }
+            }
+            if (wrapperEnabled) {
+                enabledSampleStreamWrapperList.add(sampleStreamWrappers[i]);
+            }
+        }
+        // Copy the new streams back into the streams array.
+        System.arraycopy(newStreams, 0, streams, 0, newStreams.length);
+        // Update the local state.
+        enabledSampleStreamWrappers = new HlsSampleStreamWrapper[enabledSampleStreamWrapperList.size()];
+        enabledSampleStreamWrapperList.toArray(enabledSampleStreamWrappers);
+
+        // The first enabled sample stream wrapper is responsible for intializing the timestamp
+        // adjuster. This way, if present, variants are responsible. Otherwise, audio renditions are.
+        // If only subtitles are present, then text renditions are used for timestamp adjustment
+        // initialization.
+        if (enabledSampleStreamWrappers.length > 0) {
+            enabledSampleStreamWrappers[0].setIsTimestampMaster(true);
+            for (int i = 1; i < enabledSampleStreamWrappers.length; i++) {
+                enabledSampleStreamWrappers[i].setIsTimestampMaster(false);
+            }
+        }
+
+        sequenceableLoader = new CompositeSequenceableLoader(enabledSampleStreamWrappers);
+        if (seenFirstTrackSelection && selectedNewTracks) {
+            seekToUs(positionUs);
+            // We'll need to reset renderers consuming from all streams due to the seek.
+            for (int i = 0; i < selections.length; i++) {
+                if (streams[i] != null) {
+                    streamResetFlags[i] = true;
+                }
+            }
+        }
+        seenFirstTrackSelection = true;
+        return positionUs;
     }
-    return positionUs;
-  }
 
-  // HlsSampleStreamWrapper.Callback implementation.
+    @Override
+    public boolean continueLoading(long positionUs) {
+        return sequenceableLoader.continueLoading(positionUs);
+    }
 
-  @Override
-  public void onPrepared() {
-    if (--pendingPrepareCount > 0) {
-      return;
+    @Override
+    public long getNextLoadPositionUs() {
+        return sequenceableLoader.getNextLoadPositionUs();
     }
 
-    int totalTrackGroupCount = 0;
-    for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
-      totalTrackGroupCount += sampleStreamWrapper.getTrackGroups().length;
+    @Override
+    public long readDiscontinuity() {
+        return C.TIME_UNSET;
     }
-    TrackGroup[] trackGroupArray = new TrackGroup[totalTrackGroupCount];
-    int trackGroupIndex = 0;
-    for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
-      int wrapperTrackGroupCount = sampleStreamWrapper.getTrackGroups().length;
-      for (int j = 0; j < wrapperTrackGroupCount; j++) {
-        trackGroupArray[trackGroupIndex++] = sampleStreamWrapper.getTrackGroups().get(j);
-      }
+
+    @Override
+    public long getBufferedPositionUs() {
+        long bufferedPositionUs = Long.MAX_VALUE;
+        for (HlsSampleStreamWrapper sampleStreamWrapper : enabledSampleStreamWrappers) {
+            long rendererBufferedPositionUs = sampleStreamWrapper.getBufferedPositionUs();
+            if (rendererBufferedPositionUs != C.TIME_END_OF_SOURCE) {
+                bufferedPositionUs = Math.min(bufferedPositionUs, rendererBufferedPositionUs);
+            }
+        }
+        return bufferedPositionUs == Long.MAX_VALUE ? C.TIME_END_OF_SOURCE : bufferedPositionUs;
     }
-    trackGroups = new TrackGroupArray(trackGroupArray);
-    callback.onPrepared(this);
-  }
-
-  @Override
-  public void onPlaylistRefreshRequired(HlsUrl url) {
-    playlistTracker.refreshPlaylist(url);
-  }
-
-  @Override
-  public void onContinueLoadingRequested(HlsSampleStreamWrapper sampleStreamWrapper) {
-    if (trackGroups == null) {
-      // Still preparing.
-      return;
+
+    @Override
+    public long seekToUs(long positionUs) {
+        timestampAdjusterProvider.reset();
+        // 所有的SampleStreamWrapper, seek？
+        for (HlsSampleStreamWrapper sampleStreamWrapper : enabledSampleStreamWrappers) {
+            sampleStreamWrapper.seekTo(positionUs);
+        }
+        return positionUs;
     }
-    callback.onContinueLoadingRequested(this);
-  }
 
-  // PlaylistListener implementation.
+    // HlsSampleStreamWrapper.Callback implementation.
+
+    @Override
+    public void onPrepared() {
+        if (--pendingPrepareCount > 0) {
+            return;
+        }
 
-  @Override
-  public void onPlaylistChanged() {
-    continuePreparingOrLoading();
-  }
+        int totalTrackGroupCount = 0;
+        for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
+            totalTrackGroupCount += sampleStreamWrapper.getTrackGroups().length;
+        }
+        TrackGroup[] trackGroupArray = new TrackGroup[totalTrackGroupCount];
+        int trackGroupIndex = 0;
+        for (HlsSampleStreamWrapper sampleStreamWrapper : sampleStreamWrappers) {
+            int wrapperTrackGroupCount = sampleStreamWrapper.getTrackGroups().length;
+            for (int j = 0; j < wrapperTrackGroupCount; j++) {
+                trackGroupArray[trackGroupIndex++] = sampleStreamWrapper.getTrackGroups().get(j);
+            }
+        }
+        trackGroups = new TrackGroupArray(trackGroupArray);
+        callback.onPrepared(this);
+    }
 
-  @Override
-  public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
-    for (HlsSampleStreamWrapper streamWrapper : sampleStreamWrappers) {
-      streamWrapper.onPlaylistBlacklisted(url, blacklistMs);
+    @Override
+    public void onPlaylistRefreshRequired(HlsUrl url) {
+        playlistTracker.refreshPlaylist(url);
     }
-    continuePreparingOrLoading();
-  }
-
-  // Internal methods.
-
-  private void buildAndPrepareSampleStreamWrappers() {
-    HlsMasterPlaylist masterPlaylist = playlistTracker.getMasterPlaylist();
-    // Build the default stream wrapper.
-    List<HlsUrl> selectedVariants = new ArrayList<>(masterPlaylist.variants);
-    ArrayList<HlsUrl> definiteVideoVariants = new ArrayList<>();
-    ArrayList<HlsUrl> definiteAudioOnlyVariants = new ArrayList<>();
-    for (int i = 0; i < selectedVariants.size(); i++) {
-      HlsUrl variant = selectedVariants.get(i);
-      if (variant.format.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
-        definiteVideoVariants.add(variant);
-      } else if (variantHasExplicitCodecWithPrefix(variant, "mp4a")) {
-        definiteAudioOnlyVariants.add(variant);
-      }
+
+    @Override
+    public void onContinueLoadingRequested(HlsSampleStreamWrapper sampleStreamWrapper) {
+        if (trackGroups == null) {
+            // Still preparing.
+            return;
+        }
+        callback.onContinueLoadingRequested(this);
     }
-    if (!definiteVideoVariants.isEmpty()) {
-      // We've identified some variants as definitely containing video. Assume variants within the
-      // master playlist are marked consistently, and hence that we have the full set. Filter out
-      // any other variants, which are likely to be audio only.
-      selectedVariants = definiteVideoVariants;
-    } else if (definiteAudioOnlyVariants.size() < selectedVariants.size()) {
-      // We've identified some variants, but not all, as being audio only. Filter them out to leave
-      // the remaining variants, which are likely to contain video.
-      selectedVariants.removeAll(definiteAudioOnlyVariants);
-    } else {
-      // Leave the enabled variants unchanged. They're likely either all video or all audio.
+
+    // PlaylistListener implementation.
+
+    @Override
+    public void onPlaylistChanged() {
+        continuePreparingOrLoading();
     }
-    List<HlsUrl> audioRenditions = masterPlaylist.audios;
-    List<HlsUrl> subtitleRenditions = masterPlaylist.subtitles;
-    sampleStreamWrappers = new HlsSampleStreamWrapper[1 /* variants */ + audioRenditions.size()
-            + subtitleRenditions.size()];
-    int currentWrapperIndex = 0;
-    pendingPrepareCount = sampleStreamWrappers.length;
-
-    Assertions.checkArgument(!selectedVariants.isEmpty());
-    HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[selectedVariants.size()];
-    selectedVariants.toArray(variants);
-    HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT,
-            variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormat);
-    sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
-    sampleStreamWrapper.setIsTimestampMaster(true);
-    sampleStreamWrapper.continuePreparing();
-
-    // TODO: Build video stream wrappers here.
-
-    // Build audio stream wrappers.
-    for (int i = 0; i < audioRenditions.size(); i++) {
-      sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_AUDIO,
-              new HlsUrl[]{audioRenditions.get(i)}, null, null);
-      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
-      sampleStreamWrapper.continuePreparing();
+
+    @Override
+    public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
+        for (HlsSampleStreamWrapper streamWrapper : sampleStreamWrappers) {
+            streamWrapper.onPlaylistBlacklisted(url, blacklistMs);
+        }
+        continuePreparingOrLoading();
     }
 
-    // Build subtitle stream wrappers.
-    for (int i = 0; i < subtitleRenditions.size(); i++) {
-      HlsUrl url = subtitleRenditions.get(i);
-      sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_TEXT, new HlsUrl[]{url}, null,
-              null);
-      sampleStreamWrapper.prepareSingleTrack(url.format);
-      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+    // Internal methods.
+
+    private void buildAndPrepareSampleStreamWrappers() {
+        HlsMasterPlaylist masterPlaylist = playlistTracker.getMasterPlaylist();
+        // Build the default stream wrapper.
+        List<HlsUrl> selectedVariants = new ArrayList<>(masterPlaylist.variants);
+        ArrayList<HlsUrl> definiteVideoVariants = new ArrayList<>();
+        ArrayList<HlsUrl> definiteAudioOnlyVariants = new ArrayList<>();
+        for (int i = 0; i < selectedVariants.size(); i++) {
+            HlsUrl variant = selectedVariants.get(i);
+            if (variant.format.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
+                definiteVideoVariants.add(variant);
+            } else if (variantHasExplicitCodecWithPrefix(variant, "mp4a")) {
+                definiteAudioOnlyVariants.add(variant);
+            }
+        }
+        if (!definiteVideoVariants.isEmpty()) {
+            // We've identified some variants as definitely containing video. Assume variants within the
+            // master playlist are marked consistently, and hence that we have the full set. Filter out
+            // any other variants, which are likely to be audio only.
+            selectedVariants = definiteVideoVariants;
+        } else if (definiteAudioOnlyVariants.size() < selectedVariants.size()) {
+            // We've identified some variants, but not all, as being audio only. Filter them out to leave
+            // the remaining variants, which are likely to contain video.
+            selectedVariants.removeAll(definiteAudioOnlyVariants);
+        } else {
+            // Leave the enabled variants unchanged. They're likely either all video or all audio.
+        }
+        List<HlsUrl> audioRenditions = masterPlaylist.audios;
+        List<HlsUrl> subtitleRenditions = masterPlaylist.subtitles;
+        sampleStreamWrappers = new HlsSampleStreamWrapper[1 /* variants */ + audioRenditions.size()
+                + subtitleRenditions.size()];
+        int currentWrapperIndex = 0;
+        pendingPrepareCount = sampleStreamWrappers.length;
+
+        Assertions.checkArgument(!selectedVariants.isEmpty());
+        HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[selectedVariants.size()];
+        selectedVariants.toArray(variants);
+        HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT,
+                variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormat);
+        sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+        sampleStreamWrapper.setIsTimestampMaster(true);
+        sampleStreamWrapper.continuePreparing();
+
+        // TODO: Build video stream wrappers here.
+
+        // Build audio stream wrappers.
+        for (int i = 0; i < audioRenditions.size(); i++) {
+            sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_AUDIO,
+                    new HlsUrl[]{audioRenditions.get(i)}, null, null);
+            sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+            sampleStreamWrapper.continuePreparing();
+        }
+
+        // Build subtitle stream wrappers.
+        for (int i = 0; i < subtitleRenditions.size(); i++) {
+            HlsUrl url = subtitleRenditions.get(i);
+            sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_TEXT, new HlsUrl[]{url}, null,
+                    null);
+            sampleStreamWrapper.prepareSingleTrack(url.format);
+            sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+        }
     }
-  }
-
-  private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[] variants,
-                                                          Format muxedAudioFormat, Format muxedCaptionFormat) {
-    DataSource dataSource = dataSourceFactory.createDataSource();
-    HlsChunkSource defaultChunkSource = new HlsChunkSource(playlistTracker, variants, dataSource,
-            timestampAdjusterProvider);
-    return new HlsSampleStreamWrapper(trackType, this, defaultChunkSource, allocator,
-            preparePositionUs, muxedAudioFormat, muxedCaptionFormat, minLoadableRetryCount,
-            eventDispatcher);
-  }
-
-  private void continuePreparingOrLoading() {
-    if (trackGroups != null) {
-      callback.onContinueLoadingRequested(this);
-    } else {
-      // Some of the wrappers were waiting for their media playlist to prepare.
-      for (HlsSampleStreamWrapper wrapper : sampleStreamWrappers) {
-        wrapper.continuePreparing();
-      }
+
+    private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[] variants,
+                                                            Format muxedAudioFormat, Format muxedCaptionFormat) {
+        DataSource dataSource = dataSourceFactory.createDataSource();
+        HlsChunkSource defaultChunkSource = new HlsChunkSource(playlistTracker, variants, dataSource,
+                timestampAdjusterProvider);
+        return new HlsSampleStreamWrapper(trackType, this, defaultChunkSource, allocator,
+                preparePositionUs, muxedAudioFormat, muxedCaptionFormat, minLoadableRetryCount,
+                eventDispatcher);
     }
-  }
 
-  private static boolean variantHasExplicitCodecWithPrefix(HlsUrl variant, String prefix) {
-    String codecs = variant.format.codecs;
-    if (TextUtils.isEmpty(codecs)) {
-      return false;
+    private void continuePreparingOrLoading() {
+        if (trackGroups != null) {
+            callback.onContinueLoadingRequested(this);
+        } else {
+            // Some of the wrappers were waiting for their media playlist to prepare.
+            for (HlsSampleStreamWrapper wrapper : sampleStreamWrappers) {
+                wrapper.continuePreparing();
+            }
+        }
     }
-    String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
-    for (String codec : codecArray) {
-      if (codec.startsWith(prefix)) {
-        return true;
-      }
+
+    private static boolean variantHasExplicitCodecWithPrefix(HlsUrl variant, String prefix) {
+        String codecs = variant.format.codecs;
+        if (TextUtils.isEmpty(codecs)) {
+            return false;
+        }
+        String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
+        for (String codec : codecArray) {
+            if (codec.startsWith(prefix)) {
+                return true;
+            }
+        }
+        return false;
     }
-    return false;
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index 9f01bd40d3..8ce8bef46d 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.os.Handler;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
@@ -29,6 +30,7 @@
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
+
 import java.io.IOException;
 import java.util.List;
 
@@ -36,96 +38,96 @@
  * An HLS {@link MediaSource}.
  */
 public final class HlsMediaSource implements MediaSource,
-    HlsPlaylistTracker.PrimaryPlaylistListener {
-
-  /**
-   * The default minimum number of times to retry loading data prior to failing.
-   */
-  public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
-
-  private final Uri manifestUri;
-  private final DataSource.Factory dataSourceFactory;
-  private final int minLoadableRetryCount;
-  private final EventDispatcher eventDispatcher;
-
-  private HlsPlaylistTracker playlistTracker;
-  private Listener sourceListener;
-
-  // manifestUri masterHls文件等
-  // dataSourceFactory HttpDataSource网络控制
-  public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
-    this(manifestUri, dataSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT, eventHandler,
-        eventListener);
-  }
-
-  public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
-      int minLoadableRetryCount, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
-    this.manifestUri = manifestUri;
-    this.dataSourceFactory = dataSourceFactory;
-    this.minLoadableRetryCount = minLoadableRetryCount;
-
-    // 如何处理HlsMediaSource呢?
-    eventDispatcher = new EventDispatcher(eventHandler, eventListener);
-  }
-
-  @Override
-  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
-    Assertions.checkState(playlistTracker == null);
-    // 例如:
-    //       manifestUri = https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8
-    playlistTracker = new HlsPlaylistTracker(manifestUri, dataSourceFactory, eventDispatcher, minLoadableRetryCount, this);
-
-    sourceListener = listener;
-    playlistTracker.start();
-  }
-
-  @Override
-  public void maybeThrowSourceInfoRefreshError() throws IOException {
-    playlistTracker.maybeThrowPlaylistRefreshError();
-  }
-
-  @Override
-  public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
-    Assertions.checkArgument(index == 0);
-    return new HlsMediaPeriod(playlistTracker, dataSourceFactory, minLoadableRetryCount,
-        eventDispatcher, allocator, positionUs);
-  }
-
-  @Override
-  public void releasePeriod(MediaPeriod mediaPeriod) {
-    ((HlsMediaPeriod) mediaPeriod).release();
-  }
-
-  @Override
-  public void releaseSource() {
-    playlistTracker.release();
-    playlistTracker = null;
-    sourceListener = null;
-  }
-
-  @Override
-  public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
-    SinglePeriodTimeline timeline;
-    // 直播
-    if (playlistTracker.isLive()) {
-      // TODO: fix windowPositionInPeriodUs when playlist is empty.
-      List<HlsMediaPlaylist.Segment> segments = playlist.segments;
-      long windowDefaultStartPositionUs = segments.isEmpty() ? 0
-          : segments.get(Math.max(0, segments.size() - 3)).relativeStartTimeUs;
-      timeline = new SinglePeriodTimeline(C.TIME_UNSET, playlist.durationUs,
-          playlist.startTimeUs, windowDefaultStartPositionUs, true, !playlist.hasEndTag);
-    } else /* not live */ {
-
-      // 这个是我们关注的信息
-      // Window/Timeline
-      // XXX: 一个m3u8文件对应一个 SinglePeriodTimeline
-      //
-      timeline = new SinglePeriodTimeline(playlist.startTimeUs + playlist.durationUs,
-          playlist.durationUs, playlist.startTimeUs, 0, true, false);
+        HlsPlaylistTracker.PrimaryPlaylistListener {
+
+    /**
+     * The default minimum number of times to retry loading data prior to failing.
+     */
+    public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
+
+    private final Uri manifestUri;
+    private final DataSource.Factory dataSourceFactory;
+    private final int minLoadableRetryCount;
+    private final EventDispatcher eventDispatcher;
+
+    private HlsPlaylistTracker playlistTracker;
+    private Listener sourceListener;
+
+    // manifestUri masterHls文件等
+    // dataSourceFactory HttpDataSource网络控制
+    public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory, Handler eventHandler,
+                          AdaptiveMediaSourceEventListener eventListener) {
+        this(manifestUri, dataSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT, eventHandler,
+                eventListener);
+    }
+
+    public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
+                          int minLoadableRetryCount, Handler eventHandler,
+                          AdaptiveMediaSourceEventListener eventListener) {
+        this.manifestUri = manifestUri;
+        this.dataSourceFactory = dataSourceFactory;
+        this.minLoadableRetryCount = minLoadableRetryCount;
+
+        // 如何处理HlsMediaSource呢?
+        eventDispatcher = new EventDispatcher(eventHandler, eventListener);
+    }
+
+    @Override
+    public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+        Assertions.checkState(playlistTracker == null);
+        // 例如:
+        //       manifestUri = https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear1/prog_index.m3u8
+        playlistTracker = new HlsPlaylistTracker(manifestUri, dataSourceFactory, eventDispatcher, minLoadableRetryCount, this);
+
+        sourceListener = listener;
+        playlistTracker.start();
+    }
+
+    @Override
+    public void maybeThrowSourceInfoRefreshError() throws IOException {
+        playlistTracker.maybeThrowPlaylistRefreshError();
+    }
+
+    @Override
+    public MediaPeriod createPeriod(int index, Allocator allocator, long positionUs) {
+        Assertions.checkArgument(index == 0);
+        return new HlsMediaPeriod(playlistTracker, dataSourceFactory, minLoadableRetryCount,
+                eventDispatcher, allocator, positionUs);
+    }
+
+    @Override
+    public void releasePeriod(MediaPeriod mediaPeriod) {
+        ((HlsMediaPeriod) mediaPeriod).release();
+    }
+
+    @Override
+    public void releaseSource() {
+        playlistTracker.release();
+        playlistTracker = null;
+        sourceListener = null;
+    }
+
+    @Override
+    public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
+        SinglePeriodTimeline timeline;
+        // 直播
+        if (playlistTracker.isLive()) {
+            // TODO: fix windowPositionInPeriodUs when playlist is empty.
+            List<HlsMediaPlaylist.Segment> segments = playlist.segments;
+            long windowDefaultStartPositionUs = segments.isEmpty() ? 0
+                    : segments.get(Math.max(0, segments.size() - 3)).relativeStartTimeUs;
+            timeline = new SinglePeriodTimeline(C.TIME_UNSET, playlist.durationUs,
+                    playlist.startTimeUs, windowDefaultStartPositionUs, true, !playlist.hasEndTag);
+        } else /* not live */ {
+
+            // 这个是我们关注的信息
+            // Window/Timeline
+            // XXX: 一个m3u8文件对应一个 SinglePeriodTimeline
+            //
+            timeline = new SinglePeriodTimeline(playlist.startTimeUs + playlist.durationUs,
+                    playlist.durationUs, playlist.startTimeUs, 0, true, false);
+        }
+        sourceListener.onSourceInfoRefreshed(timeline, playlist);
     }
-    sourceListener.onSourceInfoRefreshed(timeline, playlist);
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
index c63cf3e5a4..ebb8b7b520 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
@@ -18,40 +18,42 @@
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.source.SampleStream;
+
 import java.io.IOException;
 
 /**
  * {@link SampleStream} for a particular track group in HLS.
  */
-/* package */ final class HlsSampleStream implements SampleStream {
-
-  public final int group;
-  
-  private final HlsSampleStreamWrapper sampleStreamWrapper;
-
-  public HlsSampleStream(HlsSampleStreamWrapper sampleStreamWrapper, int group) {
-    this.sampleStreamWrapper = sampleStreamWrapper;
-    this.group = group;
-  }
-
-  @Override
-  public boolean isReady() {
-    return sampleStreamWrapper.isReady(group);
-  }
-
-  @Override
-  public void maybeThrowError() throws IOException {
-    sampleStreamWrapper.maybeThrowError();
-  }
-
-  @Override
-  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
-    return sampleStreamWrapper.readData(group, formatHolder, buffer);
-  }
-
-  @Override
-  public void skipToKeyframeBefore(long timeUs) {
-    sampleStreamWrapper.skipToKeyframeBefore(group, timeUs);
-  }
+/* package */
+final class HlsSampleStream implements SampleStream {
+
+    public final int group;
+
+    private final HlsSampleStreamWrapper sampleStreamWrapper;
+
+    public HlsSampleStream(HlsSampleStreamWrapper sampleStreamWrapper, int group) {
+        this.sampleStreamWrapper = sampleStreamWrapper;
+        this.group = group;
+    }
+
+    @Override
+    public boolean isReady() {
+        return sampleStreamWrapper.isReady(group);
+    }
+
+    @Override
+    public void maybeThrowError() throws IOException {
+        sampleStreamWrapper.maybeThrowError();
+    }
+
+    @Override
+    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
+        return sampleStreamWrapper.readData(group, formatHolder, buffer);
+    }
+
+    @Override
+    public void skipToKeyframeBefore(long timeUs) {
+        sampleStreamWrapper.skipToKeyframeBefore(group, timeUs);
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index 58ffa35c93..d010625373 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -51,654 +51,655 @@
 final class HlsSampleStreamWrapper implements Loader.Callback<Chunk>,
         SequenceableLoader, ExtractorOutput, UpstreamFormatChangedListener {
 
-  /**
-   * A callback to be notified of events.
-   */
-  public interface Callback extends SequenceableLoader.Callback<HlsSampleStreamWrapper> {
+    /**
+     * A callback to be notified of events.
+     */
+    public interface Callback extends SequenceableLoader.Callback<HlsSampleStreamWrapper> {
+
+        /**
+         * Called when the wrapper has been prepared.
+         */
+        void onPrepared();
+
+        /**
+         * Called to schedule a {@link #continueLoading(long)} call when the playlist referred by the
+         * given url changes.
+         */
+        void onPlaylistRefreshRequired(HlsMasterPlaylist.HlsUrl playlistUrl);
+
+    }
+
+    private static final int PRIMARY_TYPE_NONE = 0;
+    private static final int PRIMARY_TYPE_TEXT = 1;
+    private static final int PRIMARY_TYPE_AUDIO = 2;
+    private static final int PRIMARY_TYPE_VIDEO = 3;
+
+    private final int trackType;
+    private final Callback callback;
+    private final HlsChunkSource chunkSource;
+    private final Allocator allocator;
+    private final Format muxedAudioFormat;
+    private final Format muxedCaptionFormat;
+    private final int minLoadableRetryCount;
+    private final Loader loader;
+    private final EventDispatcher eventDispatcher;
+    private final HlsChunkSource.HlsChunkHolder nextChunkHolder;
+    private final SparseArray<DefaultTrackOutput> sampleQueues;
+    private final LinkedList<HlsMediaChunk> mediaChunks;
+    private final Runnable maybeFinishPrepareRunnable;
+    private final Handler handler;
+
+    private boolean sampleQueuesBuilt;
+    private boolean prepared;
+    private int enabledTrackCount;
+    private Format downstreamTrackFormat;
+    private int upstreamChunkUid;
+    private boolean released;
+
+    // Tracks are complicated in HLS. See documentation of buildTracks for details.
+    // Indexed by track (as exposed by this source).
+    private TrackGroupArray trackGroups;
+    private int primaryTrackGroupIndex;
+    // Indexed by group.
+    private boolean[] groupEnabledStates;
+
+    private long lastSeekPositionUs;
+    private long pendingResetPositionUs;
+
+    private boolean loadingFinished;
 
     /**
-     * Called when the wrapper has been prepared.
+     * @param trackType             The type of the track. One of the {@link C} {@code TRACK_TYPE_*} constants.
+     * @param callback              A callback for the wrapper.
+     * @param chunkSource           A {@link HlsChunkSource} from which chunks to load are obtained.
+     * @param allocator             An {@link Allocator} from which to obtain media buffer allocations.
+     * @param positionUs            The position from which to start loading media.
+     * @param muxedAudioFormat      If HLS master playlist indicates that the stream contains muxed audio,
+     *                              this is the audio {@link Format} as defined by the playlist.
+     * @param muxedCaptionFormat    If HLS master playlist indicates that the stream contains muxed
+     *                              captions, this is the audio {@link Format} as defined by the playlist.
+     * @param minLoadableRetryCount The minimum number of times that the source should retry a load
+     *                              before propagating an error.
+     * @param eventDispatcher       A dispatcher to notify of events.
      */
-    void onPrepared();
+    public HlsSampleStreamWrapper(int trackType, Callback callback, HlsChunkSource chunkSource,
+                                  Allocator allocator, long positionUs, Format muxedAudioFormat, Format muxedCaptionFormat,
+                                  int minLoadableRetryCount, EventDispatcher eventDispatcher) {
+        this.trackType = trackType;
+        this.callback = callback;
+        this.chunkSource = chunkSource;
+
+
+        this.allocator = allocator;
+        this.muxedAudioFormat = muxedAudioFormat;
+        this.muxedCaptionFormat = muxedCaptionFormat;
+        this.minLoadableRetryCount = minLoadableRetryCount;
+        this.eventDispatcher = eventDispatcher;
+        loader = new Loader("Loader:HlsSampleStreamWrapper");
+        nextChunkHolder = new HlsChunkSource.HlsChunkHolder();
+        sampleQueues = new SparseArray<>();
+        mediaChunks = new LinkedList<>();
+        maybeFinishPrepareRunnable = new Runnable() {
+            @Override
+            public void run() {
+                maybeFinishPrepare();
+            }
+        };
+        handler = new Handler();
+        lastSeekPositionUs = positionUs;
+        pendingResetPositionUs = positionUs;
+    }
+
+    public void continuePreparing() {
+        if (!prepared) {
+            continueLoading(lastSeekPositionUs);
+        }
+    }
 
     /**
-     * Called to schedule a {@link #continueLoading(long)} call when the playlist referred by the
-     * given url changes.
+     * Prepares a sample stream wrapper for which the master playlist provides enough information to
+     * prepare.
      */
-    void onPlaylistRefreshRequired(HlsMasterPlaylist.HlsUrl playlistUrl);
-
-  }
-
-  private static final int PRIMARY_TYPE_NONE = 0;
-  private static final int PRIMARY_TYPE_TEXT = 1;
-  private static final int PRIMARY_TYPE_AUDIO = 2;
-  private static final int PRIMARY_TYPE_VIDEO = 3;
-
-  private final int trackType;
-  private final Callback callback;
-  private final HlsChunkSource chunkSource;
-  private final Allocator allocator;
-  private final Format muxedAudioFormat;
-  private final Format muxedCaptionFormat;
-  private final int minLoadableRetryCount;
-  private final Loader loader;
-  private final EventDispatcher eventDispatcher;
-  private final HlsChunkSource.HlsChunkHolder nextChunkHolder;
-  private final SparseArray<DefaultTrackOutput> sampleQueues;
-  private final LinkedList<HlsMediaChunk> mediaChunks;
-  private final Runnable maybeFinishPrepareRunnable;
-  private final Handler handler;
-
-  private boolean sampleQueuesBuilt;
-  private boolean prepared;
-  private int enabledTrackCount;
-  private Format downstreamTrackFormat;
-  private int upstreamChunkUid;
-  private boolean released;
-
-  // Tracks are complicated in HLS. See documentation of buildTracks for details.
-  // Indexed by track (as exposed by this source).
-  private TrackGroupArray trackGroups;
-  private int primaryTrackGroupIndex;
-  // Indexed by group.
-  private boolean[] groupEnabledStates;
-
-  private long lastSeekPositionUs;
-  private long pendingResetPositionUs;
-
-  private boolean loadingFinished;
-
-  /**
-   * @param trackType             The type of the track. One of the {@link C} {@code TRACK_TYPE_*} constants.
-   * @param callback              A callback for the wrapper.
-   * @param chunkSource           A {@link HlsChunkSource} from which chunks to load are obtained.
-   * @param allocator             An {@link Allocator} from which to obtain media buffer allocations.
-   * @param positionUs            The position from which to start loading media.
-   * @param muxedAudioFormat      If HLS master playlist indicates that the stream contains muxed audio,
-   *                              this is the audio {@link Format} as defined by the playlist.
-   * @param muxedCaptionFormat    If HLS master playlist indicates that the stream contains muxed
-   *                              captions, this is the audio {@link Format} as defined by the playlist.
-   * @param minLoadableRetryCount The minimum number of times that the source should retry a load
-   *                              before propagating an error.
-   * @param eventDispatcher       A dispatcher to notify of events.
-   */
-  public HlsSampleStreamWrapper(int trackType, Callback callback, HlsChunkSource chunkSource,
-                                Allocator allocator, long positionUs, Format muxedAudioFormat, Format muxedCaptionFormat,
-                                int minLoadableRetryCount, EventDispatcher eventDispatcher) {
-    this.trackType = trackType;
-    this.callback = callback;
-    this.chunkSource = chunkSource;
-
-    
-    this.allocator = allocator;
-    this.muxedAudioFormat = muxedAudioFormat;
-    this.muxedCaptionFormat = muxedCaptionFormat;
-    this.minLoadableRetryCount = minLoadableRetryCount;
-    this.eventDispatcher = eventDispatcher;
-    loader = new Loader("Loader:HlsSampleStreamWrapper");
-    nextChunkHolder = new HlsChunkSource.HlsChunkHolder();
-    sampleQueues = new SparseArray<>();
-    mediaChunks = new LinkedList<>();
-    maybeFinishPrepareRunnable = new Runnable() {
-      @Override
-      public void run() {
+    public void prepareSingleTrack(Format format) {
+        track(0).format(format);
+        sampleQueuesBuilt = true;
         maybeFinishPrepare();
-      }
-    };
-    handler = new Handler();
-    lastSeekPositionUs = positionUs;
-    pendingResetPositionUs = positionUs;
-  }
-
-  public void continuePreparing() {
-    if (!prepared) {
-      continueLoading(lastSeekPositionUs);
-    }
-  }
-
-  /**
-   * Prepares a sample stream wrapper for which the master playlist provides enough information to
-   * prepare.
-   */
-  public void prepareSingleTrack(Format format) {
-    track(0).format(format);
-    sampleQueuesBuilt = true;
-    maybeFinishPrepare();
-  }
-
-  public void maybeThrowPrepareError() throws IOException {
-    maybeThrowError();
-  }
-
-  public TrackGroupArray getTrackGroups() {
-    return trackGroups;
-  }
-
-  public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-                              SampleStream[] streams, boolean[] streamResetFlags, boolean isFirstTrackSelection) {
-    Assertions.checkState(prepared);
-    // Disable old tracks.
-    for (int i = 0; i < selections.length; i++) {
-      if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
-        int group = ((HlsSampleStream) streams[i]).group;
-        setTrackGroupEnabledState(group, false);
-        sampleQueues.valueAt(group).disable();
-        streams[i] = null;
-      }
-    }
-    // Enable new tracks.
-    boolean selectedNewTracks = false;
-    for (int i = 0; i < selections.length; i++) {
-      if (streams[i] == null && selections[i] != null) {
-        TrackSelection selection = selections[i];
-        int group = trackGroups.indexOf(selection.getTrackGroup());
-        setTrackGroupEnabledState(group, true);
-        if (group == primaryTrackGroupIndex) {
-          chunkSource.selectTracks(selection);
-        }
-        streams[i] = new HlsSampleStream(this, group);
-        streamResetFlags[i] = true;
-        selectedNewTracks = true;
-      }
-    }
-    if (isFirstTrackSelection) {
-      // At the time of the first track selection all queues will be enabled, so we need to disable
-      // any that are no longer required.
-      int sampleQueueCount = sampleQueues.size();
-      for (int i = 0; i < sampleQueueCount; i++) {
-        if (!groupEnabledStates[i]) {
-          sampleQueues.valueAt(i).disable();
-        }
-      }
-    }
-    // Cancel requests if necessary.
-    if (enabledTrackCount == 0) {
-      chunkSource.reset();
-      downstreamTrackFormat = null;
-      mediaChunks.clear();
-      if (loader.isLoading()) {
-        loader.cancelLoading();
-      }
-    }
-    return selectedNewTracks;
-  }
-
-  public void seekTo(long positionUs) {
-    lastSeekPositionUs = positionUs;
-
-    // 跳转到什么地方再开始播放？
-    pendingResetPositionUs = positionUs;
-
-
-    loadingFinished = false;
-    mediaChunks.clear();
-    if (loader.isLoading()) {
-      loader.cancelLoading();
-    } else {
-      int sampleQueueCount = sampleQueues.size();
-      for (int i = 0; i < sampleQueueCount; i++) {
-        sampleQueues.valueAt(i).reset(groupEnabledStates[i]);
-      }
-    }
-  }
-
-  public long getBufferedPositionUs() {
-    if (loadingFinished) {
-      return C.TIME_END_OF_SOURCE;
-    } else if (isPendingReset()) {
-      return pendingResetPositionUs;
-    } else {
-      long bufferedPositionUs = lastSeekPositionUs;
-      HlsMediaChunk lastMediaChunk = mediaChunks.getLast();
-      HlsMediaChunk lastCompletedMediaChunk = lastMediaChunk.isLoadCompleted() ? lastMediaChunk
-              : mediaChunks.size() > 1 ? mediaChunks.get(mediaChunks.size() - 2) : null;
-      if (lastCompletedMediaChunk != null) {
-        bufferedPositionUs = Math.max(bufferedPositionUs, lastCompletedMediaChunk.endTimeUs);
-      }
-      int sampleQueueCount = sampleQueues.size();
-      for (int i = 0; i < sampleQueueCount; i++) {
-        bufferedPositionUs = Math.max(bufferedPositionUs,
-                sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
-      }
-      return bufferedPositionUs;
-    }
-  }
-
-  public void release() {
-    int sampleQueueCount = sampleQueues.size();
-    for (int i = 0; i < sampleQueueCount; i++) {
-      sampleQueues.valueAt(i).disable();
-    }
-    loader.release();
-    handler.removeCallbacksAndMessages(null);
-    released = true;
-  }
-
-  public long getLargestQueuedTimestampUs() {
-    long largestQueuedTimestampUs = Long.MIN_VALUE;
-    for (int i = 0; i < sampleQueues.size(); i++) {
-      largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs,
-              sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
-    }
-    return largestQueuedTimestampUs;
-  }
-
-  public void setIsTimestampMaster(boolean isTimestampMaster) {
-    chunkSource.setIsTimestampMaster(isTimestampMaster);
-  }
-
-  public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
-    chunkSource.onPlaylistBlacklisted(url, blacklistMs);
-  }
-
-  // SampleStream implementation.
-
-  /* package */ boolean isReady(int group) {
-    return loadingFinished || (!isPendingReset() && !sampleQueues.valueAt(group).isEmpty());
-  }
-
-  /* package */ void maybeThrowError() throws IOException {
-    loader.maybeThrowError();
-    chunkSource.maybeThrowError();
-  }
-
-  /* package */ int readData(int group, FormatHolder formatHolder, DecoderInputBuffer buffer) {
-    if (isPendingReset()) {
-      return C.RESULT_NOTHING_READ;
-    }
-
-    while (mediaChunks.size() > 1 && finishedReadingChunk(mediaChunks.getFirst())) {
-      mediaChunks.removeFirst();
-    }
-    HlsMediaChunk currentChunk = mediaChunks.getFirst();
-    Format trackFormat = currentChunk.trackFormat;
-    if (!trackFormat.equals(downstreamTrackFormat)) {
-      eventDispatcher.downstreamFormatChanged(trackType, trackFormat,
-              currentChunk.trackSelectionReason, currentChunk.trackSelectionData,
-              currentChunk.startTimeUs);
-    }
-    downstreamTrackFormat = trackFormat;
-
-    return sampleQueues.valueAt(group).readData(formatHolder, buffer, loadingFinished,
-            lastSeekPositionUs);
-  }
-
-  /* package */
-  void skipToKeyframeBefore(int group, long timeUs) {
-    sampleQueues.valueAt(group).skipToKeyframeBefore(timeUs);
-  }
-
-  private boolean finishedReadingChunk(HlsMediaChunk chunk) {
-    int chunkUid = chunk.uid;
-    for (int i = 0; i < sampleQueues.size(); i++) {
-      if (groupEnabledStates[i] && sampleQueues.valueAt(i).peekSourceId() == chunkUid) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  // SequenceableLoader implementation
-
-  // 是否继续加载?
-  @Override
-  public boolean continueLoading(long positionUs) {
-    if (loadingFinished || loader.isLoading()) {
-      return false;
-    }
-
-    // 继续加载:
-    // 注意这个指定的positionUs
-    chunkSource.getNextChunk(mediaChunks.isEmpty() ? null : mediaChunks.getLast(),
-            pendingResetPositionUs != C.TIME_UNSET ? pendingResetPositionUs : positionUs,
-            nextChunkHolder);
-
-    // 获取下载一个chunk之后?
-    boolean endOfStream = nextChunkHolder.endOfStream;
-    Chunk loadable = nextChunkHolder.chunk;
-    HlsMasterPlaylist.HlsUrl playlistToLoad = nextChunkHolder.playlist;
-    nextChunkHolder.clear();
-
-    if (endOfStream) {
-      loadingFinished = true;
-      return true;
-    }
-
-    // 如果没有可下载的数据，则需要Refresh Hls文件
-    if (loadable == null) {
-      if (playlistToLoad != null) {
-        callback.onPlaylistRefreshRequired(playlistToLoad);
-      }
-      return false;
-    }
-
-    if (isMediaChunk(loadable)) {
-      pendingResetPositionUs = C.TIME_UNSET;
-      HlsMediaChunk mediaChunk = (HlsMediaChunk) loadable;
-      mediaChunk.init(this);
-      mediaChunks.add(mediaChunk);
-    }
-
-    // TODO: 开始下载数据: loadable, 也即是一个HLSChunk, 一个TS文件
-    long elapsedRealtimeMs = loader.startLoading(loadable, this, minLoadableRetryCount);
-    // 接下来关注: #onLoadCompleted
-
-    // 通知开始下载
-    eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-            loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-            loadable.endTimeUs, elapsedRealtimeMs);
-    return true;
-  }
-
-  @Override
-  public long getNextLoadPositionUs() {
-    if (isPendingReset()) {
-      return pendingResetPositionUs;
-    } else {
-      return loadingFinished ? C.TIME_END_OF_SOURCE : mediaChunks.getLast().endTimeUs;
-    }
-  }
-
-  // Loader.Callback implementation.
-
-  @Override
-  public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs) {
-
-    // ChunkSource下载完毕
-    // 主要是做一些解密之类的工作，默认情况下可以跳过(主要是为了学习)
-    chunkSource.onChunkLoadCompleted(loadable);
-
-
-    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-            loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-            loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
-
-    // 是否继续下载呢?
-    if (!prepared) {
-      continueLoading(lastSeekPositionUs);
-    } else {
-      callback.onContinueLoadingRequested(this);
-    }
-  }
-
-  @Override
-  public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs,
-                             boolean released) {
-    eventDispatcher.loadCanceled(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-            loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-            loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
-
-    // 下载取消
-    if (!released) {
-      int sampleQueueCount = sampleQueues.size();
-      for (int i = 0; i < sampleQueueCount; i++) {
-        sampleQueues.valueAt(i).reset(groupEnabledStates[i]);
-      }
-      callback.onContinueLoadingRequested(this);
-    }
-  }
-
-  @Override
-  public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs,
-                         IOException error) {
-    long bytesLoaded = loadable.bytesLoaded();
-    boolean isMediaChunk = isMediaChunk(loadable);
-    boolean cancelable = !isMediaChunk || bytesLoaded == 0;
-    boolean canceled = false;
-    if (chunkSource.onChunkLoadError(loadable, cancelable, error)) {
-      if (isMediaChunk) {
-        HlsMediaChunk removed = mediaChunks.removeLast();
-        Assertions.checkState(removed == loadable);
-        if (mediaChunks.isEmpty()) {
-          pendingResetPositionUs = lastSeekPositionUs;
-        }
-      }
-      canceled = true;
-    }
-    eventDispatcher.loadError(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
-            loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
-            loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded(), error,
-            canceled);
-    if (canceled) {
-      if (!prepared) {
-        continueLoading(lastSeekPositionUs);
-      } else {
-        callback.onContinueLoadingRequested(this);
-      }
-      return Loader.DONT_RETRY;
-    } else {
-      return Loader.RETRY;
-    }
-  }
-
-  // Called by the consuming thread, but only when there is no loading thread.
-
-  /**
-   * Initializes the wrapper for loading a chunk.
-   *
-   * @param chunkUid       The chunk's uid.
-   * @param shouldSpliceIn Whether the samples parsed from the chunk should be spliced into any
-   *                       samples already queued to the wrapper.
-   */
-  public void init(int chunkUid, boolean shouldSpliceIn) {
-    upstreamChunkUid = chunkUid;
-    for (int i = 0; i < sampleQueues.size(); i++) {
-      sampleQueues.valueAt(i).sourceId(chunkUid);
-    }
-    if (shouldSpliceIn) {
-      for (int i = 0; i < sampleQueues.size(); i++) {
-        sampleQueues.valueAt(i).splice();
-      }
-    }
-  }
-
-  // ExtractorOutput implementation. Called by the loading thread.
-
-  @Override
-  public DefaultTrackOutput track(int id) {
-    if (sampleQueues.indexOfKey(id) >= 0) {
-      return sampleQueues.get(id);
-    }
-    DefaultTrackOutput trackOutput = new DefaultTrackOutput(allocator);
-    trackOutput.setUpstreamFormatChangeListener(this);
-    trackOutput.sourceId(upstreamChunkUid);
-    sampleQueues.put(id, trackOutput);
-    return trackOutput;
-  }
-
-  @Override
-  public void endTracks() {
-    sampleQueuesBuilt = true;
-    handler.post(maybeFinishPrepareRunnable);
-  }
-
-  @Override
-  public void seekMap(SeekMap seekMap) {
-    // Do nothing.
-  }
-
-  // UpstreamFormatChangedListener implementation. Called by the loading thread.
-
-  @Override
-  public void onUpstreamFormatChanged(Format format) {
-    handler.post(maybeFinishPrepareRunnable);
-  }
-
-  // Internal methods.
-
-  private void maybeFinishPrepare() {
-    if (released || prepared || !sampleQueuesBuilt) {
-      return;
-    }
-    int sampleQueueCount = sampleQueues.size();
-    for (int i = 0; i < sampleQueueCount; i++) {
-      if (sampleQueues.valueAt(i).getUpstreamFormat() == null) {
-        return;
-      }
-    }
-    buildTracks();
-    prepared = true;
-    callback.onPrepared();
-  }
-
-  /**
-   * Builds tracks that are exposed by this {@link HlsSampleStreamWrapper} instance, as well as
-   * internal data-structures required for operation.
-   * <p>
-   * Tracks in HLS are complicated. A HLS master playlist contains a number of "variants". Each
-   * variant stream typically contains muxed video, audio and (possibly) additional audio, metadata
-   * and caption tracks. We wish to allow the user to select between an adaptive track that spans
-   * all variants, as well as each individual variant. If multiple audio tracks are present within
-   * each variant then we wish to allow the user to select between those also.
-   * <p>
-   * To do this, tracks are constructed as follows. The {@link HlsChunkSource} exposes (N+1) tracks,
-   * where N is the number of variants defined in the HLS master playlist. These consist of one
-   * adaptive track defined to span all variants and a track for each individual variant. The
-   * adaptive track is initially selected. The extractor is then prepared to discover the tracks
-   * inside of each variant stream. The two sets of tracks are then combined by this method to
-   * create a third set, which is the set exposed by this {@link HlsSampleStreamWrapper}:
-   * <ul>
-   * <li>The extractor tracks are inspected to infer a "primary" track type. If a video track is
-   * present then it is always the primary type. If not, audio is the primary type if present.
-   * Else text is the primary type if present. Else there is no primary type.</li>
-   * <li>If there is exactly one extractor track of the primary type, it's expanded into (N+1)
-   * exposed tracks, all of which correspond to the primary extractor track and each of which
-   * corresponds to a different chunk source track. Selecting one of these tracks has the effect
-   * of switching the selected track on the chunk source.</li>
-   * <li>All other extractor tracks are exposed directly. Selecting one of these tracks has the
-   * effect of selecting an extractor track, leaving the selected track on the chunk source
-   * unchanged.</li>
-   * </ul>
-   */
-  private void buildTracks() {
-    // Iterate through the extractor tracks to discover the "primary" track type, and the index
-    // of the single track of this type.
-    int primaryExtractorTrackType = PRIMARY_TYPE_NONE;
-    int primaryExtractorTrackIndex = C.INDEX_UNSET;
-    int extractorTrackCount = sampleQueues.size();
-    for (int i = 0; i < extractorTrackCount; i++) {
-      String sampleMimeType = sampleQueues.valueAt(i).getUpstreamFormat().sampleMimeType;
-      int trackType;
-      if (MimeTypes.isVideo(sampleMimeType)) {
-        trackType = PRIMARY_TYPE_VIDEO;
-      } else if (MimeTypes.isAudio(sampleMimeType)) {
-        trackType = PRIMARY_TYPE_AUDIO;
-      } else if (MimeTypes.isText(sampleMimeType)) {
-        trackType = PRIMARY_TYPE_TEXT;
-      } else {
-        trackType = PRIMARY_TYPE_NONE;
-      }
-      if (trackType > primaryExtractorTrackType) {
-        primaryExtractorTrackType = trackType;
-        primaryExtractorTrackIndex = i;
-      } else if (trackType == primaryExtractorTrackType
-              && primaryExtractorTrackIndex != C.INDEX_UNSET) {
-        // We have multiple tracks of the primary type. We only want an index if there only exists a
-        // single track of the primary type, so unset the index again.
-        primaryExtractorTrackIndex = C.INDEX_UNSET;
-      }
-    }
-
-    TrackGroup chunkSourceTrackGroup = chunkSource.getTrackGroup();
-    int chunkSourceTrackCount = chunkSourceTrackGroup.length;
-
-    // Instantiate the necessary internal data-structures.
-    primaryTrackGroupIndex = C.INDEX_UNSET;
-    groupEnabledStates = new boolean[extractorTrackCount];
-
-    // Construct the set of exposed track groups.
-    TrackGroup[] trackGroups = new TrackGroup[extractorTrackCount];
-    for (int i = 0; i < extractorTrackCount; i++) {
-      Format sampleFormat = sampleQueues.valueAt(i).getUpstreamFormat();
-      if (i == primaryExtractorTrackIndex) {
-        Format[] formats = new Format[chunkSourceTrackCount];
-        for (int j = 0; j < chunkSourceTrackCount; j++) {
-          formats[j] = deriveFormat(chunkSourceTrackGroup.getFormat(j), sampleFormat);
-        }
-        trackGroups[i] = new TrackGroup(formats);
-        primaryTrackGroupIndex = i;
-      } else {
-        Format trackFormat = null;
-        if (primaryExtractorTrackType == PRIMARY_TYPE_VIDEO) {
-          if (MimeTypes.isAudio(sampleFormat.sampleMimeType)) {
-            trackFormat = muxedAudioFormat;
-          } else if (MimeTypes.APPLICATION_CEA608.equals(sampleFormat.sampleMimeType)) {
-            trackFormat = muxedCaptionFormat;
-          }
-        }
-        trackGroups[i] = new TrackGroup(deriveFormat(trackFormat, sampleFormat));
-      }
-    }
-    this.trackGroups = new TrackGroupArray(trackGroups);
-  }
-
-  /**
-   * Enables or disables a specified track group.
-   *
-   * @param group        The index of the track group.
-   * @param enabledState True if the group is being enabled, or false if it's being disabled.
-   */
-  private void setTrackGroupEnabledState(int group, boolean enabledState) {
-    Assertions.checkState(groupEnabledStates[group] != enabledState);
-    groupEnabledStates[group] = enabledState;
-    enabledTrackCount = enabledTrackCount + (enabledState ? 1 : -1);
-  }
-
-  /**
-   * Derives a track format corresponding to a given container format, by combining it with sample
-   * level information obtained from the samples.
-   *
-   * @param containerFormat The container format for which the track format should be derived.
-   * @param sampleFormat    A sample format from which to obtain sample level information.
-   * @return The derived track format.
-   */
-  private static Format deriveFormat(Format containerFormat, Format sampleFormat) {
-    if (containerFormat == null) {
-      return sampleFormat;
-    }
-    String codecs = null;
-    int sampleTrackType = MimeTypes.getTrackType(sampleFormat.sampleMimeType);
-    if (sampleTrackType == C.TRACK_TYPE_AUDIO) {
-      codecs = getAudioCodecs(containerFormat.codecs);
-    } else if (sampleTrackType == C.TRACK_TYPE_VIDEO) {
-      codecs = getVideoCodecs(containerFormat.codecs);
-    }
-    return sampleFormat.copyWithContainerInfo(containerFormat.id, codecs, containerFormat.bitrate,
-            containerFormat.width, containerFormat.height, containerFormat.selectionFlags,
-            containerFormat.language);
-  }
-
-  private boolean isMediaChunk(Chunk chunk) {
-    return chunk instanceof HlsMediaChunk;
-  }
-
-  private boolean isPendingReset() {
-    return pendingResetPositionUs != C.TIME_UNSET;
-  }
-
-  private static String getAudioCodecs(String codecs) {
-    return getCodecsOfType(codecs, C.TRACK_TYPE_AUDIO);
-  }
-
-  private static String getVideoCodecs(String codecs) {
-    return getCodecsOfType(codecs, C.TRACK_TYPE_VIDEO);
-  }
-
-  private static String getCodecsOfType(String codecs, int trackType) {
-    if (TextUtils.isEmpty(codecs)) {
-      return null;
-    }
-    String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
-    StringBuilder builder = new StringBuilder();
-    for (String codec : codecArray) {
-      if (trackType == MimeTypes.getTrackTypeOfCodec(codec)) {
-        if (builder.length() > 0) {
-          builder.append(",");
-        }
-        builder.append(codec);
-      }
-    }
-    return builder.length() > 0 ? builder.toString() : null;
-  }
+    }
+
+    public void maybeThrowPrepareError() throws IOException {
+        maybeThrowError();
+    }
+
+    public TrackGroupArray getTrackGroups() {
+        return trackGroups;
+    }
+
+    public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+                                SampleStream[] streams, boolean[] streamResetFlags, boolean isFirstTrackSelection) {
+        Assertions.checkState(prepared);
+        // Disable old tracks.
+        for (int i = 0; i < selections.length; i++) {
+            if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
+                int group = ((HlsSampleStream) streams[i]).group;
+                setTrackGroupEnabledState(group, false);
+                sampleQueues.valueAt(group).disable();
+                streams[i] = null;
+            }
+        }
+        // Enable new tracks.
+        boolean selectedNewTracks = false;
+        for (int i = 0; i < selections.length; i++) {
+            if (streams[i] == null && selections[i] != null) {
+                TrackSelection selection = selections[i];
+                int group = trackGroups.indexOf(selection.getTrackGroup());
+                setTrackGroupEnabledState(group, true);
+                if (group == primaryTrackGroupIndex) {
+                    chunkSource.selectTracks(selection);
+                }
+                streams[i] = new HlsSampleStream(this, group);
+                streamResetFlags[i] = true;
+                selectedNewTracks = true;
+            }
+        }
+        if (isFirstTrackSelection) {
+            // At the time of the first track selection all queues will be enabled, so we need to disable
+            // any that are no longer required.
+            int sampleQueueCount = sampleQueues.size();
+            for (int i = 0; i < sampleQueueCount; i++) {
+                if (!groupEnabledStates[i]) {
+                    sampleQueues.valueAt(i).disable();
+                }
+            }
+        }
+        // Cancel requests if necessary.
+        if (enabledTrackCount == 0) {
+            chunkSource.reset();
+            downstreamTrackFormat = null;
+            mediaChunks.clear();
+            if (loader.isLoading()) {
+                loader.cancelLoading();
+            }
+        }
+        return selectedNewTracks;
+    }
+
+    public void seekTo(long positionUs) {
+        lastSeekPositionUs = positionUs;
+
+        // 跳转到什么地方再开始播放？
+        pendingResetPositionUs = positionUs;
+
+
+        loadingFinished = false;
+        mediaChunks.clear();
+        if (loader.isLoading()) {
+            loader.cancelLoading();
+        } else {
+            int sampleQueueCount = sampleQueues.size();
+            for (int i = 0; i < sampleQueueCount; i++) {
+                sampleQueues.valueAt(i).reset(groupEnabledStates[i]);
+            }
+        }
+    }
+
+    public long getBufferedPositionUs() {
+        if (loadingFinished) {
+            return C.TIME_END_OF_SOURCE;
+        } else if (isPendingReset()) {
+            return pendingResetPositionUs;
+        } else {
+            long bufferedPositionUs = lastSeekPositionUs;
+            HlsMediaChunk lastMediaChunk = mediaChunks.getLast();
+            HlsMediaChunk lastCompletedMediaChunk = lastMediaChunk.isLoadCompleted() ? lastMediaChunk
+                    : mediaChunks.size() > 1 ? mediaChunks.get(mediaChunks.size() - 2) : null;
+            if (lastCompletedMediaChunk != null) {
+                bufferedPositionUs = Math.max(bufferedPositionUs, lastCompletedMediaChunk.endTimeUs);
+            }
+            int sampleQueueCount = sampleQueues.size();
+            for (int i = 0; i < sampleQueueCount; i++) {
+                bufferedPositionUs = Math.max(bufferedPositionUs,
+                        sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
+            }
+            return bufferedPositionUs;
+        }
+    }
+
+    public void release() {
+        int sampleQueueCount = sampleQueues.size();
+        for (int i = 0; i < sampleQueueCount; i++) {
+            sampleQueues.valueAt(i).disable();
+        }
+        loader.release();
+        handler.removeCallbacksAndMessages(null);
+        released = true;
+    }
+
+    public long getLargestQueuedTimestampUs() {
+        long largestQueuedTimestampUs = Long.MIN_VALUE;
+        for (int i = 0; i < sampleQueues.size(); i++) {
+            largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs,
+                    sampleQueues.valueAt(i).getLargestQueuedTimestampUs());
+        }
+        return largestQueuedTimestampUs;
+    }
+
+    public void setIsTimestampMaster(boolean isTimestampMaster) {
+        chunkSource.setIsTimestampMaster(isTimestampMaster);
+    }
+
+    public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
+        chunkSource.onPlaylistBlacklisted(url, blacklistMs);
+    }
+
+    // SampleStream implementation.
+
+    /* package */ boolean isReady(int group) {
+        return loadingFinished || (!isPendingReset() && !sampleQueues.valueAt(group).isEmpty());
+    }
+
+    /* package */ void maybeThrowError() throws IOException {
+        loader.maybeThrowError();
+        chunkSource.maybeThrowError();
+    }
+
+    /* package */ int readData(int group, FormatHolder formatHolder, DecoderInputBuffer buffer) {
+        if (isPendingReset()) {
+            return C.RESULT_NOTHING_READ;
+        }
+
+        while (mediaChunks.size() > 1 && finishedReadingChunk(mediaChunks.getFirst())) {
+            mediaChunks.removeFirst();
+        }
+        HlsMediaChunk currentChunk = mediaChunks.getFirst();
+        Format trackFormat = currentChunk.trackFormat;
+        if (!trackFormat.equals(downstreamTrackFormat)) {
+            eventDispatcher.downstreamFormatChanged(trackType, trackFormat,
+                    currentChunk.trackSelectionReason, currentChunk.trackSelectionData,
+                    currentChunk.startTimeUs);
+        }
+        downstreamTrackFormat = trackFormat;
+
+        return sampleQueues.valueAt(group).readData(formatHolder, buffer, loadingFinished,
+                lastSeekPositionUs);
+    }
+
+    /* package */
+    // KeyFrame定位
+    void skipToKeyframeBefore(int group, long timeUs) {
+        sampleQueues.valueAt(group).skipToKeyframeBefore(timeUs);
+    }
+
+    private boolean finishedReadingChunk(HlsMediaChunk chunk) {
+        int chunkUid = chunk.uid;
+        for (int i = 0; i < sampleQueues.size(); i++) {
+            if (groupEnabledStates[i] && sampleQueues.valueAt(i).peekSourceId() == chunkUid) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    // SequenceableLoader implementation
+
+    // 是否继续加载?
+    @Override
+    public boolean continueLoading(long positionUs) {
+        if (loadingFinished || loader.isLoading()) {
+            return false;
+        }
+
+        // 继续加载:
+        // 注意这个指定的positionUs
+        chunkSource.getNextChunk(mediaChunks.isEmpty() ? null : mediaChunks.getLast(),
+                pendingResetPositionUs != C.TIME_UNSET ? pendingResetPositionUs : positionUs,
+                nextChunkHolder);
+
+        // 获取下载一个chunk之后?
+        boolean endOfStream = nextChunkHolder.endOfStream;
+        Chunk loadable = nextChunkHolder.chunk;
+        HlsMasterPlaylist.HlsUrl playlistToLoad = nextChunkHolder.playlist;
+        nextChunkHolder.clear();
+
+        if (endOfStream) {
+            loadingFinished = true;
+            return true;
+        }
+
+        // 如果没有可下载的数据，则需要Refresh Hls文件
+        if (loadable == null) {
+            if (playlistToLoad != null) {
+                callback.onPlaylistRefreshRequired(playlistToLoad);
+            }
+            return false;
+        }
+
+        if (isMediaChunk(loadable)) {
+            pendingResetPositionUs = C.TIME_UNSET;
+            HlsMediaChunk mediaChunk = (HlsMediaChunk) loadable;
+            mediaChunk.init(this);
+            mediaChunks.add(mediaChunk);
+        }
+
+        // TODO: 开始下载数据: loadable, 也即是一个HLSChunk, 一个TS文件
+        long elapsedRealtimeMs = loader.startLoading(loadable, this, minLoadableRetryCount);
+        // 接下来关注: #onLoadCompleted
+
+        // 通知开始下载
+        eventDispatcher.loadStarted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
+                loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
+                loadable.endTimeUs, elapsedRealtimeMs);
+        return true;
+    }
+
+    @Override
+    public long getNextLoadPositionUs() {
+        if (isPendingReset()) {
+            return pendingResetPositionUs;
+        } else {
+            return loadingFinished ? C.TIME_END_OF_SOURCE : mediaChunks.getLast().endTimeUs;
+        }
+    }
+
+    // Loader.Callback implementation.
+
+    @Override
+    public void onLoadCompleted(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs) {
+
+        // ChunkSource下载完毕
+        // 主要是做一些解密之类的工作，默认情况下可以跳过(主要是为了学习)
+        chunkSource.onChunkLoadCompleted(loadable);
+
+
+        eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
+                loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
+                loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+
+        // 是否继续下载呢?
+        if (!prepared) {
+            continueLoading(lastSeekPositionUs);
+        } else {
+            callback.onContinueLoadingRequested(this);
+        }
+    }
+
+    @Override
+    public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs,
+                               boolean released) {
+        eventDispatcher.loadCanceled(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
+                loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
+                loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
+
+        // 下载取消
+        if (!released) {
+            int sampleQueueCount = sampleQueues.size();
+            for (int i = 0; i < sampleQueueCount; i++) {
+                sampleQueues.valueAt(i).reset(groupEnabledStates[i]);
+            }
+            callback.onContinueLoadingRequested(this);
+        }
+    }
+
+    @Override
+    public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDurationMs,
+                           IOException error) {
+        long bytesLoaded = loadable.bytesLoaded();
+        boolean isMediaChunk = isMediaChunk(loadable);
+        boolean cancelable = !isMediaChunk || bytesLoaded == 0;
+        boolean canceled = false;
+        if (chunkSource.onChunkLoadError(loadable, cancelable, error)) {
+            if (isMediaChunk) {
+                HlsMediaChunk removed = mediaChunks.removeLast();
+                Assertions.checkState(removed == loadable);
+                if (mediaChunks.isEmpty()) {
+                    pendingResetPositionUs = lastSeekPositionUs;
+                }
+            }
+            canceled = true;
+        }
+        eventDispatcher.loadError(loadable.dataSpec, loadable.type, trackType, loadable.trackFormat,
+                loadable.trackSelectionReason, loadable.trackSelectionData, loadable.startTimeUs,
+                loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded(), error,
+                canceled);
+        if (canceled) {
+            if (!prepared) {
+                continueLoading(lastSeekPositionUs);
+            } else {
+                callback.onContinueLoadingRequested(this);
+            }
+            return Loader.DONT_RETRY;
+        } else {
+            return Loader.RETRY;
+        }
+    }
+
+    // Called by the consuming thread, but only when there is no loading thread.
+
+    /**
+     * Initializes the wrapper for loading a chunk.
+     *
+     * @param chunkUid       The chunk's uid.
+     * @param shouldSpliceIn Whether the samples parsed from the chunk should be spliced into any
+     *                       samples already queued to the wrapper.
+     */
+    public void init(int chunkUid, boolean shouldSpliceIn) {
+        upstreamChunkUid = chunkUid;
+        for (int i = 0; i < sampleQueues.size(); i++) {
+            sampleQueues.valueAt(i).sourceId(chunkUid);
+        }
+        if (shouldSpliceIn) {
+            for (int i = 0; i < sampleQueues.size(); i++) {
+                sampleQueues.valueAt(i).splice();
+            }
+        }
+    }
+
+    // ExtractorOutput implementation. Called by the loading thread.
+
+    @Override
+    public DefaultTrackOutput track(int id) {
+        if (sampleQueues.indexOfKey(id) >= 0) {
+            return sampleQueues.get(id);
+        }
+        DefaultTrackOutput trackOutput = new DefaultTrackOutput(allocator);
+        trackOutput.setUpstreamFormatChangeListener(this);
+        trackOutput.sourceId(upstreamChunkUid);
+        sampleQueues.put(id, trackOutput);
+        return trackOutput;
+    }
+
+    @Override
+    public void endTracks() {
+        sampleQueuesBuilt = true;
+        handler.post(maybeFinishPrepareRunnable);
+    }
+
+    @Override
+    public void seekMap(SeekMap seekMap) {
+        // Do nothing.
+    }
+
+    // UpstreamFormatChangedListener implementation. Called by the loading thread.
+
+    @Override
+    public void onUpstreamFormatChanged(Format format) {
+        handler.post(maybeFinishPrepareRunnable);
+    }
+
+    // Internal methods.
+
+    private void maybeFinishPrepare() {
+        if (released || prepared || !sampleQueuesBuilt) {
+            return;
+        }
+        int sampleQueueCount = sampleQueues.size();
+        for (int i = 0; i < sampleQueueCount; i++) {
+            if (sampleQueues.valueAt(i).getUpstreamFormat() == null) {
+                return;
+            }
+        }
+        buildTracks();
+        prepared = true;
+        callback.onPrepared();
+    }
+
+    /**
+     * Builds tracks that are exposed by this {@link HlsSampleStreamWrapper} instance, as well as
+     * internal data-structures required for operation.
+     * <p>
+     * Tracks in HLS are complicated. A HLS master playlist contains a number of "variants". Each
+     * variant stream typically contains muxed video, audio and (possibly) additional audio, metadata
+     * and caption tracks. We wish to allow the user to select between an adaptive track that spans
+     * all variants, as well as each individual variant. If multiple audio tracks are present within
+     * each variant then we wish to allow the user to select between those also.
+     * <p>
+     * To do this, tracks are constructed as follows. The {@link HlsChunkSource} exposes (N+1) tracks,
+     * where N is the number of variants defined in the HLS master playlist. These consist of one
+     * adaptive track defined to span all variants and a track for each individual variant. The
+     * adaptive track is initially selected. The extractor is then prepared to discover the tracks
+     * inside of each variant stream. The two sets of tracks are then combined by this method to
+     * create a third set, which is the set exposed by this {@link HlsSampleStreamWrapper}:
+     * <ul>
+     * <li>The extractor tracks are inspected to infer a "primary" track type. If a video track is
+     * present then it is always the primary type. If not, audio is the primary type if present.
+     * Else text is the primary type if present. Else there is no primary type.</li>
+     * <li>If there is exactly one extractor track of the primary type, it's expanded into (N+1)
+     * exposed tracks, all of which correspond to the primary extractor track and each of which
+     * corresponds to a different chunk source track. Selecting one of these tracks has the effect
+     * of switching the selected track on the chunk source.</li>
+     * <li>All other extractor tracks are exposed directly. Selecting one of these tracks has the
+     * effect of selecting an extractor track, leaving the selected track on the chunk source
+     * unchanged.</li>
+     * </ul>
+     */
+    private void buildTracks() {
+        // Iterate through the extractor tracks to discover the "primary" track type, and the index
+        // of the single track of this type.
+        int primaryExtractorTrackType = PRIMARY_TYPE_NONE;
+        int primaryExtractorTrackIndex = C.INDEX_UNSET;
+        int extractorTrackCount = sampleQueues.size();
+        for (int i = 0; i < extractorTrackCount; i++) {
+            String sampleMimeType = sampleQueues.valueAt(i).getUpstreamFormat().sampleMimeType;
+            int trackType;
+            if (MimeTypes.isVideo(sampleMimeType)) {
+                trackType = PRIMARY_TYPE_VIDEO;
+            } else if (MimeTypes.isAudio(sampleMimeType)) {
+                trackType = PRIMARY_TYPE_AUDIO;
+            } else if (MimeTypes.isText(sampleMimeType)) {
+                trackType = PRIMARY_TYPE_TEXT;
+            } else {
+                trackType = PRIMARY_TYPE_NONE;
+            }
+            if (trackType > primaryExtractorTrackType) {
+                primaryExtractorTrackType = trackType;
+                primaryExtractorTrackIndex = i;
+            } else if (trackType == primaryExtractorTrackType
+                    && primaryExtractorTrackIndex != C.INDEX_UNSET) {
+                // We have multiple tracks of the primary type. We only want an index if there only exists a
+                // single track of the primary type, so unset the index again.
+                primaryExtractorTrackIndex = C.INDEX_UNSET;
+            }
+        }
+
+        TrackGroup chunkSourceTrackGroup = chunkSource.getTrackGroup();
+        int chunkSourceTrackCount = chunkSourceTrackGroup.length;
+
+        // Instantiate the necessary internal data-structures.
+        primaryTrackGroupIndex = C.INDEX_UNSET;
+        groupEnabledStates = new boolean[extractorTrackCount];
+
+        // Construct the set of exposed track groups.
+        TrackGroup[] trackGroups = new TrackGroup[extractorTrackCount];
+        for (int i = 0; i < extractorTrackCount; i++) {
+            Format sampleFormat = sampleQueues.valueAt(i).getUpstreamFormat();
+            if (i == primaryExtractorTrackIndex) {
+                Format[] formats = new Format[chunkSourceTrackCount];
+                for (int j = 0; j < chunkSourceTrackCount; j++) {
+                    formats[j] = deriveFormat(chunkSourceTrackGroup.getFormat(j), sampleFormat);
+                }
+                trackGroups[i] = new TrackGroup(formats);
+                primaryTrackGroupIndex = i;
+            } else {
+                Format trackFormat = null;
+                if (primaryExtractorTrackType == PRIMARY_TYPE_VIDEO) {
+                    if (MimeTypes.isAudio(sampleFormat.sampleMimeType)) {
+                        trackFormat = muxedAudioFormat;
+                    } else if (MimeTypes.APPLICATION_CEA608.equals(sampleFormat.sampleMimeType)) {
+                        trackFormat = muxedCaptionFormat;
+                    }
+                }
+                trackGroups[i] = new TrackGroup(deriveFormat(trackFormat, sampleFormat));
+            }
+        }
+        this.trackGroups = new TrackGroupArray(trackGroups);
+    }
+
+    /**
+     * Enables or disables a specified track group.
+     *
+     * @param group        The index of the track group.
+     * @param enabledState True if the group is being enabled, or false if it's being disabled.
+     */
+    private void setTrackGroupEnabledState(int group, boolean enabledState) {
+        Assertions.checkState(groupEnabledStates[group] != enabledState);
+        groupEnabledStates[group] = enabledState;
+        enabledTrackCount = enabledTrackCount + (enabledState ? 1 : -1);
+    }
+
+    /**
+     * Derives a track format corresponding to a given container format, by combining it with sample
+     * level information obtained from the samples.
+     *
+     * @param containerFormat The container format for which the track format should be derived.
+     * @param sampleFormat    A sample format from which to obtain sample level information.
+     * @return The derived track format.
+     */
+    private static Format deriveFormat(Format containerFormat, Format sampleFormat) {
+        if (containerFormat == null) {
+            return sampleFormat;
+        }
+        String codecs = null;
+        int sampleTrackType = MimeTypes.getTrackType(sampleFormat.sampleMimeType);
+        if (sampleTrackType == C.TRACK_TYPE_AUDIO) {
+            codecs = getAudioCodecs(containerFormat.codecs);
+        } else if (sampleTrackType == C.TRACK_TYPE_VIDEO) {
+            codecs = getVideoCodecs(containerFormat.codecs);
+        }
+        return sampleFormat.copyWithContainerInfo(containerFormat.id, codecs, containerFormat.bitrate,
+                containerFormat.width, containerFormat.height, containerFormat.selectionFlags,
+                containerFormat.language);
+    }
+
+    private boolean isMediaChunk(Chunk chunk) {
+        return chunk instanceof HlsMediaChunk;
+    }
+
+    private boolean isPendingReset() {
+        return pendingResetPositionUs != C.TIME_UNSET;
+    }
+
+    private static String getAudioCodecs(String codecs) {
+        return getCodecsOfType(codecs, C.TRACK_TYPE_AUDIO);
+    }
+
+    private static String getVideoCodecs(String codecs) {
+        return getCodecsOfType(codecs, C.TRACK_TYPE_VIDEO);
+    }
+
+    private static String getCodecsOfType(String codecs, int trackType) {
+        if (TextUtils.isEmpty(codecs)) {
+            return null;
+        }
+        String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
+        StringBuilder builder = new StringBuilder();
+        for (String codec : codecArray) {
+            if (trackType == MimeTypes.getTrackTypeOfCodec(codec)) {
+                if (builder.length() > 0) {
+                    builder.append(",");
+                }
+                builder.append(codec);
+            }
+        }
+        return builder.length() > 0 ? builder.toString() : null;
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
index 624e5fa4f8..55dcc66ce7 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/TimestampAdjusterProvider.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.util.SparseArray;
+
 import com.google.android.exoplayer2.extractor.TimestampAdjuster;
 
 /**
@@ -23,36 +24,36 @@
  */
 public final class TimestampAdjusterProvider {
 
-  // TODO: Prevent this array from growing indefinitely large by removing adjusters that are no
-  // longer required.
-  private final SparseArray<TimestampAdjuster> timestampAdjusters;
-
-  public TimestampAdjusterProvider() {
-    timestampAdjusters = new SparseArray<>();
-  }
-
-  /**
-   * Returns a {@link TimestampAdjuster} suitable for adjusting the pts timestamps contained in
-   * a chunk with a given discontinuity sequence.
-   *
-   * @param discontinuitySequence The chunk's discontinuity sequence.
-   * @param startTimeUs The chunk's start time.
-   * @return A {@link TimestampAdjuster}.
-   */
-  public TimestampAdjuster getAdjuster(int discontinuitySequence, long startTimeUs) {
-    TimestampAdjuster adjuster = timestampAdjusters.get(discontinuitySequence);
-    if (adjuster == null) {
-      adjuster = new TimestampAdjuster(startTimeUs);
-      timestampAdjusters.put(discontinuitySequence, adjuster);
+    // TODO: Prevent this array from growing indefinitely large by removing adjusters that are no
+    // longer required.
+    private final SparseArray<TimestampAdjuster> timestampAdjusters;
+
+    public TimestampAdjusterProvider() {
+        timestampAdjusters = new SparseArray<>();
+    }
+
+    /**
+     * Returns a {@link TimestampAdjuster} suitable for adjusting the pts timestamps contained in
+     * a chunk with a given discontinuity sequence.
+     *
+     * @param discontinuitySequence The chunk's discontinuity sequence.
+     * @param startTimeUs           The chunk's start time.
+     * @return A {@link TimestampAdjuster}.
+     */
+    public TimestampAdjuster getAdjuster(int discontinuitySequence, long startTimeUs) {
+        TimestampAdjuster adjuster = timestampAdjusters.get(discontinuitySequence);
+        if (adjuster == null) {
+            adjuster = new TimestampAdjuster(startTimeUs);
+            timestampAdjusters.put(discontinuitySequence, adjuster);
+        }
+        return adjuster;
+    }
+
+    /**
+     * Resets the provider.
+     */
+    public void reset() {
+        timestampAdjusters.clear();
     }
-    return adjuster;
-  }
-
-  /**
-   * Resets the provider.
-   */
-  public void reset() {
-    timestampAdjusters.clear();
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
index 1cb7906fd5..7529816e24 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java
@@ -26,65 +26,65 @@
  */
 public final class HlsMasterPlaylist extends HlsPlaylist {
 
-  /**
-   * Represents a url in an HLS master playlist.
-   */
-  public static final class HlsUrl {
-
-    public final String name;
-    public final String url;
-    public final Format format;
-    public final Format videoFormat;
-    public final Format audioFormat;
-    public final Format[] textFormats;
-
-    public static HlsUrl createMediaPlaylistHlsUrl(String baseUri) {
-      Format format = Format.createContainerFormat("0", MimeTypes.APPLICATION_M3U8, null, null, Format.NO_VALUE);
-      return new HlsUrl(null, baseUri, format, null, null, null);
-    }
-
-    public HlsUrl(String name, String url, Format format, Format videoFormat, Format audioFormat,
-        Format[] textFormats) {
-
-      this.name = name;
-      this.url = url;
+    /**
+     * Represents a url in an HLS master playlist.
+     */
+    public static final class HlsUrl {
+
+        public final String name;
+        public final String url;
+        public final Format format;
+        public final Format videoFormat;
+        public final Format audioFormat;
+        public final Format[] textFormats;
+
+        public static HlsUrl createMediaPlaylistHlsUrl(String baseUri) {
+            Format format = Format.createContainerFormat("0", MimeTypes.APPLICATION_M3U8, null, null, Format.NO_VALUE);
+            return new HlsUrl(null, baseUri, format, null, null, null);
+        }
+
+        public HlsUrl(String name, String url, Format format, Format videoFormat, Format audioFormat,
+                      Format[] textFormats) {
+
+            this.name = name;
+            this.url = url;
+
+            this.format = format;
+            this.videoFormat = videoFormat;
+            this.audioFormat = audioFormat;
+            this.textFormats = textFormats;
+        }
 
-      this.format = format;
-      this.videoFormat = videoFormat;
-      this.audioFormat = audioFormat;
-      this.textFormats = textFormats;
     }
 
-  }
+    public final List<HlsUrl> variants;
+    public final List<HlsUrl> audios;
+    public final List<HlsUrl> subtitles;
 
-  public final List<HlsUrl> variants;
-  public final List<HlsUrl> audios;
-  public final List<HlsUrl> subtitles;
+    public final Format muxedAudioFormat;
+    public final Format muxedCaptionFormat;
 
-  public final Format muxedAudioFormat;
-  public final Format muxedCaptionFormat;
+    public HlsMasterPlaylist(String baseUri, List<HlsUrl> variants, List<HlsUrl> audios,
+                             List<HlsUrl> subtitles, Format muxedAudioFormat, Format muxedCaptionFormat) {
 
-  public HlsMasterPlaylist(String baseUri, List<HlsUrl> variants, List<HlsUrl> audios,
-      List<HlsUrl> subtitles, Format muxedAudioFormat, Format muxedCaptionFormat) {
+        super(baseUri, HlsPlaylist.TYPE_MASTER);
 
-    super(baseUri, HlsPlaylist.TYPE_MASTER);
+        // 例如: 不同分辨率，不同网络清下的的HlsMediaPlaylist的选择
+        this.variants = Collections.unmodifiableList(variants);
 
-    // 例如: 不同分辨率，不同网络清下的的HlsMediaPlaylist的选择
-    this.variants = Collections.unmodifiableList(variants);
+        this.audios = Collections.unmodifiableList(audios);
+        this.subtitles = Collections.unmodifiableList(subtitles);
 
-    this.audios = Collections.unmodifiableList(audios);
-    this.subtitles = Collections.unmodifiableList(subtitles);
-
-    this.muxedAudioFormat = muxedAudioFormat;
-    this.muxedCaptionFormat = muxedCaptionFormat;
-  }
+        this.muxedAudioFormat = muxedAudioFormat;
+        this.muxedCaptionFormat = muxedCaptionFormat;
+    }
 
-  public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUri) {
-    // variantUri --> List<HlsUrl>
-    // 只有一个：variantUri
-    List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUri));
-    List<HlsUrl> emptyList = Collections.emptyList();
-    return new HlsMasterPlaylist(null, variant, emptyList, emptyList, null, null);
-  }
+    public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUri) {
+        // variantUri --> List<HlsUrl>
+        // 只有一个：variantUri
+        List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUri));
+        List<HlsUrl> emptyList = Collections.emptyList();
+        return new HlsMasterPlaylist(null, variant, emptyList, emptyList, null, null);
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index a6e027ecc9..3bf726d4d5 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -16,108 +16,109 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import com.google.android.exoplayer2.C;
+
 import java.util.Collections;
 import java.util.List;
 
 /**
  * Represents an HLS media playlist.
- *
+ * <p>
  * m3u8文件
  */
 public final class HlsMediaPlaylist extends HlsPlaylist {
 
-  /**
-   * Media segment reference.
-   */
-  public static final class Segment implements Comparable<Long> {
+    /**
+     * Media segment reference.
+     */
+    public static final class Segment implements Comparable<Long> {
+
+        public final String url;
+        public final long durationUs;
+        public final int discontinuitySequenceNumber;
+        public final long relativeStartTimeUs;
+        public final boolean isEncrypted;
+        public final String encryptionKeyUri;
+        public final String encryptionIV;
+        public final long byterangeOffset;
+        public final long byterangeLength;
+
+        public Segment(String uri, long byterangeOffset, long byterangeLength) {
+            this(uri, 0, -1, C.TIME_UNSET, false, null, null, byterangeOffset, byterangeLength);
+        }
+
+        public Segment(String uri, long durationUs, int discontinuitySequenceNumber,
+                       long relativeStartTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
+                       long byterangeOffset, long byterangeLength) {
+            this.url = uri;
+            this.durationUs = durationUs;
+            this.discontinuitySequenceNumber = discontinuitySequenceNumber;
+            this.relativeStartTimeUs = relativeStartTimeUs;
+            this.isEncrypted = isEncrypted;
+            this.encryptionKeyUri = encryptionKeyUri;
+            this.encryptionIV = encryptionIV;
+            this.byterangeOffset = byterangeOffset;
+            this.byterangeLength = byterangeLength;
+        }
+
+        @Override
+        public int compareTo(Long relativeStartTimeUs) {
+            return this.relativeStartTimeUs > relativeStartTimeUs
+                    ? 1 : (this.relativeStartTimeUs < relativeStartTimeUs ? -1 : 0);
+        }
 
-    public final String url;
+    }
+
+    public final long startTimeUs;
+    public final int mediaSequence;
+    public final int version;
+    public final long targetDurationUs;
+    public final boolean hasEndTag;
+    public final boolean hasProgramDateTime;
+    public final Segment initializationSegment;
+    public final List<Segment> segments;
     public final long durationUs;
-    public final int discontinuitySequenceNumber;
-    public final long relativeStartTimeUs;
-    public final boolean isEncrypted;
-    public final String encryptionKeyUri;
-    public final String encryptionIV;
-    public final long byterangeOffset;
-    public final long byterangeLength;
-
-    public Segment(String uri, long byterangeOffset, long byterangeLength) {
-      this(uri, 0, -1, C.TIME_UNSET, false, null, null, byterangeOffset, byterangeLength);
+
+    public HlsMediaPlaylist(String baseUri, long startTimeUs, int mediaSequence,
+                            int version, long targetDurationUs, boolean hasEndTag, boolean hasProgramDateTime,
+                            Segment initializationSegment, List<Segment> segments) {
+
+        // HlsMasterPlaylist vs. HlsMediaPlaylist
+        super(baseUri, HlsPlaylist.TYPE_MEDIA);
+
+        this.startTimeUs = startTimeUs; // 开始时间
+        this.mediaSequence = mediaSequence;
+        this.version = version;
+        this.targetDurationUs = targetDurationUs;
+        this.hasEndTag = hasEndTag; // 是否有结束标志
+        this.hasProgramDateTime = hasProgramDateTime;
+        this.initializationSegment = initializationSegment;
+
+        // 片段
+        this.segments = Collections.unmodifiableList(segments);
+
+        // 整个Playlist的持续时间:duration
+        if (!segments.isEmpty()) {
+            Segment last = segments.get(segments.size() - 1);
+            durationUs = last.relativeStartTimeUs + last.durationUs;
+        } else {
+            durationUs = 0;
+        }
     }
 
-    public Segment(String uri, long durationUs, int discontinuitySequenceNumber,
-        long relativeStartTimeUs, boolean isEncrypted, String encryptionKeyUri, String encryptionIV,
-        long byterangeOffset, long byterangeLength) {
-      this.url = uri;
-      this.durationUs = durationUs;
-      this.discontinuitySequenceNumber = discontinuitySequenceNumber;
-      this.relativeStartTimeUs = relativeStartTimeUs;
-      this.isEncrypted = isEncrypted;
-      this.encryptionKeyUri = encryptionKeyUri;
-      this.encryptionIV = encryptionIV;
-      this.byterangeOffset = byterangeOffset;
-      this.byterangeLength = byterangeLength;
+    // 两个Playlist如何比较呢?
+    public boolean isNewerThan(HlsMediaPlaylist other) {
+        return other == null || mediaSequence > other.mediaSequence
+                || (mediaSequence == other.mediaSequence && segments.size() > other.segments.size())
+                || (hasEndTag && !other.hasEndTag);
     }
 
-    @Override
-    public int compareTo(Long relativeStartTimeUs) {
-      return this.relativeStartTimeUs > relativeStartTimeUs
-          ? 1 : (this.relativeStartTimeUs < relativeStartTimeUs ? -1 : 0);
+    public long getEndTimeUs() {
+        return startTimeUs + durationUs;
     }
 
-  }
-
-  public final long startTimeUs;
-  public final int mediaSequence;
-  public final int version;
-  public final long targetDurationUs;
-  public final boolean hasEndTag;
-  public final boolean hasProgramDateTime;
-  public final Segment initializationSegment;
-  public final List<Segment> segments;
-  public final long durationUs;
-
-  public HlsMediaPlaylist(String baseUri, long startTimeUs, int mediaSequence,
-      int version, long targetDurationUs, boolean hasEndTag, boolean hasProgramDateTime,
-      Segment initializationSegment, List<Segment> segments) {
-
-    // HlsMasterPlaylist vs. HlsMediaPlaylist
-    super(baseUri, HlsPlaylist.TYPE_MEDIA);
-
-    this.startTimeUs = startTimeUs; // 开始时间
-    this.mediaSequence = mediaSequence;
-    this.version = version;
-    this.targetDurationUs = targetDurationUs;
-    this.hasEndTag = hasEndTag; // 是否有结束标志
-    this.hasProgramDateTime = hasProgramDateTime;
-    this.initializationSegment = initializationSegment;
-
-    // 片段
-    this.segments = Collections.unmodifiableList(segments);
-
-    // 整个Playlist的持续时间:duration
-    if (!segments.isEmpty()) {
-      Segment last = segments.get(segments.size() - 1);
-      durationUs = last.relativeStartTimeUs + last.durationUs;
-    } else {
-      durationUs = 0;
+    public HlsMediaPlaylist copyWithStartTimeUs(long startTimeUs) {
+        return new HlsMediaPlaylist(baseUri, startTimeUs, mediaSequence, version, targetDurationUs,
+                hasEndTag, hasProgramDateTime, initializationSegment, segments);
     }
-  }
-
-  // 两个Playlist如何比较呢?
-  public boolean isNewerThan(HlsMediaPlaylist other) {
-    return other == null || mediaSequence > other.mediaSequence
-        || (mediaSequence == other.mediaSequence && segments.size() > other.segments.size())
-        || (hasEndTag && !other.hasEndTag);
-  }
-
-  public long getEndTimeUs() {
-    return startTimeUs + durationUs;
-  }
-
-  public HlsMediaPlaylist copyWithStartTimeUs(long startTimeUs) {
-    return new HlsMediaPlaylist(baseUri, startTimeUs, mediaSequence, version, targetDurationUs,
-        hasEndTag, hasProgramDateTime, initializationSegment, segments);
-  }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
index 88618ecb44..c4cc7cc1f2 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylist.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import android.support.annotation.IntDef;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -24,26 +25,26 @@
  */
 public abstract class HlsPlaylist {
 
-  /**
-   * The type of playlist.
-   */
-  @Retention(RetentionPolicy.SOURCE)
-  @IntDef({TYPE_MASTER, TYPE_MEDIA})
-  public @interface Type {}
+    // The type of playlist.
+    // 定义Annotation, 在Coding阶段有效，保证输入的参数必须满足指定的条件
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({TYPE_MASTER, TYPE_MEDIA})
+    public @interface Type {
+    }
 
-  public static final int TYPE_MASTER = 0;
-  public static final int TYPE_MEDIA = 1;
+    public static final int TYPE_MASTER = 0;
+    public static final int TYPE_MEDIA = 1;
 
-  // URL
-  public final String baseUri;
+    // URL
+    public final String baseUri;
 
-  // 类型
-  @Type
-  public final int type;
+    // 类型
+    @Type
+    public final int type;
 
-  protected HlsPlaylist(String baseUri, @Type int type) {
-    this.baseUri = baseUri;
-    this.type = type;
-  }
+    protected HlsPlaylist(String baseUri, @Type int type) {
+        this.baseUri = baseUri;
+        this.type = type;
+    }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index 3c1cb25527..3791891569 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source.hls.playlist;
 
 import android.net.Uri;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
@@ -23,6 +24,7 @@
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
+
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
@@ -40,390 +42,390 @@
  */
 public final class HlsPlaylistParser implements ParsingLoadable.Parser<HlsPlaylist> {
 
-  private static final String TAG_VERSION = "#EXT-X-VERSION";
-  private static final String TAG_STREAM_INF = "#EXT-X-STREAM-INF";
-  private static final String TAG_MEDIA = "#EXT-X-MEDIA";
-  private static final String TAG_DISCONTINUITY = "#EXT-X-DISCONTINUITY";
-  private static final String TAG_DISCONTINUITY_SEQUENCE = "#EXT-X-DISCONTINUITY-SEQUENCE";
-  private static final String TAG_PROGRAM_DATE_TIME = "#EXT-X-PROGRAM-DATE-TIME";
-  private static final String TAG_INIT_SEGMENT = "#EXT-X-MAP";
-  private static final String TAG_MEDIA_DURATION = "#EXTINF";
-  private static final String TAG_MEDIA_SEQUENCE = "#EXT-X-MEDIA-SEQUENCE";
-  private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
-  private static final String TAG_ENDLIST = "#EXT-X-ENDLIST";
-  private static final String TAG_KEY = "#EXT-X-KEY";
-  private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
-
-  private static final String TYPE_AUDIO = "AUDIO";
-  private static final String TYPE_VIDEO = "VIDEO";
-  private static final String TYPE_SUBTITLES = "SUBTITLES";
-  private static final String TYPE_CLOSED_CAPTIONS = "CLOSED-CAPTIONS";
-
-  private static final String METHOD_NONE = "NONE";
-  private static final String METHOD_AES128 = "AES-128";
-
-  private static final String BOOLEAN_TRUE = "YES";
-  private static final String BOOLEAN_FALSE = "NO";
-
-  private static final Pattern REGEX_BANDWIDTH = Pattern.compile("BANDWIDTH=(\\d+)\\b");
-  private static final Pattern REGEX_CODECS = Pattern.compile("CODECS=\"(.+?)\"");
-  private static final Pattern REGEX_RESOLUTION = Pattern.compile("RESOLUTION=(\\d+x\\d+)");
-  private static final Pattern REGEX_TARGET_DURATION = Pattern.compile(TAG_TARGET_DURATION
-      + ":(\\d+)\\b");
-  private static final Pattern REGEX_VERSION = Pattern.compile(TAG_VERSION + ":(\\d+)\\b");
-  private static final Pattern REGEX_MEDIA_SEQUENCE = Pattern.compile(TAG_MEDIA_SEQUENCE
-      + ":(\\d+)\\b");
-  private static final Pattern REGEX_MEDIA_DURATION = Pattern.compile(TAG_MEDIA_DURATION
-      + ":([\\d\\.]+)\\b");
-  private static final Pattern REGEX_BYTERANGE = Pattern.compile(TAG_BYTERANGE
-      + ":(\\d+(?:@\\d+)?)\\b");
-  private static final Pattern REGEX_ATTR_BYTERANGE =
-      Pattern.compile("BYTERANGE=\"(\\d+(?:@\\d+)?)\\b\"");
-  private static final Pattern REGEX_METHOD = Pattern.compile("METHOD=(" + METHOD_NONE + "|"
-      + METHOD_AES128 + ")");
-  private static final Pattern REGEX_URI = Pattern.compile("URI=\"(.+?)\"");
-  private static final Pattern REGEX_IV = Pattern.compile("IV=([^,.*]+)");
-  private static final Pattern REGEX_TYPE = Pattern.compile("TYPE=(" + TYPE_AUDIO + "|" + TYPE_VIDEO
-      + "|" + TYPE_SUBTITLES + "|" + TYPE_CLOSED_CAPTIONS + ")");
-  private static final Pattern REGEX_LANGUAGE = Pattern.compile("LANGUAGE=\"(.+?)\"");
-  private static final Pattern REGEX_NAME = Pattern.compile("NAME=\"(.+?)\"");
-  private static final Pattern REGEX_INSTREAM_ID = Pattern.compile("INSTREAM-ID=\"(.+?)\"");
-  private static final Pattern REGEX_AUTOSELECT = compileBooleanAttrPattern("AUTOSELECT");
-  private static final Pattern REGEX_DEFAULT = compileBooleanAttrPattern("DEFAULT");
-  private static final Pattern REGEX_FORCED = compileBooleanAttrPattern("FORCED");
-
-  @Override
-  public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
-    // InputStream 封装成为: BufferedReader, 注意文件的编码，不过m3u8等文件都是英文
-    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
-
-    Queue<String> extraLines = new LinkedList<>();
-    String line;
-
-    // 这样的一个文件该如何分析呢？
-    //    #EXTM3U
-    //    #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
-    //    hls-360p/hls-360p.m3u8
-    //    #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
-    //    hls-480p/hls-480p.m3u8
-    //    #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
-    //    hls-720p/hls-720p.m3u8
-
-    try {
-      while ((line = reader.readLine()) != null) {
-        // 读取一行数据
-        line = line.trim();
-        if (line.isEmpty()) {
-          // Do nothing.
-        } else if (line.startsWith(TAG_STREAM_INF)) {
-          extraLines.add(line);
-
-          // 一个m3u8文件有两种格式: master & playlist
-          // 通过个别的tag即可对两者进行区分
-          return parseMasterPlaylist(new LineIterator(extraLines, reader), uri.toString());
-        } else if (line.startsWith(TAG_TARGET_DURATION)
-            || line.startsWith(TAG_MEDIA_SEQUENCE)
-            || line.startsWith(TAG_MEDIA_DURATION)
-            || line.startsWith(TAG_KEY)
-            || line.startsWith(TAG_BYTERANGE)
-            || line.equals(TAG_DISCONTINUITY)
-            || line.equals(TAG_DISCONTINUITY_SEQUENCE)
-            || line.equals(TAG_ENDLIST)) {
-          extraLines.add(line);
-          return parseMediaPlaylist(new LineIterator(extraLines, reader), uri.toString());
-        } else {
-          extraLines.add(line);
+    private static final String TAG_VERSION = "#EXT-X-VERSION";
+    private static final String TAG_STREAM_INF = "#EXT-X-STREAM-INF";
+    private static final String TAG_MEDIA = "#EXT-X-MEDIA";
+    private static final String TAG_DISCONTINUITY = "#EXT-X-DISCONTINUITY";
+    private static final String TAG_DISCONTINUITY_SEQUENCE = "#EXT-X-DISCONTINUITY-SEQUENCE";
+    private static final String TAG_PROGRAM_DATE_TIME = "#EXT-X-PROGRAM-DATE-TIME";
+    private static final String TAG_INIT_SEGMENT = "#EXT-X-MAP";
+    private static final String TAG_MEDIA_DURATION = "#EXTINF";
+    private static final String TAG_MEDIA_SEQUENCE = "#EXT-X-MEDIA-SEQUENCE";
+    private static final String TAG_TARGET_DURATION = "#EXT-X-TARGETDURATION";
+    private static final String TAG_ENDLIST = "#EXT-X-ENDLIST";
+    private static final String TAG_KEY = "#EXT-X-KEY";
+    private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
+
+    private static final String TYPE_AUDIO = "AUDIO";
+    private static final String TYPE_VIDEO = "VIDEO";
+    private static final String TYPE_SUBTITLES = "SUBTITLES";
+    private static final String TYPE_CLOSED_CAPTIONS = "CLOSED-CAPTIONS";
+
+    private static final String METHOD_NONE = "NONE";
+    private static final String METHOD_AES128 = "AES-128";
+
+    private static final String BOOLEAN_TRUE = "YES";
+    private static final String BOOLEAN_FALSE = "NO";
+
+    private static final Pattern REGEX_BANDWIDTH = Pattern.compile("BANDWIDTH=(\\d+)\\b");
+    private static final Pattern REGEX_CODECS = Pattern.compile("CODECS=\"(.+?)\"");
+    private static final Pattern REGEX_RESOLUTION = Pattern.compile("RESOLUTION=(\\d+x\\d+)");
+    private static final Pattern REGEX_TARGET_DURATION = Pattern.compile(TAG_TARGET_DURATION
+            + ":(\\d+)\\b");
+    private static final Pattern REGEX_VERSION = Pattern.compile(TAG_VERSION + ":(\\d+)\\b");
+    private static final Pattern REGEX_MEDIA_SEQUENCE = Pattern.compile(TAG_MEDIA_SEQUENCE
+            + ":(\\d+)\\b");
+    private static final Pattern REGEX_MEDIA_DURATION = Pattern.compile(TAG_MEDIA_DURATION
+            + ":([\\d\\.]+)\\b");
+    private static final Pattern REGEX_BYTERANGE = Pattern.compile(TAG_BYTERANGE
+            + ":(\\d+(?:@\\d+)?)\\b");
+    private static final Pattern REGEX_ATTR_BYTERANGE =
+            Pattern.compile("BYTERANGE=\"(\\d+(?:@\\d+)?)\\b\"");
+    private static final Pattern REGEX_METHOD = Pattern.compile("METHOD=(" + METHOD_NONE + "|"
+            + METHOD_AES128 + ")");
+    private static final Pattern REGEX_URI = Pattern.compile("URI=\"(.+?)\"");
+    private static final Pattern REGEX_IV = Pattern.compile("IV=([^,.*]+)");
+    private static final Pattern REGEX_TYPE = Pattern.compile("TYPE=(" + TYPE_AUDIO + "|" + TYPE_VIDEO
+            + "|" + TYPE_SUBTITLES + "|" + TYPE_CLOSED_CAPTIONS + ")");
+    private static final Pattern REGEX_LANGUAGE = Pattern.compile("LANGUAGE=\"(.+?)\"");
+    private static final Pattern REGEX_NAME = Pattern.compile("NAME=\"(.+?)\"");
+    private static final Pattern REGEX_INSTREAM_ID = Pattern.compile("INSTREAM-ID=\"(.+?)\"");
+    private static final Pattern REGEX_AUTOSELECT = compileBooleanAttrPattern("AUTOSELECT");
+    private static final Pattern REGEX_DEFAULT = compileBooleanAttrPattern("DEFAULT");
+    private static final Pattern REGEX_FORCED = compileBooleanAttrPattern("FORCED");
+
+    @Override
+    public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
+        // InputStream 封装成为: BufferedReader, 注意文件的编码，不过m3u8等文件都是英文
+        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
+
+        Queue<String> extraLines = new LinkedList<>();
+        String line;
+
+        // 这样的一个文件该如何分析呢？
+        //    #EXTM3U
+        //    #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
+        //    hls-360p/hls-360p.m3u8
+        //    #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
+        //    hls-480p/hls-480p.m3u8
+        //    #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
+        //    hls-720p/hls-720p.m3u8
+
+        try {
+            while ((line = reader.readLine()) != null) {
+                // 读取一行数据
+                line = line.trim();
+                if (line.isEmpty()) {
+                    // Do nothing.
+                } else if (line.startsWith(TAG_STREAM_INF)) {
+                    extraLines.add(line);
+
+                    // 一个m3u8文件有两种格式: master & playlist
+                    // 通过个别的tag即可对两者进行区分
+                    return parseMasterPlaylist(new LineIterator(extraLines, reader), uri.toString());
+                } else if (line.startsWith(TAG_TARGET_DURATION)
+                        || line.startsWith(TAG_MEDIA_SEQUENCE)
+                        || line.startsWith(TAG_MEDIA_DURATION)
+                        || line.startsWith(TAG_KEY)
+                        || line.startsWith(TAG_BYTERANGE)
+                        || line.equals(TAG_DISCONTINUITY)
+                        || line.equals(TAG_DISCONTINUITY_SEQUENCE)
+                        || line.equals(TAG_ENDLIST)) {
+                    extraLines.add(line);
+                    return parseMediaPlaylist(new LineIterator(extraLines, reader), uri.toString());
+                } else {
+                    extraLines.add(line);
+                }
+            }
+        } finally {
+            reader.close();
         }
-      }
-    } finally {
-      reader.close();
+        throw new ParserException("Failed to parse the playlist, could not identify any tags.");
     }
-    throw new ParserException("Failed to parse the playlist, could not identify any tags.");
-  }
-
-  private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
-      throws IOException {
-    ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>(); // 不同分辨率，不同网络条件下的处理
-    ArrayList<HlsMasterPlaylist.HlsUrl> audios = new ArrayList<>();
-    ArrayList<HlsMasterPlaylist.HlsUrl> subtitles = new ArrayList<>();
-    Format muxedAudioFormat = null;
-    Format muxedCaptionFormat = null;
-
-    String line;
-    while (iterator.hasNext()) {
-      // 一行一行遍历
-      line = iterator.next();
-
-      if (line.startsWith(TAG_MEDIA)) {
-        // #EXT-X-MEDIA
-        // #EXTINF:3.008656,
-        @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
-        String uri = parseOptionalStringAttr(line, REGEX_URI);
-        String name = parseStringAttr(line, REGEX_NAME);
-        String language = parseOptionalStringAttr(line, REGEX_LANGUAGE);
-        Format format;
-        switch (parseStringAttr(line, REGEX_TYPE)) {
-          case TYPE_AUDIO:
-             format = Format.createAudioContainerFormat(name, MimeTypes.APPLICATION_M3U8,
-                null, null, Format.NO_VALUE, Format.NO_VALUE, Format.NO_VALUE, null, selectionFlags,
-                language);
-            if (uri == null) {
-              muxedAudioFormat = format;
-            } else {
-              audios.add(new HlsMasterPlaylist.HlsUrl(name, uri, format, null, format, null));
-            }
-            break;
-          case TYPE_SUBTITLES:
-            format = Format.createTextContainerFormat(name, MimeTypes.APPLICATION_M3U8,
-                MimeTypes.TEXT_VTT, null, Format.NO_VALUE, selectionFlags, language);
-            subtitles.add(new HlsMasterPlaylist.HlsUrl(name, uri, format, null, format, null));
-            break;
-          case TYPE_CLOSED_CAPTIONS:
-            if ("CC1".equals(parseOptionalStringAttr(line, REGEX_INSTREAM_ID))) {
-              muxedCaptionFormat = Format.createTextContainerFormat(name,
-                  MimeTypes.APPLICATION_M3U8, MimeTypes.APPLICATION_CEA608, null, Format.NO_VALUE,
-                  selectionFlags, language);
+
+    private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
+            throws IOException {
+        ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>(); // 不同分辨率，不同网络条件下的处理
+        ArrayList<HlsMasterPlaylist.HlsUrl> audios = new ArrayList<>();
+        ArrayList<HlsMasterPlaylist.HlsUrl> subtitles = new ArrayList<>();
+        Format muxedAudioFormat = null;
+        Format muxedCaptionFormat = null;
+
+        String line;
+        while (iterator.hasNext()) {
+            // 一行一行遍历
+            line = iterator.next();
+
+            if (line.startsWith(TAG_MEDIA)) {
+                // #EXT-X-MEDIA
+                // #EXTINF:3.008656,
+                @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
+                String uri = parseOptionalStringAttr(line, REGEX_URI);
+                String name = parseStringAttr(line, REGEX_NAME);
+                String language = parseOptionalStringAttr(line, REGEX_LANGUAGE);
+                Format format;
+                switch (parseStringAttr(line, REGEX_TYPE)) {
+                    case TYPE_AUDIO:
+                        format = Format.createAudioContainerFormat(name, MimeTypes.APPLICATION_M3U8,
+                                null, null, Format.NO_VALUE, Format.NO_VALUE, Format.NO_VALUE, null, selectionFlags,
+                                language);
+                        if (uri == null) {
+                            muxedAudioFormat = format;
+                        } else {
+                            audios.add(new HlsMasterPlaylist.HlsUrl(name, uri, format, null, format, null));
+                        }
+                        break;
+                    case TYPE_SUBTITLES:
+                        format = Format.createTextContainerFormat(name, MimeTypes.APPLICATION_M3U8,
+                                MimeTypes.TEXT_VTT, null, Format.NO_VALUE, selectionFlags, language);
+                        subtitles.add(new HlsMasterPlaylist.HlsUrl(name, uri, format, null, format, null));
+                        break;
+                    case TYPE_CLOSED_CAPTIONS:
+                        if ("CC1".equals(parseOptionalStringAttr(line, REGEX_INSTREAM_ID))) {
+                            muxedCaptionFormat = Format.createTextContainerFormat(name,
+                                    MimeTypes.APPLICATION_M3U8, MimeTypes.APPLICATION_CEA608, null, Format.NO_VALUE,
+                                    selectionFlags, language);
+                        }
+                        break;
+                    default:
+                        // Do nothing.
+                        break;
+                }
+            } else if (line.startsWith(TAG_STREAM_INF)) {
+                // #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
+                // hls-360p/hls-360p.m3u8
+                // 解析出带宽
+                int bitrate = parseIntAttr(line, REGEX_BANDWIDTH);
+                // 编码器
+                String codecs = parseOptionalStringAttr(line, REGEX_CODECS);
+                // 分辨率: 可选
+                String resolutionString = parseOptionalStringAttr(line, REGEX_RESOLUTION);
+
+                // 解析分辨率(可选)
+                int width;
+                int height;
+                if (resolutionString != null) {
+                    String[] widthAndHeight = resolutionString.split("x");
+                    width = Integer.parseInt(widthAndHeight[0]);
+                    height = Integer.parseInt(widthAndHeight[1]);
+                    if (width <= 0 || height <= 0) {
+                        // Resolution string is invalid.
+                        width = Format.NO_VALUE;
+                        height = Format.NO_VALUE;
+                    }
+                } else {
+                    width = Format.NO_VALUE;
+                    height = Format.NO_VALUE;
+                }
+                line = iterator.next();
+                String name = Integer.toString(variants.size());
+                Format format = Format.createVideoContainerFormat(name, MimeTypes.APPLICATION_M3U8, null,
+                        codecs, bitrate, width, height, Format.NO_VALUE, null);
+
+                // 二级: m3u8文件
+                variants.add(new HlsMasterPlaylist.HlsUrl(name, line, format, null, null, null));
             }
-            break;
-          default:
-            // Do nothing.
-            break;
-        }
-      } else if (line.startsWith(TAG_STREAM_INF)) {
-        // #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=144000,CODECS="mp4a.40.2"
-        // hls-360p/hls-360p.m3u8
-        // 解析出带宽
-        int bitrate = parseIntAttr(line, REGEX_BANDWIDTH);
-        // 编码器
-        String codecs = parseOptionalStringAttr(line, REGEX_CODECS);
-        // 分辨率: 可选
-        String resolutionString = parseOptionalStringAttr(line, REGEX_RESOLUTION);
-
-        // 解析分辨率(可选)
-        int width;
-        int height;
-        if (resolutionString != null) {
-          String[] widthAndHeight = resolutionString.split("x");
-          width = Integer.parseInt(widthAndHeight[0]);
-          height = Integer.parseInt(widthAndHeight[1]);
-          if (width <= 0 || height <= 0) {
-            // Resolution string is invalid.
-            width = Format.NO_VALUE;
-            height = Format.NO_VALUE;
-          }
-        } else {
-          width = Format.NO_VALUE;
-          height = Format.NO_VALUE;
         }
-        line = iterator.next();
-        String name = Integer.toString(variants.size());
-        Format format = Format.createVideoContainerFormat(name, MimeTypes.APPLICATION_M3U8, null,
-            codecs, bitrate, width, height, Format.NO_VALUE, null);
-
-        // 二级: m3u8文件
-        variants.add(new HlsMasterPlaylist.HlsUrl(name, line, format, null, null, null));
-      }
+
+        // 返回Master
+        return new HlsMasterPlaylist(baseUri, variants, audios, subtitles, muxedAudioFormat,
+                muxedCaptionFormat);
     }
 
-    // 返回Master
-    return new HlsMasterPlaylist(baseUri, variants, audios, subtitles, muxedAudioFormat,
-        muxedCaptionFormat);
-  }
-
-  @C.SelectionFlags
-  private static int parseSelectionFlags(String line) {
-    return (parseBooleanAttribute(line, REGEX_DEFAULT, false) ? C.SELECTION_FLAG_DEFAULT : 0)
-        | (parseBooleanAttribute(line, REGEX_FORCED, false) ? C.SELECTION_FLAG_FORCED : 0)
-        | (parseBooleanAttribute(line, REGEX_AUTOSELECT, false) ? C.SELECTION_FLAG_AUTOSELECT : 0);
-  }
-
-  // 解析普通的Playlist文件
-  private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
-      throws IOException {
-    int mediaSequence = 0;
-    int version = 1; // Default version == 1.
-    long targetDurationUs = C.TIME_UNSET;
-    boolean hasEndTag = false;
-    Segment initializationSegment = null;
-    List<Segment> segments = new ArrayList<>();
-
-    long segmentDurationUs = 0;
-    int discontinuitySequenceNumber = 0;
-    long playlistStartTimeUs = 0;
-    long segmentStartTimeUs = 0;
-    long segmentByteRangeOffset = 0;
-    long segmentByteRangeLength = C.LENGTH_UNSET;
-    int segmentMediaSequence = 0;
-
-    boolean isEncrypted = false;
-    String encryptionKeyUri = null;
-    String encryptionIV = null;
-
-    String line;
-    while (iterator.hasNext()) {
-      line = iterator.next();
-      if (line.startsWith(TAG_INIT_SEGMENT)) {
-        String uri = parseStringAttr(line, REGEX_URI);
-        String byteRange = parseOptionalStringAttr(line, REGEX_ATTR_BYTERANGE);
-        if (byteRange != null) {
-          String[] splitByteRange = byteRange.split("@");
-          segmentByteRangeLength = Long.parseLong(splitByteRange[0]);
-          if (splitByteRange.length > 1) {
-            segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
-          }
-        }
-        initializationSegment = new Segment(uri, segmentByteRangeOffset, segmentByteRangeLength);
-        segmentByteRangeOffset = 0;
-        segmentByteRangeLength = C.LENGTH_UNSET;
-      } else if (line.startsWith(TAG_TARGET_DURATION)) {
-        targetDurationUs = parseIntAttr(line, REGEX_TARGET_DURATION) * C.MICROS_PER_SECOND;
-      } else if (line.startsWith(TAG_MEDIA_SEQUENCE)) {
-        mediaSequence = parseIntAttr(line, REGEX_MEDIA_SEQUENCE);
-        segmentMediaSequence = mediaSequence;
-      } else if (line.startsWith(TAG_VERSION)) {
-        // 版本
-        version = parseIntAttr(line, REGEX_VERSION);
-      } else if (line.startsWith(TAG_MEDIA_DURATION)) {
-        // 持续时间
-        segmentDurationUs = (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
-      } else if (line.startsWith(TAG_KEY)) {
-        // 秘钥
-        String method = parseStringAttr(line, REGEX_METHOD);
-        isEncrypted = METHOD_AES128.equals(method);
-        if (isEncrypted) {
-          encryptionKeyUri = parseStringAttr(line, REGEX_URI);
-          encryptionIV = parseOptionalStringAttr(line, REGEX_IV);
-        } else {
-          encryptionKeyUri = null;
-          encryptionIV = null;
-        }
-      } else if (line.startsWith(TAG_BYTERANGE)) {
-        // byte-range
-        String byteRange = parseStringAttr(line, REGEX_BYTERANGE);
-        String[] splitByteRange = byteRange.split("@");
-        segmentByteRangeLength = Long.parseLong(splitByteRange[0]);
-        if (splitByteRange.length > 1) {
-          segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
-        }
-      } else if (line.startsWith(TAG_DISCONTINUITY_SEQUENCE)) {
-        discontinuitySequenceNumber = Integer.parseInt(line.substring(line.indexOf(':') + 1));
-      } else if (line.equals(TAG_DISCONTINUITY)) {
-        discontinuitySequenceNumber++;
-      } else if (line.startsWith(TAG_PROGRAM_DATE_TIME)) {
-        if (playlistStartTimeUs == 0) {
-          long programDatetimeUs =
-              C.msToUs(Util.parseXsDateTime(line.substring(line.indexOf(':') + 1)));
-          playlistStartTimeUs = programDatetimeUs - segmentStartTimeUs;
-        }
-      } else if (!line.startsWith("#")) {
-        // 应该就是普通的ts的URL了
-        String segmentEncryptionIV;
-        if (!isEncrypted) {
-          segmentEncryptionIV = null;
-        } else if (encryptionIV != null) {
-          segmentEncryptionIV = encryptionIV;
-        } else {
-          segmentEncryptionIV = Integer.toHexString(segmentMediaSequence);
-        }
-        segmentMediaSequence++;
-        if (segmentByteRangeLength == C.LENGTH_UNSET) {
-          segmentByteRangeOffset = 0;
-        }
+    @C.SelectionFlags
+    private static int parseSelectionFlags(String line) {
+        return (parseBooleanAttribute(line, REGEX_DEFAULT, false) ? C.SELECTION_FLAG_DEFAULT : 0)
+                | (parseBooleanAttribute(line, REGEX_FORCED, false) ? C.SELECTION_FLAG_FORCED : 0)
+                | (parseBooleanAttribute(line, REGEX_AUTOSELECT, false) ? C.SELECTION_FLAG_AUTOSELECT : 0);
+    }
 
-        // 获取segments的信息
-        segments.add(new Segment(line, segmentDurationUs, discontinuitySequenceNumber,
-            segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
-            segmentByteRangeOffset, segmentByteRangeLength));
-        segmentStartTimeUs += segmentDurationUs;
-        segmentDurationUs = 0;
+    // 解析普通的Playlist文件
+    private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String baseUri)
+            throws IOException {
+        int mediaSequence = 0;
+        int version = 1; // Default version == 1.
+        long targetDurationUs = C.TIME_UNSET;
+        boolean hasEndTag = false;
+        Segment initializationSegment = null;
+        List<Segment> segments = new ArrayList<>();
+
+        long segmentDurationUs = 0;
+        int discontinuitySequenceNumber = 0;
+        long playlistStartTimeUs = 0;
+        long segmentStartTimeUs = 0;
+        long segmentByteRangeOffset = 0;
+        long segmentByteRangeLength = C.LENGTH_UNSET;
+        int segmentMediaSequence = 0;
+
+        boolean isEncrypted = false;
+        String encryptionKeyUri = null;
+        String encryptionIV = null;
+
+        String line;
+        while (iterator.hasNext()) {
+            line = iterator.next();
+            if (line.startsWith(TAG_INIT_SEGMENT)) {
+                String uri = parseStringAttr(line, REGEX_URI);
+                String byteRange = parseOptionalStringAttr(line, REGEX_ATTR_BYTERANGE);
+                if (byteRange != null) {
+                    String[] splitByteRange = byteRange.split("@");
+                    segmentByteRangeLength = Long.parseLong(splitByteRange[0]);
+                    if (splitByteRange.length > 1) {
+                        segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
+                    }
+                }
+                initializationSegment = new Segment(uri, segmentByteRangeOffset, segmentByteRangeLength);
+                segmentByteRangeOffset = 0;
+                segmentByteRangeLength = C.LENGTH_UNSET;
+            } else if (line.startsWith(TAG_TARGET_DURATION)) {
+                targetDurationUs = parseIntAttr(line, REGEX_TARGET_DURATION) * C.MICROS_PER_SECOND;
+            } else if (line.startsWith(TAG_MEDIA_SEQUENCE)) {
+                mediaSequence = parseIntAttr(line, REGEX_MEDIA_SEQUENCE);
+                segmentMediaSequence = mediaSequence;
+            } else if (line.startsWith(TAG_VERSION)) {
+                // 版本
+                version = parseIntAttr(line, REGEX_VERSION);
+            } else if (line.startsWith(TAG_MEDIA_DURATION)) {
+                // 持续时间
+                segmentDurationUs = (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
+            } else if (line.startsWith(TAG_KEY)) {
+                // 秘钥
+                String method = parseStringAttr(line, REGEX_METHOD);
+                isEncrypted = METHOD_AES128.equals(method);
+                if (isEncrypted) {
+                    encryptionKeyUri = parseStringAttr(line, REGEX_URI);
+                    encryptionIV = parseOptionalStringAttr(line, REGEX_IV);
+                } else {
+                    encryptionKeyUri = null;
+                    encryptionIV = null;
+                }
+            } else if (line.startsWith(TAG_BYTERANGE)) {
+                // byte-range
+                String byteRange = parseStringAttr(line, REGEX_BYTERANGE);
+                String[] splitByteRange = byteRange.split("@");
+                segmentByteRangeLength = Long.parseLong(splitByteRange[0]);
+                if (splitByteRange.length > 1) {
+                    segmentByteRangeOffset = Long.parseLong(splitByteRange[1]);
+                }
+            } else if (line.startsWith(TAG_DISCONTINUITY_SEQUENCE)) {
+                discontinuitySequenceNumber = Integer.parseInt(line.substring(line.indexOf(':') + 1));
+            } else if (line.equals(TAG_DISCONTINUITY)) {
+                discontinuitySequenceNumber++;
+            } else if (line.startsWith(TAG_PROGRAM_DATE_TIME)) {
+                if (playlistStartTimeUs == 0) {
+                    long programDatetimeUs =
+                            C.msToUs(Util.parseXsDateTime(line.substring(line.indexOf(':') + 1)));
+                    playlistStartTimeUs = programDatetimeUs - segmentStartTimeUs;
+                }
+            } else if (!line.startsWith("#")) {
+                // 应该就是普通的ts的URL了
+                String segmentEncryptionIV;
+                if (!isEncrypted) {
+                    segmentEncryptionIV = null;
+                } else if (encryptionIV != null) {
+                    segmentEncryptionIV = encryptionIV;
+                } else {
+                    segmentEncryptionIV = Integer.toHexString(segmentMediaSequence);
+                }
+                segmentMediaSequence++;
+                if (segmentByteRangeLength == C.LENGTH_UNSET) {
+                    segmentByteRangeOffset = 0;
+                }
+
+                // 获取segments的信息
+                segments.add(new Segment(line, segmentDurationUs, discontinuitySequenceNumber,
+                        segmentStartTimeUs, isEncrypted, encryptionKeyUri, segmentEncryptionIV,
+                        segmentByteRangeOffset, segmentByteRangeLength));
+                segmentStartTimeUs += segmentDurationUs;
+                segmentDurationUs = 0;
+
+                if (segmentByteRangeLength != C.LENGTH_UNSET) {
+                    segmentByteRangeOffset += segmentByteRangeLength;
+                }
+                segmentByteRangeLength = C.LENGTH_UNSET;
+            } else if (line.equals(TAG_ENDLIST)) {
+                hasEndTag = true;
+            }
+        }
+        return new HlsMediaPlaylist(baseUri, playlistStartTimeUs, mediaSequence, version,
+                targetDurationUs, hasEndTag, playlistStartTimeUs != 0, initializationSegment, segments);
+    }
 
-        if (segmentByteRangeLength != C.LENGTH_UNSET) {
-          segmentByteRangeOffset += segmentByteRangeLength;
+    private static String parseStringAttr(String line, Pattern pattern) throws ParserException {
+        Matcher matcher = pattern.matcher(line);
+        if (matcher.find() && matcher.groupCount() == 1) {
+            return matcher.group(1);
         }
-        segmentByteRangeLength = C.LENGTH_UNSET;
-      } else if (line.equals(TAG_ENDLIST)) {
-        hasEndTag = true;
-      }
+        throw new ParserException("Couldn't match " + pattern.pattern() + " in " + line);
     }
-    return new HlsMediaPlaylist(baseUri, playlistStartTimeUs, mediaSequence, version,
-        targetDurationUs, hasEndTag, playlistStartTimeUs != 0, initializationSegment, segments);
-  }
-
-  private static String parseStringAttr(String line, Pattern pattern) throws ParserException {
-    Matcher matcher = pattern.matcher(line);
-    if (matcher.find() && matcher.groupCount() == 1) {
-      return matcher.group(1);
+
+    private static int parseIntAttr(String line, Pattern pattern) throws ParserException {
+        return Integer.parseInt(parseStringAttr(line, pattern));
     }
-    throw new ParserException("Couldn't match " + pattern.pattern() + " in " + line);
-  }
 
-  private static int parseIntAttr(String line, Pattern pattern) throws ParserException {
-    return Integer.parseInt(parseStringAttr(line, pattern));
-  }
+    private static double parseDoubleAttr(String line, Pattern pattern) throws ParserException {
+        return Double.parseDouble(parseStringAttr(line, pattern));
+    }
 
-  private static double parseDoubleAttr(String line, Pattern pattern) throws ParserException {
-    return Double.parseDouble(parseStringAttr(line, pattern));
-  }
+    private static String parseOptionalStringAttr(String line, Pattern pattern) {
+        Matcher matcher = pattern.matcher(line);
+        if (matcher.find()) {
+            return matcher.group(1);
+        }
+        return null;
+    }
 
-  private static String parseOptionalStringAttr(String line, Pattern pattern) {
-    Matcher matcher = pattern.matcher(line);
-    if (matcher.find()) {
-      return matcher.group(1);
+    private static boolean parseBooleanAttribute(String line, Pattern pattern, boolean defaultValue) {
+        Matcher matcher = pattern.matcher(line);
+        if (matcher.find()) {
+            return matcher.group(1).equals(BOOLEAN_TRUE);
+        }
+        return defaultValue;
     }
-    return null;
-  }
 
-  private static boolean parseBooleanAttribute(String line, Pattern pattern, boolean defaultValue) {
-    Matcher matcher = pattern.matcher(line);
-    if (matcher.find()) {
-      return matcher.group(1).equals(BOOLEAN_TRUE);
+    private static Pattern compileBooleanAttrPattern(String attribute) {
+        return Pattern.compile(attribute + "=(" + BOOLEAN_FALSE + "|" + BOOLEAN_TRUE + ")");
     }
-    return defaultValue;
-  }
 
-  private static Pattern compileBooleanAttrPattern(String attribute) {
-    return Pattern.compile(attribute + "=(" + BOOLEAN_FALSE + "|" + BOOLEAN_TRUE + ")");
-  }
+    // 将reader和extralines组成的结构按照行遍历
+    private static class LineIterator {
 
-  // 将reader和extralines组成的结构按照行遍历
-  private static class LineIterator {
+        private final BufferedReader reader;
+        private final Queue<String> extraLines;
 
-    private final BufferedReader reader;
-    private final Queue<String> extraLines;
+        private String next;
 
-    private String next;
+        public LineIterator(Queue<String> extraLines, BufferedReader reader) {
+            this.extraLines = extraLines;
+            this.reader = reader;
+        }
 
-    public LineIterator(Queue<String> extraLines, BufferedReader reader) {
-      this.extraLines = extraLines;
-      this.reader = reader;
-    }
+        public boolean hasNext() throws IOException {
+            if (next != null) {
+                return true;
+            }
+            if (!extraLines.isEmpty()) {
+                next = extraLines.poll();
+                return true;
+            }
+            while ((next = reader.readLine()) != null) {
+                next = next.trim();
+                if (!next.isEmpty()) {
+                    return true;
+                }
+            }
+            return false;
+        }
 
-    public boolean hasNext() throws IOException {
-      if (next != null) {
-        return true;
-      }
-      if (!extraLines.isEmpty()) {
-        next = extraLines.poll();
-        return true;
-      }
-      while ((next = reader.readLine()) != null) {
-        next = next.trim();
-        if (!next.isEmpty()) {
-          return true;
+        public String next() throws IOException {
+            String result = null;
+            if (hasNext()) {
+                result = next;
+                next = null;
+            }
+            return result;
         }
-      }
-      return false;
-    }
 
-    public String next() throws IOException {
-      String result = null;
-      if (hasNext()) {
-        result = next;
-        next = null;
-      }
-      return result;
     }
 
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index 6ede1197ff..66a64d629a 100644
--- a/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -18,6 +18,7 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.SystemClock;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
@@ -28,6 +29,7 @@
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.UriUtil;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.IdentityHashMap;
@@ -36,496 +38,496 @@
 /**
  * Tracks playlists linked to a provided playlist url. The provided url might reference an HLS
  * master playlist or a media playlist.
- *
+ * <p>
  * Track对应一个m3u8文件， 可能是master playlist或者media playlist; 注意不同的概念
  * 负责m3u8的下载，管理，状态汇报
  */
 public final class HlsPlaylistTracker implements Loader.Callback<ParsingLoadable<HlsPlaylist>> {
 
-  /**
-   * Listener for primary playlist changes.
-   */
-  public interface PrimaryPlaylistListener {
+    /**
+     * Listener for primary playlist changes.
+     */
+    public interface PrimaryPlaylistListener {
+
+        /**
+         * Called when the primary playlist changes. （主要的playlist?)
+         *
+         * @param mediaPlaylist The primary playlist new snapshot.
+         */
+        void onPrimaryPlaylistRefreshed(HlsMediaPlaylist mediaPlaylist);
+
+    }
 
     /**
-     * Called when the primary playlist changes. （主要的playlist?)
-     *
-     * @param mediaPlaylist The primary playlist new snapshot.
+     * Called on playlist loading events.
      */
-    void onPrimaryPlaylistRefreshed(HlsMediaPlaylist mediaPlaylist);
+    public interface PlaylistEventListener {
+
+        /**
+         * Called a playlist changes.
+         */
+        void onPlaylistChanged();
+
+        /**
+         * Called if an error is encountered while loading a playlist.
+         *
+         * @param url                 The loaded url that caused the error.
+         * @param blacklistDurationMs The number of milliseconds for which the playlist has been
+         *                            blacklisted.
+         */
+        void onPlaylistBlacklisted(HlsUrl url, long blacklistDurationMs);
 
-  }
+    }
 
-  /**
-   * Called on playlist loading events.
-   */
-  public interface PlaylistEventListener {
+    /**
+     * The minimum number of milliseconds that a url is kept as primary url, if no
+     * {@link #getPlaylistSnapshot} call is made for that url.
+     */
+    private static final long PRIMARY_URL_KEEPALIVE_MS = 15000;
+
+    private final Uri initialPlaylistUri;
+    private final DataSource.Factory dataSourceFactory;
+    private final HlsPlaylistParser playlistParser;
+    private final int minRetryCount;
+    private final IdentityHashMap<HlsUrl, MediaPlaylistBundle> playlistBundles;
+    private final Handler playlistRefreshHandler;
+    private final PrimaryPlaylistListener primaryPlaylistListener;
+    private final List<PlaylistEventListener> listeners;
+    private final Loader initialPlaylistLoader;
+    private final EventDispatcher eventDispatcher;
+
+    private HlsMasterPlaylist masterPlaylist;
+    private HlsUrl primaryHlsUrl;
+    private HlsMediaPlaylist primaryUrlSnapshot;
+    private boolean isLive;
 
     /**
-     * Called a playlist changes.
+     * @param initialPlaylistUri      Uri for the initial playlist of the stream. Can refer a media
+     *                                playlist or a master playlist.
+     * @param dataSourceFactory       A factory for {@link DataSource} instances.
+     * @param eventDispatcher         A dispatcher to notify of events.
+     * @param minRetryCount           The minimum number of times the load must be retried before blacklisting a
+     *                                playlist.
+     * @param primaryPlaylistListener A callback for the primary playlist change events.
      */
-    void onPlaylistChanged();
+    public HlsPlaylistTracker(Uri initialPlaylistUri, DataSource.Factory dataSourceFactory,
+                              EventDispatcher eventDispatcher, int minRetryCount,
+                              PrimaryPlaylistListener primaryPlaylistListener) {
+
+        // Playlist的Uri
+        this.initialPlaylistUri = initialPlaylistUri;
+
+        this.dataSourceFactory = dataSourceFactory;
+        this.eventDispatcher = eventDispatcher;
+        this.minRetryCount = minRetryCount;
+        this.primaryPlaylistListener = primaryPlaylistListener;
+        listeners = new ArrayList<>();
+
+        // 执行管理 Loadable
+        initialPlaylistLoader = new Loader("HlsPlaylistTracker:MasterPlaylist");
+
+        // Parse Playlist文件
+        playlistParser = new HlsPlaylistParser();
+        playlistBundles = new IdentityHashMap<>();
+        playlistRefreshHandler = new Handler();
+    }
 
     /**
-     * Called if an error is encountered while loading a playlist.
+     * Registers a listener to receive events from the playlist tracker.
      *
-     * @param url The loaded url that caused the error.
-     * @param blacklistDurationMs The number of milliseconds for which the playlist has been
-     *     blacklisted.
+     * @param listener The listener.
      */
-    void onPlaylistBlacklisted(HlsUrl url, long blacklistDurationMs);
-
-  }
-
-  /**
-   * The minimum number of milliseconds that a url is kept as primary url, if no
-   * {@link #getPlaylistSnapshot} call is made for that url.
-   */
-  private static final long PRIMARY_URL_KEEPALIVE_MS = 15000;
-
-  private final Uri initialPlaylistUri;
-  private final DataSource.Factory dataSourceFactory;
-  private final HlsPlaylistParser playlistParser;
-  private final int minRetryCount;
-  private final IdentityHashMap<HlsUrl, MediaPlaylistBundle> playlistBundles;
-  private final Handler playlistRefreshHandler;
-  private final PrimaryPlaylistListener primaryPlaylistListener;
-  private final List<PlaylistEventListener> listeners;
-  private final Loader initialPlaylistLoader;
-  private final EventDispatcher eventDispatcher;
-
-  private HlsMasterPlaylist masterPlaylist;
-  private HlsUrl primaryHlsUrl;
-  private HlsMediaPlaylist primaryUrlSnapshot;
-  private boolean isLive;
-
-  /**
-   * @param initialPlaylistUri Uri for the initial playlist of the stream. Can refer a media
-   *     playlist or a master playlist.
-   * @param dataSourceFactory A factory for {@link DataSource} instances.
-   * @param eventDispatcher A dispatcher to notify of events.
-   * @param minRetryCount The minimum number of times the load must be retried before blacklisting a
-   *     playlist.
-   * @param primaryPlaylistListener A callback for the primary playlist change events.
-   */
-  public HlsPlaylistTracker(Uri initialPlaylistUri, DataSource.Factory dataSourceFactory,
-      EventDispatcher eventDispatcher, int minRetryCount,
-      PrimaryPlaylistListener primaryPlaylistListener) {
-
-    // Playlist的Uri
-    this.initialPlaylistUri = initialPlaylistUri;
-
-    this.dataSourceFactory = dataSourceFactory;
-    this.eventDispatcher = eventDispatcher;
-    this.minRetryCount = minRetryCount;
-    this.primaryPlaylistListener = primaryPlaylistListener;
-    listeners = new ArrayList<>();
-
-    // 执行管理 Loadable
-    initialPlaylistLoader = new Loader("HlsPlaylistTracker:MasterPlaylist");
-
-    // Parse Playlist文件
-    playlistParser = new HlsPlaylistParser();
-    playlistBundles = new IdentityHashMap<>();
-    playlistRefreshHandler = new Handler();
-  }
-
-  /**
-   * Registers a listener to receive events from the playlist tracker.
-   *
-   * @param listener The listener.
-   */
-  public void addListener(PlaylistEventListener listener) {
-    listeners.add(listener);
-  }
-
-  /**
-   * Unregisters a listener.
-   *
-   * @param listener The listener to unregister.
-   */
-  public void removeListener(PlaylistEventListener listener) {
-    listeners.remove(listener);
-  }
-
-  /**
-   * Starts tracking all the playlists related to the provided Uri.
-   */
-  public void start() {
-    // 下载: Playlist, 并且通过 playlistParser 来解析
-    // dataSourceFactory.createDataSource() 指定了网络请求
-    ParsingLoadable<HlsPlaylist> masterPlaylistLoadable =
-            new ParsingLoadable<>(dataSourceFactory.createDataSource(), initialPlaylistUri, C.DATA_TYPE_MANIFEST, playlistParser);
-
-    // this Loader callback
-    initialPlaylistLoader.startLoading(masterPlaylistLoadable, this, minRetryCount);
-  }
-
-  /**
-   * Returns the master playlist.
-   *
-   * @return The master playlist. Null if the initial playlist has yet to be loaded.
-   */
-  public HlsMasterPlaylist getMasterPlaylist() {
-    return masterPlaylist;
-  }
-
-  /**
-   * Returns the most recent snapshot available of the playlist referenced by the provided
-   * {@link HlsUrl}.
-   *
-   * @param url The {@link HlsUrl} corresponding to the requested media playlist.
-   * @return The most recent snapshot of the playlist referenced by the provided {@link HlsUrl}. May
-   *     be null if no snapshot has been loaded yet.
-   */
-  public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url) {
-    maybeSetPrimaryUrl(url);
-    return playlistBundles.get(url).getPlaylistSnapshot();
-  }
-
-  /**
-   * Releases the playlist tracker.
-   */
-  public void release() {
-    initialPlaylistLoader.release();
-    for (MediaPlaylistBundle bundle : playlistBundles.values()) {
-      bundle.release();
-    }
-    playlistRefreshHandler.removeCallbacksAndMessages(null);
-    playlistBundles.clear();
-  }
-
-  /**
-   * If the tracker is having trouble refreshing the primary playlist or loading an irreplaceable
-   * playlist, this method throws the underlying error. Otherwise, does nothing.
-   *
-   * @throws IOException The underlying error.
-   */
-  public void maybeThrowPlaylistRefreshError() throws IOException {
-    initialPlaylistLoader.maybeThrowError();
-    if (primaryHlsUrl != null) {
-      playlistBundles.get(primaryHlsUrl).mediaPlaylistLoader.maybeThrowError();
+    public void addListener(PlaylistEventListener listener) {
+        listeners.add(listener);
     }
-  }
-
-  /**
-   * Triggers a playlist refresh and whitelists it.
-   *
-   * @param url The {@link HlsUrl} of the playlist to be refreshed.
-   */
-  public void refreshPlaylist(HlsUrl url) {
-    playlistBundles.get(url).loadPlaylist();
-  }
-
-  /**
-   * Returns whether this is live content.
-   *
-   * @return True if the content is live. False otherwise.
-   */
-  public boolean isLive() {
-    return isLive;
-  }
-
-  // Loader.Callback implementation.
-
-  @Override
-  public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
-      long loadDurationMs) {
-
-    // m3u8加载完毕
-    // 整个文件已经通过: playlistParser 进行解析
-    // 注意: ParsingLoadable<HlsPlaylist> 的构建方式
-    HlsPlaylist result = loadable.getResult();
-
-    // 区分是一级索引还是二级索引
-    HlsMasterPlaylist masterPlaylist;
-    boolean isMediaPlaylist = result instanceof HlsMediaPlaylist;
-
-    // 如果是二级索引，则需要构建一个虚拟的masterPlaylist
-    if (isMediaPlaylist) {
-      masterPlaylist = HlsMasterPlaylist.createSingleVariantMasterPlaylist(result.baseUri);
-    } else /* result instanceof HlsMasterPlaylist */ {
-      masterPlaylist = (HlsMasterPlaylist) result;
-    }
-    this.masterPlaylist = masterPlaylist;
-
-    // XXX: 默认第一个为: primaryHlsUrl(因此在播放视频的时候刚开始总是不清晰....）
-    primaryHlsUrl = masterPlaylist.variants.get(0);
-    ArrayList<HlsUrl> urls = new ArrayList<>();
-    urls.addAll(masterPlaylist.variants);
-    urls.addAll(masterPlaylist.audios);
-    urls.addAll(masterPlaylist.subtitles);
-
-    // 每一个URL <--> MediaPlaylistBundle
-    createBundles(urls);
-
-    // 如何处理: MediaPlaylistBundle ?
-    // 1. 如果是MediaPlaylist, 则加载完毕
-    // 2. 如果是MastPlaylist, 则加载Playlist
-    // 参考: createBundles
-    MediaPlaylistBundle primaryBundle = playlistBundles.get(primaryHlsUrl);
-    if (isMediaPlaylist) {
-      // We don't need to load the playlist again. We can use the same result.
-      primaryBundle.processLoadedPlaylist((HlsMediaPlaylist) result);
-    } else {
-      primaryBundle.loadPlaylist();
-    }
-    eventDispatcher.loadCompleted(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
-        loadDurationMs, loadable.bytesLoaded());
-  }
-
-  @Override
-  public void onLoadCanceled(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
-      long loadDurationMs, boolean released) {
-    eventDispatcher.loadCanceled(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
-        loadDurationMs, loadable.bytesLoaded());
-  }
-
-  @Override
-  public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
-      long loadDurationMs, IOException error) {
-    boolean isFatal = error instanceof ParserException;
-    eventDispatcher.loadError(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
-        loadDurationMs, loadable.bytesLoaded(), error, isFatal);
-    return isFatal ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
-  }
-
-  // Internal methods.
-
-  private boolean maybeSelectNewPrimaryUrl() {
-    List<HlsUrl> variants = masterPlaylist.variants;
-    int variantsSize = variants.size();
-    long currentTimeMs = SystemClock.elapsedRealtime();
-    for (int i = 0; i < variantsSize; i++) {
-      MediaPlaylistBundle bundle = playlistBundles.get(variants.get(i));
-      if (currentTimeMs > bundle.blacklistUntilMs) {
-        primaryHlsUrl = bundle.playlistUrl;
-        bundle.loadPlaylist();
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private void maybeSetPrimaryUrl(HlsUrl url) {
-    if (!masterPlaylist.variants.contains(url)
-        || (primaryUrlSnapshot != null && primaryUrlSnapshot.hasEndTag)) {
-      // Only allow variant urls to be chosen as primary. Also prevent changing the primary url if
-      // the last primary snapshot contains an end tag.
-      return;
-    }
-    MediaPlaylistBundle currentPrimaryBundle = playlistBundles.get(primaryHlsUrl);
-    long primarySnapshotAccessAgeMs =
-        currentPrimaryBundle.lastSnapshotAccessTimeMs - SystemClock.elapsedRealtime();
-    if (primarySnapshotAccessAgeMs > PRIMARY_URL_KEEPALIVE_MS) {
-      primaryHlsUrl = url;
-      playlistBundles.get(primaryHlsUrl).loadPlaylist();
-    }
-  }
-
-  private void createBundles(List<HlsUrl> urls) {
-    int listSize = urls.size();
-    long currentTimeMs = SystemClock.elapsedRealtime();
-    for (int i = 0; i < listSize; i++) {
-      HlsUrl url = urls.get(i);
-      MediaPlaylistBundle bundle = new MediaPlaylistBundle(url, currentTimeMs);
-      playlistBundles.put(urls.get(i), bundle);
-    }
-  }
-
-  /**
-   * Called by the bundles when a snapshot changes.
-   *
-   * @param url The url of the playlist.
-   * @param newSnapshot The new snapshot.
-   * @return True if a refresh should be scheduled.
-   */
-  private boolean onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
-    if (url == primaryHlsUrl) {
-      if (primaryUrlSnapshot == null) {
-        // This is the first primary url snapshot.
-        isLive = !newSnapshot.hasEndTag;
-      }
-      primaryUrlSnapshot = newSnapshot;
-      primaryPlaylistListener.onPrimaryPlaylistRefreshed(newSnapshot);
-    }
-    int listenersSize = listeners.size();
-    for (int i = 0; i < listenersSize; i++) {
-      listeners.get(i).onPlaylistChanged();
-    }
-    // If the primary playlist is not the final one, we should schedule a refresh.
-    return url == primaryHlsUrl && !newSnapshot.hasEndTag;
-  }
-
-  private void notifyPlaylistBlacklisting(HlsUrl url, long blacklistMs) {
-    int listenersSize = listeners.size();
-    for (int i = 0; i < listenersSize; i++) {
-      listeners.get(i).onPlaylistBlacklisted(url, blacklistMs);
-    }
-  }
-
-  /**
-   * TODO: Track discontinuities for media playlists that don't include the discontinuity number.
-   */
-  private HlsMediaPlaylist adjustPlaylistTimestamps(HlsMediaPlaylist oldPlaylist,
-      HlsMediaPlaylist newPlaylist) {
-    // 如何处理视频上的不连续性?
-    if (newPlaylist.hasProgramDateTime) {
-      if (newPlaylist.isNewerThan(oldPlaylist)) {
-        return newPlaylist;
-      } else {
-        return oldPlaylist;
-      }
+
+    /**
+     * Unregisters a listener.
+     *
+     * @param listener The listener to unregister.
+     */
+    public void removeListener(PlaylistEventListener listener) {
+        listeners.remove(listener);
     }
-    // TODO: Once playlist type support is added, the snapshot's age can be added by using the
-    // target duration.
-    long primarySnapshotStartTimeUs = primaryUrlSnapshot != null
-        ? primaryUrlSnapshot.startTimeUs : 0;
-    if (oldPlaylist == null) {
-      if (newPlaylist.startTimeUs == primarySnapshotStartTimeUs) {
-        // Playback has just started or is VOD so no adjustment is needed.
-        return newPlaylist;
-      } else {
-        return newPlaylist.copyWithStartTimeUs(primarySnapshotStartTimeUs);
-      }
+
+    /**
+     * Starts tracking all the playlists related to the provided Uri.
+     */
+    public void start() {
+        // 下载: Playlist, 并且通过 playlistParser 来解析
+        // dataSourceFactory.createDataSource() 指定了网络请求
+        ParsingLoadable<HlsPlaylist> masterPlaylistLoadable =
+                new ParsingLoadable<>(dataSourceFactory.createDataSource(), initialPlaylistUri, C.DATA_TYPE_MANIFEST, playlistParser);
+
+        // this Loader callback
+        initialPlaylistLoader.startLoading(masterPlaylistLoadable, this, minRetryCount);
     }
-    List<Segment> oldSegments = oldPlaylist.segments;
-    int oldPlaylistSize = oldSegments.size();
-    if (!newPlaylist.isNewerThan(oldPlaylist)) {
-      // Playlist has not changed.
-      return oldPlaylist;
+
+    /**
+     * Returns the master playlist.
+     *
+     * @return The master playlist. Null if the initial playlist has yet to be loaded.
+     */
+    public HlsMasterPlaylist getMasterPlaylist() {
+        return masterPlaylist;
     }
-    int mediaSequenceOffset = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
-    if (mediaSequenceOffset <= oldPlaylistSize) {
-      long adjustedNewPlaylistStartTimeUs = mediaSequenceOffset == oldPlaylistSize
-          ? oldPlaylist.getEndTimeUs()
-          : oldPlaylist.startTimeUs + oldSegments.get(mediaSequenceOffset).relativeStartTimeUs;
-      return newPlaylist.copyWithStartTimeUs(adjustedNewPlaylistStartTimeUs);
+
+    /**
+     * Returns the most recent snapshot available of the playlist referenced by the provided
+     * {@link HlsUrl}.
+     *
+     * @param url The {@link HlsUrl} corresponding to the requested media playlist.
+     * @return The most recent snapshot of the playlist referenced by the provided {@link HlsUrl}. May
+     * be null if no snapshot has been loaded yet.
+     */
+    public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url) {
+        maybeSetPrimaryUrl(url);
+        return playlistBundles.get(url).getPlaylistSnapshot();
     }
-    // No segments overlap, we assume the new playlist start coincides with the primary playlist.
-    return newPlaylist.copyWithStartTimeUs(primarySnapshotStartTimeUs);
-  }
-
-  /**
-   * Holds all information related to a specific Media Playlist.
-   */
-  private final class MediaPlaylistBundle implements Loader.Callback<ParsingLoadable<HlsPlaylist>>,
-      Runnable {
-
-    private final HlsUrl playlistUrl;
-    private final Loader mediaPlaylistLoader;
-    private final ParsingLoadable<HlsPlaylist> mediaPlaylistLoadable;
-
-    private HlsMediaPlaylist playlistSnapshot;
-    private long lastSnapshotAccessTimeMs;
-    private long blacklistUntilMs;
-
-    public MediaPlaylistBundle(HlsUrl playlistUrl, long initialLastSnapshotAccessTimeMs) {
-      this.playlistUrl = playlistUrl;
-      lastSnapshotAccessTimeMs = initialLastSnapshotAccessTimeMs;
-      mediaPlaylistLoader = new Loader("HlsPlaylistTracker:MediaPlaylist");
-
-      // 注意: Loadable的构建
-      // UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url)
-      // 可能是从master m3u8触发，获取子的m3u8文件的URL
-      //
-      mediaPlaylistLoadable = new ParsingLoadable<>(dataSourceFactory.createDataSource(),
-          UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url), C.DATA_TYPE_MANIFEST,
-          playlistParser);
+
+    /**
+     * Releases the playlist tracker.
+     */
+    public void release() {
+        initialPlaylistLoader.release();
+        for (MediaPlaylistBundle bundle : playlistBundles.values()) {
+            bundle.release();
+        }
+        playlistRefreshHandler.removeCallbacksAndMessages(null);
+        playlistBundles.clear();
     }
 
-    public HlsMediaPlaylist getPlaylistSnapshot() {
-      lastSnapshotAccessTimeMs = SystemClock.elapsedRealtime();
-      return playlistSnapshot;
+    /**
+     * If the tracker is having trouble refreshing the primary playlist or loading an irreplaceable
+     * playlist, this method throws the underlying error. Otherwise, does nothing.
+     *
+     * @throws IOException The underlying error.
+     */
+    public void maybeThrowPlaylistRefreshError() throws IOException {
+        initialPlaylistLoader.maybeThrowError();
+        if (primaryHlsUrl != null) {
+            playlistBundles.get(primaryHlsUrl).mediaPlaylistLoader.maybeThrowError();
+        }
     }
 
-    public void release() {
-      mediaPlaylistLoader.release();
+    /**
+     * Triggers a playlist refresh and whitelists it.
+     *
+     * @param url The {@link HlsUrl} of the playlist to be refreshed.
+     */
+    public void refreshPlaylist(HlsUrl url) {
+        playlistBundles.get(url).loadPlaylist();
     }
 
-    public void loadPlaylist() {
-      // 再次开始Loading
-      blacklistUntilMs = 0;
-      if (!mediaPlaylistLoader.isLoading()) {
-        mediaPlaylistLoader.startLoading(mediaPlaylistLoadable, this, minRetryCount);
-      }
+    /**
+     * Returns whether this is live content.
+     *
+     * @return True if the content is live. False otherwise.
+     */
+    public boolean isLive() {
+        return isLive;
     }
 
     // Loader.Callback implementation.
 
     @Override
     public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
-        long loadDurationMs) {
-      // 解析完毕
-      processLoadedPlaylist((HlsMediaPlaylist) loadable.getResult());
-
-      // 通知加载情况
-      eventDispatcher.loadCompleted(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
-          loadDurationMs, loadable.bytesLoaded());
+                                long loadDurationMs) {
+
+        // m3u8加载完毕
+        // 整个文件已经通过: playlistParser 进行解析
+        // 注意: ParsingLoadable<HlsPlaylist> 的构建方式
+        HlsPlaylist result = loadable.getResult();
+
+        // 区分是一级索引还是二级索引
+        HlsMasterPlaylist masterPlaylist;
+        boolean isMediaPlaylist = result instanceof HlsMediaPlaylist;
+
+        // 如果是二级索引，则需要构建一个虚拟的masterPlaylist
+        if (isMediaPlaylist) {
+            masterPlaylist = HlsMasterPlaylist.createSingleVariantMasterPlaylist(result.baseUri);
+        } else /* result instanceof HlsMasterPlaylist */ {
+            masterPlaylist = (HlsMasterPlaylist) result;
+        }
+        this.masterPlaylist = masterPlaylist;
+
+        // XXX: 默认第一个为: primaryHlsUrl(因此在播放视频的时候刚开始总是不清晰....）
+        primaryHlsUrl = masterPlaylist.variants.get(0);
+        ArrayList<HlsUrl> urls = new ArrayList<>();
+        urls.addAll(masterPlaylist.variants);
+        urls.addAll(masterPlaylist.audios);
+        urls.addAll(masterPlaylist.subtitles);
+
+        // 每一个URL <--> MediaPlaylistBundle
+        createBundles(urls);
+
+        // 如何处理: MediaPlaylistBundle ?
+        // 1. 如果是MediaPlaylist, 则加载完毕
+        // 2. 如果是MastPlaylist, 则加载Playlist
+        // 参考: createBundles
+        MediaPlaylistBundle primaryBundle = playlistBundles.get(primaryHlsUrl);
+        if (isMediaPlaylist) {
+            // We don't need to load the playlist again. We can use the same result.
+            primaryBundle.processLoadedPlaylist((HlsMediaPlaylist) result);
+        } else {
+            primaryBundle.loadPlaylist();
+        }
+        eventDispatcher.loadCompleted(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+                loadDurationMs, loadable.bytesLoaded());
     }
 
     @Override
     public void onLoadCanceled(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
-        long loadDurationMs, boolean released) {
-      // 通知加载情况
-      eventDispatcher.loadCanceled(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
-          loadDurationMs, loadable.bytesLoaded());
+                               long loadDurationMs, boolean released) {
+        eventDispatcher.loadCanceled(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+                loadDurationMs, loadable.bytesLoaded());
     }
 
     @Override
     public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
-        long loadDurationMs, IOException error) {
-      // 通知加载情况
-      boolean isFatal = error instanceof ParserException;
-      eventDispatcher.loadError(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
-          loadDurationMs, loadable.bytesLoaded(), error, isFatal);
-      if (isFatal) {
-        return Loader.DONT_RETRY_FATAL;
-      }
-
-      // 加载出错了，是否该重试呢?
-      // 如何监控这种情况呢?
-      boolean shouldRetry = true;
-      if (ChunkedTrackBlacklistUtil.shouldBlacklist(error)) {
-        blacklistUntilMs =
-            SystemClock.elapsedRealtime() + ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS;
-        notifyPlaylistBlacklisting(playlistUrl,
-            ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS);
-        shouldRetry = primaryHlsUrl == playlistUrl && !maybeSelectNewPrimaryUrl();
-      }
-      return shouldRetry ? Loader.RETRY : Loader.DONT_RETRY;
+                           long loadDurationMs, IOException error) {
+        boolean isFatal = error instanceof ParserException;
+        eventDispatcher.loadError(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+                loadDurationMs, loadable.bytesLoaded(), error, isFatal);
+        return isFatal ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
     }
 
-    // Runnable implementation.
+    // Internal methods.
 
-    @Override
-    public void run() {
-      loadPlaylist();
+    private boolean maybeSelectNewPrimaryUrl() {
+        List<HlsUrl> variants = masterPlaylist.variants;
+        int variantsSize = variants.size();
+        long currentTimeMs = SystemClock.elapsedRealtime();
+        for (int i = 0; i < variantsSize; i++) {
+            MediaPlaylistBundle bundle = playlistBundles.get(variants.get(i));
+            if (currentTimeMs > bundle.blacklistUntilMs) {
+                primaryHlsUrl = bundle.playlistUrl;
+                bundle.loadPlaylist();
+                return true;
+            }
+        }
+        return false;
     }
 
-    // Internal methods.
+    private void maybeSetPrimaryUrl(HlsUrl url) {
+        if (!masterPlaylist.variants.contains(url)
+                || (primaryUrlSnapshot != null && primaryUrlSnapshot.hasEndTag)) {
+            // Only allow variant urls to be chosen as primary. Also prevent changing the primary url if
+            // the last primary snapshot contains an end tag.
+            return;
+        }
+        MediaPlaylistBundle currentPrimaryBundle = playlistBundles.get(primaryHlsUrl);
+        long primarySnapshotAccessAgeMs =
+                currentPrimaryBundle.lastSnapshotAccessTimeMs - SystemClock.elapsedRealtime();
+        if (primarySnapshotAccessAgeMs > PRIMARY_URL_KEEPALIVE_MS) {
+            primaryHlsUrl = url;
+            playlistBundles.get(primaryHlsUrl).loadPlaylist();
+        }
+    }
 
-    private void processLoadedPlaylist(HlsMediaPlaylist loadedMediaPlaylist) {
-      // 认为: loadedMediaPlaylist 已经加载完毕，然后呢?
+    private void createBundles(List<HlsUrl> urls) {
+        int listSize = urls.size();
+        long currentTimeMs = SystemClock.elapsedRealtime();
+        for (int i = 0; i < listSize; i++) {
+            HlsUrl url = urls.get(i);
+            MediaPlaylistBundle bundle = new MediaPlaylistBundle(url, currentTimeMs);
+            playlistBundles.put(urls.get(i), bundle);
+        }
+    }
 
-      HlsMediaPlaylist oldPlaylist = playlistSnapshot;
-      playlistSnapshot = adjustPlaylistTimestamps(oldPlaylist, loadedMediaPlaylist);
+    /**
+     * Called by the bundles when a snapshot changes.
+     *
+     * @param url         The url of the playlist.
+     * @param newSnapshot The new snapshot.
+     * @return True if a refresh should be scheduled.
+     */
+    private boolean onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
+        if (url == primaryHlsUrl) {
+            if (primaryUrlSnapshot == null) {
+                // This is the first primary url snapshot.
+                isLive = !newSnapshot.hasEndTag;
+            }
+            primaryUrlSnapshot = newSnapshot;
+            primaryPlaylistListener.onPrimaryPlaylistRefreshed(newSnapshot);
+        }
+        int listenersSize = listeners.size();
+        for (int i = 0; i < listenersSize; i++) {
+            listeners.get(i).onPlaylistChanged();
+        }
+        // If the primary playlist is not the final one, we should schedule a refresh.
+        return url == primaryHlsUrl && !newSnapshot.hasEndTag;
+    }
 
+    private void notifyPlaylistBlacklisting(HlsUrl url, long blacklistMs) {
+        int listenersSize = listeners.size();
+        for (int i = 0; i < listenersSize; i++) {
+            listeners.get(i).onPlaylistBlacklisted(url, blacklistMs);
+        }
+    }
 
-      long refreshDelayUs = C.TIME_UNSET;
-      if (oldPlaylist != playlistSnapshot) {
-        if (onPlaylistUpdated(playlistUrl, playlistSnapshot)) {
-          refreshDelayUs = playlistSnapshot.targetDurationUs;
+    /**
+     * TODO: Track discontinuities for media playlists that don't include the discontinuity number.
+     */
+    private HlsMediaPlaylist adjustPlaylistTimestamps(HlsMediaPlaylist oldPlaylist,
+                                                      HlsMediaPlaylist newPlaylist) {
+        // 如何处理视频上的不连续性?
+        if (newPlaylist.hasProgramDateTime) {
+            if (newPlaylist.isNewerThan(oldPlaylist)) {
+                return newPlaylist;
+            } else {
+                return oldPlaylist;
+            }
+        }
+        // TODO: Once playlist type support is added, the snapshot's age can be added by using the
+        // target duration.
+        long primarySnapshotStartTimeUs = primaryUrlSnapshot != null
+                ? primaryUrlSnapshot.startTimeUs : 0;
+        if (oldPlaylist == null) {
+            if (newPlaylist.startTimeUs == primarySnapshotStartTimeUs) {
+                // Playback has just started or is VOD so no adjustment is needed.
+                return newPlaylist;
+            } else {
+                return newPlaylist.copyWithStartTimeUs(primarySnapshotStartTimeUs);
+            }
+        }
+        List<Segment> oldSegments = oldPlaylist.segments;
+        int oldPlaylistSize = oldSegments.size();
+        if (!newPlaylist.isNewerThan(oldPlaylist)) {
+            // Playlist has not changed.
+            return oldPlaylist;
         }
-      } else if (!loadedMediaPlaylist.hasEndTag) {
-        refreshDelayUs = playlistSnapshot.targetDurationUs / 2;
-      }
-      if (refreshDelayUs != C.TIME_UNSET) {
-        // See HLS spec v20, section 6.3.4 for more information on media playlist refreshing.
-        playlistRefreshHandler.postDelayed(this, C.usToMs(refreshDelayUs));
-      }
+        int mediaSequenceOffset = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
+        if (mediaSequenceOffset <= oldPlaylistSize) {
+            long adjustedNewPlaylistStartTimeUs = mediaSequenceOffset == oldPlaylistSize
+                    ? oldPlaylist.getEndTimeUs()
+                    : oldPlaylist.startTimeUs + oldSegments.get(mediaSequenceOffset).relativeStartTimeUs;
+            return newPlaylist.copyWithStartTimeUs(adjustedNewPlaylistStartTimeUs);
+        }
+        // No segments overlap, we assume the new playlist start coincides with the primary playlist.
+        return newPlaylist.copyWithStartTimeUs(primarySnapshotStartTimeUs);
     }
 
-  }
+    /**
+     * Holds all information related to a specific Media Playlist.
+     */
+    private final class MediaPlaylistBundle implements Loader.Callback<ParsingLoadable<HlsPlaylist>>,
+            Runnable {
+
+        private final HlsUrl playlistUrl;
+        private final Loader mediaPlaylistLoader;
+        private final ParsingLoadable<HlsPlaylist> mediaPlaylistLoadable;
+
+        private HlsMediaPlaylist playlistSnapshot;
+        private long lastSnapshotAccessTimeMs;
+        private long blacklistUntilMs;
+
+        public MediaPlaylistBundle(HlsUrl playlistUrl, long initialLastSnapshotAccessTimeMs) {
+            this.playlistUrl = playlistUrl;
+            lastSnapshotAccessTimeMs = initialLastSnapshotAccessTimeMs;
+            mediaPlaylistLoader = new Loader("HlsPlaylistTracker:MediaPlaylist");
+
+            // 注意: Loadable的构建
+            // UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url)
+            // 可能是从master m3u8触发，获取子的m3u8文件的URL
+            //
+            mediaPlaylistLoadable = new ParsingLoadable<>(dataSourceFactory.createDataSource(),
+                    UriUtil.resolveToUri(masterPlaylist.baseUri, playlistUrl.url), C.DATA_TYPE_MANIFEST,
+                    playlistParser);
+        }
+
+        public HlsMediaPlaylist getPlaylistSnapshot() {
+            lastSnapshotAccessTimeMs = SystemClock.elapsedRealtime();
+            return playlistSnapshot;
+        }
+
+        public void release() {
+            mediaPlaylistLoader.release();
+        }
+
+        public void loadPlaylist() {
+            // 再次开始Loading
+            blacklistUntilMs = 0;
+            if (!mediaPlaylistLoader.isLoading()) {
+                mediaPlaylistLoader.startLoading(mediaPlaylistLoadable, this, minRetryCount);
+            }
+        }
+
+        // Loader.Callback implementation.
+
+        @Override
+        public void onLoadCompleted(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
+                                    long loadDurationMs) {
+            // 解析完毕
+            processLoadedPlaylist((HlsMediaPlaylist) loadable.getResult());
+
+            // 通知加载情况
+            eventDispatcher.loadCompleted(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+                    loadDurationMs, loadable.bytesLoaded());
+        }
+
+        @Override
+        public void onLoadCanceled(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
+                                   long loadDurationMs, boolean released) {
+            // 通知加载情况
+            eventDispatcher.loadCanceled(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+                    loadDurationMs, loadable.bytesLoaded());
+        }
+
+        @Override
+        public int onLoadError(ParsingLoadable<HlsPlaylist> loadable, long elapsedRealtimeMs,
+                               long loadDurationMs, IOException error) {
+            // 通知加载情况
+            boolean isFatal = error instanceof ParserException;
+            eventDispatcher.loadError(loadable.dataSpec, C.DATA_TYPE_MANIFEST, elapsedRealtimeMs,
+                    loadDurationMs, loadable.bytesLoaded(), error, isFatal);
+            if (isFatal) {
+                return Loader.DONT_RETRY_FATAL;
+            }
+
+            // 加载出错了，是否该重试呢?
+            // 如何监控这种情况呢?
+            boolean shouldRetry = true;
+            if (ChunkedTrackBlacklistUtil.shouldBlacklist(error)) {
+                blacklistUntilMs =
+                        SystemClock.elapsedRealtime() + ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS;
+                notifyPlaylistBlacklisting(playlistUrl,
+                        ChunkedTrackBlacklistUtil.DEFAULT_TRACK_BLACKLIST_MS);
+                shouldRetry = primaryHlsUrl == playlistUrl && !maybeSelectNewPrimaryUrl();
+            }
+            return shouldRetry ? Loader.RETRY : Loader.DONT_RETRY;
+        }
+
+        // Runnable implementation.
+
+        @Override
+        public void run() {
+            loadPlaylist();
+        }
+
+        // Internal methods.
+
+        private void processLoadedPlaylist(HlsMediaPlaylist loadedMediaPlaylist) {
+            // 认为: loadedMediaPlaylist 已经加载完毕，然后呢?
+
+            HlsMediaPlaylist oldPlaylist = playlistSnapshot;
+            playlistSnapshot = adjustPlaylistTimestamps(oldPlaylist, loadedMediaPlaylist);
+
+
+            long refreshDelayUs = C.TIME_UNSET;
+            if (oldPlaylist != playlistSnapshot) {
+                if (onPlaylistUpdated(playlistUrl, playlistSnapshot)) {
+                    refreshDelayUs = playlistSnapshot.targetDurationUs;
+                }
+            } else if (!loadedMediaPlaylist.hasEndTag) {
+                refreshDelayUs = playlistSnapshot.targetDurationUs / 2;
+            }
+            if (refreshDelayUs != C.TIME_UNSET) {
+                // See HLS spec v20, section 6.3.4 for more information on media playlist refreshing.
+                playlistRefreshHandler.postDelayed(this, C.usToMs(refreshDelayUs));
+            }
+        }
+
+    }
 
 }
