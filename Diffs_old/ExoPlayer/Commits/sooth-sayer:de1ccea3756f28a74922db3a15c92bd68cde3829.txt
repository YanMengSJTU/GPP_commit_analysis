diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
index 525617a3f2..f4d763c29a 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacExtractor.java
@@ -99,7 +99,7 @@ public long getPosition(long timeUs) {
 
       MediaFormat mediaFormat = MediaFormat.createAudioFormat(null, MimeTypes.AUDIO_RAW,
               streamInfo.bitRate(), MediaFormat.NO_VALUE, streamInfo.durationUs(),
-              streamInfo.channels, streamInfo.sampleRate, null, null);
+              streamInfo.channels, streamInfo.sampleRate, null, null, C.ENCODING_PCM_16BIT);
       trackOutput.format(mediaFormat);
 
       outputBuffer = new ParsableByteArray(streamInfo.maxDecodedFrameSize());
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
index e1b07e2162..4e4692fd56 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.ext.flac;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.CodecCounters;
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
@@ -343,7 +344,8 @@ private boolean readFormat(long positionUs) {
     int result = readSource(positionUs, formatHolder, null);
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
-      audioTrack.configure(format.getFrameworkMediaFormatV16(), false);
+      audioTrack.configure(MimeTypes.AUDIO_RAW, format.channelCount, format.sampleRate,
+          C.ENCODING_PCM_16BIT);
       return true;
     }
     return false;
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
index 5de3d46edb..c67eed99ae 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/LibopusAudioTrackRenderer.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.ext.opus;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.CodecCounters;
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
@@ -355,7 +356,8 @@ private boolean readFormat(long positionUs) {
     int result = readSource(positionUs, formatHolder, null);
     if (result == SampleSource.FORMAT_READ) {
       format = formatHolder.format;
-      audioTrack.configure(format.getFrameworkMediaFormatV16(), false);
+      audioTrack.configure(MimeTypes.AUDIO_RAW, format.channelCount, format.sampleRate,
+          C.ENCODING_PCM_16BIT);
       return true;
     }
     return false;
diff --git a/library/src/main/java/com/google/android/exoplayer/C.java b/library/src/main/java/com/google/android/exoplayer/C.java
index 622da04caf..b2c32bec9d 100644
--- a/library/src/main/java/com/google/android/exoplayer/C.java
+++ b/library/src/main/java/com/google/android/exoplayer/C.java
@@ -58,6 +58,26 @@
   @SuppressWarnings("InlinedApi")
   public static final int CRYPTO_MODE_AES_CTR = MediaCodec.CRYPTO_MODE_AES_CTR;
 
+  /**
+   * @see AudioFormat#ENCODING_INVALID
+   */
+  public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
+
+  /**
+   * @see AudioFormat#ENCODING_PCM_8BIT
+   */
+  public static final int ENCODING_PCM_8BIT = AudioFormat.ENCODING_PCM_8BIT;
+
+  /**
+   * @see AudioFormat#ENCODING_PCM_16BIT
+   */
+  public static final int ENCODING_PCM_16BIT = AudioFormat.ENCODING_PCM_16BIT;
+
+  /**
+   * PCM encoding with 24 bits per sample.
+   */
+  public static final int ENCODING_PCM_24BIT = 0x80000000;
+
   /**
    * @see AudioFormat#ENCODING_AC3
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
index b7a16768f9..fce7aa611c 100644
--- a/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/FrameworkSampleSource.java
@@ -326,10 +326,12 @@ private static MediaFormat createMediaFormat(android.media.MediaFormat format) {
     }
     long durationUs = format.containsKey(android.media.MediaFormat.KEY_DURATION)
         ? format.getLong(android.media.MediaFormat.KEY_DURATION) : C.UNKNOWN_TIME_US;
+    int pcmEncoding = MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT
+        : MediaFormat.NO_VALUE;
     MediaFormat mediaFormat = new MediaFormat(null, mimeType, MediaFormat.NO_VALUE, maxInputSize,
         durationUs, width, height, rotationDegrees, MediaFormat.NO_VALUE, channelCount, sampleRate,
         language, MediaFormat.OFFSET_SAMPLE_RELATIVE, initializationData, false,
-        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, encoderDelay, encoderPadding);
+        MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, pcmEncoding, encoderDelay, encoderPadding);
     mediaFormat.setFrameworkFormatV16(format);
     return mediaFormat;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index c54ac81b61..55cecdc367 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -91,6 +91,7 @@
 
   private boolean passthroughEnabled;
   private android.media.MediaFormat passthroughMediaFormat;
+  private int pcmEncoding;
   private int audioSessionId;
   private long currentPositionUs;
   private boolean allowPositionDiscontinuity;
@@ -264,10 +265,25 @@ protected MediaClock getMediaClock() {
     return this;
   }
 
+  @Override
+  protected void onInputFormatChanged(MediaFormatHolder holder) throws ExoPlaybackException {
+    super.onInputFormatChanged(holder);
+    // If the input format is anything other than PCM then we assume that the audio decoder will
+    // output 16-bit PCM.
+    pcmEncoding = MimeTypes.AUDIO_RAW.equals(holder.format.mimeType) ? holder.format.pcmEncoding
+        : C.ENCODING_PCM_16BIT;
+  }
+
   @Override
   protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat outputFormat) {
     boolean passthrough = passthroughMediaFormat != null;
-    audioTrack.configure(passthrough ? passthroughMediaFormat : outputFormat, passthrough);
+    String mimeType = passthrough
+        ? passthroughMediaFormat.getString(android.media.MediaFormat.KEY_MIME)
+        : MimeTypes.AUDIO_RAW;
+    android.media.MediaFormat format = passthrough ? passthroughMediaFormat : outputFormat;
+    int channelCount = format.getInteger(android.media.MediaFormat.KEY_CHANNEL_COUNT);
+    int sampleRate = format.getInteger(android.media.MediaFormat.KEY_SAMPLE_RATE);
+    audioTrack.configure(mimeType, channelCount, sampleRate, pcmEncoding);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index ec0b5f52f1..d11255bfd1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -935,9 +935,6 @@ private void processOutputFormat() throws ExoPlaybackException {
     if (codecNeedsMonoChannelCountWorkaround) {
       format.setInteger(android.media.MediaFormat.KEY_CHANNEL_COUNT, 1);
     }
-
-    if (this.format.bitdepth > 0)
-      format.setInteger(MediaFormat.BitDepthKey, this.format.bitdepth);
     onOutputFormatChanged(codec, format);
     codecCounters.outputFormatChangedCount++;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
index 0b6b621ecf..79c8b7775d 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaFormat.java
@@ -119,6 +119,12 @@
    * The audio sampling rate in Hz, or {@link #NO_VALUE} if unknown or not applicable.
    */
   public final int sampleRate;
+  /**
+   * The encoding for PCM audio streams. If {@link #mimeType} is {@link MimeTypes#AUDIO_RAW} then
+   * one of {@link C#ENCODING_PCM_8BIT}, {@link C#ENCODING_PCM_16BIT} and
+   * {@link C#ENCODING_PCM_24BIT}. Set to {@link #NO_VALUE} for other media types.
+   */
+  public final int pcmEncoding;
   /**
    * The number of samples to trim from the start of the decoded audio stream.
    */
@@ -147,13 +153,6 @@
   private int hashCode;
   private android.media.MediaFormat frameworkMediaFormat;
 
-  /**
-   * The bit depth of the track, or {@link #NO_VALUE} if unknown or not applicable.
-   */
-  public final int bitdepth;
-
-  public final static String BitDepthKey = "bitdepth";
-
   public static MediaFormat createVideoFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int width, int height, List<byte[]> initializationData) {
     return createVideoFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
@@ -165,22 +164,22 @@ public static MediaFormat createVideoFormat(String trackId, String mimeType, int
       int rotationDegrees, float pixelWidthHeightRatio) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
       int maxInputSize, long durationUs, int channelCount, int sampleRate,
       List<byte[]> initializationData, String language) {
-    return createAudioFormat(trackId, mimeType, NO_VALUE, bitrate, maxInputSize, durationUs,
-        channelCount, sampleRate, initializationData, language);
+    return createAudioFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, channelCount,
+        sampleRate, initializationData, language, NO_VALUE);
   }
 
-  public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitdepth,
-      int bitrate, int maxInputSize, long durationUs, int channelCount, int sampleRate,
-      List<byte[]> initializationData, String language) {
-    return new MediaFormat(trackId, mimeType, bitdepth, bitrate, maxInputSize, durationUs, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, channelCount, sampleRate, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+  public static MediaFormat createAudioFormat(String trackId, String mimeType, int bitrate,
+      int maxInputSize, long durationUs, int channelCount, int sampleRate,
+      List<byte[]> initializationData, String language, int pcmEncoding) {
+    return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, NO_VALUE, NO_VALUE,
+        NO_VALUE, NO_VALUE, channelCount, sampleRate, language, OFFSET_SAMPLE_RELATIVE,
+        initializationData, false, NO_VALUE, NO_VALUE, pcmEncoding, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createTextFormat(String trackId, String mimeType, int bitrate,
@@ -193,21 +192,21 @@ public static MediaFormat createTextFormat(String trackId, String mimeType, int
       long durationUs, String language, long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, subsampleOffsetUs, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createImageFormat(String trackId, String mimeType, int bitrate,
       long durationUs, List<byte[]> initializationData, String language) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, language, OFFSET_SAMPLE_RELATIVE,
-        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
+        initializationData, false, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createFormatForMimeType(String trackId, String mimeType, int bitrate,
       long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, false, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE);
+        NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public static MediaFormat createId3Format() {
@@ -219,18 +218,7 @@ public static MediaFormat createId3Format() {
       long durationUs, int width, int height, int rotationDegrees, float pixelWidthHeightRatio,
       int channelCount, int sampleRate, String language, long subsampleOffsetUs,
       List<byte[]> initializationData, boolean adaptive, int maxWidth, int maxHeight,
-      int encoderDelay, int encoderPadding) {
-    this(trackId, mimeType, NO_VALUE, bitrate, maxInputSize, durationUs, width, height,
-        rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
-  }
-
-  /* package */ MediaFormat(String trackId, String mimeType, int bitdepth, int bitrate,
-      int maxInputSize, long durationUs, int width, int height, int rotationDegrees,
-      float pixelWidthHeightRatio, int channelCount, int sampleRate, String language,
-      long subsampleOffsetUs, List<byte[]> initializationData, boolean adaptive,
-      int maxWidth, int maxHeight, int encoderDelay, int encoderPadding) {
+      int pcmEncoding, int encoderDelay, int encoderPadding) {
     this.trackId = trackId;
     this.mimeType = Assertions.checkNotEmpty(mimeType);
     this.bitrate = bitrate;
@@ -249,65 +237,65 @@ public static MediaFormat createId3Format() {
     this.adaptive = adaptive;
     this.maxWidth = maxWidth;
     this.maxHeight = maxHeight;
+    this.pcmEncoding = pcmEncoding;
     this.encoderDelay = encoderDelay;
     this.encoderPadding = encoderPadding;
-    this.bitdepth = bitdepth;
   }
 
   public MediaFormat copyWithMaxInputSize(int maxInputSize) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithMaxVideoDimensions(int maxWidth, int maxHeight) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithDurationUs(long durationUs) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithLanguage(String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyWithFixedTrackInfo(String trackId, int bitrate, int width, int height,
       String language) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, NO_VALUE, NO_VALUE, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   public MediaFormat copyAsAdaptive(String trackId) {
     return new MediaFormat(trackId, mimeType, NO_VALUE, NO_VALUE, durationUs, NO_VALUE, NO_VALUE,
         NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, null, OFFSET_SAMPLE_RELATIVE, null, true, maxWidth,
-        maxHeight, NO_VALUE, NO_VALUE);
+        maxHeight, NO_VALUE, NO_VALUE, NO_VALUE);
   }
 
   public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
     return new MediaFormat(trackId, mimeType, bitrate, maxInputSize, durationUs, width, height,
         rotationDegrees, pixelWidthHeightRatio, channelCount, sampleRate, language,
-        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, encoderDelay,
-        encoderPadding);
+        subsampleOffsetUs, initializationData, adaptive, maxWidth, maxHeight, pcmEncoding,
+        encoderDelay, encoderPadding);
   }
 
   /**
@@ -336,7 +324,6 @@ public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
       if (durationUs != C.UNKNOWN_TIME_US) {
         format.setLong(android.media.MediaFormat.KEY_DURATION, durationUs);
       }
-      maybeSetIntegerV16(format, BitDepthKey, bitdepth);
       frameworkMediaFormat = format;
     }
     return frameworkMediaFormat;
@@ -356,11 +343,11 @@ public MediaFormat copyWithGaplessInfo(int encoderDelay, int encoderPadding) {
 
   @Override
   public String toString() {
-    return "MediaFormat(" + trackId + ", " + mimeType + ", " + bitdepth + ", " + bitrate + ", " + maxInputSize
+    return "MediaFormat(" + trackId + ", " + mimeType + ", " + bitrate + ", " + maxInputSize
         + ", " + width + ", " + height + ", " + rotationDegrees + ", " + pixelWidthHeightRatio
         + ", " + channelCount + ", " + sampleRate + ", " + language + ", " + durationUs + ", "
-        + adaptive + ", " + maxWidth + ", " + maxHeight + ", " + encoderDelay + ", "
-        + encoderPadding + ")";
+        + adaptive + ", " + maxWidth + ", " + maxHeight + ", " + pcmEncoding + ", " + encoderDelay
+        + ", " + encoderPadding + ")";
   }
 
   @Override
@@ -369,7 +356,6 @@ public int hashCode() {
       int result = 17;
       result = 31 * result + (trackId == null ? 0 : trackId.hashCode());
       result = 31 * result + (mimeType == null ? 0 : mimeType.hashCode());
-      result = 31 * result + bitdepth;
       result = 31 * result + bitrate;
       result = 31 * result + maxInputSize;
       result = 31 * result + width;
@@ -380,10 +366,11 @@ public int hashCode() {
       result = 31 * result + (adaptive ? 1231 : 1237);
       result = 31 * result + maxWidth;
       result = 31 * result + maxHeight;
-      result = 31 * result + encoderDelay;
-      result = 31 * result + encoderPadding;
       result = 31 * result + channelCount;
       result = 31 * result + sampleRate;
+      result = 31 * result + pcmEncoding;
+      result = 31 * result + encoderDelay;
+      result = 31 * result + encoderPadding;
       result = 31 * result + (language == null ? 0 : language.hashCode());
       result = 31 * result + (int) subsampleOffsetUs;
       for (int i = 0; i < initializationData.size(); i++) {
@@ -405,13 +392,14 @@ public boolean equals(Object obj) {
     MediaFormat other = (MediaFormat) obj;
     if (adaptive != other.adaptive || bitrate != other.bitrate || maxInputSize != other.maxInputSize
         || durationUs != other.durationUs || width != other.width || height != other.height
-        || bitdepth != other.bitdepth || rotationDegrees != other.rotationDegrees
+        || rotationDegrees != other.rotationDegrees
         || pixelWidthHeightRatio != other.pixelWidthHeightRatio
         || maxWidth != other.maxWidth || maxHeight != other.maxHeight
-        || encoderDelay != other.encoderDelay || encoderPadding != other.encoderPadding
         || channelCount != other.channelCount || sampleRate != other.sampleRate
-        || subsampleOffsetUs != other.subsampleOffsetUs || !Util.areEqual(trackId, other.trackId)
-        || !Util.areEqual(language, other.language) || !Util.areEqual(mimeType, other.mimeType)
+        || pcmEncoding != other.pcmEncoding || encoderDelay != other.encoderDelay
+        || encoderPadding != other.encoderPadding || subsampleOffsetUs != other.subsampleOffsetUs
+        || !Util.areEqual(trackId, other.trackId) || !Util.areEqual(language, other.language)
+        || !Util.areEqual(mimeType, other.mimeType)
         || initializationData.size() != other.initializationData.size()) {
       return false;
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
index dd1ccfa49c..d7f47ac4fa 100644
--- a/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
+++ b/library/src/main/java/com/google/android/exoplayer/audio/AudioTrack.java
@@ -26,7 +26,6 @@
 import android.media.AudioFormat;
 import android.media.AudioManager;
 import android.media.AudioTimestamp;
-import android.media.MediaFormat;
 import android.media.PlaybackParams;
 import android.os.ConditionVariable;
 import android.os.SystemClock;
@@ -57,7 +56,6 @@
  * <p>
  * Call {@link #release()} when the instance will no longer be used.
  */
-@TargetApi(16)
 public final class AudioTrack {
 
   /**
@@ -201,11 +199,9 @@ public InvalidAudioTrackTimestampException(String message) {
   private android.media.AudioTrack audioTrack;
   private int sampleRate;
   private int channelConfig;
-  private int encoding;
+  private int sourceEncoding;
+  private int targetEncoding;
   private boolean passthrough;
-  private int channelCount;
-  private int configuredSpecifiedBufferSize;
-  private int pcmBitdepth;
   private int pcmFrameSize;
   private int bufferSize;
   private long bufferSizeUs;
@@ -231,8 +227,8 @@ public InvalidAudioTrackTimestampException(String message) {
   private int temporaryBufferOffset;
   private int bufferBytesRemaining;
 
-  ByteBuffer pcmConvertBuffer = null;
-  boolean usePCMConvertBuffer = false;
+  private ByteBuffer resampledBuffer;
+  private boolean useResampledBuffer;
 
   /**
    * Creates an audio track with default audio capabilities (no encoded audio passthrough support).
@@ -339,27 +335,31 @@ public long getCurrentPositionUs(boolean sourceEnded) {
   }
 
   /**
-   * Configures (or reconfigures) the audio track to play back media in {@code format}, inferring a
-   * buffer size from the format.
+   * Configures (or reconfigures) the audio track, inferring a suitable buffer size automatically.
    *
-   * @param format Specifies the channel count and sample rate to play back.
-   * @param passthrough Whether to play back using a passthrough encoding.
+   * @param mimeType The mime type.
+   * @param channelCount The number of channels.
+   * @param sampleRate The sample rate in Hz.
+   * @param pcmEncoding For PCM formats, the encoding used. One of {@link C#ENCODING_PCM_16BIT},
+   *     {@link C#ENCODING_PCM_16BIT} and {@link C#ENCODING_PCM_24BIT}.
    */
-  public void configure(MediaFormat format, boolean passthrough) {
-    configure(format, passthrough, 0);
+  public void configure(String mimeType, int channelCount, int sampleRate, int pcmEncoding) {
+    configure(mimeType, channelCount, sampleRate, pcmEncoding, 0);
   }
 
   /**
-   * Configures (or reconfigures) the audio track to play back media in {@code format}.
+   * Configures (or reconfigures) the audio track.
    *
-   * @param format Specifies the channel count and sample rate to play back.
-   * @param passthrough Whether to play back using a passthrough encoding.
-   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to use a
-   *     size inferred from the format.
+   * @param mimeType The mime type.
+   * @param channelCount The number of channels.
+   * @param sampleRate The sample rate in Hz.
+   * @param pcmEncoding For PCM formats, the encoding used. One of {@link C#ENCODING_PCM_16BIT},
+   *     {@link C#ENCODING_PCM_16BIT} and {@link C#ENCODING_PCM_24BIT}.
+   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
+   *     suitable buffer size automatically.
    */
-  public void configure(MediaFormat format, boolean passthrough, int specifiedBufferSize) {
-    channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
-    configuredSpecifiedBufferSize = specifiedBufferSize;
+  public void configure(String mimeType, int channelCount, int sampleRate, int pcmEncoding,
+      int specifiedBufferSize) {
     int channelConfig;
     switch (channelCount) {
       case 1:
@@ -389,84 +389,48 @@ public void configure(MediaFormat format, boolean passthrough, int specifiedBuff
       default:
         throw new IllegalArgumentException("Unsupported channel count: " + channelCount);
     }
-    int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
-    String mimeType = format.getString(MediaFormat.KEY_MIME);
-    int encoding = passthrough ? getEncodingForMimeType(mimeType) : AudioFormat.ENCODING_PCM_16BIT;
-    if (isInitialized() && this.sampleRate == sampleRate && this.channelConfig == channelConfig
-            && this.encoding == encoding) {
-      // We already have an audio track with the correct sample rate, encoding and channel config.
+
+    boolean passthrough = !MimeTypes.AUDIO_RAW.equals(mimeType);
+    int sourceEncoding;
+    if (passthrough) {
+      sourceEncoding = getEncodingForMimeType(mimeType);
+    } else if (pcmEncoding == C.ENCODING_PCM_8BIT || pcmEncoding == C.ENCODING_PCM_16BIT
+        || pcmEncoding == C.ENCODING_PCM_24BIT) {
+      sourceEncoding = pcmEncoding;
+    } else {
+      throw new IllegalArgumentException("Unsupported PCM encoding: " + pcmEncoding);
+    }
+
+    if (isInitialized() && this.sourceEncoding == sourceEncoding && this.sampleRate == sampleRate
+        && this.channelConfig == channelConfig) {
+      // We already have an audio track with the correct sample rate, channel config and encoding.
       return;
     }
 
     reset();
 
-    this.pcmBitdepth = mimeType.equals(MimeTypes.AUDIO_RAW) &&
-        format.containsKey(com.google.android.exoplayer.MediaFormat.BitDepthKey)
-        ? format.getInteger(com.google.android.exoplayer.MediaFormat.BitDepthKey) : -1;
-    if (encoding == AudioFormat.ENCODING_PCM_16BIT && pcmBitdepth != -1) {
-
-      switch (pcmBitdepth) {
-
-        case 8:
-          if (audioCapabilities.supportsEncoding(AudioFormat.ENCODING_PCM_8BIT))
-            encoding = AudioFormat.ENCODING_PCM_8BIT;
-          break;
-        case 24:
-          /*  TODO - write 24 - 32bit float conversion for <= two channel only
-          if (Util.SDK_INT >= 21 && channelCount > 2)
-              && audioCapabilities.supportsEncoding(AudioFormat.ENCODING_PCM_FLOAT))
-            encoding = AudioFormat.ENCODING_PCM_FLOAT;*/
-          break;
-        case 32:
-          // must be 32bit float
-          if (Util.SDK_INT >= 21 && audioCapabilities.supportsEncoding(AudioFormat.ENCODING_PCM_FLOAT))
-            encoding = AudioFormat.ENCODING_PCM_FLOAT;
-        default:
-          // don't do anything for 16bit
-          break;
-      }
-    }
-
+    this.sourceEncoding = sourceEncoding;
     this.passthrough = passthrough;
     this.sampleRate = sampleRate;
     this.channelConfig = channelConfig;
+    targetEncoding = passthrough ? sourceEncoding : C.ENCODING_PCM_16BIT;
+    pcmFrameSize = 2 * channelCount; // 2 bytes per 16-bit sample * number of channels.
 
-    configureFrameAndBufferSizes(encoding);
-  }
-
-  private int getPCMBytesPerChannel(int encoding) {
-
-    switch (encoding) {
-
-      case AudioFormat.ENCODING_PCM_8BIT:
-        return 1; // 1 bytes per 8 bit sample
-      case AudioFormat.ENCODING_PCM_FLOAT:
-        return 4; // 4 bytes per 32 bit sample
-      default:
-        return 2; // 2 bytes per 16 bit sample
-    }
-  }
-
-  private void configureFrameAndBufferSizes(int encoding) {
-
-    this.encoding = encoding;
-    pcmFrameSize = getPCMBytesPerChannel(encoding) * channelCount; // PCM BPC * number of channels.
-
-    if (configuredSpecifiedBufferSize != 0) {
-      bufferSize = configuredSpecifiedBufferSize;
+    if (specifiedBufferSize != 0) {
+      bufferSize = specifiedBufferSize;
     } else if (passthrough) {
       // TODO: Set the minimum buffer size using getMinBufferSize when it takes the encoding into
       // account. [Internal: b/25181305]
-      if (encoding == C.ENCODING_AC3 || encoding == C.ENCODING_E_AC3) {
+      if (targetEncoding == C.ENCODING_AC3 || targetEncoding == C.ENCODING_E_AC3) {
         // AC-3 allows bitrates up to 640 kbit/s.
         bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 80 * 1024 / C.MICROS_PER_SECOND);
-      } else { // encoding == C.ENCODING_DTS || encoding == C.ENCODING_DTS_HD
+      } else /* (targetEncoding == C.ENCODING_DTS || targetEncoding == C.ENCODING_DTS_HD) */ {
         // DTS allows an 'open' bitrate, but we assume the maximum listed value: 1536 kbit/s.
         bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 192 * 1024 / C.MICROS_PER_SECOND);
       }
     } else {
       int minBufferSize =
-          android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, encoding);
+          android.media.AudioTrack.getMinBufferSize(sampleRate, channelConfig, targetEncoding);
       Assertions.checkState(minBufferSize != android.media.AudioTrack.ERROR_BAD_VALUE);
       int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
       int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * pcmFrameSize;
@@ -504,7 +468,14 @@ public int initialize(int sessionId) throws InitializationException {
     // initialization of the audio track to fail.
     releasingConditionVariable.block();
 
-    createAudioTrack(sessionId);
+    if (sessionId == SESSION_ID_NOT_SET) {
+      audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
+          targetEncoding, bufferSize, android.media.AudioTrack.MODE_STREAM);
+    } else {
+      // Re-attach to the same audio session.
+      audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig,
+          targetEncoding, bufferSize, android.media.AudioTrack.MODE_STREAM, sessionId);
+    }
     checkAudioTrackInitialized();
 
     sessionId = audioTrack.getAudioSessionId();
@@ -519,7 +490,7 @@ public int initialize(int sessionId) throws InitializationException {
         if (keepSessionIdAudioTrack == null) {
           int sampleRate = 4000; // Equal to private android.media.AudioTrack.MIN_SAMPLE_RATE.
           int channelConfig = AudioFormat.CHANNEL_OUT_MONO;
-          int encoding = AudioFormat.ENCODING_PCM_16BIT;
+          int encoding = C.ENCODING_PCM_16BIT;
           int bufferSize = 2; // Use a two byte buffer, as it is not actually used for playback.
           keepSessionIdAudioTrack = new android.media.AudioTrack(streamType, sampleRate,
               channelConfig, encoding, bufferSize, android.media.AudioTrack.MODE_STATIC, sessionId);
@@ -533,36 +504,6 @@ public int initialize(int sessionId) throws InitializationException {
     return sessionId;
   }
 
-  private void createAudioTrack(int sessionId) throws IllegalArgumentException {
-
-    try {
-      if (sessionId == SESSION_ID_NOT_SET) {
-        audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig, encoding,
-                bufferSize, android.media.AudioTrack.MODE_STREAM);
-      } else {
-        // Re-attach to the same audio session.
-        audioTrack = new android.media.AudioTrack(streamType, sampleRate, channelConfig, encoding,
-                bufferSize, android.media.AudioTrack.MODE_STREAM, sessionId);
-      }
-    }
-    catch (IllegalArgumentException e) {
-
-      switch(encoding) {
-
-        case AudioFormat.ENCODING_PCM_8BIT:
-        case AudioFormat.ENCODING_PCM_FLOAT:
-          // if we tried to create 8 or 32 bit tracks when they aren't supported
-          // reset to 16bit and try again
-          configureFrameAndBufferSizes(AudioFormat.ENCODING_PCM_16BIT);
-          createAudioTrack(sessionId);
-          break;
-        default:
-          throw e;
-      }
-
-    }
-  }
-
   /**
    * Returns the size of this {@link AudioTrack}'s buffer in bytes.
    * <p>
@@ -648,22 +589,25 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
 
     int result = 0;
     if (bufferBytesRemaining == 0) {
-
-      usePCMConvertBuffer = false;
-      if (shouldConvertPCMInput()) {
-        usePCMConvertBuffer = convertPCMInput(buffer, offset, size);
-        if (usePCMConvertBuffer) {
-          size = pcmConvertBuffer.position();
-          pcmConvertBuffer.position(0);
-        }
-      }
       // The previous buffer (if there was one) was fully written to the audio track. We're now
       // seeing a new buffer for the first time.
+
+      useResampledBuffer = targetEncoding != sourceEncoding;
+      if (useResampledBuffer) {
+        Assertions.checkState(targetEncoding == C.ENCODING_PCM_16BIT);
+        // Resample the buffer to get the data in the target encoding.
+        resampledBuffer = resampleTo16BitPcm(buffer, offset, size, sourceEncoding, resampledBuffer);
+        // Use the resampled buffer, offset and size.
+        buffer = resampledBuffer;
+        offset = resampledBuffer.position();
+        size = resampledBuffer.limit();
+      }
+
       bufferBytesRemaining = size;
       buffer.position(offset);
       if (passthrough && framesPerEncodedSample == 0) {
         // If this is the first encoded sample, calculate the sample size in frames.
-        framesPerEncodedSample = getFramesPerEncodedSample(encoding, buffer);
+        framesPerEncodedSample = getFramesPerEncodedSample(targetEncoding, buffer);
       }
       if (startMediaTimeState == START_NOT_SET) {
         startMediaTimeUs = Math.max(0, presentationTimeUs);
@@ -708,10 +652,9 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
           temporaryBufferOffset += bytesWritten;
         }
       }
-    } else if (usePCMConvertBuffer) {
-      bytesWritten = writeNonBlockingV21(audioTrack, pcmConvertBuffer, bufferBytesRemaining);
     } else {
-      bytesWritten = writeNonBlockingV21(audioTrack, buffer, bufferBytesRemaining);
+      ByteBuffer data = useResampledBuffer ? resampledBuffer : buffer;
+      bytesWritten = writeNonBlockingV21(audioTrack, data, bufferBytesRemaining);
     }
 
     if (bytesWritten < 0) {
@@ -731,61 +674,6 @@ public int handleBuffer(ByteBuffer buffer, int offset, int size, long presentati
     return result;
   }
 
-  private boolean shouldConvertPCMInput() {
-
-    return (encoding == AudioFormat.ENCODING_PCM_16BIT && (pcmBitdepth == 24 || pcmBitdepth == 8));
-        //||(Util.SDK_INT >= 21 && encoding == AudioFormat.ENCODING_PCM_FLOAT && pcmBitdepth == 24);
-  }
-
-  private boolean convertPCMInput(ByteBuffer buffer, int offset, int size) {
-
-    if (pcmBitdepth == 24 && size < 3)
-      return false;
-
-    // if we are upconverting to 32 bit from 24 bit increase the buffer by 1/3
-    // if we are upconverting to 16bit from 8 bit double the buffer
-    // else we are downconverting to 16 from 24 bit make the buffer 2/3
-    int getMinBufferSize = encoding == AudioFormat.ENCODING_PCM_FLOAT ? (buffer.capacity() * 4)/3
-                           : pcmBitdepth == 8 ? buffer.capacity() * 2 : (buffer.capacity() * 2)/3;
-    if (pcmConvertBuffer == null || pcmConvertBuffer.capacity() < getMinBufferSize) {
-      pcmConvertBuffer = ByteBuffer.allocateDirect(getMinBufferSize);
-    }
-    pcmConvertBuffer.position(0);
-
-    int endPosition = offset + size;
-    buffer.position(offset);
-
-    // these conversions are little endian to little endian
-    /*if (encoding == AudioFormat.ENCODING_PCM_FLOAT) {
-      // 24->32 bit
-    }
-    else*/
-    if (pcmBitdepth == 8) {
-      // 8->16 bit, 8bit is an unsigned byte from 0-255, get back to -128,128 and then upconvert
-      final byte empty = 0;
-      int byte8;
-      while (endPosition > offset) {
-
-        byte8 = ((int)buffer.get()) - 128;
-        pcmConvertBuffer.put(empty);
-        pcmConvertBuffer.put((byte)(byte8 & 0xff));
-        ++offset;
-      }
-    }
-    else {
-      // 24->16 bit, drop the lowest byte to downconvert
-      int offsetOrig24 = offset;
-      while (endPosition > offsetOrig24) {
-        buffer.position(offsetOrig24 + 1);
-        pcmConvertBuffer.put(buffer.get());
-        pcmConvertBuffer.put(buffer.get());
-        offsetOrig24 += 3;
-      }
-    }
-
-    return true;
-  }
-
   /**
    * Ensures that the last data passed to {@link #handleBuffer(ByteBuffer, int, int, long)} is
    * played out in full.
@@ -796,12 +684,6 @@ public void handleEndOfStream() {
     }
   }
 
-  @TargetApi(21)
-  private static int writeNonBlockingV21(
-      android.media.AudioTrack audioTrack, ByteBuffer buffer, int size) {
-    return audioTrack.write(buffer, size, android.media.AudioTrack.WRITE_NON_BLOCKING);
-  }
-
   /**
    * Returns whether the audio track has more data pending that will be played back.
    */
@@ -821,7 +703,6 @@ public void setPlaybackParams(PlaybackParams playbackParams) {
     audioTrackUtil.setPlaybackParameters(playbackParams);
   }
 
-
   /**
    * Sets the playback volume.
    */
@@ -842,16 +723,6 @@ private void setAudioTrackVolume() {
     }
   }
 
-  @TargetApi(21)
-  private static void setAudioTrackVolumeV21(android.media.AudioTrack audioTrack, float volume) {
-    audioTrack.setVolume(volume);
-  }
-
-  @SuppressWarnings("deprecation")
-  private static void setAudioTrackVolumeV3(android.media.AudioTrack audioTrack, float volume) {
-    audioTrack.setStereoVolume(volume, volume);
-  }
-
   /**
    * Pauses playback.
    */
@@ -1072,7 +943,8 @@ private void resetSyncParams() {
    * See [Internal: b/18899620, b/19187573, b/21145353].
    */
   private boolean needsPassthroughWorkarounds() {
-    return Util.SDK_INT < 23 && (encoding == C.ENCODING_AC3 || encoding == C.ENCODING_E_AC3);
+    return Util.SDK_INT < 23
+        && (targetEncoding == C.ENCODING_AC3 || targetEncoding == C.ENCODING_E_AC3);
   }
 
   /**
@@ -1087,6 +959,64 @@ private boolean overrideHasPendingData() {
         && audioTrack.getPlaybackHeadPosition() == 0;
   }
 
+  /**
+   * Converts the provided buffer into 16-bit PCM.
+   *
+   * @param buffer The buffer containing the data to convert.
+   * @param offset The offset of the data in the buffer.
+   * @param size The size in bytes of the data in the buffer.
+   * @param sourceEncoding The data encoding.
+   * @param out A buffer into which the output should be written, if its capacity is sufficient.
+   * @return The 16-bit PCM output. Different to the out parameter if null was passed, or if the
+   *     capacity was insufficient for the output.
+   */
+  private static ByteBuffer resampleTo16BitPcm(ByteBuffer buffer, int offset, int size,
+      int sourceEncoding, ByteBuffer out) {
+    int resampledSize;
+    switch (sourceEncoding) {
+      case C.ENCODING_PCM_8BIT:
+        resampledSize = size * 2;
+        break;
+      case C.ENCODING_PCM_24BIT:
+        resampledSize = (size / 3) * 2;
+        break;
+      default:
+        // Never happens.
+        throw new IllegalStateException();
+    }
+
+    ByteBuffer resampledBuffer = out;
+    if (resampledBuffer == null || resampledBuffer.capacity() < resampledSize) {
+      resampledBuffer = ByteBuffer.allocateDirect(resampledSize);
+    }
+    resampledBuffer.position(0);
+    resampledBuffer.limit(resampledSize);
+
+    // Samples are little endian.
+    int limit = offset + size;
+    switch (sourceEncoding) {
+      case C.ENCODING_PCM_8BIT:
+        // 8->16 bit resampling. Shift each byte from [0, 256) to [-128, 128) and scale up.
+        for (int i = offset; i < limit; i++) {
+          resampledBuffer.put((byte) 0);
+          resampledBuffer.put((byte) ((buffer.get(i) & 0xFF) - 128));
+        }
+        break;
+      case C.ENCODING_PCM_24BIT:
+        // 24->16 bit resampling. Drop the least significant byte.
+        for (int i = offset; i < limit; i += 3) {
+          resampledBuffer.put(buffer.get(i));
+          resampledBuffer.put(buffer.get(i + 1));
+        }
+        break;
+      default:
+        // Never happens.
+        throw new IllegalStateException();
+    }
+
+    return resampledBuffer;
+  }
+
   private static int getEncodingForMimeType(String mimeType) {
     switch (mimeType) {
       case MimeTypes.AUDIO_AC3:
@@ -1098,7 +1028,7 @@ private static int getEncodingForMimeType(String mimeType) {
       case MimeTypes.AUDIO_DTS_HD:
         return C.ENCODING_DTS_HD;
       default:
-        return AudioFormat.ENCODING_INVALID;
+        return C.ENCODING_INVALID;
     }
   }
 
@@ -1114,6 +1044,22 @@ private static int getFramesPerEncodedSample(int encoding, ByteBuffer buffer) {
     }
   }
 
+  @TargetApi(21)
+  private static int writeNonBlockingV21(
+      android.media.AudioTrack audioTrack, ByteBuffer buffer, int size) {
+    return audioTrack.write(buffer, size, android.media.AudioTrack.WRITE_NON_BLOCKING);
+  }
+
+  @TargetApi(21)
+  private static void setAudioTrackVolumeV21(android.media.AudioTrack audioTrack, float volume) {
+    audioTrack.setVolume(volume);
+  }
+
+  @SuppressWarnings("deprecation")
+  private static void setAudioTrackVolumeV3(android.media.AudioTrack audioTrack, float volume) {
+    audioTrack.setStereoVolume(volume, volume);
+  }
+
   /**
    * Wraps an {@link android.media.AudioTrack} to expose useful utility methods.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 83e0e6675e..14e14e9952 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -910,10 +910,14 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       return;
     }
 
+    // TODO: Determine the correct PCM encoding.
+    int pcmEncoding = MimeTypes.AUDIO_RAW.equals(mimeType) ? C.ENCODING_PCM_16BIT
+        : MediaFormat.NO_VALUE;
+
     out.mediaFormat = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
         MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, durationUs, channelCount, sampleRate,
         initializationData == null ? null : Collections.singletonList(initializationData),
-        language);
+        language, pcmEncoding);
   }
 
   /** Returns the position of the esds box within a parent, or -1 if no esds box is found */
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
index c83da2f6d8..345c1aaf8d 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
@@ -90,7 +90,8 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
               wavHeader.getNumChannels(),
               wavHeader.getSampleRateHz(),
               null,
-              null));
+              null,
+              wavHeader.getEncoding()));
       extractorOutput.seekMap(this);
     }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
index 24fb83ecd8..4ebdfcbc45 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
@@ -30,6 +30,9 @@
   private final int blockAlignment;
   /** Bits per sample for the audio data. */
   private final int bitsPerSample;
+  /** The pcm encoding */
+  private final int encoding;
+
   /** Offset to the start of sample data. */
   private long dataStartPosition;
   /** Total size in bytes of the sample data. */
@@ -40,12 +43,14 @@ public WavHeader(
       int sampleRateHz,
       int averageBytesPerSecond,
       int blockAlignment,
-      int bitsPerSample) {
+      int bitsPerSample,
+      int encoding) {
     this.numChannels = numChannels;
     this.sampleRateHz = sampleRateHz;
     this.averageBytesPerSecond = averageBytesPerSecond;
     this.blockAlignment = blockAlignment;
     this.bitsPerSample = bitsPerSample;
+    this.encoding = encoding;
   }
 
   /** Returns the duration in microseconds of this WAV. */
@@ -110,4 +115,10 @@ public void setDataBounds(long dataStartPosition, long dataSize) {
     this.dataStartPosition = dataStartPosition;
     this.dataSize = dataSize;
   }
+
+  /** Returns the PCM encoding. **/
+  public int getEncoding() {
+    return encoding;
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
index f533c44939..ca220d523c 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.extractor.wav;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.util.Assertions;
@@ -88,8 +89,10 @@ public static WavHeader peek(ExtractorInput input)
       throw new ParserException("Expected block alignment: " + expectedBlockAlignment + "; got: "
           + blockAlignment);
     }
-    if (bitsPerSample != 16) {
-      Log.e(TAG, "Only 16-bit WAVs are supported; got: " + bitsPerSample);
+
+    int encoding = Util.getPcmEncoding(bitsPerSample);
+    if (encoding == C.ENCODING_INVALID) {
+      Log.e(TAG, "Unsupported WAV bit depth: " + bitsPerSample);
       return null;
     }
 
@@ -101,8 +104,8 @@ public static WavHeader peek(ExtractorInput input)
     // If present, skip extensionSize, validBitsPerSample, channelMask, subFormatGuid, ...
     input.advancePeekPosition((int) chunkHeader.size - 16);
 
-    return new WavHeader(
-        numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment, bitsPerSample);
+    return new WavHeader(numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment,
+        bitsPerSample, encoding);
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
index 77c59a3288..08a058ad03 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/webm/WebmExtractor.java
@@ -1217,6 +1217,7 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
         throws ParserException {
       String mimeType;
       int maxInputSize = MediaFormat.NO_VALUE;
+      int pcmEncoding = MediaFormat.NO_VALUE;
       List<byte[]> initializationData = null;
       switch (codecId) {
         case CODEC_ID_VP8:
@@ -1301,13 +1302,15 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
           if (!parseMsAcmCodecPrivate(new ParsableByteArray(codecPrivate))) {
             throw new ParserException("Non-PCM MS/ACM is unsupported");
           }
-          if (audioBitDepth != 16 && audioBitDepth != 24) {
+          pcmEncoding = Util.getPcmEncoding(audioBitDepth);
+          if (pcmEncoding == C.ENCODING_INVALID) {
             throw new ParserException("Unsupported PCM bit depth: " + audioBitDepth);
           }
           break;
         case CODEC_ID_PCM_INT_LIT:
           mimeType = MimeTypes.AUDIO_RAW;
-          if (audioBitDepth != 16 && audioBitDepth != 24) {
+          pcmEncoding = Util.getPcmEncoding(audioBitDepth);
+          if (pcmEncoding == C.ENCODING_INVALID) {
             throw new ParserException("Unsupported PCM bit depth: " + audioBitDepth);
           }
           break;
@@ -1329,9 +1332,9 @@ public void initializeOutput(ExtractorOutput output, int trackId, long durationU
       // TODO: Consider reading the name elements of the tracks and, if present, incorporating them
       // into the trackId passed when creating the formats.
       if (MimeTypes.isAudio(mimeType)) {
-        format = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType, audioBitDepth,
+        format = MediaFormat.createAudioFormat(Integer.toString(trackId), mimeType,
             MediaFormat.NO_VALUE, maxInputSize, durationUs, channelCount, sampleRate,
-            initializationData, language);
+            initializationData, language, pcmEncoding);
       } else if (MimeTypes.isVideo(mimeType)) {
         if (displayUnit == Track.DISPLAY_UNIT_PIXELS) {
           displayWidth = displayWidth == MediaFormat.NO_VALUE ? width : displayWidth;
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index 73accd5ad8..efad3ecc1f 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -769,6 +769,27 @@ public static String getUserAgent(Context context, String applicationName) {
     }
   }
 
+  /**
+   * Converts a sample bit depth to a corresponding PCM encoding constant.
+   *
+   * @param bitDepth The bit depth. Supported values are 8, 16 and 24.
+   * @return The corresponding encoding. One of {@link C#ENCODING_PCM_8BIT},
+   *     {@link C#ENCODING_PCM_16BIT} and {@link C#ENCODING_PCM_24BIT}. If the bit depth is
+   *     unsupported then {@link C#ENCODING_INVALID} is returned.
+   */
+  public static int getPcmEncoding(int bitDepth) {
+    switch (bitDepth) {
+      case 8:
+        return C.ENCODING_PCM_8BIT;
+      case 16:
+        return C.ENCODING_PCM_16BIT;
+      case 24:
+        return C.ENCODING_PCM_24BIT;
+      default:
+        return C.ENCODING_INVALID;
+    }
+  }
+
   /**
    * Makes a best guess to infer the type from a file name.
    *
