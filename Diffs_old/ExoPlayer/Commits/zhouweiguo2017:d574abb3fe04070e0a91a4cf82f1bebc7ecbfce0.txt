diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
index fe94acf3cd..6ded24c563 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsReader.java
@@ -17,7 +17,6 @@
 
 import android.util.Log;
 import android.util.Pair;
-
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
@@ -29,7 +28,6 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import com.google.android.exoplayer2.util.ParsableByteArray;
-
 import java.util.Arrays;
 import java.util.Collections;
 
@@ -38,396 +36,411 @@
  */
 public final class AdtsReader implements ElementaryStreamReader {
 
-    private static final String TAG = "AdtsReader";
-
-    private static final int STATE_FINDING_SAMPLE = 0;
-    private static final int STATE_READING_ID3_HEADER = 1;
-    private static final int STATE_READING_ADTS_HEADER = 2;
-    private static final int STATE_READING_SAMPLE = 3;
-
-    private static final int HEADER_SIZE = 5;
-    private static final int CRC_SIZE = 2;
-
-    // Match states used while looking for the next sample
-    private static final int MATCH_STATE_VALUE_SHIFT = 8;
-    private static final int MATCH_STATE_START = 1 << MATCH_STATE_VALUE_SHIFT;
-    private static final int MATCH_STATE_FF = 2 << MATCH_STATE_VALUE_SHIFT;
-    private static final int MATCH_STATE_I = 3 << MATCH_STATE_VALUE_SHIFT;
-    private static final int MATCH_STATE_ID = 4 << MATCH_STATE_VALUE_SHIFT;
-
-    private static final int ID3_HEADER_SIZE = 10;
-    private static final int ID3_SIZE_OFFSET = 6;
-    private static final byte[] ID3_IDENTIFIER = {'I', 'D', '3'};
-
-    private final boolean exposeId3;
-    private final ParsableBitArray adtsScratch;
-    private final ParsableByteArray id3HeaderBuffer;
-    private final String language;
-
-    private String formatId;
-    private TrackOutput output;
-    private TrackOutput id3Output;
-
-    private int state;
-    private int bytesRead;
-
-    private int matchState;
-
-    private boolean hasCrc;
-
-    // Used when parsing the header.
-    private boolean hasOutputFormat;
-    private long sampleDurationUs;
-    private int sampleSize;
-
-    // Used when reading the samples.
-    private long timeUs;
-
-    private TrackOutput currentOutput;
-    private long currentSampleDuration;
-
-    private int mMode = C.TS_STREAM_TYPE_AAC;
-    private String encryptionMethod;
-    private byte[] encryptionKey;
-    private byte[] encryptionIv;
-    private ParsableByteArray sampleData;
-    private int writtenSampleSize;
-    private boolean bMyCode;
-    private boolean bParseID3;
-    private boolean bFirstSample;
-    private long totalBytesWritten;
-
-    /**
-     * @param exposeId3 True if the reader should expose ID3 information.
-     */
-    public AdtsReader(boolean exposeId3) {
-        this(exposeId3, null);
-    }
-
-    /**
-     * @param exposeId3 True if the reader should expose ID3 information.
-     * @param language  Track language.
-     */
-    public AdtsReader(boolean exposeId3, String language) {
-        adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
-        id3HeaderBuffer = new ParsableByteArray(Arrays.copyOf(ID3_IDENTIFIER, ID3_HEADER_SIZE));
-        setFindingSampleState();
-        this.exposeId3 = exposeId3;
-        this.language = language;
-
-        bMyCode = false;//TODO:original code could handle AAC audio well, need further investigation here
-        bParseID3 = false;
-        bFirstSample = true;
-        sampleData = new ParsableByteArray();
-        totalBytesWritten = 0;
-    }
-
-    public AdtsReader(boolean exposeId3, String language, int streamType, HLSEncryptInfo hlsEncryptInfo) {
-        this(exposeId3, language);
-
-        this.mMode = streamType;
-        this.encryptionKey = hlsEncryptInfo.encryptionKey;
-        this.encryptionIv = hlsEncryptInfo.encryptionIv;
-    }
-
-    /*
-      support pure sample-aes aac audio content
-     */
-    public AdtsReader(boolean exposeId3, int streamType, byte[] encryptionKey, byte[] encryptionIv) {
-        this(exposeId3, null);
-
-        this.mMode = streamType;
-        this.encryptionKey = encryptionKey;
-        this.encryptionIv = encryptionIv;
+  private static final String TAG = "AdtsReader";
+
+  private static final int STATE_FINDING_SAMPLE = 0;
+  private static final int STATE_READING_ID3_HEADER = 1;
+  private static final int STATE_READING_ADTS_HEADER = 2;
+  private static final int STATE_READING_SAMPLE = 3;
+
+  private static final int HEADER_SIZE = 5;
+  private static final int CRC_SIZE = 2;
+
+  // Match states used while looking for the next sample
+  private static final int MATCH_STATE_VALUE_SHIFT = 8;
+  private static final int MATCH_STATE_START = 1 << MATCH_STATE_VALUE_SHIFT;
+  private static final int MATCH_STATE_FF = 2 << MATCH_STATE_VALUE_SHIFT;
+  private static final int MATCH_STATE_I = 3 << MATCH_STATE_VALUE_SHIFT;
+  private static final int MATCH_STATE_ID = 4 << MATCH_STATE_VALUE_SHIFT;
+
+  private static final int ID3_HEADER_SIZE = 10;
+  private static final int ID3_SIZE_OFFSET = 6;
+  private static final byte[] ID3_IDENTIFIER = {'I', 'D', '3'};
+
+  private final boolean exposeId3;
+  private final ParsableBitArray adtsScratch;
+  private final ParsableByteArray id3HeaderBuffer;
+  private final String language;
+
+  private String formatId;
+  private TrackOutput output;
+  private TrackOutput id3Output;
+
+  private int state;
+  private int bytesRead;
+
+  private int matchState;
+
+  private boolean hasCrc;
+
+  // Used when parsing the header.
+  private boolean hasOutputFormat;
+  private long sampleDurationUs;
+  private int sampleSize;
+
+  // Used when reading the samples.
+  private long timeUs;
+
+  private TrackOutput currentOutput;
+  private long currentSampleDuration;
+
+  private int mMode = C.TS_STREAM_TYPE_AAC;
+  private String encryptionMethod;
+  private byte[] encryptionKey;
+  private byte[] encryptionIv;
+  private ParsableByteArray sampleData;
+  private int writtenSampleSize;
+  private boolean bMyCode;
+  private boolean bParseID3;
+  private boolean bFirstSample;
+  private long totalBytesWritten;
+
+  /**
+   * @param exposeId3 True if the reader should expose ID3 information.
+   */
+  public AdtsReader(boolean exposeId3) {
+    this(exposeId3, null);
+  }
+
+  /**
+   * @param exposeId3 True if the reader should expose ID3 information.
+   * @param language Track language.
+   */
+  public AdtsReader(boolean exposeId3, String language) {
+    adtsScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
+    id3HeaderBuffer = new ParsableByteArray(Arrays.copyOf(ID3_IDENTIFIER, ID3_HEADER_SIZE));
+    setFindingSampleState();
+    this.exposeId3 = exposeId3;
+    this.language = language;
+
+    bFirstSample = true;
+    sampleData = new ParsableByteArray();
+  }
+
+  public AdtsReader(boolean exposeId3, String language, int streamType, HLSEncryptInfo hlsEncryptInfo) {
+    this(exposeId3, language);
+
+    this.mMode = streamType;
+    this.encryptionKey = hlsEncryptInfo.encryptionKey;
+    this.encryptionIv = hlsEncryptInfo.encryptionIv;
+  }
+
+  public AdtsReader(boolean exposeId3, int streamType, byte[] encryptionKey, byte[] encryptionIv) {
+    this(exposeId3, null);
+
+    this.mMode = streamType;
+    this.encryptionKey = encryptionKey;
+    this.encryptionIv = encryptionIv;
+  }
+
+  @Override
+  public void seek() {
+    setFindingSampleState();
+  }
+
+  @Override
+  public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
+    idGenerator.generateNewId();
+    formatId = idGenerator.getFormatId();
+    output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_AUDIO);
+    if (exposeId3) {
+      idGenerator.generateNewId();
+      id3Output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_METADATA);
+      id3Output.format(Format.createSampleFormat(idGenerator.getFormatId(),
+          MimeTypes.APPLICATION_ID3, null, Format.NO_VALUE, null));
+    } else {
+      id3Output = new DummyTrackOutput();
     }
-
-    @Override
-    public void seek() {
-        setFindingSampleState();
-    }
-
-    @Override
-    public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
-        idGenerator.generateNewId();
-        formatId = idGenerator.getFormatId();
-        output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_AUDIO);
-        if (exposeId3) {
-            idGenerator.generateNewId();
-            id3Output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_METADATA);
-            id3Output.format(Format.createSampleFormat(idGenerator.getFormatId(),
-                    MimeTypes.APPLICATION_ID3, null, Format.NO_VALUE, null));
-        } else {
-            id3Output = new DummyTrackOutput();
+  }
+
+  @Override
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    timeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
+    int offset = data.getPosition();
+    int limit = data.limit();
+    int size = data.bytesLeft();
+
+    totalBytesWritten += data.bytesLeft();
+
+    if (bMyCode) {
+      if (bFirstSample) {
+        bFirstSample = false;
+        sampleData.reset((int) totalBytesWritten);
+        System.arraycopy(data.data, offset, sampleData.data, sampleData.getPosition(), size);
+      } else {
+        int curLeft = sampleData.bytesLeft();
+        byte[] leftData = new byte[curLeft];
+        if (curLeft > 0) {
+          System.arraycopy(sampleData.data, sampleData.getPosition(), leftData, 0, curLeft);
         }
-    }
-
-    @Override
-    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-        timeUs = pesTimeUs;
-    }
-
-    @Override
-    public void consume(ParsableByteArray data) {
-        while (data.bytesLeft() > 0) {
-            switch (state) {
-                case STATE_FINDING_SAMPLE:
-                    findNextSample(data);
-                    break;
-                case STATE_READING_ID3_HEADER:
-                    if (continueRead(data, id3HeaderBuffer.data, ID3_HEADER_SIZE)) {
-                        parseId3Header();
-                    }
-                    break;
-                case STATE_READING_ADTS_HEADER:
-                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
-                    if (continueRead(data, adtsScratch.data, targetLength)) {
-                        parseAdtsHeader();
-                    }
-                    break;
-                case STATE_READING_SAMPLE:
-                    readSample(data);
-                    break;
-            }
+        sampleData.reset(curLeft + size);
+        if (curLeft > 0) {
+          System.arraycopy(leftData, 0, sampleData.data, 0, curLeft);
         }
+        System.arraycopy(data.data, offset, sampleData.data, curLeft, size);
+      }
     }
 
-    @Override
-    public void packetFinished() {
-        // Do nothing.
+    while (data.bytesLeft() > 0) {
+      switch (state) {
+        case STATE_FINDING_SAMPLE:
+          findNextSample(data);
+          break;
+        case STATE_READING_ID3_HEADER:
+          if (continueRead(data, id3HeaderBuffer.data, ID3_HEADER_SIZE)) {
+            parseId3Header();
+          }
+          break;
+        case STATE_READING_ADTS_HEADER:
+          int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
+          if (continueRead(data, adtsScratch.data, targetLength)) {
+            parseAdtsHeader();
+          }
+          break;
+        case STATE_READING_SAMPLE:
+          readSample(data);
+          break;
+      }
     }
-
-    /**
-     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
-     * that the data should be written into {@code target} starting from an offset of zero.
-     *
-     * @param source       The source from which to read.
-     * @param target       The target into which data is to be read.
-     * @param targetLength The target length of the read.
-     * @return Whether the target length was reached.
-     */
-    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
-        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
-        source.readBytes(target, bytesRead, bytesToRead);
-        bytesRead += bytesToRead;
-        return bytesRead == targetLength;
-    }
-
-    /**
-     * Sets the state to STATE_FINDING_SAMPLE.
-     */
-    private void setFindingSampleState() {
-        state = STATE_FINDING_SAMPLE;
-        bytesRead = 0;
-        matchState = MATCH_STATE_START;
+  }
+
+  @Override
+  public void packetFinished() {
+    // Do nothing.
+  }
+
+  /**
+   * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
+   * that the data should be written into {@code target} starting from an offset of zero.
+   *
+   * @param source The source from which to read.
+   * @param target The target into which data is to be read.
+   * @param targetLength The target length of the read.
+   * @return Whether the target length was reached.
+   */
+  private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
+    int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
+    source.readBytes(target, bytesRead, bytesToRead);
+    bytesRead += bytesToRead;
+    return bytesRead == targetLength;
+  }
+
+  /**
+   * Sets the state to STATE_FINDING_SAMPLE.
+   */
+  private void setFindingSampleState() {
+    state = STATE_FINDING_SAMPLE;
+    bytesRead = 0;
+    matchState = MATCH_STATE_START;
+  }
+
+  /**
+   * Sets the state to STATE_READING_ID3_HEADER and resets the fields required for
+   * {@link #parseId3Header()}.
+   */
+  private void setReadingId3HeaderState() {
+    state = STATE_READING_ID3_HEADER;
+    bytesRead = ID3_IDENTIFIER.length;
+    sampleSize = 0;
+    id3HeaderBuffer.setPosition(0);
+  }
+
+  /**
+   * Sets the state to STATE_READING_SAMPLE.
+   *
+   * @param outputToUse TrackOutput object to write the sample to
+   * @param currentSampleDuration Duration of the sample to be read
+   * @param priorReadBytes Size of prior read bytes
+   * @param sampleSize Size of the sample
+   */
+  private void setReadingSampleState(TrackOutput outputToUse, long currentSampleDuration,
+      int priorReadBytes, int sampleSize) {
+    state = STATE_READING_SAMPLE;
+    bytesRead = priorReadBytes;
+    this.currentOutput = outputToUse;
+    this.currentSampleDuration = currentSampleDuration;
+    this.sampleSize = sampleSize;
+  }
+
+  /**
+   * Sets the state to STATE_READING_ADTS_HEADER.
+   */
+  private void setReadingAdtsHeaderState() {
+    state = STATE_READING_ADTS_HEADER;
+    bytesRead = 0;
+  }
+
+  /**
+   * Locates the next sample start, advancing the position to the byte that immediately follows
+   * identifier. If a sample was not located, the position is advanced to the limit.
+   *
+   * @param pesBuffer The buffer whose position should be advanced.
+   */
+  private void findNextSample(ParsableByteArray pesBuffer) {
+    byte[] adtsData = pesBuffer.data;
+    int position = pesBuffer.getPosition();
+    int endOffset = pesBuffer.limit();
+    bParseID3 = false;
+    while (position < endOffset) {
+      int data = adtsData[position++] & 0xFF;
+      if (matchState == MATCH_STATE_FF && data >= 0xF0 && data != 0xFF) {
+        hasCrc = (data & 0x1) == 0;
+        setReadingAdtsHeaderState();
+        pesBuffer.setPosition(position);
+        return;
+      }
+      switch (matchState | data) {
+        case MATCH_STATE_START | 0xFF:
+          matchState = MATCH_STATE_FF;
+          break;
+        case MATCH_STATE_START | 'I':
+          matchState = MATCH_STATE_I;
+          break;
+        case MATCH_STATE_I | 'D':
+          matchState = MATCH_STATE_ID;
+          break;
+        case MATCH_STATE_ID | '3':
+          setReadingId3HeaderState();
+          pesBuffer.setPosition(position);
+          bParseID3 = true;
+          return;
+        default:
+          if (matchState != MATCH_STATE_START) {
+            // If matching fails in a later state, revert to MATCH_STATE_START and
+            // check this byte again
+            matchState = MATCH_STATE_START;
+            position--;
+          }
+          break;
+      }
     }
-
-    /**
-     * Sets the state to STATE_READING_ID3_HEADER and resets the fields required for
-     * {@link #parseId3Header()}.
-     */
-    private void setReadingId3HeaderState() {
-        state = STATE_READING_ID3_HEADER;
-        bytesRead = ID3_IDENTIFIER.length;
-        sampleSize = 0;
-        id3HeaderBuffer.setPosition(0);
+    pesBuffer.setPosition(position);
+  }
+
+  /**
+   * Parses the Id3 header.
+   */
+  private void parseId3Header() {
+    id3Output.sampleData(id3HeaderBuffer, ID3_HEADER_SIZE);
+    id3HeaderBuffer.setPosition(ID3_SIZE_OFFSET);
+    setReadingSampleState(id3Output, 0, ID3_HEADER_SIZE,
+        id3HeaderBuffer.readSynchSafeInt() + ID3_HEADER_SIZE);
+  }
+
+  /**
+   * Parses the sample header.
+   */
+  private void parseAdtsHeader() {
+    adtsScratch.setPosition(0);
+
+    if (!hasOutputFormat) {
+      int audioObjectType = adtsScratch.readBits(2) + 1;
+      if (audioObjectType != 2) {
+        // The stream indicates AAC-Main (1), AAC-SSR (3) or AAC-LTP (4). When the stream indicates
+        // AAC-Main it's more likely that the stream contains HE-AAC (5), which cannot be
+        // represented correctly in the 2 bit audio_object_type field in the ADTS header. In
+        // practice when the stream indicates AAC-SSR or AAC-LTP it more commonly contains AAC-LC or
+        // HE-AAC. Since most Android devices don't support AAC-Main, AAC-SSR or AAC-LTP, and since
+        // indicating AAC-LC works for HE-AAC streams, we pretend that we're dealing with AAC-LC and
+        // hope for the best. In practice this often works.
+        // See: https://github.com/google/ExoPlayer/issues/774
+        // See: https://github.com/google/ExoPlayer/issues/1383
+        Log.w(TAG, "Detected audio object type: " + audioObjectType + ", but assuming AAC LC.");
+        audioObjectType = 2;
+      }
+
+      int sampleRateIndex = adtsScratch.readBits(4);
+      adtsScratch.skipBits(1);
+      int channelConfig = adtsScratch.readBits(3);
+
+      byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAacAudioSpecificConfig(
+          audioObjectType, sampleRateIndex, channelConfig);
+      Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
+          audioSpecificConfig);
+
+      Format format = Format.createAudioSampleFormat(formatId, MimeTypes.AUDIO_AAC, null,
+          Format.NO_VALUE, Format.NO_VALUE, audioParams.second, audioParams.first,
+          Collections.singletonList(audioSpecificConfig), null, 0, language);
+      // In this class a sample is an access unit, but the MediaFormat sample rate specifies the
+      // number of PCM audio samples per second.
+      sampleDurationUs = (C.MICROS_PER_SECOND * 1024) / format.sampleRate;
+      output.format(format);
+      hasOutputFormat = true;
+    } else {
+      adtsScratch.skipBits(10);
     }
 
-    /**
-     * Sets the state to STATE_READING_SAMPLE.
-     *
-     * @param outputToUse           TrackOutput object to write the sample to
-     * @param currentSampleDuration Duration of the sample to be read
-     * @param priorReadBytes        Size of prior read bytes
-     * @param sampleSize            Size of the sample
-     */
-    private void setReadingSampleState(TrackOutput outputToUse, long currentSampleDuration,
-                                       int priorReadBytes, int sampleSize) {
-        state = STATE_READING_SAMPLE;
-        bytesRead = priorReadBytes;
-        this.currentOutput = outputToUse;
-        this.currentSampleDuration = currentSampleDuration;
-        this.sampleSize = sampleSize;
+    adtsScratch.skipBits(4);
+    int sampleSize = adtsScratch.readBits(13) - 2 /* the sync word */ - HEADER_SIZE;
+    if (hasCrc) {
+      sampleSize -= CRC_SIZE;
     }
 
-    /**
-     * Sets the state to STATE_READING_ADTS_HEADER.
-     */
-    private void setReadingAdtsHeaderState() {
-        state = STATE_READING_ADTS_HEADER;
-        bytesRead = 0;
-    }
+    setReadingSampleState(output, sampleDurationUs, 0, sampleSize);
+  }
 
-    /**
-     * Locates the next sample start, advancing the position to the byte that immediately follows
-     * identifier. If a sample was not located, the position is advanced to the limit.
-     *
-     * @param pesBuffer The buffer whose position should be advanced.
-     */
-    private void findNextSample(ParsableByteArray pesBuffer) {
-        byte[] adtsData = pesBuffer.data;
-        int position = pesBuffer.getPosition();
-        int endOffset = pesBuffer.limit();
-        while (position < endOffset) {
-            int data = adtsData[position++] & 0xFF;
-            if (matchState == MATCH_STATE_FF && data >= 0xF0 && data != 0xFF) {
-                hasCrc = (data & 0x1) == 0;
-                setReadingAdtsHeaderState();
-                pesBuffer.setPosition(position);
-                return;
-            }
-            switch (matchState | data) {
-                case MATCH_STATE_START | 0xFF:
-                    matchState = MATCH_STATE_FF;
-                    break;
-                case MATCH_STATE_START | 'I':
-                    matchState = MATCH_STATE_I;
-                    break;
-                case MATCH_STATE_I | 'D':
-                    matchState = MATCH_STATE_ID;
-                    break;
-                case MATCH_STATE_ID | '3':
-                    setReadingId3HeaderState();
-                    pesBuffer.setPosition(position);
-                    return;
-                default:
-                    if (matchState != MATCH_STATE_START) {
-                        // If matching fails in a later state, revert to MATCH_STATE_START and
-                        // check this byte again
-                        matchState = MATCH_STATE_START;
-                        position--;
-                    }
-                    break;
-            }
-        }
-        pesBuffer.setPosition(position);
-    }
+  /**
+   * Reads the rest of the sample
+   */
+  private void readSample(ParsableByteArray data) {
+    int skipSize = 0;
+    int realSampleSize = 0;
 
-    /**
-     * Parses the Id3 header.
-     */
-    private void parseId3Header() {
-        id3Output.sampleData(id3HeaderBuffer, ID3_HEADER_SIZE);
-        id3HeaderBuffer.setPosition(ID3_SIZE_OFFSET);
-        setReadingSampleState(id3Output, 0, ID3_HEADER_SIZE,
-                id3HeaderBuffer.readSynchSafeInt() + ID3_HEADER_SIZE);
+    int headerSize = 2 /* the sync word */ + HEADER_SIZE;
+    if (hasCrc) {
+      headerSize += CRC_SIZE;
     }
 
-    /**
-     * Parses the sample header.
-     */
-    private void parseAdtsHeader() {
-        adtsScratch.setPosition(0);
-
-        if (!hasOutputFormat) {
-            int audioObjectType = adtsScratch.readBits(2) + 1;
-            if (audioObjectType != 2) {
-                // The stream indicates AAC-Main (1), AAC-SSR (3) or AAC-LTP (4). When the stream indicates
-                // AAC-Main it's more likely that the stream contains HE-AAC (5), which cannot be
-                // represented correctly in the 2 bit audio_object_type field in the ADTS header. In
-                // practice when the stream indicates AAC-SSR or AAC-LTP it more commonly contains AAC-LC or
-                // HE-AAC. Since most Android devices don't support AAC-Main, AAC-SSR or AAC-LTP, and since
-                // indicating AAC-LC works for HE-AAC streams, we pretend that we're dealing with AAC-LC and
-                // hope for the best. In practice this often works.
-                // See: https://github.com/google/ExoPlayer/issues/774
-                // See: https://github.com/google/ExoPlayer/issues/1383
-                Log.w(TAG, "Detected audio object type: " + audioObjectType + ", but assuming AAC LC.");
-                audioObjectType = 2;
-            }
-
-            int sampleRateIndex = adtsScratch.readBits(4);
-            adtsScratch.skipBits(1);
-            int channelConfig = adtsScratch.readBits(3);
-
-            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAacAudioSpecificConfig(
-                    audioObjectType, sampleRateIndex, channelConfig);
-            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAacAudioSpecificConfig(
-                    audioSpecificConfig);
-
-            Format format = Format.createAudioSampleFormat(formatId, MimeTypes.AUDIO_AAC, null,
-                    Format.NO_VALUE, Format.NO_VALUE, audioParams.second, audioParams.first,
-                    Collections.singletonList(audioSpecificConfig), null, 0, language);
-            // In this class a sample is an access unit, but the MediaFormat sample rate specifies the
-            // number of PCM audio samples per second.
-            sampleDurationUs = (C.MICROS_PER_SECOND * 1024) / format.sampleRate;
-            output.format(format);
-            hasOutputFormat = true;
-        } else {
-            adtsScratch.skipBits(10);
-        }
+    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
 
-        adtsScratch.skipBits(4);
-        int sampleSize = adtsScratch.readBits(13) - 2 /* the sync word */ - HEADER_SIZE;
-        if (hasCrc) {
-            sampleSize -= CRC_SIZE;
-        }
-
-        setReadingSampleState(output, sampleDurationUs, 0, sampleSize);
+    if (bMyCode) {
+      if (bParseID3)
+        skipSize = bytesRead;
+      else
+        skipSize = headerSize;// when ID3 parsed, bytesRead != 0
     }
 
-    /**
-     * Reads the rest of the sample
-     */
-    private void readSample(ParsableByteArray data) {
-        int skipSize = 0;
-        int realSampleSize = 0;
+    if (!bMyCode) {
+      currentOutput.sampleData(data, bytesToRead);
+      writtenSampleSize += bytesToRead;
+    } else {
+      data.setPosition(data.getPosition() + bytesToRead);
+    }
 
-        int headerSize = 2 /* the sync word */ + HEADER_SIZE;
-        if (hasCrc) {
-            headerSize += CRC_SIZE;
-        }
+    bytesRead += bytesToRead;
 
-        int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
+    if (bytesRead == sampleSize) {
+      if (bMyCode) {
+        if (skipSize != headerSize) //ID3 header parsed
+          realSampleSize = bytesToRead;
+        else
+          realSampleSize = sampleSize;
 
-        if (bMyCode) {
-            //Assertions.checkArgument(data.getPosition() );
-            if (bParseID3)
-                skipSize = bytesRead;
-            else
-                skipSize = headerSize;// when ID3 parsed, bytesRead != 0
-        }
+        ParsableByteArray realSample = new ParsableByteArray();
+        realSample.reset(realSampleSize);
+        System.arraycopy(sampleData.data, sampleData.getPosition() + skipSize, realSample.data, 0, realSampleSize);
+        sampleData.setPosition(sampleData.getPosition() + skipSize + realSampleSize);
 
-        if (!bMyCode) {
-            currentOutput.sampleData(data, bytesToRead);
-            writtenSampleSize += bytesToRead;
-        } else {
-            data.setPosition(data.getPosition() + bytesToRead);
+        if (mMode == C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES) {
+          C.decryptSampleAes_Audio(realSample, realSampleSize, encryptionKey, encryptionIv);
         }
 
-        bytesRead += bytesToRead;
-
-        if (bytesRead == sampleSize) {
-
-            if (bMyCode) {
-                if (skipSize != headerSize) //ID3 header parsed
-                    realSampleSize = bytesToRead;
-                else
-                    realSampleSize = sampleSize;
-
-                ParsableByteArray realSample = new ParsableByteArray();
-                realSample.reset(realSampleSize);
-                System.arraycopy(sampleData.data, sampleData.getPosition() + skipSize, realSample.data, 0, realSampleSize);
-                sampleData.setPosition(sampleData.getPosition() + skipSize + realSampleSize);
+        currentOutput.sampleData(realSample, realSampleSize);
+        writtenSampleSize += realSampleSize;
 
-                if (mMode == C.TS_STREAM_TYPE_AAC_ADTS_SAMPLE_AES) {
-                    C.decryptSampleAes_Audio(realSample, realSampleSize, encryptionKey, encryptionIv);
-                }
-
-                currentOutput.sampleData(realSample, realSampleSize);
-                writtenSampleSize += realSampleSize;
-            }
-
-            if (!bMyCode) {
-                currentOutput.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
-            } else {
-                int newOffset = (int) (writtenSampleSize - totalBytesWritten);
-                currentOutput.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, newOffset, null);
-            }
-            timeUs += currentSampleDuration;
-
-            setFindingSampleState();
-        }
+        int newOffset = (int) (writtenSampleSize - totalBytesWritten);
+        currentOutput.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, newOffset, null);
+      } else {
+        currentOutput.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0, null);
+      }
 
+      timeUs += currentSampleDuration;
+      setFindingSampleState();
     }
-
+  }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index 0e6d1f4d57..8d368227ab 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -19,7 +19,6 @@
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
-
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -38,7 +37,6 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import com.google.android.exoplayer2.util.Util;
-
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -52,512 +50,511 @@
  */
 public final class TsExtractor implements Extractor {
 
-    /**
-     * Factory for {@link TsExtractor} instances.
-     */
-    public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
-
-        @Override
-        public Extractor[] createExtractors() {
-            return new Extractor[]{new TsExtractor()};
-        }
-
-    };
+  /**
+   * Factory for {@link TsExtractor} instances.
+   */
+  public static final ExtractorsFactory FACTORY = new ExtractorsFactory() {
 
-    /**
-     * Modes for the extractor.
-     */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({MODE_MULTI_PMT, MODE_SINGLE_PMT, MODE_HLS})
-    public @interface Mode {
+    @Override
+    public Extractor[] createExtractors() {
+      return new Extractor[] {new TsExtractor()};
     }
 
-    /**
-     * Behave as defined in ISO/IEC 13818-1.
-     */
-    public static final int MODE_MULTI_PMT = 0;
-    /**
-     * Assume only one PMT will be contained in the stream, even if more are declared by the PAT.
-     */
-    public static final int MODE_SINGLE_PMT = 1;
-    /**
-     * Enable single PMT mode, map {@link TrackOutput}s by their type (instead of PID) and ignore
-     * continuity counters.
-     */
-    public static final int MODE_HLS = 2;
-
-    public static final int TS_STREAM_TYPE_MPA = 0x03;
-    public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
-    public static final int TS_STREAM_TYPE_AAC = 0x0F;
-    public static final int TS_STREAM_TYPE_AC3 = 0x81;
-    public static final int TS_STREAM_TYPE_DTS = 0x8A;
-    public static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
-    public static final int TS_STREAM_TYPE_E_AC3 = 0x87;
-    public static final int TS_STREAM_TYPE_H262 = 0x02;
-    public static final int TS_STREAM_TYPE_H264 = 0x1B;
-    public static final int TS_STREAM_TYPE_H265 = 0x24;
-    public static final int TS_STREAM_TYPE_ID3 = 0x15;
-    public static final int TS_STREAM_TYPE_SPLICE_INFO = 0x86;
-    public static final int TS_STREAM_TYPE_DVBSUBS = 0x59;
-
-    private static final int TS_PACKET_SIZE = 188;
-    private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
-    private static final int TS_PAT_PID = 0;
-    private static final int MAX_PID_PLUS_ONE = 0x2000;
-
-    private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
-    private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
-    private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
-
-    private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
-    private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
-
-    @Mode
-    private final int mode;
-    private final List<TimestampAdjuster> timestampAdjusters;
-    private final ParsableByteArray tsPacketBuffer;
-    private final ParsableBitArray tsScratch;
-    private final SparseIntArray continuityCounters;
-    private final TsPayloadReader.Factory payloadReaderFactory;
-    private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
-    private final SparseBooleanArray trackIds;
-
-    // Accessed only by the loading thread.
-    private ExtractorOutput output;
-    private int remainingPmts;
-    private boolean tracksEnded;
-    private TsPayloadReader id3Reader;
-
-    private HLSEncryptInfo hlsEncryptInfo;
-    private static int mMode = C.TS_STREAM_TYPE_H264;
-
-    public TsExtractor() {
-        this(0);
+  };
+
+  /**
+   * Modes for the extractor.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({MODE_MULTI_PMT, MODE_SINGLE_PMT, MODE_HLS})
+  public @interface Mode {}
+
+  /**
+   * Behave as defined in ISO/IEC 13818-1.
+   */
+  public static final int MODE_MULTI_PMT = 0;
+  /**
+   * Assume only one PMT will be contained in the stream, even if more are declared by the PAT.
+   */
+  public static final int MODE_SINGLE_PMT = 1;
+  /**
+   * Enable single PMT mode, map {@link TrackOutput}s by their type (instead of PID) and ignore
+   * continuity counters.
+   */
+  public static final int MODE_HLS = 2;
+
+  public static final int TS_STREAM_TYPE_MPA = 0x03;
+  public static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
+  public static final int TS_STREAM_TYPE_AAC = 0x0F;
+  public static final int TS_STREAM_TYPE_AC3 = 0x81;
+  public static final int TS_STREAM_TYPE_DTS = 0x8A;
+  public static final int TS_STREAM_TYPE_HDMV_DTS = 0x82;
+  public static final int TS_STREAM_TYPE_E_AC3 = 0x87;
+  public static final int TS_STREAM_TYPE_H262 = 0x02;
+  public static final int TS_STREAM_TYPE_H264 = 0x1B;
+  public static final int TS_STREAM_TYPE_H265 = 0x24;
+  public static final int TS_STREAM_TYPE_ID3 = 0x15;
+  public static final int TS_STREAM_TYPE_SPLICE_INFO = 0x86;
+  public static final int TS_STREAM_TYPE_DVBSUBS = 0x59;
+
+  private static final int TS_PACKET_SIZE = 188;
+  private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
+  private static final int TS_PAT_PID = 0;
+  private static final int MAX_PID_PLUS_ONE = 0x2000;
+
+  private static final long AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("AC-3");
+  private static final long E_AC3_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("EAC3");
+  private static final long HEVC_FORMAT_IDENTIFIER = Util.getIntegerCodeForString("HEVC");
+
+  private static final int BUFFER_PACKET_COUNT = 5; // Should be at least 2
+  private static final int BUFFER_SIZE = TS_PACKET_SIZE * BUFFER_PACKET_COUNT;
+
+  @Mode private final int mode;
+  private final List<TimestampAdjuster> timestampAdjusters;
+  private final ParsableByteArray tsPacketBuffer;
+  private final ParsableBitArray tsScratch;
+  private final SparseIntArray continuityCounters;
+  private final TsPayloadReader.Factory payloadReaderFactory;
+  private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
+  private final SparseBooleanArray trackIds;
+
+  // Accessed only by the loading thread.
+  private ExtractorOutput output;
+  private int remainingPmts;
+  private boolean tracksEnded;
+  private TsPayloadReader id3Reader;
+
+  private static int mMode = TS_STREAM_TYPE_H264;
+  private HLSEncryptInfo hlsEncryptInfo;
+
+  public TsExtractor() {
+    this(0);
+  }
+
+  /**
+   * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
+   *     {@code FLAG_*} values that control the behavior of the payload readers.
+   */
+  public TsExtractor(@Flags int defaultTsPayloadReaderFlags) {
+    this(MODE_SINGLE_PMT, defaultTsPayloadReaderFlags);
+  }
+
+  /**
+   * @param mode Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
+   *     and {@link #MODE_HLS}.
+   * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
+   *     {@code FLAG_*} values that control the behavior of the payload readers.
+   */
+  public TsExtractor(@Mode int mode, @Flags int defaultTsPayloadReaderFlags) {
+    this(mode, new TimestampAdjuster(0),
+        new DefaultTsPayloadReaderFactory(defaultTsPayloadReaderFlags));
+  }
+
+
+  /**
+   * @param mode Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
+   *     and {@link #MODE_HLS}.
+   * @param timestampAdjuster A timestamp adjuster for offsetting and scaling sample timestamps.
+   * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
+   */
+  public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
+      TsPayloadReader.Factory payloadReaderFactory) {
+    this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
+    this.mode = mode;
+    if (mode == MODE_SINGLE_PMT || mode == MODE_HLS) {
+      timestampAdjusters = Collections.singletonList(timestampAdjuster);
+    } else {
+      timestampAdjusters = new ArrayList<>();
+      timestampAdjusters.add(timestampAdjuster);
     }
-
-    /**
-     * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
-     *                                    {@code FLAG_*} values that control the behavior of the payload readers.
-     */
-    public TsExtractor(@Flags int defaultTsPayloadReaderFlags) {
-        this(MODE_SINGLE_PMT, defaultTsPayloadReaderFlags);
+    tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
+    tsScratch = new ParsableBitArray(new byte[3]);
+    trackIds = new SparseBooleanArray();
+    tsPayloadReaders = new SparseArray<>();
+    continuityCounters = new SparseIntArray();
+    resetPayloadReaders();
+  }
+
+  public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
+                     TsPayloadReader.Factory payloadReaderFactory, HLSEncryptInfo hlsEncryptInfo) {
+    this(mode, timestampAdjuster, payloadReaderFactory);
+
+    this.hlsEncryptInfo = hlsEncryptInfo;
+  }
+
+  // Extractor implementation.
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    byte[] buffer = tsPacketBuffer.data;
+    input.peekFully(buffer, 0, BUFFER_SIZE);
+    for (int j = 0; j < TS_PACKET_SIZE; j++) {
+      for (int i = 0; true; i++) {
+        if (i == BUFFER_PACKET_COUNT) {
+          input.skipFully(j);
+          return true;
+        }
+        if (buffer[j + i * TS_PACKET_SIZE] != TS_SYNC_BYTE) {
+          break;
+        }
+      }
     }
-
-    /**
-     * @param mode                        Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
-     *                                    and {@link #MODE_HLS}.
-     * @param defaultTsPayloadReaderFlags A combination of {@link DefaultTsPayloadReaderFactory}
-     *                                    {@code FLAG_*} values that control the behavior of the payload readers.
-     */
-    public TsExtractor(@Mode int mode, @Flags int defaultTsPayloadReaderFlags) {
-        this(mode, new TimestampAdjuster(0),
-                new DefaultTsPayloadReaderFactory(defaultTsPayloadReaderFlags));
+    return false;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    this.output = output;
+    output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
+  }
+
+  @Override
+  public void seek(long position, long timeUs) {
+    int timestampAdjustersCount = timestampAdjusters.size();
+    for (int i = 0; i < timestampAdjustersCount; i++) {
+      timestampAdjusters.get(i).reset();
     }
-
-
-    /**
-     * @param mode                 Mode for the extractor. One of {@link #MODE_MULTI_PMT}, {@link #MODE_SINGLE_PMT}
-     *                             and {@link #MODE_HLS}.
-     * @param timestampAdjuster    A timestamp adjuster for offsetting and scaling sample timestamps.
-     * @param payloadReaderFactory Factory for injecting a custom set of payload readers.
-     */
-    public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
-                       TsPayloadReader.Factory payloadReaderFactory) {
-        this.payloadReaderFactory = Assertions.checkNotNull(payloadReaderFactory);
-        this.mode = mode;
-        if (mode == MODE_SINGLE_PMT || mode == MODE_HLS) {
-            timestampAdjusters = Collections.singletonList(timestampAdjuster);
-        } else {
-            timestampAdjusters = new ArrayList<>();
-            timestampAdjusters.add(timestampAdjuster);
-        }
-        tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
-        tsScratch = new ParsableBitArray(new byte[3]);
-        trackIds = new SparseBooleanArray();
-        tsPayloadReaders = new SparseArray<>();
-        continuityCounters = new SparseIntArray();
-        resetPayloadReaders();
+    tsPacketBuffer.reset();
+    continuityCounters.clear();
+    // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
+    resetPayloadReaders();
+  }
+
+  @Override
+  public void release() {
+    // Do nothing
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+    byte[] data = tsPacketBuffer.data;
+    // Shift bytes to the start of the buffer if there isn't enough space left at the end
+    if (BUFFER_SIZE - tsPacketBuffer.getPosition() < TS_PACKET_SIZE) {
+      int bytesLeft = tsPacketBuffer.bytesLeft();
+      if (bytesLeft > 0) {
+        System.arraycopy(data, tsPacketBuffer.getPosition(), data, 0, bytesLeft);
+      }
+      tsPacketBuffer.reset(data, bytesLeft);
     }
-
-    public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
-                       TsPayloadReader.Factory payloadReaderFactory, HLSEncryptInfo hlsEncryptInfo) {
-        this(mode, timestampAdjuster, payloadReaderFactory);
-        this.hlsEncryptInfo = hlsEncryptInfo;
+    // Read more bytes until there is at least one packet size
+    while (tsPacketBuffer.bytesLeft() < TS_PACKET_SIZE) {
+      int limit = tsPacketBuffer.limit();
+      int read = input.read(data, limit, BUFFER_SIZE - limit);
+      if (read == C.RESULT_END_OF_INPUT) {
+        return RESULT_END_OF_INPUT;
+      }
+      tsPacketBuffer.setLimit(limit + read);
     }
 
-    // Extractor implementation.
-
-    @Override
-    public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
-        byte[] buffer = tsPacketBuffer.data;
-        input.peekFully(buffer, 0, BUFFER_SIZE);
-        for (int j = 0; j < TS_PACKET_SIZE; j++) {
-            for (int i = 0; true; i++) {
-                if (i == BUFFER_PACKET_COUNT) {
-                    input.skipFully(j);
-                    return true;
-                }
-                if (buffer[j + i * TS_PACKET_SIZE] != TS_SYNC_BYTE) {
-                    break;
-                }
-            }
-        }
-        return false;
+    // Note: see ISO/IEC 13818-1, section 2.4.3.2 for detailed information on the format of
+    // the header.
+    final int limit = tsPacketBuffer.limit();
+    int position = tsPacketBuffer.getPosition();
+    while (position < limit && data[position] != TS_SYNC_BYTE) {
+      position++;
     }
+    tsPacketBuffer.setPosition(position);
 
-    @Override
-    public void init(ExtractorOutput output) {
-        this.output = output;
-        output.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
+    int endOfPacket = position + TS_PACKET_SIZE;
+    if (endOfPacket > limit) {
+      return RESULT_CONTINUE;
     }
 
-    @Override
-    public void seek(long position, long timeUs) {
-        int timestampAdjustersCount = timestampAdjusters.size();
-        for (int i = 0; i < timestampAdjustersCount; i++) {
-            timestampAdjusters.get(i).reset();
+    tsPacketBuffer.skipBytes(1);
+    tsPacketBuffer.readBytes(tsScratch, 3);
+    if (tsScratch.readBit()) { // transport_error_indicator
+      // There are uncorrectable errors in this packet.
+      tsPacketBuffer.setPosition(endOfPacket);
+      return RESULT_CONTINUE;
+    }
+    boolean payloadUnitStartIndicator = tsScratch.readBit();
+    tsScratch.skipBits(1); // transport_priority
+    int pid = tsScratch.readBits(13);
+    tsScratch.skipBits(2); // transport_scrambling_control
+    boolean adaptationFieldExists = tsScratch.readBit();
+    boolean payloadExists = tsScratch.readBit();
+
+    // Discontinuity check.
+    boolean discontinuityFound = false;
+    int continuityCounter = tsScratch.readBits(4);
+    if (mode != MODE_HLS) {
+      int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
+      continuityCounters.put(pid, continuityCounter);
+      if (previousCounter == continuityCounter) {
+        if (payloadExists) {
+          // Duplicate packet found.
+          tsPacketBuffer.setPosition(endOfPacket);
+          return RESULT_CONTINUE;
         }
-        tsPacketBuffer.reset();
-        continuityCounters.clear();
-        // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
-        resetPayloadReaders();
+      } else if (continuityCounter != (previousCounter + 1) % 16) {
+        discontinuityFound = true;
+      }
     }
 
-    @Override
-    public void release() {
-        // Do nothing
+    // Skip the adaptation field.
+    if (adaptationFieldExists) {
+      int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
+      tsPacketBuffer.skipBytes(adaptationFieldLength);
     }
 
-    @Override
-    public int read(ExtractorInput input, PositionHolder seekPosition)
-            throws IOException, InterruptedException {
-        byte[] data = tsPacketBuffer.data;
-        // Shift bytes to the start of the buffer if there isn't enough space left at the end
-        if (BUFFER_SIZE - tsPacketBuffer.getPosition() < TS_PACKET_SIZE) {
-            int bytesLeft = tsPacketBuffer.bytesLeft();
-            if (bytesLeft > 0) {
-                System.arraycopy(data, tsPacketBuffer.getPosition(), data, 0, bytesLeft);
-            }
-            tsPacketBuffer.reset(data, bytesLeft);
-        }
-        // Read more bytes until there is at least one packet size
-        while (tsPacketBuffer.bytesLeft() < TS_PACKET_SIZE) {
-            int limit = tsPacketBuffer.limit();
-            int read = input.read(data, limit, BUFFER_SIZE - limit);
-            if (read == C.RESULT_END_OF_INPUT) {
-                return RESULT_END_OF_INPUT;
-            }
-            tsPacketBuffer.setLimit(limit + read);
+    // Read the payload.
+    if (payloadExists) {
+      TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
+      if (payloadReader != null) {
+        if (discontinuityFound) {
+          payloadReader.seek();
         }
+        tsPacketBuffer.setLimit(endOfPacket);
+        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
+        Assertions.checkState(tsPacketBuffer.getPosition() <= endOfPacket);
+        tsPacketBuffer.setLimit(limit);
+      }
+    }
 
-        // Note: see ISO/IEC 13818-1, section 2.4.3.2 for detailed information on the format of
-        // the header.
-        final int limit = tsPacketBuffer.limit();
-        int position = tsPacketBuffer.getPosition();
-        while (position < limit && data[position] != TS_SYNC_BYTE) {
-            position++;
-        }
-        tsPacketBuffer.setPosition(position);
+    tsPacketBuffer.setPosition(endOfPacket);
+    return RESULT_CONTINUE;
+  }
 
-        int endOfPacket = position + TS_PACKET_SIZE;
-        if (endOfPacket > limit) {
-            return RESULT_CONTINUE;
-        }
+  // Internals.
 
-        tsPacketBuffer.skipBytes(1);
-        tsPacketBuffer.readBytes(tsScratch, 3);
-        if (tsScratch.readBit()) { // transport_error_indicator
-            // There are uncorrectable errors in this packet.
-            tsPacketBuffer.setPosition(endOfPacket);
-            return RESULT_CONTINUE;
-        }
-        boolean payloadUnitStartIndicator = tsScratch.readBit();
-        tsScratch.skipBits(1); // transport_priority
-        int pid = tsScratch.readBits(13);
-        tsScratch.skipBits(2); // transport_scrambling_control
-        boolean adaptationFieldExists = tsScratch.readBit();
-        boolean payloadExists = tsScratch.readBit();
-
-        // Discontinuity check.
-        boolean discontinuityFound = false;
-        int continuityCounter = tsScratch.readBits(4);
-        if (mode != MODE_HLS) {
-            int previousCounter = continuityCounters.get(pid, continuityCounter - 1);
-            continuityCounters.put(pid, continuityCounter);
-            if (previousCounter == continuityCounter) {
-                if (payloadExists) {
-                    // Duplicate packet found.
-                    tsPacketBuffer.setPosition(endOfPacket);
-                    return RESULT_CONTINUE;
-                }
-            } else if (continuityCounter != (previousCounter + 1) % 16) {
-                discontinuityFound = true;
-            }
-        }
+  private void resetPayloadReaders() {
+    trackIds.clear();
+    tsPayloadReaders.clear();
+    SparseArray<TsPayloadReader> initialPayloadReaders =
+        payloadReaderFactory.createInitialPayloadReaders();
+    int initialPayloadReadersSize = initialPayloadReaders.size();
+    for (int i = 0; i < initialPayloadReadersSize; i++) {
+      tsPayloadReaders.put(initialPayloadReaders.keyAt(i), initialPayloadReaders.valueAt(i));
+    }
+    tsPayloadReaders.put(TS_PAT_PID, new SectionReader(new PatReader()));
+    id3Reader = null;
+  }
 
-        // Skip the adaptation field.
-        if (adaptationFieldExists) {
-            int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
-            tsPacketBuffer.skipBytes(adaptationFieldLength);
-        }
+  /**
+   * Parses Program Association Table data.
+   */
+  private class PatReader implements SectionPayloadReader {
 
-        // Read the payload.
-        if (payloadExists) {
-            TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
-            if (payloadReader != null) {
-                if (discontinuityFound) {
-                    payloadReader.seek();
-                }
-                tsPacketBuffer.setLimit(endOfPacket);
-                payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
-                Assertions.checkState(tsPacketBuffer.getPosition() <= endOfPacket);
-                tsPacketBuffer.setLimit(limit);
-            }
-        }
+    private final ParsableBitArray patScratch;
 
-        tsPacketBuffer.setPosition(endOfPacket);
-        return RESULT_CONTINUE;
+    public PatReader() {
+      patScratch = new ParsableBitArray(new byte[4]);
     }
 
-    // Internals.
+    @Override
+    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+        TrackIdGenerator idGenerator) {
+      // Do nothing.
+    }
 
-    private void resetPayloadReaders() {
-        trackIds.clear();
-        tsPayloadReaders.clear();
-        SparseArray<TsPayloadReader> initialPayloadReaders =
-                payloadReaderFactory.createInitialPayloadReaders();
-        int initialPayloadReadersSize = initialPayloadReaders.size();
-        for (int i = 0; i < initialPayloadReadersSize; i++) {
-            tsPayloadReaders.put(initialPayloadReaders.keyAt(i), initialPayloadReaders.valueAt(i));
+    @Override
+    public void consume(ParsableByteArray sectionData) {
+      int tableId = sectionData.readUnsignedByte();
+      if (tableId != 0x00 /* program_association_section */) {
+        // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
+        return;
+      }
+      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12),
+      // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
+      // section_number (8), last_section_number (8)
+      sectionData.skipBytes(7);
+
+      int programCount = sectionData.bytesLeft() / 4;
+      for (int i = 0; i < programCount; i++) {
+        sectionData.readBytes(patScratch, 4);
+        int programNumber = patScratch.readBits(16);
+        patScratch.skipBits(3); // reserved (3)
+        if (programNumber == 0) {
+          patScratch.skipBits(13); // network_PID (13)
+        } else {
+          int pid = patScratch.readBits(13);
+          tsPayloadReaders.put(pid, new SectionReader(new PmtReader(pid)));
+          remainingPmts++;
         }
-        tsPayloadReaders.put(TS_PAT_PID, new SectionReader(new PatReader()));
-        id3Reader = null;
+      }
+      if (mode != MODE_HLS) {
+        tsPayloadReaders.remove(TS_PAT_PID);
+      }
     }
 
-    /**
-     * Parses Program Association Table data.
-     */
-    private class PatReader implements SectionPayloadReader {
+  }
 
-        private final ParsableBitArray patScratch;
+  /**
+   * Parses Program Map Table.
+   */
+  private class PmtReader implements SectionPayloadReader {
 
-        public PatReader() {
-            patScratch = new ParsableBitArray(new byte[4]);
-        }
+    private static final int TS_PMT_DESC_REGISTRATION = 0x05;
+    private static final int TS_PMT_DESC_ISO639_LANG = 0x0A;
+    private static final int TS_PMT_DESC_AC3 = 0x6A;
+    private static final int TS_PMT_DESC_EAC3 = 0x7A;
+    private static final int TS_PMT_DESC_DTS = 0x7B;
+    private static final int TS_PMT_DESC_DVBSUBS = 0x59;
 
-        @Override
-        public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-                         TrackIdGenerator idGenerator) {
-            // Do nothing.
-        }
-
-        @Override
-        public void consume(ParsableByteArray sectionData) {
-            int tableId = sectionData.readUnsignedByte();
-            if (tableId != 0x00 /* program_association_section */) {
-                // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
-                return;
-            }
-            // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12),
-            // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
-            // section_number (8), last_section_number (8)
-            sectionData.skipBytes(7);
-
-            int programCount = sectionData.bytesLeft() / 4;
-            for (int i = 0; i < programCount; i++) {
-                sectionData.readBytes(patScratch, 4);
-                int programNumber = patScratch.readBits(16);
-                patScratch.skipBits(3); // reserved (3)
-                if (programNumber == 0) {
-                    patScratch.skipBits(13); // network_PID (13)
-                } else {
-                    int pid = patScratch.readBits(13);
-                    tsPayloadReaders.put(pid, new SectionReader(new PmtReader(pid)));
-                    remainingPmts++;
-                }
-            }
-            if (mode != MODE_HLS) {
-                tsPayloadReaders.remove(TS_PAT_PID);
-            }
-        }
+    private final ParsableBitArray pmtScratch;
+    private final int pid;
 
+    public PmtReader(int pid) {
+      pmtScratch = new ParsableBitArray(new byte[5]);
+      this.pid = pid;
     }
 
-    /**
-     * Parses Program Map Table.
-     */
-    private class PmtReader implements SectionPayloadReader {
-
-        private static final int TS_PMT_DESC_REGISTRATION = 0x05;
-        private static final int TS_PMT_DESC_ISO639_LANG = 0x0A;
-        private static final int TS_PMT_DESC_AC3 = 0x6A;
-        private static final int TS_PMT_DESC_EAC3 = 0x7A;
-        private static final int TS_PMT_DESC_DTS = 0x7B;
-        private static final int TS_PMT_DESC_DVBSUBS = 0x59;
-
-        private final ParsableBitArray pmtScratch;
-        private final int pid;
+    @Override
+    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+        TrackIdGenerator idGenerator) {
+      // Do nothing.
+    }
 
-        public PmtReader(int pid) {
-            pmtScratch = new ParsableBitArray(new byte[5]);
-            this.pid = pid;
+    @Override
+    public void consume(ParsableByteArray sectionData) {
+      int tableId = sectionData.readUnsignedByte();
+      if (tableId != 0x02 /* TS_program_map_section */) {
+        // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
+        return;
+      }
+      // TimestampAdjuster assignment.
+      TimestampAdjuster timestampAdjuster;
+      if (mode == MODE_SINGLE_PMT || mode == MODE_HLS || remainingPmts == 1) {
+        timestampAdjuster = timestampAdjusters.get(0);
+      } else {
+        timestampAdjuster = new TimestampAdjuster(
+            timestampAdjusters.get(0).getFirstSampleTimestampUs());
+        timestampAdjusters.add(timestampAdjuster);
+      }
+
+      // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12)
+      sectionData.skipBytes(2);
+      int programNumber = sectionData.readUnsignedShort();
+      // reserved (2), version_number (5), current_next_indicator (1), section_number (8),
+      // last_section_number (8), reserved (3), PCR_PID (13)
+      sectionData.skipBytes(5);
+
+      // Read program_info_length.
+      sectionData.readBytes(pmtScratch, 2);
+      pmtScratch.skipBits(4);
+      int programInfoLength = pmtScratch.readBits(12);
+
+      // Skip the descriptors.
+      sectionData.skipBytes(programInfoLength);
+
+      if (mode == MODE_HLS && id3Reader == null) {
+        // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
+        // appears intermittently during playback. See [Internal: b/20261500].
+        EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, null, new byte[0]);
+        id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo, null);
+        id3Reader.init(timestampAdjuster, output,
+            new TrackIdGenerator(programNumber, TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
+      }
+
+      int remainingEntriesLength = sectionData.bytesLeft();
+      while (remainingEntriesLength > 0) {
+        sectionData.readBytes(pmtScratch, 5);
+        int streamType = pmtScratch.readBits(8);
+        pmtScratch.skipBits(3); // reserved
+        int elementaryPid = pmtScratch.readBits(13);
+        pmtScratch.skipBits(4); // reserved
+        int esInfoLength = pmtScratch.readBits(12); // ES_info_length.
+        EsInfo esInfo = readEsInfo(sectionData, esInfoLength);
+        if (streamType == 0x06) {
+          streamType = esInfo.streamType;
         }
+        remainingEntriesLength -= esInfoLength + 5;
 
-        @Override
-        public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
-                         TrackIdGenerator idGenerator) {
-            // Do nothing.
+        int trackId = mode == MODE_HLS ? streamType : elementaryPid;
+        if (trackIds.get(trackId)) {
+          continue;
         }
+        trackIds.put(trackId, true);
 
-        @Override
-        public void consume(ParsableByteArray sectionData) {
-            int tableId = sectionData.readUnsignedByte();
-            if (tableId != 0x02 /* TS_program_map_section */) {
-                // See ISO/IEC 13818-1, section 2.4.4.4 for more information on table id assignment.
-                return;
-            }
-            // TimestampAdjuster assignment.
-            TimestampAdjuster timestampAdjuster;
-            if (mode == MODE_SINGLE_PMT || mode == MODE_HLS || remainingPmts == 1) {
-                timestampAdjuster = timestampAdjusters.get(0);
-            } else {
-                timestampAdjuster = new TimestampAdjuster(
-                        timestampAdjusters.get(0).getFirstSampleTimestampUs());
-                timestampAdjusters.add(timestampAdjuster);
-            }
-
-            // section_syntax_indicator(1), '0'(1), reserved(2), section_length(12)
-            sectionData.skipBytes(2);
-            int programNumber = sectionData.readUnsignedShort();
-            // reserved (2), version_number (5), current_next_indicator (1), section_number (8),
-            // last_section_number (8), reserved (3), PCR_PID (13)
-            sectionData.skipBytes(5);
-
-            // Read program_info_length.
-            sectionData.readBytes(pmtScratch, 2);
-            pmtScratch.skipBits(4);
-            int programInfoLength = pmtScratch.readBits(12);
-
-            // Skip the descriptors.
-            sectionData.skipBytes(programInfoLength);
-
-            if (mode == MODE_HLS && id3Reader == null) {
-                // Setup an ID3 track regardless of whether there's a corresponding entry, in case one
-                // appears intermittently during playback. See [Internal: b/20261500].
-                EsInfo dummyEsInfo = new EsInfo(TS_STREAM_TYPE_ID3, null, null, new byte[0]);
-                id3Reader = payloadReaderFactory.createPayloadReader(TS_STREAM_TYPE_ID3, dummyEsInfo, null);
-                id3Reader.init(timestampAdjuster, output,
-                        new TrackIdGenerator(programNumber, TS_STREAM_TYPE_ID3, MAX_PID_PLUS_ONE));
-            }
-
-            int remainingEntriesLength = sectionData.bytesLeft();
-            while (remainingEntriesLength > 0) {
-                sectionData.readBytes(pmtScratch, 5);
-                int streamType = pmtScratch.readBits(8);
-                pmtScratch.skipBits(3); // reserved
-                int elementaryPid = pmtScratch.readBits(13);
-                pmtScratch.skipBits(4); // reserved
-                int esInfoLength = pmtScratch.readBits(12); // ES_info_length.
-                EsInfo esInfo = readEsInfo(sectionData, esInfoLength);
-                if (streamType == 0x06) {
-                    streamType = esInfo.streamType;
-                }
-                remainingEntriesLength -= esInfoLength + 5;
-
-                int trackId = mode == MODE_HLS ? streamType : elementaryPid;
-                if (trackIds.get(trackId)) {
-                    continue;
-                }
-                trackIds.put(trackId, true);
-
-                TsPayloadReader reader;
-                if (mode == MODE_HLS && streamType == TS_STREAM_TYPE_ID3) {
-                    reader = id3Reader;
-                } else {
-                    reader = payloadReaderFactory.createPayloadReader(streamType, esInfo, hlsEncryptInfo);
-                    if (reader != null) {
-                        reader.init(timestampAdjuster, output,
-                                new TrackIdGenerator(programNumber, trackId, MAX_PID_PLUS_ONE));
-                    }
-                }
-
-                if (reader != null) {
-                    tsPayloadReaders.put(elementaryPid, reader);
-                }
-            }
-            if (mode == MODE_HLS) {
-                if (!tracksEnded) {
-                    output.endTracks();
-                    remainingPmts = 0;
-                    tracksEnded = true;
-                }
-            } else {
-                tsPayloadReaders.remove(pid);
-                remainingPmts = mode == MODE_SINGLE_PMT ? 0 : remainingPmts - 1;
-                if (remainingPmts == 0) {
-                    output.endTracks();
-                    tracksEnded = true;
-                }
-            }
+        TsPayloadReader reader;
+        if (mode == MODE_HLS && streamType == TS_STREAM_TYPE_ID3) {
+          reader = id3Reader;
+        } else {
+          reader = payloadReaderFactory.createPayloadReader(streamType, esInfo, hlsEncryptInfo);
+          if (reader != null) {
+            reader.init(timestampAdjuster, output,
+                new TrackIdGenerator(programNumber, trackId, MAX_PID_PLUS_ONE));
+          }
         }
 
-        /**
-         * Returns the stream info read from the available descriptors. Sets {@code data}'s position to
-         * the end of the descriptors.
-         *
-         * @param data   A buffer with its position set to the start of the first descriptor.
-         * @param length The length of descriptors to read from the current position in {@code data}.
-         * @return The stream info read from the available descriptors.
-         */
-        private EsInfo readEsInfo(ParsableByteArray data, int length) {
-            int descriptorsStartPosition = data.getPosition();
-            int descriptorsEndPosition = descriptorsStartPosition + length;
-            int streamType = -1;
-            String language = null;
-            List<DvbSubtitleInfo> dvbSubtitleInfos = null;
-            while (data.getPosition() < descriptorsEndPosition) {
-                int descriptorTag = data.readUnsignedByte();
-                int descriptorLength = data.readUnsignedByte();
-                int positionOfNextDescriptor = data.getPosition() + descriptorLength;
-                if (descriptorTag == TS_PMT_DESC_REGISTRATION) { // registration_descriptor
-                    long formatIdentifier = data.readUnsignedInt();
-                    if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
-                        streamType = TS_STREAM_TYPE_AC3;
-                    } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
-                        streamType = TS_STREAM_TYPE_E_AC3;
-                    } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
-                        streamType = TS_STREAM_TYPE_H265;
-                    }
-                } else if (descriptorTag == TS_PMT_DESC_AC3) { // AC-3_descriptor in DVB (ETSI EN 300 468)
-                    streamType = TS_STREAM_TYPE_AC3;
-                } else if (descriptorTag == TS_PMT_DESC_EAC3) { // enhanced_AC-3_descriptor
-                    streamType = TS_STREAM_TYPE_E_AC3;
-                } else if (descriptorTag == TS_PMT_DESC_DTS) { // DTS_descriptor
-                    streamType = TS_STREAM_TYPE_DTS;
-                } else if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
-                    language = data.readString(3).trim();
-                    // Audio type is ignored.
-                } else if (descriptorTag == TS_PMT_DESC_DVBSUBS) {
-                    streamType = TS_STREAM_TYPE_DVBSUBS;
-                    dvbSubtitleInfos = new ArrayList<>();
-                    while (data.getPosition() < positionOfNextDescriptor) {
-                        String dvbLanguage = data.readString(3).trim();
-                        int dvbSubtitlingType = data.readUnsignedByte();
-                        byte[] initializationData = new byte[4];
-                        data.readBytes(initializationData, 0, 4);
-                        dvbSubtitleInfos.add(new DvbSubtitleInfo(dvbLanguage, dvbSubtitlingType,
-                                initializationData));
-                    }
-                }
-                // Skip unused bytes of current descriptor.
-                data.skipBytes(positionOfNextDescriptor - data.getPosition());
-            }
-            data.setPosition(descriptorsEndPosition);
-            return new EsInfo(streamType, language, dvbSubtitleInfos,
-                    Arrays.copyOfRange(data.data, descriptorsStartPosition, descriptorsEndPosition));
+        if (reader != null) {
+          tsPayloadReaders.put(elementaryPid, reader);
+        }
+      }
+      if (mode == MODE_HLS) {
+        if (!tracksEnded) {
+          output.endTracks();
+          remainingPmts = 0;
+          tracksEnded = true;
         }
+      } else {
+        tsPayloadReaders.remove(pid);
+        remainingPmts = mode == MODE_SINGLE_PMT ? 0 : remainingPmts - 1;
+        if (remainingPmts == 0) {
+          output.endTracks();
+          tracksEnded = true;
+        }
+      }
+    }
 
+    /**
+     * Returns the stream info read from the available descriptors. Sets {@code data}'s position to
+     * the end of the descriptors.
+     *
+     * @param data A buffer with its position set to the start of the first descriptor.
+     * @param length The length of descriptors to read from the current position in {@code data}.
+     * @return The stream info read from the available descriptors.
+     */
+    private EsInfo readEsInfo(ParsableByteArray data, int length) {
+      int descriptorsStartPosition = data.getPosition();
+      int descriptorsEndPosition = descriptorsStartPosition + length;
+      int streamType = -1;
+      String language = null;
+      List<DvbSubtitleInfo> dvbSubtitleInfos = null;
+      while (data.getPosition() < descriptorsEndPosition) {
+        int descriptorTag = data.readUnsignedByte();
+        int descriptorLength = data.readUnsignedByte();
+        int positionOfNextDescriptor = data.getPosition() + descriptorLength;
+        if (descriptorTag == TS_PMT_DESC_REGISTRATION) { // registration_descriptor
+          long formatIdentifier = data.readUnsignedInt();
+          if (formatIdentifier == AC3_FORMAT_IDENTIFIER) {
+            streamType = TS_STREAM_TYPE_AC3;
+          } else if (formatIdentifier == E_AC3_FORMAT_IDENTIFIER) {
+            streamType = TS_STREAM_TYPE_E_AC3;
+          } else if (formatIdentifier == HEVC_FORMAT_IDENTIFIER) {
+            streamType = TS_STREAM_TYPE_H265;
+          }
+        } else if (descriptorTag == TS_PMT_DESC_AC3) { // AC-3_descriptor in DVB (ETSI EN 300 468)
+          streamType = TS_STREAM_TYPE_AC3;
+        } else if (descriptorTag == TS_PMT_DESC_EAC3) { // enhanced_AC-3_descriptor
+          streamType = TS_STREAM_TYPE_E_AC3;
+        } else if (descriptorTag == TS_PMT_DESC_DTS) { // DTS_descriptor
+          streamType = TS_STREAM_TYPE_DTS;
+        } else if (descriptorTag == TS_PMT_DESC_ISO639_LANG) {
+          language = data.readString(3).trim();
+          // Audio type is ignored.
+        } else if (descriptorTag == TS_PMT_DESC_DVBSUBS) {
+          streamType = TS_STREAM_TYPE_DVBSUBS;
+          dvbSubtitleInfos = new ArrayList<>();
+          while (data.getPosition() < positionOfNextDescriptor) {
+            String dvbLanguage = data.readString(3).trim();
+            int dvbSubtitlingType = data.readUnsignedByte();
+            byte[] initializationData = new byte[4];
+            data.readBytes(initializationData, 0, 4);
+            dvbSubtitleInfos.add(new DvbSubtitleInfo(dvbLanguage, dvbSubtitlingType,
+                initializationData));
+          }
+        }
+        // Skip unused bytes of current descriptor.
+        data.skipBytes(positionOfNextDescriptor - data.getPosition());
+      }
+      data.setPosition(descriptorsEndPosition);
+      return new EsInfo(streamType, language, dvbSubtitleInfos,
+          Arrays.copyOfRange(data.data, descriptorsStartPosition, descriptorsEndPosition));
     }
 
+  }
+
 
 }
