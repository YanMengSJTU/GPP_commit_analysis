diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index e8d5d9e340..3a18119fdd 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,12 @@
 # Release notes #
 
+### r1.5.5 ###
+
+* DASH: Enable MP4 embedded WebVTT playback (#1185)
+* HLS: Fix handling of extended ID3 tags in MPEG-TS (#1181)
+* MP3: Fix incorrect position calculation in VBRI header (#1197)
+* Fix issue seeking backward using SingleSampleSource (#1193)
+
 ### r1.5.4 ###
 
 * HLS: Support for variant selection and WebVtt subtitles.
diff --git a/demo/src/main/AndroidManifest.xml b/demo/src/main/AndroidManifest.xml
index 29c2b1f950..a7c1072663 100644
--- a/demo/src/main/AndroidManifest.xml
+++ b/demo/src/main/AndroidManifest.xml
@@ -16,8 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.android.exoplayer.demo"
-    android:versionCode="1503"
-    android:versionName="1.5.4"
+    android:versionCode="1505"
+    android:versionName="1.5.5"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml b/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
index d71f92db6c..b7afa3b77b 100644
--- a/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
+++ b/demo_misc/vp9_opus_sw/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.demo.vp9opus"
-    android:versionCode="1503"
-    android:versionName="1.5.4"
+    android:versionCode="1505"
+    android:versionName="1.5.5"
     android:theme="@style/RootTheme">
 
   <uses-permission android:name="android.permission.INTERNET"/>
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
index 51e070e401..f37f3f92c3 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
+++ b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
@@ -200,6 +200,12 @@ public void onDecoderError(VpxDecoderException e) {
     updateDebugInfoTextView();
   }
 
+  @Override
+  public void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
+      long initializationDurationMs) {
+    // do nothing.
+  }
+
   @Override
   public void onPlayerStateChanged(boolean playWhenReady, int state) {
     switch (player.getPlaybackState()) {
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
index f20f877c5a..6f5fa62b08 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java
@@ -79,6 +79,17 @@
      */
     void onDecoderError(VpxDecoderException e);
 
+    /**
+     * Invoked when a decoder is successfully created.
+     *
+     * @param decoderName The decoder that was configured and created.
+     * @param elapsedRealtimeMs {@code elapsedRealtime} timestamp of when the initialization
+     *    finished.
+     * @param initializationDurationMs Amount of time taken to initialize the decoder.
+     */
+    void onDecoderInitialized(String decoderName, long elapsedRealtimeMs,
+        long initializationDurationMs);
+
   }
 
   /**
@@ -189,8 +200,10 @@ protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourc
 
     // If we don't have a decoder yet, we need to instantiate one.
     if (decoder == null) {
+      long startElapsedRealtimeMs = SystemClock.elapsedRealtime();
       decoder = new VpxDecoderWrapper(outputMode);
       decoder.start();
+      notifyDecoderInitialized(startElapsedRealtimeMs, SystemClock.elapsedRealtime());
       codecCounters.codecInitCount++;
     }
 
@@ -490,4 +503,17 @@ public void run() {
     }
   }
 
+  private void notifyDecoderInitialized(
+      final long startElapsedRealtimeMs, final long finishElapsedRealtimeMs) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onDecoderInitialized("libvpx" + getLibvpxVersion(),
+              finishElapsedRealtimeMs, finishElapsedRealtimeMs - startElapsedRealtimeMs);
+        }
+      });
+    }
+  }
+
 }
diff --git a/library/build.gradle b/library/build.gradle
index 10cb65a13e..f5ac063ffc 100644
--- a/library/build.gradle
+++ b/library/build.gradle
@@ -77,7 +77,7 @@ publish {
     userOrg = 'google'
     groupId = 'com.google.android.exoplayer'
     artifactId = 'exoplayer'
-    version = 'r1.5.4'
+    version = 'r1.5.5'
     description = 'The ExoPlayer library.'
     website = 'https://github.com/google/ExoPlayer'
 }
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
index 19c6586bf5..581bacde10 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/DefaultExtractorInputTest.java
@@ -34,6 +34,7 @@
 
   private static final String TEST_URI = "http://www.google.com";
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8};
+  private static final int LARGE_TEST_DATA_LENGTH = 8192;
 
   public void testInitialPosition() throws IOException {
     FakeDataSource testDataSource = buildDataSource();
@@ -182,6 +183,16 @@ public void testSkip() throws IOException, InterruptedException {
     assertEquals(-1, expectedEndOfInput);
   }
 
+  public void testLargeSkip() throws IOException, InterruptedException {
+    FakeDataSource testDataSource = buildLargeDataSource();
+    DefaultExtractorInput input = new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
+    // Check that skipping the entire data source succeeds.
+    int bytesToSkip = LARGE_TEST_DATA_LENGTH;
+    while (bytesToSkip > 0) {
+      bytesToSkip -= input.skip(bytesToSkip);
+    }
+  }
+
   public void testSkipFullyOnce() throws IOException, InterruptedException {
     // Skip TEST_DATA.
     DefaultExtractorInput input = createDefaultExtractorInput();
@@ -286,11 +297,14 @@ public void testPeekFully() throws IOException, InterruptedException {
     // Check that we read the whole of TEST_DATA.
     assertTrue(Arrays.equals(TEST_DATA, target));
     assertEquals(0, input.getPosition());
+    assertEquals(TEST_DATA.length, input.getPeekPosition());
 
     // Check that we can read again from the buffer
     byte[] target2 = new byte[TEST_DATA.length];
     input.readFully(target2, 0, TEST_DATA.length);
     assertTrue(Arrays.equals(TEST_DATA, target2));
+    assertEquals(TEST_DATA.length, input.getPosition());
+    assertEquals(TEST_DATA.length, input.getPeekPosition());
 
     // Check that we fail with EOFException if we peek again
     try {
@@ -391,6 +405,14 @@ private static FakeDataSource buildFailingDataSource() throws IOException {
     return testDataSource;
   }
 
+  private static FakeDataSource buildLargeDataSource() throws IOException {
+    FakeDataSource.Builder builder = new FakeDataSource.Builder();
+    builder.appendReadData(new byte[LARGE_TEST_DATA_LENGTH]);
+    FakeDataSource testDataSource = builder.build();
+    testDataSource.open(new DataSpec(Uri.parse(TEST_URI)));
+    return testDataSource;
+  }
+
   private static DefaultExtractorInput createDefaultExtractorInput() throws IOException {
     FakeDataSource testDataSource = buildDataSource();
     return new DefaultExtractorInput(testDataSource, 0, C.LENGTH_UNBOUNDED);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/XingSeekerTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/XingSeekerTest.java
index e981e65f49..88a14401f0 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/XingSeekerTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp3/XingSeekerTest.java
@@ -16,9 +16,9 @@
 package com.google.android.exoplayer.extractor.mp3;
 
 import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.testutil.TestUtil;
 import com.google.android.exoplayer.util.MpegAudioHeader;
 import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
 
 import android.test.InstrumentationTestCase;
 
@@ -29,7 +29,7 @@
 
   // Xing header/payload from http://storage.googleapis.com/exoplayer-test-media-0/play.mp3.
   private static final int XING_FRAME_HEADER_DATA = 0xFFFB3000;
-  private static final byte[] XING_FRAME_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] XING_FRAME_PAYLOAD = Util.getBytesFromHexString(
       "00000007000008dd000e7919000205080a0d0f1214171a1c1e212426292c2e303336383b3d404245484a4c4f5254"
       + "575a5c5e616466696b6e707376787a7d808285878a8c8f929496999c9ea1a4a6a8abaeb0b3b5b8babdc0c2c4c7"
       + "cacccfd2d4d6d9dcdee1e3e6e8ebeef0f2f5f8fafd");
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
index d4f796c3bc..01df6f1acc 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/mp4/Mp4ExtractorTest.java
@@ -39,21 +39,21 @@
 public final class Mp4ExtractorTest extends TestCase {
 
   /** String of hexadecimal bytes containing the video stsd payload from an AVC video. */
-  private static final byte[] VIDEO_STSD_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] VIDEO_STSD_PAYLOAD = Util.getBytesFromHexString(
       "00000000000000010000009961766331000000000000000100000000000000000000000000000000050002d00048"
       + "000000480000000000000001000000000000000000000000000000000000000000000000000000000000000000"
       + "18ffff0000002f617663430164001fffe100186764001facb402802dd80880000003008000001e078c19500100"
       + "0468ee3cb000000014627472740000e35c0042a61000216cb8");
-  private static final byte[] VIDEO_HDLR_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] VIDEO_HDLR_PAYLOAD = Util.getBytesFromHexString(
       "000000000000000076696465");
-  private static final byte[] VIDEO_MDHD_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] VIDEO_MDHD_PAYLOAD = Util.getBytesFromHexString(
       "0000000000000000cf6c48890000001e00001c8a55c40000");
   private static final int TIMESCALE = 30;
   private static final int VIDEO_WIDTH = 1280;
   private static final int VIDEO_HEIGHT = 720;
 
   /** String of hexadecimal bytes containing the video stsd payload for an mp4v track. */
-  private static final byte[] VIDEO_STSD_MP4V_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] VIDEO_STSD_MP4V_PAYLOAD = Util.getBytesFromHexString(
       "0000000000000001000000A36D703476000000000000000100000000000000000000000000000000014000B40048"
       + "000000480000000000000001000000000000000000000000000000000000000000000000000000000000000000"
       + "18FFFF0000004D6573647300000000033F00000004372011001A400004CF280002F1180528000001B001000001"
@@ -62,26 +62,26 @@
   private static final int VIDEO_MP4V_HEIGHT = 180;
 
   /** String of hexadecimal bytes containing the audio stsd payload from an AAC track. */
-  private static final byte[] AUDIO_STSD_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] AUDIO_STSD_PAYLOAD = Util.getBytesFromHexString(
       "0000000000000001000000596d703461000000000000000100000000000000000001001000000000ac4400000000"
       + "003565736473000000000327000000041f401500023e00024bc000023280051012080000000000000000000000"
       + "000000060102");
-  private static final byte[] AUDIO_HDLR_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] AUDIO_HDLR_PAYLOAD = Util.getBytesFromHexString(
       "0000000000000000736f756e");
-  private static final byte[] AUDIO_MDHD_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] AUDIO_MDHD_PAYLOAD = Util.getBytesFromHexString(
       "00000000cf6c4889cf6c488a0000ac4400a3e40055c40000");
 
   /** String of hexadecimal bytes for an ftyp payload with major_brand mp41 and minor_version 0. **/
-  private static final byte[] FTYP_PAYLOAD = TestUtil.createByteArray("6d70343100000000");
+  private static final byte[] FTYP_PAYLOAD = Util.getBytesFromHexString("6d70343100000000");
 
   /** String of hexadecimal bytes containing an mvhd payload from an AVC/AAC video. */
-  private static final byte[] MVHD_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] MVHD_PAYLOAD = Util.getBytesFromHexString(
       "00000000cf6c4888cf6c48880000025800023ad40001000001000000000000000000000000010000000000000000"
       + "000000000000000100000000000000000000000000004000000000000000000000000000000000000000000000"
       + "000000000000000003");
 
   /** String of hexadecimal bytes containing a tkhd payload with an unknown duration. */
-  private static final byte[] TKHD_PAYLOAD = TestUtil.createByteArray(
+  private static final byte[] TKHD_PAYLOAD = Util.getBytesFromHexString(
       "00000007D1F0C7BFD1F0C7BF0000000000000000FFFFFFFF00000000000000000000000000000000000100000000"
       + "0000000000000000000000010000000000000000000000000000400000000780000004380000");
 
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ts/AdtsReaderTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ts/AdtsReaderTest.java
index 78f0dd5ce9..e75b63011b 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ts/AdtsReaderTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ts/AdtsReaderTest.java
@@ -60,11 +60,11 @@
 
   private static final long ADTS_SAMPLE_DURATION = 23219L;
 
-  private ParsableByteArray data;
-
-  private AdtsReader adtsReader;
   private FakeTrackOutput adtsOutput;
   private FakeTrackOutput id3Output;
+  private AdtsReader adtsReader;
+  private ParsableByteArray data;
+  private boolean firstFeed;
 
   @Override
   protected void setUp() throws Exception {
@@ -72,6 +72,7 @@ protected void setUp() throws Exception {
     id3Output = new FakeTrackOutput();
     adtsReader = new AdtsReader(adtsOutput, id3Output);
     data = new ParsableByteArray(TEST_DATA);
+    firstFeed = true;
   }
 
   public void testSkipToNextSample() throws Exception {
@@ -138,7 +139,7 @@ public void testMultiId3PacketConsumed() throws Exception {
   public void testMultiPacketConsumed() throws Exception {
     for (int i = 0; i < 10; i++) {
       data.setPosition(0);
-      adtsReader.consume(data, 0, i == 0);
+      feed();
 
       long timeUs = ADTS_SAMPLE_DURATION * i;
       int j = i * 2;
@@ -158,12 +159,21 @@ public void testAdtsDataOnly() throws Exception {
   }
 
   private void feedLimited(int limit) {
+    maybeStartPacket();
     data.setLimit(limit);
     feed();
   }
 
   private void feed() {
-    adtsReader.consume(data, 0, true);
+    maybeStartPacket();
+    adtsReader.consume(data);
+  }
+
+  private void maybeStartPacket() {
+    if (firstFeed) {
+      adtsReader.packetStarted(0, true);
+      firstFeed = false;
+    }
   }
 
   private void assertSampleCounts(int id3SampleCount, int adtsSampleCount) {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java b/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
index 0195028a76..08c86b0d32 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java
@@ -80,15 +80,6 @@ public static ExtractorInput createTestExtractorInput(byte[] data, int offset)
     return source;
   }
 
-  public static byte[] createByteArray(String hexBytes) {
-    byte[] result = new byte[hexBytes.length() / 2];
-    for (int i = 0; i < result.length; i++) {
-      result[i] = (byte) ((Character.digit(hexBytes.charAt(i * 2), 16) << 4)
-          + Character.digit(hexBytes.charAt(i * 2 + 1), 16));
-    }
-    return result;
-  }
-
   public static byte[] createByteArray(int... intArray) {
     byte[] byteArray = new byte[intArray.length];
     for (int i = 0; i < byteArray.length; i++) {
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java b/library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
index 0a10c1794c..3755a9f250 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/util/NalUnitUtilTest.java
@@ -147,8 +147,8 @@ private static void assertUnescapeDoesNotModify(String input) {
   }
 
   private static void assertUnescapeMatchesExpected(String input, String expectedOutput) {
-    byte[] bitstream = getByteArrayForHexString(input);
-    byte[] expectedOutputBitstream = getByteArrayForHexString(expectedOutput);
+    byte[] bitstream = Util.getBytesFromHexString(input);
+    byte[] expectedOutputBitstream = Util.getBytesFromHexString(expectedOutput);
     int count = NalUnitUtil.unescapeStream(bitstream, bitstream.length);
     assertEquals(expectedOutputBitstream.length, count);
     byte[] outputBitstream = new byte[count];
@@ -156,15 +156,4 @@ private static void assertUnescapeMatchesExpected(String input, String expectedO
     assertTrue(Arrays.equals(expectedOutputBitstream, outputBitstream));
   }
 
-  private static byte[] getByteArrayForHexString(String hexString) {
-    int length = hexString.length();
-    Assertions.checkArgument(length % 2 == 0);
-    byte[] result = new byte[length / 2];
-    for (int i = 0; i < result.length; i++) {
-      result[i] = (byte) ((Character.digit(hexString.charAt(i * 2), 16) << 4)
-          + Character.digit(hexString.charAt(i * 2 + 1), 16));
-    }
-    return result;
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
index 96f8124789..69f9a7e569 100644
--- a/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
+++ b/library/src/main/java/com/google/android/exoplayer/ExoPlayerLibraryInfo.java
@@ -23,7 +23,7 @@
   /**
    * The version of the library, expressed as a string.
    */
-  public static final String VERSION = "1.5.4";
+  public static final String VERSION = "1.5.5";
 
   /**
    * The version of the library, expressed as an integer.
@@ -31,7 +31,7 @@
    * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 001002003.
    */
-  public static final int VERSION_INT = 001005004;
+  public static final int VERSION_INT = 001005005;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer.util.Assertions}
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
index afe93e6a7a..71a774b5e1 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java
@@ -316,6 +316,12 @@ protected void onDiscontinuity(long positionUs) throws ExoPlaybackException {
   protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, MediaCodec codec,
       ByteBuffer buffer, MediaCodec.BufferInfo bufferInfo, int bufferIndex, boolean shouldSkip)
       throws ExoPlaybackException {
+    if (passthroughEnabled && (bufferInfo.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) != 0) {
+      // Discard output buffers from the passthrough (raw) decoder containing codec specific data.
+      codec.releaseOutputBuffer(bufferIndex, false);
+      return true;
+    }
+
     if (shouldSkip) {
       codec.releaseOutputBuffer(bufferIndex, false);
       codecCounters.skippedOutputBufferCount++;
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
index 0f1d42e5e1..2c2597b17d 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecTrackRenderer.java
@@ -202,6 +202,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private final List<Long> decodeOnlyPresentationTimestamps;
   private final MediaCodec.BufferInfo outputBufferInfo;
   private final EventListener eventListener;
+  private final boolean deviceNeedsAutoFrcWorkaround;
   protected final Handler eventHandler;
 
   private MediaFormat format;
@@ -253,6 +254,7 @@ public MediaCodecTrackRenderer(SampleSource source, MediaCodecSelector mediaCode
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
+    deviceNeedsAutoFrcWorkaround = deviceNeedsAutoFrcWorkaround();
     codecCounters = new CodecCounters();
     sampleHolder = new SampleHolder(SampleHolder.BUFFER_REPLACEMENT_MODE_DISABLED);
     formatHolder = new MediaFormatHolder();
@@ -294,18 +296,15 @@ protected DecoderInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
   }
 
   /**
-   * Configures a newly created {@link MediaCodec}. Sub-classes should override this method if they
-   * wish to configure the codec with a non-null surface.
+   * Configures a newly created {@link MediaCodec}.
    *
    * @param codec The {@link MediaCodec} to configure.
    * @param codecIsAdaptive Whether the codec is adaptive.
    * @param format The format for which the codec is being configured.
    * @param crypto For drm protected playbacks, a {@link MediaCrypto} to use for decryption.
    */
-  protected void configureCodec(MediaCodec codec, boolean codecIsAdaptive,
-      android.media.MediaFormat format, MediaCrypto crypto) {
-    codec.configure(format, null, crypto, 0);
-  }
+  protected abstract void configureCodec(MediaCodec codec, boolean codecIsAdaptive,
+      android.media.MediaFormat format, MediaCrypto crypto);
 
   @SuppressWarnings("deprecation")
   protected final void maybeInitCodec() throws ExoPlaybackException {
@@ -361,7 +360,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       codec = MediaCodec.createByCodecName(codecName);
       TraceUtil.endSection();
       TraceUtil.beginSection("configureCodec");
-      configureCodec(codec, decoderInfo.adaptive, format.getFrameworkMediaFormatV16(), mediaCrypto);
+      configureCodec(codec, decoderInfo.adaptive, getFrameworkMediaFormat(format), mediaCrypto);
       TraceUtil.endSection();
       TraceUtil.beginSection("codec.start()");
       codec.start();
@@ -684,6 +683,14 @@ private boolean feedInputBuffer(long positionUs, boolean firstFeed) throws ExoPl
     return cryptoInfo;
   }
 
+  private android.media.MediaFormat getFrameworkMediaFormat(MediaFormat format) {
+    android.media.MediaFormat mediaFormat = format.getFrameworkMediaFormatV16();
+    if (deviceNeedsAutoFrcWorkaround) {
+      mediaFormat.setInteger("auto-frc", 0);
+    }
+    return mediaFormat;
+  }
+
   private boolean shouldWaitForKeys(boolean sampleEncrypted) throws ExoPlaybackException {
     if (!openedDrmSession) {
       return false;
@@ -972,4 +979,22 @@ private static boolean codecNeedsEosFlushWorkaround(String name) {
     return Util.SDK_INT <= 23 && "OMX.google.vorbis.decoder".equals(name);
   }
 
+  /**
+   * Returns whether the device is known to enable frame-rate conversion logic that negatively
+   * impacts ExoPlayer.
+   * <p>
+   * If true is returned then we explicitly disable the feature.
+   *
+   * @return True if the device is known to enable frame-rate conversion logic that negatively
+   *     impacts ExoPlayer. False otherwise.
+   */
+  private static boolean deviceNeedsAutoFrcWorkaround() {
+    // nVidia Shield prior to M tries to adjust the playback rate to better map the frame-rate of
+    // content to the refresh rate of the display. For example playback of 23.976fps content is
+    // adjusted to play at 1.001x speed when the output display is 60Hz. Unfortunately the
+    // implementation causes ExoPlayer's reported playback position to drift out of sync. Captions
+    // also lose sync [Internal: b/26453592].
+    return Util.SDK_INT <= 22 && "foster".equals(Util.DEVICE) && "NVIDIA".equals(Util.MANUFACTURER);
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
index cc3f114b7d..d5e82482ff 100644
--- a/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java
@@ -87,7 +87,8 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
 
   }
 
-  // TODO: Use MediaFormat constants if these get exposed through the API. See [Internal: b/14127601].
+  // TODO: Use MediaFormat constants if these get exposed through the API. See
+  // [Internal: b/14127601].
   private static final String KEY_CROP_LEFT = "crop-left";
   private static final String KEY_CROP_RIGHT = "crop-right";
   private static final String KEY_CROP_BOTTOM = "crop-bottom";
diff --git a/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
index ec7a8dcbb7..ca66e23316 100644
--- a/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
@@ -57,6 +57,7 @@
   private byte[] sampleData;
   private int sampleSize;
 
+  private long pendingDiscontinuityPositionUs;
   private boolean loadingFinished;
   private Loader loader;
   private IOException currentLoadableException;
@@ -102,6 +103,7 @@ public MediaFormat getFormat(int track) {
   @Override
   public void enable(int track, long positionUs) {
     state = STATE_SEND_FORMAT;
+    pendingDiscontinuityPositionUs = NO_DISCONTINUITY;
     clearCurrentLoadableException();
     maybeStartLoading();
   }
@@ -121,7 +123,9 @@ public void maybeThrowError() throws IOException {
 
   @Override
   public long readDiscontinuity(int track) {
-    return NO_DISCONTINUITY;
+    long discontinuityPositionUs = pendingDiscontinuityPositionUs;
+    pendingDiscontinuityPositionUs = NO_DISCONTINUITY;
+    return discontinuityPositionUs;
   }
 
   @Override
@@ -152,6 +156,7 @@ public int readData(int track, long positionUs, MediaFormatHolder formatHolder,
   @Override
   public void seekToUs(long positionUs) {
     if (state == STATE_END_OF_STREAM) {
+      pendingDiscontinuityPositionUs = positionUs;
       state = STATE_SEND_SAMPLE;
     }
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java b/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
deleted file mode 100644
index 12fd645fa9..0000000000
--- a/library/src/main/java/com/google/android/exoplayer/chunk/SingleSampleChunkSource.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer.chunk;
-
-import com.google.android.exoplayer.C;
-import com.google.android.exoplayer.MediaFormat;
-import com.google.android.exoplayer.upstream.DataSource;
-import com.google.android.exoplayer.upstream.DataSpec;
-
-import java.util.List;
-
-/**
- * A chunk source that provides a single chunk containing a single sample.
- * <p>
- * An example use case for this implementation is to act as the source for loading out-of-band
- * subtitles, where subtitles for the entire video are delivered as a single file.
- */
-public final class SingleSampleChunkSource implements ChunkSource {
-
-  private final DataSource dataSource;
-  private final DataSpec dataSpec;
-  private final Format format;
-  private final long durationUs;
-  private final MediaFormat mediaFormat;
-
-  /**
-   * @param dataSource A {@link DataSource} suitable for loading the sample data.
-   * @param dataSpec Defines the location of the sample.
-   * @param format The format of the sample.
-   * @param durationUs The duration of the sample in microseconds, or {@link C#UNKNOWN_TIME_US} if
-   *     the duration is unknown, or {@link C#MATCH_LONGEST_US} if the duration should match the
-   *     duration of the longest track whose duration is known.
-   * @param mediaFormat The sample media format. May be null.
-   */
-  public SingleSampleChunkSource(DataSource dataSource, DataSpec dataSpec, Format format,
-      long durationUs, MediaFormat mediaFormat) {
-    this.dataSource = dataSource;
-    this.dataSpec = dataSpec;
-    this.format = format;
-    this.durationUs = durationUs;
-    this.mediaFormat = mediaFormat;
-  }
-
-  @Override
-  public boolean prepare() {
-    return true;
-  }
-
-  @Override
-  public int getTrackCount() {
-    return 1;
-  }
-
-  @Override
-  public MediaFormat getFormat(int track) {
-    return mediaFormat;
-  }
-
-  @Override
-  public void enable(int track) {
-    // Do nothing.
-  }
-
-  @Override
-  public void continueBuffering(long playbackPositionUs) {
-    // Do nothing.
-  }
-
-  @Override
-  public void getChunkOperation(List<? extends MediaChunk> queue, long playbackPositionUs,
-      ChunkOperationHolder out) {
-    if (!queue.isEmpty()) {
-      // We've already provided the single sample.
-      out.endOfStream = true;
-      return;
-    }
-    out.chunk = initChunk();
-  }
-
-  @Override
-  public void disable(List<? extends MediaChunk> queue) {
-    // Do nothing.
-  }
-
-  @Override
-  public void maybeThrowError() {
-    // Do nothing.
-  }
-
-  @Override
-  public void onChunkLoadCompleted(Chunk chunk) {
-    // Do nothing.
-  }
-
-  @Override
-  public void onChunkLoadError(Chunk chunk, Exception e) {
-    // Do nothing.
-  }
-
-  private SingleSampleMediaChunk initChunk() {
-    return new SingleSampleMediaChunk(dataSource, dataSpec, Chunk.TRIGGER_UNSPECIFIED, format, 0,
-        durationUs, 0, mediaFormat, null, Chunk.NO_PARENT_ID);
-  }
-
-}
diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
index 84717b9c79..b2f1c39f37 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
@@ -152,8 +152,12 @@ private static boolean isFormatPlayable(Format format, String[] allowedContainer
       return false;
     }
     if (format.width > 0 && format.height > 0) {
-      String videoMediaMimeType = MimeTypes.getVideoMediaMimeType(format.codecs);
-      if (Util.SDK_INT >= 21 && !MimeTypes.VIDEO_UNKNOWN.equals(videoMediaMimeType)) {
+      if (Util.SDK_INT >= 21) {
+        String videoMediaMimeType = MimeTypes.getVideoMediaMimeType(format.codecs);
+        if (MimeTypes.VIDEO_UNKNOWN.equals(videoMediaMimeType)) {
+          // Assume the video is H.264.
+          videoMediaMimeType = MimeTypes.VIDEO_H264;
+        }
         if (format.frameRate > 0) {
           return MediaCodecUtil.isSizeAndRateSupportedV21(videoMediaMimeType, false, format.width,
               format.height, format.frameRate);
@@ -162,9 +166,9 @@ private static boolean isFormatPlayable(Format format, String[] allowedContainer
               format.height);
         }
       }
-      //Assuming that the media is H.264
+      // Assume the video is H.264.
       if (format.width * format.height > maxDecodableFrameSize) {
-        // Filtering stream that device cannot play
+        // Filtering format because it exceeds the maximum decodable frame size.
         return false;
       }
     }
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index eec4ea5e98..420bd39899 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -426,14 +426,20 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long playb
         // we'll need to wait until it's refreshed. If it's unbounded we just need to wait for a
         // while before attempting to load the chunk.
         return;
-      } else if (!currentManifest.dynamic) {
-        // The current manifest isn't dynamic, so check whether we've reached the end of the stream.
+      } else {
+        // A period's duration is the maximum of its various representation's durations, so it's
+        // possible that due to the minor differences between them our available range values might
+        // not sync exactly with the actual available content, so double check whether or not we've
+        // really run out of content to play.
         PeriodHolder lastPeriodHolder = periodHolders.valueAt(periodHolders.size() - 1);
         if (previous.parentId == lastPeriodHolder.localIndex) {
           RepresentationHolder representationHolder =
               lastPeriodHolder.representationHolders.get(previous.format.id);
           if (representationHolder.isBeyondLastSegment(previous.getNextChunkIndex())) {
-            out.endOfStream = true;
+            if (!currentManifest.dynamic) {
+              // The current manifest isn't dynamic, so we've reached the end of the stream.
+              out.endOfStream = true;
+            }
             return;
           }
         }
@@ -644,11 +650,15 @@ private static String getMediaMimeType(Format format) {
       return MimeTypes.getVideoMediaMimeType(format.codecs);
     } else if (mimeTypeIsRawText(formatMimeType)) {
       return formatMimeType;
-    } else if (MimeTypes.APPLICATION_MP4.equals(formatMimeType) && "stpp".equals(format.codecs)) {
-      return MimeTypes.APPLICATION_TTML;
-    } else {
-      return null;
+    } else if (MimeTypes.APPLICATION_MP4.equals(formatMimeType)) {
+      if ("stpp".equals(format.codecs)) {
+        return MimeTypes.APPLICATION_TTML;
+      }
+      if ("wvtt".equals(format.codecs)) {
+        return MimeTypes.APPLICATION_MP4VTT;
+      }
     }
+    return null;
   }
 
   /* package */ static boolean mimeTypeIsWebm(String mimeType) {
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
index f14fa0816a..538f0bb005 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/mpd/MediaPresentationDescriptionParser.java
@@ -32,6 +32,7 @@
 
 import android.text.TextUtils;
 import android.util.Base64;
+import android.util.Log;
 import android.util.Pair;
 
 import org.xml.sax.helpers.DefaultHandler;
@@ -56,6 +57,8 @@
 public class MediaPresentationDescriptionParser extends DefaultHandler
     implements UriLoadable.Parser<MediaPresentationDescription> {
 
+  private static final String TAG = "MediaPresentationDescriptionParser";
+
   private static final Pattern FRAME_RATE_PATTERN = Pattern.compile("(\\d+)(?:/(\\d+))?");
 
   private final String contentId;
@@ -149,12 +152,11 @@ protected MediaPresentationDescription parseMediaPresentationDescription(XmlPull
       }
     } while (!ParserUtil.isEndTag(xpp, "MPD"));
 
-    if (!dynamic && durationMs == -1) {
-      // The manifest is static and doesn't define a duration. This is unexpected.
+    if (durationMs == -1) {
       if (nextPeriodStartMs != -1) {
         // If we know the end time of the final period, we can use it as the duration.
         durationMs = nextPeriodStartMs;
-      } else {
+      } else if (!dynamic) {
         throw new ParserException("Unable to determine duration of static manifest.");
       }
     }
@@ -245,7 +247,10 @@ protected AdaptationSet parseAdaptationSet(XmlPullParser xpp, String baseUrl,
           seenFirstBaseUrl = true;
         }
       } else if (ParserUtil.isStartTag(xpp, "ContentProtection")) {
-        contentProtectionsBuilder.addAdaptationSetProtection(parseContentProtection(xpp));
+        ContentProtection contentProtection = parseContentProtection(xpp);
+        if (contentProtection != null) {
+          contentProtectionsBuilder.addAdaptationSetProtection(contentProtection);
+        }
       } else if (ParserUtil.isStartTag(xpp, "ContentComponent")) {
         language = checkLanguageConsistency(language, xpp.getAttributeValue(null, "lang"));
         contentType = checkContentTypeConsistency(contentType, parseContentType(xpp));
@@ -308,10 +313,11 @@ protected int getContentType(Representation representation) {
   }
 
   /**
-   * Parses a ContentProtection element.
+   * Parses a {@link ContentProtection} element.
    *
    * @throws XmlPullParserException If an error occurs parsing the element.
    * @throws IOException If an error occurs reading the element.
+   * @return The parsed {@link ContentProtection} element, or null if the element is unsupported.
    **/
   protected ContentProtection parseContentProtection(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
@@ -320,16 +326,17 @@ protected ContentProtection parseContentProtection(XmlPullParser xpp)
     SchemeInitData data = null;
     do {
       xpp.next();
-      // The cenc:pssh element is defined in 23001-7:2015
+      // The cenc:pssh element is defined in 23001-7:2015.
       if (ParserUtil.isStartTag(xpp, "cenc:pssh") && xpp.next() == XmlPullParser.TEXT) {
         data = new SchemeInitData(MimeTypes.VIDEO_MP4,
             Base64.decode(xpp.getText(), Base64.DEFAULT));
         uuid = PsshAtomUtil.parseUuid(data.data);
-        if (uuid == null) {
-          throw new ParserException("Invalid pssh atom in cenc:pssh element");
-        }
       }
     } while (!ParserUtil.isEndTag(xpp, "ContentProtection"));
+    if (uuid == null) {
+      Log.w(TAG, "Skipped unsupported ContentProtection element");
+      return null;
+    }
     return buildContentProtection(schemeIdUri, uuid, data);
   }
 
@@ -387,7 +394,10 @@ protected Representation parseRepresentation(XmlPullParser xpp, String baseUrl,
       } else if (ParserUtil.isStartTag(xpp, "SegmentTemplate")) {
         segmentBase = parseSegmentTemplate(xpp, baseUrl, (SegmentTemplate) segmentBase);
       } else if (ParserUtil.isStartTag(xpp, "ContentProtection")) {
-        contentProtectionsBuilder.addRepresentationProtection(parseContentProtection(xpp));
+        ContentProtection contentProtection = parseContentProtection(xpp);
+        if (contentProtection != null) {
+          contentProtectionsBuilder.addAdaptationSetProtection(contentProtection);
+        }
       }
     } while (!ParserUtil.isEndTag(xpp, "Representation"));
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
index ca60e546b8..07264cb866 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/DefaultExtractorInput.java
@@ -80,7 +80,8 @@ public void readFully(byte[] target, int offset, int length)
   public int skip(int length) throws IOException, InterruptedException {
     int bytesSkipped = skipFromPeekBuffer(length);
     if (bytesSkipped == 0) {
-      bytesSkipped = readFromDataSource(SCRATCH_SPACE, 0, length, 0, true);
+      bytesSkipped =
+          readFromDataSource(SCRATCH_SPACE, 0, Math.min(length, SCRATCH_SPACE.length), 0, true);
     }
     commitBytesRead(bytesSkipped);
     return bytesSkipped;
@@ -146,6 +147,11 @@ public void resetPeekPosition() {
     peekBufferPosition = 0;
   }
 
+  @Override
+  public long getPeekPosition() {
+    return position + peekBufferPosition;
+  }
+
   @Override
   public long getPosition() {
     return position;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
index 87c141c0b2..6e03e932a6 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorInput.java
@@ -203,7 +203,14 @@ boolean advancePeekPosition(int length, boolean allowEndOfInput)
   void resetPeekPosition();
 
   /**
-   * The current read position (byte offset) in the stream.
+   * Returns the current peek position (byte offset) in the stream.
+   *
+   * @return The peek position (byte offset) in the stream.
+   */
+  long getPeekPosition();
+
+  /**
+   * Returns the current read position (byte offset) in the stream.
    *
    * @return The read position (byte offset) in the stream.
    */
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/GaplessInfo.java b/library/src/main/java/com/google/android/exoplayer/extractor/GaplessInfo.java
new file mode 100644
index 0000000000..bf5a681009
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/GaplessInfo.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Utility for parsing and representing gapless playback information.
+ */
+public final class GaplessInfo {
+
+  private static final String GAPLESS_COMMENT_ID = "iTunSMPB";
+  private static final Pattern GAPLESS_COMMENT_PATTERN =
+      Pattern.compile("^ [0-9a-fA-F]{8} ([0-9a-fA-F]{8}) ([0-9a-fA-F]{8})");
+
+  /**
+   * Parses a gapless playback comment (stored in an ID3 header or MPEG 4 user data).
+   *
+   * @param name The comment's identifier.
+   * @param data The comment's payload data.
+   * @return Parsed gapless playback information, if present and non-zero. {@code null} otherwise.
+   */
+  public static GaplessInfo createFromComment(String name, String data) {
+    if (!GAPLESS_COMMENT_ID.equals(name)) {
+      return null;
+    }
+    Matcher matcher = GAPLESS_COMMENT_PATTERN.matcher(data);
+    if (matcher.find()) {
+      try {
+        int encoderDelay = Integer.parseInt(matcher.group(1), 16);
+        int encoderPadding = Integer.parseInt(matcher.group(2), 16);
+        return encoderDelay == 0 && encoderPadding == 0 ? null
+            : new GaplessInfo(encoderDelay, encoderPadding);
+      } catch (NumberFormatException e) {
+        // Ignore incorrectly formatted comments.
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Parses gapless playback information associated with an MP3 Xing header.
+   *
+   * @param value The 24-bit value to parse.
+   * @return Parsed gapless playback information, if non-zero. {@code null} otherwise.
+   */
+  public static GaplessInfo createFromXingHeaderValue(int value) {
+    int encoderDelay = value >> 12;
+    int encoderPadding = value & 0x0FFF;
+    return encoderDelay == 0 && encoderPadding == 0 ? null
+        : new GaplessInfo(encoderDelay, encoderPadding);
+  }
+
+  /**
+   * The number of samples to trim from the start of the decoded audio stream.
+   */
+  public final int encoderDelay;
+  /**
+   * The number of samples to trim from the end of the decoded audio stream.
+   */
+  public final int encoderPadding;
+
+  /**
+   * Creates a new {@link GaplessInfo} with the specified encoder delay and padding.
+   *
+   * @param encoderDelay The encoder delay.
+   * @param encoderPadding The encoder padding.
+   */
+  private GaplessInfo(int encoderDelay, int encoderPadding) {
+    this.encoderDelay = encoderDelay;
+    this.encoderPadding = encoderPadding;
+  }
+
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Id3Util.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Id3Util.java
index 06aa5add34..7b158f71cd 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Id3Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Id3Util.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer.extractor.mp3;
 
 import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.GaplessInfo;
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
@@ -23,8 +24,6 @@
 
 import java.io.IOException;
 import java.nio.charset.Charset;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 /**
  * Utility for parsing ID3 version 2 metadata in MP3 files.
@@ -37,9 +36,6 @@
   private static final int MAXIMUM_METADATA_SIZE = 3 * 1024 * 1024;
 
   private static final int ID3_TAG = Util.getIntegerCodeForString("ID3");
-  private static final String GAPLESS_COMMENT_NAME = "iTunSMPB";
-  private static final Pattern GAPLESS_COMMENT_VALUE_PATTERN =
-      Pattern.compile("^ [0-9a-fA-F]{8} ([0-9a-fA-F]{8}) ([0-9a-fA-F]{8})");
   private static final Charset[] CHARSET_BY_ENCODING = new Charset[] {Charset.forName("ISO-8859-1"),
       Charset.forName("UTF-16LE"), Charset.forName("UTF-16BE"), Charset.forName("UTF-8")};
 
@@ -47,17 +43,15 @@
    * Peeks data from the input and parses ID3 metadata.
    *
    * @param input The {@link ExtractorInput} from which data should be peeked.
-   * @param out {@link Mp3Extractor.Metadata} to populate based on the input.
-   * @return The number of bytes peeked from the input.
+   * @return The gapless playback information, if present and non-zero. {@code null} otherwise.
    * @throws IOException If an error occurred peeking from the input.
    * @throws InterruptedException If the thread was interrupted.
    */
-  public static int parseId3(ExtractorInput input, Mp3Extractor.Metadata out)
+  public static GaplessInfo parseId3(ExtractorInput input)
       throws IOException, InterruptedException {
-    out.encoderDelay = 0;
-    out.encoderPadding = 0;
     ParsableByteArray scratch = new ParsableByteArray(10);
     int peekedId3Bytes = 0;
+    GaplessInfo metadata = null;
     while (true) {
       input.peekFully(scratch.data, 0, 10);
       scratch.setPosition(0);
@@ -69,10 +63,10 @@ public static int parseId3(ExtractorInput input, Mp3Extractor.Metadata out)
       int minorVersion = scratch.readUnsignedByte();
       int flags = scratch.readUnsignedByte();
       int length = scratch.readSynchSafeInt();
-      if (canParseMetadata(majorVersion, minorVersion, flags, length)) {
+      if (metadata == null && canParseMetadata(majorVersion, minorVersion, flags, length)) {
         byte[] frame = new byte[length];
         input.peekFully(frame, 0, length);
-        parseMetadata(new ParsableByteArray(frame), majorVersion, flags, out);
+        metadata = parseGaplessInfo(new ParsableByteArray(frame), majorVersion, flags);
       } else {
         input.advancePeekPosition(length);
       }
@@ -81,7 +75,7 @@ public static int parseId3(ExtractorInput input, Mp3Extractor.Metadata out)
     }
     input.resetPeekPosition();
     input.advancePeekPosition(peekedId3Bytes);
-    return peekedId3Bytes;
+    return metadata;
   }
 
   private static boolean canParseMetadata(int majorVersion, int minorVersion, int flags,
@@ -93,19 +87,18 @@ private static boolean canParseMetadata(int majorVersion, int minorVersion, int
         && !(majorVersion == 4 && (flags & 0x0F) != 0);
   }
 
-  private static void parseMetadata(ParsableByteArray frame, int version, int flags,
-      Mp3Extractor.Metadata out) {
+  private static GaplessInfo parseGaplessInfo(ParsableByteArray frame, int version, int flags) {
     unescape(frame, version, flags);
 
     // Skip any extended header.
     frame.setPosition(0);
     if (version == 3 && (flags & 0x40) != 0) {
       if (frame.bytesLeft() < 4) {
-        return;
+        return null;
       }
       int extendedHeaderSize = frame.readUnsignedIntToInt();
       if (extendedHeaderSize > frame.bytesLeft()) {
-        return;
+        return null;
       }
       int paddingSize = 0;
       if (extendedHeaderSize >= 6) {
@@ -114,17 +107,17 @@ private static void parseMetadata(ParsableByteArray frame, int version, int flag
         frame.setPosition(4);
         frame.setLimit(frame.limit() - paddingSize);
         if (frame.bytesLeft() < extendedHeaderSize) {
-          return;
+          return null;
         }
       }
       frame.skipBytes(extendedHeaderSize);
     } else if (version == 4 && (flags & 0x40) != 0) {
       if (frame.bytesLeft() < 4) {
-        return;
+        return null;
       }
       int extendedHeaderSize = frame.readSynchSafeInt();
       if (extendedHeaderSize < 6 || extendedHeaderSize > frame.bytesLeft() + 4) {
-        return;
+        return null;
       }
       frame.setPosition(extendedHeaderSize);
     }
@@ -132,20 +125,15 @@ private static void parseMetadata(ParsableByteArray frame, int version, int flag
     // Extract gapless playback metadata stored in comments.
     Pair<String, String> comment;
     while ((comment = findNextComment(version, frame)) != null) {
-      if (comment.first.length() > 3 && comment.first.substring(3).equals(GAPLESS_COMMENT_NAME)) {
-        Matcher matcher = GAPLESS_COMMENT_VALUE_PATTERN.matcher(comment.second);
-        if (matcher.find()) {
-          try {
-            out.encoderDelay = Integer.parseInt(matcher.group(1), 16);
-            out.encoderPadding = Integer.parseInt(matcher.group(2), 16);
-            break;
-          } catch (NumberFormatException e) {
-            out.encoderDelay = 0;
-            return;
-          }
+      if (comment.first.length() > 3) {
+        GaplessInfo gaplessInfo =
+            GaplessInfo.createFromComment(comment.first.substring(3), comment.second);
+        if (gaplessInfo != null) {
+          return gaplessInfo;
         }
       }
     }
+    return null;
   }
 
   private static Pair<String, String> findNextComment(int majorVersion, ParsableByteArray data) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
index e16d294845..05359c8df9 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/Mp3Extractor.java
@@ -21,6 +21,7 @@
 import com.google.android.exoplayer.extractor.Extractor;
 import com.google.android.exoplayer.extractor.ExtractorInput;
 import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.GaplessInfo;
 import com.google.android.exoplayer.extractor.PositionHolder;
 import com.google.android.exoplayer.extractor.SeekMap;
 import com.google.android.exoplayer.extractor.TrackOutput;
@@ -56,7 +57,6 @@
   private final long forcedFirstSampleTimestampUs;
   private final ParsableByteArray scratch;
   private final MpegAudioHeader synchronizedHeader;
-  private final Metadata metadata;
 
   // Extractor outputs.
   private ExtractorOutput extractorOutput;
@@ -64,6 +64,7 @@
 
   private int synchronizedHeaderData;
 
+  private GaplessInfo gaplessInfo;
   private Seeker seeker;
   private long basisTimeUs;
   private int samplesRead;
@@ -86,7 +87,6 @@ public Mp3Extractor(long forcedFirstSampleTimestampUs) {
     this.forcedFirstSampleTimestampUs = forcedFirstSampleTimestampUs;
     scratch = new ParsableByteArray(4);
     synchronizedHeader = new MpegAudioHeader();
-    metadata = new Metadata();
     basisTimeUs = -1;
   }
 
@@ -194,11 +194,15 @@ private boolean synchronizeCatchingEndOfInput(ExtractorInput input)
 
   private boolean synchronize(ExtractorInput input, boolean sniffing)
       throws IOException, InterruptedException {
-    input.resetPeekPosition();
     int searched = 0;
     int validFrameCount = 0;
     int candidateSynchronizedHeaderData = 0;
-    int peekedId3Bytes = input.getPosition() == 0 ? Id3Util.parseId3(input, metadata) : 0;
+    int peekedId3Bytes = 0;
+    input.resetPeekPosition();
+    if (input.getPosition() == 0) {
+      gaplessInfo = Id3Util.parseId3(input);
+      peekedId3Bytes = (int) input.getPeekPosition();
+    }
     while (true) {
       if (sniffing && searched == MAX_SNIFF_BYTES) {
         return false;
@@ -274,15 +278,13 @@ private void setupSeeker(ExtractorInput input) throws IOException, InterruptedEx
     int headerData = frame.readInt();
     if (headerData == XING_HEADER || headerData == INFO_HEADER) {
       seeker = XingSeeker.create(synchronizedHeader, frame, position, length);
-      if (seeker != null && metadata.encoderDelay == 0 && metadata.encoderPadding == 0) {
+      if (seeker != null && gaplessInfo == null) {
         // If there is a Xing header, read gapless playback metadata at a fixed offset.
         input.resetPeekPosition();
         input.advancePeekPosition(xingBase + 141);
         input.peekFully(scratch.data, 0, 3);
         scratch.setPosition(0);
-        int gaplessMetadata = scratch.readUnsignedInt24();
-        metadata.encoderDelay = gaplessMetadata >> 12;
-        metadata.encoderPadding = gaplessMetadata & 0x0FFF;
+        gaplessInfo = GaplessInfo.createFromXingHeaderValue(scratch.readUnsignedInt24());
       }
       input.skipFully(synchronizedHeader.frameSize);
     } else {
@@ -290,7 +292,7 @@ private void setupSeeker(ExtractorInput input) throws IOException, InterruptedEx
       frame.setPosition(36); // MPEG audio header (4 bytes) + 32 bytes.
       headerData = frame.readInt();
       if (headerData == VBRI_HEADER) {
-        seeker = VbriSeeker.create(synchronizedHeader, frame, position);
+        seeker = VbriSeeker.create(synchronizedHeader, frame, position, length);
         input.skipFully(synchronizedHeader.frameSize);
       }
     }
@@ -325,11 +327,4 @@ private void setupSeeker(ExtractorInput input) throws IOException, InterruptedEx
 
   }
 
-  /* package */ static final class Metadata {
-
-    public int encoderDelay;
-    public int encoderPadding;
-
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
index 170a944409..8d0c0000d2 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp3/VbriSeeker.java
@@ -34,11 +34,12 @@
    * @param frame The data in this audio frame, with its position set to immediately after the
    *     'VBRI' tag.
    * @param position The position (byte offset) of the start of this frame in the stream.
+   * @param inputLength The length of the stream in bytes.
    * @return A {@link VbriSeeker} for seeking in the stream, or {@code null} if the required
    *     information is not present.
    */
   public static VbriSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArray frame,
-      long position) {
+      long position, long inputLength) {
     frame.skipBytes(10);
     int numFrames = frame.readInt();
     if (numFrames <= 0) {
@@ -47,53 +48,52 @@ public static VbriSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArr
     int sampleRate = mpegAudioHeader.sampleRate;
     long durationUs = Util.scaleLargeTimestamp(numFrames,
         C.MICROS_PER_SECOND * (sampleRate >= 32000 ? 1152 : 576), sampleRate);
-    int numEntries = frame.readUnsignedShort();
+    int entryCount = frame.readUnsignedShort();
     int scale = frame.readUnsignedShort();
     int entrySize = frame.readUnsignedShort();
+    frame.skipBytes(2);
 
-    // Read entries in the VBRI header.
-    long[] timesUs = new long[numEntries];
-    long[] offsets = new long[numEntries];
-    long segmentDurationUs = durationUs / numEntries;
-    long now = 0;
-    int segmentIndex = 0;
-    while (segmentIndex < numEntries) {
-      int numBytes;
+    // Skip the frame containing the VBRI header.
+    position += mpegAudioHeader.frameSize;
+
+    // Read table of contents entries.
+    long[] timesUs = new long[entryCount + 1];
+    long[] positions = new long[entryCount + 1];
+    timesUs[0] = 0L;
+    positions[0] = position;
+    for (int index = 1; index < timesUs.length; index++) {
+      int segmentSize;
       switch (entrySize) {
         case 1:
-          numBytes = frame.readUnsignedByte();
+          segmentSize = frame.readUnsignedByte();
           break;
         case 2:
-          numBytes = frame.readUnsignedShort();
+          segmentSize = frame.readUnsignedShort();
           break;
         case 3:
-          numBytes = frame.readUnsignedInt24();
+          segmentSize = frame.readUnsignedInt24();
           break;
         case 4:
-          numBytes = frame.readUnsignedIntToInt();
+          segmentSize = frame.readUnsignedIntToInt();
           break;
         default:
           return null;
       }
-      now += segmentDurationUs;
-      timesUs[segmentIndex] = now;
-      position += numBytes * scale;
-      offsets[segmentIndex] = position;
-
-      segmentIndex++;
+      position += segmentSize * scale;
+      timesUs[index] = index * durationUs / entryCount;
+      positions[index] =
+          inputLength == C.LENGTH_UNBOUNDED ? position : Math.min(inputLength, position);
     }
-    return new VbriSeeker(timesUs, offsets, position + mpegAudioHeader.frameSize, durationUs);
+    return new VbriSeeker(timesUs, positions, durationUs);
   }
 
   private final long[] timesUs;
   private final long[] positions;
-  private final long basePosition;
   private final long durationUs;
 
-  private VbriSeeker(long[] timesUs, long[] positions, long basePosition, long durationUs) {
+  private VbriSeeker(long[] timesUs, long[] positions, long durationUs) {
     this.timesUs = timesUs;
     this.positions = positions;
-    this.basePosition = basePosition;
     this.durationUs = durationUs;
   }
 
@@ -104,8 +104,7 @@ public boolean isSeekable() {
 
   @Override
   public long getPosition(long timeUs) {
-    int index = Util.binarySearchFloor(timesUs, timeUs, false, false);
-    return basePosition + (index == -1 ? 0L : positions[index]);
+    return positions[Util.binarySearchFloor(timesUs, timeUs, true, true)];
   }
 
   @Override
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
index ba281c5c24..48a30236e3 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Atom.java
@@ -114,6 +114,13 @@
   public static final int TYPE_stpp = Util.getIntegerCodeForString("stpp");
   public static final int TYPE_samr = Util.getIntegerCodeForString("samr");
   public static final int TYPE_sawb = Util.getIntegerCodeForString("sawb");
+  public static final int TYPE_udta = Util.getIntegerCodeForString("udta");
+  public static final int TYPE_meta = Util.getIntegerCodeForString("meta");
+  public static final int TYPE_ilst = Util.getIntegerCodeForString("ilst");
+  public static final int TYPE_mean = Util.getIntegerCodeForString("mean");
+  public static final int TYPE_name = Util.getIntegerCodeForString("name");
+  public static final int TYPE_data = Util.getIntegerCodeForString("data");
+  public static final int TYPE_DASHES = Util.getIntegerCodeForString("----");
 
   public final int type;
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 5691d927d5..9b3bb9c4f6 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.extractor.GaplessInfo;
 import com.google.android.exoplayer.util.Ac3Util;
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
@@ -330,6 +331,71 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         editedFlags);
   }
 
+  /**
+   * Parses a udta atom.
+   *
+   * @param udtaAtom The udta (user data) atom to parse.
+   * @return Gapless playback information stored in the user data, or {@code null} if not present.
+   */
+  public static GaplessInfo parseUdta(Atom.ContainerAtom udtaAtom) {
+    Atom.LeafAtom metaAtom = udtaAtom.getLeafAtomOfType(Atom.TYPE_meta);
+    if (metaAtom == null) {
+      return null;
+    }
+    ParsableByteArray data = metaAtom.data;
+    data.setPosition(Atom.FULL_HEADER_SIZE);
+    ParsableByteArray ilst = new ParsableByteArray();
+    while (data.bytesLeft() > 0) {
+      int length = data.readInt() - Atom.HEADER_SIZE;
+      int type = data.readInt();
+      if (type == Atom.TYPE_ilst) {
+        ilst.reset(data.data, data.getPosition() + length);
+        ilst.setPosition(data.getPosition());
+        GaplessInfo gaplessInfo = parseIlst(ilst);
+        if (gaplessInfo != null) {
+          return gaplessInfo;
+        }
+      }
+      data.skipBytes(length);
+    }
+    return null;
+  }
+
+  private static GaplessInfo parseIlst(ParsableByteArray ilst) {
+    while (ilst.bytesLeft() > 0) {
+      int position = ilst.getPosition();
+      int endPosition = position + ilst.readInt();
+      int type = ilst.readInt();
+      if (type == Atom.TYPE_DASHES) {
+        String lastCommentMean = null;
+        String lastCommentName = null;
+        String lastCommentData = null;
+        while (ilst.getPosition() < endPosition) {
+          int length = ilst.readInt() - Atom.FULL_HEADER_SIZE;
+          int key = ilst.readInt();
+          ilst.skipBytes(4);
+          if (key == Atom.TYPE_mean) {
+            lastCommentMean = ilst.readString(length);
+          } else if (key == Atom.TYPE_name) {
+            lastCommentName = ilst.readString(length);
+          } else if (key == Atom.TYPE_data) {
+            ilst.skipBytes(4);
+            lastCommentData = ilst.readString(length - 4);
+          } else {
+            ilst.skipBytes(length);
+          }
+        }
+        if (lastCommentName != null && lastCommentData != null
+            && "com.apple.iTunes".equals(lastCommentMean)) {
+          return GaplessInfo.createFromComment(lastCommentName, lastCommentData);
+        }
+      } else {
+        ilst.setPosition(endPosition);
+      }
+    }
+    return null;
+  }
+
   /**
    * Parses a mvhd atom (defined in 14496-12), returning the timescale for the movie.
    *
@@ -743,10 +809,12 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
       mimeType = MimeTypes.AUDIO_AC3;
     } else if (atomType == Atom.TYPE_ec_3) {
       mimeType = MimeTypes.AUDIO_E_AC3;
-    } else if (atomType == Atom.TYPE_dtsc || atomType == Atom.TYPE_dtse) {
+    } else if (atomType == Atom.TYPE_dtsc) {
       mimeType = MimeTypes.AUDIO_DTS;
     } else if (atomType == Atom.TYPE_dtsh || atomType == Atom.TYPE_dtsl) {
       mimeType = MimeTypes.AUDIO_DTS_HD;
+    } else if (atomType == Atom.TYPE_dtse) {
+      mimeType = MimeTypes.AUDIO_DTS_EXPRESS;
     } else if (atomType == Atom.TYPE_samr) {
       mimeType = MimeTypes.AUDIO_AMR_NB;
     } else if (atomType == Atom.TYPE_sawb) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
index 0e2cea9adb..e9d402efd2 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/FragmentedMp4Extractor.java
@@ -33,10 +33,13 @@
 import com.google.android.exoplayer.util.ParsableByteArray;
 import com.google.android.exoplayer.util.Util;
 
+import android.util.Log;
+
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Stack;
+import java.util.UUID;
 
 /**
  * Facilitates the extraction of data from the fragmented mp4 container format.
@@ -45,6 +48,8 @@
  */
 public final class FragmentedMp4Extractor implements Extractor {
 
+  private static final String TAG = "FragmentedMp4Extractor";
+
   /**
    * Flag to work around an issue in some video streams where every frame is marked as a sync frame.
    * The workaround overrides the sync frame flags in the stream, forcing them to false except for
@@ -299,8 +304,13 @@ private void onMoovContainerAtomRead(ContainerAtom moov) throws ParserException
           drmInitData = new DrmInitData.Mapped();
         }
         byte[] psshData = child.data.data;
-        drmInitData.put(PsshAtomUtil.parseUuid(psshData),
-            new SchemeInitData(MimeTypes.VIDEO_MP4, psshData));
+        UUID uuid = PsshAtomUtil.parseUuid(psshData);
+        if (uuid == null) {
+          Log.w(TAG, "Skipped pssh atom (failed to extract uuid)");
+        } else {
+          drmInitData.put(PsshAtomUtil.parseUuid(psshData),
+              new SchemeInitData(MimeTypes.VIDEO_MP4, psshData));
+        }
       }
     }
     if (drmInitData != null) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
index a1f01b0cb8..b47702f0f4 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/Mp4Extractor.java
@@ -268,10 +268,18 @@ private static boolean processFtypAtom(ParsableByteArray atomData) {
     return false;
   }
 
-  /** Updates the stored track metadata to reflect the contents of the specified moov atom. */
+  /**
+   * Updates the stored track metadata to reflect the contents of the specified moov atom.
+   */
   private void processMoovAtom(ContainerAtom moov) {
     List<Mp4Track> tracks = new ArrayList<>();
     long earliestSampleOffset = Long.MAX_VALUE;
+    // TODO: Apply gapless information.
+    // GaplessInfo gaplessInfo = null;
+    // Atom.ContainerAtom udta = moov.getContainerAtomOfType(Atom.TYPE_udta);
+    // if (udta != null) {
+    //   gaplessInfo = AtomParsers.parseUdta(udta);
+    // }
     for (int i = 0; i < moov.containerChildren.size(); i++) {
       Atom.ContainerAtom atom = moov.containerChildren.get(i);
       if (atom.type != Atom.TYPE_trak) {
@@ -410,19 +418,24 @@ private int getTrackIndexOfEarliestCurrentSample() {
     return earliestSampleTrackIndex;
   }
 
-  /** Returns whether the extractor should parse a leaf atom with type {@code atom}. */
+  /**
+   * Returns whether the extractor should parse a leaf atom with type {@code atom}.
+   */
   private static boolean shouldParseLeafAtom(int atom) {
     return atom == Atom.TYPE_mdhd || atom == Atom.TYPE_mvhd || atom == Atom.TYPE_hdlr
         || atom == Atom.TYPE_stsd || atom == Atom.TYPE_stts || atom == Atom.TYPE_stss
         || atom == Atom.TYPE_ctts || atom == Atom.TYPE_elst || atom == Atom.TYPE_stsc
         || atom == Atom.TYPE_stsz || atom == Atom.TYPE_stco || atom == Atom.TYPE_co64
-        || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_ftyp;
+        || atom == Atom.TYPE_tkhd || atom == Atom.TYPE_ftyp || atom == Atom.TYPE_meta;
   }
 
-  /** Returns whether the extractor should parse a container atom with type {@code atom}. */
+  /**
+   * Returns whether the extractor should parse a container atom with type {@code atom}.
+   */
   private static boolean shouldParseContainerAtom(int atom) {
     return atom == Atom.TYPE_moov || atom == Atom.TYPE_trak || atom == Atom.TYPE_mdia
-        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_edts;
+        || atom == Atom.TYPE_minf || atom == Atom.TYPE_stbl || atom == Atom.TYPE_edts
+        || atom == Atom.TYPE_udta;
   }
 
   private static final class Mp4Track {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/PsshAtomUtil.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/PsshAtomUtil.java
index 03b910d7f7..d250cb4a3a 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/PsshAtomUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/PsshAtomUtil.java
@@ -17,6 +17,9 @@
 
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import android.util.Log;
+import android.util.Pair;
+
 import java.nio.ByteBuffer;
 import java.util.UUID;
 
@@ -25,6 +28,8 @@
  */
 public final class PsshAtomUtil {
 
+  private static final String TAG = "PsshAtomUtil";
+
   private PsshAtomUtil() {}
 
   /**
@@ -48,75 +53,88 @@ private PsshAtomUtil() {}
   }
 
   /**
-   * Parses the UUID from a PSSH atom.
+   * Parses the UUID from a PSSH atom. Version 0 and 1 PSSH atoms are supported.
    * <p>
    * The UUID is only parsed if the data is a valid PSSH atom.
    *
    * @param atom The atom to parse.
-   * @return The parsed UUID. Null if the data is not a valid PSSH atom.
+   * @return The parsed UUID. Null if the input is not a valid PSSH atom, or if the PSSH atom has
+   *     an unsupported version.
    */
   public static UUID parseUuid(byte[] atom) {
-    ParsableByteArray atomData = new ParsableByteArray(atom);
-    if (!isPsshAtom(atomData, null)) {
+    Pair<UUID, byte[]> parsedAtom = parsePsshAtom(atom);
+    if (parsedAtom == null) {
       return null;
     }
-    atomData.setPosition(Atom.FULL_HEADER_SIZE);
-    return new UUID(atomData.readLong(), atomData.readLong());
+    return parsedAtom.first;
   }
 
   /**
-   * Parses the scheme specific data from a PSSH atom.
+   * Parses the scheme specific data from a PSSH atom. Version 0 and 1 PSSH atoms are supported.
    * <p>
    * The scheme specific data is only parsed if the data is a valid PSSH atom matching the given
    * UUID, or if the data is a valid PSSH atom of any type in the case that the passed UUID is null.
    *
    * @param atom The atom to parse.
    * @param uuid The required UUID of the PSSH atom, or null to accept any UUID.
-   * @return The parsed scheme specific data. Null if the data is not a valid PSSH atom or if its
-   *     UUID does not match the one provided.
+   * @return The parsed scheme specific data. Null if the input is not a valid PSSH atom, or if the
+   *     PSSH atom has an unsupported version, or if the PSSH atom does not match the passed UUID.
    */
   public static byte[] parseSchemeSpecificData(byte[] atom, UUID uuid) {
-    ParsableByteArray atomData = new ParsableByteArray(atom);
-    if (!isPsshAtom(atomData, uuid)) {
+    Pair<UUID, byte[]> parsedAtom = parsePsshAtom(atom);
+    if (parsedAtom == null) {
       return null;
     }
-    atomData.setPosition(Atom.FULL_HEADER_SIZE + 16 /* UUID */);
-    int dataSize = atomData.readInt();
-    byte[] data = new byte[dataSize];
-    atomData.readBytes(data, 0, dataSize);
-    return data;
+    if (uuid != null && !uuid.equals(parsedAtom.first)) {
+      Log.w(TAG, "UUID mismatch. Expected: " + uuid + ", got: " + parsedAtom.first + ".");
+      return null;
+    }
+    return parsedAtom.second;
   }
 
-  private static boolean isPsshAtom(ParsableByteArray atomData, UUID uuid) {
+  /**
+   * Parses the UUID and scheme specific data from a PSSH atom. Version 0 and 1 PSSH atoms are
+   * supported.
+   *
+   * @param atom The atom to parse.
+   * @return A pair consisting of the parsed UUID and scheme specific data. Null if the input is
+   *     not a valid PSSH atom, or if the PSSH atom has an unsupported version.
+   */
+  private static Pair<UUID, byte[]> parsePsshAtom(byte[] atom) {
+    ParsableByteArray atomData = new ParsableByteArray(atom);
     if (atomData.limit() < Atom.FULL_HEADER_SIZE + 16 /* UUID */ + 4 /* DataSize */) {
       // Data too short.
-      return false;
+      return null;
     }
     atomData.setPosition(0);
     int atomSize = atomData.readInt();
     if (atomSize != atomData.bytesLeft() + 4) {
       // Not an atom, or incorrect atom size.
-      return false;
+      return null;
     }
     int atomType = atomData.readInt();
     if (atomType != Atom.TYPE_pssh) {
       // Not an atom, or incorrect atom type.
-      return false;
+      return null;
     }
-    atomData.setPosition(Atom.FULL_HEADER_SIZE);
-    if (uuid == null) {
-      atomData.skipBytes(16);
-    } else if (atomData.readLong() != uuid.getMostSignificantBits()
-        || atomData.readLong() != uuid.getLeastSignificantBits()) {
-      // UUID doesn't match.
-      return false;
+    int atomVersion = Atom.parseFullAtomVersion(atomData.readInt());
+    if (atomVersion > 1) {
+      Log.w(TAG, "Unsupported pssh version: " + atomVersion);
+      return null;
+    }
+    UUID uuid = new UUID(atomData.readLong(), atomData.readLong());
+    if (atomVersion == 1) {
+      int keyIdCount = atomData.readUnsignedIntToInt();
+      atomData.skipBytes(16 * keyIdCount);
     }
-    int dataSize = atomData.readInt();
+    int dataSize = atomData.readUnsignedIntToInt();
     if (dataSize != atomData.bytesLeft()) {
       // Incorrect dataSize.
-      return false;
+      return null;
     }
-    return true;
+    byte[] data = new byte[dataSize];
+    atomData.readBytes(data, 0, dataSize);
+    return Pair.create(uuid, data);
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java
index b167fb5fe1..69663b22ed 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java
@@ -74,10 +74,12 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
-    if (startOfPacket) {
-      timeUs = pesTimeUs;
-    }
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    timeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
     while (data.bytesLeft() > 0) {
       switch (state) {
         case STATE_FINDING_SYNC:
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
index d83e9a1561..8c35de4002 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsExtractor.java
@@ -45,7 +45,7 @@
 
   // Accessed only by the loading thread.
   private AdtsReader adtsReader;
-  private boolean firstPacket;
+  private boolean startedPacket;
 
   public AdtsExtractor() {
     this(0);
@@ -54,7 +54,6 @@ public AdtsExtractor() {
   public AdtsExtractor(long firstSampleTimestampUs) {
     this.firstSampleTimestampUs = firstSampleTimestampUs;
     packetBuffer = new ParsableByteArray(MAX_PACKET_SIZE);
-    firstPacket = true;
   }
 
   @Override
@@ -117,7 +116,7 @@ public void init(ExtractorOutput output) {
 
   @Override
   public void seek() {
-    firstPacket = true;
+    startedPacket = false;
     adtsReader.seek();
   }
 
@@ -135,8 +134,12 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
     // TODO: Make it possible for adtsReader to consume the dataSource directly, so that it becomes
     // unnecessary to copy the data through packetBuffer.
-    adtsReader.consume(packetBuffer, firstSampleTimestampUs, firstPacket);
-    firstPacket = false;
+    if (!startedPacket) {
+      // Pass data to the reader as though it's contained within a single infinitely long packet.
+      adtsReader.packetStarted(firstSampleTimestampUs, true);
+      startedPacket = true;
+    }
+    adtsReader.consume(packetBuffer);
     return RESULT_CONTINUE;
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
index c4578f363a..ead08da623 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
@@ -93,10 +93,12 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
-    if (startOfPacket) {
-      timeUs = pesTimeUs;
-    }
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    timeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
     while (data.bytesLeft() > 0) {
       switch (state) {
         case STATE_FINDING_SAMPLE:
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/DtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/DtsReader.java
index d363c0de8b..cbc55fa4e9 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/DtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/DtsReader.java
@@ -73,10 +73,12 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
-    if (startOfPacket) {
-      timeUs = pesTimeUs;
-    }
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    timeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
     while (data.bytesLeft() > 0) {
       switch (state) {
         case STATE_FINDING_SYNC:
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/ElementaryStreamReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/ElementaryStreamReader.java
index 7bcdd1775a..3cd3fe6984 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/ElementaryStreamReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/ElementaryStreamReader.java
@@ -34,27 +34,26 @@ protected ElementaryStreamReader(TrackOutput output) {
 
   /**
    * Notifies the reader that a seek has occurred.
-   * <p>
-   * Following a call to this method, the data passed to the next invocation of
-   * {@link #consume(ParsableByteArray, long, boolean)} will not be a continuation of the data that
-   * was previously passed. Hence the reader should reset any internal state.
    */
   public abstract void seek();
 
   /**
-   * Consumes (possibly partial) payload data.
+   * Invoked when a packet starts.
    *
-   * @param data The payload data to consume.
-   * @param pesTimeUs The timestamp associated with the payload.
-   * @param startOfPacket True if this is the first time this method is being called for the
-   *     current packet. False otherwise.
+   * @param pesTimeUs The timestamp associated with the packet.
+   * @param dataAlignmentIndicator The data alignment indicator associated with the packet.
    */
-  public abstract void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket);
+  public abstract void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator);
 
   /**
-   * Invoked once all of the payload data for a packet has been passed to
-   * {@link #consume(ParsableByteArray, long, boolean)}. The next call to
-   * {@link #consume(ParsableByteArray, long, boolean)} will have {@code startOfPacket == true}.
+   * Consumes (possibly partial) data from the current packet.
+   *
+   * @param data The data to consume.
+   */
+  public abstract void consume(ParsableByteArray data);
+
+  /**
+   * Invoked when a packet ends.
    */
   public abstract void packetFinished();
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
index 6b5935f042..5ebcf025d0 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H262Reader.java
@@ -48,10 +48,13 @@
   // State that should be reset on seek.
   private final boolean[] prefixFlags;
   private final CsdBuffer csdBuffer;
-  private boolean foundFirstFrameInPacket;
   private boolean foundFirstFrameInGroup;
   private long totalBytesWritten;
 
+  // Per packet state that gets reset at the start of each packet.
+  private long pesTimeUs;
+  private boolean foundFirstFrameInPacket;
+
   // Per sample state that gets reset at the start of each frame.
   private boolean isKeyframe;
   private long framePosition;
@@ -73,10 +76,13 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
-    if (startOfPacket) {
-      foundFirstFrameInPacket = false;
-    }
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    this.pesTimeUs = pesTimeUs;
+    foundFirstFrameInPacket = false;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
     while (data.bytesLeft() > 0) {
       int offset = data.getPosition();
       int limit = data.limit();
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
index 0465e6f573..86c31d7c8b 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
@@ -57,6 +57,9 @@
   private boolean foundFirstSample;
   private long totalBytesWritten;
 
+  // Per packet state that gets reset at the start of each packet.
+  private long pesTimeUs;
+
   // Per sample state that gets reset at the start of each sample.
   private boolean isKeyframe;
   private long samplePosition;
@@ -78,7 +81,6 @@ public H264Reader(TrackOutput output, SeiReader seiReader, boolean idrKeyframesO
 
   @Override
   public void seek() {
-    seiReader.seek();
     NalUnitUtil.clearPrefixFlags(prefixFlags);
     sps.reset();
     pps.reset();
@@ -91,7 +93,12 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    this.pesTimeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
     while (data.bytesLeft() > 0) {
       int offset = data.getPosition();
       int limit = data.limit();
@@ -194,7 +201,7 @@ private void feedNalUnitTargetEnd(long pesTimeUs, int discardPadding) {
       int unescapedLength = NalUnitUtil.unescapeStream(sei.nalData, sei.nalLength);
       seiWrapper.reset(sei.nalData, unescapedLength);
       seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
-      seiReader.consume(seiWrapper, pesTimeUs, true);
+      seiReader.consume(pesTimeUs, seiWrapper);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
index 2ce1e3ec39..6031dc7a01 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
@@ -58,6 +58,9 @@
   private final SampleReader sampleReader;
   private long totalBytesWritten;
 
+  // Per packet state that gets reset at the start of each packet.
+  private long pesTimeUs;
+
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
@@ -76,7 +79,6 @@ public H265Reader(TrackOutput output, SeiReader seiReader) {
 
   @Override
   public void seek() {
-    seiReader.seek();
     NalUnitUtil.clearPrefixFlags(prefixFlags);
     vps.reset();
     sps.reset();
@@ -88,7 +90,12 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    this.pesTimeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
     while (data.bytesLeft() > 0) {
       int offset = data.getPosition();
       int limit = data.limit();
@@ -179,7 +186,7 @@ private void nalUnitEnd(long position, int offset, int discardPadding, long pesT
 
       // Skip the NAL prefix and type.
       seiWrapper.skipBytes(5);
-      seiReader.consume(seiWrapper, pesTimeUs, true);
+      seiReader.consume(pesTimeUs, seiWrapper);
     }
     if (suffixSei.endNalUnit(discardPadding)) {
       int unescapedLength = NalUnitUtil.unescapeStream(suffixSei.nalData, suffixSei.nalLength);
@@ -187,7 +194,7 @@ private void nalUnitEnd(long position, int offset, int discardPadding, long pesT
 
       // Skip the NAL prefix and type.
       seiWrapper.skipBytes(5);
-      seiReader.consume(seiWrapper, pesTimeUs, true);
+      seiReader.consume(pesTimeUs, seiWrapper);
     }
   }
 
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
index 569ae6acc4..e3a1c15954 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/Id3Reader.java
@@ -25,16 +25,22 @@
  */
 /* package */ final class Id3Reader extends ElementaryStreamReader {
 
+  private static final int ID3_HEADER_SIZE = 10;
+
+  private final ParsableByteArray id3Header;
+
   // State that should be reset on seek.
   private boolean writingSample;
 
   // Per sample state that gets reset at the start of each sample.
   private long sampleTimeUs;
   private int sampleSize;
+  private int sampleBytesRead;
 
   public Id3Reader(TrackOutput output) {
     super(output);
     output.format(MediaFormat.createId3Format());
+    id3Header = new ParsableByteArray(ID3_HEADER_SIZE);
   }
 
   @Override
@@ -43,20 +49,43 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
-    if (startOfPacket) {
-      writingSample = true;
-      sampleTimeUs = pesTimeUs;
-      sampleSize = 0;
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    if (!dataAlignmentIndicator) {
+      return;
     }
-    if (writingSample) {
-      sampleSize += data.bytesLeft();
-      output.sampleData(data, data.bytesLeft());
+    writingSample = true;
+    sampleTimeUs = pesTimeUs;
+    sampleSize = 0;
+    sampleBytesRead = 0;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
+    if (!writingSample) {
+      return;
+    }
+    int bytesAvailable = data.bytesLeft();
+    if (sampleBytesRead < ID3_HEADER_SIZE) {
+      // We're still reading the ID3 header.
+      int headerBytesAvailable = Math.min(bytesAvailable, ID3_HEADER_SIZE - sampleBytesRead);
+      System.arraycopy(data.data, data.getPosition(), id3Header.data, sampleBytesRead,
+          headerBytesAvailable);
+      if (sampleBytesRead + headerBytesAvailable == ID3_HEADER_SIZE) {
+        // We've finished reading the ID3 header. Extract the sample size.
+        id3Header.setPosition(6); // 'ID3' (3) + version (2) + flags (1)
+        sampleSize = ID3_HEADER_SIZE + id3Header.readSynchSafeInt();
+      }
     }
+    // Write data to the output.
+    output.sampleData(data, bytesAvailable);
+    sampleBytesRead += bytesAvailable;
   }
 
   @Override
   public void packetFinished() {
+    if (!writingSample || sampleSize == 0 || sampleBytesRead != sampleSize) {
+      return;
+    }
     output.sampleMetadata(sampleTimeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
     writingSample = false;
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
index ee8f84cfde..70ac6e579d 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpegAudioReader.java
@@ -66,10 +66,12 @@ public void seek() {
   }
 
   @Override
-  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
-    if (startOfPacket) {
-      timeUs = pesTimeUs;
-    }
+  public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
+    timeUs = pesTimeUs;
+  }
+
+  @Override
+  public void consume(ParsableByteArray data) {
     while (data.bytesLeft() > 0) {
       switch (state) {
         case STATE_FINDING_HEADER:
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
index 2aa143d44a..a4499fb9c4 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/SeiReader.java
@@ -23,26 +23,21 @@
 import com.google.android.exoplayer.util.ParsableByteArray;
 
 /**
- * Parses a SEI data from H.264 frames and extracts samples with closed captions data.
- *
- * TODO: Technically, we shouldn't allow a sample to be read from the queue until we're sure that
- * a sample with an earlier timestamp won't be added to it.
+ * Consumes SEI buffers, outputting contained EIA608 messages to a {@link TrackOutput}.
  */
-/* package */ final class SeiReader extends ElementaryStreamReader {
+// TODO: Technically, we shouldn't allow a sample to be read from the queue until we're sure that
+// a sample with an earlier timestamp won't be added to it.
+/* package */ final class SeiReader {
+
+  private final TrackOutput output;
 
   public SeiReader(TrackOutput output) {
-    super(output);
+    this.output = output;
     output.format(MediaFormat.createTextFormat(null, MimeTypes.APPLICATION_EIA608,
         MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, null));
   }
 
-  @Override
-  public void seek() {
-    // Do nothing.
-  }
-
-  @Override
-  public void consume(ParsableByteArray seiBuffer, long pesTimeUs, boolean startOfPacket) {
+  public void consume(long pesTimeUs, ParsableByteArray seiBuffer) {
     int b;
     while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
       // Parse payload type.
@@ -57,7 +52,7 @@ public void consume(ParsableByteArray seiBuffer, long pesTimeUs, boolean startOf
         b = seiBuffer.readUnsignedByte();
         payloadSize += b;
       } while (b == 0xFF);
-      // Process the payload. We only support EIA-608 payloads currently.
+      // Process the payload.
       if (Eia608Parser.isSeiMessageEia608(payloadType, payloadSize, seiBuffer)) {
         output.sampleData(seiBuffer, payloadSize);
         output.sampleMetadata(pesTimeUs, C.SAMPLE_FLAG_SYNC, payloadSize, 0, null);
@@ -67,9 +62,4 @@ public void consume(ParsableByteArray seiBuffer, long pesTimeUs, boolean startOf
     }
   }
 
-  @Override
-  public void packetFinished() {
-    // Do nothing.
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index bb8351ea5a..9fee879779 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -438,13 +438,13 @@ private int readPrivateDataStreamType(ParsableByteArray data, int length) {
 
     private int state;
     private int bytesRead;
-    private boolean bodyStarted;
 
     private boolean ptsFlag;
     private boolean dtsFlag;
     private boolean seenFirstDts;
     private int extendedHeaderLength;
     private int payloadSize;
+    private boolean dataAlignmentIndicator;
     private long timeUs;
 
     public PesReader(ElementaryStreamReader pesPayloadReader) {
@@ -457,7 +457,6 @@ public PesReader(ElementaryStreamReader pesPayloadReader) {
     public void seek() {
       state = STATE_FINDING_HEADER;
       bytesRead = 0;
-      bodyStarted = false;
       seenFirstDts = false;
       pesPayloadReader.seek();
     }
@@ -482,10 +481,8 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
             if (payloadSize != -1) {
               Log.w(TAG, "Unexpected start indicator: expected " + payloadSize + " more bytes");
             }
-            // Either way, if the body was started, notify the reader that it has now finished.
-            if (bodyStarted) {
-              pesPayloadReader.packetFinished();
-            }
+            // Either way, notify the reader that it has now finished.
+            pesPayloadReader.packetFinished();
             break;
         }
         setState(STATE_READING_HEADER);
@@ -507,7 +504,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
             if (continueRead(data, pesScratch.data, readLength)
                 && continueRead(data, null, extendedHeaderLength)) {
               parseHeaderExtension();
-              bodyStarted = false;
+              pesPayloadReader.packetStarted(timeUs, dataAlignmentIndicator);
               setState(STATE_READING_BODY);
             }
             break;
@@ -518,8 +515,7 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
               readLength -= padding;
               data.setLimit(data.getPosition() + readLength);
             }
-            pesPayloadReader.consume(data, timeUs, !bodyStarted);
-            bodyStarted = true;
+            pesPayloadReader.consume(data);
             if (payloadSize != -1) {
               payloadSize -= readLength;
               if (payloadSize == 0) {
@@ -572,9 +568,9 @@ private boolean parseHeader() {
 
       pesScratch.skipBits(8); // stream_id.
       int packetLength = pesScratch.readBits(16);
-      // First 8 bits are skipped: '10' (2), PES_scrambling_control (2), PES_priority (1),
-      // data_alignment_indicator (1), copyright (1), original_or_copy (1)
-      pesScratch.skipBits(8);
+      pesScratch.skipBits(5); // '10' (2), PES_scrambling_control (2), PES_priority (1)
+      dataAlignmentIndicator = pesScratch.readBit();
+      pesScratch.skipBits(2); // copyright (1), original_or_copy (1)
       ptsFlag = pesScratch.readBit();
       dtsFlag = pesScratch.readBit();
       // ESCR_flag (1), ES_rate_flag (1), DSM_trick_mode_flag (1),
diff --git a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
index 6efa6e95d9..26f1476ca9 100644
--- a/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
+++ b/library/src/main/java/com/google/android/exoplayer/smoothstreaming/SmoothStreamingManifestParser.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer.util.Assertions;
 import com.google.android.exoplayer.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.Util;
 
 import android.util.Base64;
 import android.util.Pair;
@@ -648,7 +649,7 @@ public void parseStartTag(XmlPullParser parser) throws ParserException {
 
       value = parser.getAttributeValue(null, KEY_CODEC_PRIVATE_DATA);
       if (value != null && value.length() > 0) {
-        byte[] codecPrivateData = hexStringToByteArray(value);
+        byte[] codecPrivateData = Util.getBytesFromHexString(value);
         byte[][] split = CodecSpecificDataUtil.splitNalUnits(codecPrivateData);
         if (split == null) {
           csd.add(codecPrivateData);
@@ -684,27 +685,18 @@ private static String fourCCToMimeType(String fourCC) {
         return MimeTypes.AUDIO_AC3;
       } else if (fourCC.equalsIgnoreCase("ec-3") || fourCC.equalsIgnoreCase("dec3")) {
         return MimeTypes.AUDIO_E_AC3;
-      } else if (fourCC.equalsIgnoreCase("dtsc") || fourCC.equalsIgnoreCase("dtse")) {
+      } else if (fourCC.equalsIgnoreCase("dtsc")) {
         return MimeTypes.AUDIO_DTS;
       } else if (fourCC.equalsIgnoreCase("dtsh") || fourCC.equalsIgnoreCase("dtsl")) {
         return MimeTypes.AUDIO_DTS_HD;
+      } else if (fourCC.equalsIgnoreCase("dtse")) {
+        return MimeTypes.AUDIO_DTS_EXPRESS;
       } else if (fourCC.equalsIgnoreCase("opus")) {
         return MimeTypes.AUDIO_OPUS;
       }
       return null;
     }
 
-    private static byte[] hexStringToByteArray(String hexString) {
-      int length = hexString.length();
-      byte[] data = new byte[length / 2];
-      for (int i = 0; i < data.length; i++) {
-        int stringOffset = i * 2;
-        data[i] = (byte) ((Character.digit(hexString.charAt(stringOffset), 16) << 4)
-            + Character.digit(hexString.charAt(stringOffset + 1), 16));
-      }
-      return data;
-    }
-
   }
 
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
index 865966ad53..ee489cb451 100644
--- a/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
+++ b/library/src/main/java/com/google/android/exoplayer/text/TextTrackRenderer.java
@@ -89,7 +89,7 @@
     }
     try {
       DEFAULT_PARSER_CLASSES.add(
-          Class.forName("com.google.android.exoplayer.text.mp4webvtt.Mp4WebvttParser")
+          Class.forName("com.google.android.exoplayer.text.webvtt.Mp4WebvttParser")
               .asSubclass(SubtitleParser.class));
     } catch (ClassNotFoundException e) {
       // Parser not found.
diff --git a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
index 38564f1ce5..02d5685e98 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/MimeTypes.java
@@ -49,6 +49,7 @@
   public static final String AUDIO_TRUEHD = BASE_TYPE_AUDIO + "/true-hd";
   public static final String AUDIO_DTS = BASE_TYPE_AUDIO + "/vnd.dts";
   public static final String AUDIO_DTS_HD = BASE_TYPE_AUDIO + "/vnd.dts.hd";
+  public static final String AUDIO_DTS_EXPRESS = BASE_TYPE_AUDIO + "/vnd.dts.hd;profile=lbr";
   public static final String AUDIO_VORBIS = BASE_TYPE_AUDIO + "/vorbis";
   public static final String AUDIO_OPUS = BASE_TYPE_AUDIO + "/opus";
   public static final String AUDIO_AMR_NB = BASE_TYPE_AUDIO + "/3gpp";
@@ -168,10 +169,12 @@ public static String getAudioMediaMimeType(String codecs) {
         return MimeTypes.AUDIO_AC3;
       } else if (codec.startsWith("ec-3") || codec.startsWith("dec3")) {
         return MimeTypes.AUDIO_E_AC3;
-      } else if (codec.startsWith("dtsc") || codec.startsWith("dtse")) {
+      } else if (codec.startsWith("dtsc")) {
         return MimeTypes.AUDIO_DTS;
       } else if (codec.startsWith("dtsh") || codec.startsWith("dtsl")) {
         return MimeTypes.AUDIO_DTS_HD;
+      } else if (codec.startsWith("dtse")) {
+        return MimeTypes.AUDIO_DTS_EXPRESS;
       } else if (codec.startsWith("opus")) {
         return MimeTypes.AUDIO_OPUS;
       } else if (codec.startsWith("vorbis")) {
diff --git a/library/src/main/java/com/google/android/exoplayer/util/Util.java b/library/src/main/java/com/google/android/exoplayer/util/Util.java
index edff76bdd6..bd057cfbf8 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/Util.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/Util.java
@@ -668,6 +668,22 @@ public static String getHexStringFromBytes(byte[] data, int beginIndex, int endI
     return dataStringBuilder.toString();
   }
 
+  /**
+   * Returns a byte array containing values parsed from the hex string provided.
+   *
+   * @param hexString The hex string to convert to bytes.
+   * @return A byte array containing values parsed from the hex string provided.
+   */
+  public static byte[] getBytesFromHexString(String hexString) {
+    byte[] data = new byte[hexString.length() / 2];
+    for (int i = 0; i < data.length; i++) {
+      int stringOffset = i * 2;
+      data[i] = (byte) ((Character.digit(hexString.charAt(stringOffset), 16) << 4)
+          + Character.digit(hexString.charAt(stringOffset + 1), 16));
+    }
+    return data;
+  }
+
   /**
    * Returns a string with comma delimited simple names of each object's class.
    *
diff --git a/playbacktests/src/main/AndroidManifest.xml b/playbacktests/src/main/AndroidManifest.xml
index 9aeb5b1478..d96d879161 100644
--- a/playbacktests/src/main/AndroidManifest.xml
+++ b/playbacktests/src/main/AndroidManifest.xml
@@ -17,8 +17,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer.playbacktests"
-    android:versionCode="1503"
-    android:versionName="1.5.4">
+    android:versionCode="1505"
+    android:versionName="1.5.5">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
