diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
index 425f2b77cd..9db33b019b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.extractor.amr.AmrExtractor;
 import com.google.android.exoplayer2.extractor.flv.FlvExtractor;
+import com.google.android.exoplayer2.extractor.flv.FlvExtractorAudioFix;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.extractor.mp3.Mp3Extractor;
 import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
@@ -169,7 +170,8 @@ public synchronized DefaultExtractorsFactory setTsExtractorFlags(
     extractors[4] = new AdtsExtractor();
     extractors[5] = new Ac3Extractor();
     extractors[6] = new TsExtractor(tsMode, tsFlags);
-    extractors[7] = new FlvExtractor();
+    extractors[7] = new FlvExtractorAudioFix();
+//    extractors[7] = new FlvExtractor();
     extractors[8] = new OggExtractor();
     extractors[9] = new PsExtractor();
     extractors[10] = new WavExtractor();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
index d908f28945..2d921e4af9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer2.extractor.flv;
 
 import android.support.annotation.IntDef;
+import android.util.Log;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -32,7 +34,7 @@
 /**
  * Extracts data from the FLV container format.
  */
-public final class FlvExtractor implements Extractor {
+public class FlvExtractor implements Extractor {
 
   /**
    * Factory for {@link FlvExtractor} instances.
@@ -41,7 +43,8 @@
 
     @Override
     public Extractor[] createExtractors() {
-      return new Extractor[] {new FlvExtractor()};
+//      return new Extractor[] {new FlvExtractor()};
+      return new Extractor[] {new FlvExtractorAudioFix()};
     }
 
   };
@@ -54,43 +57,45 @@
       STATE_READING_TAG_DATA})
   private @interface States {}
   private static final int STATE_READING_FLV_HEADER = 1;
-  private static final int STATE_SKIPPING_TO_TAG_HEADER = 2;
+  static final int STATE_SKIPPING_TO_TAG_HEADER = 2;
   private static final int STATE_READING_TAG_HEADER = 3;
   private static final int STATE_READING_TAG_DATA = 4;
 
   // Header sizes.
-  private static final int FLV_HEADER_SIZE = 9;
-  private static final int FLV_TAG_HEADER_SIZE = 11;
+  static final int FLV_HEADER_SIZE = 9;
+  static final int FLV_TAG_HEADER_SIZE = 11;
 
   // Tag types.
-  private static final int TAG_TYPE_AUDIO = 8;
-  private static final int TAG_TYPE_VIDEO = 9;
-  private static final int TAG_TYPE_SCRIPT_DATA = 18;
+  static final int TAG_TYPE_AUDIO = 8;
+  static final int TAG_TYPE_VIDEO = 9;
+  static final int TAG_TYPE_SCRIPT_DATA = 18;
 
   // FLV container identifier.
   private static final int FLV_TAG = Util.getIntegerCodeForString("FLV");
 
   private final ParsableByteArray scratch;
-  private final ParsableByteArray headerBuffer;
+  final ParsableByteArray headerBuffer;
+  final ParsableByteArray sniffBuffer;
   private final ParsableByteArray tagHeaderBuffer;
   private final ParsableByteArray tagData;
   private final ScriptTagPayloadReader metadataReader;
 
-  private ExtractorOutput extractorOutput;
-  private @States int state;
+  ExtractorOutput extractorOutput;
+  @States int state;
   private long mediaTagTimestampOffsetUs;
-  private int bytesToNextTagHeader;
+  int bytesToNextTagHeader;
   private int tagType;
   private int tagDataSize;
   private long tagTimestampUs;
   private boolean outputSeekMap;
-  private AudioTagPayloadReader audioReader;
-  private VideoTagPayloadReader videoReader;
+  AudioTagPayloadReader audioReader;
+  VideoTagPayloadReader videoReader;
 
   public FlvExtractor() {
     scratch = new ParsableByteArray(4);
     headerBuffer = new ParsableByteArray(FLV_HEADER_SIZE);
     tagHeaderBuffer = new ParsableByteArray(FLV_TAG_HEADER_SIZE);
+    sniffBuffer = new ParsableByteArray(FLV_HEADER_SIZE + FLV_TAG_HEADER_SIZE);
     tagData = new ParsableByteArray();
     metadataReader = new ScriptTagPayloadReader();
     state = STATE_READING_FLV_HEADER;
@@ -183,7 +188,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
    * @throws IOException If an error occurred reading or parsing data from the source.
    * @throws InterruptedException If the thread was interrupted.
    */
-  private boolean readFlvHeader(ExtractorInput input) throws IOException, InterruptedException {
+  boolean readFlvHeader(ExtractorInput input) throws IOException, InterruptedException {
     if (!input.readFully(headerBuffer.data, 0, FLV_HEADER_SIZE, true)) {
       // We've reached the end of the stream.
       return false;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorAudioFix.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorAudioFix.java
new file mode 100644
index 0000000000..6995e5327f
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorAudioFix.java
@@ -0,0 +1,104 @@
+package com.google.android.exoplayer2.extractor.flv;
+
+import android.util.Log;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+
+import java.io.IOException;
+
+public class FlvExtractorAudioFix extends FlvExtractor {
+
+    public FlvExtractorAudioFix() {
+        super();
+        Log.i ("FlvExtAudioFix", "invoked FlvExtractor constructor");
+    }
+
+    static final int FLV_ATAG = 1;
+    static final int FLV_VTAG = 2;
+    static final int FLV_AVTAGS = (FLV_ATAG | FLV_VTAG);
+    static final int FLV_NOTAGS = 0;
+
+    int hasBothAVTags (ExtractorInput input, int hdrSize) throws IOException, InterruptedException {
+        int skipBytes, tagType, tagDataSize, itr = 0, ret = FLV_NOTAGS;
+
+        input.resetPeekPosition();
+        skipBytes = hdrSize - 9 + 4;
+        input.advancePeekPosition (skipBytes);
+
+        Log.i ("FlvExtAudioFix", "areBothAudioVideoPresent: currPeekPos: " +
+                input.getPeekPosition() + ", curReadpos: " + input.getPosition() +
+                ", skipBytes: " + skipBytes);
+        while (itr < 6) {
+            if (!input.peekFully(sniffBuffer.data, 0, FLV_TAG_HEADER_SIZE, true)) {
+                Log.e("FlvExtAudioFix", "areBothAudioVideoPresent: peek" + itr + " failed");
+                return ret;
+            }
+            sniffBuffer.setPosition(0);
+            tagType = sniffBuffer.readUnsignedByte();
+            tagDataSize = sniffBuffer.readUnsignedInt24();
+
+            input.advancePeekPosition(tagDataSize + 4);
+            Log.i("FlvExtAudioFix", "areBothAudioVideoPresent: itr: " + itr +
+                    ": currPeekPos: " + input.getPeekPosition() + ", curReadpos: " +
+                    input.getPosition() + ", ta1DataSize[" + itr + "]: " + tagDataSize +
+                    ", tagType[" + itr + "]: " + tagType);
+            itr++;
+            if (tagType == TAG_TYPE_AUDIO)
+                ret |= FLV_ATAG;
+            else if (tagType == TAG_TYPE_VIDEO)
+                ret |= FLV_VTAG;
+        }
+        input.resetPeekPosition();
+
+        return ret;
+    }
+    @Override
+    /**
+     * Reads an FLV container header from the provided {@link ExtractorInput}.
+     *
+     * @param input The {@link ExtractorInput} from which to read.
+     * @return True if header was read successfully. False if the end of stream was reached.
+     * @throws IOException If an error occurred reading or parsing data from the source.
+     * @throws InterruptedException If the thread was interrupted.
+     */
+    boolean readFlvHeader(ExtractorInput input) throws IOException, InterruptedException {
+        if (!input.readFully(headerBuffer.data, 0, FLV_HEADER_SIZE, true)) {
+            // We've reached the end of the stream.
+            return false;
+        }
+
+        headerBuffer.setPosition(0);
+        headerBuffer.skipBytes(4);
+        int flags = headerBuffer.readUnsignedByte();
+        int hdrSize = headerBuffer.readInt();
+        boolean hasAudio = false; // = (flags & 0x04) != 0;
+        boolean hasVideo = false; // = (flags & 0x01) != 0;
+
+        int ret = hasBothAVTags(input, hdrSize);
+        Log.i ("FlvExtAudioFix", "readFlvHeader: ret: " + ret);
+        if (ret == FLV_ATAG)
+            hasAudio = true;
+        else if (ret == FLV_VTAG)
+            hasVideo = true;
+        else if (ret == FLV_AVTAGS)
+            hasAudio = hasVideo = true;
+
+        if (hasAudio && audioReader == null) {
+            audioReader = new AudioTagPayloadReader(
+                    extractorOutput.track(TAG_TYPE_AUDIO, C.TRACK_TYPE_AUDIO));
+        }
+        if (hasVideo && videoReader == null) {
+            videoReader = new VideoTagPayloadReader(
+                    extractorOutput.track(TAG_TYPE_VIDEO, C.TRACK_TYPE_VIDEO));
+        }
+        extractorOutput.endTracks();
+
+        // We need to skip any additional content in the FLV header, plus the 4 byte previous tag size.
+        bytesToNextTagHeader = hdrSize - FLV_HEADER_SIZE + 4;
+        state = STATE_SKIPPING_TO_TAG_HEADER;
+        Log.i ("flvext", "readFlvHeader -> STATE_SKIPPING_TO_TAG_HEADER");
+        return true;
+    }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 4e40b095fa..63c86c2c96 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -50,7 +50,7 @@
 /**
  * A {@link MediaPeriod} that extracts data using an {@link Extractor}.
  */
-/* package */ class ExtractorMediaPeriod implements MediaPeriod, ExtractorOutput,
+/* package */ final class ExtractorMediaPeriod implements MediaPeriod, ExtractorOutput,
     Loader.Callback<ExtractorMediaPeriod.ExtractingLoadable>, Loader.ReleaseCallback,
     UpstreamFormatChangedListener {
 
@@ -77,46 +77,46 @@
 
   private final Uri uri;
   private final DataSource dataSource;
-  final int minLoadableRetryCount;
+  private final int minLoadableRetryCount;
   private final EventDispatcher eventDispatcher;
-  final Listener listener;
+  private final Listener listener;
   private final Allocator allocator;
   @Nullable private final String customCacheKey;
   private final long continueLoadingCheckIntervalBytes;
   private final Loader loader;
   private final ExtractorHolder extractorHolder;
-  final ConditionVariable loadCondition;
+  private final ConditionVariable loadCondition;
   private final Runnable maybeFinishPrepareRunnable;
   private final Runnable onContinueLoadingRequestedRunnable;
   private final Handler handler;
 
-  @Nullable Callback callback;
-  SeekMap seekMap;
-  SampleQueue[] sampleQueues;
+  private @Nullable Callback callback;
+  private SeekMap seekMap;
+  private SampleQueue[] sampleQueues;
   private int[] sampleQueueTrackIds;
-  boolean sampleQueuesBuilt;
-  boolean prepared;
-  int actualMinLoadableRetryCount;
+  private boolean sampleQueuesBuilt;
+  private boolean prepared;
+  private int actualMinLoadableRetryCount;
 
   private boolean seenFirstTrackSelection;
   private boolean notifyDiscontinuity;
   private boolean notifiedReadingStarted;
   private int enabledTrackCount;
-  TrackGroupArray tracks;
-  long durationUs;
-  boolean[] trackEnabledStates;
-  boolean[] trackIsAudioVideoFlags;
-  boolean[] trackFormatNotificationSent;
-  boolean haveAudioVideoTracks;
-  long length;
-
-  long lastSeekPositionUs;
-  long pendingResetPositionUs;
+  private TrackGroupArray tracks;
+  private long durationUs;
+  private boolean[] trackEnabledStates;
+  private boolean[] trackIsAudioVideoFlags;
+  private boolean[] trackFormatNotificationSent;
+  private boolean haveAudioVideoTracks;
+  private long length;
+
+  private long lastSeekPositionUs;
+  private long pendingResetPositionUs;
   private boolean pendingDeferredRetry;
 
   private int extractedSamplesCountAtStartOfLoad;
-  boolean loadingFinished;
-  boolean released;
+  private boolean loadingFinished;
+  private boolean released;
 
   /**
    * @param uri The {@link Uri} of the media stream.
@@ -600,7 +600,7 @@ public void onUpstreamFormatChanged(Format format) {
 
   // Internal methods.
 
-  public void maybeFinishPrepare() {
+  private void maybeFinishPrepare() {
     if (released || prepared || seekMap == null || !sampleQueuesBuilt) {
       return;
     }
@@ -718,7 +718,7 @@ private boolean configureRetry(ExtractingLoadable loadable, int currentExtracted
    * @param positionUs The seek position in microseconds.
    * @return Whether the in-buffer seek was successful.
    */
-  boolean seekInsideBufferUs(long positionUs) {
+  private boolean seekInsideBufferUs(long positionUs) {
     int trackCount = sampleQueues.length;
     for (int i = 0; i < trackCount; i++) {
       SampleQueue sampleQueue = sampleQueues[i];
@@ -744,7 +744,7 @@ private int getExtractedSamplesCount() {
     return extractedSamplesCount;
   }
 
-  long getLargestQueuedTimestampUs() {
+  private long getLargestQueuedTimestampUs() {
     long largestQueuedTimestampUs = Long.MIN_VALUE;
     for (SampleQueue sampleQueue : sampleQueues) {
       largestQueuedTimestampUs = Math.max(largestQueuedTimestampUs,
@@ -753,7 +753,7 @@ long getLargestQueuedTimestampUs() {
     return largestQueuedTimestampUs;
   }
 
-  boolean isPendingReset() {
+  private boolean isPendingReset() {
     return pendingResetPositionUs != C.TIME_UNSET;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriodAudioFix.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriodAudioFix.java
deleted file mode 100644
index 51e3990d75..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriodAudioFix.java
+++ /dev/null
@@ -1,159 +0,0 @@
-package com.google.android.exoplayer2.source;
-
-import android.net.Uri;
-import android.support.annotation.Nullable;
-import android.util.Log;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.extractor.Extractor;
-import com.google.android.exoplayer2.upstream.Allocator;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.util.MimeTypes;
-
-public class ExtractorMediaPeriodAudioFix extends ExtractorMediaPeriod {
-
-    int validSampleQCount;
-
-    /**
-     * @param uri                               The {@link Uri} of the media stream.
-     * @param dataSource                        The data source to read the media.
-     * @param extractors                        The extractors to use to read the data source.
-     * @param minLoadableRetryCount             The minimum number of times to retry if a loading error occurs.
-     * @param eventDispatcher                   A dispatcher to notify of events.
-     * @param listener                          A listener to notify when information about the period changes.
-     * @param allocator                         An {@link Allocator} from which to obtain media buffer allocations.
-     * @param customCacheKey                    A custom key that uniquely identifies the original stream. Used for cache
-     *                                          indexing. May be null.
-     * @param continueLoadingCheckIntervalBytes The number of bytes that should be loaded between each
-     *                                          invocation of {@link Callback#onContinueLoadingRequested(SequenceableLoader)}.
-     */
-    public ExtractorMediaPeriodAudioFix(
-            Uri uri,
-            DataSource dataSource,
-            Extractor[] extractors,
-            int minLoadableRetryCount,
-            MediaSourceEventListener.EventDispatcher eventDispatcher,
-            Listener listener,
-            Allocator allocator,
-            @Nullable String customCacheKey,
-            int continueLoadingCheckIntervalBytes) {
-        super(uri, dataSource, extractors, minLoadableRetryCount, eventDispatcher, listener, allocator, customCacheKey, continueLoadingCheckIntervalBytes);
-        Log.i ("ExtMediaPeriodAFix", "invoked super constructor()");
-    }
-
-    @Override
-    public void discardBuffer(long positionUs, boolean toKeyframe) {
-
-        int trackCount = validSampleQCount;
-
-        for (int i = 0; i < trackCount; i++) {
-            sampleQueues[i].discardTo(positionUs, toKeyframe, trackEnabledStates[i]);
-        }
-    }
-
-    @Override
-    public long getBufferedPositionUs() {
-
-        if (loadingFinished) {
-            return C.TIME_END_OF_SOURCE;
-        } else if (isPendingReset()) {
-            return pendingResetPositionUs;
-        }
-        long largestQueuedTimestampUs;
-        if (haveAudioVideoTracks) {
-            // Ignore non-AV tracks, which may be sparse or poorly interleaved.
-            largestQueuedTimestampUs = Long.MAX_VALUE;
-            int trackCount = validSampleQCount;
-            for (int i = 0; i < trackCount; i++) {
-                if (trackIsAudioVideoFlags[i]) {
-                    largestQueuedTimestampUs = Math.min(largestQueuedTimestampUs,
-                            sampleQueues[i].getLargestQueuedTimestampUs());
-                }
-            }
-        } else {
-            largestQueuedTimestampUs = getLargestQueuedTimestampUs();
-        }
-        return largestQueuedTimestampUs == Long.MIN_VALUE ? lastSeekPositionUs
-                : largestQueuedTimestampUs;
-    }
-
-    @Override
-    public void maybeFinishPrepare() {
-
-        int validQCount = 0;
-        boolean videoStream = false, nullStream = false;
-
-        Log.i ("ExtMediaPeriodAFix", "maybeFinishPrepare invoked, using validSampleQCount: " +
-                validSampleQCount);
-
-        if (released || prepared || seekMap == null || !sampleQueuesBuilt) {
-            return;
-        }
-        for (SampleQueue sampleQueue : sampleQueues) {
-            if (sampleQueue.getUpstreamFormat() == null) {
-                Log.e ("EXO_PLAYER_EXTMEDPER", "UpstreamFormat is NULL");
-                nullStream = true;
-                if (videoStream)
-                    return;
-            } else {
-                if (sampleQueue.getUpstreamFormat().sampleMimeType.contains ("video")) {
-                    videoStream = true;
-                }
-                validQCount++;
-            }
-        }
-
-        if (validQCount == 0 || (videoStream && nullStream)) {
-            Log.e ("EXOPLAYER_EXTMEDPER", "maybeFinishPrepare: Returning as validQCOunt: " +
-                    validQCount + ", videoStream: " + videoStream + ", nullStream: " + nullStream);
-            return;
-        }
-
-        loadCondition.close();
-        validSampleQCount = validQCount;
-        int trackCount = validQCount;
-        TrackGroup[] trackArray = new TrackGroup[trackCount];
-        trackIsAudioVideoFlags = new boolean[trackCount];
-        trackEnabledStates = new boolean[trackCount];
-        trackFormatNotificationSent = new boolean[trackCount];
-        durationUs = seekMap.getDurationUs();
-        for (int i = 0; i < trackCount; i++) {
-            Format trackFormat = sampleQueues[i].getUpstreamFormat();
-            if (trackFormat == null)
-                continue;
-            trackArray[i] = new TrackGroup(trackFormat);
-            String mimeType = trackFormat.sampleMimeType;
-            boolean isAudioVideo = MimeTypes.isVideo(mimeType) || MimeTypes.isAudio(mimeType);
-            trackIsAudioVideoFlags[i] = isAudioVideo;
-            haveAudioVideoTracks |= isAudioVideo;
-        }
-        tracks = new TrackGroupArray(trackArray);
-        if (minLoadableRetryCount == ExtractorMediaSource.MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA
-                && length == C.LENGTH_UNSET && seekMap.getDurationUs() == C.TIME_UNSET) {
-            actualMinLoadableRetryCount = ExtractorMediaSource.DEFAULT_MIN_LOADABLE_RETRY_COUNT_LIVE;
-        }
-        prepared = true;
-        listener.onSourceInfoRefreshed(durationUs, seekMap.isSeekable());
-        callback.onPrepared(this);
-    }
-
-    @Override
-    boolean seekInsideBufferUs(long positionUs) {
-        int trackCount = validSampleQCount;
-        for (int i = 0; i < trackCount; i++) {
-            SampleQueue sampleQueue = sampleQueues[i];
-            sampleQueue.rewind();
-            boolean seekInsideQueue = sampleQueue.advanceTo(positionUs, true, false)
-                    != SampleQueue.ADVANCE_FAILED;
-            // If we have AV tracks then an in-buffer seek is successful if the seek into every AV queue
-            // is successful. We ignore whether seeks within non-AV queues are successful in this case, as
-            // they may be sparse or poorly interleaved. If we only have non-AV tracks then a seek is
-            // successful only if the seek into every queue succeeds.
-            if (!seekInsideQueue && (trackIsAudioVideoFlags[i] || !haveAudioVideoTracks)) {
-                return false;
-            }
-        }
-        return true;
-    }
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index 31f7559fc4..c4a0487bd9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -42,7 +42,7 @@
  * <p>Note that the built-in extractors for AAC, MPEG PS/TS and FLV streams do not support seeking.
  */
 public final class ExtractorMediaSource extends BaseMediaSource
-    implements ExtractorMediaPeriodAudioFix.Listener {
+    implements ExtractorMediaPeriod.Listener {
   /**
    * Listener of {@link ExtractorMediaSource} events.
    *
@@ -356,8 +356,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     Assertions.checkArgument(id.periodIndex == 0);
-    return new ExtractorMediaPeriodAudioFix(
-//    return new ExtractorMediaPeriod(
+    return new ExtractorMediaPeriod(
         uri,
         dataSourceFactory.createDataSource(),
         extractorsFactory.createExtractors(),
@@ -371,7 +370,7 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
 
   @Override
   public void releasePeriod(MediaPeriod mediaPeriod) {
-    ((ExtractorMediaPeriodAudioFix) mediaPeriod).release();
+    ((ExtractorMediaPeriod) mediaPeriod).release();
   }
 
   @Override
