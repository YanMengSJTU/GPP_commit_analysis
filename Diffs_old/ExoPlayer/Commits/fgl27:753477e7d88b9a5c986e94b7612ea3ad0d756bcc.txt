diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index c90129e7ba..3c792b1bee 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -2,6 +2,8 @@
 
 ### dev-v2 (not yet released) ###
 
+* Add `allowedCapturePolicy` field to `AudioAttributes` wrapper to allow to
+  opt-out of audio recording.
 * Add `DataSpec.httpRequestHeaders` to set HTTP request headers when connecting
   to an HTTP source. `DefaultHttpDataSource`, `CronetDataSource` and
   `OkHttpDataSource` include headers set in the DataSpec when connecting to the
@@ -64,6 +66,10 @@
   [#4337](https://github.com/google/ExoPlayer/issues/4337)).
 * Publish `testutils` module to simplify unit testing with ExoPlayer
   ([#6267](https://github.com/google/ExoPlayer/issues/6267)).
+* Add `uid` to `Timeline.Window` to uniquely identify window instances.
+* Fix decoder selection for E-AC3 JOC streams
+  ([#6398](https://github.com/google/ExoPlayer/issues/6398)).
+* Fix Dolby Vision fallback to AVC and HEVC.
 
 ### 2.10.4 ###
 
@@ -95,6 +101,8 @@
 * Fix issue where playback speeds are not used in adaptive track selections
   after manual selection changes for other renderers
   ([#6256](https://github.com/google/ExoPlayer/issues/6256)).
+* Fix initialization data handling for FLAC in MP4
+  ([#6396](https://github.com/google/ExoPlayer/issues/6396)).
 
 ### 2.10.3 ###
 
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
index a0741b23cc..2857141f8f 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
@@ -114,6 +114,7 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
     long durationUs = durationsUs[windowIndex];
     boolean isDynamic = durationUs == C.TIME_UNSET;
     return window.set(
+        /* uid= */ ids[windowIndex],
         /* tag= */ ids[windowIndex],
         /* manifest= */ null,
         /* presentationStartTimeMs= */ C.TIME_UNSET,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index f5db0145fe..f4e51a38a0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -15,13 +15,17 @@
  */
 package com.google.android.exoplayer2;
 
+import android.os.Looper;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmInitData;
+import com.google.android.exoplayer2.drm.DrmSession;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MediaClock;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 
 /**
@@ -283,6 +287,35 @@ protected final RendererConfiguration getConfiguration() {
     return configuration;
   }
 
+  /** Returns a {@link DrmSession} ready for assignment, handling resource management. */
+  @Nullable
+  protected final <T extends ExoMediaCrypto> DrmSession<T> getUpdatedSourceDrmSession(
+      @Nullable Format oldFormat,
+      Format newFormat,
+      @Nullable DrmSessionManager<T> drmSessionManager,
+      @Nullable DrmSession<T> existingSourceSession)
+      throws ExoPlaybackException {
+    boolean drmInitDataChanged =
+        !Util.areEqual(newFormat.drmInitData, oldFormat == null ? null : oldFormat.drmInitData);
+    if (!drmInitDataChanged) {
+      return existingSourceSession;
+    }
+    @Nullable DrmSession<T> newSourceDrmSession = null;
+    if (newFormat.drmInitData != null) {
+      if (drmSessionManager == null) {
+        throw ExoPlaybackException.createForRenderer(
+            new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
+      }
+      newSourceDrmSession =
+          drmSessionManager.acquireSession(
+              Assertions.checkNotNull(Looper.myLooper()), newFormat.drmInitData);
+    }
+    if (existingSourceSession != null) {
+      existingSourceSession.releaseReference();
+    }
+    return newSourceDrmSession;
+  }
+
   /**
    * Returns the index of the renderer within the player.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index 38553697d0..c8a73fbe9a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -17,6 +17,7 @@
 
 import android.annotation.TargetApi;
 import android.content.Context;
+import android.media.AudioAttributes;
 import android.media.AudioFormat;
 import android.media.AudioManager;
 import android.media.MediaCodec;
@@ -440,6 +441,21 @@ private C() {}
   public static final int USAGE_VOICE_COMMUNICATION_SIGNALLING =
       android.media.AudioAttributes.USAGE_VOICE_COMMUNICATION_SIGNALLING;
 
+  /**
+   * Capture policies for {@link com.google.android.exoplayer2.audio.AudioAttributes}. One of {@link
+   * #ALLOW_CAPTURE_BY_ALL}, {@link #ALLOW_CAPTURE_BY_NONE} or {@link #ALLOW_CAPTURE_BY_SYSTEM}.
+   */
+  @Documented
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({ALLOW_CAPTURE_BY_ALL, ALLOW_CAPTURE_BY_NONE, ALLOW_CAPTURE_BY_SYSTEM})
+  public @interface AudioAllowedCapturePolicy {}
+  /** See {@link android.media.AudioAttributes#ALLOW_CAPTURE_BY_ALL}. */
+  public static final int ALLOW_CAPTURE_BY_ALL = AudioAttributes.ALLOW_CAPTURE_BY_ALL;
+  /** See {@link android.media.AudioAttributes#ALLOW_CAPTURE_BY_NONE}. */
+  public static final int ALLOW_CAPTURE_BY_NONE = AudioAttributes.ALLOW_CAPTURE_BY_NONE;
+  /** See {@link android.media.AudioAttributes#ALLOW_CAPTURE_BY_SYSTEM}. */
+  public static final int ALLOW_CAPTURE_BY_SYSTEM = AudioAttributes.ALLOW_CAPTURE_BY_SYSTEM;
+
   /**
    * Audio focus types. One of {@link #AUDIOFOCUS_NONE}, {@link #AUDIOFOCUS_GAIN}, {@link
    * #AUDIOFOCUS_GAIN_TRANSIENT}, {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} or {@link
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 8beb7d781e..1478a1b2bf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -1326,9 +1326,16 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
               timeline, timeline.getPeriodByUid(newPeriodUid, period).windowIndex, C.TIME_UNSET);
       newContentPositionUs = defaultPosition.second;
       newPeriodId = queue.resolveMediaPeriodIdForAds(defaultPosition.first, newContentPositionUs);
-    } else if (newPeriodId.isAd()) {
-      // Recheck if the current ad still needs to be played.
-      newPeriodId = queue.resolveMediaPeriodIdForAds(newPeriodId.periodUid, newContentPositionUs);
+    } else {
+      // Recheck if the current ad still needs to be played or if we need to start playing an ad.
+      newPeriodId =
+          queue.resolveMediaPeriodIdForAds(playbackInfo.periodId.periodUid, newContentPositionUs);
+      if (!playbackInfo.periodId.isAd() && !newPeriodId.isAd()) {
+        // Drop update if we keep playing the same content (MediaPeriod.periodUid are identical) and
+        // only MediaPeriodId.nextAdGroupIndex may have changed. This postpones a potential
+        // discontinuity until we reach the former next ad group position.
+        newPeriodId = playbackInfo.periodId;
+      }
     }
 
     if (playbackInfo.periodId.equals(newPeriodId) && oldContentPositionUs == newContentPositionUs) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
index 172d9c4107..c496052f94 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -115,6 +115,17 @@
    */
   public static final class Window {
 
+    /**
+     * A {@link #uid} for a window that must be used for single-window {@link Timeline Timelines}.
+     */
+    public static final Object SINGLE_WINDOW_UID = new Object();
+
+    /**
+     * A unique identifier for the window. Single-window {@link Timeline Timelines} must use {@link
+     * #SINGLE_WINDOW_UID}.
+     */
+    public Object uid;
+
     /** A tag for the window. Not necessarily unique. */
     @Nullable public Object tag;
 
@@ -175,8 +186,14 @@
      */
     public long positionInFirstPeriodUs;
 
+    /** Creates window. */
+    public Window() {
+      uid = SINGLE_WINDOW_UID;
+    }
+
     /** Sets the data held by this window. */
     public Window set(
+        Object uid,
         @Nullable Object tag,
         @Nullable Object manifest,
         long presentationStartTimeMs,
@@ -188,6 +205,7 @@ public Window set(
         int firstPeriodIndex,
         int lastPeriodIndex,
         long positionInFirstPeriodUs) {
+      this.uid = uid;
       this.tag = tag;
       this.manifest = manifest;
       this.presentationStartTimeMs = presentationStartTimeMs;
@@ -793,8 +811,8 @@ public final Period getPeriod(int periodIndex, Period period) {
   public abstract Period getPeriod(int periodIndex, Period period, boolean setIds);
 
   /**
-   * Returns the index of the period identified by its unique {@code id}, or {@link C#INDEX_UNSET}
-   * if the period is not in the timeline.
+   * Returns the index of the period identified by its unique {@link Period#uid}, or {@link
+   * C#INDEX_UNSET} if the period is not in the timeline.
    *
    * @param uid A unique identifier for a period.
    * @return The index of the period, or {@link C#INDEX_UNSET} if the period was not found.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
index 1b0d629da7..516df8147c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioAttributes.java
@@ -18,6 +18,7 @@
 import android.annotation.TargetApi;
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Util;
 
 /**
  * Attributes for audio playback, which configure the underlying platform
@@ -42,17 +43,19 @@
     private @C.AudioContentType int contentType;
     private @C.AudioFlags int flags;
     private @C.AudioUsage int usage;
+    private @C.AudioAllowedCapturePolicy int allowedCapturePolicy;
 
     /**
      * Creates a new builder for {@link AudioAttributes}.
-     * <p>
-     * By default the content type is {@link C#CONTENT_TYPE_UNKNOWN}, usage is
-     * {@link C#USAGE_MEDIA}, and no flags are set.
+     *
+     * <p>By default the content type is {@link C#CONTENT_TYPE_UNKNOWN}, usage is {@link
+     * C#USAGE_MEDIA}, capture policy is {@link C#ALLOW_CAPTURE_BY_ALL} and no flags are set.
      */
     public Builder() {
       contentType = C.CONTENT_TYPE_UNKNOWN;
       flags = 0;
       usage = C.USAGE_MEDIA;
+      allowedCapturePolicy = C.ALLOW_CAPTURE_BY_ALL;
     }
 
     /**
@@ -79,11 +82,15 @@ public Builder setUsage(@C.AudioUsage int usage) {
       return this;
     }
 
-    /**
-     * Creates an {@link AudioAttributes} instance from this builder.
-     */
+    /** See {@link android.media.AudioAttributes.Builder#setAllowedCapturePolicy(int)}. */
+    public Builder setAllowedCapturePolicy(@C.AudioAllowedCapturePolicy int allowedCapturePolicy) {
+      this.allowedCapturePolicy = allowedCapturePolicy;
+      return this;
+    }
+
+    /** Creates an {@link AudioAttributes} instance from this builder. */
     public AudioAttributes build() {
-      return new AudioAttributes(contentType, flags, usage);
+      return new AudioAttributes(contentType, flags, usage, allowedCapturePolicy);
     }
 
   }
@@ -91,24 +98,38 @@ public AudioAttributes build() {
   public final @C.AudioContentType int contentType;
   public final @C.AudioFlags int flags;
   public final @C.AudioUsage int usage;
+  public final @C.AudioAllowedCapturePolicy int allowedCapturePolicy;
 
   @Nullable private android.media.AudioAttributes audioAttributesV21;
 
-  private AudioAttributes(@C.AudioContentType int contentType, @C.AudioFlags int flags,
-      @C.AudioUsage int usage) {
+  private AudioAttributes(
+      @C.AudioContentType int contentType,
+      @C.AudioFlags int flags,
+      @C.AudioUsage int usage,
+      @C.AudioAllowedCapturePolicy int allowedCapturePolicy) {
     this.contentType = contentType;
     this.flags = flags;
     this.usage = usage;
+    this.allowedCapturePolicy = allowedCapturePolicy;
   }
 
+  /**
+   * Returns a {@link android.media.AudioAttributes} from this instance.
+   *
+   * <p>Field {@link AudioAttributes#allowedCapturePolicy} is ignored for API levels prior to 29.
+   */
   @TargetApi(21)
   public android.media.AudioAttributes getAudioAttributesV21() {
     if (audioAttributesV21 == null) {
-      audioAttributesV21 = new android.media.AudioAttributes.Builder()
-          .setContentType(contentType)
-          .setFlags(flags)
-          .setUsage(usage)
-          .build();
+      android.media.AudioAttributes.Builder builder =
+          new android.media.AudioAttributes.Builder()
+              .setContentType(contentType)
+              .setFlags(flags)
+              .setUsage(usage);
+      if (Util.SDK_INT >= 29) {
+        builder.setAllowedCapturePolicy(allowedCapturePolicy);
+      }
+      audioAttributesV21 = builder.build();
     }
     return audioAttributesV21;
   }
@@ -122,8 +143,10 @@ public boolean equals(@Nullable Object obj) {
       return false;
     }
     AudioAttributes other = (AudioAttributes) obj;
-    return this.contentType == other.contentType && this.flags == other.flags
-        && this.usage == other.usage;
+    return this.contentType == other.contentType
+        && this.flags == other.flags
+        && this.usage == other.usage
+        && this.allowedCapturePolicy == other.allowedCapturePolicy;
   }
 
   @Override
@@ -132,6 +155,7 @@ public int hashCode() {
     result = 31 * result + contentType;
     result = 31 * result + flags;
     result = 31 * result + usage;
+    result = 31 * result + allowedCapturePolicy;
     return result;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index 251901f4f2..34f8363c78 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -46,6 +46,7 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
@@ -361,10 +362,11 @@ protected int supportsFormat(
     decoderInfos = MediaCodecUtil.getDecoderInfosSortedByFormatSupport(decoderInfos, format);
     if (MimeTypes.AUDIO_E_AC3_JOC.equals(format.sampleMimeType)) {
       // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.
-      List<MediaCodecInfo> eac3DecoderInfos =
+      List<MediaCodecInfo> decoderInfosWithEac3 = new ArrayList<>(decoderInfos);
+      decoderInfosWithEac3.addAll(
           mediaCodecSelector.getDecoderInfos(
-              MimeTypes.AUDIO_E_AC3, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false);
-      decoderInfos.addAll(eac3DecoderInfos);
+              MimeTypes.AUDIO_E_AC3, requiresSecureDecoder, /* requiresTunnelingDecoder= */ false));
+      decoderInfos = decoderInfosWithEac3;
     }
     return Collections.unmodifiableList(decoderInfos);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index 52d55b2c31..e92f1d63db 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -17,7 +17,6 @@
 
 import android.media.audiofx.Virtualizer;
 import android.os.Handler;
-import android.os.Looper;
 import android.os.SystemClock;
 import androidx.annotation.IntDef;
 import androidx.annotation.Nullable;
@@ -673,32 +672,15 @@ private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session)
 
   @SuppressWarnings("unchecked")
   private void onInputFormatChanged(FormatHolder formatHolder) throws ExoPlaybackException {
-    Format oldFormat = inputFormat;
-    inputFormat = formatHolder.format;
-
-    boolean drmInitDataChanged = !Util.areEqual(inputFormat.drmInitData, oldFormat == null ? null
-        : oldFormat.drmInitData);
-    if (drmInitDataChanged) {
-      if (inputFormat.drmInitData != null) {
-
-        if (formatHolder.includesDrmSession) {
-          setSourceDrmSession((DrmSession<ExoMediaCrypto>) formatHolder.drmSession);
-        } else {
-          if (drmSessionManager == null) {
-            throw ExoPlaybackException.createForRenderer(
-                new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
-          }
-          DrmSession<ExoMediaCrypto> session =
-              drmSessionManager.acquireSession(Looper.myLooper(), inputFormat.drmInitData);
-          if (sourceDrmSession != null) {
-            sourceDrmSession.releaseReference();
-          }
-          sourceDrmSession = session;
-        }
-      } else {
-        setSourceDrmSession(null);
-      }
+    Format newFormat = Assertions.checkNotNull(formatHolder.format);
+    if (formatHolder.includesDrmSession) {
+      setSourceDrmSession((DrmSession<ExoMediaCrypto>) formatHolder.drmSession);
+    } else {
+      sourceDrmSession =
+          getUpdatedSourceDrmSession(inputFormat, newFormat, drmSessionManager, sourceDrmSession);
     }
+    Format oldFormat = inputFormat;
+    inputFormat = newFormat;
 
     if (!canKeepCodec(oldFormat, inputFormat)) {
       if (decoderReceivedBuffers) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 2800c6069e..f7b4040144 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -1162,7 +1162,16 @@ private static void parseAudioSampleEntry(ParsableByteArray parent, int atomType
         System.arraycopy(opusMagic, 0, initializationData, 0, opusMagic.length);
         parent.setPosition(childPosition + Atom.HEADER_SIZE);
         parent.readBytes(initializationData, opusMagic.length, childAtomBodySize);
-      } else if (childAtomSize == Atom.TYPE_dfLa || childAtomType == Atom.TYPE_alac) {
+      } else if (childAtomType == Atom.TYPE_dfLa) {
+        int childAtomBodySize = childAtomSize - Atom.FULL_HEADER_SIZE;
+        initializationData = new byte[4 + childAtomBodySize];
+        initializationData[0] = 0x66; // f
+        initializationData[1] = 0x4C; // L
+        initializationData[2] = 0x61; // a
+        initializationData[3] = 0x43; // C
+        parent.setPosition(childPosition + Atom.FULL_HEADER_SIZE);
+        parent.readBytes(initializationData, /* offset= */ 4, childAtomBodySize);
+      } else if (childAtomType == Atom.TYPE_alac) {
         int childAtomBodySize = childAtomSize - Atom.FULL_HEADER_SIZE;
         initializationData = new byte[childAtomBodySize];
         parent.setPosition(childPosition + Atom.FULL_HEADER_SIZE);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index 45ae82d049..f853339474 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -23,7 +23,6 @@
 import android.media.MediaCryptoException;
 import android.media.MediaFormat;
 import android.os.Bundle;
-import android.os.Looper;
 import android.os.SystemClock;
 import androidx.annotation.CheckResult;
 import androidx.annotation.IntDef;
@@ -1200,33 +1199,15 @@ protected void onCodecInitialized(String name, long initializedTimestampMs,
    */
   @SuppressWarnings("unchecked")
   protected void onInputFormatChanged(FormatHolder formatHolder) throws ExoPlaybackException {
-    Format oldFormat = inputFormat;
-    Format newFormat = formatHolder.format;
-    inputFormat = newFormat;
     waitingForFirstSampleInFormat = true;
-
-    boolean drmInitDataChanged =
-        !Util.areEqual(newFormat.drmInitData, oldFormat == null ? null : oldFormat.drmInitData);
-    if (drmInitDataChanged) {
-      if (newFormat.drmInitData != null) {
-        if (formatHolder.includesDrmSession) {
-          setSourceDrmSession((DrmSession<FrameworkMediaCrypto>) formatHolder.drmSession);
-        } else {
-          if (drmSessionManager == null) {
-            throw ExoPlaybackException.createForRenderer(
-                new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
-          }
-          DrmSession<FrameworkMediaCrypto> session =
-              drmSessionManager.acquireSession(Looper.myLooper(), newFormat.drmInitData);
-          if (sourceDrmSession != null) {
-            sourceDrmSession.releaseReference();
-          }
-          sourceDrmSession = session;
-        }
-      } else {
-        setSourceDrmSession(null);
-      }
+    Format newFormat = Assertions.checkNotNull(formatHolder.format);
+    if (formatHolder.includesDrmSession) {
+      setSourceDrmSession((DrmSession<FrameworkMediaCrypto>) formatHolder.drmSession);
+    } else {
+      sourceDrmSession =
+          getUpdatedSourceDrmSession(inputFormat, newFormat, drmSessionManager, sourceDrmSession);
     }
+    inputFormat = newFormat;
 
     if (codec == null) {
       maybeInitCodec();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
index a639cf9a1b..10ff81147e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecSelector.java
@@ -52,7 +52,8 @@ public MediaCodecInfo getPassthroughDecoderInfo() throws DecoderQueryException {
    * @param mimeType The MIME type for which a decoder is required.
    * @param requiresSecureDecoder Whether a secure decoder is required.
    * @param requiresTunnelingDecoder Whether a tunneling decoder is required.
-   * @return A list of {@link MediaCodecInfo}s corresponding to decoders. May be empty.
+   * @return An unmodifiable list of {@link MediaCodecInfo}s corresponding to decoders. May be
+   *     empty.
    * @throws DecoderQueryException Thrown if there was an error querying decoders.
    */
   List<MediaCodecInfo> getDecoderInfos(
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index eb97d546e5..3ec0094e60 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -81,8 +81,6 @@ private DecoderQueryException(Throwable cause) {
   // Dolby Vision.
   private static final Map<String, Integer> DOLBY_VISION_STRING_TO_PROFILE;
   private static final Map<String, Integer> DOLBY_VISION_STRING_TO_LEVEL;
-  private static final String CODEC_ID_DVHE = "dvhe";
-  private static final String CODEC_ID_DVH1 = "dvh1";
   // AV1.
   private static final SparseIntArray AV1_LEVEL_NUMBER_TO_CONST;
   private static final String CODEC_ID_AV01 = "av01";
@@ -156,8 +154,8 @@ public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure, boo
    *     unless secure decryption really is required.
    * @param tunneling Whether the decoder is required to support tunneling. Always pass false unless
    *     tunneling really is required.
-   * @return A list of all {@link MediaCodecInfo}s for the given mime type, in the order given by
-   *     {@link MediaCodecList}.
+   * @return An unmodifiable list of all {@link MediaCodecInfo}s for the given mime type, in the
+   *     order given by {@link MediaCodecList}.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
   public static synchronized List<MediaCodecInfo> getDecoderInfos(
@@ -245,6 +243,10 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
       return null;
     }
     String[] parts = format.codecs.split("\\.");
+    // Dolby Vision can use DV, AVC or HEVC codec IDs, so check the MIME type first.
+    if (MimeTypes.VIDEO_DOLBY_VISION.equals(format.sampleMimeType)) {
+      return getDolbyVisionProfileAndLevel(format.codecs, parts);
+    }
     switch (parts[0]) {
       case CODEC_ID_AVC1:
       case CODEC_ID_AVC2:
@@ -254,9 +256,6 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
       case CODEC_ID_HEV1:
       case CODEC_ID_HVC1:
         return getHevcProfileAndLevel(format.codecs, parts);
-      case CODEC_ID_DVHE:
-      case CODEC_ID_DVH1:
-        return getDolbyVisionProfileAndLevel(format.codecs, parts);
       case CODEC_ID_AV01:
         return getAv1ProfileAndLevel(format.codecs, parts, format.colorInfo);
       case CODEC_ID_MP4A:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
index 4e7b572384..703bb7e3a8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
@@ -53,14 +53,14 @@ public static Object getChildPeriodUidFromConcatenatedUid(Object concatenatedUid
   }
 
   /**
-   * Returns concatenated UID for a period in a child timeline.
+   * Returns a concatenated UID for a period or window in a child timeline.
    *
-   * @param childTimelineUid UID of the child timeline this period belongs to.
-   * @param childPeriodUid UID of the period in the child timeline.
-   * @return UID of the period in the concatenated timeline.
+   * @param childTimelineUid UID of the child timeline this period or window belongs to.
+   * @param childPeriodOrWindowUid UID of the period or window in the child timeline.
+   * @return UID of the period or window in the concatenated timeline.
    */
-  public static Object getConcatenatedUid(Object childTimelineUid, Object childPeriodUid) {
-    return Pair.create(childTimelineUid, childPeriodUid);
+  public static Object getConcatenatedUid(Object childTimelineUid, Object childPeriodOrWindowUid) {
+    return Pair.create(childTimelineUid, childPeriodOrWindowUid);
   }
 
   /**
@@ -195,6 +195,12 @@ public final Window getWindow(int windowIndex, Window window, long defaultPositi
     int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);
     getTimelineByChildIndex(childIndex)
         .getWindow(windowIndex - firstWindowIndexInChild, window, defaultPositionProjectionUs);
+    Object childUid = getChildUidByChildIndex(childIndex);
+    // Don't create new objects if the child is using SINGLE_WINDOW_UID.
+    window.uid =
+        Window.SINGLE_WINDOW_UID.equals(window.uid)
+            ? childUid
+            : getConcatenatedUid(childUid, window.uid);
     window.firstPeriodIndex += firstPeriodIndexInChild;
     window.lastPeriodIndex += firstPeriodIndexInChild;
     return window;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
index 671bc9eb74..8727fc5ed9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MaskingMediaSource.java
@@ -19,6 +19,7 @@
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Timeline.Window;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
@@ -134,7 +135,8 @@ protected void onChildSourceInfoRefreshed(
       timeline = timeline.cloneWithUpdatedTimeline(newTimeline);
     } else if (newTimeline.isEmpty()) {
       timeline =
-          MaskingTimeline.createWithRealTimeline(newTimeline, MaskingTimeline.DUMMY_EXTERNAL_ID);
+          MaskingTimeline.createWithRealTimeline(
+              newTimeline, Window.SINGLE_WINDOW_UID, MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID);
     } else {
       // Determine first period and the start position.
       // This will be:
@@ -156,12 +158,13 @@ protected void onChildSourceInfoRefreshed(
           windowStartPositionUs = periodPreparePositionUs;
         }
       }
+      Object windowUid = window.uid;
       Pair<Object, Long> periodPosition =
           newTimeline.getPeriodPosition(
               window, period, /* windowIndex= */ 0, windowStartPositionUs);
       Object periodUid = periodPosition.first;
       long periodPositionUs = periodPosition.second;
-      timeline = MaskingTimeline.createWithRealTimeline(newTimeline, periodUid);
+      timeline = MaskingTimeline.createWithRealTimeline(newTimeline, windowUid, periodUid);
       if (unpreparedMaskingMediaPeriod != null) {
         MaskingMediaPeriod maskingPeriod = unpreparedMaskingMediaPeriod;
         maskingPeriod.overridePreparePositionUs(periodPositionUs);
@@ -190,14 +193,14 @@ protected boolean shouldDispatchCreateOrReleaseEvent(MediaPeriodId mediaPeriodId
   }
 
   private Object getInternalPeriodUid(Object externalPeriodUid) {
-    return externalPeriodUid.equals(MaskingTimeline.DUMMY_EXTERNAL_ID)
-        ? timeline.replacedInternalId
+    return externalPeriodUid.equals(MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID)
+        ? timeline.replacedInternalPeriodUid
         : externalPeriodUid;
   }
 
   private Object getExternalPeriodUid(Object internalPeriodUid) {
-    return timeline.replacedInternalId.equals(internalPeriodUid)
-        ? MaskingTimeline.DUMMY_EXTERNAL_ID
+    return timeline.replacedInternalPeriodUid.equals(internalPeriodUid)
+        ? MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID
         : internalPeriodUid;
   }
 
@@ -207,9 +210,10 @@ private Object getExternalPeriodUid(Object internalPeriodUid) {
    */
   private static final class MaskingTimeline extends ForwardingTimeline {
 
-    public static final Object DUMMY_EXTERNAL_ID = new Object();
+    public static final Object DUMMY_EXTERNAL_PERIOD_UID = new Object();
 
-    private final Object replacedInternalId;
+    private final Object replacedInternalWindowUid;
+    private final Object replacedInternalPeriodUid;
 
     /**
      * Returns an instance with a dummy timeline using the provided window tag.
@@ -217,7 +221,8 @@ private Object getExternalPeriodUid(Object internalPeriodUid) {
      * @param windowTag A window tag.
      */
     public static MaskingTimeline createWithDummyTimeline(@Nullable Object windowTag) {
-      return new MaskingTimeline(new DummyTimeline(windowTag), DUMMY_EXTERNAL_ID);
+      return new MaskingTimeline(
+          new DummyTimeline(windowTag), Window.SINGLE_WINDOW_UID, DUMMY_EXTERNAL_PERIOD_UID);
     }
 
     /**
@@ -225,16 +230,21 @@ public static MaskingTimeline createWithDummyTimeline(@Nullable Object windowTag
      * assigned dummy period ID.
      *
      * @param timeline The real timeline.
+     * @param firstWindowUid The window UID in the timeline which will be replaced by the already
+     *     assigned {@link Window#SINGLE_WINDOW_UID}.
      * @param firstPeriodUid The period UID in the timeline which will be replaced by the already
-     *     assigned dummy period UID.
+     *     assigned {@link #DUMMY_EXTERNAL_PERIOD_UID}.
      */
-    public static MaskingTimeline createWithRealTimeline(Timeline timeline, Object firstPeriodUid) {
-      return new MaskingTimeline(timeline, firstPeriodUid);
+    public static MaskingTimeline createWithRealTimeline(
+        Timeline timeline, Object firstWindowUid, Object firstPeriodUid) {
+      return new MaskingTimeline(timeline, firstWindowUid, firstPeriodUid);
     }
 
-    private MaskingTimeline(Timeline timeline, Object replacedInternalId) {
+    private MaskingTimeline(
+        Timeline timeline, Object replacedInternalWindowUid, Object replacedInternalPeriodUid) {
       super(timeline);
-      this.replacedInternalId = replacedInternalId;
+      this.replacedInternalWindowUid = replacedInternalWindowUid;
+      this.replacedInternalPeriodUid = replacedInternalPeriodUid;
     }
 
     /**
@@ -243,7 +253,7 @@ private MaskingTimeline(Timeline timeline, Object replacedInternalId) {
      * @param timeline The new timeline.
      */
     public MaskingTimeline cloneWithUpdatedTimeline(Timeline timeline) {
-      return new MaskingTimeline(timeline, replacedInternalId);
+      return new MaskingTimeline(timeline, replacedInternalWindowUid, replacedInternalPeriodUid);
     }
 
     /** Returns the wrapped timeline. */
@@ -251,24 +261,34 @@ public Timeline getTimeline() {
       return timeline;
     }
 
+    @Override
+    public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
+      timeline.getWindow(windowIndex, window, defaultPositionProjectionUs);
+      if (Util.areEqual(window.uid, replacedInternalWindowUid)) {
+        window.uid = Window.SINGLE_WINDOW_UID;
+      }
+      return window;
+    }
+
     @Override
     public Period getPeriod(int periodIndex, Period period, boolean setIds) {
       timeline.getPeriod(periodIndex, period, setIds);
-      if (Util.areEqual(period.uid, replacedInternalId)) {
-        period.uid = DUMMY_EXTERNAL_ID;
+      if (Util.areEqual(period.uid, replacedInternalPeriodUid)) {
+        period.uid = DUMMY_EXTERNAL_PERIOD_UID;
       }
       return period;
     }
 
     @Override
     public int getIndexOfPeriod(Object uid) {
-      return timeline.getIndexOfPeriod(DUMMY_EXTERNAL_ID.equals(uid) ? replacedInternalId : uid);
+      return timeline.getIndexOfPeriod(
+          DUMMY_EXTERNAL_PERIOD_UID.equals(uid) ? replacedInternalPeriodUid : uid);
     }
 
     @Override
     public Object getUidOfPeriod(int periodIndex) {
       Object uid = timeline.getUidOfPeriod(periodIndex);
-      return Util.areEqual(uid, replacedInternalId) ? DUMMY_EXTERNAL_ID : uid;
+      return Util.areEqual(uid, replacedInternalPeriodUid) ? DUMMY_EXTERNAL_PERIOD_UID : uid;
     }
   }
 
@@ -289,6 +309,7 @@ public int getWindowCount() {
     @Override
     public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
       return window.set(
+          Window.SINGLE_WINDOW_UID,
           tag,
           /* manifest= */ null,
           /* presentationStartTimeMs= */ C.TIME_UNSET,
@@ -312,7 +333,7 @@ public int getPeriodCount() {
     public Period getPeriod(int periodIndex, Period period, boolean setIds) {
       return period.set(
           /* id= */ 0,
-          /* uid= */ MaskingTimeline.DUMMY_EXTERNAL_ID,
+          /* uid= */ MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID,
           /* windowIndex= */ 0,
           /* durationUs = */ C.TIME_UNSET,
           /* positionInWindowUs= */ 0);
@@ -320,12 +341,12 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
 
     @Override
     public int getIndexOfPeriod(Object uid) {
-      return uid == MaskingTimeline.DUMMY_EXTERNAL_ID ? 0 : C.INDEX_UNSET;
+      return uid == MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID ? 0 : C.INDEX_UNSET;
     }
 
     @Override
     public Object getUidOfPeriod(int periodIndex) {
-      return MaskingTimeline.DUMMY_EXTERNAL_ID;
+      return MaskingTimeline.DUMMY_EXTERNAL_PERIOD_UID;
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index 966f8e4c7a..49d67935a5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -175,6 +175,7 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
       }
     }
     return window.set(
+        Window.SINGLE_WINDOW_UID,
         tag,
         manifest,
         presentationStartTimeMs,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index 4e8da959ba..135de3d67f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -480,6 +480,12 @@ public ParametersBuilder setPreferredTextLanguage(@Nullable String preferredText
       return this;
     }
 
+    @Override
+    public ParametersBuilder setPreferredTextRoleFlags(@C.RoleFlags int preferredTextRoleFlags) {
+      super.setPreferredTextRoleFlags(preferredTextRoleFlags);
+      return this;
+    }
+
     @Override
     public ParametersBuilder setSelectUndeterminedTextLanguage(
         boolean selectUndeterminedTextLanguage) {
@@ -713,6 +719,7 @@ public Parameters build() {
           allowAudioMixedChannelCountAdaptiveness,
           // Text
           preferredTextLanguage,
+          preferredTextRoleFlags,
           selectUndeterminedTextLanguage,
           disabledTextTrackSelectionFlags,
           // General
@@ -917,6 +924,7 @@ private Parameters() {
           /* allowAudioMixedChannelCountAdaptiveness= */ false,
           // Text
           TrackSelectionParameters.DEFAULT.preferredTextLanguage,
+          TrackSelectionParameters.DEFAULT.preferredTextRoleFlags,
           TrackSelectionParameters.DEFAULT.selectUndeterminedTextLanguage,
           TrackSelectionParameters.DEFAULT.disabledTextTrackSelectionFlags,
           // General
@@ -950,6 +958,7 @@ private Parameters() {
         boolean allowAudioMixedChannelCountAdaptiveness,
         // Text
         @Nullable String preferredTextLanguage,
+        @C.RoleFlags int preferredTextRoleFlags,
         boolean selectUndeterminedTextLanguage,
         @C.SelectionFlags int disabledTextTrackSelectionFlags,
         // General
@@ -963,6 +972,7 @@ private Parameters() {
       super(
           preferredAudioLanguage,
           preferredTextLanguage,
+          preferredTextRoleFlags,
           selectUndeterminedTextLanguage,
           disabledTextTrackSelectionFlags);
       // Video
@@ -1407,7 +1417,8 @@ public DefaultTrackSelector() {
 
   /**
    * @deprecated Use {@link #DefaultTrackSelector(Context)} instead. The bandwidth meter should be
-   *     passed directly to the player in {@link SimpleExoPlayer.Builder}.
+   *     passed directly to the player in {@link
+   *     com.google.android.exoplayer2.SimpleExoPlayer.Builder}.
    */
   @Deprecated
   @SuppressWarnings("deprecation")
@@ -2691,7 +2702,9 @@ public int hashCode() {
     private final boolean isDefault;
     private final boolean hasPreferredIsForcedFlag;
     private final int preferredLanguageScore;
+    private final int preferredRoleFlagsScore;
     private final int selectedAudioLanguageScore;
+    private final boolean hasCaptionRoleFlags;
 
     public TextTrackScore(
         Format format,
@@ -2707,6 +2720,10 @@ public TextTrackScore(
       preferredLanguageScore =
           getFormatLanguageScore(
               format, parameters.preferredTextLanguage, parameters.selectUndeterminedTextLanguage);
+      preferredRoleFlagsScore =
+          Integer.bitCount(format.roleFlags & parameters.preferredTextRoleFlags);
+      hasCaptionRoleFlags =
+          (format.roleFlags & (C.ROLE_FLAG_CAPTION | C.ROLE_FLAG_DESCRIBES_MUSIC_AND_SOUND)) != 0;
       // Prefer non-forced to forced if a preferred text language has been matched. Where both are
       // provided the non-forced track will usually contain the forced subtitles as a subset.
       // Otherwise, prefer a forced track.
@@ -2717,7 +2734,10 @@ public TextTrackScore(
       selectedAudioLanguageScore =
           getFormatLanguageScore(format, selectedAudioLanguage, selectedAudioLanguageUndetermined);
       isWithinConstraints =
-          preferredLanguageScore > 0 || isDefault || (isForced && selectedAudioLanguageScore > 0);
+          preferredLanguageScore > 0
+              || (parameters.preferredTextLanguage == null && preferredRoleFlagsScore > 0)
+              || isDefault
+              || (isForced && selectedAudioLanguageScore > 0);
     }
 
     /**
@@ -2735,13 +2755,22 @@ public int compareTo(TextTrackScore other) {
       if (this.preferredLanguageScore != other.preferredLanguageScore) {
         return compareInts(this.preferredLanguageScore, other.preferredLanguageScore);
       }
+      if (this.preferredRoleFlagsScore != other.preferredRoleFlagsScore) {
+        return compareInts(this.preferredRoleFlagsScore, other.preferredRoleFlagsScore);
+      }
       if (this.isDefault != other.isDefault) {
         return this.isDefault ? 1 : -1;
       }
       if (this.hasPreferredIsForcedFlag != other.hasPreferredIsForcedFlag) {
         return this.hasPreferredIsForcedFlag ? 1 : -1;
       }
-      return compareInts(this.selectedAudioLanguageScore, other.selectedAudioLanguageScore);
+      if (this.selectedAudioLanguageScore != other.selectedAudioLanguageScore) {
+        return compareInts(this.selectedAudioLanguageScore, other.selectedAudioLanguageScore);
+      }
+      if (preferredRoleFlagsScore == 0 && this.hasCaptionRoleFlags != other.hasCaptionRoleFlags) {
+        return this.hasCaptionRoleFlags ? -1 : 1;
+      }
+      return 0;
     }
   }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java
index 1582fabc88..e31c4f51b8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectionParameters.java
@@ -33,6 +33,7 @@
 
     @Nullable /* package */ String preferredAudioLanguage;
     @Nullable /* package */ String preferredTextLanguage;
+    @C.RoleFlags /* package */ int preferredTextRoleFlags;
     /* package */ boolean selectUndeterminedTextLanguage;
     @C.SelectionFlags /* package */ int disabledTextTrackSelectionFlags;
 
@@ -48,6 +49,7 @@ public Builder() {
     /* package */ Builder(TrackSelectionParameters initialValues) {
       preferredAudioLanguage = initialValues.preferredAudioLanguage;
       preferredTextLanguage = initialValues.preferredTextLanguage;
+      preferredTextRoleFlags = initialValues.preferredTextRoleFlags;
       selectUndeterminedTextLanguage = initialValues.selectUndeterminedTextLanguage;
       disabledTextTrackSelectionFlags = initialValues.disabledTextTrackSelectionFlags;
     }
@@ -76,6 +78,17 @@ public Builder setPreferredTextLanguage(@Nullable String preferredTextLanguage)
       return this;
     }
 
+    /**
+     * Sets the preferred {@link C.RoleFlags} for text tracks.
+     *
+     * @param preferredTextRoleFlags Preferred text role flags.
+     * @return This builder.
+     */
+    public Builder setPreferredTextRoleFlags(@C.RoleFlags int preferredTextRoleFlags) {
+      this.preferredTextRoleFlags = preferredTextRoleFlags;
+      return this;
+    }
+
     /**
      * Sets whether a text track with undetermined language should be selected if no track with
      * {@link #setPreferredTextLanguage(String)} is available, or if the preferred language is
@@ -110,6 +123,7 @@ public TrackSelectionParameters build() {
           preferredAudioLanguage,
           // Text
           preferredTextLanguage,
+          preferredTextRoleFlags,
           selectUndeterminedTextLanguage,
           disabledTextTrackSelectionFlags);
     }
@@ -129,6 +143,11 @@ public TrackSelectionParameters build() {
    * the default track if there is one, or no track otherwise. The default value is {@code null}.
    */
   @Nullable public final String preferredTextLanguage;
+  /**
+   * The preferred {@link C.RoleFlags} for text tracks. {@code 0} selects the default track if there
+   * is one, or no track otherwise. The default value is {@code 0}.
+   */
+  @C.RoleFlags public final int preferredTextRoleFlags;
   /**
    * Whether a text track with undetermined language should be selected if no track with {@link
    * #preferredTextLanguage} is available, or if {@link #preferredTextLanguage} is unset. The
@@ -146,6 +165,7 @@ public TrackSelectionParameters build() {
         /* preferredAudioLanguage= */ null,
         // Text
         /* preferredTextLanguage= */ null,
+        /* preferredTextRoleFlags= */ 0,
         /* selectUndeterminedTextLanguage= */ false,
         /* disabledTextTrackSelectionFlags= */ 0);
   }
@@ -153,12 +173,14 @@ public TrackSelectionParameters build() {
   /* package */ TrackSelectionParameters(
       @Nullable String preferredAudioLanguage,
       @Nullable String preferredTextLanguage,
+      @C.RoleFlags int preferredTextRoleFlags,
       boolean selectUndeterminedTextLanguage,
       @C.SelectionFlags int disabledTextTrackSelectionFlags) {
     // Audio
     this.preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
     // Text
     this.preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
+    this.preferredTextRoleFlags = preferredTextRoleFlags;
     this.selectUndeterminedTextLanguage = selectUndeterminedTextLanguage;
     this.disabledTextTrackSelectionFlags = disabledTextTrackSelectionFlags;
   }
@@ -166,6 +188,7 @@ public TrackSelectionParameters build() {
   /* package */ TrackSelectionParameters(Parcel in) {
     this.preferredAudioLanguage = in.readString();
     this.preferredTextLanguage = in.readString();
+    this.preferredTextRoleFlags = in.readInt();
     this.selectUndeterminedTextLanguage = Util.readBoolean(in);
     this.disabledTextTrackSelectionFlags = in.readInt();
   }
@@ -187,6 +210,7 @@ public boolean equals(@Nullable Object obj) {
     TrackSelectionParameters other = (TrackSelectionParameters) obj;
     return TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
         && TextUtils.equals(preferredTextLanguage, other.preferredTextLanguage)
+        && preferredTextRoleFlags == other.preferredTextRoleFlags
         && selectUndeterminedTextLanguage == other.selectUndeterminedTextLanguage
         && disabledTextTrackSelectionFlags == other.disabledTextTrackSelectionFlags;
   }
@@ -196,6 +220,7 @@ public int hashCode() {
     int result = 1;
     result = 31 * result + (preferredAudioLanguage == null ? 0 : preferredAudioLanguage.hashCode());
     result = 31 * result + (preferredTextLanguage == null ? 0 : preferredTextLanguage.hashCode());
+    result = 31 * result + preferredTextRoleFlags;
     result = 31 * result + (selectUndeterminedTextLanguage ? 1 : 0);
     result = 31 * result + disabledTextTrackSelectionFlags;
     return result;
@@ -212,6 +237,7 @@ public int describeContents() {
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeString(preferredAudioLanguage);
     dest.writeString(preferredTextLanguage);
+    dest.writeInt(preferredTextRoleFlags);
     Util.writeBoolean(dest, selectUndeterminedTextLanguage);
     dest.writeInt(disabledTextTrackSelectionFlags);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index f73dde58c3..a9f571c085 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -21,6 +21,7 @@
 import android.graphics.Point;
 import android.media.MediaCodec;
 import android.media.MediaCodecInfo.CodecCapabilities;
+import android.media.MediaCodecInfo.CodecProfileLevel;
 import android.media.MediaCrypto;
 import android.media.MediaFormat;
 import android.os.Bundle;
@@ -393,15 +394,17 @@ protected int supportsFormat(
             format.sampleMimeType, requiresSecureDecoder, requiresTunnelingDecoder);
     decoderInfos = MediaCodecUtil.getDecoderInfosSortedByFormatSupport(decoderInfos, format);
     if (MimeTypes.VIDEO_DOLBY_VISION.equals(format.sampleMimeType)) {
-      // Fallback to primary decoders for H.265/HEVC or H.264/AVC for the relevant DV profiles.
+      // Fall back to H.264/AVC or H.265/HEVC for the relevant DV profiles.
+      @Nullable
       Pair<Integer, Integer> codecProfileAndLevel = MediaCodecUtil.getCodecProfileAndLevel(format);
       if (codecProfileAndLevel != null) {
         int profile = codecProfileAndLevel.first;
-        if (profile == 4 || profile == 8) {
+        if (profile == CodecProfileLevel.DolbyVisionProfileDvheDtr
+            || profile == CodecProfileLevel.DolbyVisionProfileDvheSt) {
           decoderInfos.addAll(
               mediaCodecSelector.getDecoderInfos(
                   MimeTypes.VIDEO_H265, requiresSecureDecoder, requiresTunnelingDecoder));
-        } else if (profile == 9) {
+        } else if (profile == CodecProfileLevel.DolbyVisionProfileDvavSe) {
           decoderInfos.addAll(
               mediaCodecSelector.getDecoderInfos(
                   MimeTypes.VIDEO_H264, requiresSecureDecoder, requiresTunnelingDecoder));
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
index 39c3aa2621..048f9cbf0f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer2.video;
 
 import android.os.Handler;
-import android.os.Looper;
 import android.os.SystemClock;
 import android.view.Surface;
 import androidx.annotation.CallSuper;
@@ -38,7 +37,6 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.TimedValueQueue;
 import com.google.android.exoplayer2.util.TraceUtil;
-import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoRendererEventListener.EventDispatcher;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -80,8 +78,7 @@
   private final DecoderInputBuffer flagsOnlyBuffer;
   private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
 
-  private Format format;
-  private Format pendingFormat;
+  private Format inputFormat;
   private Format outputFormat;
   private SimpleDecoder<
           VideoDecoderInputBuffer,
@@ -100,6 +97,7 @@
   private long initialPositionUs;
   private long joiningDeadlineMs;
   private boolean waitingForKeys;
+  private boolean waitingForFirstSampleInFormat;
 
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
@@ -166,7 +164,7 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       return;
     }
 
-    if (format == null) {
+    if (inputFormat == null) {
       // We don't have a format yet, so try and read one.
       formatHolder.clear();
       flagsOnlyBuffer.clear();
@@ -213,7 +211,7 @@ public boolean isReady() {
     if (waitingForKeys) {
       return false;
     }
-    if (format != null
+    if (inputFormat != null
         && (isSourceReady() || outputBuffer != null)
         && (renderedFirstFrame || !hasOutputSurface())) {
       // Ready. If we were joining then we've now joined, so clear the joining deadline.
@@ -271,7 +269,7 @@ protected void onStopped() {
 
   @Override
   protected void onDisabled() {
-    format = null;
+    inputFormat = null;
     waitingForKeys = false;
     clearReportedVideoSize();
     clearRenderedFirstFrame();
@@ -363,32 +361,15 @@ private void setDecoderDrmSession(@Nullable DrmSession<ExoMediaCrypto> session)
   @CallSuper
   @SuppressWarnings("unchecked")
   protected void onInputFormatChanged(FormatHolder formatHolder) throws ExoPlaybackException {
-    Format oldFormat = format;
-    format = formatHolder.format;
-    pendingFormat = format;
-
-    boolean drmInitDataChanged =
-        !Util.areEqual(format.drmInitData, oldFormat == null ? null : oldFormat.drmInitData);
-    if (drmInitDataChanged) {
-      if (format.drmInitData != null) {
-        if (formatHolder.includesDrmSession) {
-          setSourceDrmSession((DrmSession<ExoMediaCrypto>) formatHolder.drmSession);
-        } else {
-          if (drmSessionManager == null) {
-            throw ExoPlaybackException.createForRenderer(
-                new IllegalStateException("Media requires a DrmSessionManager"), getIndex());
-          }
-          DrmSession<ExoMediaCrypto> session =
-              drmSessionManager.acquireSession(Looper.myLooper(), format.drmInitData);
-          if (sourceDrmSession != null) {
-            sourceDrmSession.releaseReference();
-          }
-          sourceDrmSession = session;
-        }
-      } else {
-        setSourceDrmSession(null);
-      }
+    waitingForFirstSampleInFormat = true;
+    Format newFormat = Assertions.checkNotNull(formatHolder.format);
+    if (formatHolder.includesDrmSession) {
+      setSourceDrmSession((DrmSession<ExoMediaCrypto>) formatHolder.drmSession);
+    } else {
+      sourceDrmSession =
+          getUpdatedSourceDrmSession(inputFormat, newFormat, drmSessionManager, sourceDrmSession);
     }
+    inputFormat = newFormat;
 
     if (sourceDrmSession != decoderDrmSession) {
       if (decoderReceivedBuffers) {
@@ -401,7 +382,7 @@ protected void onInputFormatChanged(FormatHolder formatHolder) throws ExoPlaybac
       }
     }
 
-    eventDispatcher.inputFormatChanged(format);
+    eventDispatcher.inputFormatChanged(inputFormat);
   }
 
   /**
@@ -663,7 +644,7 @@ private void maybeInitDecoder() throws ExoPlaybackException {
 
     try {
       long decoderInitializingTimestamp = SystemClock.elapsedRealtime();
-      decoder = createDecoder(format, mediaCrypto);
+      decoder = createDecoder(inputFormat, mediaCrypto);
       long decoderInitializedTimestamp = SystemClock.elapsedRealtime();
       onDecoderInitialized(
           decoder.getName(),
@@ -726,12 +707,12 @@ private boolean feedInputBuffer() throws VideoDecoderException, ExoPlaybackExcep
     if (waitingForKeys) {
       return false;
     }
-    if (pendingFormat != null) {
-      formatQueue.add(inputBuffer.timeUs, pendingFormat);
-      pendingFormat = null;
+    if (waitingForFirstSampleInFormat) {
+      formatQueue.add(inputBuffer.timeUs, inputFormat);
+      waitingForFirstSampleInFormat = false;
     }
     inputBuffer.flip();
-    inputBuffer.colorInfo = format.colorInfo;
+    inputBuffer.colorInfo = inputFormat.colorInfo;
     onQueueInputBuffer(inputBuffer);
     decoder.queueInputBuffer(inputBuffer);
     buffersInCodecCount++;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtilTest.java
index e8d65255c3..3693e494d4 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtilTest.java
@@ -19,6 +19,7 @@
 
 import android.media.MediaCodecInfo;
 import android.util.Pair;
+import androidx.annotation.Nullable;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -34,6 +35,7 @@
   @Test
   public void getCodecProfileAndLevel_handlesVp9Profile1CodecString() {
     assertCodecProfileAndLevelForCodecsString(
+        MimeTypes.VIDEO_VP9,
         "vp09.01.51",
         MediaCodecInfo.CodecProfileLevel.VP9Profile1,
         MediaCodecInfo.CodecProfileLevel.VP9Level51);
@@ -42,6 +44,7 @@ public void getCodecProfileAndLevel_handlesVp9Profile1CodecString() {
   @Test
   public void getCodecProfileAndLevel_handlesVp9Profile2CodecString() {
     assertCodecProfileAndLevelForCodecsString(
+        MimeTypes.VIDEO_VP9,
         "vp09.02.10",
         MediaCodecInfo.CodecProfileLevel.VP9Profile2,
         MediaCodecInfo.CodecProfileLevel.VP9Level1);
@@ -51,6 +54,7 @@ public void getCodecProfileAndLevel_handlesVp9Profile2CodecString() {
   public void getCodecProfileAndLevel_handlesFullVp9CodecString() {
     // Example from https://www.webmproject.org/vp9/mp4/#codecs-parameter-string.
     assertCodecProfileAndLevelForCodecsString(
+        MimeTypes.VIDEO_VP9,
         "vp09.02.10.10.01.09.16.09.01",
         MediaCodecInfo.CodecProfileLevel.VP9Profile2,
         MediaCodecInfo.CodecProfileLevel.VP9Level1);
@@ -59,6 +63,7 @@ public void getCodecProfileAndLevel_handlesFullVp9CodecString() {
   @Test
   public void getCodecProfileAndLevel_handlesDolbyVisionCodecString() {
     assertCodecProfileAndLevelForCodecsString(
+        MimeTypes.VIDEO_DOLBY_VISION,
         "dvh1.05.05",
         MediaCodecInfo.CodecProfileLevel.DolbyVisionProfileDvheStn,
         MediaCodecInfo.CodecProfileLevel.DolbyVisionLevelFhd60);
@@ -67,6 +72,7 @@ public void getCodecProfileAndLevel_handlesDolbyVisionCodecString() {
   @Test
   public void getCodecProfileAndLevel_handlesAv1ProfileMain8CodecString() {
     assertCodecProfileAndLevelForCodecsString(
+        MimeTypes.VIDEO_AV1,
         "av01.0.10M.08",
         MediaCodecInfo.CodecProfileLevel.AV1ProfileMain8,
         MediaCodecInfo.CodecProfileLevel.AV1Level42);
@@ -75,6 +81,7 @@ public void getCodecProfileAndLevel_handlesAv1ProfileMain8CodecString() {
   @Test
   public void getCodecProfileAndLevel_handlesAv1ProfileMain10CodecString() {
     assertCodecProfileAndLevelForCodecsString(
+        MimeTypes.VIDEO_AV1,
         "av01.0.20M.10",
         MediaCodecInfo.CodecProfileLevel.AV1ProfileMain10,
         MediaCodecInfo.CodecProfileLevel.AV1Level7);
@@ -91,7 +98,7 @@ public void getCodecProfileAndLevel_handlesAv1ProfileMain10HDRWithHdrInfoSet() {
     Format format =
         Format.createVideoSampleFormat(
             /* id= */ null,
-            /* sampleMimeType= */ MimeTypes.VIDEO_UNKNOWN,
+            MimeTypes.VIDEO_AV1,
             /* codecs= */ "av01.0.21M.10",
             /* bitrate= */ Format.NO_VALUE,
             /* maxInputSize= */ Format.NO_VALUE,
@@ -122,7 +129,7 @@ public void getCodecProfileAndLevel_handlesAv1ProfileMain10HDRWithoutHdrInfoSet(
     Format format =
         Format.createVideoSampleFormat(
             /* id= */ null,
-            /* sampleMimeType= */ MimeTypes.VIDEO_UNKNOWN,
+            MimeTypes.VIDEO_AV1,
             /* codecs= */ "av01.0.21M.10",
             /* bitrate= */ Format.NO_VALUE,
             /* maxInputSize= */ Format.NO_VALUE,
@@ -146,6 +153,7 @@ public void getCodecProfileAndLevel_handlesAv1ProfileMain10HDRWithoutHdrInfoSet(
   public void getCodecProfileAndLevel_handlesFullAv1CodecString() {
     // Example from https://aomediacodec.github.io/av1-isobmff/#codecsparam.
     assertCodecProfileAndLevelForCodecsString(
+        MimeTypes.VIDEO_AV1,
         "av01.0.04M.10.0.112.09.16.09.0",
         MediaCodecInfo.CodecProfileLevel.AV1ProfileMain10,
         MediaCodecInfo.CodecProfileLevel.AV1Level3);
@@ -186,11 +194,11 @@ public void getCodecProfileAndLevel_rejectsEmptyCodecString() {
   }
 
   private static void assertCodecProfileAndLevelForCodecsString(
-      String codecs, int profile, int level) {
+      String mimeType, String codecs, int profile, int level) {
     Format format =
         Format.createVideoSampleFormat(
             /* id= */ null,
-            /* sampleMimeType= */ MimeTypes.VIDEO_UNKNOWN,
+            mimeType,
             /* codecs= */ codecs,
             /* bitrate= */ Format.NO_VALUE,
             /* maxInputSize= */ Format.NO_VALUE,
@@ -203,6 +211,7 @@ private static void assertCodecProfileAndLevelForCodecsString(
   }
 
   private static void assertCodecProfileAndLevelForFormat(Format format, int profile, int level) {
+    @Nullable
     Pair<Integer, Integer> codecProfileAndLevel = MediaCodecUtil.getCodecProfileAndLevel(format);
     assertThat(codecProfileAndLevel).isNotNull();
     assertThat(codecProfileAndLevel.first).isEqualTo(profile);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
index 7c57c44924..292742b527 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
@@ -151,6 +151,7 @@ public void testParametersParcelable() {
             /* allowAudioMixedChannelCountAdaptiveness= */ true,
             // Text
             /* preferredTextLanguage= */ "de",
+            /* preferredTextRoleFlags= */ C.ROLE_FLAG_CAPTION,
             /* selectUndeterminedTextLanguage= */ true,
             /* disabledTextTrackSelectionFlags= */ 8,
             // General
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index c9a039a4bd..f8bdfd5ec6 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -1216,6 +1216,7 @@ public Window getWindow(int windowIndex, Window window, long defaultPositionProj
               && manifest.minUpdatePeriodMs != C.TIME_UNSET
               && manifest.durationMs == C.TIME_UNSET;
       return window.set(
+          Window.SINGLE_WINDOW_UID,
           windowTag,
           manifest,
           presentationStartTimeMs,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index f2db9541eb..713d96c759 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -414,8 +414,18 @@ public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
           playlist.hasEndTag ? offsetFromInitialStartTimeUs + playlist.durationUs : C.TIME_UNSET;
       List<HlsMediaPlaylist.Segment> segments = playlist.segments;
       if (windowDefaultStartPositionUs == C.TIME_UNSET) {
-        windowDefaultStartPositionUs = segments.isEmpty() ? 0
-            : segments.get(Math.max(0, segments.size() - 3)).relativeStartTimeUs;
+        windowDefaultStartPositionUs = 0;
+        if (!segments.isEmpty()) {
+          int defaultStartSegmentIndex = Math.max(0, segments.size() - 3);
+          // We attempt to set the default start position to be at least twice the target duration
+          // behind the live edge.
+          long minStartPositionUs = playlist.durationUs - playlist.targetDurationUs * 2;
+          while (defaultStartSegmentIndex > 0
+              && segments.get(defaultStartSegmentIndex).relativeStartTimeUs > minStartPositionUs) {
+            defaultStartSegmentIndex--;
+          }
+          windowDefaultStartPositionUs = segments.get(defaultStartSegmentIndex).relativeStartTimeUs;
+        }
       }
       timeline =
           new SinglePeriodTimeline(
diff --git a/library/ui/src/main/res/values/strings.xml b/library/ui/src/main/res/values/strings.xml
index e3f1c3aaec..056f4de409 100644
--- a/library/ui/src/main/res/values/strings.xml
+++ b/library/ui/src/main/res/values/strings.xml
@@ -34,9 +34,9 @@
   <string name="exo_controls_repeat_one_description">Repeat one</string>
   <!-- Description for a button that controls the repeat mode of a media playback. In this mode the entire playlist is repeated. [CHAR LIMIT=30] -->
   <string name="exo_controls_repeat_all_description">Repeat all</string>
-  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is on. [CHAR LIMIT=30] -->
+  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is on. [CHAR LIMIT=33] -->
   <string name="exo_controls_shuffle_on_description">Shuffle on</string>
-  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is off. [CHAR LIMIT=30] -->
+  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is off. [CHAR LIMIT=33] -->
   <string name="exo_controls_shuffle_off_description">Shuffle off</string>
   <!-- Description for a media control button that toggles whether a video playback is fullscreen. [CHAR LIMIT=30] -->
   <string name="exo_controls_fullscreen_description">Fullscreen mode</string>
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
index f0a0c77ff6..af672f0da3 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
@@ -182,6 +182,7 @@ public int getWindowCount() {
   public Window getWindow(int windowIndex, Window window, long defaultPositionProjectionUs) {
     TimelineWindowDefinition windowDefinition = windowDefinitions[windowIndex];
     return window.set(
+        /* uid= */ windowDefinition.id,
         /* tag= */ windowDefinition.id,
         manifests[windowIndex],
         /* presentationStartTimeMs= */ C.TIME_UNSET,
