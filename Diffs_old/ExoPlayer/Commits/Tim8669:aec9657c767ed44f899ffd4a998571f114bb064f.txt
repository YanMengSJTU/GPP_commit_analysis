diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java b/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
index 02167d3838..7eaaa107a6 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/MediaChunk.java
@@ -43,6 +43,10 @@ public MediaChunk(DataSource dataSource, DataSpec dataSpec, int trigger, Format
         Chunk.NO_PARENT_ID);
   }
 
+  public int getNextChunkIndex() {
+    return chunkIndex + 1;
+  }
+
   /**
    * @param dataSource A {@link DataSource} for loading the data.
    * @param dataSpec Defines the data to be loaded.
diff --git a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
index 8c7350e1d5..be84f3fa0d 100644
--- a/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/dash/DashChunkSource.java
@@ -424,7 +424,7 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long playb
         if (previous.parentId == lastPeriodHolder.localIndex) {
           RepresentationHolder representationHolder =
               lastPeriodHolder.representationHolders.get(previous.format.id);
-          if (representationHolder.isLastSegment(previous.chunkIndex)) {
+          if (representationHolder.isBeyondLastSegment(previous.getNextChunkIndex())) {
             out.endOfStream = true;
             return;
           }
@@ -443,7 +443,7 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long playb
       } else if (!periodHolder.isIndexUnbounded()) {
         RepresentationHolder representationHolder =
             periodHolder.representationHolders.get(previous.format.id);
-        if (representationHolder.isLastSegment(previous.chunkIndex)) {
+        if (representationHolder.isBeyondLastSegment(previous.getNextChunkIndex())) {
           // We reached the end of a period. Start the next one.
           periodHolder = periodHolders.get(previous.parentId + 1);
           startingNewPeriod = true;
@@ -478,9 +478,9 @@ public final void getChunkOperation(List<? extends MediaChunk> queue, long playb
 
     int segmentNum = queue.isEmpty() ? representationHolder.getSegmentNum(playbackPositionUs)
           : startingNewPeriod ? representationHolder.getFirstAvailableSegmentNum()
-          : queue.get(out.queueSize - 1).chunkIndex + 1;
+          : queue.get(out.queueSize - 1).getNextChunkIndex();
     Chunk nextMediaChunk = newMediaChunk(periodHolder, representationHolder, dataSource,
-        mediaFormat, segmentNum, evaluation.trigger);
+        mediaFormat, enabledTrack, segmentNum, evaluation.trigger);
     lastChunkWasInitialization = false;
     out.chunk = nextMediaChunk;
   }
@@ -672,8 +672,9 @@ private Chunk newInitializationChunk(RangedUri initializationUri, RangedUri inde
         extractor, manifestIndex);
   }
 
-  private Chunk newMediaChunk(PeriodHolder periodHolder, RepresentationHolder representationHolder,
-      DataSource dataSource, MediaFormat mediaFormat, int segmentNum, int trigger) {
+  protected Chunk newMediaChunk(
+      PeriodHolder periodHolder, RepresentationHolder representationHolder, DataSource dataSource,
+      MediaFormat mediaFormat, ExposedTrack enabledTrack, int segmentNum, int trigger) {
     Representation representation = representationHolder.representation;
     Format format = representation.format;
     long startTimeUs = representationHolder.getSegmentStartTimeUs(segmentNum);
@@ -802,11 +803,13 @@ public void run() {
     }
   }
 
-  // Private classes.
+  // Protected classes.
 
-  private static final class ExposedTrack {
+  protected static final class ExposedTrack {
 
     public final MediaFormat trackFormat;
+    public final int adaptiveMaxWidth;
+    public final int adaptiveMaxHeight;
 
     private final int adaptationSetIndex;
 
@@ -815,8 +818,6 @@ public void run() {
 
     // Adaptive track variables.
     private final Format[] adaptiveFormats;
-    private final int adaptiveMaxWidth;
-    private final int adaptiveMaxHeight;
 
     public ExposedTrack(MediaFormat trackFormat, int adaptationSetIndex, Format fixedFormat) {
       this.trackFormat = trackFormat;
@@ -843,8 +844,9 @@ public boolean isAdaptive() {
 
   }
 
-  private static final class RepresentationHolder {
+  protected static final class RepresentationHolder {
 
+    public final boolean mimeTypeIsRawText;
     public final ChunkExtractorWrapper extractorWrapper;
 
     public Representation representation;
@@ -862,7 +864,8 @@ public RepresentationHolder(long periodStartTimeUs, long periodDurationUs,
       this.periodDurationUs = periodDurationUs;
       this.representation = representation;
       String mimeType = representation.format.mimeType;
-      extractorWrapper = mimeTypeIsRawText(mimeType) ? null : new ChunkExtractorWrapper(
+      mimeTypeIsRawText = mimeTypeIsRawText(mimeType);
+      extractorWrapper = mimeTypeIsRawText ? null : new ChunkExtractorWrapper(
           mimeTypeIsWebm(mimeType) ? new WebmExtractor() : new FragmentedMp4Extractor());
       segmentIndex = representation.getIndex();
     }
@@ -919,10 +922,14 @@ public long getSegmentEndTimeUs(int segmentNum) {
           + segmentIndex.getDurationUs(segmentNum - segmentNumShift, periodDurationUs);
     }
 
-    public boolean isLastSegment(int segmentNum) {
-      int lastSegmentNum = segmentIndex.getLastSegmentNum(periodDurationUs);
+    public int getLastSegmentNum() {
+      return segmentIndex.getLastSegmentNum(periodDurationUs);
+    }
+
+    public boolean isBeyondLastSegment(int segmentNum) {
+      int lastSegmentNum = getLastSegmentNum();
       return lastSegmentNum == DashSegmentIndex.INDEX_UNBOUNDED ? false
-          : segmentNum == (lastSegmentNum + segmentNumShift);
+          : segmentNum > (lastSegmentNum + segmentNumShift);
     }
 
     public int getFirstAvailableSegmentNum() {
@@ -935,7 +942,7 @@ public RangedUri getSegmentUrl(int segmentNum) {
 
   }
 
-  private static final class PeriodHolder {
+  protected static final class PeriodHolder {
 
     public final int localIndex;
     public final long startTimeUs;
@@ -1019,6 +1026,10 @@ public boolean isIndexExplicit() {
       return indexIsExplicit;
     }
 
+    public DrmInitData getDrmInitData() {
+      return drmInitData;
+    }
+
     // Private methods.
 
     private void updateRepresentationIndependentProperties(long periodDurationUs,
