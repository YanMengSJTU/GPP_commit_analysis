diff --git a/settings.gradle b/settings.gradle
old mode 100644
new mode 100755
index 544d2d4a21..bd9af4cdf1
--- a/settings.gradle
+++ b/settings.gradle
@@ -11,7 +11,7 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
-include ':library'
+include ':library', ':twelve'
 include ':library-core'
 include ':library-dash'
 include ':library-hls'
diff --git a/twelve/.gitignore b/twelve/.gitignore
new file mode 100755
index 0000000000..796b96d1c4
--- /dev/null
+++ b/twelve/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/twelve/build.gradle b/twelve/build.gradle
new file mode 100755
index 0000000000..76c49ec254
--- /dev/null
+++ b/twelve/build.gradle
@@ -0,0 +1,56 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 25
+    buildToolsVersion "25.0.2"
+
+    defaultConfig {
+        applicationId "com.dolzzo.twelve"
+        minSdkVersion 19
+        targetSdkVersion 25
+        versionCode 1
+        versionName "1.0"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+        renderscriptTargetApi 19
+        renderscriptSupportModeEnabled true
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+
+        debug {
+            shrinkResources false
+            minifyEnabled false
+            jniDebuggable = true
+        }
+    }
+
+    productFlavors {
+        noExtensions
+        withExtensions
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+        exclude group: 'com.android.support', module: 'support-annotations'
+    })
+    compile 'com.android.support:appcompat-v7:25.3.1'
+    compile 'com.android.support:support-v4:25.3.1'
+    compile 'com.android.support:support-annotations:25.3.1'
+    compile 'com.android.support:cardview-v7:25.3.1'
+    compile 'com.android.support:palette-v7:25.3.1'
+    compile 'com.android.support:design:25.3.1'
+
+    compile project(':library')
+    withExtensionsCompile project(path: ':extension-ffmpeg')
+    withExtensionsCompile project(path: ':extension-flac')
+    withExtensionsCompile project(path: ':extension-opus')
+    withExtensionsCompile project(path: ':extension-vp9')
+
+    testCompile 'junit:junit:4.12'
+}
diff --git a/twelve/proguard-rules.pro b/twelve/proguard-rules.pro
new file mode 100755
index 0000000000..eacdf33fa7
--- /dev/null
+++ b/twelve/proguard-rules.pro
@@ -0,0 +1,25 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in C:\Dev\android-sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
+#-renamesourcefileattribute SourceFile
diff --git a/twelve/src/androidTest/java/com/dolzzo/twelve/ExampleInstrumentedTest.java b/twelve/src/androidTest/java/com/dolzzo/twelve/ExampleInstrumentedTest.java
new file mode 100755
index 0000000000..e6085ad1da
--- /dev/null
+++ b/twelve/src/androidTest/java/com/dolzzo/twelve/ExampleInstrumentedTest.java
@@ -0,0 +1,26 @@
+package com.dolzzo.twelve;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumentation test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() throws Exception {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getTargetContext();
+
+        assertEquals("com.dolzzo.twelve", appContext.getPackageName());
+    }
+}
diff --git a/twelve/src/main/AndroidManifest.xml b/twelve/src/main/AndroidManifest.xml
new file mode 100755
index 0000000000..6d09c87aa5
--- /dev/null
+++ b/twelve/src/main/AndroidManifest.xml
@@ -0,0 +1,208 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2012 Andrew Neal
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.dolzzo.twelve">
+
+    <!-- Used for caching and creating new playlists -->
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+    <!-- Used to check for a network connection -->
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+    <!-- Used to download images -->
+    <uses-permission android:name="android.permission.INTERNET" />
+    <!-- Used to keep the service running when the phone sleeps -->
+    <uses-permission android:name="android.permission.WAKE_LOCK" />
+    <!-- The main service uses a sticky broadcast -->
+    <uses-permission android:name="android.permission.BROADCAST_STICKY" />
+    <!-- Lower or raise the music based on the phone state -->
+    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
+    <!-- Used to set the devices's ringtone -->
+    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
+    <!-- Used to create launcher shortcuts -->
+    <uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT" />
+    <!-- Used to check if the app is in the background -->
+    <uses-permission android:name="android.permission.REAL_GET_TASKS" />
+    <!-- Allows Eleven to read from External Storage -->
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
+
+    <!-- Audio Visualizer Permissions -->
+    <uses-permission android:name="android.permission.RECORD_AUDIO" />
+    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
+
+    <!-- Accelerometer feature for shake to play -->
+    <uses-feature android:name="android.hardware.sensor.accelerometer" />
+
+    <application
+        android:name=".ElevenApplication"
+        android:allowBackup="true"
+        android:allowTaskReparenting="true"
+        android:hardwareAccelerated="@bool/config_hardwareAccelerated"
+        android:icon="@mipmap/ic_launcher_eleven"
+        android:label="@string/app_name"
+        android:largeHeap="@bool/config_largeHeap"
+        android:taskAffinity="com.dolzzo.twelve.task"
+        android:theme="@style/AppTheme.NoActionBar">
+
+        <!-- Searchable -->
+        <meta-data
+            android:name="android.app.default_searchable"
+            android:value=".ui.activities.SearchActivity" />
+        <!-- Main activity -->
+        <activity
+            android:name=".ui.activities.HomeActivity"
+            android:exported="true"
+            android:launchMode="singleTop"
+            android:theme="@style/AppTheme.NoActionBar"
+            android:windowSoftInputMode="adjustPan">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <action android:name="android.intent.action.MUSIC_PLAYER" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+                <category android:name="android.intent.category.APP_MUSIC" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+
+                <data android:mimeType="vnd.android.cursor.dir/playlist" />
+                <data android:mimeType="vnd.android.cursor.dir/albums" />
+                <data android:mimeType="vnd.android.cursor.dir/artists" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="com.dolzzo.twelve.AUDIO_PLAYER" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+        <!-- Search interface -->
+        <activity
+            android:name=".ui.activities.SearchActivity"
+            android:exported="true"
+            android:theme="@style/AppTheme"
+            android:windowSoftInputMode="adjustResize">
+            <intent-filter>
+                <action android:name="android.intent.action.SEARCH" />
+                <action android:name="android.intent.action.MEDIA_SEARCH" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+
+            <meta-data
+                android:name="android.app.searchable"
+                android:resource="@xml/searchable" />
+        </activity>
+        <!-- Used to set options -->
+        <activity
+            android:name=".ui.activities.SettingsActivity"
+            android:label="@string/menu_settings" />
+        <!-- Audio Preview -->
+        <activity
+            android:name=".ui.activities.preview.AudioPreviewActivity"
+            android:excludeFromRecents="true"
+            android:launchMode="singleTask"
+            android:taskAffinity=""
+            android:theme="@style/Theme.AudioPreview">
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+
+                <data android:scheme="content" />
+                <data android:mimeType="audio/*" />
+                <data android:mimeType="application/ogg" />
+                <data android:mimeType="application/x-ogg" />
+                <data android:mimeType="application/itunes" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+
+                <data android:scheme="file" />
+                <data android:mimeType="audio/*" />
+                <data android:mimeType="application/ogg" />
+                <data android:mimeType="application/x-ogg" />
+                <data android:mimeType="application/itunes" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.BROWSABLE" />
+
+                <data android:scheme="http" />
+                <data android:mimeType="audio/*" />
+                <data android:mimeType="application/ogg" />
+                <data android:mimeType="application/x-ogg" />
+                <data android:mimeType="application/itunes" />
+            </intent-filter>
+        </activity>
+        <!-- 4x1 App Widget -->
+        <receiver
+            android:name=".appwidgets.AppWidgetSmall"
+            android:exported="false"
+            android:label="@string/app_widget_small">
+            <intent-filter>
+                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
+            </intent-filter>
+
+            <meta-data
+                android:name="android.appwidget.provider"
+                android:resource="@xml/app_widget_small" />
+        </receiver>
+        <!-- 4x2  App Widget -->
+        <receiver
+            android:name=".appwidgets.AppWidgetLarge"
+            android:exported="false"
+            android:label="@string/app_widget_large">
+            <intent-filter>
+                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
+            </intent-filter>
+
+            <meta-data
+                android:name="android.appwidget.provider"
+                android:resource="@xml/app_widget_large" />
+        </receiver>
+        <!-- 4x2 alternate App Widget -->
+        <receiver
+            android:name=".appwidgets.AppWidgetLargeAlternate"
+            android:exported="false"
+            android:label="@string/app_widget_large_alt">
+            <intent-filter>
+                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
+            </intent-filter>
+
+            <meta-data
+                android:name="android.appwidget.provider"
+                android:resource="@xml/app_widget_large_alternate" />
+        </receiver>
+        <!-- Media button receiver -->
+        <receiver android:name=".MediaButtonIntentReceiver">
+            <intent-filter>
+                <action android:name="android.intent.action.MEDIA_BUTTON" />
+                <action android:name="android.media.AUDIO_BECOMING_NOISY" />
+            </intent-filter>
+        </receiver>
+        <!-- Music service -->
+        <service
+            android:name=".MusicPlaybackService"
+            android:label="@string/app_name" />
+    </application>
+
+</manifest>
diff --git a/twelve/src/main/aidl/com/dolzzo/twelve/IElevenService.aidl b/twelve/src/main/aidl/com/dolzzo/twelve/IElevenService.aidl
new file mode 100755
index 0000000000..7ad2fcb9a9
--- /dev/null
+++ b/twelve/src/main/aidl/com/dolzzo/twelve/IElevenService.aidl
@@ -0,0 +1,53 @@
+package com.dolzzo.twelve;
+
+import com.dolzzo.twelve.service.MusicPlaybackTrack;
+
+interface IElevenService
+{
+    void openFile(String path);
+    void open(in long [] list, int position, long sourceId, int sourceType);
+    void stop();
+    void pause();
+    void play();
+    void prev(boolean forcePrevious);
+    void next();
+    void enqueue(in long [] list, int action, long sourceId, int sourceType);
+    void setQueuePosition(int index);
+    void setShuffleMode(int shufflemode);
+    void setRepeatMode(int repeatmode);
+    void moveQueueItem(int from, int to);
+    void refresh();
+    void playlistChanged();
+    boolean isPlaying();
+    long [] getQueue();
+    long getQueueItemAtPosition(int position);
+    int getQueueSize();
+    int getQueuePosition();
+    int getQueueHistoryPosition(int position);
+    int getQueueHistorySize();
+    int[] getQueueHistoryList();
+    long duration();
+    long position();
+    long seek(long pos);
+    void seekRelative(long deltaInMs);
+    long getAudioId();
+    MusicPlaybackTrack getCurrentTrack();
+    MusicPlaybackTrack getTrack(int index);
+    long getNextAudioId();
+    long getPreviousAudioId();
+    long getArtistId();
+    long getAlbumId();
+    String getArtistName();
+    String getTrackName();
+    String getAlbumName();
+    String getPath();
+    int getShuffleMode();
+    int removeTracks(int first, int last);
+    int removeTrack(long id);
+    boolean removeTrackAtPosition(long id, int position);
+    int getRepeatMode();
+    int getMediaMountedCount();
+    int getAudioSessionId();
+    void setShakeToPlayEnabled(boolean enabled);
+    void setLockscreenAlbumArt(boolean enabled);
+}
diff --git a/twelve/src/main/aidl/com/dolzzo/twelve/service/MusicPlaybackTrack.aidl b/twelve/src/main/aidl/com/dolzzo/twelve/service/MusicPlaybackTrack.aidl
new file mode 100755
index 0000000000..68c880ac29
--- /dev/null
+++ b/twelve/src/main/aidl/com/dolzzo/twelve/service/MusicPlaybackTrack.aidl
@@ -0,0 +1,3 @@
+package com.dolzzo.twelve.service;
+
+parcelable MusicPlaybackTrack;
\ No newline at end of file
diff --git a/twelve/src/main/assets/licenses.html b/twelve/src/main/assets/licenses.html
new file mode 100755
index 0000000000..8f98b81e69
--- /dev/null
+++ b/twelve/src/main/assets/licenses.html
@@ -0,0 +1,97 @@
+<html>
+<head>
+    <style> body { } pre { background-color: #eeeeee; padding: 1em; white-space: pre-wrap; }
+    </style>
+</head>
+<body>
+<h3>Notices for files:</h3>
+<ul>
+    <li>ActionBarSherlock</li>
+    <li>NineOldAndroids.jar</li>
+</ul>
+<pre>
+/*
+ * Copyright 2012 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+</pre>
+
+<h3>Notices for file:</h3>
+<ul>
+    <li>AppMsg</li>
+</ul>
+<pre>
+/*
+ * Copyright 2012 Evgeny Shishkin
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+</pre>
+
+<h3>Notices for files:</h3>
+<ul>
+    <li>DragSortListView</li>
+</ul>
+<pre>
+/*
+ * Copyright (C) 2012 Carl Bauer
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+</pre>
+</body>
+</html>
+
+<h3>Notices for file:</h3>
+<ul>
+    <li>android-support-v4.jar</li>
+</ul>
+<pre>
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+</pre>
+</body></html>
diff --git a/twelve/src/main/java/com/dolzzo/twelve/Config.java b/twelve/src/main/java/com/dolzzo/twelve/Config.java
new file mode 100755
index 0000000000..13469026b6
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/Config.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve;
+
+/**
+ * App-wide constants.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public final class Config {
+
+    /**
+     * Used to distinguish album art from artist images
+     */
+    public static final String ALBUM_ART_SUFFIX = "album";
+    /**
+     * The ID of an artist, album, genre, or playlist passed to the profile
+     * activity
+     */
+    public static final String ID = "id";
+    /**
+     * The name of an artist, album, genre, or playlist passed to the profile
+     * activity
+     */
+    public static final String NAME = "name";
+    /**
+     * The name of an artist passed to the profile activity
+     */
+    public static final String ARTIST_NAME = "artist_name";
+    /**
+     * The year an album was released passed to the profile activity
+     */
+    public static final String ALBUM_YEAR = "album_year";
+    /**
+     * number of songs in a album or track list
+     */
+    public static final String SONG_COUNT = "song_count";
+    /**
+     * The MIME type passed to a the profile activity
+     */
+    public static final String MIME_TYPE = "mime_type";
+    /**
+     * Play from search intent
+     */
+    public static final String PLAY_FROM_SEARCH = "android.media.action.MEDIA_PLAY_FROM_SEARCH";
+    /**
+     * The smart playlist type
+     */
+    public static final String SMART_PLAYLIST_TYPE = "smart_playlist_type";
+    /**
+     * Number of search results to show at the top level search
+     */
+    public static final int SEARCH_NUM_RESULTS_TO_GET = 3;
+
+    /* This class is never initiated. */
+    public Config() {
+    }
+
+    public static enum SmartPlaylistType {
+        LastAdded(-1, R.string.playlist_last_added),
+        RecentlyPlayed(-2, R.string.playlist_recently_played),
+        TopTracks(-3, R.string.playlist_top_tracks);
+
+        public long mId;
+        public int mTitleId;
+
+        SmartPlaylistType(long id, int titleId) {
+            mId = id;
+            mTitleId = titleId;
+        }
+
+        public static SmartPlaylistType getTypeById(long id) {
+            for (SmartPlaylistType type : SmartPlaylistType.values()) {
+                if (type.mId == id) {
+                    return type;
+                }
+            }
+
+            return null;
+        }
+    }
+
+    /**
+     * This helps identify where an id has come from.  Mainly used to determine when a user
+     * clicks a song where that song came from (artist/album/playlist)
+     */
+    public static enum IdType {
+        NA(0),
+        Artist(1),
+        Album(2),
+        Playlist(3);
+
+        public final int mId;
+
+        IdType(final int id) {
+            mId = id;
+        }
+
+        public static IdType getTypeById(int id) {
+            for (IdType type : values()) {
+                if (type.mId == id) {
+                    return type;
+                }
+            }
+
+            throw new IllegalArgumentException("Unrecognized id: " + id);
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ElevenApplication.java b/twelve/src/main/java/com/dolzzo/twelve/ElevenApplication.java
new file mode 100755
index 0000000000..b4572c7b66
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ElevenApplication.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve;
+
+import android.app.Application;
+import android.os.StrictMode;
+
+import com.dolzzo.twelve.cache.ImageCache;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Used to turn off logging for jaudiotagger and free up memory when
+ * {@code #onLowMemory()} is called on pre-ICS devices. On post-ICS memory is
+ * released within {@link ImageCache}.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class ElevenApplication extends Application {
+    private static final boolean DEBUG = false;
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreate() {
+        // Enable strict mode logging
+        enableStrictMode();
+        // Turn off logging for jaudiotagger.
+        Logger.getLogger("org.jaudiotagger").setLevel(Level.OFF);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLowMemory() {
+        ImageCache.getInstance(this).evictAll();
+        super.onLowMemory();
+    }
+
+    private void enableStrictMode() {
+        if (DEBUG) {
+            final StrictMode.ThreadPolicy.Builder threadPolicyBuilder = new StrictMode.ThreadPolicy.Builder()
+                    .detectAll().penaltyLog();
+            final StrictMode.VmPolicy.Builder vmPolicyBuilder = new StrictMode.VmPolicy.Builder()
+                    .detectAll().penaltyLog();
+
+            threadPolicyBuilder.penaltyFlashScreen();
+            StrictMode.setThreadPolicy(threadPolicyBuilder.build());
+            StrictMode.setVmPolicy(vmPolicyBuilder.build());
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/MediaButtonIntentReceiver.java b/twelve/src/main/java/com/dolzzo/twelve/MediaButtonIntentReceiver.java
new file mode 100755
index 0000000000..ad221f3a0c
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/MediaButtonIntentReceiver.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project Licensed under the Apache
+ * License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve;
+
+import android.content.Context;
+import android.content.Intent;
+import android.media.AudioManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import android.support.v4.content.WakefulBroadcastReceiver;
+import android.util.Log;
+import android.view.KeyEvent;
+
+import com.dolzzo.twelve.ui.activities.HomeActivity;
+
+/**
+ * Used to control headset playback.
+ * Single press: pause/resume
+ * Double press: next track
+ * Triple press: previous track
+ * Long press: voice search
+ */
+public class MediaButtonIntentReceiver extends WakefulBroadcastReceiver {
+    private static final boolean DEBUG = false;
+    private static final String TAG = "MediaButtonIntentReceiver";
+
+    private static final int MSG_LONGPRESS_TIMEOUT = 1;
+    private static final int MSG_HEADSET_DOUBLE_CLICK_TIMEOUT = 2;
+
+    private static final int LONG_PRESS_DELAY = 1000;
+    private static final int DOUBLE_CLICK = 800;
+
+    private static WakeLock mWakeLock = null;
+    private static int mClickCounter = 0;
+    private static long mLastClickTime = 0;
+    private static boolean mDown = false;
+    private static boolean mLaunched = false;
+
+    private static Handler mHandler = new Handler() {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void handleMessage(final Message msg) {
+            switch (msg.what) {
+                case MSG_LONGPRESS_TIMEOUT:
+                    if (DEBUG) Log.v(TAG, "Handling longpress timeout, launched " + mLaunched);
+                    if (!mLaunched) {
+                        final Context context = (Context) msg.obj;
+                        final Intent i = new Intent();
+                        i.setClass(context, HomeActivity.class);
+                        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+                        context.startActivity(i);
+                        mLaunched = true;
+                    }
+                    break;
+
+                case MSG_HEADSET_DOUBLE_CLICK_TIMEOUT:
+                    final int clickCount = msg.arg1;
+                    final String command;
+
+                    if (DEBUG) Log.v(TAG, "Handling headset click, count = " + clickCount);
+                    switch (clickCount) {
+                        case 1:
+                            command = MusicPlaybackService.CMDTOGGLEPAUSE;
+                            break;
+                        case 2:
+                            command = MusicPlaybackService.CMDNEXT;
+                            break;
+                        case 3:
+                            command = MusicPlaybackService.CMDPREVIOUS;
+                            break;
+                        default:
+                            command = null;
+                            break;
+                    }
+
+                    if (command != null) {
+                        final Context context = (Context) msg.obj;
+                        startService(context, command);
+                    }
+                    break;
+            }
+            releaseWakeLockIfHandlerIdle();
+        }
+    };
+
+    private static void startService(Context context, String command) {
+        final Intent i = new Intent(context, MusicPlaybackService.class);
+        i.setAction(MusicPlaybackService.SERVICECMD);
+        i.putExtra(MusicPlaybackService.CMDNAME, command);
+        i.putExtra(MusicPlaybackService.FROM_MEDIA_BUTTON, true);
+        startWakefulService(context, i);
+    }
+
+    private static void acquireWakeLockAndSendMessage(Context context, Message msg, long delay) {
+        if (mWakeLock == null) {
+            Context appContext = context.getApplicationContext();
+            PowerManager pm = (PowerManager) appContext.getSystemService(Context.POWER_SERVICE);
+            mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Eleven headset button");
+            mWakeLock.setReferenceCounted(false);
+        }
+        if (DEBUG) Log.v(TAG, "Acquiring wake lock and sending " + msg.what);
+        // Make sure we don't indefinitely hold the wake lock under any circumstances
+        mWakeLock.acquire(10000);
+
+        mHandler.sendMessageDelayed(msg, delay);
+    }
+
+    private static void releaseWakeLockIfHandlerIdle() {
+        if (mHandler.hasMessages(MSG_LONGPRESS_TIMEOUT)
+                || mHandler.hasMessages(MSG_HEADSET_DOUBLE_CLICK_TIMEOUT)) {
+            if (DEBUG) Log.v(TAG, "Handler still has messages pending, not releasing wake lock");
+            return;
+        }
+
+        if (mWakeLock != null) {
+            if (DEBUG) Log.v(TAG, "Releasing wake lock");
+            mWakeLock.release();
+            mWakeLock = null;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onReceive(final Context context, final Intent intent) {
+        if (DEBUG) Log.v(TAG, "Received intent: " + intent);
+        final String intentAction = intent.getAction();
+        if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intentAction)) {
+            startService(context, MusicPlaybackService.CMDPAUSE);
+        } else if (Intent.ACTION_MEDIA_BUTTON.equals(intentAction)) {
+            final KeyEvent event = intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
+            if (event == null) {
+                return;
+            }
+
+            final int keycode = event.getKeyCode();
+            final int action = event.getAction();
+            final long eventtime = event.getEventTime();
+
+            String command = null;
+            switch (keycode) {
+                case KeyEvent.KEYCODE_MEDIA_STOP:
+                    command = MusicPlaybackService.CMDSTOP;
+                    break;
+                case KeyEvent.KEYCODE_HEADSETHOOK:
+                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+                    command = MusicPlaybackService.CMDTOGGLEPAUSE;
+                    break;
+                case KeyEvent.KEYCODE_MEDIA_NEXT:
+                    command = MusicPlaybackService.CMDNEXT;
+                    break;
+                case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+                    command = MusicPlaybackService.CMDPREVIOUS;
+                    break;
+                case KeyEvent.KEYCODE_MEDIA_PAUSE:
+                    command = MusicPlaybackService.CMDPAUSE;
+                    break;
+                case KeyEvent.KEYCODE_MEDIA_PLAY:
+                    command = MusicPlaybackService.CMDPLAY;
+                    break;
+            }
+            if (command != null) {
+                if (action == KeyEvent.ACTION_DOWN) {
+                    if (mDown) {
+                        if (MusicPlaybackService.CMDTOGGLEPAUSE.equals(command)
+                                || MusicPlaybackService.CMDPLAY.equals(command)) {
+                            if (mLastClickTime != 0
+                                    && eventtime - mLastClickTime > LONG_PRESS_DELAY) {
+                                acquireWakeLockAndSendMessage(context,
+                                        mHandler.obtainMessage(MSG_LONGPRESS_TIMEOUT, context), 0);
+                            }
+                        }
+                    } else if (event.getRepeatCount() == 0) {
+                        // Only consider the first event in a sequence, not the repeat events,
+                        // so that we don't trigger in cases where the first event went to
+                        // a different app (e.g. when the user ends a phone call by
+                        // long pressing the headset button)
+
+                        // The service may or may not be running, but we need to send it
+                        // a command.
+                        if (keycode == KeyEvent.KEYCODE_HEADSETHOOK) {
+                            if (eventtime - mLastClickTime >= DOUBLE_CLICK) {
+                                mClickCounter = 0;
+                            }
+
+                            mClickCounter++;
+                            if (DEBUG) Log.v(TAG, "Got headset click, count = " + mClickCounter);
+                            mHandler.removeMessages(MSG_HEADSET_DOUBLE_CLICK_TIMEOUT);
+
+                            Message msg = mHandler.obtainMessage(
+                                    MSG_HEADSET_DOUBLE_CLICK_TIMEOUT, mClickCounter, 0, context);
+
+                            long delay = mClickCounter < 3 ? DOUBLE_CLICK : 0;
+                            if (mClickCounter >= 3) {
+                                mClickCounter = 0;
+                            }
+                            mLastClickTime = eventtime;
+                            acquireWakeLockAndSendMessage(context, msg, delay);
+                        } else {
+                            startService(context, command);
+                        }
+                        mLaunched = false;
+                        mDown = true;
+                    }
+                } else {
+                    mHandler.removeMessages(MSG_LONGPRESS_TIMEOUT);
+                    mDown = false;
+                }
+                if (isOrderedBroadcast()) {
+                    abortBroadcast();
+                }
+                releaseWakeLockIfHandlerIdle();
+            }
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/MusicPlaybackService.java b/twelve/src/main/java/com/dolzzo/twelve/MusicPlaybackService.java
new file mode 100755
index 0000000000..c9c84ebea8
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/MusicPlaybackService.java
@@ -0,0 +1,3657 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve;
+
+import android.annotation.SuppressLint;
+import android.app.AlarmManager;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.appwidget.AppWidgetManager;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.graphics.Bitmap;
+import android.hardware.SensorManager;
+import android.media.AudioManager;
+import android.media.AudioManager.OnAudioFocusChangeListener;
+import android.media.MediaPlayer;
+import android.media.audiofx.AudioEffect;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.SystemClock;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.AlbumColumns;
+import android.provider.MediaStore.Audio.AudioColumns;
+import android.support.v4.media.MediaMetadataCompat;
+import android.support.v4.media.session.MediaSessionCompat;
+import android.support.v4.media.session.PlaybackStateCompat;
+import android.support.v7.app.NotificationCompat;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.dolzzo.twelve.Config.IdType;
+import com.dolzzo.twelve.appwidgets.AppWidgetLarge;
+import com.dolzzo.twelve.appwidgets.AppWidgetLargeAlternate;
+import com.dolzzo.twelve.appwidgets.AppWidgetSmall;
+import com.dolzzo.twelve.cache.ImageCache;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.provider.MusicPlaybackState;
+import com.dolzzo.twelve.provider.RecentStore;
+import com.dolzzo.twelve.provider.SongPlayCount;
+import com.dolzzo.twelve.service.MusicPlaybackTrack;
+import com.dolzzo.twelve.utils.BitmapWithColors;
+import com.dolzzo.twelve.utils.Lists;
+import com.dolzzo.twelve.utils.ShakeDetector;
+import com.dolzzo.twelve.utils.SrtManager;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.DefaultLoadControl;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.ExoPlayerFactory;
+import com.google.android.exoplayer2.LoadControl;
+import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
+import com.google.android.exoplayer2.extractor.ExtractorsFactory;
+import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.util.Util;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.ListIterator;
+import java.util.Random;
+import java.util.TreeSet;
+
+/**
+ * A backbround {@link Service} used to keep music playing between activities
+ * and when the user moves Apollo into the background.
+ */
+@SuppressLint("NewApi")
+public class MusicPlaybackService extends Service {
+    /**
+     * Indicates that the music has paused or resumed
+     */
+    public static final String PLAYSTATE_CHANGED = "com.dolzzo.twelve.playstatechanged";
+    /**
+     * Indicates that music playback position within
+     * a title was changed
+     */
+    public static final String POSITION_CHANGED = "com.dolzzo.twelve.positionchanged";
+    /**
+     * Indicates the meta data has changed in some way, like a track change
+     */
+    public static final String META_CHANGED = "com.dolzzo.twelve.metachanged";
+    /**
+     * Indicates the queue has been updated
+     */
+    public static final String QUEUE_CHANGED = "com.dolzzo.twelve.queuechanged";
+    /**
+     * Indicates the queue has been updated
+     */
+    public static final String PLAYLIST_CHANGED = "com.dolzzo.twelve.playlistchanged";
+    /**
+     * Indicates the repeat mode changed
+     */
+    public static final String REPEATMODE_CHANGED = "com.dolzzo.twelve.repeatmodechanged";
+    /**
+     * Indicates the shuffle mode changed
+     */
+    public static final String SHUFFLEMODE_CHANGED = "com.dolzzo.twelve.shufflemodechanged";
+    /**
+     * Indicates the track fails to play
+     */
+    public static final String TRACK_ERROR = "com.dolzzo.twelve.trackerror";
+    /**
+     * For backwards compatibility reasons, also provide sticky
+     * broadcasts under the music package
+     */
+    public static final String ELEVEN_PACKAGE_NAME = "com.dolzzo.twelve";
+    public static final String MUSIC_PACKAGE_NAME = "com.android.music";
+    /**
+     * Called to indicate a general service commmand. Used in
+     * {@link MediaButtonIntentReceiver}
+     */
+    public static final String SERVICECMD = "com.dolzzo.twelve.musicservicecommand";
+    /**
+     * Called to go toggle between pausing and playing the music
+     */
+    public static final String TOGGLEPAUSE_ACTION = "com.dolzzo.twelve.togglepause";
+    /**
+     * Called to go to pause the playback
+     */
+    public static final String PAUSE_ACTION = "com.dolzzo.twelve.pause";
+    /**
+     * Called to go to stop the playback
+     */
+    public static final String STOP_ACTION = "com.dolzzo.twelve.stop";
+    /**
+     * Called to go to the previous track or the beginning of the track if partway through the track
+     */
+    public static final String PREVIOUS_ACTION = "com.dolzzo.twelve.previous";
+    /**
+     * Called to go to the previous track regardless of how far in the current track the playback is
+     */
+    public static final String PREVIOUS_FORCE_ACTION = "com.dolzzo.twelve.previous.force";
+    /**
+     * Called to go to the next track
+     */
+    public static final String NEXT_ACTION = "com.dolzzo.twelve.next";
+    /**
+     * Called to change the repeat mode
+     */
+    public static final String REPEAT_ACTION = "com.dolzzo.twelve.repeat";
+    /**
+     * Called to change the shuffle mode
+     */
+    public static final String SHUFFLE_ACTION = "com.dolzzo.twelve.shuffle";
+    public static final String FROM_MEDIA_BUTTON = "frommediabutton";
+    /**
+     * Used to easily notify a list that it should refresh. i.e. A playlist
+     * changes
+     */
+    public static final String REFRESH = "com.dolzzo.twelve.refresh";
+    /**
+     * Called to notify of a timed text
+     */
+    public static final String NEW_LYRICS = "com.dolzzo.twelve.lyrics";
+    /**
+     * Called to update the remote control client
+     */
+    public static final String UPDATE_LOCKSCREEN = "com.dolzzo.twelve.updatelockscreen";
+    public static final String CMDNAME = "command";
+    public static final String CMDTOGGLEPAUSE = "togglepause";
+    public static final String CMDSTOP = "stop";
+    public static final String CMDPAUSE = "pause";
+    public static final String CMDPLAY = "play";
+    public static final String CMDPREVIOUS = "previous";
+    public static final String CMDNEXT = "next";
+    public static final String CMDNOTIF = "buttonId";
+    /**
+     * Moves a list to the next position in the queue
+     */
+    public static final int NEXT = 2;
+    /**
+     * Moves a list to the last position in the queue
+     */
+    public static final int LAST = 3;
+    /**
+     * Shuffles no songs, turns shuffling off
+     */
+    public static final int SHUFFLE_NONE = 0;
+    /**
+     * Shuffles all songs
+     */
+    public static final int SHUFFLE_NORMAL = 1;
+    /**
+     * Party shuffle
+     */
+    public static final int SHUFFLE_AUTO = 2;
+    /**
+     * Turns repeat off
+     */
+    public static final int REPEAT_NONE = 0;
+    /**
+     * Repeats the current track in a list
+     */
+    public static final int REPEAT_CURRENT = 1;
+    /**
+     * Repeats all the tracks in a list
+     */
+    public static final int REPEAT_ALL = 2;
+    /**
+     * The max size allowed for the track history
+     * TODO: Comeback and rewrite/fix all the whole queue code bugs after demo
+     * https://cyanogen.atlassian.net/browse/MUSIC-175
+     * https://cyanogen.atlassian.net/browse/MUSIC-44
+     */
+    public static final int MAX_HISTORY_SIZE = 1000;
+    private static final String TAG = "MusicPlaybackService";
+    private static final boolean D = false;
+    /**
+     * Used by the alarm intent to shutdown the service after being idle
+     */
+    private static final String SHUTDOWN = "com.dolzzo.twelve.shutdown";
+    private static final int IDCOLIDX = 0;
+    /**
+     * Indicates when the track ends
+     */
+    private static final int TRACK_ENDED = 1;
+    /**
+     * Indicates that the current track was changed the next track
+     */
+    private static final int TRACK_WENT_TO_NEXT = 2;
+    /**
+     * Indicates the player died
+     */
+    private static final int SERVER_DIED = 3;
+    /**
+     * Indicates some sort of focus change, maybe a phone call
+     */
+    private static final int FOCUSCHANGE = 4;
+    /**
+     * Indicates to fade the volume down
+     */
+    private static final int FADEDOWN = 5;
+    /**
+     * Indicates to fade the volume back up
+     */
+    private static final int FADEUP = 6;
+    /**
+     * Notifies that there is a new timed text string
+     */
+    private static final int LYRICS = 7;
+    /**
+     * Idle time before stopping the foreground notfication (5 minutes)
+     */
+    private static final int IDLE_DELAY = 5 * 60 * 1000;
+    /**
+     * Song play time used as threshold for rewinding to the beginning of the
+     * track instead of skipping to the previous track when getting the PREVIOUS
+     * command
+     */
+    private static final long REWIND_INSTEAD_PREVIOUS_THRESHOLD = 3000;
+    /**
+     * The columns used to retrieve any info from the current track
+     */
+    private static final String[] PROJECTION = new String[]{
+            "audio._id AS _id", MediaStore.Audio.Media.ARTIST, MediaStore.Audio.Media.ALBUM,
+            MediaStore.Audio.Media.TITLE, MediaStore.Audio.Media.DATA,
+            MediaStore.Audio.Media.MIME_TYPE, MediaStore.Audio.Media.ALBUM_ID,
+            MediaStore.Audio.Media.ARTIST_ID
+    };
+    /**
+     * The columns used to retrieve any info from the current album
+     */
+    private static final String[] ALBUM_PROJECTION = new String[]{
+            MediaStore.Audio.Albums.ALBUM, MediaStore.Audio.Albums.ARTIST,
+            MediaStore.Audio.Albums.LAST_YEAR
+    };
+    /**
+     * Used to shuffle the tracks
+     */
+    private static final Shuffler mShuffler = new Shuffler();
+    private static final int NOTIFY_MODE_NONE = 0;
+    private static final int NOTIFY_MODE_FOREGROUND = 1;
+    private static final int NOTIFY_MODE_BACKGROUND = 2;
+    /*
+        Columns for a pseudo cursor we are creating for downloaded songs
+        Modeled after mCursor to be able to respond to respond to the same queries as it
+     */
+    private static final String[] PROJECTION_MATRIX = new String[]{
+            "_id", MediaStore.Audio.Media.ARTIST, MediaStore.Audio.Media.ALBUM,
+            MediaStore.Audio.Media.TITLE, MediaStore.Audio.Media.DATA,
+            MediaStore.Audio.Media.MIME_TYPE, MediaStore.Audio.Media.ALBUM_ID,
+            MediaStore.Audio.Media.ARTIST_ID
+    };
+    /**
+     * Keeps a mapping of the track history
+     */
+    private static LinkedList<Integer> mHistory = Lists.newLinkedList();
+    /**
+     * Service stub
+     */
+    private final IBinder mBinder = new ServiceStub(this);
+    /**
+     * 4x1 widget
+     */
+    private final AppWidgetSmall mAppWidgetSmall = AppWidgetSmall.getInstance();
+    /**
+     * 4x2 widget
+     */
+    private final AppWidgetLarge mAppWidgetLarge = AppWidgetLarge.getInstance();
+    /**
+     * 4x2 alternate widget
+     */
+    private final AppWidgetLargeAlternate mAppWidgetLargeAlternate = AppWidgetLargeAlternate
+            .getInstance();
+    /**
+     * The media player
+     */
+    private MultiPlayer2 mPlayer;
+    /**
+     * The path of the current file to play
+     */
+    private String mFileToPlay;
+    /**
+     * Alarm intent for removing the notification when nothing is playing
+     * for some time
+     */
+    private AlarmManager mAlarmManager;
+    private PendingIntent mShutdownIntent;
+    private boolean mShutdownScheduled;
+    private NotificationManager mNotificationManager;
+    /**
+     * The cursor used to retrieve info on the current track and run the
+     * necessary queries to play audio files
+     */
+    private Cursor mCursor;
+    /**
+     * The cursor used to retrieve info on the album the current track is
+     * part of, if any.
+     */
+    private Cursor mAlbumCursor;
+    /**
+     * Monitors the audio state
+     */
+    private AudioManager mAudioManager;
+    /**
+     * Settings used to save and retrieve the queue and history
+     */
+    private SharedPreferences mPreferences;
+    /**
+     * Used to know when the service is active
+     */
+    private boolean mServiceInUse = false;
+    /**
+     * Used to know if something should be playing or not
+     */
+    private boolean mIsSupposedToBePlaying = false;
+    /**
+     * Gets the last played time to determine whether we still want notifications or not
+     */
+    private long mLastPlayedTime;
+    private int mNotifyMode = NOTIFY_MODE_NONE;
+    private long mNotificationPostTime = 0;
+    /**
+     * Used to indicate if the queue can be saved
+     */
+    private boolean mQueueIsSaveable = true;
+
+    /**
+     * Used to track what type of audio focus loss caused the playback to pause
+     */
+    private boolean mPausedByTransientLossOfFocus = false;
+
+    /**
+     * Lock screen controls
+     */
+    private MediaSessionCompat mSession;
+
+    private ComponentName mMediaButtonReceiverComponent;
+
+    // We use this to distinguish between different cards when saving/restoring
+    // playlists
+    private int mCardId;
+
+    private int mPlayPos = -1;
+
+    private int mNextPlayPos = -1;
+
+    private int mOpenFailedCounter = 0;
+
+    private int mMediaMountedCount = 0;
+
+    private int mShuffleMode = SHUFFLE_NONE;
+
+    private int mRepeatMode = REPEAT_NONE;
+
+    private int mServiceStartId = -1;
+
+    private String mLyrics;
+
+    private ArrayList<MusicPlaybackTrack> mPlaylist = new ArrayList<MusicPlaybackTrack>(100);
+
+    private long[] mAutoShuffleList = null;
+
+    private MusicPlayerHandler mPlayerHandler;
+    private final OnAudioFocusChangeListener mAudioFocusListener = new OnAudioFocusChangeListener() {
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onAudioFocusChange(final int focusChange) {
+            mPlayerHandler.obtainMessage(FOCUSCHANGE, focusChange, 0).sendToTarget();
+        }
+    };
+    private HandlerThread mHandlerThread;
+    private BroadcastReceiver mUnmountReceiver = null;
+    // to improve perf, instead of hitting the disk cache or file cache, store the bitmaps in memory
+    private String mCachedKey;
+    private BitmapWithColors[] mCachedBitmapWithColors = new BitmapWithColors[2];
+    /**
+     * Image cache
+     */
+    private ImageFetcher mImageFetcher;
+    /**
+     * Recently listened database
+     */
+    private RecentStore mRecentsCache;
+    /**
+     * The song play count database
+     */
+    private SongPlayCount mSongPlayCountCache;
+    /**
+     * Stores the playback state
+     */
+    private MusicPlaybackState mPlaybackStateStore;
+    /**
+     * Shake detector class used for shake to switch song feature
+     */
+    private ShakeDetector mShakeDetector;
+    private final BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            final String command = intent.getStringExtra(CMDNAME);
+
+            if (AppWidgetSmall.CMDAPPWIDGETUPDATE.equals(command)) {
+                final int[] small = intent.getIntArrayExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS);
+                mAppWidgetSmall.performUpdate(MusicPlaybackService.this, small);
+            } else if (AppWidgetLarge.CMDAPPWIDGETUPDATE.equals(command)) {
+                final int[] large = intent.getIntArrayExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS);
+                mAppWidgetLarge.performUpdate(MusicPlaybackService.this, large);
+            } else if (AppWidgetLargeAlternate.CMDAPPWIDGETUPDATE.equals(command)) {
+                final int[] largeAlt = intent
+                        .getIntArrayExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS);
+                mAppWidgetLargeAlternate.performUpdate(MusicPlaybackService.this, largeAlt);
+            } else {
+                handleCommandIntent(intent);
+            }
+        }
+    };
+    /**
+     * Switch for displaying album art on lockscreen
+     */
+    private boolean mShowAlbumArtOnLockscreen;
+    private ShakeDetector.Listener mShakeDetectorListener = new ShakeDetector.Listener() {
+
+        @Override
+        public void hearShake() {
+            /*
+             * on shake detect, play next song
+             */
+            if (D) {
+                Log.d(TAG, "Shake detected!!!");
+            }
+            gotoNext(true);
+        }
+    };
+    private ContentObserver mMediaStoreObserver;
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public IBinder onBind(final Intent intent) {
+        if (D) Log.d(TAG, "Service bound, intent = " + intent);
+        cancelShutdown();
+        mServiceInUse = true;
+        return mBinder;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onUnbind(final Intent intent) {
+        if (D) Log.d(TAG, "Service unbound");
+        mServiceInUse = false;
+        saveQueue(true);
+
+        if (mIsSupposedToBePlaying || mPausedByTransientLossOfFocus) {
+            // Something is currently playing, or will be playing once
+            // an in-progress action requesting audio focus ends, so don't stop
+            // the service now.
+            return true;
+
+            // If there is a playlist but playback is paused, then wait a while
+            // before stopping the service, so that pause/resume isn't slow.
+            // Also delay stopping the service if we're transitioning between
+            // tracks.
+        } else if (mPlaylist.size() > 0 || mPlayerHandler.hasMessages(TRACK_ENDED)) {
+            scheduleDelayedShutdown();
+            return true;
+        }
+        stopSelf(mServiceStartId);
+
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onRebind(final Intent intent) {
+        cancelShutdown();
+        mServiceInUse = true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreate() {
+        if (D) Log.d(TAG, "Creating service");
+        super.onCreate();
+
+        mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
+
+        // Initialize the favorites and recents databases
+        mRecentsCache = RecentStore.getInstance(this);
+
+        // gets the song play count cache
+        mSongPlayCountCache = SongPlayCount.getInstance(this);
+
+        // gets a pointer to the playback state store
+        mPlaybackStateStore = MusicPlaybackState.getInstance(this);
+
+        // Initialize the image fetcher
+        mImageFetcher = ImageFetcher.getInstance(this);
+        // Initialize the image cache
+        mImageFetcher.setImageCache(ImageCache.getInstance(this));
+
+        // Start up the thread running the service. Note that we create a
+        // separate thread because the service normally runs in the process's
+        // main thread, which we don't want to block. We also make it
+        // background priority so CPU-intensive work will not disrupt the UI.
+        mHandlerThread = new HandlerThread("MusicPlayerHandler",
+                android.os.Process.THREAD_PRIORITY_BACKGROUND);
+        mHandlerThread.start();
+
+        // Initialize the handler
+        mPlayerHandler = new MusicPlayerHandler(this, mHandlerThread.getLooper());
+
+        // Initialize the audio manager and register any headset controls for
+        // playback
+        mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
+        mMediaButtonReceiverComponent = new ComponentName(getPackageName(),
+                MediaButtonIntentReceiver.class.getName());
+        mAudioManager.registerMediaButtonEventReceiver(mMediaButtonReceiverComponent);
+
+        // Use the remote control APIs to set the playback state
+        setUpMediaSession();
+
+        // Initialize the preferences
+        mPreferences = getSharedPreferences("Service", 0);
+        mCardId = getCardId();
+
+        registerExternalStorageListener();
+
+        // Initialize the media player
+        mPlayer = new MultiPlayer2(this);
+        mPlayer.setHandler(mPlayerHandler);
+
+        // Initialize the intent filter and each action
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(SERVICECMD);
+        filter.addAction(TOGGLEPAUSE_ACTION);
+        filter.addAction(PAUSE_ACTION);
+        filter.addAction(STOP_ACTION);
+        filter.addAction(NEXT_ACTION);
+        filter.addAction(PREVIOUS_ACTION);
+        filter.addAction(PREVIOUS_FORCE_ACTION);
+        filter.addAction(REPEAT_ACTION);
+        filter.addAction(SHUFFLE_ACTION);
+        // Attach the broadcast listener
+        registerReceiver(mIntentReceiver, filter);
+
+        // Get events when MediaStore content changes
+        mMediaStoreObserver = new MediaStoreObserver(mPlayerHandler);
+        getContentResolver().registerContentObserver(
+                MediaStore.Audio.Media.INTERNAL_CONTENT_URI, true, mMediaStoreObserver);
+        getContentResolver().registerContentObserver(
+                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, true, mMediaStoreObserver);
+
+        // Initialize the delayed shutdown intent
+        final Intent shutdownIntent = new Intent(this, MusicPlaybackService.class);
+        shutdownIntent.setAction(SHUTDOWN);
+
+        mAlarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
+        mShutdownIntent = PendingIntent.getService(this, 0, shutdownIntent, 0);
+
+        // Listen for the idle state
+        scheduleDelayedShutdown();
+
+        // Bring the queue back
+        reloadQueue();
+        notifyChange(QUEUE_CHANGED);
+        notifyChange(META_CHANGED);
+    }
+
+    private void setUpMediaSession() {
+        mSession = new MediaSessionCompat(this, "Eleven");
+        mSession.setCallback(new MediaSessionCompat.Callback() {
+            @Override
+            public void onPause() {
+                pause();
+                mPausedByTransientLossOfFocus = false;
+            }
+
+            @Override
+            public void onPlay() {
+                play();
+            }
+
+            @Override
+            public void onSeekTo(long pos) {
+                seek(pos);
+            }
+
+            @Override
+            public void onSkipToNext() {
+                gotoNext(true);
+            }
+
+            @Override
+            public void onSkipToPrevious() {
+                prev(false);
+            }
+
+            @Override
+            public void onStop() {
+                pause();
+                mPausedByTransientLossOfFocus = false;
+                seek(0);
+                releaseServiceUiAndStop();
+            }
+        });
+        mSession.setFlags(MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS);
+        mSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onDestroy() {
+        if (D) Log.d(TAG, "Destroying service");
+        super.onDestroy();
+        // Remove any sound effects
+        final Intent audioEffectsIntent = new Intent(
+                AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION);
+        audioEffectsIntent.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());
+        audioEffectsIntent.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());
+        sendBroadcast(audioEffectsIntent);
+
+        // remove any pending alarms
+        mAlarmManager.cancel(mShutdownIntent);
+
+        // Remove any callbacks from the handler
+        mPlayerHandler.removeCallbacksAndMessages(null);
+        // quit the thread so that anything that gets posted won't run
+        mHandlerThread.quitSafely();
+
+        // Release the player
+        mPlayer.release();
+        mPlayer = null;
+
+        // Remove the audio focus listener and lock screen controls
+        mAudioManager.abandonAudioFocus(mAudioFocusListener);
+        mSession.release();
+
+        // remove the media store observer
+        getContentResolver().unregisterContentObserver(mMediaStoreObserver);
+
+        // Close the cursor
+        closeCursor();
+
+        // Unregister the mount listener
+        unregisterReceiver(mIntentReceiver);
+        if (mUnmountReceiver != null) {
+            unregisterReceiver(mUnmountReceiver);
+            mUnmountReceiver = null;
+        }
+
+        // deinitialize shake detector
+        stopShakeDetector(true);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int onStartCommand(final Intent intent, final int flags, final int startId) {
+        if (D) Log.d(TAG, "Got new intent " + intent + ", startId = " + startId);
+        mServiceStartId = startId;
+
+        if (intent != null) {
+            final String action = intent.getAction();
+
+            if (SHUTDOWN.equals(action)) {
+                mShutdownScheduled = false;
+                releaseServiceUiAndStop();
+                return START_NOT_STICKY;
+            }
+
+            handleCommandIntent(intent);
+        }
+
+        // Make sure the service will shut down on its own if it was
+        // just started but not bound to and nothing is playing
+        scheduleDelayedShutdown();
+
+        if (intent != null && intent.getBooleanExtra(FROM_MEDIA_BUTTON, false)) {
+            MediaButtonIntentReceiver.completeWakefulIntent(intent);
+        }
+
+        return START_STICKY;
+    }
+
+    private void releaseServiceUiAndStop() {
+        if (isPlaying()
+                || mPausedByTransientLossOfFocus
+                || mPlayerHandler.hasMessages(TRACK_ENDED)) {
+            return;
+        }
+
+        if (D) Log.d(TAG, "Nothing is playing anymore, releasing notification");
+        cancelNotification();
+        mAudioManager.abandonAudioFocus(mAudioFocusListener);
+        mSession.setActive(false);
+
+        if (!mServiceInUse) {
+            saveQueue(true);
+            stopSelf(mServiceStartId);
+        }
+    }
+
+    private void handleCommandIntent(Intent intent) {
+        final String action = intent.getAction();
+        final String command = SERVICECMD.equals(action) ? intent.getStringExtra(CMDNAME) : null;
+
+        if (D) Log.d(TAG, "handleCommandIntent: action = " + action + ", command = " + command);
+
+        if (CMDNEXT.equals(command) || NEXT_ACTION.equals(action)) {
+            gotoNext(true);
+        } else if (CMDPREVIOUS.equals(command) || PREVIOUS_ACTION.equals(action)
+                || PREVIOUS_FORCE_ACTION.equals(action)) {
+            prev(PREVIOUS_FORCE_ACTION.equals(action));
+        } else if (CMDTOGGLEPAUSE.equals(command) || TOGGLEPAUSE_ACTION.equals(action)) {
+            if (isPlaying()) {
+                pause();
+                mPausedByTransientLossOfFocus = false;
+            } else {
+                play();
+            }
+        } else if (CMDPAUSE.equals(command) || PAUSE_ACTION.equals(action)) {
+            pause();
+            mPausedByTransientLossOfFocus = false;
+        } else if (CMDPLAY.equals(command)) {
+            play();
+        } else if (CMDSTOP.equals(command) || STOP_ACTION.equals(action)) {
+            pause();
+            mPausedByTransientLossOfFocus = false;
+            seek(0);
+            releaseServiceUiAndStop();
+        } else if (REPEAT_ACTION.equals(action)) {
+            cycleRepeat();
+        } else if (SHUFFLE_ACTION.equals(action)) {
+            cycleShuffle();
+        }
+    }
+
+    /**
+     * Updates the notification, considering the current play and activity state
+     */
+    private void updateNotification() {
+        final int newNotifyMode;
+        if (isPlaying()) {
+            newNotifyMode = NOTIFY_MODE_FOREGROUND;
+        } else if (recentlyPlayed()) {
+            newNotifyMode = NOTIFY_MODE_BACKGROUND;
+        } else {
+            newNotifyMode = NOTIFY_MODE_NONE;
+        }
+
+        int notificationId = hashCode();
+        if (mNotifyMode != newNotifyMode) {
+            if (mNotifyMode == NOTIFY_MODE_FOREGROUND) {
+                stopForeground(newNotifyMode == NOTIFY_MODE_NONE);
+            } else if (newNotifyMode == NOTIFY_MODE_NONE) {
+                mNotificationManager.cancel(notificationId);
+                mNotificationPostTime = 0;
+            }
+        }
+
+        if (newNotifyMode == NOTIFY_MODE_FOREGROUND) {
+            startForeground(notificationId, buildNotification());
+        } else if (newNotifyMode == NOTIFY_MODE_BACKGROUND) {
+            mNotificationManager.notify(notificationId, buildNotification());
+        }
+
+        mNotifyMode = newNotifyMode;
+    }
+
+    private void cancelNotification() {
+        stopForeground(true);
+        mNotificationManager.cancel(hashCode());
+        mNotificationPostTime = 0;
+        mNotifyMode = NOTIFY_MODE_NONE;
+    }
+
+    /**
+     * @return A card ID used to save and restore playlists, i.e., the queue.
+     */
+    private int getCardId() {
+        final ContentResolver resolver = getContentResolver();
+        Cursor cursor = resolver.query(Uri.parse("content://media/external/fs_id"), null, null,
+                null, null);
+        int mCardId = -1;
+        if (cursor != null && cursor.moveToFirst()) {
+            mCardId = cursor.getInt(0);
+            cursor.close();
+            cursor = null;
+        }
+        return mCardId;
+    }
+
+    /**
+     * Called when we receive a ACTION_MEDIA_EJECT notification.
+     *
+     * @param storagePath The path to mount point for the removed media
+     */
+    public void closeExternalStorageFiles(final String storagePath) {
+        stop(true);
+        notifyChange(QUEUE_CHANGED);
+        notifyChange(META_CHANGED);
+    }
+
+    /**
+     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications. The
+     * intent will call closeExternalStorageFiles() if the external media is
+     * going to be ejected, so applications can clean up any files they have
+     * open.
+     */
+    public void registerExternalStorageListener() {
+        if (mUnmountReceiver == null) {
+            mUnmountReceiver = new BroadcastReceiver() {
+
+                /**
+                 * {@inheritDoc}
+                 */
+                @Override
+                public void onReceive(final Context context, final Intent intent) {
+                    final String action = intent.getAction();
+                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {
+                        saveQueue(true);
+                        mQueueIsSaveable = false;
+                        closeExternalStorageFiles(intent.getData().getPath());
+                    } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
+                        mMediaMountedCount++;
+                        mCardId = getCardId();
+                        reloadQueue();
+                        mQueueIsSaveable = true;
+                        notifyChange(QUEUE_CHANGED);
+                        notifyChange(META_CHANGED);
+                    }
+                }
+            };
+            final IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_MEDIA_EJECT);
+            filter.addAction(Intent.ACTION_MEDIA_MOUNTED);
+            filter.addDataScheme("file");
+            registerReceiver(mUnmountReceiver, filter);
+        }
+    }
+
+    private void scheduleDelayedShutdown() {
+        if (D) Log.v(TAG, "Scheduling shutdown in " + IDLE_DELAY + " ms");
+        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                SystemClock.elapsedRealtime() + IDLE_DELAY, mShutdownIntent);
+        mShutdownScheduled = true;
+    }
+
+    private void cancelShutdown() {
+        if (D) Log.d(TAG, "Cancelling delayed shutdown, scheduled = " + mShutdownScheduled);
+        if (mShutdownScheduled) {
+            mAlarmManager.cancel(mShutdownIntent);
+            mShutdownScheduled = false;
+        }
+    }
+
+    /**
+     * Stops playback
+     *
+     * @param goToIdle True to go to the idle state, false otherwise
+     */
+    private void stop(final boolean goToIdle) {
+        if (D) Log.d(TAG, "Stopping playback, goToIdle = " + goToIdle);
+        if (mPlayer.isInitialized()) {
+            mPlayer.stop();
+        }
+        mFileToPlay = null;
+        closeCursor();
+        if (goToIdle) {
+            setIsSupposedToBePlaying(false, false);
+        } else {
+            stopForeground(false);
+        }
+    }
+
+    /**
+     * Removes the range of tracks specified from the play list. If a file
+     * within the range is the file currently being played, playback will move
+     * to the next file after the range.
+     *
+     * @param first The first file to be removed
+     * @param last  The last file to be removed
+     * @return the number of tracks deleted
+     */
+    private int removeTracksInternal(int first, int last) {
+        synchronized (this) {
+            if (last < first) {
+                return 0;
+            } else if (first < 0) {
+                first = 0;
+            } else if (last >= mPlaylist.size()) {
+                last = mPlaylist.size() - 1;
+            }
+
+            boolean gotonext = false;
+            if (first <= mPlayPos && mPlayPos <= last) {
+                mPlayPos = first;
+                gotonext = true;
+            } else if (mPlayPos > last) {
+                mPlayPos -= last - first + 1;
+            }
+            final int numToRemove = last - first + 1;
+
+            if (first == 0 && last == mPlaylist.size() - 1) {
+                mPlayPos = -1;
+                mNextPlayPos = -1;
+                mPlaylist.clear();
+                mHistory.clear();
+            } else {
+                for (int i = 0; i < numToRemove; i++) {
+                    mPlaylist.remove(first);
+                }
+
+                // remove the items from the history
+                // this is not ideal as the history shouldn't be impacted by this
+                // but since we are removing items from the array, it will throw
+                // an exception if we keep it around.  Idealistically with the queue
+                // rewrite this should be all be fixed
+                // https://cyanogen.atlassian.net/browse/MUSIC-44
+                ListIterator<Integer> positionIterator = mHistory.listIterator();
+                while (positionIterator.hasNext()) {
+                    int pos = positionIterator.next();
+                    if (pos >= first && pos <= last) {
+                        positionIterator.remove();
+                    } else if (pos > last) {
+                        positionIterator.set(pos - numToRemove);
+                    }
+                }
+            }
+            if (gotonext) {
+                if (mPlaylist.size() == 0) {
+                    stop(true);
+                    mPlayPos = -1;
+                    closeCursor();
+                } else {
+                    if (mShuffleMode != SHUFFLE_NONE) {
+                        mPlayPos = getNextPosition(true);
+                    } else if (mPlayPos >= mPlaylist.size()) {
+                        mPlayPos = 0;
+                    }
+                    final boolean wasPlaying = isPlaying();
+                    stop(false);
+                    openCurrentAndNext();
+                    if (wasPlaying) {
+                        play();
+                    }
+                }
+                notifyChange(META_CHANGED);
+            }
+            return last - first + 1;
+        }
+    }
+
+    /**
+     * Adds a list to the playlist
+     *
+     * @param list     The list to add
+     * @param position The position to place the tracks
+     */
+    private void addToPlayList(final long[] list, int position, long sourceId, IdType sourceType) {
+        final int addlen = list.length;
+        if (position < 0) {
+            mPlaylist.clear();
+            position = 0;
+        }
+
+        mPlaylist.ensureCapacity(mPlaylist.size() + addlen);
+        if (position > mPlaylist.size()) {
+            position = mPlaylist.size();
+        }
+
+        final ArrayList<MusicPlaybackTrack> arrayList = new ArrayList<MusicPlaybackTrack>(addlen);
+        for (int i = 0; i < list.length; i++) {
+            arrayList.add(new MusicPlaybackTrack(list[i], sourceId, sourceType, i));
+        }
+
+        mPlaylist.addAll(position, arrayList);
+
+        if (mPlaylist.size() == 0) {
+            closeCursor();
+            notifyChange(META_CHANGED);
+        }
+    }
+
+    /**
+     * @param trackId The track ID
+     */
+    private void updateCursor(final long trackId) {
+        updateCursor("_id=" + trackId, null);
+    }
+
+    private void updateCursor(final String selection, final String[] selectionArgs) {
+        synchronized (this) {
+            closeCursor();
+            mCursor = openCursorAndGoToFirst(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                    PROJECTION, selection, selectionArgs);
+        }
+        updateAlbumCursor();
+    }
+
+    private void updateCursor(final Uri uri) {
+        synchronized (this) {
+            closeCursor();
+            mCursor = openCursorAndGoToFirst(uri, PROJECTION, null, null);
+        }
+        updateAlbumCursor();
+    }
+
+    private void updateAlbumCursor() {
+        long albumId = getAlbumId();
+        if (albumId >= 0) {
+            mAlbumCursor = openCursorAndGoToFirst(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,
+                    ALBUM_PROJECTION, "_id=" + albumId, null);
+        } else {
+            mAlbumCursor = null;
+        }
+    }
+
+    private Cursor openCursorAndGoToFirst(Uri uri, String[] projection,
+                                          String selection, String[] selectionArgs) {
+        Cursor c = getContentResolver().query(uri, projection,
+                selection, selectionArgs, null, null);
+        if (c == null) {
+            return null;
+        }
+        if (!c.moveToFirst()) {
+            c.close();
+            return null;
+        }
+        return c;
+    }
+
+    private synchronized void closeCursor() {
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        if (mAlbumCursor != null) {
+            mAlbumCursor.close();
+            mAlbumCursor = null;
+        }
+    }
+
+    /**
+     * Called to open a new file as the current track and prepare the next for
+     * playback
+     */
+    private void openCurrentAndNext() {
+        openCurrentAndMaybeNext(true);
+    }
+
+    /**
+     * Called to open a new file as the current track and prepare the next for
+     * playback
+     *
+     * @param openNext True to prepare the next track for playback, false
+     *                 otherwise.
+     */
+    private void openCurrentAndMaybeNext(final boolean openNext) {
+        synchronized (this) {
+            closeCursor();
+
+            if (mPlaylist.size() == 0) {
+                return;
+            }
+            stop(false);
+
+            boolean shutdown = false;
+
+            updateCursor(mPlaylist.get(mPlayPos).mId);
+            while (true) {
+                if (mCursor != null
+                        && openFile(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + "/"
+                        + mCursor.getLong(IDCOLIDX))) {
+                    break;
+                }
+
+                // if we get here then opening the file failed. We can close the
+                // cursor now, because
+                // we're either going to create a new one next, or stop trying
+                closeCursor();
+                if (mOpenFailedCounter++ < 10 && mPlaylist.size() > 1) {
+                    final int pos = getNextPosition(false);
+                    if (pos < 0) {
+                        shutdown = true;
+                        break;
+                    }
+                    mPlayPos = pos;
+                    stop(false);
+                    mPlayPos = pos;
+                    updateCursor(mPlaylist.get(mPlayPos).mId);
+                } else {
+                    mOpenFailedCounter = 0;
+                    Log.w(TAG, "Failed to open file for playback");
+                    shutdown = true;
+                    break;
+                }
+            }
+
+            if (shutdown) {
+                scheduleDelayedShutdown();
+                if (mIsSupposedToBePlaying) {
+                    mIsSupposedToBePlaying = false;
+                    notifyChange(PLAYSTATE_CHANGED);
+                }
+            } else if (openNext) {
+                setNextTrack();
+            }
+        }
+    }
+
+    private void sendErrorMessage(final String trackName) {
+        final Intent i = new Intent(TRACK_ERROR);
+        i.putExtra(TrackErrorExtra.TRACK_NAME, trackName);
+        sendBroadcast(i);
+    }
+
+    /**
+     * @param force         True to force the player onto the track next, false
+     *                      otherwise.
+     * @return The next position to play.
+     */
+    private int getNextPosition(final boolean force) {
+        // as a base case, if the playlist is empty just return -1
+        if (mPlaylist == null || mPlaylist.isEmpty()) {
+            return -1;
+        }
+        // if we're not forced to go to the next track and we are only playing the current track
+        if (!force && mRepeatMode == REPEAT_CURRENT) {
+            if (mPlayPos < 0) {
+                return 0;
+            }
+            return mPlayPos;
+        } else if (mShuffleMode == SHUFFLE_NORMAL) {
+            final int numTracks = mPlaylist.size();
+
+            // count the number of times a track has been played
+            final int[] trackNumPlays = new int[numTracks];
+            for (int i = 0; i < numTracks; i++) {
+                // set it all to 0
+                trackNumPlays[i] = 0;
+            }
+
+            // walk through the history and add up the number of times the track
+            // has been played
+            final int numHistory = mHistory.size();
+            for (int i = 0; i < numHistory; i++) {
+                final int idx = mHistory.get(i).intValue();
+                if (idx >= 0 && idx < numTracks) {
+                    trackNumPlays[idx]++;
+                }
+            }
+
+            // also add the currently playing track to the count
+            if (mPlayPos >= 0 && mPlayPos < numTracks) {
+                trackNumPlays[mPlayPos]++;
+            }
+
+            // figure out the least # of times a track has a played as well as
+            // how many tracks share that count
+            int minNumPlays = Integer.MAX_VALUE;
+            int numTracksWithMinNumPlays = 0;
+            for (int i = 0; i < trackNumPlays.length; i++) {
+                // if we found a new track that has less number of plays, reset the counters
+                if (trackNumPlays[i] < minNumPlays) {
+                    minNumPlays = trackNumPlays[i];
+                    numTracksWithMinNumPlays = 1;
+                } else if (trackNumPlays[i] == minNumPlays) {
+                    // increment this track shares the # of tracks
+                    numTracksWithMinNumPlays++;
+                }
+            }
+
+            // if we've played each track at least once and all tracks have been played an equal
+            // # of times and we aren't repeating all and we're not forcing a track, then
+            // return no more tracks
+            if (minNumPlays > 0 && numTracksWithMinNumPlays == numTracks
+                    && mRepeatMode != REPEAT_ALL && !force) {
+                return -1;
+            }
+
+            // else pick a track from the least number of played tracks
+            int skip = mShuffler.nextInt(numTracksWithMinNumPlays);
+            for (int i = 0; i < trackNumPlays.length; i++) {
+                if (trackNumPlays[i] == minNumPlays) {
+                    if (skip == 0) {
+                        return i;
+                    } else {
+                        skip--;
+                    }
+                }
+            }
+
+            // Unexpected to land here
+            if (D)
+                Log.e(TAG, "Getting the next position resulted did not get a result when it should have");
+            return -1;
+        } else if (mShuffleMode == SHUFFLE_AUTO) {
+            doAutoShuffleUpdate();
+            return mPlayPos + 1;
+        } else {
+            if (mPlayPos >= mPlaylist.size() - 1) {
+                if (mRepeatMode == REPEAT_NONE && !force) {
+                    return -1;
+                } else if (mRepeatMode == REPEAT_ALL || force) {
+                    return 0;
+                }
+                return -1;
+            } else {
+                return mPlayPos + 1;
+            }
+        }
+    }
+
+    /**
+     * Sets the track to be played
+     */
+    private void setNextTrack() {
+        setNextTrack(getNextPosition(false));
+    }
+
+    /**
+     * Sets the next track to be played
+     *
+     * @param position the target position we want
+     */
+    private void setNextTrack(int position) {
+        mNextPlayPos = position;
+        if (D) Log.d(TAG, "setNextTrack: next play position = " + mNextPlayPos);
+        if (mNextPlayPos >= 0 && mPlaylist != null && mNextPlayPos < mPlaylist.size()) {
+            final long id = mPlaylist.get(mNextPlayPos).mId;
+            mPlayer.setNextDataSource(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI + "/" + id);
+        } else {
+            mPlayer.setNextDataSource(null);
+        }
+    }
+
+    /**
+     * Creates a shuffled playlist used for party mode
+     */
+    private boolean makeAutoShuffleList() {
+        Cursor cursor = null;
+        try {
+            cursor = getContentResolver().query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                    new String[]{
+                            MediaStore.Audio.Media._ID
+                    }, MediaStore.Audio.Media.IS_MUSIC + "=1", null, null);
+            if (cursor == null || cursor.getCount() == 0) {
+                return false;
+            }
+            final int len = cursor.getCount();
+            final long[] list = new long[len];
+            for (int i = 0; i < len; i++) {
+                cursor.moveToNext();
+                list[i] = cursor.getLong(0);
+            }
+            mAutoShuffleList = list;
+            return true;
+        } catch (final RuntimeException e) {
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+                cursor = null;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Creates the party shuffle playlist
+     */
+    private void doAutoShuffleUpdate() {
+        boolean notify = false;
+        if (mPlayPos > 10) {
+            removeTracks(0, mPlayPos - 9);
+            notify = true;
+        }
+        final int toAdd = 7 - (mPlaylist.size() - (mPlayPos < 0 ? -1 : mPlayPos));
+        for (int i = 0; i < toAdd; i++) {
+            int lookback = mHistory.size();
+            int idx = -1;
+            while (true) {
+                idx = mShuffler.nextInt(mAutoShuffleList.length);
+                if (!wasRecentlyUsed(idx, lookback)) {
+                    break;
+                }
+                lookback /= 2;
+            }
+            mHistory.add(idx);
+            if (mHistory.size() > MAX_HISTORY_SIZE) {
+                mHistory.remove(0);
+            }
+            mPlaylist.add(new MusicPlaybackTrack(mAutoShuffleList[idx], -1, IdType.NA, -1));
+            notify = true;
+        }
+        if (notify) {
+            notifyChange(QUEUE_CHANGED);
+        }
+    }
+
+    /**/
+    private boolean wasRecentlyUsed(final int idx, int lookbacksize) {
+        if (lookbacksize == 0) {
+            return false;
+        }
+        final int histsize = mHistory.size();
+        if (histsize < lookbacksize) {
+            lookbacksize = histsize;
+        }
+        final int maxidx = histsize - 1;
+        for (int i = 0; i < lookbacksize; i++) {
+            final long entry = mHistory.get(maxidx - i);
+            if (entry == idx) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Notify the change-receivers that something has changed.
+     */
+    private void notifyChange(final String what) {
+        if (D) Log.d(TAG, "notifyChange: what = " + what);
+
+        // Update the lockscreen controls
+        updateMediaSession(what);
+
+        if (what.equals(POSITION_CHANGED)) {
+            return;
+        }
+
+        final Intent intent = new Intent(what);
+        intent.putExtra("id", getAudioId());
+        intent.putExtra("artist", getArtistName());
+        intent.putExtra("album", getAlbumName());
+        intent.putExtra("track", getTrackName());
+        intent.putExtra("playing", isPlaying());
+
+        if (NEW_LYRICS.equals(what)) {
+            intent.putExtra("lyrics", mLyrics);
+        }
+
+        sendStickyBroadcast(intent);
+
+        final Intent musicIntent = new Intent(intent);
+        musicIntent.setAction(what.replace(ELEVEN_PACKAGE_NAME, MUSIC_PACKAGE_NAME));
+        sendStickyBroadcast(musicIntent);
+
+        if (what.equals(META_CHANGED)) {
+            // Add the track to the recently played list.
+            mRecentsCache.addSongId(getAudioId());
+
+            mSongPlayCountCache.bumpSongCount(getAudioId());
+        } else if (what.equals(QUEUE_CHANGED)) {
+            saveQueue(true);
+            if (isPlaying()) {
+                // if we are in shuffle mode and our next track is still valid,
+                // try to re-use the track
+                // We need to reimplement the queue to prevent hacky solutions like this
+                // https://cyanogen.atlassian.net/browse/MUSIC-175
+                // https://cyanogen.atlassian.net/browse/MUSIC-44
+                if (mNextPlayPos >= 0 && mNextPlayPos < mPlaylist.size()
+                        && getShuffleMode() != SHUFFLE_NONE) {
+                    setNextTrack(mNextPlayPos);
+                } else {
+                    setNextTrack();
+                }
+            }
+        } else {
+            saveQueue(false);
+        }
+
+        if (what.equals(PLAYSTATE_CHANGED)) {
+            updateNotification();
+        }
+
+        // Update the app-widgets
+        mAppWidgetSmall.notifyChange(this, what);
+        mAppWidgetLarge.notifyChange(this, what);
+        mAppWidgetLargeAlternate.notifyChange(this, what);
+    }
+
+    private void updateMediaSession(final String what) {
+        int playState = mIsSupposedToBePlaying
+                ? PlaybackStateCompat.STATE_PLAYING
+                : PlaybackStateCompat.STATE_PAUSED;
+
+        long playBackStateActions = PlaybackStateCompat.ACTION_PLAY |
+                PlaybackStateCompat.ACTION_PLAY_PAUSE |
+                PlaybackStateCompat.ACTION_PLAY_FROM_MEDIA_ID |
+                PlaybackStateCompat.ACTION_PAUSE |
+                PlaybackStateCompat.ACTION_SKIP_TO_NEXT |
+                PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS;
+
+        if (what.equals(PLAYSTATE_CHANGED) || what.equals(POSITION_CHANGED)) {
+            mSession.setPlaybackState(new PlaybackStateCompat.Builder()
+                    .setActions(playBackStateActions)
+                    .setState(playState, position(), 1.0f).build());
+        } else if (what.equals(META_CHANGED) || what.equals(QUEUE_CHANGED)) {
+            Bitmap albumArt = getAlbumArt(false).getBitmap();
+            if (albumArt != null) {
+                // RemoteControlClient wants to recycle the bitmaps thrown at it, so we need
+                // to make sure not to hand out our cache copy
+                Bitmap.Config config = albumArt.getConfig();
+                if (config == null) {
+                    config = Bitmap.Config.ARGB_8888;
+                }
+                albumArt = albumArt.copy(config, false);
+            }
+
+            mSession.setMetadata(new MediaMetadataCompat.Builder()
+                    .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, getArtistName())
+                    .putString(MediaMetadataCompat.METADATA_KEY_ALBUM_ARTIST, getAlbumArtistName())
+                    .putString(MediaMetadataCompat.METADATA_KEY_ALBUM, getAlbumName())
+                    .putString(MediaMetadataCompat.METADATA_KEY_TITLE, getTrackName())
+                    .putLong(MediaMetadataCompat.METADATA_KEY_DURATION, duration())
+                    .putLong(MediaMetadataCompat.METADATA_KEY_TRACK_NUMBER, getQueuePosition() + 1)
+                    .putLong(MediaMetadataCompat.METADATA_KEY_NUM_TRACKS, getQueue().length)
+                    .putString(MediaMetadataCompat.METADATA_KEY_GENRE, getGenreName())
+                    .putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART,
+                            mShowAlbumArtOnLockscreen ? albumArt : null)
+                    .build());
+
+            mSession.setPlaybackState(new PlaybackStateCompat.Builder()
+                    .setActions(playBackStateActions)
+                    .setState(playState, position(), 1.0f).build());
+        }
+    }
+
+    private Notification buildNotification() {
+        final String albumName = getAlbumName();
+        final String artistName = getArtistName();
+        final boolean isPlaying = isPlaying();
+        String text = TextUtils.isEmpty(albumName)
+                ? artistName : artistName + " - " + albumName;
+
+        int playButtonResId = isPlaying
+                ? R.drawable.btn_playback_pause : R.drawable.btn_playback_play;
+        int playButtonTitleResId = isPlaying
+                ? R.string.accessibility_pause : R.string.accessibility_play;
+
+        android.support.v7.app.NotificationCompat.MediaStyle style = new android.support.v7.app.NotificationCompat.MediaStyle()
+                .setMediaSession(mSession.getSessionToken())
+                .setShowActionsInCompactView(0, 1, 2);
+
+        Intent nowPlayingIntent = new Intent("com.dolzzo.twelve.AUDIO_PLAYER")
+                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        PendingIntent clickIntent = PendingIntent.getActivity(this, 0, nowPlayingIntent, 0);
+        BitmapWithColors artwork = getAlbumArt(false);
+
+        if (mNotificationPostTime == 0) {
+            mNotificationPostTime = System.currentTimeMillis();
+        }
+
+        NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
+        builder.setSmallIcon(R.drawable.ic_notification)
+                .setLargeIcon(artwork.getBitmap())
+                .setContentIntent(clickIntent)
+                .setContentTitle(getTrackName())
+                .setContentText(text)
+                .setWhen(mNotificationPostTime)
+                .setShowWhen(false)
+                .setStyle(style)
+                .setVisibility(Notification.VISIBILITY_PUBLIC)
+                .addAction(R.drawable.btn_playback_previous,
+                        getString(R.string.accessibility_prev),
+                        retrievePlaybackAction(PREVIOUS_ACTION))
+                .addAction(playButtonResId, getString(playButtonTitleResId),
+                        retrievePlaybackAction(TOGGLEPAUSE_ACTION))
+                .addAction(R.drawable.btn_playback_next,
+                        getString(R.string.accessibility_next),
+                        retrievePlaybackAction(NEXT_ACTION));
+
+        builder.setColor(artwork.getVibrantDarkColor());
+
+        return builder.build();
+    }
+
+    private final PendingIntent retrievePlaybackAction(final String action) {
+        final ComponentName serviceName = new ComponentName(this, MusicPlaybackService.class);
+        Intent intent = new Intent(action);
+        intent.setComponent(serviceName);
+
+        return PendingIntent.getService(this, 0, intent, 0);
+    }
+
+    /**
+     * Saves the queue
+     *
+     * @param full True if the queue is full
+     */
+    private void saveQueue(final boolean full) {
+        if (!mQueueIsSaveable) {
+            return;
+        }
+
+        final SharedPreferences.Editor editor = mPreferences.edit();
+        if (full) {
+            mPlaybackStateStore.saveState(mPlaylist,
+                    mShuffleMode != SHUFFLE_NONE ? mHistory : null);
+            editor.putInt("cardid", mCardId);
+        }
+        editor.putInt("curpos", mPlayPos);
+        if (mPlayer.isInitialized()) {
+            editor.putLong("seekpos", mPlayer.position());
+        }
+        editor.putInt("repeatmode", mRepeatMode);
+        editor.putInt("shufflemode", mShuffleMode);
+        editor.apply();
+    }
+
+    /**
+     * Reloads the queue as the user left it the last time they stopped using
+     * Apollo
+     */
+    private void reloadQueue() {
+        int id = mCardId;
+        if (mPreferences.contains("cardid")) {
+            id = mPreferences.getInt("cardid", ~mCardId);
+        }
+        if (id == mCardId) {
+            mPlaylist = mPlaybackStateStore.getQueue();
+        }
+        if (mPlaylist.size() > 0) {
+            final int pos = mPreferences.getInt("curpos", 0);
+            if (pos < 0 || pos >= mPlaylist.size()) {
+                mPlaylist.clear();
+                return;
+            }
+            mPlayPos = pos;
+            updateCursor(mPlaylist.get(mPlayPos).mId);
+            if (mCursor == null) {
+                SystemClock.sleep(3000);
+                updateCursor(mPlaylist.get(mPlayPos).mId);
+            }
+            synchronized (this) {
+                closeCursor();
+                mOpenFailedCounter = 20;
+                openCurrentAndNext();
+            }
+            if (!mPlayer.isInitialized()) {
+                mPlaylist.clear();
+                return;
+            }
+
+            final long seekpos = mPreferences.getLong("seekpos", 0);
+            seek(seekpos >= 0 && seekpos < duration() ? seekpos : 0);
+
+            if (D) {
+                Log.d(TAG, "restored queue, currently at position "
+                        + position() + "/" + duration()
+                        + " (requested " + seekpos + ")");
+            }
+
+            int repmode = mPreferences.getInt("repeatmode", REPEAT_NONE);
+            if (repmode != REPEAT_ALL && repmode != REPEAT_CURRENT) {
+                repmode = REPEAT_NONE;
+            }
+            mRepeatMode = repmode;
+
+            int shufmode = mPreferences.getInt("shufflemode", SHUFFLE_NONE);
+            if (shufmode != SHUFFLE_AUTO && shufmode != SHUFFLE_NORMAL) {
+                shufmode = SHUFFLE_NONE;
+            }
+            if (shufmode != SHUFFLE_NONE) {
+                mHistory = mPlaybackStateStore.getHistory(mPlaylist.size());
+            }
+            if (shufmode == SHUFFLE_AUTO) {
+                if (!makeAutoShuffleList()) {
+                    shufmode = SHUFFLE_NONE;
+                }
+            }
+            mShuffleMode = shufmode;
+        }
+    }
+
+    /**
+     * Opens a file and prepares it for playback
+     *
+     * @param path The path of the file to open
+     */
+    public boolean openFile(final String path) {
+        if (D) Log.d(TAG, "openFile: path = " + path);
+        synchronized (this) {
+            if (path == null) {
+                return false;
+            }
+
+            // If mCursor is null, try to associate path with a database cursor
+            if (mCursor == null) {
+                Uri uri = Uri.parse(path);
+                boolean shouldAddToPlaylist = true;     // should try adding audio info to playlist
+                long id = -1;
+                try {
+                    id = Long.valueOf(uri.getLastPathSegment());
+                } catch (NumberFormatException ex) {
+                    // Ignore
+                }
+
+                if (id != -1 && path.startsWith(
+                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI.toString())) {
+                    updateCursor(uri);
+
+                } else if (id != -1 && path.startsWith(
+                        MediaStore.Files.getContentUri("external").toString())) {
+                    updateCursor(id);
+
+                    // handle downloaded media files
+                } else if (path.startsWith("content://downloads/")) {
+
+                    // extract MediaProvider(MP) uri , if available
+                    // Downloads.Impl.COLUMN_MEDIAPROVIDER_URI
+                    String mpUri = getValueForDownloadedFile(this, uri, "mediaprovider_uri");
+                    if (D) Log.i(TAG, "Downloaded file's MP uri : " + mpUri);
+                    if (!TextUtils.isEmpty(mpUri)) {
+                        // if mpUri is valid, play that URI instead
+                        if (openFile(mpUri)) {
+                            // notify impending change in track
+                            notifyChange(META_CHANGED);
+                            return true;
+                        } else {
+                            return false;
+                        }
+                    } else {
+                        // create phantom cursor with download info, if a MP uri wasn't found
+                        updateCursorForDownloadedFile(this, uri);
+                        shouldAddToPlaylist = false;    // song info isn't available in MediaStore
+                    }
+
+                } else {
+                    // assuming a "file://" uri by this point ...
+                    String where = MediaStore.Audio.Media.DATA + "=?";
+                    String[] selectionArgs = new String[]{path};
+                    updateCursor(where, selectionArgs);
+                }
+                try {
+                    if (mCursor != null && shouldAddToPlaylist) {
+                        mPlaylist.clear();
+                        mPlaylist.add(new MusicPlaybackTrack(
+                                mCursor.getLong(IDCOLIDX), -1, IdType.NA, -1));
+                        // propagate the change in playlist state
+                        notifyChange(QUEUE_CHANGED);
+                        mPlayPos = 0;
+                        mHistory.clear();
+                    }
+                } catch (final UnsupportedOperationException ex) {
+                    // Ignore
+                }
+            }
+
+            mFileToPlay = path;
+            mPlayer.setDataSource(mFileToPlay);
+            if (mPlayer.isInitialized()) {
+                mOpenFailedCounter = 0;
+                return true;
+            }
+
+            String trackName = getTrackName();
+            if (TextUtils.isEmpty(trackName)) {
+                trackName = path;
+            }
+            sendErrorMessage(trackName);
+
+            stop(true);
+            return false;
+        }
+    }
+
+    /**
+     * Creates a pseudo cursor for downloaded audio files with minimal info
+     *
+     * @param context needed to query the download uri
+     * @param uri     the uri of the downloaded file
+     */
+    private void updateCursorForDownloadedFile(Context context, Uri uri) {
+        synchronized (this) {
+            closeCursor();  // clear mCursor
+            MatrixCursor cursor = new MatrixCursor(PROJECTION_MATRIX);
+            // get title of the downloaded file ; Downloads.Impl.COLUMN_TITLE
+            String title = getValueForDownloadedFile(this, uri, "title");
+            // populating the cursor with bare minimum info
+            cursor.addRow(new Object[]{
+                    null,
+                    null,
+                    null,
+                    title,
+                    null,
+                    null,
+                    null,
+                    null
+            });
+            mCursor = cursor;
+            mCursor.moveToFirst();
+        }
+    }
+
+    /**
+     * Query the DownloadProvider to get the value in the specified column
+     *
+     * @param context
+     * @param uri     the uri of the downloaded file
+     * @param column
+     * @return
+     */
+    private String getValueForDownloadedFile(Context context, Uri uri, String column) {
+
+        Cursor cursor = null;
+        final String[] projection = {
+                column
+        };
+
+        try {
+            cursor = context.getContentResolver().query(uri, projection, null, null, null);
+            if (cursor != null && cursor.moveToFirst()) {
+                return cursor.getString(0);
+            }
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Returns the audio session ID
+     *
+     * @return The current media player audio session ID
+     */
+    public int getAudioSessionId() {
+        synchronized (this) {
+            return mPlayer.getAudioSessionId();
+        }
+    }
+
+    /**
+     * Indicates if the media storeage device has been mounted or not
+     *
+     * @return 1 if Intent.ACTION_MEDIA_MOUNTED is called, 0 otherwise
+     */
+    public int getMediaMountedCount() {
+        return mMediaMountedCount;
+    }
+
+    /**
+     * Returns the shuffle mode
+     *
+     * @return The current shuffle mode (all, party, none)
+     */
+    public int getShuffleMode() {
+        return mShuffleMode;
+    }
+
+    /**
+     * Sets the shuffle mode
+     *
+     * @param shufflemode The shuffle mode to use
+     */
+    public void setShuffleMode(final int shufflemode) {
+        synchronized (this) {
+            if (mShuffleMode == shufflemode && mPlaylist.size() > 0) {
+                return;
+            }
+
+            mShuffleMode = shufflemode;
+            if (mShuffleMode == SHUFFLE_AUTO) {
+                if (makeAutoShuffleList()) {
+                    mPlaylist.clear();
+                    doAutoShuffleUpdate();
+                    mPlayPos = 0;
+                    openCurrentAndNext();
+                    play();
+                    notifyChange(META_CHANGED);
+                    return;
+                } else {
+                    mShuffleMode = SHUFFLE_NONE;
+                }
+            } else {
+                setNextTrack();
+            }
+            saveQueue(false);
+            notifyChange(SHUFFLEMODE_CHANGED);
+        }
+    }
+
+    /**
+     * Returns the repeat mode
+     *
+     * @return The current repeat mode (all, one, none)
+     */
+    public int getRepeatMode() {
+        return mRepeatMode;
+    }
+
+    /**
+     * Sets the repeat mode
+     *
+     * @param repeatmode The repeat mode to use
+     */
+    public void setRepeatMode(final int repeatmode) {
+        synchronized (this) {
+            mRepeatMode = repeatmode;
+            setNextTrack();
+            saveQueue(false);
+            notifyChange(REPEATMODE_CHANGED);
+        }
+    }
+
+    /**
+     * Removes all instances of the track with the given ID from the playlist.
+     *
+     * @param id The id to be removed
+     * @return how many instances of the track were removed
+     */
+    public int removeTrack(final long id) {
+        int numremoved = 0;
+        synchronized (this) {
+            for (int i = 0; i < mPlaylist.size(); i++) {
+                if (mPlaylist.get(i).mId == id) {
+                    numremoved += removeTracksInternal(i, i);
+                    i--;
+                }
+            }
+        }
+        if (numremoved > 0) {
+            notifyChange(QUEUE_CHANGED);
+        }
+        return numremoved;
+    }
+
+    /**
+     * Removes a song from the playlist at the specified position.
+     *
+     * @param id       The song id to be removed
+     * @param position The position of the song in the playlist
+     * @return true if successful
+     */
+    public boolean removeTrackAtPosition(final long id, final int position) {
+        synchronized (this) {
+            if (position >= 0 &&
+                    position < mPlaylist.size() &&
+                    mPlaylist.get(position).mId == id) {
+
+                return removeTracks(position, position) > 0;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Removes the range of tracks specified from the play list. If a file
+     * within the range is the file currently being played, playback will move
+     * to the next file after the range.
+     *
+     * @param first The first file to be removed
+     * @param last  The last file to be removed
+     * @return the number of tracks deleted
+     */
+    public int removeTracks(final int first, final int last) {
+        final int numremoved = removeTracksInternal(first, last);
+        if (numremoved > 0) {
+            notifyChange(QUEUE_CHANGED);
+        }
+        return numremoved;
+    }
+
+    /**
+     * Returns the position in the queue
+     *
+     * @return the current position in the queue
+     */
+    public int getQueuePosition() {
+        synchronized (this) {
+            return mPlayPos;
+        }
+    }
+
+    /**
+     * Sets the position of a track in the queue
+     *
+     * @param index The position to place the track
+     */
+    public void setQueuePosition(final int index) {
+        synchronized (this) {
+            stop(false);
+            mPlayPos = index;
+            openCurrentAndNext();
+            play();
+            notifyChange(META_CHANGED);
+            if (mShuffleMode == SHUFFLE_AUTO) {
+                doAutoShuffleUpdate();
+            }
+        }
+    }
+
+    /**
+     * @return the size of the queue history cache
+     */
+    public int getQueueHistorySize() {
+        synchronized (this) {
+            return mHistory.size();
+        }
+    }
+
+    /**
+     * @return the position in the history
+     */
+    public int getQueueHistoryPosition(int position) {
+        synchronized (this) {
+            if (position >= 0 && position < mHistory.size()) {
+                return mHistory.get(position);
+            }
+        }
+
+        return -1;
+    }
+
+    /**
+     * @return the queue of history positions
+     */
+    public int[] getQueueHistoryList() {
+        synchronized (this) {
+            int[] history = new int[mHistory.size()];
+            for (int i = 0; i < mHistory.size(); i++) {
+                history[i] = mHistory.get(i);
+            }
+
+            return history;
+        }
+    }
+
+    /**
+     * Returns the path to current song
+     *
+     * @return The path to the current song
+     */
+    public String getPath() {
+        synchronized (this) {
+            if (mCursor == null) {
+                return null;
+            }
+            return mCursor.getString(mCursor.getColumnIndexOrThrow(AudioColumns.DATA));
+        }
+    }
+
+    /**
+     * Returns the album name
+     *
+     * @return The current song album Name
+     */
+    public String getAlbumName() {
+        synchronized (this) {
+            if (mCursor == null) {
+                return null;
+            }
+            return mCursor.getString(mCursor.getColumnIndexOrThrow(AudioColumns.ALBUM));
+        }
+    }
+
+    /**
+     * Returns the song name
+     *
+     * @return The current song name
+     */
+    public String getTrackName() {
+        synchronized (this) {
+            if (mCursor == null) {
+                return null;
+            }
+            return mCursor.getString(mCursor.getColumnIndexOrThrow(AudioColumns.TITLE));
+        }
+    }
+
+    /**
+     * Returns the genre name of song
+     *
+     * @return The current song genre name
+     */
+    public String getGenreName() {
+        synchronized (this) {
+            if (mCursor == null || mPlayPos < 0 || mPlayPos >= mPlaylist.size()) {
+                return null;
+            }
+            String[] genreProjection = {MediaStore.Audio.Genres.NAME};
+            Uri genreUri = MediaStore.Audio.Genres.getContentUriForAudioId("external",
+                    (int) mPlaylist.get(mPlayPos).mId);
+            Cursor genreCursor = getContentResolver().query(genreUri, genreProjection,
+                    null, null, null);
+            if (genreCursor != null) {
+                try {
+                    if (genreCursor.moveToFirst()) {
+                        return genreCursor.getString(
+                                genreCursor.getColumnIndexOrThrow(MediaStore.Audio.Genres.NAME));
+                    }
+                } finally {
+                    genreCursor.close();
+                }
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Returns the artist name
+     *
+     * @return The current song artist name
+     */
+    public String getArtistName() {
+        synchronized (this) {
+            if (mCursor == null) {
+                return null;
+            }
+            return mCursor.getString(mCursor.getColumnIndexOrThrow(AudioColumns.ARTIST));
+        }
+    }
+
+    /**
+     * Returns the artist name
+     *
+     * @return The current song artist name
+     */
+    public String getAlbumArtistName() {
+        synchronized (this) {
+            if (mAlbumCursor == null) {
+                return null;
+            }
+            return mAlbumCursor.getString(mAlbumCursor.getColumnIndexOrThrow(AlbumColumns.ARTIST));
+        }
+    }
+
+    /**
+     * Returns the album ID
+     *
+     * @return The current song album ID
+     */
+    public long getAlbumId() {
+        synchronized (this) {
+            if (mCursor == null) {
+                return -1;
+            }
+            return mCursor.getLong(mCursor.getColumnIndexOrThrow(AudioColumns.ALBUM_ID));
+        }
+    }
+
+    /**
+     * Returns the artist ID
+     *
+     * @return The current song artist ID
+     */
+    public long getArtistId() {
+        synchronized (this) {
+            if (mCursor == null) {
+                return -1;
+            }
+            return mCursor.getLong(mCursor.getColumnIndexOrThrow(AudioColumns.ARTIST_ID));
+        }
+    }
+
+    /**
+     * @return The audio id of the track
+     */
+    public long getAudioId() {
+        MusicPlaybackTrack track = getCurrentTrack();
+        if (track != null) {
+            return track.mId;
+        }
+
+        return -1;
+    }
+
+    /**
+     * Gets the currently playing music track
+     */
+    public MusicPlaybackTrack getCurrentTrack() {
+        return getTrack(mPlayPos);
+    }
+
+    /**
+     * Gets the music track from the queue at the specified index
+     *
+     * @param index position
+     * @return music track or null
+     */
+    public synchronized MusicPlaybackTrack getTrack(int index) {
+        if (index >= 0 && index < mPlaylist.size() && mPlayer.isInitialized()) {
+            return mPlaylist.get(index);
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns the next audio ID
+     *
+     * @return The next track ID
+     */
+    public long getNextAudioId() {
+        synchronized (this) {
+            if (mNextPlayPos >= 0 && mNextPlayPos < mPlaylist.size() && mPlayer.isInitialized()) {
+                return mPlaylist.get(mNextPlayPos).mId;
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Returns the previous audio ID
+     *
+     * @return The previous track ID
+     */
+    public long getPreviousAudioId() {
+        synchronized (this) {
+            if (mPlayer.isInitialized()) {
+                int pos = getPreviousPlayPosition(false);
+                if (pos >= 0 && pos < mPlaylist.size()) {
+                    return mPlaylist.get(pos).mId;
+                }
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Seeks the current track to a specific time
+     *
+     * @param position The time to seek to
+     * @return The time to play the track at
+     */
+    public long seek(long position) {
+        if (mPlayer.isInitialized()) {
+            if (position < 0) {
+                position = 0;
+            } else if (position > mPlayer.duration()) {
+                position = mPlayer.duration();
+            }
+            long result = mPlayer.seek(position);
+            notifyChange(POSITION_CHANGED);
+            return result;
+        }
+        return -1;
+    }
+
+    /**
+     * Seeks the current track to a position relative to its current position
+     * If the relative position is after or before the track, it will also automatically
+     * jump to the previous or next track respectively
+     *
+     * @param deltaInMs The delta time to seek to in milliseconds
+     */
+    public void seekRelative(long deltaInMs) {
+        synchronized (this) {
+            if (mPlayer.isInitialized()) {
+                final long newPos = position() + deltaInMs;
+                final long duration = duration();
+                if (newPos < 0) {
+                    prev(true);
+                    // seek to the new duration + the leftover position
+                    seek(duration() + newPos);
+                } else if (newPos >= duration) {
+                    gotoNext(true);
+                    // seek to the leftover duration
+                    seek(newPos - duration);
+                } else {
+                    seek(newPos);
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns the current position in time of the currenttrack
+     *
+     * @return The current playback position in miliseconds
+     */
+    public long position() {
+        if (mPlayer.isInitialized()) {
+            return mPlayer.position();
+        }
+        return -1;
+    }
+
+    /**
+     * Returns the full duration of the current track
+     *
+     * @return The duration of the current track in miliseconds
+     */
+    public long duration() {
+        if (mPlayer.isInitialized()) {
+            return mPlayer.duration();
+        }
+        return -1;
+    }
+
+    /**
+     * Returns the queue
+     *
+     * @return The queue as a long[]
+     */
+    public long[] getQueue() {
+        synchronized (this) {
+            final int len = mPlaylist.size();
+            final long[] list = new long[len];
+            for (int i = 0; i < len; i++) {
+                list[i] = mPlaylist.get(i).mId;
+            }
+            return list;
+        }
+    }
+
+    /**
+     * Gets the track id at a given position in the queue
+     *
+     * @param position
+     * @return track id in the queue position
+     */
+    public long getQueueItemAtPosition(int position) {
+        synchronized (this) {
+            if (position >= 0 && position < mPlaylist.size()) {
+                return mPlaylist.get(position).mId;
+            }
+        }
+
+        return -1;
+    }
+
+    /**
+     * @return the size of the queue
+     */
+    public int getQueueSize() {
+        synchronized (this) {
+            return mPlaylist.size();
+        }
+    }
+
+    /**
+     * @return True if music is playing, false otherwise
+     */
+    public boolean isPlaying() {
+        return mIsSupposedToBePlaying;
+    }
+
+    /**
+     * Helper function to wrap the logic around mIsSupposedToBePlaying for consistentcy
+     *
+     * @param value  to set mIsSupposedToBePlaying to
+     * @param notify whether we want to fire PLAYSTATE_CHANGED event
+     */
+    private void setIsSupposedToBePlaying(boolean value, boolean notify) {
+        if (mIsSupposedToBePlaying != value) {
+            mIsSupposedToBePlaying = value;
+
+            // Update mLastPlayed time first and notify afterwards, as
+            // the notification listener method needs the up-to-date value
+            // for the recentlyPlayed() method to work
+            if (!mIsSupposedToBePlaying) {
+                scheduleDelayedShutdown();
+                mLastPlayedTime = System.currentTimeMillis();
+            }
+
+            if (notify) {
+                notifyChange(PLAYSTATE_CHANGED);
+            }
+        }
+    }
+
+    /**
+     * @return true if is playing or has played within the last IDLE_DELAY time
+     */
+    private boolean recentlyPlayed() {
+        return isPlaying() || System.currentTimeMillis() - mLastPlayedTime < IDLE_DELAY;
+    }
+
+    /**
+     * Opens a list for playback
+     *
+     * @param list     The list of tracks to open
+     * @param position The position to start playback at
+     */
+    public void open(final long[] list, final int position, long sourceId, IdType sourceType) {
+        synchronized (this) {
+            if (mShuffleMode == SHUFFLE_AUTO) {
+                mShuffleMode = SHUFFLE_NORMAL;
+            }
+            final long oldId = getAudioId();
+            final int listlength = list.length;
+            boolean newlist = true;
+            if (mPlaylist.size() == listlength) {
+                newlist = false;
+                for (int i = 0; i < listlength; i++) {
+                    if (list[i] != mPlaylist.get(i).mId) {
+                        newlist = true;
+                        break;
+                    }
+                }
+            }
+            if (newlist) {
+                addToPlayList(list, -1, sourceId, sourceType);
+                notifyChange(QUEUE_CHANGED);
+            }
+            if (position >= 0) {
+                mPlayPos = position;
+            } else {
+                mPlayPos = mShuffler.nextInt(mPlaylist.size());
+            }
+            mHistory.clear();
+            openCurrentAndNext();
+            if (oldId != getAudioId()) {
+                notifyChange(META_CHANGED);
+            }
+        }
+    }
+
+    /**
+     * Stops playback.
+     */
+    public void stop() {
+        stopShakeDetector(false);
+        stop(true);
+    }
+
+    /**
+     * Resumes or starts playback.
+     */
+    public void play() {
+        startShakeDetector();
+        play(true);
+    }
+
+    /**
+     * Resumes or starts playback.
+     *
+     * @param createNewNextTrack True if you want to figure out the next track, false
+     *                           if you want to re-use the existing next track (used for going back)
+     */
+    public void play(boolean createNewNextTrack) {
+        int status = mAudioManager.requestAudioFocus(mAudioFocusListener,
+                AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);
+
+        if (D) Log.d(TAG, "Starting playback: audio focus request status = " + status);
+
+        if (status != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
+            return;
+        }
+
+        final Intent intent = new Intent(AudioEffect.ACTION_OPEN_AUDIO_EFFECT_CONTROL_SESSION);
+        intent.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());
+        intent.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());
+        sendBroadcast(intent);
+
+        mAudioManager.registerMediaButtonEventReceiver(new ComponentName(getPackageName(),
+                MediaButtonIntentReceiver.class.getName()));
+        mSession.setActive(true);
+
+        if (createNewNextTrack) {
+            setNextTrack();
+        } else {
+            setNextTrack(mNextPlayPos);
+        }
+
+        if (mPlayer.isInitialized()) {
+            final long duration = mPlayer.duration();
+            if (mRepeatMode != REPEAT_CURRENT && duration > 2000
+                    && mPlayer.position() >= duration - 2000) {
+                gotoNext(true);
+            }
+
+            mPlayer.start();
+            mPlayerHandler.removeMessages(FADEDOWN);
+            mPlayerHandler.sendEmptyMessage(FADEUP);
+
+            setIsSupposedToBePlaying(true, true);
+
+            cancelShutdown();
+            updateNotification();
+        } else if (mPlaylist.size() <= 0) {
+            setShuffleMode(SHUFFLE_AUTO);
+        }
+    }
+
+    /**
+     * Temporarily pauses playback.
+     */
+    public void pause() {
+        if (D) Log.d(TAG, "Pausing playback");
+        synchronized (this) {
+            mPlayerHandler.removeMessages(FADEUP);
+            if (mIsSupposedToBePlaying) {
+                final Intent intent = new Intent(
+                        AudioEffect.ACTION_CLOSE_AUDIO_EFFECT_CONTROL_SESSION);
+                intent.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, getAudioSessionId());
+                intent.putExtra(AudioEffect.EXTRA_PACKAGE_NAME, getPackageName());
+                sendBroadcast(intent);
+
+                mPlayer.pause();
+                setIsSupposedToBePlaying(false, true);
+                stopShakeDetector(false);
+            }
+        }
+    }
+
+    /**
+     * Changes from the current track to the next track
+     */
+    public void gotoNext(final boolean force) {
+        if (D) Log.d(TAG, "Going to next track");
+        synchronized (this) {
+            if (mPlaylist.size() <= 0) {
+                if (D) Log.d(TAG, "No play queue");
+                scheduleDelayedShutdown();
+                return;
+            }
+            int pos = mNextPlayPos;
+            if (pos < 0) {
+                pos = getNextPosition(force);
+            }
+
+            if (pos < 0) {
+                setIsSupposedToBePlaying(false, true);
+                return;
+            }
+
+            stop(false);
+            setAndRecordPlayPos(pos);
+            openCurrentAndNext();
+            play();
+            notifyChange(META_CHANGED);
+        }
+    }
+
+    public void setAndRecordPlayPos(int nextPos) {
+        synchronized (this) {
+            // save to the history
+            if (mShuffleMode != SHUFFLE_NONE) {
+                mHistory.add(mPlayPos);
+                if (mHistory.size() > MAX_HISTORY_SIZE) {
+                    mHistory.remove(0);
+                }
+            }
+
+            mPlayPos = nextPos;
+        }
+    }
+
+    /**
+     * Changes from the current track to the previous played track
+     */
+    public void prev(boolean forcePrevious) {
+        synchronized (this) {
+            // if we aren't repeating 1, and we are either early in the song
+            // or we want to force go back, then go to the prevous track
+            boolean goPrevious = getRepeatMode() != REPEAT_CURRENT &&
+                    (position() < REWIND_INSTEAD_PREVIOUS_THRESHOLD || forcePrevious);
+
+            if (goPrevious) {
+                if (D) Log.d(TAG, "Going to previous track");
+                int pos = getPreviousPlayPosition(true);
+                // if we have no more previous tracks, quit
+                if (pos < 0) {
+                    return;
+                }
+                mNextPlayPos = mPlayPos;
+                mPlayPos = pos;
+                stop(false);
+                openCurrent();
+                play(false);
+                notifyChange(META_CHANGED);
+            } else {
+                if (D) Log.d(TAG, "Going to beginning of track");
+                seek(0);
+                play(false);
+            }
+        }
+    }
+
+    public int getPreviousPlayPosition(boolean removeFromHistory) {
+        synchronized (this) {
+            if (mShuffleMode == SHUFFLE_NORMAL) {
+                // Go to previously-played track and remove it from the history
+                final int histsize = mHistory.size();
+                if (histsize == 0) {
+                    return -1;
+                }
+                final Integer pos = mHistory.get(histsize - 1);
+                if (removeFromHistory) {
+                    mHistory.remove(histsize - 1);
+                }
+                return pos.intValue();
+            } else {
+                if (mPlayPos > 0) {
+                    return mPlayPos - 1;
+                } else {
+                    return mPlaylist.size() - 1;
+                }
+            }
+        }
+    }
+
+    /**
+     * We don't want to open the current and next track when the user is using
+     * the {@code #prev()} method because they won't be able to travel back to
+     * the previously listened track if they're shuffling.
+     */
+    private void openCurrent() {
+        openCurrentAndMaybeNext(false);
+    }
+
+    /**
+     * Moves an item in the queue from one position to another
+     *
+     * @param from The position the item is currently at
+     * @param to   The position the item is being moved to
+     */
+    public void moveQueueItem(int from, int to) {
+        synchronized (this) {
+            if (from >= mPlaylist.size()) {
+                from = mPlaylist.size() - 1;
+            }
+            if (to >= mPlaylist.size()) {
+                to = mPlaylist.size() - 1;
+            }
+
+            if (from == to) {
+                return;
+            }
+
+            final MusicPlaybackTrack track = mPlaylist.remove(from);
+            if (from < to) {
+                mPlaylist.add(to, track);
+                if (mPlayPos == from) {
+                    mPlayPos = to;
+                } else if (mPlayPos >= from && mPlayPos <= to) {
+                    mPlayPos--;
+                }
+            } else if (to < from) {
+                mPlaylist.add(to, track);
+                if (mPlayPos == from) {
+                    mPlayPos = to;
+                } else if (mPlayPos >= to && mPlayPos <= from) {
+                    mPlayPos++;
+                }
+            }
+            notifyChange(QUEUE_CHANGED);
+        }
+    }
+
+    /**
+     * Queues a new list for playback
+     *
+     * @param list   The list to queue
+     * @param action The action to take
+     */
+    public void enqueue(final long[] list, final int action, long sourceId, IdType sourceType) {
+        synchronized (this) {
+            if (action == NEXT && mPlayPos + 1 < mPlaylist.size()) {
+                addToPlayList(list, mPlayPos + 1, sourceId, sourceType);
+                mNextPlayPos = mPlayPos + 1;
+                notifyChange(QUEUE_CHANGED);
+            } else {
+                addToPlayList(list, Integer.MAX_VALUE, sourceId, sourceType);
+                notifyChange(QUEUE_CHANGED);
+            }
+
+            if (mPlayPos < 0) {
+                mPlayPos = 0;
+                openCurrentAndNext();
+                play();
+                notifyChange(META_CHANGED);
+            }
+        }
+    }
+
+    /**
+     * Cycles through the different repeat modes
+     */
+    private void cycleRepeat() {
+        if (mRepeatMode == REPEAT_NONE) {
+            setRepeatMode(REPEAT_ALL);
+        } else if (mRepeatMode == REPEAT_ALL) {
+            setRepeatMode(REPEAT_CURRENT);
+            if (mShuffleMode != SHUFFLE_NONE) {
+                setShuffleMode(SHUFFLE_NONE);
+            }
+        } else {
+            setRepeatMode(REPEAT_NONE);
+        }
+    }
+
+    /**
+     * Cycles through the different shuffle modes
+     */
+    private void cycleShuffle() {
+        if (mShuffleMode == SHUFFLE_NONE) {
+            setShuffleMode(SHUFFLE_NORMAL);
+            if (mRepeatMode == REPEAT_CURRENT) {
+                setRepeatMode(REPEAT_ALL);
+            }
+        } else if (mShuffleMode == SHUFFLE_NORMAL || mShuffleMode == SHUFFLE_AUTO) {
+            setShuffleMode(SHUFFLE_NONE);
+        }
+    }
+
+    /**
+     * @param smallBitmap true to return a smaller version of the default artwork image.
+     *                    Currently Has no impact on the artwork size if one exists
+     * @return The album art for the current album.
+     */
+    public BitmapWithColors getAlbumArt(boolean smallBitmap) {
+        final String albumName = getAlbumName();
+        final String artistName = getArtistName();
+        final long albumId = getAlbumId();
+        final String key = albumName + "_" + artistName + "_" + albumId;
+        final int targetIndex = smallBitmap ? 0 : 1;
+
+        // if the cached key matches and we have the bitmap, return it
+        if (key.equals(mCachedKey) && mCachedBitmapWithColors[targetIndex] != null) {
+            return mCachedBitmapWithColors[targetIndex];
+        }
+
+        // otherwise get the artwork (or defaultartwork if none found)
+        final BitmapWithColors bitmap = mImageFetcher.getArtwork(albumName,
+                albumId, artistName, smallBitmap);
+
+        // if the key is different, clear the bitmaps first
+        if (!key.equals(mCachedKey)) {
+            mCachedBitmapWithColors[0] = null;
+            mCachedBitmapWithColors[1] = null;
+        }
+
+        // store the new key and bitmap
+        mCachedKey = key;
+        mCachedBitmapWithColors[targetIndex] = bitmap;
+        return bitmap;
+    }
+
+    /**
+     * Called when one of the lists should refresh or requery.
+     */
+    public void refresh() {
+        notifyChange(REFRESH);
+    }
+
+    /**
+     * Called when one of the playlists have changed (renamed, added/removed tracks)
+     */
+    public void playlistChanged() {
+        notifyChange(PLAYLIST_CHANGED);
+    }
+
+    /**
+     * Called to set the status of shake to play feature
+     */
+    public void setShakeToPlayEnabled(boolean enabled) {
+        if (D) {
+            Log.d(TAG, "ShakeToPlay status: " + enabled);
+        }
+        if (enabled) {
+            if (mShakeDetector == null) {
+                mShakeDetector = new ShakeDetector(mShakeDetectorListener);
+            }
+            // if song is already playing, start listening immediately
+            if (isPlaying()) {
+                startShakeDetector();
+            }
+        } else {
+            stopShakeDetector(true);
+        }
+    }
+
+    /**
+     * Called to set visibility of album art on lockscreen
+     */
+    public void setLockscreenAlbumArt(boolean enabled) {
+        mShowAlbumArtOnLockscreen = enabled;
+        notifyChange(META_CHANGED);
+    }
+
+    /**
+     * Called to start listening to shakes
+     */
+    private void startShakeDetector() {
+        if (mShakeDetector != null) {
+            mShakeDetector.start((SensorManager) getSystemService(SENSOR_SERVICE));
+        }
+    }
+
+    /**
+     * Called to stop listening to shakes
+     */
+    private void stopShakeDetector(final boolean destroyShakeDetector) {
+        if (mShakeDetector != null) {
+            mShakeDetector.stop();
+        }
+        if (destroyShakeDetector) {
+            mShakeDetector = null;
+            if (D) {
+                Log.d(TAG, "ShakeToPlay destroyed!!!");
+            }
+        }
+    }
+
+    public interface TrackErrorExtra {
+        /**
+         * Name of the track that was unable to play
+         */
+        public static final String TRACK_NAME = "trackname";
+    }
+
+    ;
+
+    private static final class MusicPlayerHandler extends Handler {
+        private final WeakReference<MusicPlaybackService> mService;
+        private float mCurrentVolume = 1.0f;
+
+        /**
+         * Constructor of <code>MusicPlayerHandler</code>
+         *
+         * @param service The service to use.
+         * @param looper  The thread to run on.
+         */
+        public MusicPlayerHandler(final MusicPlaybackService service, final Looper looper) {
+            super(looper);
+            mService = new WeakReference<MusicPlaybackService>(service);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void handleMessage(final Message msg) {
+            final MusicPlaybackService service = mService.get();
+            if (service == null) {
+                return;
+            }
+
+            synchronized (service) {
+                switch (msg.what) {
+                    case FADEDOWN:
+                        mCurrentVolume -= .05f;
+                        if (mCurrentVolume > .2f) {
+                            sendEmptyMessageDelayed(FADEDOWN, 10);
+                        } else {
+                            mCurrentVolume = .2f;
+                        }
+                        service.mPlayer.setVolume(mCurrentVolume);
+                        break;
+                    case FADEUP:
+                        mCurrentVolume += .01f;
+                        if (mCurrentVolume < 1.0f) {
+                            sendEmptyMessageDelayed(FADEUP, 10);
+                        } else {
+                            mCurrentVolume = 1.0f;
+                        }
+                        service.mPlayer.setVolume(mCurrentVolume);
+                        break;
+                    case SERVER_DIED:
+                        if (service.isPlaying()) {
+                            final TrackErrorInfo info = (TrackErrorInfo) msg.obj;
+                            service.sendErrorMessage(info.mTrackName);
+
+                            // since the service isPlaying(), we only need to remove the offending
+                            // audio track, and the code will automatically play the next track
+                            service.removeTrack(info.mId);
+                        } else {
+                            service.openCurrentAndNext();
+                        }
+                        break;
+                    case TRACK_WENT_TO_NEXT:
+                        service.setAndRecordPlayPos(service.mNextPlayPos);
+                        service.setNextTrack();
+                        if (service.mCursor != null) {
+                            service.mCursor.close();
+                            service.mCursor = null;
+                        }
+                        service.updateCursor(service.mPlaylist.get(service.mPlayPos).mId);
+                        service.notifyChange(META_CHANGED);
+                        service.updateNotification();
+                        break;
+                    case TRACK_ENDED:
+                        if (service.mRepeatMode == REPEAT_CURRENT) {
+                            service.seek(0);
+                            service.play();
+                        } else {
+                            service.gotoNext(false);
+                        }
+                        break;
+                    case LYRICS:
+                        service.mLyrics = (String) msg.obj;
+                        service.notifyChange(NEW_LYRICS);
+                        break;
+                    case FOCUSCHANGE:
+                        if (D) Log.d(TAG, "Received audio focus change event " + msg.arg1);
+                        switch (msg.arg1) {
+                            case AudioManager.AUDIOFOCUS_LOSS:
+                            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
+                                if (service.isPlaying()) {
+                                    service.mPausedByTransientLossOfFocus =
+                                            msg.arg1 == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT;
+                                }
+                                service.pause();
+                                break;
+                            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
+                                removeMessages(FADEUP);
+                                sendEmptyMessage(FADEDOWN);
+                                break;
+                            case AudioManager.AUDIOFOCUS_GAIN:
+                                if (!service.isPlaying()
+                                        && service.mPausedByTransientLossOfFocus) {
+                                    service.mPausedByTransientLossOfFocus = false;
+                                    mCurrentVolume = 0f;
+                                    service.mPlayer.setVolume(mCurrentVolume);
+                                    service.play();
+                                } else {
+                                    removeMessages(FADEDOWN);
+                                    sendEmptyMessage(FADEUP);
+                                }
+                                break;
+                            default:
+                        }
+                        break;
+                    default:
+                        break;
+                }
+            }
+        }
+    }
+
+    private static final class Shuffler {
+
+        private final LinkedList<Integer> mHistoryOfNumbers = new LinkedList<Integer>();
+
+        private final TreeSet<Integer> mPreviousNumbers = new TreeSet<Integer>();
+
+        private final Random mRandom = new Random();
+
+        private int mPrevious;
+
+        /**
+         * Constructor of <code>Shuffler</code>
+         */
+        public Shuffler() {
+            super();
+        }
+
+        /**
+         * @param interval The length the queue
+         * @return The position of the next track to play
+         */
+        public int nextInt(final int interval) {
+            int next;
+            do {
+                next = mRandom.nextInt(interval);
+            } while (next == mPrevious && interval > 1
+                    && !mPreviousNumbers.contains(Integer.valueOf(next)));
+            mPrevious = next;
+            mHistoryOfNumbers.add(mPrevious);
+            mPreviousNumbers.add(mPrevious);
+            cleanUpHistory();
+            return next;
+        }
+
+        /**
+         * Removes old tracks and cleans up the history preparing for new tracks
+         * to be added to the mapping
+         */
+        private void cleanUpHistory() {
+            if (!mHistoryOfNumbers.isEmpty() && mHistoryOfNumbers.size() >= MAX_HISTORY_SIZE) {
+                for (int i = 0; i < Math.max(1, MAX_HISTORY_SIZE / 2); i++) {
+                    mPreviousNumbers.remove(mHistoryOfNumbers.removeFirst());
+                }
+            }
+        }
+    }
+
+    private static final class TrackErrorInfo {
+        public long mId;
+        public String mTrackName;
+
+        public TrackErrorInfo(long id, String trackName) {
+            mId = id;
+            mTrackName = trackName;
+        }
+    }
+
+    private static final class MultiPlayer2 implements ExoPlayer.EventListener {
+        private final WeakReference<MusicPlaybackService> mService;
+        private SrtManager mSrtManager;
+        private Handler mHandler;
+
+        private SimpleExoPlayer mCurrentMediaPlayer;
+        private String mNextMediaPath;
+        private boolean mIsInitailized;
+
+        public MultiPlayer2(final MusicPlaybackService service) {
+
+            if (service == null) {
+                throw new IllegalArgumentException();
+            }
+
+            mService = new WeakReference<MusicPlaybackService>(service);
+            mSrtManager = new SrtManager() {
+                @Override
+                public void onTimedText(String text) {
+                    if (mHandler != null) {
+                        mHandler.obtainMessage(LYRICS, text).sendToTarget();
+                    }
+                }
+            };
+
+            createExoPlayer(service.getApplicationContext());
+        }
+
+        private void createExoPlayer(Context context) {
+            // 1. Create a default TrackSelector
+            Handler mainHandler = new Handler();
+            BandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
+            TrackSelection.Factory videoTrackSelectionFactory =
+                    new AdaptiveTrackSelection.Factory(bandwidthMeter);
+            TrackSelector trackSelector =
+                    new DefaultTrackSelector(videoTrackSelectionFactory);
+
+            // 2. Create a default LoadControl
+            LoadControl loadControl = new DefaultLoadControl();
+            // 3. Create the player
+            mCurrentMediaPlayer =
+                    ExoPlayerFactory.newSimpleInstance(context, trackSelector, loadControl);
+            mCurrentMediaPlayer.addListener(this);
+        }
+
+        /**
+         * Sets the handler
+         *
+         * @param handler The handler to use
+         */
+        public void setHandler(final Handler handler) {
+            mHandler = handler;
+        }
+
+        /**
+         * Releases resources associated with this MediaPlayer object.
+         */
+        public void release() {
+            mCurrentMediaPlayer.release();
+            mSrtManager.release();
+            mSrtManager = null;
+        }
+
+        /**
+         * Resets the MediaPlayer to its uninitialized state.
+         */
+        public void stop() {
+            mCurrentMediaPlayer.stop();
+            mSrtManager.reset();
+        }
+
+        /**
+         * @return True if the player is ready to go, false otherwise
+         */
+        public boolean isInitialized() {
+            return (mCurrentMediaPlayer.getPlaybackState() == ExoPlayer.STATE_READY) || mIsInitailized;
+        }
+
+        /**
+         * Set the MediaPlayer to start when this MediaPlayer finishes playback.
+         *
+         * @param path The path of the file, or the http/rtsp URL of the stream
+         *             you want to play
+         */
+        public void setNextDataSource(final String path) {
+            mNextMediaPath = path;
+        }
+
+        /**
+         * Gets the current playback position.
+         *
+         * @return The current position in milliseconds
+         */
+        public long position() {
+            return mCurrentMediaPlayer.getCurrentPosition();
+        }
+
+        /**
+         * @param path The path of the file, or the http/rtsp URL of the stream
+         *             you want to play
+         */
+        public void setDataSource(final String path) {
+            boolean isInitialized = setDataSourceImpl(mCurrentMediaPlayer, path);
+            if (isInitialized) {
+                loadSrt(path);
+                setNextDataSource(null);
+                mIsInitailized = true;
+            }
+        }
+
+
+        private void loadSrt(final String path) {
+            mSrtManager.reset();
+
+            Uri uri = Uri.parse(path);
+            String filePath = null;
+
+            if (path.startsWith("content://")) {
+                // resolve the content resolver path to a file path
+                Cursor cursor = null;
+                try {
+                    final String[] proj = {MediaStore.Audio.Media.DATA};
+                    cursor = mService.get().getContentResolver().query(uri, proj,
+                            null, null, null);
+                    if (cursor != null && cursor.moveToFirst()) {
+                        filePath = cursor.getString(0);
+                    }
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                        cursor = null;
+                    }
+                }
+            } else {
+                filePath = uri.getPath();
+            }
+
+            if (!TextUtils.isEmpty(filePath)) {
+                final int lastIndex = filePath.lastIndexOf('.');
+                if (lastIndex != -1) {
+                    String newPath = filePath.substring(0, lastIndex) + ".srt";
+                    final File f = new File(newPath);
+
+                    mSrtManager.initialize(mCurrentMediaPlayer, f);
+                }
+            }
+        }
+
+        /**
+         * Starts or resumes playback.
+         */
+        public void start() {
+            mCurrentMediaPlayer.setPlayWhenReady(true);
+            mSrtManager.play();
+        }
+
+        /**
+         * Gets the duration of the file.
+         *
+         * @return The duration in milliseconds
+         */
+        public long duration() {
+
+            long duration = mCurrentMediaPlayer.getDuration();
+
+            if (duration == C.TIME_UNSET) {
+                return 0;
+            }
+
+            return duration;
+        }
+
+        /**
+         * Pauses playback. Call start() to resume.
+         */
+        public void pause() {
+            mCurrentMediaPlayer.setPlayWhenReady(false);
+            mSrtManager.pause();
+        }
+
+        /**
+         * Sets the volume on this player.
+         *
+         * @param vol Left and right volume scalar
+         */
+        public void setVolume(final float vol) {
+            mCurrentMediaPlayer.setVolume(vol);
+        }
+
+        /**
+         * @param player The {@link MediaPlayer} to use
+         * @param path   The path of the file, or the http/rtsp URL of the stream
+         *               you want to play
+         * @return True if the <code>player</code> has been prepared and is
+         * ready to play, false otherwise
+         */
+        private boolean setDataSourceImpl(final ExoPlayer player, final String path) {
+            try {
+                Context context = mService.get().getApplicationContext();
+                // Measures bandwidth during playback. Can be null if not required.
+                DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
+                // Produces DataSource instances through which media data is loaded.
+                DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(context,
+                        Util.getUserAgent(context, "yourApplicationName"), bandwidthMeter);
+                // Produces Extractor instances for parsing the media data.
+                ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory();
+                // This is the MediaSource representing the media to be played.
+                MediaSource mediaSource = new ExtractorMediaSource(Uri.parse(path),
+                        dataSourceFactory, extractorsFactory, null, null);
+
+                player.prepare(mediaSource);
+
+
+            } catch (final IllegalArgumentException todo) {
+                // TODO: notify the user why the file couldn't be opened
+                return false;
+            }
+            return true;
+        }
+
+
+        public long seek(long whereto) {
+            mCurrentMediaPlayer.seekTo(whereto);
+            mSrtManager.seekTo(whereto);
+            return whereto;
+        }
+
+        public int getAudioSessionId() {
+            return 0;
+        }
+
+        @Override
+        public void onTimelineChanged(Timeline timeline, Object manifest) {
+
+        }
+
+        @Override
+        public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
+
+        }
+
+        @Override
+        public void onLoadingChanged(boolean isLoading) {
+
+        }
+
+        @Override
+        public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+            if (playbackState == ExoPlayer.STATE_ENDED) {
+                if (mNextMediaPath != null) {
+                    setDataSourceImpl(mCurrentMediaPlayer, mNextMediaPath);
+                    loadSrt(mNextMediaPath);
+                    mNextMediaPath = null;
+                    mHandler.sendEmptyMessage(TRACK_WENT_TO_NEXT);
+                } else {
+                    mHandler.sendEmptyMessage(TRACK_ENDED);
+                }
+            }
+        }
+
+        @Override
+        public void onPlayerError(ExoPlaybackException error) {
+
+        }
+
+        @Override
+        public void onPositionDiscontinuity() {
+
+        }
+
+        @Override
+        public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
+
+        }
+
+    }
+
+    private static final class ServiceStub extends IElevenService.Stub {
+
+        private final WeakReference<MusicPlaybackService> mService;
+
+        private ServiceStub(final MusicPlaybackService service) {
+            mService = new WeakReference<MusicPlaybackService>(service);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void openFile(final String path) throws RemoteException {
+            mService.get().openFile(path);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void open(final long[] list, final int position, long sourceId, int sourceType)
+                throws RemoteException {
+            mService.get().open(list, position, sourceId, IdType.getTypeById(sourceType));
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void stop() throws RemoteException {
+            mService.get().stop();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void pause() throws RemoteException {
+            mService.get().pause();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void play() throws RemoteException {
+            mService.get().play();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void prev(boolean forcePrevious) throws RemoteException {
+            mService.get().prev(forcePrevious);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void next() throws RemoteException {
+            mService.get().gotoNext(true);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void enqueue(final long[] list, final int action, long sourceId, int sourceType)
+                throws RemoteException {
+            mService.get().enqueue(list, action, sourceId, IdType.getTypeById(sourceType));
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void moveQueueItem(final int from, final int to) throws RemoteException {
+            mService.get().moveQueueItem(from, to);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void refresh() throws RemoteException {
+            mService.get().refresh();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void playlistChanged() throws RemoteException {
+            mService.get().playlistChanged();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean isPlaying() throws RemoteException {
+            return mService.get().isPlaying();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long[] getQueue() throws RemoteException {
+            return mService.get().getQueue();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long getQueueItemAtPosition(int position) throws RemoteException {
+            return mService.get().getQueueItemAtPosition(position);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getQueueSize() throws RemoteException {
+            return mService.get().getQueueSize();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getQueueHistoryPosition(int position) throws RemoteException {
+            return mService.get().getQueueHistoryPosition(position);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getQueueHistorySize() throws RemoteException {
+            return mService.get().getQueueHistorySize();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int[] getQueueHistoryList() throws RemoteException {
+            return mService.get().getQueueHistoryList();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long duration() throws RemoteException {
+            return mService.get().duration();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long position() throws RemoteException {
+            return mService.get().position();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long seek(final long position) throws RemoteException {
+            return mService.get().seek(position);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void seekRelative(final long deltaInMs) throws RemoteException {
+            mService.get().seekRelative(deltaInMs);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long getAudioId() throws RemoteException {
+            return mService.get().getAudioId();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public MusicPlaybackTrack getCurrentTrack() throws RemoteException {
+            return mService.get().getCurrentTrack();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public MusicPlaybackTrack getTrack(int index) throws RemoteException {
+            return mService.get().getTrack(index);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long getNextAudioId() throws RemoteException {
+            return mService.get().getNextAudioId();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long getPreviousAudioId() throws RemoteException {
+            return mService.get().getPreviousAudioId();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long getArtistId() throws RemoteException {
+            return mService.get().getArtistId();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public long getAlbumId() throws RemoteException {
+            return mService.get().getAlbumId();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String getArtistName() throws RemoteException {
+            return mService.get().getArtistName();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String getTrackName() throws RemoteException {
+            return mService.get().getTrackName();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String getAlbumName() throws RemoteException {
+            return mService.get().getAlbumName();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String getPath() throws RemoteException {
+            return mService.get().getPath();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getQueuePosition() throws RemoteException {
+            return mService.get().getQueuePosition();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void setQueuePosition(final int index) throws RemoteException {
+            mService.get().setQueuePosition(index);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getShuffleMode() throws RemoteException {
+            return mService.get().getShuffleMode();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void setShuffleMode(final int shufflemode) throws RemoteException {
+            mService.get().setShuffleMode(shufflemode);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getRepeatMode() throws RemoteException {
+            return mService.get().getRepeatMode();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void setRepeatMode(final int repeatmode) throws RemoteException {
+            mService.get().setRepeatMode(repeatmode);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int removeTracks(final int first, final int last) throws RemoteException {
+            return mService.get().removeTracks(first, last);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int removeTrack(final long id) throws RemoteException {
+            return mService.get().removeTrack(id);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean removeTrackAtPosition(final long id, final int position)
+                throws RemoteException {
+            return mService.get().removeTrackAtPosition(id, position);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getMediaMountedCount() throws RemoteException {
+            return mService.get().getMediaMountedCount();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int getAudioSessionId() throws RemoteException {
+            return mService.get().getAudioSessionId();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void setShakeToPlayEnabled(boolean enabled) {
+            mService.get().setShakeToPlayEnabled(enabled);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void setLockscreenAlbumArt(boolean enabled) {
+            mService.get().setLockscreenAlbumArt(enabled);
+        }
+
+    }
+
+    private class MediaStoreObserver extends ContentObserver implements Runnable {
+        // milliseconds to delay before calling refresh to aggregate events
+        private static final long REFRESH_DELAY = 500;
+        private Handler mHandler;
+
+        public MediaStoreObserver(Handler handler) {
+            super(handler);
+            mHandler = handler;
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            // if a change is detected, remove any scheduled callback
+            // then post a new one. This is intended to prevent closely
+            // spaced events from generating multiple refresh calls
+            mHandler.removeCallbacks(this);
+            mHandler.postDelayed(this, REFRESH_DELAY);
+        }
+
+        @Override
+        public void run() {
+            // actually call refresh when the delayed callback fires
+            Log.e("ELEVEN", "calling refresh!");
+            refresh();
+        }
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/MusicStateListener.java b/twelve/src/main/java/com/dolzzo/twelve/MusicStateListener.java
new file mode 100755
index 0000000000..7f1ae20d80
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/MusicStateListener.java
@@ -0,0 +1,38 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve;
+
+/**
+ * Listens for playback changes to send the the fragments bound to this activity
+ */
+public interface MusicStateListener {
+
+    /**
+     * Called when {@link MusicPlaybackService#REFRESH} is invoked
+     */
+    public void restartLoader();
+
+    /**
+     * Called when {@link MusicPlaybackService#PLAYLIST_CHANGED} is invoked
+     */
+    public void onPlaylistChanged();
+
+    /**
+     * Called when {@link MusicPlaybackService#META_CHANGED} is invoked
+     */
+    public void onMetaChanged();
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/AlbumAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/AlbumAdapter.java
new file mode 100755
index 0000000000..b2c26382f2
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/AlbumAdapter.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.adapters;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.BaseAdapter;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.model.Album;
+import com.dolzzo.twelve.ui.MusicHolder;
+import com.dolzzo.twelve.ui.MusicHolder.DataHolder;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * This {@link ArrayAdapter} is used to display all of the albums on a user's
+ * device for {@link RecentsFragment} and {@link AlbumsFragment}.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class AlbumAdapter extends BaseAdapter implements IPopupMenuCallback {
+    /**
+     * The resource Id of the layout to inflate
+     */
+    private final int mLayoutId;
+
+    /**
+     * Image cache and image fetcher
+     */
+    private final ImageFetcher mImageFetcher;
+
+    /**
+     * Used to cache the album info
+     */
+    private DataHolder[] mData = new DataHolder[0];
+    private List<Album> mAlbums = Collections.emptyList();
+
+    /**
+     * Used to listen to the pop up menu callbacks
+     */
+    private IPopupMenuCallback.IListener mListener;
+
+    /**
+     * number of columns of containing grid view,
+     * used to determine which views to pad
+     */
+    private int mColumns;
+    private int mPadding;
+
+    private Context mContext;
+
+    /**
+     * Constructor of <code>AlbumAdapter</code>
+     *
+     * @param context  The {@link Context} to use.
+     * @param layoutId The resource Id of the view to inflate.
+     * @param style    Determines which layout to use and therefore which items to
+     *                 load.
+     */
+    public AlbumAdapter(final Activity context, final int layoutId) {
+        mContext = context;
+        // Get the layout Id
+        mLayoutId = layoutId;
+        // Initialize the cache & image fetcher
+        mImageFetcher = ApolloUtils.getImageFetcher(context);
+        mPadding = context.getResources().getDimensionPixelSize(R.dimen.list_item_general_margin);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View getView(final int position, View convertView, final ViewGroup parent) {
+        // Recycle ViewHolder's items
+        MusicHolder holder;
+        if (convertView == null) {
+            convertView = LayoutInflater.from(mContext).inflate(mLayoutId, parent, false);
+            holder = new MusicHolder(convertView);
+            convertView.setTag(holder);
+            // set the pop up menu listener
+            holder.mPopupMenuButton.get().setPopupMenuClickedListener(mListener);
+        } else {
+            holder = (MusicHolder) convertView.getTag();
+        }
+
+        adjustPadding(position, convertView);
+
+        // Retrieve the data holder
+        final DataHolder dataHolder = mData[position];
+
+        // Sets the position each time because of recycling
+        holder.mPopupMenuButton.get().setPosition(position);
+        // Set each album name (line one)
+        holder.mLineOne.get().setText(dataHolder.mLineOne);
+        // Set the artist name (line two)
+        holder.mLineTwo.get().setText(dataHolder.mLineTwo);
+        // Asynchronously load the album images into the adapter
+        mImageFetcher.loadAlbumImage(
+                dataHolder.mLineTwo, dataHolder.mLineOne,
+                dataHolder.mItemId, holder.mImage.get());
+
+        return convertView;
+    }
+
+    private void adjustPadding(final int position, View convertView) {
+        if (position < mColumns) {
+            // first row
+            convertView.setPadding(0, mPadding, 0, 0);
+            return;
+        }
+        int count = getCount();
+        int footers = count % mColumns;
+        if (footers == 0) {
+            footers = mColumns;
+        }
+        if (position >= (count - footers)) {
+            // last row
+            convertView.setPadding(0, 0, 0, mPadding);
+        } else {
+            // middle rows
+            convertView.setPadding(0, 0, 0, 0);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    @Override
+    public int getCount() {
+        return mAlbums.size();
+    }
+
+    @Override
+    public Album getItem(int pos) {
+        return mAlbums.get(pos);
+    }
+
+    @Override
+    public long getItemId(int pos) {
+        return pos;
+    }
+
+    /**
+     * Method used to cache the data used to populate the list or grid. The idea
+     * is to cache everything before {@code #getView(int, View, ViewGroup)} is
+     * called.
+     */
+    public void buildCache() {
+        mData = new DataHolder[mAlbums.size()];
+        int i = 0;
+        for (Album album : mAlbums) {
+            mData[i] = new DataHolder();
+            mData[i].mItemId = album.mAlbumId;
+            mData[i].mLineOne = album.mAlbumName;
+            mData[i].mLineTwo = album.mArtistName;
+            i++;
+        }
+    }
+
+    public void setData(List<Album> albums) {
+        mAlbums = albums;
+        buildCache();
+        notifyDataSetChanged();
+    }
+
+    public void setNumColumns(int columns) {
+        mColumns = columns;
+    }
+
+    public void unload() {
+        setData(Collections.<Album>emptyList());
+    }
+
+    /**
+     * @param pause True to temporarily pause the disk cache, false otherwise.
+     */
+    public void setPauseDiskCache(final boolean pause) {
+        if (mImageFetcher != null) {
+            mImageFetcher.setPauseDiskCache(pause);
+        }
+    }
+
+    /**
+     * @param album The key used to find the cached album to remove
+     */
+    public void removeFromCache(final Album album) {
+        if (mImageFetcher != null) {
+            mImageFetcher.removeFromCache(
+                    ImageFetcher.generateAlbumCacheKey(album.mAlbumName, album.mArtistName));
+        }
+    }
+
+    /**
+     * Flushes the disk cache.
+     */
+    public void flush() {
+        mImageFetcher.flush();
+    }
+
+    /**
+     * Gets the item position for a given id
+     *
+     * @param id identifies the object
+     * @return the position if found, -1 otherwise
+     */
+    public int getItemPosition(long id) {
+        int i = 0;
+        for (Album album : mAlbums) {
+            if (album.mAlbumId == id) {
+                return i;
+            }
+            i++;
+        }
+
+        return -1;
+    }
+
+    @Override
+    public void setPopupMenuClickedListener(IPopupMenuCallback.IListener listener) {
+        mListener = listener;
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/AlbumArtPagerAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/AlbumArtPagerAdapter.java
new file mode 100755
index 0000000000..52ec8cc266
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/AlbumArtPagerAdapter.java
@@ -0,0 +1,291 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.dolzzo.twelve.adapters;
+
+import android.content.Context;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentStatePagerAdapter;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ICacheListener;
+import com.dolzzo.twelve.cache.ImageCache;
+import com.dolzzo.twelve.model.AlbumArtistDetails;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.SquareImageView;
+
+import java.util.Iterator;
+import java.util.LinkedList;
+
+/**
+ * A {@link android.support.v4.app.FragmentStatePagerAdapter} class for swiping between album art
+ */
+public class AlbumArtPagerAdapter extends FragmentStatePagerAdapter {
+    public static final long NO_TRACK_ID = -1;
+    private static final String TAG = AlbumArtPagerAdapter.class.getSimpleName();
+    private static final int MAX_ALBUM_ARTIST_SIZE = 10;
+    // This helps with flickering and jumping and reloading the same tracks
+    private final static LinkedList<AlbumArtistDetails> sCacheAlbumArtistDetails = new LinkedList<AlbumArtistDetails>();
+    private static boolean DEBUG = false;
+    // the length of the playlist
+    private int mPlaylistLen = 0;
+
+    public AlbumArtPagerAdapter(FragmentManager fm) {
+        super(fm);
+    }
+
+    /**
+     * Adds the album artist details to the cache
+     *
+     * @param details the AlbumArtistDetails to add
+     */
+    public static void addAlbumArtistDetails(AlbumArtistDetails details) {
+        if (getAlbumArtistDetails(details.mAudioId) == null) {
+            sCacheAlbumArtistDetails.add(details);
+            if (sCacheAlbumArtistDetails.size() > MAX_ALBUM_ARTIST_SIZE) {
+                sCacheAlbumArtistDetails.remove();
+            }
+        }
+    }
+
+    /**
+     * Gets the album artist details for the audio track.  If it exists, it re-inserts the item
+     * to the end of the queue so it is considered the 'freshest' and stays longer
+     *
+     * @param audioId the audio track to look for
+     * @return the details of the album artist
+     */
+    public static AlbumArtistDetails getAlbumArtistDetails(long audioId) {
+        for (Iterator<AlbumArtistDetails> i = sCacheAlbumArtistDetails.descendingIterator(); i.hasNext(); ) {
+            final AlbumArtistDetails entry = i.next();
+            if (entry.mAudioId == audioId) {
+                // remove it from the stack to re-add to the top
+                i.remove();
+                sCacheAlbumArtistDetails.add(entry);
+                return entry;
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public Fragment getItem(final int position) {
+        long trackID = getTrackId(position);
+        return AlbumArtFragment.newInstance(trackID);
+    }
+
+    @Override
+    public int getCount() {
+        return mPlaylistLen;
+    }
+
+    public void setPlaylistLength(final int len) {
+        mPlaylistLen = len;
+        notifyDataSetChanged();
+    }
+
+    /**
+     * Gets the track id for the item at position
+     *
+     * @param position position of the item of the queue
+     * @return track id of the item at position or NO_TRACK_ID if unknown
+     */
+    private long getTrackId(int position) {
+        if (MusicUtils.getRepeatMode() == MusicPlaybackService.REPEAT_CURRENT) {
+            // if we are only playing one song, return the current audio id
+            return MusicUtils.getCurrentAudioId();
+        } else if (MusicUtils.getShuffleMode() == MusicPlaybackService.SHUFFLE_NONE) {
+            // if we aren't shuffling, just return based on the queue position
+            // add a check for empty queue
+            return MusicUtils.getQueueItemAtPosition(position);
+        } else {
+            // if we are shuffling, there is no 'queue' going forward per say
+            // because it is dynamically generated.  In that case we can only look
+            // at the history and up to the very next track.  When we come back to this
+            // after the demo, we should redo that queue logic to be able to give us
+            // tracks going forward
+
+            // how far into the history we are
+            int positionOffset = MusicUtils.getQueueHistorySize();
+
+            if (position - positionOffset == 0) { // current track
+                return MusicUtils.getCurrentAudioId();
+            } else if (position - positionOffset == 1) { // next track
+                return MusicUtils.getNextAudioId();
+            } else if (position < positionOffset) {
+                int queuePosition = MusicUtils.getQueueHistoryPosition(position);
+                if (position >= 0) {
+                    return MusicUtils.getQueueItemAtPosition(queuePosition);
+                }
+            }
+        }
+
+        // fallback case
+        return NO_TRACK_ID;
+    }
+
+    /**
+     * The fragments to be displayed inside this adapter.  This wraps the album art
+     * and handles loading the album art for a given audio id
+     */
+    public static class AlbumArtFragment extends Fragment implements ICacheListener {
+        private static final String ID = "com.dolzzo.twelve.adapters.AlbumArtPagerAdapter.AlbumArtFragment.ID";
+
+        private View mRootView;
+        private AlbumArtistLoader mTask;
+        private SquareImageView mImageView;
+        private long mAudioId = NO_TRACK_ID;
+
+        public static AlbumArtFragment newInstance(final long trackId) {
+            AlbumArtFragment frag = new AlbumArtFragment();
+            final Bundle args = new Bundle();
+            args.putLong(ID, trackId);
+            frag.setArguments(args);
+            return frag;
+        }
+
+        @Override
+        public void onCreate(final Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+
+            mAudioId = getArguments().getLong(ID, NO_TRACK_ID);
+            ImageCache.getInstance(getActivity()).addCacheListener(this);
+        }
+
+        @Override
+        public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) {
+            mRootView = inflater.inflate(R.layout.album_art_fragment, null);
+            return mRootView;
+        }
+
+        @Override
+        public void onDestroy() {
+            super.onDestroy();
+
+            ImageCache.getInstance(getActivity()).removeCacheListener(this);
+        }
+
+        @Override
+        public void onDestroyView() {
+            super.onDestroyView();
+
+            // if we are destroying our view, cancel our task and null it
+            if (mTask != null) {
+                mTask.cancel(true);
+                mTask = null;
+            }
+        }
+
+        @Override
+        public void onActivityCreated(final Bundle savedInstanceState) {
+            super.onActivityCreated(savedInstanceState);
+            mImageView = (SquareImageView) mRootView.findViewById(R.id.audio_player_album_art);
+            loadImageAsync();
+        }
+
+        /**
+         * Loads the image asynchronously
+         */
+        private void loadImageAsync() {
+            // if we have no track id, quit
+            if (mAudioId == NO_TRACK_ID) {
+                return;
+            }
+
+            // try loading from the cache
+            AlbumArtistDetails details = getAlbumArtistDetails(mAudioId);
+            if (details != null) {
+                loadImageAsync(details);
+            } else {
+                // Cancel any previous tasks
+                if (mTask != null) {
+                    mTask.cancel(true);
+                    mTask = null;
+                }
+
+                mTask = new AlbumArtistLoader(this, getActivity());
+                ApolloUtils.execute(false, mTask, mAudioId);
+            }
+
+        }
+
+        /**
+         * Loads the image asynchronously
+         *
+         * @param details details of the image to load
+         */
+        private void loadImageAsync(AlbumArtistDetails details) {
+            // load the actual image
+            ApolloUtils.getImageFetcher(getActivity()).loadAlbumImage(
+                    details.mArtistName,
+                    details.mAlbumName,
+                    details.mAlbumId,
+                    mImageView
+            );
+        }
+
+        @Override
+        public void onCacheUnpaused() {
+            loadImageAsync();
+        }
+    }
+
+    /**
+     * This looks up the album and artist details for a track
+     */
+    private static class AlbumArtistLoader extends AsyncTask<Long, Void, AlbumArtistDetails> {
+        private Context mContext;
+        private AlbumArtFragment mFragment;
+
+        public AlbumArtistLoader(final AlbumArtFragment albumArtFragment, final Context context) {
+            mContext = context;
+            mFragment = albumArtFragment;
+        }
+
+        @Override
+        protected AlbumArtistDetails doInBackground(final Long... params) {
+            long id = params[0];
+            return MusicUtils.getAlbumArtDetails(mContext, id);
+        }
+
+        @Override
+        protected void onPostExecute(final AlbumArtistDetails result) {
+            if (result != null) {
+                if (DEBUG) {
+                    Log.d(TAG, "[" + mFragment.mAudioId + "] Loading image: "
+                            + result.mAlbumId + ","
+                            + result.mAlbumName + ","
+                            + result.mArtistName);
+                }
+
+                AlbumArtPagerAdapter.addAlbumArtistDetails(result);
+                mFragment.loadImageAsync(result);
+            } else if (DEBUG) {
+                Log.d(TAG, "No Image found for audioId: " + mFragment.mAudioId);
+            }
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/AlbumDetailSongAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/AlbumDetailSongAdapter.java
new file mode 100755
index 0000000000..e633adb957
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/AlbumDetailSongAdapter.java
@@ -0,0 +1,83 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.adapters;
+
+import android.app.Activity;
+import android.content.Context;
+import android.os.Bundle;
+import android.support.v4.content.Loader;
+import android.view.View;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.loaders.AlbumSongLoader;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.ui.fragments.AlbumDetailFragment;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+import java.util.List;
+
+public abstract class AlbumDetailSongAdapter extends DetailSongAdapter {
+    private AlbumDetailFragment mFragment;
+
+    public AlbumDetailSongAdapter(Activity activity, AlbumDetailFragment fragment) {
+        super(activity);
+        mFragment = fragment;
+    }
+
+    protected int rowLayoutId() {
+        return R.layout.album_detail_song;
+    }
+
+    protected Config.IdType getSourceType() {
+        return Config.IdType.Album;
+    }
+
+    @Override // LoaderCallbacks
+    public Loader<List<Song>> onCreateLoader(int id, Bundle args) {
+        onLoading();
+        setSourceId(args.getLong(Config.ID));
+        return new AlbumSongLoader(mActivity, getSourceId());
+    }
+
+    @Override // LoaderCallbacks
+    public void onLoadFinished(Loader<List<Song>> loader, List<Song> songs) {
+        super.onLoadFinished(loader, songs);
+        mFragment.update(songs);
+    }
+
+    protected Holder newHolder(View root, ImageFetcher fetcher) {
+        return new AlbumHolder(root, fetcher, mActivity);
+    }
+
+    private static class AlbumHolder extends Holder {
+        TextView duration;
+        Context context;
+
+        protected AlbumHolder(View root, ImageFetcher fetcher, Context context) {
+            super(root, fetcher);
+            this.context = context;
+            duration = (TextView) root.findViewById(R.id.duration);
+        }
+
+        protected void update(Song song) {
+            title.setText(song.mSongName);
+            duration.setText(MusicUtils.makeShortTimeString(context, song.mDuration));
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/ArtistAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/ArtistAdapter.java
new file mode 100755
index 0000000000..5434bfadc9
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/ArtistAdapter.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.adapters;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.model.Artist;
+import com.dolzzo.twelve.sectionadapter.SectionAdapter.BasicAdapter;
+import com.dolzzo.twelve.ui.MusicHolder;
+import com.dolzzo.twelve.ui.MusicHolder.DataHolder;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+
+/**
+ * This {@link ArrayAdapter} is used to display all of the artists on a user's
+ * device for {@link ArtistFragment}.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+
+/**
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class ArtistAdapter extends ArrayAdapter<Artist> implements BasicAdapter, IPopupMenuCallback {
+
+    /**
+     * Number of views (ImageView and TextView)
+     */
+    private static final int VIEW_TYPE_COUNT = 2;
+
+    /**
+     * The resource Id of the layout to inflate
+     */
+    private final int mLayoutId;
+
+    /**
+     * Image cache and image fetcher
+     */
+    private final ImageFetcher mImageFetcher;
+
+    /**
+     * Semi-transparent overlay
+     */
+    private final int mOverlay;
+
+    /**
+     * Used to cache the artist info
+     */
+    private DataHolder[] mData;
+
+    /**
+     * Used to listen to the pop up menu callbacks
+     */
+    private IListener mListener;
+
+    /**
+     * Constructor of <code>ArtistAdapter</code>
+     *
+     * @param context  The {@link Context} to use.
+     * @param layoutId The resource Id of the view to inflate.
+     */
+    public ArtistAdapter(final Activity context, final int layoutId) {
+        super(context, 0);
+        // Get the layout Id
+        mLayoutId = layoutId;
+        // Initialize the cache & image fetcher
+        mImageFetcher = ApolloUtils.getImageFetcher(context);
+        // Cache the transparent overlay
+        mOverlay = context.getResources().getColor(R.color.list_item_background);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View getView(final int position, View convertView, final ViewGroup parent) {
+        // Recycle ViewHolder's items
+        MusicHolder holder;
+        if (convertView == null) {
+            convertView = LayoutInflater.from(getContext()).inflate(mLayoutId, parent, false);
+            holder = new MusicHolder(convertView);
+            convertView.setTag(holder);
+
+            // set the pop up menu listener
+            holder.mPopupMenuButton.get().setPopupMenuClickedListener(mListener);
+        } else {
+            holder = (MusicHolder) convertView.getTag();
+        }
+
+        // Retrieve the data holder
+        final DataHolder dataHolder = mData[position];
+
+        // Set each artist name (line one)
+        holder.mLineOne.get().setText(dataHolder.mLineOne);
+        // Set the number of albums (line two)
+        holder.mLineTwo.get().setText(dataHolder.mLineTwo);
+        // Asynchronously load the artist image into the adapter
+        mImageFetcher.loadArtistImage(dataHolder.mLineOne, holder.mImage.get());
+        // because of recycling, we need to set the position each time
+        holder.mPopupMenuButton.get().setPosition(position);
+
+        return convertView;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getViewTypeCount() {
+        return VIEW_TYPE_COUNT;
+    }
+
+    /**
+     * Method used to cache the data used to populate the list or grid. The idea
+     * is to cache everything before {@code #getView(int, View, ViewGroup)} is
+     * called.
+     */
+    public void buildCache() {
+        mData = new DataHolder[getCount()];
+        for (int i = 0; i < getCount(); i++) {
+            // Build the artist
+            final Artist artist = getItem(i);
+
+            // Build the data holder
+            mData[i] = new DataHolder();
+            // Artist Id
+            mData[i].mItemId = artist.mArtistId;
+            // Artist names (line one)
+            mData[i].mLineOne = artist.mArtistName;
+
+            String albumNumber = MusicUtils.makeLabel(getContext(),
+                    R.plurals.Nalbums, artist.mAlbumNumber);
+            String songNumber = MusicUtils.makeLabel(getContext(),
+                    R.plurals.Nsongs, artist.mSongNumber);
+
+            mData[i].mLineTwo = MusicUtils.makeCombinedString(getContext(), albumNumber, songNumber);
+        }
+    }
+
+    /**
+     * Method that unloads and clears the items in the adapter
+     */
+    public void unload() {
+        clear();
+        mData = null;
+    }
+
+    /**
+     * @param pause True to temporarily pause the disk cache, false otherwise.
+     */
+    public void setPauseDiskCache(final boolean pause) {
+        if (mImageFetcher != null) {
+            mImageFetcher.setPauseDiskCache(pause);
+        }
+    }
+
+    /**
+     * @param artist The key used to find the cached artist to remove
+     */
+    public void removeFromCache(final Artist artist) {
+        if (mImageFetcher != null) {
+            mImageFetcher.removeFromCache(artist.mArtistName);
+        }
+    }
+
+    /**
+     * Flushes the disk cache.
+     */
+    public void flush() {
+        mImageFetcher.flush();
+    }
+
+    /**
+     * Gets the item position for a given id
+     *
+     * @param id identifies the object
+     * @return the position if found, -1 otherwise
+     */
+    @Override
+    public int getItemPosition(long id) {
+        for (int i = 0; i < getCount(); i++) {
+            if (getItem(i).mArtistId == id) {
+                return i;
+            }
+        }
+
+        return -1;
+    }
+
+    @Override
+    public void setPopupMenuClickedListener(IListener listener) {
+        mListener = listener;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/ArtistDetailAlbumAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/ArtistDetailAlbumAdapter.java
new file mode 100755
index 0000000000..7e84896e24
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/ArtistDetailAlbumAdapter.java
@@ -0,0 +1,159 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.adapters;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.Loader;
+import android.support.v7.widget.RecyclerView;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.loaders.AlbumLoader;
+import com.dolzzo.twelve.model.Album;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.NavUtils;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.PopupMenuButton;
+
+import java.util.Collections;
+import java.util.List;
+
+public class ArtistDetailAlbumAdapter
+        extends RecyclerView.Adapter<ArtistDetailAlbumAdapter.ViewHolder>
+        implements LoaderCallbacks<List<Album>>, IPopupMenuCallback {
+    private static final int TYPE_FIRST = 1;
+    private static final int TYPE_MIDDLE = 2;
+    private static final int TYPE_LAST = 3;
+
+    private final Activity mActivity;
+    private final ImageFetcher mImageFetcher;
+    private final LayoutInflater mInflater;
+    private List<Album> mAlbums = Collections.emptyList();
+    private IListener mListener;
+    private int mListMargin;
+
+    public ArtistDetailAlbumAdapter(final Activity activity) {
+        mActivity = activity;
+        mImageFetcher = ApolloUtils.getImageFetcher(activity);
+        mInflater = LayoutInflater.from(activity);
+        mListMargin = activity.getResources().
+                getDimensionPixelSize(R.dimen.list_item_general_margin);
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        // use view types to distinguish first and last elements
+        // so they can be given special treatment for layout
+        if (position == 0) {
+            return TYPE_FIRST;
+        } else if (position == getItemCount() - 1) {
+            return TYPE_LAST;
+        } else return TYPE_MIDDLE;
+    }
+
+    @Override
+    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        View v = mInflater.inflate(R.layout.artist_detail_album, parent, false);
+        // add extra margin to the first and last elements
+        ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) v.getLayoutParams();
+        if (viewType == TYPE_FIRST) {
+            params.leftMargin = mListMargin;
+        } else if (viewType == TYPE_LAST) {
+            params.rightMargin = mListMargin;
+        }
+        return new ViewHolder(v);
+    }
+
+    @Override
+    public void onBindViewHolder(ViewHolder holder, int position) {
+        Album a = mAlbums.get(position);
+        holder.title.setText(a.mAlbumName);
+        holder.year.setText(a.mYear);
+        mImageFetcher.loadAlbumImage(
+                a.mArtistName, a.mAlbumName, a.mAlbumId, holder.art);
+        holder.popupbutton.setPopupMenuClickedListener(mListener);
+        holder.popupbutton.setPosition(position);
+        addAction(holder.itemView, a);
+    }
+
+    private void addAction(View view, final Album album) {
+        view.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                NavUtils.openAlbumProfile(
+                        mActivity, album.mAlbumName, album.mArtistName, album.mAlbumId);
+            }
+        });
+    }
+
+    @Override
+    public int getItemCount() {
+        return mAlbums.size();
+    }
+
+    public Album getItem(int position) {
+        return mAlbums.get(position);
+    }
+
+    @Override
+    public void setPopupMenuClickedListener(IListener listener) {
+        mListener = listener;
+    }
+
+    @Override // LoaderCallbacks
+    public Loader<List<Album>> onCreateLoader(int id, Bundle args) {
+        return new AlbumLoader(mActivity, args.getLong(Config.ID));
+    }
+
+    @Override // LoaderCallbacks
+    public void onLoadFinished(Loader<List<Album>> loader, List<Album> albums) {
+        if (albums.isEmpty()) {
+            return;
+        }
+        mAlbums = albums;
+        notifyDataSetChanged();
+    }
+
+    @Override // LoaderCallbacks
+    public void onLoaderReset(Loader<List<Album>> loader) {
+        mAlbums = Collections.emptyList();
+        notifyDataSetChanged();
+        mImageFetcher.flush();
+    }
+
+    public static class ViewHolder extends RecyclerView.ViewHolder {
+        public ImageView art;
+        public TextView title;
+        public TextView year;
+        public PopupMenuButton popupbutton;
+
+        public ViewHolder(View root) {
+            super(root);
+            art = (ImageView) root.findViewById(R.id.album_art);
+            title = (TextView) root.findViewById(R.id.title);
+            year = (TextView) root.findViewById(R.id.year);
+            popupbutton = (PopupMenuButton) root.findViewById(R.id.overflow);
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/ArtistDetailSongAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/ArtistDetailSongAdapter.java
new file mode 100755
index 0000000000..8c1e3b348b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/ArtistDetailSongAdapter.java
@@ -0,0 +1,78 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.adapters;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.provider.MediaStore;
+import android.support.v4.content.Loader;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.loaders.SongLoader;
+import com.dolzzo.twelve.model.Song;
+
+import java.util.List;
+
+public abstract class ArtistDetailSongAdapter extends DetailSongAdapter {
+    public ArtistDetailSongAdapter(Activity activity) {
+        super(activity);
+    }
+
+    protected int rowLayoutId() {
+        return R.layout.artist_detail_song;
+    }
+
+    protected Config.IdType getSourceType() {
+        return Config.IdType.Artist;
+    }
+
+    @Override // LoaderCallbacks
+    public Loader<List<Song>> onCreateLoader(int id, Bundle args) {
+        onLoading();
+        setSourceId(args.getLong(Config.ID));
+        final String selection = MediaStore.Audio.AudioColumns.ARTIST_ID + "=" + getSourceId();
+        return new SongLoader(mActivity, selection);
+    }
+
+    protected Holder newHolder(View root, ImageFetcher fetcher) {
+        return new ArtistHolder(root, fetcher);
+    }
+
+    private static class ArtistHolder extends Holder {
+        ImageView art;
+        TextView album;
+
+        protected ArtistHolder(View root, ImageFetcher fetcher) {
+            super(root, fetcher);
+            art = (ImageView) root.findViewById(R.id.album_art);
+            album = (TextView) root.findViewById(R.id.album);
+        }
+
+        protected void update(Song song) {
+            title.setText(song.mSongName);
+            album.setText(song.mAlbumName);
+
+            if (song.mAlbumId >= 0) {
+                fetcher.loadAlbumImage(song.mArtistName, song.mAlbumName, song.mAlbumId, art);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/DetailSongAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/DetailSongAdapter.java
new file mode 100755
index 0000000000..a8a957b04f
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/DetailSongAdapter.java
@@ -0,0 +1,167 @@
+package com.dolzzo.twelve.adapters;
+
+import android.app.Activity;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.Loader;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.BaseAdapter;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.service.MusicPlaybackTrack;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.PopupMenuButton;
+
+import java.util.Collections;
+import java.util.List;
+
+public abstract class DetailSongAdapter extends BaseAdapter
+        implements LoaderCallbacks<List<Song>>, OnItemClickListener, IPopupMenuCallback {
+    protected final Activity mActivity;
+    private final ImageFetcher mImageFetcher;
+    private final LayoutInflater mInflater;
+    private List<Song> mSongs = Collections.emptyList();
+    private IListener mListener;
+    private long mSourceId = -1;
+    private MusicPlaybackTrack mCurrentlyPlayingTrack;
+
+    public DetailSongAdapter(final Activity activity) {
+        mActivity = activity;
+        mImageFetcher = ApolloUtils.getImageFetcher(activity);
+        mInflater = LayoutInflater.from(activity);
+    }
+
+    @Override
+    public int getCount() {
+        return mSongs.size();
+    }
+
+    @Override
+    public Song getItem(int pos) {
+        return mSongs.get(pos);
+    }
+
+    @Override
+    public long getItemId(int pos) {
+        return pos;
+    }
+
+    protected long getSourceId() {
+        return mSourceId;
+    }
+
+    protected void setSourceId(long id) {
+        mSourceId = id;
+    }
+
+    public void setCurrentlyPlayingTrack(MusicPlaybackTrack currentTrack) {
+        if (mCurrentlyPlayingTrack == null || !mCurrentlyPlayingTrack.equals(currentTrack)) {
+            mCurrentlyPlayingTrack = currentTrack;
+            notifyDataSetChanged();
+        }
+    }
+
+    @Override
+    public View getView(int pos, View convertView, ViewGroup parent) {
+        if (convertView == null) {
+            convertView = mInflater.inflate(rowLayoutId(), parent, false);
+            convertView.setTag(newHolder(convertView, mImageFetcher));
+        }
+
+        Holder holder = (Holder) convertView.getTag();
+
+        Song song = getItem(pos);
+        holder.update(song);
+        holder.popupMenuButton.setPopupMenuClickedListener(mListener);
+        holder.popupMenuButton.setPosition(pos);
+
+        if (mCurrentlyPlayingTrack != null
+                && mCurrentlyPlayingTrack.mSourceId == getSourceId()
+                && mCurrentlyPlayingTrack.mSourceType == getSourceType()
+                && mCurrentlyPlayingTrack.mId == song.mSongId) {
+            holder.playIcon.setVisibility(View.VISIBLE);
+        } else {
+            holder.playIcon.setVisibility(View.GONE);
+        }
+
+        return convertView;
+    }
+
+    protected abstract int rowLayoutId();
+
+    protected abstract void onLoading();
+
+    protected abstract void onNoResults();
+
+    protected abstract Config.IdType getSourceType();
+
+    @Override // OnItemClickListener
+    public void onItemClick(AdapterView<?> parent, View view, int pos, long id) {
+        // id is in this case the index in the underlying collection,
+        // which is what we are interested in here -- so use as position
+        int position = (int) id;
+        // ignore clicks on the header
+        if (id < 0) {
+            return;
+        }
+        // play clicked song and enqueue the rest of the songs in the Adapter
+        int songCount = getCount();
+        long[] toPlay = new long[songCount];
+        // add all songs to list
+        for (int i = 0; i < songCount; i++) {
+            toPlay[i] = getItem(i).mSongId;
+        }
+        // specify the song position to start playing
+        MusicUtils.playAll(mActivity, toPlay, position, getSourceId(), getSourceType(), false);
+    }
+
+    @Override // LoaderCallbacks
+    public void onLoadFinished(Loader<List<Song>> loader, List<Song> songs) {
+        if (songs.isEmpty()) {
+            onNoResults();
+            return;
+        }
+        mSongs = songs;
+        notifyDataSetChanged();
+    }
+
+    @Override // LoaderCallbacks
+    public void onLoaderReset(Loader<List<Song>> loader) {
+        mSongs = Collections.emptyList();
+        notifyDataSetChanged();
+        mImageFetcher.flush();
+    }
+
+    @Override
+    public void setPopupMenuClickedListener(IListener listener) {
+        mListener = listener;
+    }
+
+    protected abstract Holder newHolder(View root, ImageFetcher fetcher);
+
+    protected static abstract class Holder {
+        protected ImageFetcher fetcher;
+        protected TextView title;
+        protected PopupMenuButton popupMenuButton;
+        protected ImageView playIcon;
+
+        protected Holder(View root, ImageFetcher fetcher) {
+            this.fetcher = fetcher;
+            title = (TextView) root.findViewById(R.id.title);
+            popupMenuButton = (PopupMenuButton) root.findViewById(R.id.overflow);
+            playIcon = (ImageView) root.findViewById(R.id.now_playing);
+        }
+
+        protected abstract void update(Song song);
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/PagerAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/PagerAdapter.java
new file mode 100755
index 0000000000..fd8e84bbef
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/PagerAdapter.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.adapters;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentPagerAdapter;
+import android.util.SparseArray;
+import android.view.ViewGroup;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.fragments.AlbumFragment;
+import com.dolzzo.twelve.ui.fragments.ArtistFragment;
+import com.dolzzo.twelve.ui.fragments.PlaylistFragment;
+import com.dolzzo.twelve.ui.fragments.SongFragment;
+import com.dolzzo.twelve.utils.Lists;
+
+import java.lang.ref.WeakReference;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * A {@link FragmentPagerAdapter} class for swiping between playlists, recent,
+ * artists, albums, songs, and genre {@link Fragment}s on phones.<br/>
+ */
+public class PagerAdapter extends FragmentPagerAdapter {
+
+    private final SparseArray<WeakReference<Fragment>> mFragmentArray = new SparseArray<WeakReference<Fragment>>();
+
+    private final List<Holder> mHolderList = Lists.newArrayList();
+
+    private final Context mContext;
+
+    private int mCurrentPage;
+
+    /**
+     * Constructor of <code>PagerAdatper<code>
+     *
+     * @param fragmentManager The supporting fragment manager
+     */
+    public PagerAdapter(final Context context, final FragmentManager fragmentManager) {
+        super(fragmentManager);
+        mContext = context;
+    }
+
+    /**
+     * Method that adds a new fragment class to the viewer (the fragment is
+     * internally instantiate)
+     *
+     * @param className The full qualified name of fragment class.
+     * @param params    The instantiate params.
+     */
+    @SuppressWarnings("synthetic-access")
+    public void add(final Class<? extends Fragment> className, final Bundle params) {
+        final Holder mHolder = new Holder();
+        mHolder.mClassName = className.getName();
+        mHolder.mParams = params;
+
+        final int mPosition = mHolderList.size();
+        mHolderList.add(mPosition, mHolder);
+        notifyDataSetChanged();
+    }
+
+    /**
+     * Method that returns the {@link Fragment} in the argument
+     * position.
+     *
+     * @param position The position of the fragment to return.
+     * @return Fragment The {@link Fragment} in the argument position.
+     */
+    public Fragment getFragment(final int position) {
+        final WeakReference<Fragment> mWeakFragment = mFragmentArray.get(position);
+        if (mWeakFragment != null && mWeakFragment.get() != null) {
+            return mWeakFragment.get();
+        }
+        return getItem(position);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Object instantiateItem(final ViewGroup container, final int position) {
+        final Fragment mFragment = (Fragment) super.instantiateItem(container, position);
+        final WeakReference<Fragment> mWeakFragment = mFragmentArray.get(position);
+        if (mWeakFragment != null) {
+            mWeakFragment.clear();
+        }
+        mFragmentArray.put(position, new WeakReference<Fragment>(mFragment));
+        return mFragment;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Fragment getItem(final int position) {
+        final Holder mCurrentHolder = mHolderList.get(position);
+        final Fragment mFragment = Fragment.instantiate(mContext,
+                mCurrentHolder.mClassName, mCurrentHolder.mParams);
+        return mFragment;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void destroyItem(final ViewGroup container, final int position, final Object object) {
+        super.destroyItem(container, position, object);
+        final WeakReference<Fragment> mWeakFragment = mFragmentArray.get(position);
+        if (mWeakFragment != null) {
+            mWeakFragment.clear();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getCount() {
+        return mHolderList.size();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public CharSequence getPageTitle(final int position) {
+        return mContext.getResources().getStringArray(R.array.page_titles)[position]
+                .toUpperCase(Locale.getDefault());
+    }
+
+    /**
+     * Method that returns the current page position.
+     *
+     * @return int The current page.
+     */
+    public int getCurrentPage() {
+        return mCurrentPage;
+    }
+
+    /**
+     * Method that sets the current page position.
+     *
+     * @param currentPage The current page.
+     */
+    protected void setCurrentPage(final int currentPage) {
+        mCurrentPage = currentPage;
+    }
+
+    /**
+     * An enumeration of all the main fragments supported.
+     */
+    public enum MusicFragments {
+        /**
+         * The artist fragment
+         */
+        ARTIST(ArtistFragment.class),
+        /**
+         * The album fragment
+         */
+        ALBUM(AlbumFragment.class),
+        /**
+         * The song fragment
+         */
+        SONG(SongFragment.class),
+        /**
+         * The playlist fragment
+         */
+        PLAYLIST(PlaylistFragment.class);
+
+        private Class<? extends Fragment> mFragmentClass;
+
+        /**
+         * Constructor of <code>MusicFragments</code>
+         *
+         * @param fragmentClass The fragment class
+         */
+        private MusicFragments(final Class<? extends Fragment> fragmentClass) {
+            mFragmentClass = fragmentClass;
+        }
+
+        /**
+         * Method that returns the fragment class.
+         *
+         * @return Class<? extends Fragment> The fragment class.
+         */
+        public Class<? extends Fragment> getFragmentClass() {
+            return mFragmentClass;
+        }
+
+    }
+
+    /**
+     * A private class with information about fragment initialization
+     */
+    private final static class Holder {
+        String mClassName;
+
+        Bundle mParams;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/PlaylistAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/PlaylistAdapter.java
new file mode 100755
index 0000000000..80add64728
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/PlaylistAdapter.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.adapters;
+
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+
+import com.dolzzo.twelve.Config.SmartPlaylistType;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.model.Playlist;
+import com.dolzzo.twelve.ui.MusicHolder;
+import com.dolzzo.twelve.ui.MusicHolder.DataHolder;
+import com.dolzzo.twelve.ui.fragments.PlaylistFragment;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+
+/**
+ * This {@link ArrayAdapter} is used to display all of the playlists on a user's
+ * device for {@link PlaylistFragment}.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class PlaylistAdapter extends ArrayAdapter<Playlist> implements IPopupMenuCallback {
+
+    /**
+     * Smart playlists and normal playlists
+     */
+    private static final int VIEW_TYPE_COUNT = 2;
+
+    /**
+     * Used to identify the view type
+     */
+    private static final int SMART_PLAYLIST_VIEW_TYPE = 1;
+    /**
+     * Used to listen to the pop up menu callbacks
+     */
+    protected IListener mListener;
+    /**
+     * Used to cache the playlist info
+     */
+    private DataHolder[] mData;
+
+    /**
+     * Constructor of <code>PlaylistAdapter</code>
+     *
+     * @param context The {@link Context} to use.
+     */
+    public PlaylistAdapter(final Context context) {
+        super(context, 0);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View getView(final int position, View convertView, final ViewGroup parent) {
+        // Recycle ViewHolder's items
+        MusicHolder holder;
+        if (convertView == null) {
+            int layoutId = R.layout.list_item_normal;
+
+            if (getItemViewType(position) == SMART_PLAYLIST_VIEW_TYPE) {
+                layoutId = R.layout.list_item_smart_playlist;
+            }
+
+            convertView = LayoutInflater.from(getContext()).inflate(layoutId, parent, false);
+            holder = new MusicHolder(convertView);
+            convertView.setTag(holder);
+
+            // set the pop up menu listener
+            holder.mPopupMenuButton.get().setPopupMenuClickedListener(mListener);
+        } else {
+            holder = (MusicHolder) convertView.getTag();
+        }
+
+        // Retrieve the data holder
+        final DataHolder dataHolder = mData[position];
+
+        // because of recycling, we need to set the position each time
+        holder.mPopupMenuButton.get().setPosition(position);
+
+        // Set each playlist name (line one)
+        holder.mLineOne.get().setText(dataHolder.mLineOne);
+
+        if (dataHolder.mLineTwo == null) {
+            holder.mLineTwo.get().setVisibility(View.GONE);
+        } else {
+            holder.mLineTwo.get().setVisibility(View.VISIBLE);
+            holder.mLineTwo.get().setText(dataHolder.mLineTwo);
+        }
+
+        SmartPlaylistType type = SmartPlaylistType.getTypeById(dataHolder.mItemId);
+        if (type != null) {
+            // Set the image resource based on the icon
+            switch (type) {
+                case LastAdded:
+                    holder.mImage.get().setImageResource(R.drawable.recently_added);
+                    break;
+                case RecentlyPlayed:
+                    holder.mImage.get().setImageResource(R.drawable.recent_icon);
+                    break;
+                case TopTracks:
+                default:
+                    holder.mImage.get().setImageResource(R.drawable.top_tracks_icon);
+                    break;
+            }
+        } else {
+            // load the image
+            ImageFetcher.getInstance(getContext()).loadPlaylistCoverArtImage(
+                    dataHolder.mItemId, holder.mImage.get());
+        }
+
+
+        return convertView;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getViewTypeCount() {
+        return VIEW_TYPE_COUNT;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getItemViewType(int position) {
+        if (getItem(position).isSmartPlaylist()) {
+            return SMART_PLAYLIST_VIEW_TYPE;
+        }
+
+        return 0;
+    }
+
+    /**
+     * Method used to cache the data used to populate the list or grid. The idea
+     * is to cache everything before {@code #getView(int, View, ViewGroup)} is
+     * called.
+     */
+    public void buildCache() {
+        mData = new DataHolder[getCount()];
+        for (int i = 0; i < getCount(); i++) {
+            // Build the artist
+            final Playlist playlist = getItem(i);
+
+            // Build the data holder
+            mData[i] = new DataHolder();
+            // Playlist Id
+            mData[i].mItemId = playlist.mPlaylistId;
+            // Playlist names (line one)
+            mData[i].mLineOne = playlist.mPlaylistName;
+            // # of songs
+            if (playlist.mSongCount >= 0) {
+                mData[i].mLineTwo = MusicUtils.makeLabel(getContext(),
+                        R.plurals.Nsongs, playlist.mSongCount);
+            }
+        }
+    }
+
+    /**
+     * Method that unloads and clears the items in the adapter
+     */
+    public void unload() {
+        clear();
+        mData = null;
+    }
+
+    @Override
+    public void setPopupMenuClickedListener(IListener listener) {
+        mListener = listener;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/ProfileSongAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/ProfileSongAdapter.java
new file mode 100755
index 0000000000..51c6a168a4
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/ProfileSongAdapter.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.adapters;
+
+import android.app.Activity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.model.Song;
+
+import java.util.Collection;
+
+/**
+ * This {@link ArrayAdapter} is used to display the songs for a particular playlist
+ * {@link com.dolzzo.twelve.ui.fragments.PlaylistDetailFragment}
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class ProfileSongAdapter extends SongAdapter {
+    /**
+     * Instead of having random +1 and -1 sprinkled around, this variable will show what is really
+     * related to the header
+     */
+    public static final int NUM_HEADERS = 1;
+
+    /**
+     * Fake header layout Id
+     */
+    private final int mHeaderId;
+
+    /**
+     * Constructor of <code>ProfileSongAdapter</code>
+     *
+     * @param activity The {@link Activity} to use
+     * @param layoutId The resource Id of the view to inflate.
+     */
+    public ProfileSongAdapter(final long playlistId, final Activity activity, final int layoutId,
+                              final int headerId) {
+        super(activity, layoutId, playlistId, Config.IdType.Playlist);
+        // Cache the header
+        mHeaderId = headerId;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View getView(final int position, View convertView, final ViewGroup parent) {
+
+        // Return a faux header at position 0
+        if (position == 0) {
+            if (convertView == null) {
+                convertView = LayoutInflater.from(getContext()).inflate(mHeaderId, parent, false);
+            }
+
+            return convertView;
+        }
+
+        return super.getView(position, convertView, parent);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    protected boolean showNowPlayingIndicator(final Song song, final int position) {
+        return super.showNowPlayingIndicator(song, position)
+                && mCurrentlyPlayingTrack.mSourcePosition == position - NUM_HEADERS;
+    }
+
+    @Override
+    public boolean isEnabled(int position) {
+        if (position == 0) {
+            return false;
+        }
+
+        return super.isEnabled(position);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getViewTypeCount() {
+        return super.getViewTypeCount() + NUM_HEADERS;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getItemViewType(final int position) {
+        if (position == 0) {
+            // since our view type count adds 1 to the super class, we can return viewtypecount - 1
+            return getViewTypeCount() - 1;
+        }
+        return super.getItemViewType(position);
+    }
+
+    @Override
+    public void addAll(Collection<? extends Song> collection) {
+        // insert a header if one is needed
+        insertHeader();
+        super.addAll(collection);
+    }
+
+    @Override
+    public void addAll(Song... items) {
+        // insert a header if one is needed
+        insertHeader();
+        super.addAll(items);
+    }
+
+    /**
+     * Make sure we insert our header when we add items
+     */
+    private void insertHeader() {
+        if (getCount() == 0) {
+            // add a dummy entry to the underlying adapter.  This is needed otherwise the
+            // underlying adapter could crash because getCount() doesn't match up
+            add(new Song(-1, null, null, null, -1, -1, -1));
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/SongAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/SongAdapter.java
new file mode 100755
index 0000000000..8fa90203a0
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/SongAdapter.java
@@ -0,0 +1,324 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.adapters;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.model.Artist;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.sectionadapter.SectionAdapter;
+import com.dolzzo.twelve.service.MusicPlaybackTrack;
+import com.dolzzo.twelve.ui.MusicHolder;
+import com.dolzzo.twelve.ui.MusicHolder.DataHolder;
+import com.dolzzo.twelve.ui.fragments.QueueFragment;
+import com.dolzzo.twelve.ui.fragments.SongFragment;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.PlayPauseProgressButton;
+
+/**
+ * This {@link ArrayAdapter} is used to display all of the songs on a user's
+ * device for {@link SongFragment}. It is also used to show the queue in
+ * {@link QueueFragment}.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class SongAdapter extends ArrayAdapter<Song>
+        implements SectionAdapter.BasicAdapter, IPopupMenuCallback {
+
+    public static final int NOTHING_PLAYING = -1;
+
+    /**
+     * Number of views (TextView)
+     */
+    private static final int VIEW_TYPE_COUNT = 1;
+
+    /**
+     * The resource Id of the layout to inflate
+     */
+    private final int mLayoutId;
+
+    /**
+     * Image cache and image fetcher
+     */
+    private final ImageFetcher mImageFetcher;
+    /**
+     * Current music track
+     */
+    protected MusicPlaybackTrack mCurrentlyPlayingTrack;
+    /**
+     * Source id and type
+     */
+    protected long mSourceId;
+    protected Config.IdType mSourceType;
+    /**
+     * The index of the item that is currently playing
+     */
+    private long mCurrentQueuePosition = NOTHING_PLAYING;
+    /**
+     * Used to cache the song info
+     */
+    private DataHolder[] mData;
+    /**
+     * Used to listen to the pop up menu callbacks
+     */
+    private IPopupMenuCallback.IListener mListener;
+
+    /**
+     * Constructor of <code>SongAdapter</code>
+     *
+     * @param context    The {@link Context} to use.
+     * @param layoutId   The resource Id of the view to inflate.
+     * @param sourceId   The source id that the adapter is created from
+     * @param sourceType The source type that the adapter is created from
+     */
+    public SongAdapter(final Activity context, final int layoutId, final long sourceId,
+                       final Config.IdType sourceType) {
+        super(context, 0);
+        // Get the layout Id
+        mLayoutId = layoutId;
+        // Initialize the cache & image fetcher
+        mImageFetcher = ApolloUtils.getImageFetcher(context);
+        // set the source id and type
+        mSourceId = sourceId;
+        mSourceType = sourceType;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View getView(final int position, View convertView, final ViewGroup parent) {
+        // Recycle ViewHolder's items
+        MusicHolder holder;
+        if (convertView == null) {
+            convertView = LayoutInflater.from(getContext()).inflate(mLayoutId, parent, false);
+            holder = new MusicHolder(convertView);
+            convertView.setTag(holder);
+
+            holder.mPopupMenuButton.get().setPopupMenuClickedListener(mListener);
+        } else {
+            holder = (MusicHolder) convertView.getTag();
+        }
+
+        // Retrieve the data holder
+        final DataHolder dataHolder = mData[position];
+
+        // Sets the position each time because of recycling
+        holder.mPopupMenuButton.get().setPosition(position);
+        // Set each song name (line one)
+        holder.mLineOne.get().setText(dataHolder.mLineOne);
+        // Set the album name (line two)
+        holder.mLineTwo.get().setText(dataHolder.mLineTwo);
+
+        // Asynchronously load the artist image into the adapter
+        Song item = getItem(position);
+        if (item.mAlbumId >= 0) {
+            mImageFetcher.loadAlbumImage(item.mArtistName, item.mAlbumName, item.mAlbumId,
+                    holder.mImage.get());
+        }
+
+        // padding doesn't apply to included layouts, so we need
+        // to wrap it in a container and show/hide with the container
+        PlayPauseProgressButton playPauseProgressButton = holder.mPlayPauseProgressButton.get();
+        if (playPauseProgressButton != null) {
+            View playPauseContainer = holder.mPlayPauseProgressContainer.get();
+
+            if (mCurrentQueuePosition == position) {
+                // make it visible
+                playPauseProgressButton.enableAndShow();
+                playPauseContainer.setVisibility(View.VISIBLE);
+            } else {
+                // hide it
+                playPauseProgressButton.disableAndHide();
+                playPauseContainer.setVisibility(View.GONE);
+            }
+        }
+
+        View nowPlayingIndicator = holder.mNowPlayingIndicator.get();
+        if (nowPlayingIndicator != null) {
+            if (showNowPlayingIndicator(item, position)) {
+                nowPlayingIndicator.setVisibility(View.VISIBLE);
+            } else {
+                nowPlayingIndicator.setVisibility(View.GONE);
+            }
+        }
+
+        return convertView;
+    }
+
+    /**
+     * Determines whether the song at the position should show the currently playing indicator
+     *
+     * @param song     the song in question
+     * @param position the position of the song
+     * @return true if we want to show the indicator
+     */
+    protected boolean showNowPlayingIndicator(final Song song, final int position) {
+        if (mCurrentlyPlayingTrack != null
+                && mCurrentlyPlayingTrack.mSourceId == mSourceId
+                && mCurrentlyPlayingTrack.mSourceType == mSourceType
+                && mCurrentlyPlayingTrack.mId == song.mSongId) {
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getViewTypeCount() {
+        return VIEW_TYPE_COUNT;
+    }
+
+    /**
+     * Method used to cache the data used to populate the list or grid. The idea
+     * is to cache everything before {@code #getView(int, View, ViewGroup)} is
+     * called.
+     */
+    public void buildCache() {
+        mData = new DataHolder[getCount()];
+        for (int i = 0; i < getCount(); i++) {
+            // Build the song
+            final Song song = getItem(i);
+
+            // skip special placeholders
+            if (song.mSongId == -1) {
+                continue;
+            }
+
+            // Build the data holder
+            mData[i] = new DataHolder();
+            // Song Id
+            mData[i].mItemId = song.mSongId;
+            // Song names (line one)
+            mData[i].mLineOne = song.mSongName;
+            // Song duration (line one, right)
+            mData[i].mLineOneRight = MusicUtils.makeShortTimeString(getContext(), song.mDuration);
+
+            // Artist Name | Album Name (line two)
+            mData[i].mLineTwo = MusicUtils.makeCombinedString(getContext(), song.mArtistName,
+                    song.mAlbumName);
+        }
+    }
+
+    /**
+     * @param pause True to temporarily pause the disk cache, false otherwise.
+     */
+    public void setPauseDiskCache(final boolean pause) {
+        if (mImageFetcher != null) {
+            mImageFetcher.setPauseDiskCache(pause);
+        }
+    }
+
+    /**
+     * @param artist The key used to find the cached artist to remove
+     */
+    public void removeFromCache(final Artist artist) {
+        if (mImageFetcher != null) {
+            mImageFetcher.removeFromCache(artist.mArtistName);
+        }
+    }
+
+    /**
+     * Method that unloads and clears the items in the adapter
+     */
+    public void unload() {
+        clear();
+        mData = null;
+    }
+
+    /**
+     * Do nothing.
+     */
+    public void flush() {
+    }
+
+    /**
+     * Gets the item position for a given id
+     *
+     * @param id identifies the object
+     * @return the position if found, -1 otherwise
+     */
+    @Override
+    public int getItemPosition(long id) {
+        for (int i = 0; i < getCount(); i++) {
+            if (getItem(i).mSongId == id) {
+                return i;
+            }
+        }
+
+        return -1;
+    }
+
+    public void setCurrentQueuePosition(long queuePosition) {
+        if (mCurrentQueuePosition != queuePosition) {
+            mCurrentQueuePosition = queuePosition;
+
+            notifyDataSetChanged();
+        }
+    }
+
+    @Override
+    public void setPopupMenuClickedListener(IListener listener) {
+        mListener = listener;
+    }
+
+    /**
+     * Sets the currently playing track for the adapter to know when to show indicators
+     *
+     * @param currentTrack the currently playing track
+     * @return true if the current track is different
+     */
+    public boolean setCurrentlyPlayingTrack(MusicPlaybackTrack currentTrack) {
+        if (mCurrentlyPlayingTrack == null || !mCurrentlyPlayingTrack.equals(currentTrack)) {
+            mCurrentlyPlayingTrack = currentTrack;
+
+            notifyDataSetChanged();
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * @return Gets the list of song ids from the adapter
+     */
+    public long[] getSongIds() {
+        long[] ret = new long[getCount()];
+        for (int i = 0; i < getCount(); i++) {
+            ret[i] = getItem(i).mSongId;
+        }
+
+        return ret;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/adapters/SummarySearchAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/adapters/SummarySearchAdapter.java
new file mode 100755
index 0000000000..beaf139801
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/adapters/SummarySearchAdapter.java
@@ -0,0 +1,223 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.adapters;
+
+import android.app.Activity;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.format.PrefixHighlighter;
+import com.dolzzo.twelve.model.SearchResult;
+import com.dolzzo.twelve.sectionadapter.SectionAdapter;
+import com.dolzzo.twelve.ui.MusicHolder;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+
+import java.util.Locale;
+
+/**
+ * Used to populate the list view with the search results.
+ */
+public final class SummarySearchAdapter extends ArrayAdapter<SearchResult>
+        implements SectionAdapter.BasicAdapter, IPopupMenuCallback {
+
+    /**
+     * Image cache and image fetcher
+     */
+    private final ImageFetcher mImageFetcher;
+
+    /**
+     * Highlights the query
+     */
+    private final PrefixHighlighter mHighlighter;
+
+    /**
+     * The prefix that's highlighted
+     */
+    private char[] mPrefix;
+
+    /**
+     * Used to listen to the pop up menu callbacks
+     */
+    private IListener mListener;
+
+    /**
+     * Constructor for <code>SearchAdapter</code>
+     *
+     * @param context The {@link Activity} to use.
+     */
+    public SummarySearchAdapter(final Activity context) {
+        super(context, 0);
+        // Initialize the cache & image fetcher
+        mImageFetcher = ApolloUtils.getImageFetcher(context);
+        // Create the prefix highlighter
+        mHighlighter = new PrefixHighlighter(context);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View getView(final int position, View convertView, final ViewGroup parent) {
+            /* Recycle ViewHolder's items */
+        MusicHolder holder;
+
+        if (convertView == null) {
+            convertView = LayoutInflater.from(getContext()).inflate(
+                    R.layout.list_item_normal, parent, false);
+            holder = new MusicHolder(convertView);
+            convertView.setTag(holder);
+            // set the pop up menu listener
+            holder.mPopupMenuButton.get().setPopupMenuClickedListener(mListener);
+        } else {
+            holder = (MusicHolder) convertView.getTag();
+        }
+
+        // Sets the position each time because of recycling
+        holder.mPopupMenuButton.get().setPosition(position);
+
+        final SearchResult item = getItem(position);
+
+        switch (item.mType) {
+            case Artist:
+                // Asynchronously load the artist image into the adapter
+                mImageFetcher.loadArtistImage(item.mArtist, holder.mImage.get());
+
+                setText(holder.mLineOne.get(), item.mArtist);
+
+                String songCount = MusicUtils.makeLabel(getContext(), R.plurals.Nsongs, item.mSongCount);
+                String albumCount = MusicUtils.makeLabel(getContext(), R.plurals.Nalbums, item.mAlbumCount);
+                // Album Name | Artist Name (line two)
+                holder.mLineTwo.get().setText(MusicUtils.makeCombinedString(getContext(), songCount, albumCount));
+                break;
+            case Album:
+                // Asynchronously load the album images into the adapter
+                mImageFetcher.loadAlbumImage(item.mArtist, item.mAlbum,
+                        item.mId, holder.mImage.get());
+
+                setText(holder.mLineOne.get(), item.mAlbum);
+                setText(holder.mLineTwo.get(), item.mArtist);
+                break;
+            case Song:
+                // Asynchronously load the album images into the adapter
+                mImageFetcher.loadAlbumImage(item.mArtist, item.mAlbum,
+                        item.mAlbumId, holder.mImage.get());
+
+                setText(holder.mLineOne.get(), item.mTitle);
+                setText(holder.mLineTwo.get(),
+                        MusicUtils.makeCombinedString(getContext(), item.mArtist, item.mAlbum));
+                break;
+            case Playlist:
+                // Asynchronously load the playlist images into the adapter
+                ImageFetcher.getInstance(getContext()).loadPlaylistCoverArtImage(
+                        item.mId, holder.mImage.get());
+
+                setText(holder.mLineOne.get(), item.mTitle);
+                String songs = MusicUtils.makeLabel(getContext(), R.plurals.Nsongs, item.mSongCount);
+                holder.mLineTwo.get().setText(songs);
+                break;
+        }
+
+        return convertView;
+    }
+
+    /**
+     * Sets the text onto the textview with highlighting if a prefix is defined
+     *
+     * @param textView
+     * @param text
+     */
+    private void setText(final TextView textView, final String text) {
+        if (mPrefix == null) {
+            textView.setText(text);
+        } else {
+            mHighlighter.setText(textView, text, mPrefix);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    /**
+     * @param pause True to temporarily pause the disk cache, false
+     *              otherwise.
+     */
+    public void setPauseDiskCache(final boolean pause) {
+        if (mImageFetcher != null) {
+            mImageFetcher.setPauseDiskCache(pause);
+        }
+    }
+
+    /**
+     * @param prefix The query to filter.
+     */
+    public void setPrefix(final CharSequence prefix) {
+        if (!TextUtils.isEmpty(prefix)) {
+            mPrefix = prefix.toString().toUpperCase(Locale.getDefault()).toCharArray();
+        } else {
+            mPrefix = null;
+        }
+    }
+
+    @Override
+    public void unload() {
+        clear();
+    }
+
+    @Override
+    public void buildCache() {
+
+    }
+
+    @Override
+    public void flush() {
+        mImageFetcher.flush();
+    }
+
+    /**
+     * Gets the item position for a given id
+     *
+     * @param id identifies the object
+     * @return the position if found, -1 otherwise
+     */
+    @Override
+    public int getItemPosition(long id) {
+        for (int i = 0; i < getCount(); i++) {
+            if (getItem(i).mId == id) {
+                return i;
+            }
+        }
+
+        return -1;
+    }
+
+    @Override
+    public void setPopupMenuClickedListener(IListener listener) {
+        mListener = listener;
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetBase.java b/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetBase.java
new file mode 100755
index 0000000000..903522c972
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetBase.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.appwidgets;
+
+import android.app.PendingIntent;
+import android.appwidget.AppWidgetProvider;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+
+public abstract class AppWidgetBase extends AppWidgetProvider {
+
+    protected PendingIntent buildPendingIntent(Context context, final String action,
+                                               final ComponentName serviceName) {
+        Intent intent = new Intent(action);
+        intent.setComponent(serviceName);
+        return PendingIntent.getService(context, 0, intent, 0);
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetLarge.java b/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetLarge.java
new file mode 100755
index 0000000000..14d2c99c7f
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetLarge.java
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.appwidgets;
+
+import android.annotation.SuppressLint;
+import android.app.PendingIntent;
+import android.appwidget.AppWidgetManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.widget.RemoteViews;
+
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.activities.HomeActivity;
+
+/**
+ * 4x2 App-Widget
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+@SuppressLint("NewApi")
+public class AppWidgetLarge extends AppWidgetBase {
+
+    public static final String CMDAPPWIDGETUPDATE = "app_widget_large_update";
+
+    private static AppWidgetLarge mInstance;
+
+    public static synchronized AppWidgetLarge getInstance() {
+        if (mInstance == null) {
+            mInstance = new AppWidgetLarge();
+        }
+        return mInstance;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onUpdate(final Context context, final AppWidgetManager appWidgetManager,
+                         final int[] appWidgetIds) {
+        defaultAppWidget(context, appWidgetIds);
+        final Intent updateIntent = new Intent(MusicPlaybackService.SERVICECMD);
+        updateIntent.putExtra(MusicPlaybackService.CMDNAME, AppWidgetLarge.CMDAPPWIDGETUPDATE);
+        updateIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);
+        updateIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
+        context.sendBroadcast(updateIntent);
+    }
+
+    /**
+     * Initialize given widgets to default state, where we launch Music on
+     * default click and hide actions if service not running.
+     */
+    private void defaultAppWidget(final Context context, final int[] appWidgetIds) {
+        final RemoteViews appWidgetViews = new RemoteViews(context.getPackageName(),
+                R.layout.app_widget_large);
+        linkButtons(context, appWidgetViews);
+        pushUpdate(context, appWidgetIds, appWidgetViews);
+    }
+
+    private void pushUpdate(final Context context, final int[] appWidgetIds, final RemoteViews views) {
+        final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
+        if (appWidgetIds != null) {
+            appWidgetManager.updateAppWidget(appWidgetIds, views);
+        } else {
+            appWidgetManager.updateAppWidget(new ComponentName(context, getClass()), views);
+        }
+    }
+
+    /**
+     * Check against {@link AppWidgetManager} if there are any instances of this
+     * widget.
+     */
+    private boolean hasInstances(final Context context) {
+        final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
+        final int[] mAppWidgetIds = appWidgetManager.getAppWidgetIds(new ComponentName(context,
+                getClass()));
+        return mAppWidgetIds.length > 0;
+    }
+
+    /**
+     * Handle a change notification coming over from
+     * {@link MusicPlaybackService}
+     */
+    public void notifyChange(final MusicPlaybackService service, final String what) {
+        if (hasInstances(service)) {
+            if (MusicPlaybackService.META_CHANGED.equals(what)
+                    || MusicPlaybackService.PLAYSTATE_CHANGED.equals(what)) {
+                performUpdate(service, null);
+            }
+        }
+    }
+
+    /**
+     * Update all active widget instances by pushing changes
+     */
+    public void performUpdate(final MusicPlaybackService service, final int[] appWidgetIds) {
+        final RemoteViews appWidgetView = new RemoteViews(service.getPackageName(),
+                R.layout.app_widget_large);
+
+        final CharSequence trackName = service.getTrackName();
+        final CharSequence artistName = service.getArtistName();
+        final CharSequence albumName = service.getAlbumName();
+        final Bitmap bitmap = service.getAlbumArt(true).getBitmap();
+
+        // Set the titles and artwork
+        appWidgetView.setTextViewText(R.id.app_widget_large_line_one, trackName);
+        appWidgetView.setTextViewText(R.id.app_widget_large_line_two, artistName);
+        appWidgetView.setTextViewText(R.id.app_widget_large_line_three, albumName);
+        appWidgetView.setImageViewBitmap(R.id.app_widget_large_image, bitmap);
+
+        // Set correct drawable for pause state
+        final boolean isPlaying = service.isPlaying();
+        if (isPlaying) {
+            appWidgetView.setImageViewResource(R.id.app_widget_large_play,
+                    R.drawable.btn_playback_pause);
+            appWidgetView.setContentDescription(R.id.app_widget_large_play,
+                    service.getString(R.string.accessibility_pause));
+        } else {
+            appWidgetView.setImageViewResource(R.id.app_widget_large_play,
+                    R.drawable.btn_playback_play);
+            appWidgetView.setContentDescription(R.id.app_widget_large_play,
+                    service.getString(R.string.accessibility_play));
+        }
+
+        // Link actions buttons to intents
+        linkButtons(service, appWidgetView);
+
+        // Update the app-widget
+        pushUpdate(service, appWidgetIds, appWidgetView);
+    }
+
+    /**
+     * Link up various button actions using {@link PendingIntents}.
+     */
+    private void linkButtons(final Context context, final RemoteViews views) {
+        Intent action;
+        PendingIntent pendingIntent;
+
+        final ComponentName serviceName = new ComponentName(context, MusicPlaybackService.class);
+
+        // Home
+        action = new Intent(context, HomeActivity.class);
+        action.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        pendingIntent = PendingIntent.getActivity(context, 0, action, 0);
+        views.setOnClickPendingIntent(R.id.app_widget_large_info_container, pendingIntent);
+        views.setOnClickPendingIntent(R.id.app_widget_large_image, pendingIntent);
+
+        // Previous track
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.PREVIOUS_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_large_previous, pendingIntent);
+
+        // Play and pause
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.TOGGLEPAUSE_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_large_play, pendingIntent);
+
+        // Next track
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.NEXT_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_large_next, pendingIntent);
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetLargeAlternate.java b/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetLargeAlternate.java
new file mode 100755
index 0000000000..59a3f93f5b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetLargeAlternate.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.appwidgets;
+
+import android.annotation.SuppressLint;
+import android.app.PendingIntent;
+import android.appwidget.AppWidgetManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.widget.RemoteViews;
+
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.activities.HomeActivity;
+import com.dolzzo.twelve.widgets.RepeatButton;
+import com.dolzzo.twelve.widgets.ShuffleButton;
+
+/**
+ * 4x2 App-Widget
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+@SuppressLint("NewApi")
+public class AppWidgetLargeAlternate extends AppWidgetBase {
+
+    public static final String CMDAPPWIDGETUPDATE = "app_widget_large_alternate_update";
+
+    private static AppWidgetLargeAlternate mInstance;
+
+    public static synchronized AppWidgetLargeAlternate getInstance() {
+        if (mInstance == null) {
+            mInstance = new AppWidgetLargeAlternate();
+        }
+        return mInstance;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onUpdate(final Context context, final AppWidgetManager appWidgetManager,
+                         final int[] appWidgetIds) {
+        defaultAppWidget(context, appWidgetIds);
+        final Intent updateIntent = new Intent(MusicPlaybackService.SERVICECMD);
+        updateIntent.putExtra(MusicPlaybackService.CMDNAME,
+                AppWidgetLargeAlternate.CMDAPPWIDGETUPDATE);
+        updateIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);
+        updateIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
+        context.sendBroadcast(updateIntent);
+    }
+
+    /**
+     * Initialize given widgets to default state, where we launch Music on
+     * default click and hide actions if service not running.
+     */
+    private void defaultAppWidget(final Context context, final int[] appWidgetIds) {
+        final RemoteViews appWidgetViews = new RemoteViews(context.getPackageName(),
+                R.layout.app_widget_large_alternate);
+        linkButtons(context, appWidgetViews);
+        pushUpdate(context, appWidgetIds, appWidgetViews);
+    }
+
+    private void pushUpdate(final Context context, final int[] appWidgetIds, final RemoteViews views) {
+        final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
+        if (appWidgetIds != null) {
+            appWidgetManager.updateAppWidget(appWidgetIds, views);
+        } else {
+            appWidgetManager.updateAppWidget(new ComponentName(context, getClass()), views);
+        }
+    }
+
+    /**
+     * Check against {@link AppWidgetManager} if there are any instances of this
+     * widget.
+     */
+    private boolean hasInstances(final Context context) {
+        final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
+        final int[] mAppWidgetIds = appWidgetManager.getAppWidgetIds(new ComponentName(context,
+                getClass()));
+        return mAppWidgetIds.length > 0;
+    }
+
+    /**
+     * Handle a change notification coming over from
+     * {@link MusicPlaybackService}
+     */
+    public void notifyChange(final MusicPlaybackService service, final String what) {
+        if (hasInstances(service)) {
+            if (MusicPlaybackService.META_CHANGED.equals(what)
+                    || MusicPlaybackService.PLAYSTATE_CHANGED.equals(what)
+                    || MusicPlaybackService.REPEATMODE_CHANGED.equals(what)
+                    || MusicPlaybackService.SHUFFLEMODE_CHANGED.equals(what)) {
+                performUpdate(service, null);
+            }
+        }
+    }
+
+    /**
+     * Update all active widget instances by pushing changes
+     */
+    public void performUpdate(final MusicPlaybackService service, final int[] appWidgetIds) {
+        final RemoteViews appWidgetView = new RemoteViews(service.getPackageName(),
+                R.layout.app_widget_large_alternate);
+
+        final CharSequence trackName = service.getTrackName();
+        final CharSequence artistName = service.getArtistName();
+        final CharSequence albumName = service.getAlbumName();
+        final Bitmap bitmap = service.getAlbumArt(true).getBitmap();
+
+        // Set the titles and artwork
+        appWidgetView.setTextViewText(R.id.app_widget_large_alternate_line_one, trackName);
+        appWidgetView.setTextViewText(R.id.app_widget_large_alternate_line_two, artistName);
+        appWidgetView.setTextViewText(R.id.app_widget_large_alternate_line_three, albumName);
+        appWidgetView.setImageViewBitmap(R.id.app_widget_large_alternate_image, bitmap);
+
+        // Set correct drawable for pause state
+        final boolean isPlaying = service.isPlaying();
+        if (isPlaying) {
+            appWidgetView.setImageViewResource(R.id.app_widget_large_alternate_play,
+                    R.drawable.btn_playback_pause);
+            appWidgetView.setContentDescription(R.id.app_widget_large_alternate_play,
+                    service.getString(R.string.accessibility_pause));
+        } else {
+            appWidgetView.setImageViewResource(R.id.app_widget_large_alternate_play,
+                    R.drawable.btn_playback_play);
+            appWidgetView.setContentDescription(R.id.app_widget_large_alternate_play,
+                    service.getString(R.string.accessibility_play));
+        }
+
+        // Set the correct drawable for the repeat state
+        switch (service.getRepeatMode()) {
+            case MusicPlaybackService.REPEAT_ALL:
+                appWidgetView.setImageViewResource(R.id.app_widget_large_alternate_repeat,
+                        R.drawable.btn_playback_repeat_all);
+                appWidgetView.setInt(R.id.app_widget_large_alternate_repeat, "setAlpha",
+                        (int) (RepeatButton.ACTIVE_ALPHA * 255));
+                break;
+            case MusicPlaybackService.REPEAT_CURRENT:
+                appWidgetView.setImageViewResource(R.id.app_widget_large_alternate_repeat,
+                        R.drawable.btn_playback_repeat_one);
+                appWidgetView.setInt(R.id.app_widget_large_alternate_repeat, "setAlpha",
+                        (int) (RepeatButton.ACTIVE_ALPHA * 255));
+                break;
+            default:
+                appWidgetView.setImageViewResource(R.id.app_widget_large_alternate_repeat,
+                        R.drawable.btn_playback_repeat_all);
+                appWidgetView.setInt(R.id.app_widget_large_alternate_repeat, "setAlpha",
+                        (int) (RepeatButton.INACTIVE_ALPHA * 255));
+                break;
+        }
+
+        // Set the correct drawable for the shuffle state
+        switch (service.getShuffleMode()) {
+            case MusicPlaybackService.SHUFFLE_NONE:
+                appWidgetView.setImageViewResource(R.id.app_widget_large_alternate_shuffle,
+                        R.drawable.btn_playback_shuffle_all);
+                appWidgetView.setInt(R.id.app_widget_large_alternate_shuffle, "setAlpha",
+                        (int) (ShuffleButton.INACTIVE_ALPHA * 255));
+                break;
+            case MusicPlaybackService.SHUFFLE_AUTO:
+            case MusicPlaybackService.SHUFFLE_NORMAL:
+            default:
+                appWidgetView.setImageViewResource(R.id.app_widget_large_alternate_shuffle,
+                        R.drawable.btn_playback_shuffle_all);
+                appWidgetView.setInt(R.id.app_widget_large_alternate_shuffle, "setAlpha",
+                        (int) (ShuffleButton.ACTIVE_ALPHA * 255));
+                break;
+        }
+
+        // Link actions buttons to intents
+        linkButtons(service, appWidgetView);
+
+        // Update the app-widget
+        pushUpdate(service, appWidgetIds, appWidgetView);
+    }
+
+    /**
+     * Link up various button actions using {@link PendingIntents}.
+     */
+    private void linkButtons(final Context context, final RemoteViews views) {
+        Intent action;
+        PendingIntent pendingIntent;
+
+        final ComponentName serviceName = new ComponentName(context, MusicPlaybackService.class);
+
+        // Home
+        action = new Intent(context, HomeActivity.class);
+        action.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        pendingIntent = PendingIntent.getActivity(context, 0, action, 0);
+        views.setOnClickPendingIntent(R.id.app_widget_large_alternate_info_container,
+                pendingIntent);
+        views.setOnClickPendingIntent(R.id.app_widget_large_alternate_image, pendingIntent);
+
+        // Shuffle modes
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.SHUFFLE_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_large_alternate_shuffle, pendingIntent);
+
+        // Previous track
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.PREVIOUS_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_large_alternate_previous, pendingIntent);
+
+        // Play and pause
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.TOGGLEPAUSE_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_large_alternate_play, pendingIntent);
+
+        // Next track
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.NEXT_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_large_alternate_next, pendingIntent);
+
+        // Repeat modes
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.REPEAT_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_large_alternate_repeat, pendingIntent);
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetSmall.java b/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetSmall.java
new file mode 100755
index 0000000000..81a1df29c2
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/appwidgets/AppWidgetSmall.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.appwidgets;
+
+import android.annotation.SuppressLint;
+import android.app.PendingIntent;
+import android.appwidget.AppWidgetManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.text.TextUtils;
+import android.view.View;
+import android.widget.RemoteViews;
+
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.activities.HomeActivity;
+
+/**
+ * 4x1 App-Widget
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+@SuppressLint("NewApi")
+public class AppWidgetSmall extends AppWidgetBase {
+
+    public static final String CMDAPPWIDGETUPDATE = "app_widget_small_update";
+
+    private static AppWidgetSmall mInstance;
+
+    public static synchronized AppWidgetSmall getInstance() {
+        if (mInstance == null) {
+            mInstance = new AppWidgetSmall();
+        }
+        return mInstance;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onUpdate(final Context context, final AppWidgetManager appWidgetManager,
+                         final int[] appWidgetIds) {
+        defaultAppWidget(context, appWidgetIds);
+        final Intent updateIntent = new Intent(MusicPlaybackService.SERVICECMD);
+        updateIntent.putExtra(MusicPlaybackService.CMDNAME, AppWidgetSmall.CMDAPPWIDGETUPDATE);
+        updateIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds);
+        updateIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
+        context.sendBroadcast(updateIntent);
+    }
+
+    /**
+     * Initialize given widgets to default state, where we launch Music on
+     * default click and hide actions if service not running.
+     */
+    private void defaultAppWidget(final Context context, final int[] appWidgetIds) {
+        final RemoteViews appWidgetViews = new RemoteViews(context.getPackageName(),
+                R.layout.app_widget_small);
+        appWidgetViews.setViewVisibility(R.id.app_widget_small_info_container, View.INVISIBLE);
+        linkButtons(context, appWidgetViews);
+        pushUpdate(context, appWidgetIds, appWidgetViews);
+    }
+
+    private void pushUpdate(final Context context, final int[] appWidgetIds, final RemoteViews views) {
+        final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
+        if (appWidgetIds != null) {
+            appWidgetManager.updateAppWidget(appWidgetIds, views);
+        } else {
+            appWidgetManager.updateAppWidget(new ComponentName(context, getClass()), views);
+        }
+    }
+
+    /**
+     * Check against {@link AppWidgetManager} if there are any instances of this
+     * widget.
+     */
+    private boolean hasInstances(final Context context) {
+        final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
+        final int[] mAppWidgetIds = appWidgetManager.getAppWidgetIds(new ComponentName(context,
+                getClass()));
+        return mAppWidgetIds.length > 0;
+    }
+
+    /**
+     * Handle a change notification coming over from
+     * {@link MusicPlaybackService}
+     */
+    public void notifyChange(final MusicPlaybackService service, final String what) {
+        if (hasInstances(service)) {
+            if (MusicPlaybackService.META_CHANGED.equals(what)
+                    || MusicPlaybackService.PLAYSTATE_CHANGED.equals(what)) {
+                performUpdate(service, null);
+            }
+        }
+    }
+
+    /**
+     * Update all active widget instances by pushing changes
+     */
+    public void performUpdate(final MusicPlaybackService service, final int[] appWidgetIds) {
+        final RemoteViews appWidgetView = new RemoteViews(service.getPackageName(),
+                R.layout.app_widget_small);
+
+        final CharSequence trackName = service.getTrackName();
+        final CharSequence artistName = service.getArtistName();
+        final Bitmap bitmap = service.getAlbumArt(true).getBitmap();
+
+        // Set the titles and artwork
+        if (TextUtils.isEmpty(trackName) && TextUtils.isEmpty(artistName)) {
+            appWidgetView.setViewVisibility(R.id.app_widget_small_info_container, View.INVISIBLE);
+        } else {
+            appWidgetView.setViewVisibility(R.id.app_widget_small_info_container, View.VISIBLE);
+            appWidgetView.setTextViewText(R.id.app_widget_small_line_one, trackName);
+            appWidgetView.setTextViewText(R.id.app_widget_small_line_two, artistName);
+        }
+        appWidgetView.setImageViewBitmap(R.id.app_widget_small_image, bitmap);
+
+        // Set correct drawable for pause state
+        final boolean isPlaying = service.isPlaying();
+        if (isPlaying) {
+            appWidgetView.setImageViewResource(R.id.app_widget_small_play,
+                    R.drawable.btn_playback_pause);
+            appWidgetView.setContentDescription(R.id.app_widget_small_play,
+                    service.getString(R.string.accessibility_pause));
+        } else {
+            appWidgetView.setImageViewResource(R.id.app_widget_small_play,
+                    R.drawable.btn_playback_play);
+            appWidgetView.setContentDescription(R.id.app_widget_small_play,
+                    service.getString(R.string.accessibility_play));
+        }
+
+        // Link actions buttons to intents
+        linkButtons(service, appWidgetView);
+
+        // Update the app-widget
+        pushUpdate(service, appWidgetIds, appWidgetView);
+    }
+
+    /**
+     * Link up various button actions using {@link PendingIntents}.
+     */
+    private void linkButtons(final Context context, final RemoteViews views) {
+        Intent action;
+        PendingIntent pendingIntent;
+
+        final ComponentName serviceName = new ComponentName(context, MusicPlaybackService.class);
+
+        // Home
+        action = new Intent(context, HomeActivity.class);
+        action.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        pendingIntent = PendingIntent.getActivity(context, 0, action, 0);
+        views.setOnClickPendingIntent(R.id.app_widget_small_info_container, pendingIntent);
+        views.setOnClickPendingIntent(R.id.app_widget_small_image, pendingIntent);
+
+        // Previous track
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.PREVIOUS_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_small_previous, pendingIntent);
+
+        // Play and pause
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.TOGGLEPAUSE_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_small_play, pendingIntent);
+
+        // Next track
+        pendingIntent = buildPendingIntent(context, MusicPlaybackService.NEXT_ACTION, serviceName);
+        views.setOnClickPendingIntent(R.id.app_widget_small_next, pendingIntent);
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/BitmapWorkerTask.java b/twelve/src/main/java/com/dolzzo/twelve/cache/BitmapWorkerTask.java
new file mode 100755
index 0000000000..12a03d46bf
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/BitmapWorkerTask.java
@@ -0,0 +1,148 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.cache;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
+import android.os.AsyncTask;
+import android.widget.ImageView;
+
+import com.dolzzo.twelve.cache.ImageWorker.ImageType;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * The actual {@link android.os.AsyncTask} that will process the image.
+ */
+public abstract class BitmapWorkerTask<Params, Progress, Result>
+        extends AsyncTask<Params, Progress, Result> {
+    /**
+     * The {@link android.widget.ImageView} used to set the result
+     */
+    protected final WeakReference<ImageView> mImageReference;
+
+    /**
+     * Type of URL to download
+     */
+    protected final ImageWorker.ImageType mImageType;
+    protected final Context mContext;
+    protected final ImageCache mImageCache;
+    protected final Resources mResources;
+    /**
+     * The key used to store cached entries
+     */
+    public String mKey;
+    /**
+     * Layer drawable used to cross fade the result from the worker
+     */
+    protected Drawable mFromDrawable;
+    protected boolean mScaleImgToView;
+
+    /**
+     * Constructor of <code>BitmapWorkerTask</code>
+     *
+     * @param key          used for caching the image
+     * @param imageView    The {@link ImageView} to use.
+     * @param imageType    The type of image URL to fetch for.
+     * @param fromDrawable what drawable to transition from
+     */
+    public BitmapWorkerTask(final String key, final ImageView imageView, final ImageType imageType,
+                            final Drawable fromDrawable, final Context context) {
+        this(key, imageView, imageType, fromDrawable, context, false);
+    }
+
+    /**
+     * Constructor of <code>BitmapWorkerTask</code>
+     *
+     * @param key            used for caching the image
+     * @param imageView      The {@link ImageView} to use.
+     * @param imageType      The type of image URL to fetch for.
+     * @param fromDrawable   what drawable to transition from
+     * @param scaleImgToView flag to scale the bitmap to the image view bounds
+     */
+    public BitmapWorkerTask(final String key, final ImageView imageView, final ImageType imageType,
+                            final Drawable fromDrawable, final Context context, final boolean scaleImgToView) {
+        mKey = key;
+
+        mContext = context;
+        mImageCache = ImageCache.getInstance(mContext);
+        mResources = mContext.getResources();
+
+        mImageReference = new WeakReference<ImageView>(imageView);
+        mImageType = imageType;
+
+        // A transparent image (layer 0) and the new result (layer 1)
+        mFromDrawable = fromDrawable;
+
+        mScaleImgToView = scaleImgToView;
+    }
+
+    /**
+     * @return The {@link ImageView} associated with this task as long as
+     * the ImageView's task still points to this task as well.
+     * Returns null otherwise.
+     */
+    protected ImageView getAttachedImageView() {
+        final ImageView imageView = mImageReference.get();
+        if (imageView != null) {
+            final BitmapWorkerTask bitmapWorkerTask = ImageWorker.getBitmapWorkerTask(imageView);
+            if (this == bitmapWorkerTask) {
+                return imageView;
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Gets the bitmap given the input params
+     *
+     * @param params artistName, albumName, albumId
+     * @return Bitmap
+     */
+    protected Bitmap getBitmapInBackground(final String... params) {
+        return ImageWorker.getBitmapInBackground(mContext, mImageCache, mKey,
+                params[1], params[0], Long.valueOf(params[2]), mImageType);
+    }
+
+    /**
+     * Creates a transition drawable with default parameters
+     *
+     * @param bitmap the bitmap to transition to
+     * @return the transition drawable
+     */
+    protected TransitionDrawable createImageTransitionDrawable(final Bitmap bitmap) {
+        return createImageTransitionDrawable(bitmap, ImageWorker.FADE_IN_TIME, false, false);
+    }
+
+    /**
+     * Creates a transition drawable
+     *
+     * @param bitmap   to transition to
+     * @param fadeTime the time to fade in ms
+     * @param dither   setting
+     * @param force    force create a transition even if bitmap == null (fade to transparent)
+     * @return the transition drawable
+     */
+    protected TransitionDrawable createImageTransitionDrawable(final Bitmap bitmap,
+                                                               final int fadeTime, final boolean dither, final boolean force) {
+        return ImageWorker.createImageTransitionDrawable(mResources, mFromDrawable, bitmap,
+                fadeTime, dither, force);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/BlurBitmapWorkerTask.java b/twelve/src/main/java/com/dolzzo/twelve/cache/BlurBitmapWorkerTask.java
new file mode 100755
index 0000000000..b909c54a9d
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/BlurBitmapWorkerTask.java
@@ -0,0 +1,179 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.cache;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
+import android.support.v8.renderscript.Allocation;
+import android.support.v8.renderscript.Element;
+import android.support.v8.renderscript.RenderScript;
+import android.support.v8.renderscript.ScriptIntrinsicBlur;
+import android.widget.ImageView;
+
+import com.dolzzo.twelve.cache.ImageWorker.ImageType;
+import com.dolzzo.twelve.widgets.BlurScrimImage;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * This will download the image (if needed) and create a blur and set the scrim as well on the
+ * BlurScrimImage
+ */
+public class BlurBitmapWorkerTask extends BitmapWorkerTask<String, Void, BlurBitmapWorkerTask.ResultContainer> {
+    // if the image is too small, the blur will look bad post scale up so we use the min size
+    // to scale up before bluring
+    private static final int MIN_BITMAP_SIZE = 500;
+    // number of times to run the blur
+    private static final int NUM_BLUR_RUNS = 8;
+    // 25f is the max blur radius possible
+    private static final float BLUR_RADIUS = 25f;
+    /**
+     * RenderScript used to blur the image
+     */
+    protected final RenderScript mRenderScript;
+    /**
+     * The {@link com.dolzzo.twelve.widgets.BlurScrimImage} used to set the result
+     */
+    private final WeakReference<BlurScrimImage> mBlurScrimImage;
+
+    /**
+     * Constructor of <code>BlurBitmapWorkerTask</code>
+     *
+     * @param key            used for caching the image
+     * @param blurScrimImage The {@link BlurScrimImage} to use.
+     * @param imageType      The type of image URL to fetch for.
+     * @param fromDrawable   what drawable to transition from
+     */
+    public BlurBitmapWorkerTask(final String key, final BlurScrimImage blurScrimImage,
+                                final ImageType imageType, final Drawable fromDrawable,
+                                final Context context, final RenderScript renderScript) {
+        super(key, blurScrimImage.getImageView(), imageType, fromDrawable, context);
+        mBlurScrimImage = new WeakReference<BlurScrimImage>(blurScrimImage);
+        mRenderScript = renderScript;
+
+        // use the existing image as the drawable and if it doesn't exist fallback to transparent
+        mFromDrawable = blurScrimImage.getImageView().getDrawable();
+        if (mFromDrawable == null) {
+            mFromDrawable = fromDrawable;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected ResultContainer doInBackground(final String... params) {
+        if (isCancelled()) {
+            return null;
+        }
+
+        Bitmap bitmap = getBitmapInBackground(params);
+
+        ResultContainer result = new ResultContainer();
+
+        Bitmap output = null;
+
+        if (bitmap != null) {
+            // now create the blur bitmap
+            Bitmap input = bitmap;
+
+            // if the image is too small, scale it up before running through the blur
+            if (input.getWidth() < MIN_BITMAP_SIZE || input.getHeight() < MIN_BITMAP_SIZE) {
+                float multiplier = Math.max(MIN_BITMAP_SIZE / (float) input.getWidth(),
+                        MIN_BITMAP_SIZE / (float) input.getHeight());
+                input = input.createScaledBitmap(bitmap, (int) (input.getWidth() * multiplier),
+                        (int) (input.getHeight() * multiplier), true);
+                // since we created a new bitmap, we can re-use the bitmap for our output
+                output = input;
+            } else {
+                // if we aren't creating a new bitmap, create a new output bitmap
+                output = Bitmap.createBitmap(input.getWidth(), input.getHeight(), input.getConfig());
+            }
+
+            // run the blur multiple times
+            for (int i = 0; i < NUM_BLUR_RUNS; i++) {
+                final Allocation inputAlloc = Allocation.createFromBitmap(mRenderScript, input);
+                final Allocation outputAlloc = Allocation.createTyped(mRenderScript,
+                        inputAlloc.getType());
+                final ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(mRenderScript,
+                        Element.U8_4(mRenderScript));
+
+                script.setRadius(BLUR_RADIUS);
+                script.setInput(inputAlloc);
+                script.forEach(outputAlloc);
+                outputAlloc.copyTo(output);
+
+                // if we run more than 1 blur, the new input should be the old output
+                input = output;
+            }
+
+            // Set the scrim color to be 50% gray
+            result.mPaletteColor = 0x7f000000;
+
+            // create the bitmap transition drawable
+            result.mImageViewBitmapDrawable = createImageTransitionDrawable(output,
+                    ImageWorker.FADE_IN_TIME_SLOW, true, true);
+
+            return result;
+        }
+
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onPostExecute(ResultContainer resultContainer) {
+        BlurScrimImage blurScrimImage = mBlurScrimImage.get();
+        if (blurScrimImage != null) {
+            if (resultContainer == null) {
+                // if we have no image, then signal the transition to the default state
+                blurScrimImage.transitionToDefaultState();
+            } else {
+                // create the palette transition
+                TransitionDrawable paletteTransition = ImageWorker.createPaletteTransition(
+                        blurScrimImage,
+                        resultContainer.mPaletteColor);
+
+                // set the transition drawable
+                blurScrimImage.setTransitionDrawable(resultContainer.mImageViewBitmapDrawable,
+                        paletteTransition);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected final ImageView getAttachedImageView() {
+        final BlurScrimImage blurImage = mBlurScrimImage.get();
+        final BitmapWorkerTask bitmapWorkerTask = ImageWorker.getBitmapWorkerTask(blurImage);
+        if (this == bitmapWorkerTask) {
+            return blurImage.getImageView();
+        }
+        return null;
+    }
+
+    // container for the result
+    public static class ResultContainer {
+        public TransitionDrawable mImageViewBitmapDrawable;
+        public int mPaletteColor;
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/DiskLruCache.java b/twelve/src/main/java/com/dolzzo/twelve/cache/DiskLruCache.java
new file mode 100755
index 0000000000..f3e68ba8f6
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/DiskLruCache.java
@@ -0,0 +1,970 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project Licensed under the Apache
+ * License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.cache;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedWriter;
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileWriter;
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.lang.reflect.Array;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * ***************************************************************************** Taken from the JB source code, can be found in:
+ * libcore/luni/src/main/java/libcore/io/DiskLruCache.java or direct link:
+ * https:
+ * //android.googlesource.com/platform/libcore/+/android-4.1.1_r1/luni/src/
+ * main/java/libcore/io/DiskLruCache.java A cache that uses a bounded amount of
+ * space on a filesystem. Each cache entry has a string key and a fixed number
+ * of values. Values are byte sequences, accessible as streams or files. Each
+ * value must be between {@code 0} and {@code Integer.MAX_VALUE} bytes in
+ * length.
+ * <p>
+ * The cache stores its data in a directory on the filesystem. This directory
+ * must be exclusive to the cache; the cache may delete or overwrite files from
+ * its directory. It is an error for multiple processes to use the same cache
+ * directory at the same time.
+ * <p>
+ * This cache limits the number of bytes that it will store on the filesystem.
+ * When the number of stored bytes exceeds the limit, the cache will remove
+ * entries in the background until the limit is satisfied. The limit is not
+ * strict: the cache may temporarily exceed it while waiting for files to be
+ * deleted. The limit does not include filesystem overhead or the cache journal
+ * so space-sensitive applications should set a conservative limit.
+ * <p>
+ * Clients call {@link #edit} to create or update the values of an entry. An
+ * entry may have only one editor at one time; if a value is not available to be
+ * edited then {@link #edit} will return null.
+ * <ul>
+ * <li>When an entry is being <strong>created</strong> it is necessary to supply
+ * a full set of values; the empty value should be used as a placeholder if
+ * necessary.
+ * <li>When an entry is being <strong>edited</strong>, it is not necessary to
+ * supply data for every value; values default to their previous value.
+ * </ul>
+ * Every {@link #edit} call must be matched by a call to {@link Editor#commit}
+ * or {@link Editor#abort}. Committing is atomic: a read observes the full set
+ * of values as they were before or after the commit, but never a mix of values.
+ * <p>
+ * Clients call {@link #get} to read a snapshot of an entry. The read will
+ * observe the value at the time that {@link #get} was called. Updates and
+ * removals after the call do not impact ongoing reads.
+ * <p>
+ * This class is tolerant of some I/O errors. If files are missing from the
+ * filesystem, the corresponding entries will be dropped from the cache. If an
+ * error occurs while writing a cache value, the edit will fail silently.
+ * Callers should handle other problems by catching {@code IOException} and
+ * responding appropriately.
+ */
+public final class DiskLruCache implements Closeable {
+    static final String JOURNAL_FILE = "journal";
+
+    static final String JOURNAL_FILE_TMP = "journal.tmp";
+
+    static final String MAGIC = "libcore.io.DiskLruCache";
+
+    static final String VERSION_1 = "1";
+
+    static final long ANY_SEQUENCE_NUMBER = -1;
+
+    private static final String CLEAN = "CLEAN";
+
+    private static final String DIRTY = "DIRTY";
+
+    private static final String REMOVE = "REMOVE";
+
+    private static final String READ = "READ";
+
+    private static final Charset UTF_8 = Charset.forName("UTF-8");
+
+    private static final int IO_BUFFER_SIZE = 8 * 1024;
+
+    /*
+     * This cache uses a journal file named "journal". A typical journal file
+     * looks like this: libcore.io.DiskLruCache 1 100 2 CLEAN
+     * 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY
+     * 335c4c6028171cfddfbaae1a9c313c52 CLEAN 335c4c6028171cfddfbaae1a9c313c52
+     * 3934 2342 REMOVE 335c4c6028171cfddfbaae1a9c313c52 DIRTY
+     * 1ab96a171faeeee38496d8b330771a7a CLEAN 1ab96a171faeeee38496d8b330771a7a
+     * 1600 234 READ 335c4c6028171cfddfbaae1a9c313c52 READ
+     * 3400330d1dfc7f3f7f4b8d4d803dfcf6 The first five lines of the journal form
+     * its header. They are the constant string "libcore.io.DiskLruCache", the
+     * disk cache's version, the application's version, the value count, and a
+     * blank line. Each of the subsequent lines in the file is a record of the
+     * state of a cache entry. Each line contains space-separated values: a
+     * state, a key, and optional state-specific values. o DIRTY lines track
+     * that an entry is actively being created or updated. Every successful
+     * DIRTY action should be followed by a CLEAN or REMOVE action. DIRTY lines
+     * without a matching CLEAN or REMOVE indicate that temporary files may need
+     * to be deleted. o CLEAN lines track a cache entry that has been
+     * successfully published and may be read. A publish line is followed by the
+     * lengths of each of its values. o READ lines track accesses for LRU. o
+     * REMOVE lines track entries that have been deleted. The journal file is
+     * appended to as cache operations occur. The journal may occasionally be
+     * compacted by dropping redundant lines. A temporary file named
+     * "journal.tmp" will be used during compaction; that file should be deleted
+     * if it exists when the cache is opened.
+     */
+
+    private final File directory;
+
+    private final File journalFile;
+
+    private final File journalFileTmp;
+
+    private final int appVersion;
+
+    private final long maxSize;
+
+    private final int valueCount;
+    private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<String, Entry>(0,
+            0.75f, true);
+    /**
+     * This cache uses a single background thread to evict entries.
+     */
+    private final ExecutorService executorService = new ThreadPoolExecutor(0, 1, 60L,
+            TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+    private long size = 0;
+    private Writer journalWriter;
+    private int redundantOpCount;
+    private final Callable<Void> cleanupCallable = new Callable<Void>() {
+        @Override
+        public Void call() throws Exception {
+            synchronized (DiskLruCache.this) {
+                if (journalWriter == null) {
+                    return null; // closed
+                }
+                trimToSize();
+                if (journalRebuildRequired()) {
+                    rebuildJournal();
+                    redundantOpCount = 0;
+                }
+            }
+            return null;
+        }
+    };
+    /**
+     * To differentiate between old and current snapshots, each entry is given a
+     * sequence number each time an edit is committed. A snapshot is stale if
+     * its sequence number is not equal to its entry's sequence number.
+     */
+    private long nextSequenceNumber = 0;
+
+    private DiskLruCache(final File directory, final int appVersion, final int valueCount,
+                         final long maxSize) {
+        this.directory = directory;
+        this.appVersion = appVersion;
+        journalFile = new File(directory, JOURNAL_FILE);
+        journalFileTmp = new File(directory, JOURNAL_FILE_TMP);
+        this.valueCount = valueCount;
+        this.maxSize = maxSize;
+    }
+
+    /* From java.util.Arrays */
+    @SuppressWarnings("unchecked")
+    private static <T> T[] copyOfRange(final T[] original, final int start, final int end) {
+        final int originalLength = original.length; // For exception priority
+        // compatibility.
+        if (start > end) {
+            throw new IllegalArgumentException();
+        }
+        if (start < 0 || start > originalLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        final int resultLength = end - start;
+        final int copyLength = Math.min(resultLength, originalLength - start);
+        final T[] result = (T[]) Array.newInstance(original.getClass().getComponentType(),
+                resultLength);
+        System.arraycopy(original, start, result, 0, copyLength);
+        return result;
+    }
+
+    /**
+     * Returns the remainder of 'reader' as a string, closing it when done.
+     */
+    public static String readFully(final Reader reader) throws IOException {
+        try {
+            final StringWriter writer = new StringWriter();
+            final char[] buffer = new char[1024];
+            int count;
+            while ((count = reader.read(buffer)) != -1) {
+                writer.write(buffer, 0, count);
+            }
+            return writer.toString();
+        } finally {
+            reader.close();
+        }
+    }
+
+    /**
+     * Returns the ASCII characters up to but not including the next "\r\n", or
+     * "\n".
+     *
+     * @throws java.io.EOFException if the stream is exhausted before the next
+     *                              newline character.
+     */
+    public static String readAsciiLine(final InputStream in) throws IOException {
+        // TODO: support UTF-8 here instead
+
+        final StringBuilder result = new StringBuilder(80);
+        while (true) {
+            final int c = in.read();
+            if (c == -1) {
+                throw new EOFException();
+            } else if (c == '\n') {
+                break;
+            }
+
+            result.append((char) c);
+        }
+        final int length = result.length();
+        if (length > 0 && result.charAt(length - 1) == '\r') {
+            result.setLength(length - 1);
+        }
+        return result.toString();
+    }
+
+    /**
+     * Closes 'closeable', ignoring any checked exceptions. Does nothing if
+     * 'closeable' is null.
+     */
+    public static void closeQuietly(final Closeable closeable) {
+        if (closeable != null) {
+            try {
+                closeable.close();
+            } catch (final RuntimeException rethrown) {
+                throw rethrown;
+            } catch (final Exception ignored) {
+            }
+        }
+    }
+
+    /**
+     * Recursively delete everything in {@code dir}.
+     */
+    // TODO: this should specify paths as Strings rather than as Files
+    public static void deleteContents(final File dir) throws IOException {
+        final File[] files = dir.listFiles();
+        if (files == null) {
+            throw new IllegalArgumentException("not a directory: " + dir);
+        }
+        for (final File file : files) {
+            if (file.isDirectory()) {
+                deleteContents(file);
+            }
+            if (!file.delete()) {
+                throw new IOException("failed to delete file: " + file);
+            }
+        }
+    }
+
+    /**
+     * Opens the cache in {@code directory}, creating a cache if none exists
+     * there.
+     *
+     * @param directory  a writable directory
+     * @param appVersion
+     * @param valueCount the number of values per cache entry. Must be positive.
+     * @param maxSize    the maximum number of bytes this cache should use to store
+     * @throws IOException if reading or writing the cache directory fails
+     */
+    public static DiskLruCache open(final File directory, final int appVersion,
+                                    final int valueCount, final long maxSize) throws IOException {
+        if (maxSize <= 0) {
+            throw new IllegalArgumentException("maxSize <= 0");
+        }
+        if (valueCount <= 0) {
+            throw new IllegalArgumentException("valueCount <= 0");
+        }
+
+        // prefer to pick up where we left off
+        DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
+        if (cache.journalFile.exists()) {
+            try {
+                cache.readJournal();
+                cache.processJournal();
+                cache.journalWriter = new BufferedWriter(new FileWriter(cache.journalFile, true),
+                        IO_BUFFER_SIZE);
+                return cache;
+            } catch (final IOException journalIsCorrupt) {
+                // System.logW("DiskLruCache " + directory + " is corrupt: "
+                // + journalIsCorrupt.getMessage() + ", removing");
+                cache.delete();
+            }
+        }
+
+        // create a new empty cache
+        directory.mkdirs();
+        cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
+        cache.rebuildJournal();
+        return cache;
+    }
+
+    private static void deleteIfExists(final File file) throws IOException {
+        // try {
+        // Libcore.os.remove(file.getPath());
+        // } catch (ErrnoException errnoException) {
+        // if (errnoException.errno != OsConstants.ENOENT) {
+        // throw errnoException.rethrowAsIOException();
+        // }
+        // }
+        if (file.exists() && !file.delete()) {
+            throw new IOException();
+        }
+    }
+
+    private static String inputStreamToString(final InputStream in) throws IOException {
+        return readFully(new InputStreamReader(in, UTF_8));
+    }
+
+    private void readJournal() throws IOException {
+        final InputStream in = new BufferedInputStream(new FileInputStream(journalFile),
+                IO_BUFFER_SIZE);
+        try {
+            final String magic = readAsciiLine(in);
+            final String version = readAsciiLine(in);
+            final String appVersionString = readAsciiLine(in);
+            final String valueCountString = readAsciiLine(in);
+            final String blank = readAsciiLine(in);
+            if (!MAGIC.equals(magic) || !VERSION_1.equals(version)
+                    || !Integer.toString(appVersion).equals(appVersionString)
+                    || !Integer.toString(valueCount).equals(valueCountString) || !"".equals(blank)) {
+                throw new IOException("unexpected journal header: [" + magic + ", " + version
+                        + ", " + valueCountString + ", " + blank + "]");
+            }
+
+            while (true) {
+                try {
+                    readJournalLine(readAsciiLine(in));
+                } catch (final EOFException endOfJournal) {
+                    break;
+                }
+            }
+        } finally {
+            closeQuietly(in);
+        }
+    }
+
+    private void readJournalLine(final String line) throws IOException {
+        final String[] parts = line.split(" ");
+        if (parts.length < 2) {
+            throw new IOException("unexpected journal line: " + line);
+        }
+
+        final String key = parts[1];
+        if (parts[0].equals(REMOVE) && parts.length == 2) {
+            lruEntries.remove(key);
+            return;
+        }
+
+        Entry entry = lruEntries.get(key);
+        if (entry == null) {
+            entry = new Entry(key);
+            lruEntries.put(key, entry);
+        }
+
+        if (parts[0].equals(CLEAN) && parts.length == 2 + valueCount) {
+            entry.readable = true;
+            entry.currentEditor = null;
+            entry.setLengths(copyOfRange(parts, 2, parts.length));
+        } else if (parts[0].equals(DIRTY) && parts.length == 2) {
+            entry.currentEditor = new Editor(entry);
+        } else if (parts[0].equals(READ) && parts.length == 2) {
+            // this work was already done by calling lruEntries.get()
+        } else {
+            throw new IOException("unexpected journal line: " + line);
+        }
+    }
+
+    /**
+     * Computes the initial size and collects garbage as a part of opening the
+     * cache. Dirty entries are assumed to be inconsistent and will be deleted.
+     */
+    private void processJournal() throws IOException {
+        deleteIfExists(journalFileTmp);
+        for (final Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
+            final Entry entry = i.next();
+            if (entry.currentEditor == null) {
+                for (int t = 0; t < valueCount; t++) {
+                    size += entry.lengths[t];
+                }
+            } else {
+                entry.currentEditor = null;
+                for (int t = 0; t < valueCount; t++) {
+                    deleteIfExists(entry.getCleanFile(t));
+                    deleteIfExists(entry.getDirtyFile(t));
+                }
+                i.remove();
+            }
+        }
+    }
+
+    /**
+     * Creates a new journal that omits redundant information. This replaces the
+     * current journal if it exists.
+     */
+    private synchronized void rebuildJournal() throws IOException {
+        if (journalWriter != null) {
+            journalWriter.close();
+        }
+
+        final Writer writer = new BufferedWriter(new FileWriter(journalFileTmp), IO_BUFFER_SIZE);
+        writer.write(MAGIC);
+        writer.write("\n");
+        writer.write(VERSION_1);
+        writer.write("\n");
+        writer.write(Integer.toString(appVersion));
+        writer.write("\n");
+        writer.write(Integer.toString(valueCount));
+        writer.write("\n");
+        writer.write("\n");
+
+        for (final Entry entry : lruEntries.values()) {
+            if (entry.currentEditor != null) {
+                writer.write(DIRTY + ' ' + entry.key + '\n');
+            } else {
+                writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+            }
+        }
+
+        writer.close();
+        journalFileTmp.renameTo(journalFile);
+        journalWriter = new BufferedWriter(new FileWriter(journalFile, true), IO_BUFFER_SIZE);
+    }
+
+    /**
+     * Returns a snapshot of the entry named {@code key}, or null if it doesn't
+     * exist is not currently readable. If a value is returned, it is moved to
+     * the head of the LRU queue.
+     */
+    public synchronized Snapshot get(final String key) throws IOException {
+        checkNotClosed();
+        validateKey(key);
+        final Entry entry = lruEntries.get(key);
+        if (entry == null) {
+            return null;
+        }
+
+        if (!entry.readable) {
+            return null;
+        }
+
+        /*
+         * Open all streams eagerly to guarantee that we see a single published
+         * snapshot. If we opened streams lazily then the streams could come
+         * from different edits.
+         */
+        final InputStream[] ins = new InputStream[valueCount];
+        try {
+            for (int i = 0; i < valueCount; i++) {
+                ins[i] = new FileInputStream(entry.getCleanFile(i));
+            }
+        } catch (final FileNotFoundException e) {
+            // a file must have been deleted manually!
+            return null;
+        }
+
+        redundantOpCount++;
+        journalWriter.append(READ + ' ').append(key).append('\n');
+        if (journalRebuildRequired()) {
+            executorService.submit(cleanupCallable);
+        }
+
+        return new Snapshot(key, entry.sequenceNumber, ins);
+    }
+
+    /**
+     * Returns an editor for the entry named {@code key}, or null if another
+     * edit is in progress.
+     */
+    public Editor edit(final String key) throws IOException {
+        return edit(key, ANY_SEQUENCE_NUMBER);
+    }
+
+    private synchronized Editor edit(final String key, final long expectedSequenceNumber)
+            throws IOException {
+        checkNotClosed();
+        validateKey(key);
+        Entry entry = lruEntries.get(key);
+        if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER
+                && (entry == null || entry.sequenceNumber != expectedSequenceNumber)) {
+            return null; // snapshot is stale
+        }
+        if (entry == null) {
+            entry = new Entry(key);
+            lruEntries.put(key, entry);
+        } else if (entry.currentEditor != null) {
+            return null; // another edit is in progress
+        }
+
+        final Editor editor = new Editor(entry);
+        entry.currentEditor = editor;
+
+        // flush the journal before creating files to prevent file leaks
+        journalWriter.write(DIRTY + ' ' + key + '\n');
+        journalWriter.flush();
+        return editor;
+    }
+
+    /**
+     * Returns the directory where this cache stores its data.
+     */
+    public File getDirectory() {
+        return directory;
+    }
+
+    /**
+     * Returns the maximum number of bytes that this cache should use to store
+     * its data.
+     */
+    public long maxSize() {
+        return maxSize;
+    }
+
+    /**
+     * Returns the number of bytes currently being used to store the values in
+     * this cache. This may be greater than the max size if a background
+     * deletion is pending.
+     */
+    public synchronized long size() {
+        return size;
+    }
+
+    private synchronized void completeEdit(final Editor editor, final boolean success)
+            throws IOException {
+        final Entry entry = editor.entry;
+        if (entry.currentEditor != editor) {
+            throw new IllegalStateException();
+        }
+
+        // if this edit is creating the entry for the first time, every index
+        // must have a value
+        if (success && !entry.readable) {
+            for (int i = 0; i < valueCount; i++) {
+                if (!entry.getDirtyFile(i).exists()) {
+                    editor.abort();
+                    throw new IllegalStateException("edit didn't create file " + i);
+                }
+            }
+        }
+
+        for (int i = 0; i < valueCount; i++) {
+            final File dirty = entry.getDirtyFile(i);
+            if (success) {
+                if (dirty.exists()) {
+                    final File clean = entry.getCleanFile(i);
+                    dirty.renameTo(clean);
+                    final long oldLength = entry.lengths[i];
+                    final long newLength = clean.length();
+                    entry.lengths[i] = newLength;
+                    size = size - oldLength + newLength;
+                }
+            } else {
+                deleteIfExists(dirty);
+            }
+        }
+
+        redundantOpCount++;
+        entry.currentEditor = null;
+        if (entry.readable | success) {
+            entry.readable = true;
+            journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+            if (success) {
+                entry.sequenceNumber = nextSequenceNumber++;
+            }
+        } else {
+            lruEntries.remove(entry.key);
+            journalWriter.write(REMOVE + ' ' + entry.key + '\n');
+        }
+
+        if (size > maxSize || journalRebuildRequired()) {
+            executorService.submit(cleanupCallable);
+        }
+    }
+
+    /**
+     * We only rebuild the journal when it will halve the size of the journal
+     * and eliminate at least 2000 ops.
+     */
+    private boolean journalRebuildRequired() {
+        final int REDUNDANT_OP_COMPACT_THRESHOLD = 2000;
+        return redundantOpCount >= REDUNDANT_OP_COMPACT_THRESHOLD
+                && redundantOpCount >= lruEntries.size();
+    }
+
+    /**
+     * Drops the entry for {@code key} if it exists and can be removed. Entries
+     * actively being edited cannot be removed.
+     *
+     * @return true if an entry was removed.
+     */
+    public synchronized boolean remove(final String key) throws IOException {
+        checkNotClosed();
+        validateKey(key);
+        final Entry entry = lruEntries.get(key);
+        if (entry == null || entry.currentEditor != null) {
+            return false;
+        }
+
+        for (int i = 0; i < valueCount; i++) {
+            final File file = entry.getCleanFile(i);
+            if (!file.delete()) {
+                throw new IOException("failed to delete " + file);
+            }
+            size -= entry.lengths[i];
+            entry.lengths[i] = 0;
+        }
+
+        redundantOpCount++;
+        journalWriter.append(REMOVE + ' ').append(key).append('\n');
+        lruEntries.remove(key);
+
+        if (journalRebuildRequired()) {
+            executorService.submit(cleanupCallable);
+        }
+
+        return true;
+    }
+
+    /**
+     * Returns true if this cache has been closed.
+     */
+    public boolean isClosed() {
+        return journalWriter == null;
+    }
+
+    private void checkNotClosed() {
+        if (journalWriter == null) {
+            throw new IllegalStateException("cache is closed");
+        }
+    }
+
+    /**
+     * Force buffered operations to the filesystem.
+     */
+    public synchronized void flush() throws IOException {
+        checkNotClosed();
+        trimToSize();
+        journalWriter.flush();
+    }
+
+    /**
+     * Closes this cache. Stored values will remain on the filesystem.
+     */
+    @Override
+    public synchronized void close() throws IOException {
+        if (journalWriter == null) {
+            return; // already closed
+        }
+        for (final Entry entry : new ArrayList<Entry>(lruEntries.values())) {
+            if (entry.currentEditor != null) {
+                entry.currentEditor.abort();
+            }
+        }
+        trimToSize();
+        journalWriter.close();
+        journalWriter = null;
+    }
+
+    private void trimToSize() throws IOException {
+        while (size > maxSize) {
+            // Map.Entry<String, Entry> toEvict = lruEntries.eldest();
+            final Map.Entry<String, Entry> toEvict = lruEntries.entrySet().iterator().next();
+            remove(toEvict.getKey());
+        }
+    }
+
+    /**
+     * Closes the cache and deletes all of its stored values. This will delete
+     * all files in the cache directory including files that weren't created by
+     * the cache.
+     */
+    public void delete() throws IOException {
+        close();
+        deleteContents(directory);
+    }
+
+    private void validateKey(final String key) {
+        if (key.contains(" ") || key.contains("\n") || key.contains("\r")) {
+            throw new IllegalArgumentException("keys must not contain spaces or newlines: \"" + key
+                    + "\"");
+        }
+    }
+
+    /**
+     * A snapshot of the values for an entry.
+     */
+    public final class Snapshot implements Closeable {
+        private final String key;
+
+        private final long sequenceNumber;
+
+        private final InputStream[] ins;
+
+        private Snapshot(final String key, final long sequenceNumber, final InputStream[] ins) {
+            this.key = key;
+            this.sequenceNumber = sequenceNumber;
+            this.ins = ins;
+        }
+
+        /**
+         * Returns an editor for this snapshot's entry, or null if either the
+         * entry has changed since this snapshot was created or if another edit
+         * is in progress.
+         */
+        public Editor edit() throws IOException {
+            return DiskLruCache.this.edit(key, sequenceNumber);
+        }
+
+        /**
+         * Returns the unbuffered stream with the value for {@code index}.
+         */
+        public InputStream getInputStream(final int index) {
+            return ins[index];
+        }
+
+        /**
+         * Returns the string value for {@code index}.
+         */
+        public String getString(final int index) throws IOException {
+            return inputStreamToString(getInputStream(index));
+        }
+
+        @Override
+        public void close() {
+            for (final InputStream in : ins) {
+                closeQuietly(in);
+            }
+        }
+    }
+
+    /**
+     * Edits the values for an entry.
+     */
+    public final class Editor {
+        private final Entry entry;
+
+        private boolean hasErrors;
+
+        private Editor(final Entry entry) {
+            this.entry = entry;
+        }
+
+        /**
+         * Returns an unbuffered input stream to read the last committed value,
+         * or null if no value has been committed.
+         */
+        public InputStream newInputStream(final int index) throws IOException {
+            synchronized (DiskLruCache.this) {
+                if (entry.currentEditor != this) {
+                    throw new IllegalStateException();
+                }
+                if (!entry.readable) {
+                    return null;
+                }
+                return new FileInputStream(entry.getCleanFile(index));
+            }
+        }
+
+        /**
+         * Returns the last committed value as a string, or null if no value has
+         * been committed.
+         */
+        public String getString(final int index) throws IOException {
+            final InputStream in = newInputStream(index);
+            return in != null ? inputStreamToString(in) : null;
+        }
+
+        /**
+         * Returns a new unbuffered output stream to write the value at
+         * {@code index}. If the underlying output stream encounters errors when
+         * writing to the filesystem, this edit will be aborted when
+         * {@link #commit} is called. The returned output stream does not throw
+         * IOExceptions.
+         */
+        public OutputStream newOutputStream(final int index) throws IOException {
+            synchronized (DiskLruCache.this) {
+                if (entry.currentEditor != this) {
+                    throw new IllegalStateException();
+                }
+                return new FaultHidingOutputStream(new FileOutputStream(entry.getDirtyFile(index)));
+            }
+        }
+
+        /**
+         * Sets the value at {@code index} to {@code value}.
+         */
+        public void set(final int index, final String value) throws IOException {
+            Writer writer = null;
+            try {
+                writer = new OutputStreamWriter(newOutputStream(index), UTF_8);
+                writer.write(value);
+            } finally {
+                closeQuietly(writer);
+            }
+        }
+
+        /**
+         * Commits this edit so it is visible to readers. This releases the edit
+         * lock so another edit may be started on the same key.
+         */
+        public void commit() throws IOException {
+            if (hasErrors) {
+                completeEdit(this, false);
+                remove(entry.key); // the previous entry is stale
+            } else {
+                completeEdit(this, true);
+            }
+        }
+
+        /**
+         * Aborts this edit. This releases the edit lock so another edit may be
+         * started on the same key.
+         */
+        public void abort() throws IOException {
+            completeEdit(this, false);
+        }
+
+        private class FaultHidingOutputStream extends FilterOutputStream {
+            private FaultHidingOutputStream(final OutputStream out) {
+                super(out);
+            }
+
+            @Override
+            public void write(final int oneByte) {
+                try {
+                    out.write(oneByte);
+                } catch (final IOException e) {
+                    hasErrors = true;
+                }
+            }
+
+            @Override
+            public void write(final byte[] buffer, final int offset, final int length) {
+                try {
+                    out.write(buffer, offset, length);
+                } catch (final IOException e) {
+                    hasErrors = true;
+                }
+            }
+
+            @Override
+            public void close() {
+                try {
+                    out.close();
+                } catch (final IOException e) {
+                    hasErrors = true;
+                }
+            }
+
+            @Override
+            public void flush() {
+                try {
+                    out.flush();
+                } catch (final IOException e) {
+                    hasErrors = true;
+                }
+            }
+        }
+    }
+
+    private final class Entry {
+        private final String key;
+
+        /**
+         * Lengths of this entry's files.
+         */
+        private final long[] lengths;
+
+        /**
+         * True if this entry has ever been published
+         */
+        private boolean readable;
+
+        /**
+         * The ongoing edit or null if this entry is not being edited.
+         */
+        private Editor currentEditor;
+
+        /**
+         * The sequence number of the most recently committed edit to this
+         * entry.
+         */
+        private long sequenceNumber;
+
+        private Entry(final String key) {
+            this.key = key;
+            lengths = new long[valueCount];
+        }
+
+        public String getLengths() throws IOException {
+            final StringBuilder result = new StringBuilder();
+            for (final long size : lengths) {
+                result.append(' ').append(size);
+            }
+            return result.toString();
+        }
+
+        /**
+         * Set lengths using decimal numbers like "10123".
+         */
+        private void setLengths(final String[] strings) throws IOException {
+            if (strings.length != valueCount) {
+                throw invalidLengths(strings);
+            }
+
+            try {
+                for (int i = 0; i < strings.length; i++) {
+                    lengths[i] = Long.parseLong(strings[i]);
+                }
+            } catch (final NumberFormatException e) {
+                throw invalidLengths(strings);
+            }
+        }
+
+        private IOException invalidLengths(final String[] strings) throws IOException {
+            throw new IOException("unexpected journal line: " + Arrays.toString(strings));
+        }
+
+        public File getCleanFile(final int i) {
+            return new File(directory, key + "." + i);
+        }
+
+        public File getDirtyFile(final int i) {
+            return new File(directory, key + "." + i + ".tmp");
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/ICacheListener.java b/twelve/src/main/java/com/dolzzo/twelve/cache/ICacheListener.java
new file mode 100755
index 0000000000..8575d8d9c6
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/ICacheListener.java
@@ -0,0 +1,20 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.cache;
+
+public interface ICacheListener {
+    void onCacheUnpaused();
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/ImageCache.java b/twelve/src/main/java/com/dolzzo/twelve/cache/ImageCache.java
new file mode 100755
index 0000000000..778fb46306
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/ImageCache.java
@@ -0,0 +1,823 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.cache;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.Fragment;
+import android.app.FragmentManager;
+import android.content.ComponentCallbacks2;
+import android.content.ContentUris;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Looper;
+import android.os.ParcelFileDescriptor;
+import android.util.Log;
+
+import com.dolzzo.twelve.utils.ApolloUtils;
+
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.HashSet;
+
+/**
+ * This class holds the memory and disk bitmap caches.
+ */
+public final class ImageCache {
+
+    private static final String TAG = ImageCache.class.getSimpleName();
+
+    /**
+     * The {@link Uri} used to retrieve album art
+     */
+    private static final Uri mArtworkUri;
+
+    /**
+     * Default memory cache size as a percent of device memory class
+     */
+    private static final float MEM_CACHE_DIVIDER = 0.25f;
+
+    /**
+     * Default disk cache size 10MB
+     */
+    private static final int DISK_CACHE_SIZE = 1024 * 1024 * 10;
+
+    /**
+     * Compression settings when writing images to disk cache
+     */
+    private static final CompressFormat COMPRESS_FORMAT = CompressFormat.JPEG;
+
+    /**
+     * Disk cache index to read from
+     */
+    private static final int DISK_CACHE_INDEX = 0;
+
+    /**
+     * Image compression quality
+     */
+    private static final int COMPRESS_QUALITY = 98;
+    private static ImageCache sInstance;
+
+    static {
+        mArtworkUri = Uri.parse("content://media/external/audio/albumart");
+    }
+
+    private final Object mPauseLock = new Object();
+    /**
+     * Used to temporarily pause the disk cache while scrolling
+     */
+    public boolean mPauseDiskAccess = false;
+    /**
+     * LRU cache
+     */
+    private MemoryCache mLruCache;
+    /**
+     * Disk LRU cache
+     */
+    private DiskLruCache mDiskCache;
+    /**
+     * listeners to the cache state
+     */
+    private HashSet<ICacheListener> mListeners = new HashSet<ICacheListener>();
+
+    /**
+     * Constructor of <code>ImageCache</code>
+     *
+     * @param context The {@link Context} to use
+     */
+    public ImageCache(final Context context) {
+        init(context);
+    }
+
+    /**
+     * Used to create a singleton of {@link ImageCache}
+     *
+     * @param context The {@link Context} to use
+     * @return A new instance of this class.
+     */
+    public final static ImageCache getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new ImageCache(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    /**
+     * Find and return an existing ImageCache stored in a {@link RetainFragment}
+     * , if not found a new one is created using the supplied params and saved
+     * to a {@link RetainFragment}
+     *
+     * @param activity The calling {@link FragmentActivity}
+     * @return An existing retained ImageCache object or a new one if one did
+     * not exist
+     */
+    public static final ImageCache findOrCreateCache(final Activity activity) {
+
+        // Search for, or create an instance of the non-UI RetainFragment
+        final RetainFragment retainFragment = findOrCreateRetainFragment(
+                activity.getFragmentManager());
+
+        // See if we already have an ImageCache stored in RetainFragment
+        ImageCache cache = (ImageCache) retainFragment.getObject();
+
+        // No existing ImageCache, create one and store it in RetainFragment
+        if (cache == null) {
+            cache = getInstance(activity);
+            retainFragment.setObject(cache);
+        }
+        return cache;
+    }
+
+    /**
+     * Locate an existing instance of this {@link Fragment} or if not found,
+     * create and add it using {@link FragmentManager}
+     *
+     * @param fm The {@link FragmentManager} to use
+     * @return The existing instance of the {@link Fragment} or the new instance
+     * if just created
+     */
+    public static final RetainFragment findOrCreateRetainFragment(final FragmentManager fm) {
+        // Check to see if we have retained the worker fragment
+        RetainFragment retainFragment = (RetainFragment) fm.findFragmentByTag(TAG);
+
+        // If not retained, we need to create and add it
+        if (retainFragment == null) {
+            retainFragment = new RetainFragment();
+            fm.beginTransaction().add(retainFragment, TAG).commit();
+        }
+        return retainFragment;
+    }
+
+    /**
+     * Get a usable cache directory (external if available, internal otherwise)
+     *
+     * @param context    The {@link Context} to use
+     * @param uniqueName A unique directory name to append to the cache
+     *                   directory
+     * @return The cache directory
+     */
+    public static final File getDiskCacheDir(final Context context, final String uniqueName) {
+        // getExternalCacheDir(context) returns null if external storage is not ready
+        final String cachePath = getExternalCacheDir(context) != null
+                ? getExternalCacheDir(context).getPath()
+                : context.getCacheDir().getPath();
+        return new File(cachePath, uniqueName);
+    }
+
+    /**
+     * Check if external storage is built-in or removable
+     *
+     * @return True if external storage is removable (like an SD card), false
+     * otherwise
+     */
+    public static final boolean isExternalStorageRemovable() {
+        return Environment.isExternalStorageRemovable();
+    }
+
+    /**
+     * Get the external app cache directory
+     *
+     * @param context The {@link Context} to use
+     * @return The external cache directory
+     */
+    public static final File getExternalCacheDir(final Context context) {
+        return context.getExternalCacheDir();
+    }
+
+    /**
+     * Check how much usable space is available at a given path.
+     *
+     * @param path The path to check
+     * @return The space available in bytes
+     */
+    public static final long getUsableSpace(final File path) {
+        return path.getUsableSpace();
+    }
+
+    /**
+     * A hashing method that changes a string (like a URL) into a hash suitable
+     * for using as a disk filename.
+     *
+     * @param key The key used to store the file
+     */
+    public static final String hashKeyForDisk(final String key) {
+        String cacheKey;
+        try {
+            final MessageDigest digest = MessageDigest.getInstance("MD5");
+            digest.update(key.getBytes());
+            cacheKey = bytesToHexString(digest.digest());
+        } catch (final NoSuchAlgorithmException e) {
+            cacheKey = String.valueOf(key.hashCode());
+        }
+        return cacheKey;
+    }
+
+    /**
+     * http://stackoverflow.com/questions/332079
+     *
+     * @param bytes The bytes to convert.
+     * @return A {@link String} converted from the bytes of a hashable key used
+     * to store a filename on the disk, to hex digits.
+     */
+    private static final String bytesToHexString(final byte[] bytes) {
+        final StringBuilder builder = new StringBuilder();
+        for (final byte b : bytes) {
+            final String hex = Integer.toHexString(0xFF & b);
+            if (hex.length() == 1) {
+                builder.append('0');
+            }
+            builder.append(hex);
+        }
+        return builder.toString();
+    }
+
+    /**
+     * Initialize the cache, providing all parameters.
+     *
+     * @param context     The {@link Context} to use
+     * @param cacheParams The cache parameters to initialize the cache
+     */
+    private void init(final Context context) {
+        ApolloUtils.execute(false, new AsyncTask<Void, Void, Void>() {
+
+            @Override
+            protected Void doInBackground(final Void... unused) {
+                // Initialize the disk cahe in a background thread
+                initDiskCache(context);
+                return null;
+            }
+        }, (Void[]) null);
+        // Set up the memory cache
+        initLruCache(context);
+    }
+
+    /**
+     * Initializes the disk cache. Note that this includes disk access so this
+     * should not be executed on the main/UI thread. By default an ImageCache
+     * does not initialize the disk cache when it is created, instead you should
+     * call initDiskCache() to initialize it on a background thread.
+     *
+     * @param context The {@link Context} to use
+     */
+    private synchronized void initDiskCache(final Context context) {
+        // Set up disk cache
+        if (mDiskCache == null || mDiskCache.isClosed()) {
+            File diskCacheDir = getDiskCacheDir(context, TAG);
+            if (diskCacheDir != null) {
+                if (!diskCacheDir.exists()) {
+                    diskCacheDir.mkdirs();
+                }
+                if (getUsableSpace(diskCacheDir) > DISK_CACHE_SIZE) {
+                    try {
+                        mDiskCache = DiskLruCache.open(diskCacheDir, 1, 1, DISK_CACHE_SIZE);
+                    } catch (final IOException e) {
+                        diskCacheDir = null;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Sets up the Lru cache
+     *
+     * @param context The {@link Context} to use
+     */
+    @SuppressLint("NewApi")
+    public void initLruCache(final Context context) {
+        final ActivityManager activityManager = (ActivityManager) context
+                .getSystemService(Context.ACTIVITY_SERVICE);
+        final int lruCacheSize = Math.round(MEM_CACHE_DIVIDER * activityManager.getMemoryClass()
+                * 1024 * 1024);
+        mLruCache = new MemoryCache(lruCacheSize);
+
+        // Release some memory as needed
+        context.registerComponentCallbacks(new ComponentCallbacks2() {
+
+            /**
+             * {@inheritDoc}
+             */
+            @Override
+            public void onTrimMemory(final int level) {
+                if (level >= TRIM_MEMORY_MODERATE) {
+                    evictAll();
+                } else if (level >= TRIM_MEMORY_BACKGROUND) {
+                    mLruCache.trimToSize(mLruCache.size() / 2);
+                }
+            }
+
+            /**
+             * {@inheritDoc}
+             */
+            @Override
+            public void onLowMemory() {
+                // Nothing to do
+            }
+
+            /**
+             * {@inheritDoc}
+             */
+            @Override
+            public void onConfigurationChanged(final Configuration newConfig) {
+                // Nothing to do
+            }
+        });
+    }
+
+    /**
+     * Adds a new image to the memory and disk caches
+     *
+     * @param data   The key used to store the image
+     * @param bitmap The {@link Bitmap} to cache
+     */
+    public void addBitmapToCache(final String data, final Bitmap bitmap) {
+        addBitmapToCache(data, bitmap, false);
+    }
+
+    /**
+     * Adds a new image to the memory and disk caches
+     *
+     * @param data    The key used to store the image
+     * @param bitmap  The {@link Bitmap} to cache
+     * @param replace force a replace even if the bitmap exists in the cache
+     */
+    public void addBitmapToCache(final String data, final Bitmap bitmap, final boolean replace) {
+        if (data == null || bitmap == null) {
+            return;
+        }
+
+        // Add to memory cache
+        addBitmapToMemCache(data, bitmap, replace);
+
+        // Add to disk cache
+        if (mDiskCache != null && !mDiskCache.isClosed()) {
+            final String key = hashKeyForDisk(data);
+            OutputStream out = null;
+            try {
+                final DiskLruCache.Snapshot snapshot = mDiskCache.get(key);
+                if (snapshot != null) {
+                    snapshot.getInputStream(DISK_CACHE_INDEX).close();
+                }
+
+                if (snapshot == null || replace) {
+                    final DiskLruCache.Editor editor = mDiskCache.edit(key);
+                    if (editor != null) {
+                        out = editor.newOutputStream(DISK_CACHE_INDEX);
+                        bitmap.compress(COMPRESS_FORMAT, COMPRESS_QUALITY, out);
+                        editor.commit();
+                        out.close();
+                        flush();
+                    }
+                }
+            } catch (final IOException e) {
+                Log.e(TAG, "addBitmapToCache - " + e);
+            } catch (final IllegalStateException e) {
+                // if the user clears the cache while we have an async task going we could try
+                // writing to the disk cache while it isn't ready. Catching here will silently
+                // fail instead
+                Log.e(TAG, "addBitmapToCache - " + e);
+            } finally {
+                try {
+                    if (out != null) {
+                        out.close();
+                        out = null;
+                    }
+                } catch (final IOException e) {
+                    Log.e(TAG, "addBitmapToCache - " + e);
+                } catch (final IllegalStateException e) {
+                    Log.e(TAG, "addBitmapToCache - " + e);
+                }
+            }
+        }
+    }
+
+    /**
+     * Called to add a new image to the memory cache
+     *
+     * @param data   The key identifier
+     * @param bitmap The {@link Bitmap} to cache
+     */
+    public void addBitmapToMemCache(final String data, final Bitmap bitmap) {
+        addBitmapToMemCache(data, bitmap, false);
+    }
+
+    /**
+     * Called to add a new image to the memory cache
+     *
+     * @param data    The key identifier
+     * @param bitmap  The {@link Bitmap} to cache
+     * @param replace whether to force a replace if it already exists
+     */
+    public void addBitmapToMemCache(final String data, final Bitmap bitmap, final boolean replace) {
+        if (data == null || bitmap == null) {
+            return;
+        }
+        // Add to memory cache
+        if (replace || getBitmapFromMemCache(data) == null) {
+            mLruCache.put(data, bitmap);
+        }
+    }
+
+    /**
+     * Fetches a cached image from the memory cache
+     *
+     * @param data Unique identifier for which item to get
+     * @return The {@link Bitmap} if found in cache, null otherwise
+     */
+    public final Bitmap getBitmapFromMemCache(final String data) {
+        if (data == null) {
+            return null;
+        }
+        if (mLruCache != null) {
+            final Bitmap lruBitmap = mLruCache.get(data);
+            if (lruBitmap != null) {
+                return lruBitmap;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Fetches a cached image from the disk cache
+     *
+     * @param data Unique identifier for which item to get
+     * @return The {@link Bitmap} if found in cache, null otherwise
+     */
+    public final Bitmap getBitmapFromDiskCache(final String data) {
+        if (data == null) {
+            return null;
+        }
+
+        // Check in the memory cache here to avoid going to the disk cache less
+        // often
+        if (getBitmapFromMemCache(data) != null) {
+            return getBitmapFromMemCache(data);
+        }
+
+        waitUntilUnpaused();
+        final String key = hashKeyForDisk(data);
+        if (mDiskCache != null) {
+            InputStream inputStream = null;
+            try {
+                final DiskLruCache.Snapshot snapshot = mDiskCache.get(key);
+                if (snapshot != null) {
+                    inputStream = snapshot.getInputStream(DISK_CACHE_INDEX);
+                    if (inputStream != null) {
+                        final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
+                        if (bitmap != null) {
+                            return bitmap;
+                        }
+                    }
+                }
+            } catch (final IOException e) {
+                Log.e(TAG, "getBitmapFromDiskCache - " + e);
+            } finally {
+                try {
+                    if (inputStream != null) {
+                        inputStream.close();
+                    }
+                } catch (final IOException e) {
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Tries to return a cached image from memory cache before fetching from the
+     * disk cache
+     *
+     * @param data Unique identifier for which item to get
+     * @return The {@link Bitmap} if found in cache, null otherwise
+     */
+    public final Bitmap getCachedBitmap(final String data) {
+        if (data == null) {
+            return null;
+        }
+        Bitmap cachedImage = getBitmapFromMemCache(data);
+        if (cachedImage == null) {
+            cachedImage = getBitmapFromDiskCache(data);
+        }
+        if (cachedImage != null) {
+            addBitmapToMemCache(data, cachedImage);
+            return cachedImage;
+        }
+        return null;
+    }
+
+    /**
+     * Tries to return the album art from memory cache and disk cache, before
+     * calling {@code #getArtworkFromFile(Context, String)} again
+     *
+     * @param context The {@link Context} to use
+     * @param data    The name of the album art
+     * @param id      The ID of the album to find artwork for
+     * @return The artwork for an album
+     */
+    public final Bitmap getCachedArtwork(final Context context, final String data, final long id) {
+        if (context == null || data == null) {
+            return null;
+        }
+        Bitmap cachedImage = getCachedBitmap(data);
+        if (cachedImage == null && id >= 0) {
+            cachedImage = getArtworkFromFile(context, id);
+        }
+        if (cachedImage != null) {
+            addBitmapToMemCache(data, cachedImage);
+            return cachedImage;
+        }
+        return null;
+    }
+
+    /**
+     * Used to fetch the artwork for an album locally from the user's device
+     *
+     * @param context The {@link Context} to use
+     * @param albumID The ID of the album to find artwork for
+     * @return The artwork for an album
+     */
+    public final Bitmap getArtworkFromFile(final Context context, final long albumId) {
+        if (albumId < 0) {
+            return null;
+        }
+        Bitmap artwork = null;
+        waitUntilUnpaused();
+        try {
+            final Uri uri = ContentUris.withAppendedId(mArtworkUri, albumId);
+            final ParcelFileDescriptor parcelFileDescriptor = context.getContentResolver()
+                    .openFileDescriptor(uri, "r");
+            if (parcelFileDescriptor != null) {
+                final FileDescriptor fileDescriptor = parcelFileDescriptor.getFileDescriptor();
+                artwork = BitmapFactory.decodeFileDescriptor(fileDescriptor);
+            }
+        } catch (final IllegalStateException e) {
+            // Log.e(TAG, "IllegalStateExcetpion - getArtworkFromFile - ", e);
+        } catch (final FileNotFoundException e) {
+            // Log.e(TAG, "FileNotFoundException - getArtworkFromFile - ", e);
+        } catch (final OutOfMemoryError evict) {
+            // Log.e(TAG, "OutOfMemoryError - getArtworkFromFile - ", evict);
+            evictAll();
+        }
+        return artwork;
+    }
+
+    /**
+     * flush() is called to synchronize up other methods that are accessing the
+     * cache first
+     */
+    public void flush() {
+        ApolloUtils.execute(false, new AsyncTask<Void, Void, Void>() {
+
+            @Override
+            protected Void doInBackground(final Void... unused) {
+                if (mDiskCache != null) {
+                    try {
+                        if (!mDiskCache.isClosed()) {
+                            mDiskCache.flush();
+                        }
+                    } catch (final IOException e) {
+                        Log.e(TAG, "flush - " + e);
+                    }
+                }
+                return null;
+            }
+        }, (Void[]) null);
+    }
+
+    /**
+     * Clears the disk and memory caches
+     */
+    public void clearCaches() {
+        ApolloUtils.execute(false, new AsyncTask<Void, Void, Void>() {
+
+            @Override
+            protected Void doInBackground(final Void... unused) {
+                // Clear the disk cache
+                try {
+                    if (mDiskCache != null) {
+                        mDiskCache.delete();
+                        mDiskCache = null;
+                    }
+                } catch (final IOException e) {
+                    Log.e(TAG, "clearCaches - " + e);
+                }
+                // Clear the memory cache
+                evictAll();
+                return null;
+            }
+        }, (Void[]) null);
+    }
+
+    /**
+     * Closes the disk cache associated with this ImageCache object. Note that
+     * this includes disk access so this should not be executed on the main/UI
+     * thread.
+     */
+    public void close() {
+        ApolloUtils.execute(false, new AsyncTask<Void, Void, Void>() {
+
+            @Override
+            protected Void doInBackground(final Void... unused) {
+                if (mDiskCache != null) {
+                    try {
+                        if (!mDiskCache.isClosed()) {
+                            mDiskCache.close();
+                            mDiskCache = null;
+                        }
+                    } catch (final IOException e) {
+                        Log.e(TAG, "close - " + e);
+                    }
+                }
+                return null;
+            }
+        }, (Void[]) null);
+    }
+
+    /**
+     * Evicts all of the items from the memory cache and lets the system know
+     * now would be a good time to garbage collect
+     */
+    public void evictAll() {
+        if (mLruCache != null) {
+            mLruCache.evictAll();
+        }
+        System.gc();
+    }
+
+    /**
+     * @param key The key used to identify which cache entries to delete.
+     */
+    public void removeFromCache(final String key) {
+        if (key == null) {
+            return;
+        }
+        // Remove the Lru entry
+        if (mLruCache != null) {
+            mLruCache.remove(key);
+        }
+
+        try {
+            // Remove the disk entry
+            if (mDiskCache != null) {
+                mDiskCache.remove(hashKeyForDisk(key));
+            }
+        } catch (final IOException e) {
+            Log.e(TAG, "remove - " + e);
+        }
+        flush();
+    }
+
+    /**
+     * Used to temporarily pause the disk cache while the user is scrolling to
+     * improve scrolling.
+     *
+     * @param pause True to temporarily pause the disk cache, false otherwise.
+     */
+    public void setPauseDiskCache(final boolean pause) {
+        synchronized (mPauseLock) {
+            if (mPauseDiskAccess != pause) {
+                mPauseDiskAccess = pause;
+                if (!pause) {
+                    mPauseLock.notify();
+
+                    for (ICacheListener listener : mListeners) {
+                        listener.onCacheUnpaused();
+                    }
+                }
+            }
+        }
+    }
+
+    private void waitUntilUnpaused() {
+        synchronized (mPauseLock) {
+            if (Looper.myLooper() != Looper.getMainLooper()) {
+                while (mPauseDiskAccess) {
+                    try {
+                        mPauseLock.wait();
+                    } catch (InterruptedException e) {
+                        // ignored, we'll start waiting again
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * @return True if the user is scrolling, false otherwise.
+     */
+    public boolean isDiskCachePaused() {
+        return mPauseDiskAccess;
+    }
+
+    public void addCacheListener(ICacheListener listener) {
+        mListeners.add(listener);
+    }
+
+    public void removeCacheListener(ICacheListener listener) {
+        mListeners.remove(listener);
+    }
+
+    /**
+     * A simple non-UI Fragment that stores a single Object and is retained over
+     * configuration changes. In this sample it will be used to retain an
+     * {@link ImageCache} object.
+     */
+    public static final class RetainFragment extends Fragment {
+
+        /**
+         * The object to be stored
+         */
+        private Object mObject;
+
+        /**
+         * Empty constructor as per the {@link Fragment} documentation
+         */
+        public RetainFragment() {
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onCreate(final Bundle savedInstanceState) {
+            super.onCreate(savedInstanceState);
+            // Make sure this Fragment is retained over a configuration change
+            setRetainInstance(true);
+        }
+
+        /**
+         * Get the stored object
+         *
+         * @return The stored object
+         */
+        public Object getObject() {
+            return mObject;
+        }
+
+        /**
+         * Store a single object in this {@link Fragment}
+         *
+         * @param object The object to store
+         */
+        public void setObject(final Object object) {
+            mObject = object;
+        }
+    }
+
+    /**
+     * Used to cache images via {@link LruCache}.
+     */
+    public static final class MemoryCache extends LruCache<String, Bitmap> {
+
+        /**
+         * Constructor of <code>MemoryCache</code>
+         *
+         * @param maxSize The allowed size of the {@link LruCache}
+         */
+        public MemoryCache(final int maxSize) {
+            super(maxSize);
+        }
+
+        /**
+         * Get the size in bytes of a bitmap.
+         */
+        public static final int getBitmapSize(final Bitmap bitmap) {
+            return bitmap.getByteCount();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        protected int sizeOf(final String paramString, final Bitmap paramBitmap) {
+            return getBitmapSize(paramBitmap);
+        }
+
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/ImageFetcher.java b/twelve/src/main/java/com/dolzzo/twelve/cache/ImageFetcher.java
new file mode 100755
index 0000000000..629b89bc67
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/ImageFetcher.java
@@ -0,0 +1,320 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.cache;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.widget.ImageView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.cache.PlaylistWorkerTask.PlaylistWorkerType;
+import com.dolzzo.twelve.utils.BitmapWithColors;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.BlurScrimImage;
+import com.dolzzo.twelve.widgets.LetterTileDrawable;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A subclass of {@link ImageWorker} that fetches images from a URL.
+ */
+public class ImageFetcher extends ImageWorker {
+
+    private static final int DEFAULT_MAX_IMAGE_HEIGHT = 1024;
+
+    private static final int DEFAULT_MAX_IMAGE_WIDTH = 1024;
+
+    private static ImageFetcher sInstance = null;
+
+    /**
+     * Creates a new instance of {@link ImageFetcher}.
+     *
+     * @param context The {@link Context} to use.
+     */
+    public ImageFetcher(final Context context) {
+        super(context);
+    }
+
+    /**
+     * Used to create a singleton of the image fetcher
+     *
+     * @param context The {@link Context} to use
+     * @return A new instance of this class.
+     */
+    public static final ImageFetcher getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new ImageFetcher(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    public static String getCurrentCacheKey() {
+        return generateAlbumCacheKey(MusicUtils.getAlbumName(), MusicUtils.getArtistName());
+    }
+
+    /**
+     * Generates key used by album art cache. It needs both album name and artist name
+     * to let to select correct image for the case when there are two albums with the
+     * same artist.
+     *
+     * @param albumName  The album name the cache key needs to be generated.
+     * @param artistName The artist name the cache key needs to be generated.
+     * @return
+     */
+    public static String generateAlbumCacheKey(final String albumName, final String artistName) {
+        if (albumName == null || artistName == null) {
+            return null;
+        }
+        return albumName + "_" + artistName + "_" + Config.ALBUM_ART_SUFFIX;
+    }
+
+    /**
+     * Decode and sample down a {@link Bitmap} from a Uri.
+     *
+     * @param selectedImage Uri of the Image to decode
+     * @return A {@link Bitmap} sampled down from the original with the same
+     * aspect ratio and dimensions that are equal to or greater than the
+     * requested width and height
+     */
+    public static Bitmap decodeSampledBitmapFromUri(ContentResolver cr, final Uri selectedImage) {
+        // First decode with inJustDecodeBounds=true to check dimensions
+        final BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inJustDecodeBounds = true;
+
+        try {
+            InputStream input = cr.openInputStream(selectedImage);
+            BitmapFactory.decodeStream(input, null, options);
+            input.close();
+
+            if (options.outHeight == -1 || options.outWidth == -1) {
+                return null;
+            }
+
+            // Calculate inSampleSize
+            options.inSampleSize = calculateInSampleSize(options, DEFAULT_MAX_IMAGE_WIDTH,
+                    DEFAULT_MAX_IMAGE_HEIGHT);
+
+            // Decode bitmap with inSampleSize set
+            options.inJustDecodeBounds = false;
+            input = cr.openInputStream(selectedImage);
+            return BitmapFactory.decodeStream(input, null, options);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+            return null;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return null;
+    }
+
+    /**
+     * Calculate an inSampleSize for use in a
+     * {@link android.graphics.BitmapFactory.Options} object when decoding
+     * bitmaps using the decode* methods from {@link BitmapFactory}. This
+     * implementation calculates the closest inSampleSize that will result in
+     * the final decoded bitmap having a width and height equal to or larger
+     * than the requested width and height. This implementation does not ensure
+     * a power of 2 is returned for inSampleSize which can be faster when
+     * decoding but results in a larger bitmap which isn't as useful for caching
+     * purposes.
+     *
+     * @param options   An options object with out* params already populated (run
+     *                  through a decode* method with inJustDecodeBounds==true
+     * @param reqWidth  The requested width of the resulting bitmap
+     * @param reqHeight The requested height of the resulting bitmap
+     * @return The value to be used for inSampleSize
+     */
+    public static final int calculateInSampleSize(final BitmapFactory.Options options,
+                                                  final int reqWidth, final int reqHeight) {
+        /* Raw height and width of image */
+        final int height = options.outHeight;
+        final int width = options.outWidth;
+        int inSampleSize = 1;
+
+        if (height > reqHeight || width > reqWidth) {
+            if (width > height) {
+                inSampleSize = Math.round((float) height / (float) reqHeight);
+            } else {
+                inSampleSize = Math.round((float) width / (float) reqWidth);
+            }
+
+            // This offers some additional logic in case the image has a strange
+            // aspect ratio. For example, a panorama may have a much larger
+            // width than height. In these cases the total pixels might still
+            // end up being too large to fit comfortably in memory, so we should
+            // be more aggressive with sample down the image (=larger
+            // inSampleSize).
+
+            final float totalPixels = width * height;
+
+            /* More than 2x the requested pixels we'll sample down further */
+            final float totalReqPixelsCap = reqWidth * reqHeight * 2;
+
+            while (totalPixels / (inSampleSize * inSampleSize) > totalReqPixelsCap) {
+                inSampleSize++;
+            }
+        }
+        return inSampleSize;
+    }
+
+    /**
+     * Loads a playlist's most played song's artist image
+     *
+     * @param playlistId id of the playlist
+     * @param imageView  imageview to load into
+     */
+    public void loadPlaylistArtistImage(final long playlistId, final ImageView imageView) {
+        loadPlaylistImage(playlistId, PlaylistWorkerType.Artist, imageView);
+    }
+
+    /**
+     * Loads a playlist's most played songs into a combined image, or show 1 if not enough images
+     *
+     * @param playlistId id of the playlist
+     * @param imageView  imageview to load into
+     */
+    public void loadPlaylistCoverArtImage(final long playlistId, final ImageView imageView) {
+        loadPlaylistImage(playlistId, PlaylistWorkerType.CoverArt, imageView);
+    }
+
+    /**
+     * Used to fetch album images.
+     */
+    public void loadAlbumImage(final String artistName, final String albumName, final long albumId,
+                               final ImageView imageView) {
+        loadImage(generateAlbumCacheKey(albumName, artistName), artistName, albumName, albumId, imageView,
+                ImageType.ALBUM);
+    }
+
+    /**
+     * Used to fetch the current artwork.
+     */
+    public void loadCurrentArtwork(final ImageView imageView) {
+        loadImage(getCurrentCacheKey(),
+                MusicUtils.getArtistName(), MusicUtils.getAlbumName(), MusicUtils.getCurrentAlbumId(),
+                imageView, ImageType.ALBUM);
+    }
+
+    /**
+     * Used to fetch the current artwork blurred.
+     */
+    public void loadCurrentBlurredArtwork(final BlurScrimImage image) {
+        loadBlurImage(getCurrentCacheKey(),
+                MusicUtils.getArtistName(), MusicUtils.getAlbumName(), MusicUtils.getCurrentAlbumId(),
+                image, ImageType.ALBUM);
+    }
+
+    /**
+     * Used to fetch artist images.
+     */
+    public void loadArtistImage(final String key, final ImageView imageView) {
+        loadImage(key, key, null, -1, imageView, ImageType.ARTIST);
+    }
+
+    /**
+     * Used to fetch artist images. It also scales the image to fit the image view, if necessary.
+     */
+    public void loadArtistImage(final String key, final ImageView imageView, boolean scaleImgToView) {
+        loadImage(key, key, null, -1, imageView, ImageType.ARTIST, scaleImgToView);
+    }
+
+    /**
+     * Used to fetch the current artist image.
+     */
+    public void loadCurrentArtistImage(final ImageView imageView) {
+        loadImage(MusicUtils.getArtistName(), MusicUtils.getArtistName(), null, -1, imageView,
+                ImageType.ARTIST);
+    }
+
+    /**
+     * @param pause True to temporarily pause the disk cache, false otherwise.
+     */
+    public void setPauseDiskCache(final boolean pause) {
+        if (mImageCache != null) {
+            mImageCache.setPauseDiskCache(pause);
+        }
+    }
+
+    /**
+     * Clears the disk and memory caches
+     */
+    public void clearCaches() {
+        if (mImageCache != null) {
+            mImageCache.clearCaches();
+        }
+
+        // clear the keys of images we've already downloaded
+        sKeys.clear();
+    }
+
+    public void addCacheListener(ICacheListener listener) {
+        if (mImageCache != null) {
+            mImageCache.addCacheListener(listener);
+        }
+    }
+
+    public void removeCacheListener(ICacheListener listener) {
+        if (mImageCache != null) {
+            mImageCache.removeCacheListener(listener);
+        }
+    }
+
+    /**
+     * @param key The key used to find the image to remove
+     */
+    public void removeFromCache(final String key) {
+        if (mImageCache != null) {
+            mImageCache.removeFromCache(key);
+        }
+    }
+
+    /**
+     * Finds cached or downloads album art. Used in {@link MusicPlaybackService}
+     * to set the current album art in the notification and lock screen
+     *
+     * @param albumName    The name of the current album
+     * @param albumId      The ID of the current album
+     * @param artistName   The album artist in case we should have to download
+     *                     missing artwork
+     * @param smallArtwork Get the small version of the default artwork if no artwork exists
+     * @return The album art as an {@link Bitmap}
+     */
+    public BitmapWithColors getArtwork(final String albumName, final long albumId,
+                                       final String artistName, boolean smallArtwork) {
+        // Check the disk cache
+        Bitmap artwork = null;
+        String key = String.valueOf(albumId);
+
+        if (artwork == null && albumName != null && mImageCache != null) {
+            artwork = mImageCache.getBitmapFromDiskCache(key);
+        }
+        if (artwork == null && albumId >= 0 && mImageCache != null) {
+            // Check for local artwork
+            artwork = mImageCache.getArtworkFromFile(mContext, albumId);
+        }
+        if (artwork != null) {
+            return new BitmapWithColors(artwork, key.hashCode());
+        }
+
+        return LetterTileDrawable.createDefaultBitmap(mContext, key, ImageType.ALBUM, false,
+                smallArtwork);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/ImageWorker.java b/twelve/src/main/java/com/dolzzo/twelve/cache/ImageWorker.java
new file mode 100755
index 0000000000..8b8c050024
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/ImageWorker.java
@@ -0,0 +1,585 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.cache;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
+import android.support.v8.renderscript.RenderScript;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.dolzzo.twelve.cache.PlaylistWorkerTask.PlaylistWorkerType;
+import com.dolzzo.twelve.provider.PlaylistArtworkStore;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.ImageUtils;
+import com.dolzzo.twelve.widgets.BlurScrimImage;
+import com.dolzzo.twelve.widgets.LetterTileDrawable;
+
+import java.lang.ref.WeakReference;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * This class wraps up completing some arbitrary long running work when loading
+ * a {@link Bitmap} to an {@link ImageView}. It handles things like using a
+ * memory and disk cache, running the work in a background thread and setting a
+ * placeholder image.
+ */
+public abstract class ImageWorker {
+
+    /**
+     * Default transition drawable fade time
+     */
+    public static final int FADE_IN_TIME = 200;
+    /**
+     * Default transition drawable fade time slow
+     */
+    public static final int FADE_IN_TIME_SLOW = 1000;
+    /**
+     * Render script
+     */
+    public static RenderScript sRenderScript = null;
+    /**
+     * Tracks which images we've tried to download and prevents it from trying again
+     * In the future we might want to throw this into a db
+     */
+    public static Set<String> sKeys = Collections.synchronizedSet(new HashSet<String>());
+    /**
+     * The resources to use
+     */
+    private final Resources mResources;
+
+    /**
+     * First layer of the transition drawable
+     */
+    private final ColorDrawable mTransparentDrawable;
+
+    /**
+     * The Context to use
+     */
+    protected Context mContext;
+
+    /**
+     * Disk and memory caches
+     */
+    protected ImageCache mImageCache;
+
+    /**
+     * Constructor of <code>ImageWorker</code>
+     *
+     * @param context The {@link Context} to use
+     */
+    protected ImageWorker(final Context context) {
+        mContext = context.getApplicationContext();
+
+        if (sRenderScript == null) {
+            sRenderScript = RenderScript.create(mContext);
+        }
+
+        mResources = mContext.getResources();
+        // Create the transparent layer for the transition drawable
+        mTransparentDrawable = new ColorDrawable(Color.TRANSPARENT);
+    }
+
+    public static Bitmap getBitmapInBackground(final Context context, final ImageCache imageCache,
+                                               final String key, final String albumName, final String artistName,
+                                               final long albumId, final ImageType imageType) {
+        // The result
+        Bitmap bitmap = null;
+
+        // First, check the disk cache for the image
+        if (key != null && imageCache != null) {
+            bitmap = imageCache.getCachedBitmap(key);
+        }
+
+        // Second, if we're fetching artwork, check the device for the image
+        if (bitmap == null && imageType.equals(ImageType.ALBUM) && albumId >= 0
+                && key != null && imageCache != null) {
+            bitmap = imageCache.getCachedArtwork(context, key, albumId);
+        }
+
+        // Third, by now we need to download the image
+        if (bitmap == null && ApolloUtils.isOnline(context) && !sKeys.contains(key)) {
+            // Now define what the artist name, album name, and url are.
+            String url = ImageUtils.processImageUrl(context, artistName, albumName, imageType);
+            if (url != null) {
+                bitmap = ImageUtils.processBitmap(context, url);
+            }
+        }
+
+        // Fourth, add the new image to the cache
+        if (bitmap != null && key != null && imageCache != null) {
+            imageCache.addBitmapToCache(key, bitmap);
+        }
+
+        sKeys.add(key);
+
+        return bitmap;
+    }
+
+    /**
+     * Parses the drawable for instances of TransitionDrawable and breaks them open until it finds
+     * a drawable that isn't a transition drawable
+     *
+     * @param drawable to parse
+     * @return the target drawable that isn't a TransitionDrawable
+     */
+    public static Drawable getTopDrawable(final Drawable drawable) {
+        if (drawable == null) {
+            return null;
+        }
+
+        Drawable retDrawable = drawable;
+        while (retDrawable instanceof TransitionDrawable) {
+            TransitionDrawable transition = (TransitionDrawable) retDrawable;
+            retDrawable = transition.getDrawable(transition.getNumberOfLayers() - 1);
+        }
+
+        return retDrawable;
+    }
+
+    /**
+     * Creates a transition drawable to Bitmap with params
+     *
+     * @param resources    Android Resources!
+     * @param fromDrawable the drawable to transition from
+     * @param bitmap       the bitmap to transition to
+     * @param fadeTime     the fade time in MS to fade in
+     * @param dither       setting
+     * @param force        force create a transition even if bitmap == null (fade to transparent)
+     * @return the drawable if created, null otherwise
+     */
+    public static TransitionDrawable createImageTransitionDrawable(final Resources resources,
+                                                                   final Drawable fromDrawable, final Bitmap bitmap, final int fadeTime,
+                                                                   final boolean dither, final boolean force) {
+        if (bitmap != null || force) {
+            final Drawable[] arrayDrawable = new Drawable[2];
+            arrayDrawable[0] = getTopDrawable(fromDrawable);
+
+            // Add the transition to drawable
+            Drawable layerTwo;
+            if (bitmap != null) {
+                layerTwo = new BitmapDrawable(resources, bitmap);
+                layerTwo.setFilterBitmap(false);
+                layerTwo.setDither(dither);
+            } else {
+                // if no bitmap (forced) then transition to transparent
+                layerTwo = new ColorDrawable(Color.TRANSPARENT);
+            }
+
+            arrayDrawable[1] = layerTwo;
+
+            // Finally, return the image
+            final TransitionDrawable result = new TransitionDrawable(arrayDrawable);
+            result.setCrossFadeEnabled(true);
+            result.startTransition(fadeTime);
+            return result;
+        }
+
+        return null;
+    }
+
+    /**
+     * This will create the palette transition from the original color to the new one
+     *
+     * @param scrimImage the container to change the color for
+     * @param color      the color to transition to
+     * @return the transition to run
+     */
+    public static TransitionDrawable createPaletteTransition(BlurScrimImage scrimImage, int color) {
+        final Drawable[] arrayDrawable = new Drawable[2];
+        arrayDrawable[0] = getTopDrawable(scrimImage.getBackground());
+
+        if (arrayDrawable[0] == null) {
+            arrayDrawable[0] = new ColorDrawable(Color.TRANSPARENT);
+        }
+
+        arrayDrawable[1] = new ColorDrawable(color);
+
+        // create the transition
+        final TransitionDrawable result = new TransitionDrawable(arrayDrawable);
+        result.setCrossFadeEnabled(true);
+        result.startTransition(FADE_IN_TIME_SLOW);
+        return result;
+    }
+
+    /**
+     * Cancels and clears out any pending bitmap worker tasks on this image view
+     *
+     * @param image ImageView/BlurScrimImage to check
+     */
+    public static final void cancelWork(final View image) {
+        Object tag = image.getTag();
+        if (tag != null && tag instanceof AsyncTaskContainer) {
+            AsyncTaskContainer asyncTaskContainer = (AsyncTaskContainer) tag;
+            BitmapWorkerTask bitmapWorkerTask = asyncTaskContainer.getBitmapWorkerTask();
+            if (bitmapWorkerTask != null) {
+                bitmapWorkerTask.cancel(false);
+            }
+
+            // clear out the tag
+            image.setTag(null);
+        }
+    }
+
+    /**
+     * Returns false if the existing async task is loading the same key value
+     * Returns true otherwise and also cancels the async task if one exists
+     */
+    public static final boolean executePotentialWork(final String key, final View view) {
+        final AsyncTaskContainer asyncTaskContainer = getAsyncTaskContainer(view);
+        if (asyncTaskContainer != null) {
+            // we are trying to reload the same image, return false to indicate no work is needed
+            if (asyncTaskContainer.getKey().equals(key)) {
+                return false;
+            }
+
+            // since we don't match, cancel the work and switch to the new worker task
+            cancelWork(view);
+        }
+
+        return true;
+    }
+
+    /**
+     * Used to determine if the current image drawable has an instance of
+     * {@link AsyncTaskContainer}
+     *
+     * @param view Any {@link View} that either is or contains an ImageView.
+     * @return Retrieve the AsyncTaskContainer assigned to the {@link View}. null if there is no
+     * such task.
+     */
+    public static final AsyncTaskContainer getAsyncTaskContainer(final View view) {
+        if (view != null) {
+            if (view.getTag() instanceof AsyncTaskContainer) {
+                return (AsyncTaskContainer) view.getTag();
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Used to determine if the current image drawable has an instance of
+     * {@link BitmapWorkerTask}.  A {@link BitmapWorkerTask} may not exist even if the {@link
+     * AsyncTaskContainer} does as it may have finished its work
+     *
+     * @param view Any {@link View} that either is or contains an ImageView.
+     * @return Retrieve the currently active work task (if any) associated with
+     * this {@link View}. null if there is no such task.
+     */
+    public static final BitmapWorkerTask getBitmapWorkerTask(final View view) {
+        AsyncTaskContainer asyncTask = getAsyncTaskContainer(view);
+        if (asyncTask != null) {
+            return asyncTask.getBitmapWorkerTask();
+        }
+
+        return null;
+    }
+
+    /**
+     * Set the {@link ImageCache} object to use with this ImageWorker.
+     *
+     * @param cacheCallback new {@link ImageCache} object.
+     */
+    public void setImageCache(final ImageCache cacheCallback) {
+        mImageCache = cacheCallback;
+    }
+
+    /**
+     * Closes the disk cache associated with this ImageCache object. Note that
+     * this includes disk access so this should not be executed on the main/UI
+     * thread.
+     */
+    public void close() {
+        if (mImageCache != null) {
+            mImageCache.close();
+        }
+    }
+
+    /**
+     * flush() is called to synchronize up other methods that are accessing the
+     * cache first
+     */
+    public void flush() {
+        if (mImageCache != null) {
+            mImageCache.flush();
+        }
+    }
+
+    /**
+     * Adds a new image to the memory and disk caches
+     *
+     * @param data   The key used to store the image
+     * @param bitmap The {@link Bitmap} to cache
+     */
+    public void addBitmapToCache(final String key, final Bitmap bitmap) {
+        if (mImageCache != null) {
+            mImageCache.addBitmapToCache(key, bitmap);
+        }
+    }
+
+    /**
+     * @return A new drawable of the default artwork
+     */
+    public Drawable getNewDrawable(ImageType imageType, String name,
+                                   String identifier) {
+        LetterTileDrawable letterTileDrawable = new LetterTileDrawable(mContext);
+        letterTileDrawable.setTileDetails(name, identifier, imageType);
+        letterTileDrawable.setIsCircular(false);
+        return letterTileDrawable;
+    }
+
+    /**
+     * Loads the default image into the image view given the image type
+     *
+     * @param imageView The {@link ImageView}
+     * @param imageType The type of image
+     */
+    public void loadDefaultImage(final ImageView imageView, final ImageType imageType,
+                                 final String name, final String identifier) {
+        if (imageView != null) {
+            // if an existing letter drawable exists, re-use it
+            Drawable existingDrawable = imageView.getDrawable();
+            if (existingDrawable != null && existingDrawable instanceof LetterTileDrawable) {
+                ((LetterTileDrawable) existingDrawable).setTileDetails(name, identifier, imageType);
+            } else {
+                imageView.setImageDrawable(getNewDrawable(imageType, name,
+                        identifier));
+            }
+        }
+    }
+
+    /**
+     * Called to fetch the artist or album art.
+     *
+     * @param key        The unique identifier for the image.
+     * @param artistName The artist name for the Last.fm API.
+     * @param albumName  The album name for the Last.fm API.
+     * @param albumId    The album art index, to check for missing artwork.
+     * @param imageView  The {@link ImageView} used to set the cached
+     *                   {@link Bitmap}.
+     * @param imageType  The type of image URL to fetch for.
+     */
+    protected void loadImage(final String key, final String artistName, final String albumName,
+                             final long albumId, final ImageView imageView, final ImageType imageType) {
+
+        loadImage(key, artistName, albumName, albumId, imageView, imageType, false);
+    }
+
+    /**
+     * Called to fetch the artist or album art.
+     *
+     * @param key            The unique identifier for the image.
+     * @param artistName     The artist name for the Last.fm API.
+     * @param albumName      The album name for the Last.fm API.
+     * @param albumId        The album art index, to check for missing artwork.
+     * @param imageView      The {@link ImageView} used to set the cached
+     *                       {@link Bitmap}.
+     * @param imageType      The type of image URL to fetch for.
+     * @param scaleImgToView config option to scale the image to the image view's dimensions
+     */
+    protected void loadImage(final String key, final String artistName, final String albumName,
+                             final long albumId, final ImageView imageView,
+                             final ImageType imageType, final boolean scaleImgToView) {
+
+        if (key == null || mImageCache == null || imageView == null) {
+            return;
+        }
+
+        // First, check the memory for the image
+        final Bitmap lruBitmap = mImageCache.getBitmapFromMemCache(key);
+        if (lruBitmap != null) {   // Bitmap found in memory cache
+            // scale image if necessary
+            if (scaleImgToView) {
+                imageView.setImageBitmap(ImageUtils.scaleBitmapForImageView(lruBitmap, imageView));
+            } else {
+                imageView.setImageBitmap(lruBitmap);
+            }
+        } else {
+            // load the default image
+            if (imageType == ImageType.ARTIST) {
+                loadDefaultImage(imageView, imageType, artistName, key);
+            } else if (imageType == ImageType.ALBUM) {
+                // don't show letters for albums so pass in null as the display string
+                // because an album could have multiple artists, use the album id as the key here
+                loadDefaultImage(imageView, imageType, null, String.valueOf(albumId));
+            } else {
+                // don't show letters for playlists so pass in null as the display string
+                loadDefaultImage(imageView, imageType, null, key);
+            }
+
+            if (executePotentialWork(key, imageView)
+                    && imageView != null && !mImageCache.isDiskCachePaused()) {
+                Drawable fromDrawable = imageView.getDrawable();
+                if (fromDrawable == null) {
+                    fromDrawable = mTransparentDrawable;
+                }
+
+                // Otherwise run the worker task
+                final SimpleBitmapWorkerTask bitmapWorkerTask = new SimpleBitmapWorkerTask(key,
+                        imageView, imageType, fromDrawable, mContext, scaleImgToView);
+
+                final AsyncTaskContainer asyncTaskContainer = new AsyncTaskContainer(bitmapWorkerTask);
+                imageView.setTag(asyncTaskContainer);
+                try {
+                    ApolloUtils.execute(false, bitmapWorkerTask,
+                            artistName, albumName, String.valueOf(albumId));
+                } catch (RejectedExecutionException e) {
+                    // Executor has exhausted queue space
+                }
+            }
+        }
+    }
+
+    /**
+     * Called to fetch a playlist's top artist or cover art
+     *
+     * @param playlistId playlist identifier
+     * @param type       of work to get (Artist or CoverArt)
+     * @param imageView  to set the image to
+     */
+    public void loadPlaylistImage(final long playlistId, final PlaylistWorkerType type,
+                                  final ImageView imageView) {
+        if (mImageCache == null || imageView == null) {
+            return;
+        }
+
+        String key = null;
+        switch (type) {
+            case Artist:
+                key = PlaylistArtworkStore.getArtistCacheKey(playlistId);
+                break;
+            case CoverArt:
+                key = PlaylistArtworkStore.getCoverCacheKey(playlistId);
+                break;
+        }
+
+        // First, check the memory for the image
+        final Bitmap lruBitmap = mImageCache.getBitmapFromMemCache(key);
+        if (lruBitmap != null) {
+            // Bitmap found in memory cache
+            imageView.setImageBitmap(lruBitmap);
+        } else {
+            // load the default image
+            loadDefaultImage(imageView, ImageType.PLAYLIST, null, String.valueOf(playlistId));
+        }
+
+        // even though we may have found the image in the cache, we want to check if the playlist
+        // has been updated, or it's been too long since the last update and change the image
+        // accordingly
+        if (executePotentialWork(key, imageView) && !mImageCache.isDiskCachePaused()) {
+            // since a playlist's image can change based on changes to the playlist
+            // set the from drawable to be the existing image (if it exists) instead of transparent
+            // and fade from there
+            Drawable fromDrawable = imageView.getDrawable();
+            if (fromDrawable == null) {
+                fromDrawable = mTransparentDrawable;
+            }
+
+            // Otherwise run the worker task
+            final PlaylistWorkerTask bitmapWorkerTask = new PlaylistWorkerTask(key, playlistId, type,
+                    lruBitmap != null, imageView, fromDrawable, mContext);
+            final AsyncTaskContainer asyncTaskContainer = new AsyncTaskContainer(bitmapWorkerTask);
+            imageView.setTag(asyncTaskContainer);
+            try {
+                ApolloUtils.execute(false, bitmapWorkerTask);
+            } catch (RejectedExecutionException e) {
+                // Executor has exhausted queue space
+            }
+        }
+    }
+
+    /**
+     * Called to fetch the blurred artist or album art.
+     *
+     * @param key            The unique identifier for the image.
+     * @param artistName     The artist name for the Last.fm API.
+     * @param albumName      The album name for the Last.fm API.
+     * @param albumId        The album art index, to check for missing artwork.
+     * @param blurScrimImage The {@link BlurScrimImage} used to set the cached
+     *                       {@link Bitmap}.
+     * @param imageType      The type of image URL to fetch for.
+     */
+    protected void loadBlurImage(final String key, final String artistName, final String albumName,
+                                 final long albumId, final BlurScrimImage blurScrimImage, final ImageType imageType) {
+        if (key == null || mImageCache == null || blurScrimImage == null) {
+            return;
+        }
+
+        if (executePotentialWork(key, blurScrimImage) && !mImageCache.isDiskCachePaused()) {
+            // Otherwise run the worker task
+            final BlurBitmapWorkerTask blurWorkerTask = new BlurBitmapWorkerTask(key, blurScrimImage,
+                    imageType, mTransparentDrawable, mContext, sRenderScript);
+            final AsyncTaskContainer asyncTaskContainer = new AsyncTaskContainer(blurWorkerTask);
+            blurScrimImage.setTag(asyncTaskContainer);
+
+            try {
+                ApolloUtils.execute(false, blurWorkerTask, artistName, albumName, String.valueOf(albumId));
+            } catch (RejectedExecutionException e) {
+                // Executor has exhausted queue space, show default artwork
+                blurScrimImage.transitionToDefaultState();
+            }
+        }
+    }
+
+    /**
+     * Used to define what type of image URL to fetch for, artist or album.
+     */
+    public enum ImageType {
+        ARTIST, ALBUM, PLAYLIST;
+    }
+
+    /**
+     * A custom {@link BitmapDrawable} that will be attached to the
+     * {@link View} which either is or contains an {@link ImageView} while the work is in progress.
+     * Contains a reference to the actual worker task, so that it can be stopped if a new binding is
+     * required, and makes sure that only the last started worker process can
+     * bind its result, independently of the finish order.
+     */
+    public static final class AsyncTaskContainer {
+
+        private final WeakReference<BitmapWorkerTask> mBitmapWorkerTaskReference;
+        // keep a copy of the key in case the worker task mBitmapWorkerTaskReference is released
+        // after completion
+        private String mKey;
+
+        /**
+         * Constructor of <code>AsyncDrawable</code>
+         */
+        public AsyncTaskContainer(final BitmapWorkerTask bitmapWorkerTask) {
+            mBitmapWorkerTaskReference = new WeakReference<BitmapWorkerTask>(bitmapWorkerTask);
+            mKey = bitmapWorkerTask.mKey;
+        }
+
+        /**
+         * @return The {@link BitmapWorkerTask} associated with this drawable
+         */
+        public BitmapWorkerTask getBitmapWorkerTask() {
+            return mBitmapWorkerTaskReference.get();
+        }
+
+        public String getKey() {
+            return mKey;
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/LruCache.java b/twelve/src/main/java/com/dolzzo/twelve/cache/LruCache.java
new file mode 100755
index 0000000000..8f5bba4177
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/LruCache.java
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project Licensed under the Apache
+ * License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.cache;
+
+// NOTE: upstream of this class is android.util.LruCache, changes below
+// expose trimToSize() to be called externally.
+
+import android.annotation.SuppressLint;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * Static library version of {@link android.util.LruCache}. Used to write apps
+ * that run on API levels prior to 12. When running on API level 12 or above,
+ * this implementation is still used; it does not try to switch to the
+ * framework's implementation. See the framework SDK documentation for a class
+ * overview.
+ */
+public class LruCache<K, V> {
+
+    private final LinkedHashMap<K, V> map;
+
+    private final int maxSize;
+
+    /**
+     * Size of this cache in units. Not necessarily the number of elements.
+     */
+    private int size;
+
+    private int putCount;
+
+    private int createCount;
+
+    private int evictionCount;
+
+    private int hitCount;
+
+    private int missCount;
+
+    /**
+     * @param maxSize for caches that do not override {@link #sizeOf}, this is
+     *                the maximum number of entries in the cache. For all other
+     *                caches, this is the maximum sum of the sizes of the entries in
+     *                this cache.
+     */
+    public LruCache(final int maxSize) {
+        if (maxSize <= 0) {
+            throw new IllegalArgumentException("maxSize <= 0");
+        }
+        this.maxSize = maxSize;
+        this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
+    }
+
+    /**
+     * Returns the value for {@code key} if it exists in the cache or can be
+     * created by {@code #create}. If a value was returned, it is moved to the
+     * head of the queue. This returns null if a value is not cached and cannot
+     * be created.
+     */
+    public final V get(final K key) {
+        if (key == null) {
+            throw new NullPointerException("key == null");
+        }
+
+        V mapValue;
+        synchronized (this) {
+            mapValue = map.get(key);
+            if (mapValue != null) {
+                this.hitCount++;
+                return mapValue;
+            }
+            this.missCount++;
+        }
+
+        /*
+         * Attempt to create a value. This may take a long time, and the map may
+         * be different when create() returns. If a conflicting value was added
+         * to the map while create() was working, we leave that value in the map
+         * and release the created value.
+         */
+
+        final V createdValue = create(key);
+        if (createdValue == null) {
+            return null;
+        }
+
+        synchronized (this) {
+            this.createCount++;
+            mapValue = map.put(key, createdValue);
+
+            if (mapValue != null) {
+                /* There was a conflict so undo that last put */
+                this.map.put(key, mapValue);
+            } else {
+                this.size += safeSizeOf(key, createdValue);
+            }
+        }
+
+        if (mapValue != null) {
+            entryRemoved(false, key, createdValue, mapValue);
+            return mapValue;
+        } else {
+            trimToSize(maxSize);
+            return createdValue;
+        }
+    }
+
+    /**
+     * Caches {@code value} for {@code key}. The value is moved to the head of
+     * the queue.
+     *
+     * @return the previous value mapped by {@code key}.
+     */
+    public final V put(final K key, final V value) {
+        if (key == null || value == null) {
+            throw new NullPointerException("key == null || value == null");
+        }
+
+        V previous;
+        synchronized (this) {
+            this.putCount++;
+            this.size += safeSizeOf(key, value);
+            previous = this.map.put(key, value);
+            if (previous != null) {
+                this.size -= safeSizeOf(key, previous);
+            }
+        }
+
+        if (previous != null) {
+            entryRemoved(false, key, previous, value);
+        }
+
+        trimToSize(maxSize);
+        return previous;
+    }
+
+    /**
+     * @param maxSize the maximum size of the cache before returning. May be -1
+     *                to evict even 0-sized elements.
+     */
+    public void trimToSize(final int maxSize) {
+        while (true) {
+            K key;
+            V value;
+            synchronized (this) {
+                if (this.size < 0 || this.map.isEmpty() && size != 0) {
+                    throw new IllegalStateException(getClass().getName()
+                            + ".sizeOf() is reporting inconsistent results!");
+                }
+
+                if (this.size <= maxSize || this.map.isEmpty()) {
+                    break;
+                }
+
+                final Map.Entry<K, V> toEvict = this.map.entrySet().iterator().next();
+                key = toEvict.getKey();
+                value = toEvict.getValue();
+                this.map.remove(key);
+                this.size -= safeSizeOf(key, value);
+                this.evictionCount++;
+            }
+
+            entryRemoved(true, key, value, null);
+        }
+    }
+
+    /**
+     * Removes the entry for {@code key} if it exists.
+     *
+     * @return the previous value mapped by {@code key}.
+     */
+    public final V remove(final K key) {
+        if (key == null) {
+            throw new NullPointerException("key == null");
+        }
+
+        V previous;
+        synchronized (this) {
+            previous = this.map.remove(key);
+            if (previous != null) {
+                this.size -= safeSizeOf(key, previous);
+            }
+        }
+
+        if (previous != null) {
+            entryRemoved(false, key, previous, null);
+        }
+
+        return previous;
+    }
+
+    /**
+     * Called for entries that have been evicted or removed. This method is
+     * invoked when a value is evicted to make space, removed by a call to
+     * {@link #remove}, or replaced by a call to {@link #put}. The default
+     * implementation does nothing.
+     * <p>
+     * The method is called without synchronization: other threads may access
+     * the cache while this method is executing.
+     *
+     * @param evicted  true if the entry is being removed to make space, false if
+     *                 the removal was caused by a {@link #put} or {@link #remove}.
+     * @param newValue the new value for {@code key}, if it exists. If non-null,
+     *                 this removal was caused by a {@link #put}. Otherwise it was
+     *                 caused by an eviction or a {@link #remove}.
+     */
+    protected void entryRemoved(final boolean evicted, final K key, final V oldValue,
+                                final V newValue) {
+    }
+
+    /**
+     * Called after a cache miss to compute a value for the corresponding key.
+     * Returns the computed value or null if no value can be computed. The
+     * default implementation returns null.
+     * <p>
+     * The method is called without synchronization: other threads may access
+     * the cache while this method is executing.
+     * <p>
+     * If a value for {@code key} exists in the cache when this method returns,
+     * the created value will be released with {@link #entryRemoved} and
+     * discarded. This can occur when multiple threads request the same key at
+     * the same time (causing multiple values to be created), or when one thread
+     * calls {@link #put} while another is creating a value for the same key.
+     */
+    protected V create(final K key) {
+        return null;
+    }
+
+    private int safeSizeOf(final K key, final V value) {
+        final int result = sizeOf(key, value);
+        if (result < 0) {
+            throw new IllegalStateException("Negative size: " + key + "=" + value);
+        }
+        return result;
+    }
+
+    /**
+     * Returns the size of the entry for {@code key} and {@code value} in
+     * user-defined units. The default implementation returns 1 so that size is
+     * the number of entries and max size is the maximum number of entries.
+     * <p>
+     * An entry's size must not change while it is in the cache.
+     */
+    protected int sizeOf(final K key, final V value) {
+        return 1;
+    }
+
+    /**
+     * Clear the cache, calling {@link #entryRemoved} on each removed entry.
+     */
+    public final void evictAll() {
+        trimToSize(-1); // -1 will evict 0-sized elements
+    }
+
+    /**
+     * For caches that do not override {@link #sizeOf}, this returns the number
+     * of entries in the cache. For all other caches, this returns the sum of
+     * the sizes of the entries in this cache.
+     */
+    public synchronized final int size() {
+        return this.size;
+    }
+
+    /**
+     * For caches that do not override {@link #sizeOf}, this returns the maximum
+     * number of entries in the cache. For all other caches, this returns the
+     * maximum sum of the sizes of the entries in this cache.
+     */
+    public synchronized final int maxSize() {
+        return this.maxSize;
+    }
+
+    /**
+     * Returns the number of times {@link #get} returned a value.
+     */
+    public synchronized final int hitCount() {
+        return this.hitCount;
+    }
+
+    /**
+     * Returns the number of times {@link #get} returned null or required a new
+     * value to be created.
+     */
+    public synchronized final int missCount() {
+        return this.missCount;
+    }
+
+    /**
+     * Returns the number of times {@link #create(Object)} returned a value.
+     */
+    public synchronized final int createCount() {
+        return this.createCount;
+    }
+
+    /**
+     * Returns the number of times {@link #put} was called.
+     */
+    public synchronized final int putCount() {
+        return this.putCount;
+    }
+
+    /**
+     * Returns the number of values that have been evicted.
+     */
+    public synchronized final int evictionCount() {
+        return this.evictionCount;
+    }
+
+    /**
+     * Returns a copy of the current contents of the cache, ordered from least
+     * recently accessed to most recently accessed.
+     */
+    public synchronized final Map<K, V> snapshot() {
+        return new LinkedHashMap<K, V>(this.map);
+    }
+
+    @SuppressLint("DefaultLocale")
+    @Override
+    public synchronized final String toString() {
+        final int accesses = this.hitCount + this.missCount;
+        final int hitPercent = accesses != 0 ? 100 * this.hitCount / accesses : 0;
+        return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]", this.maxSize,
+                this.hitCount, this.missCount, hitPercent);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/PlaylistWorkerTask.java b/twelve/src/main/java/com/dolzzo/twelve/cache/PlaylistWorkerTask.java
new file mode 100755
index 0000000000..7415689629
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/PlaylistWorkerTask.java
@@ -0,0 +1,383 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.cache;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
+import android.provider.MediaStore;
+import android.widget.ImageView;
+
+import com.dolzzo.twelve.cache.ImageWorker.ImageType;
+import com.dolzzo.twelve.loaders.PlaylistSongLoader;
+import com.dolzzo.twelve.loaders.SortedCursor;
+import com.dolzzo.twelve.provider.PlaylistArtworkStore;
+import com.dolzzo.twelve.provider.SongPlayCount;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+
+/**
+ * The playlistWorkerTask will load either the top artist image or the cover art (a combination of
+ * up to 4 of the top song's album images) into the designated ImageView.  If not enough time has
+ * elapsed since the last update or if the # of songs in the playlist hasn't changed, no new images
+ * will be loaded.
+ */
+public class PlaylistWorkerTask extends BitmapWorkerTask<Void, Void, TransitionDrawable> {
+    // number of images to load in the cover art
+    private static final int MAX_NUM_BITMAPS_TO_LOAD = 4;
+    protected final long mPlaylistId;
+    protected final PlaylistArtworkStore mPlaylistStore;
+    protected final PlaylistWorkerType mWorkerType;
+    // if we've found it in the cache, don't do any more logic unless enough time has elapsed or
+    // if the playlist has changed
+    protected final boolean mFoundInCache;
+    // because a cached image can be loaded, we use this flag to signal to remove that default image
+    protected boolean mFallbackToDefaultImage;
+
+    /**
+     * Constructor of <code>PlaylistWorkerTask</code>
+     *
+     * @param key          the key of the image to store to
+     * @param playlistId   the playlist identifier
+     * @param type         Artist or CoverArt?
+     * @param foundInCache does this exist in the memory cache already
+     * @param imageView    The {@link ImageView} to use.
+     * @param fromDrawable what drawable to transition from
+     */
+    public PlaylistWorkerTask(final String key, final long playlistId, final PlaylistWorkerType type,
+                              final boolean foundInCache, final ImageView imageView,
+                              final Drawable fromDrawable, final Context context) {
+        super(key, imageView, ImageType.PLAYLIST, fromDrawable, context);
+
+        mPlaylistId = playlistId;
+        mWorkerType = type;
+        mPlaylistStore = PlaylistArtworkStore.getInstance(mContext);
+        mFoundInCache = foundInCache;
+        mFallbackToDefaultImage = false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected TransitionDrawable doInBackground(final Void... params) {
+        if (isCancelled()) {
+            return null;
+        }
+
+        Bitmap bitmap = null;
+
+        // See if we need to update the image
+        boolean needsUpdate = false;
+        if (mWorkerType == PlaylistWorkerType.Artist
+                && mPlaylistStore.needsArtistArtUpdate(mPlaylistId)) {
+            needsUpdate = true;
+        } else if (mWorkerType == PlaylistWorkerType.CoverArt
+                && mPlaylistStore.needsCoverArtUpdate(mPlaylistId)) {
+            needsUpdate = true;
+        }
+
+        // if we don't need to update and we've already found it in the cache, then return
+        if (!needsUpdate && mFoundInCache) {
+            return null;
+        }
+
+        // if we didn't find it in memory cache, try the disk cache
+        if (!mFoundInCache) {
+            bitmap = mImageCache.getCachedBitmap(mKey);
+        }
+
+        // if we don't need an update, return something
+        if (!needsUpdate) {
+            if (bitmap != null) {
+                // if we found a bitmap, return it
+                return createImageTransitionDrawable(bitmap);
+            } else {
+                // otherwise return null since we don't need an update
+                return null;
+            }
+        }
+
+        // otherwise re-run the logic to get the bitmap
+        Cursor sortedCursor = null;
+
+        try {
+            // get the top songs for our playlist
+            sortedCursor = getTopSongsForPlaylist();
+
+            if (isCancelled()) {
+                return null;
+            }
+
+            if (sortedCursor == null || sortedCursor.getCount() == 0) {
+                // if all songs were removed from the playlist, update the last updated time
+                // and reset to the default art
+                if (mWorkerType == PlaylistWorkerType.Artist) {
+                    // update the timestamp
+                    mPlaylistStore.updateArtistArt(mPlaylistId);
+                    // remove the cached image
+                    mImageCache.removeFromCache(PlaylistArtworkStore.getArtistCacheKey(mPlaylistId));
+                    // revert back to default image
+                    mFallbackToDefaultImage = true;
+                } else if (mWorkerType == PlaylistWorkerType.CoverArt) {
+                    // update the timestamp
+                    mPlaylistStore.updateCoverArt(mPlaylistId);
+                    // remove the cached image
+                    mImageCache.removeFromCache(PlaylistArtworkStore.getCoverCacheKey(mPlaylistId));
+                    // revert back to default image
+                    mFallbackToDefaultImage = true;
+                }
+            } else if (mWorkerType == PlaylistWorkerType.Artist) {
+                bitmap = loadTopArtist(sortedCursor);
+            } else {
+                bitmap = loadTopSongs(sortedCursor);
+            }
+        } finally {
+            if (sortedCursor != null) {
+                sortedCursor.close();
+            }
+        }
+
+        // if we have a bitmap create a transition drawable
+        if (bitmap != null) {
+            return createImageTransitionDrawable(bitmap);
+        }
+
+        return null;
+    }
+
+    /**
+     * This gets the sorted cursor of the songs from a playlist based on play count
+     *
+     * @return Cursor containing the sorted list
+     */
+    protected Cursor getTopSongsForPlaylist() {
+        Cursor playlistCursor = null;
+        SortedCursor sortedCursor = null;
+
+        try {
+            // gets the songs in the playlist
+            playlistCursor = PlaylistSongLoader.makePlaylistSongCursor(mContext, mPlaylistId);
+            if (playlistCursor == null || !playlistCursor.moveToFirst()) {
+                return null;
+            }
+
+            // get all the ids in the list
+            long[] songIds = new long[playlistCursor.getCount()];
+            do {
+                long id = playlistCursor.getLong(playlistCursor.getColumnIndex(
+                        MediaStore.Audio.Playlists.Members.AUDIO_ID));
+
+                songIds[playlistCursor.getPosition()] = id;
+            } while (playlistCursor.moveToNext());
+
+            if (isCancelled()) {
+                return null;
+            }
+
+            // find the sorted order for the playlist based on the top songs database
+            long[] order = SongPlayCount.getInstance(mContext).getTopPlayedResultsForList(songIds);
+
+            // create a new cursor that takes the playlist cursor and the sorted order
+            sortedCursor = new SortedCursor(playlistCursor, order,
+                    MediaStore.Audio.Playlists.Members.AUDIO_ID, null);
+
+            // since this cursor is now wrapped by SortedTracksCursor, remove the reference here
+            // so we don't accidentally close it in the finally loop
+            playlistCursor = null;
+        } finally {
+            // if we quit early from isCancelled(), close our cursor
+            if (playlistCursor != null) {
+                playlistCursor.close();
+                playlistCursor = null;
+            }
+        }
+
+        return sortedCursor;
+    }
+
+    /**
+     * Gets the most played song's artist image
+     *
+     * @param sortedCursor the sorted playlist song cursor
+     * @return Bitmap of the artist
+     */
+    protected Bitmap loadTopArtist(Cursor sortedCursor) {
+        if (sortedCursor == null || !sortedCursor.moveToFirst()) {
+            return null;
+        }
+
+        Bitmap bitmap = null;
+        int artistIndex = sortedCursor.getColumnIndex(MediaStore.Audio.AudioColumns.ARTIST);
+        String artistName = null;
+
+        do {
+            if (isCancelled()) {
+                return null;
+            }
+
+            artistName = sortedCursor.getString(artistIndex);
+            // try to load the bitmap
+            bitmap = ImageWorker.getBitmapInBackground(mContext, mImageCache, artistName,
+                    null, artistName, -1, ImageType.ARTIST);
+        } while (sortedCursor.moveToNext() && bitmap == null);
+
+        if (bitmap == null) {
+            // if we can't find any artist images, try loading the top songs image
+            bitmap = mImageCache.getCachedBitmap(
+                    PlaylistArtworkStore.getCoverCacheKey(mPlaylistId));
+        }
+
+        if (bitmap != null) {
+            // add the image to the cache
+            mImageCache.addBitmapToCache(mKey, bitmap, true);
+        } else {
+            mImageCache.removeFromCache(mKey);
+            mFallbackToDefaultImage = true;
+        }
+
+        // store the fact that we ran this code into the db to prevent multiple re-runs
+        mPlaylistStore.updateArtistArt(mPlaylistId);
+
+        return bitmap;
+    }
+
+    /**
+     * Gets the Cover Art of the playlist, which is a combination of the top song's album image
+     *
+     * @param sortedCursor the sorted playlist song cursor
+     * @return Bitmap of the artist
+     */
+    protected Bitmap loadTopSongs(Cursor sortedCursor) {
+        if (sortedCursor == null || !sortedCursor.moveToFirst()) {
+            return null;
+        }
+
+        ArrayList<Bitmap> loadedBitmaps = new ArrayList<Bitmap>(MAX_NUM_BITMAPS_TO_LOAD);
+
+        final int artistIdx = sortedCursor.getColumnIndex(MediaStore.Audio.AudioColumns.ARTIST);
+        final int albumIdIdx = sortedCursor.getColumnIndex(MediaStore.Audio.AudioColumns.ALBUM_ID);
+        final int albumIdx = sortedCursor.getColumnIndex(MediaStore.Audio.AudioColumns.ALBUM);
+
+        Bitmap bitmap = null;
+        String artistName = null;
+        String albumName = null;
+        long albumId = -1;
+
+        // create a hashset of the keys so we don't load images from the same album multiple times
+        HashSet<String> keys = new HashSet<String>(sortedCursor.getCount());
+
+        do {
+            if (isCancelled()) {
+                return null;
+            }
+
+            artistName = sortedCursor.getString(artistIdx);
+            albumName = sortedCursor.getString(albumIdx);
+            albumId = sortedCursor.getLong(albumIdIdx);
+
+            String key = ImageFetcher.generateAlbumCacheKey(albumName, artistName);
+
+            // if we successfully added the key (ie the key didn't previously exist)
+            if (keys.add(key)) {
+                // try to load the bitmap
+                bitmap = ImageWorker.getBitmapInBackground(mContext, mImageCache,
+                        key, albumName, artistName, albumId, ImageType.ALBUM);
+
+                // if we got the bitmap, add it to the list
+                if (bitmap != null) {
+                    loadedBitmaps.add(bitmap);
+                    bitmap = null;
+                }
+            }
+        } while (sortedCursor.moveToNext() && loadedBitmaps.size() < MAX_NUM_BITMAPS_TO_LOAD);
+
+        // if we found at least 1 bitmap
+        if (loadedBitmaps.size() > 0) {
+            // get the first bitmap
+            bitmap = loadedBitmaps.get(0);
+
+            // if we have many bitmaps
+            if (loadedBitmaps.size() == MAX_NUM_BITMAPS_TO_LOAD) {
+                // create a combined bitmap of the 4 images
+                final int width = bitmap.getWidth();
+                final int height = bitmap.getHeight();
+                Bitmap combinedBitmap = Bitmap.createBitmap(width, height,
+                        bitmap.getConfig());
+                Canvas combinedCanvas = new Canvas(combinedBitmap);
+
+                // top left
+                combinedCanvas.drawBitmap(loadedBitmaps.get(0), null,
+                        new Rect(0, 0, width / 2, height / 2), null);
+
+                // top right
+                combinedCanvas.drawBitmap(loadedBitmaps.get(1), null,
+                        new Rect(width / 2, 0, width, height / 2), null);
+
+                // bottom left
+                combinedCanvas.drawBitmap(loadedBitmaps.get(2), null,
+                        new Rect(0, height / 2, width / 2, height), null);
+
+                // bottom right
+                combinedCanvas.drawBitmap(loadedBitmaps.get(3), null,
+                        new Rect(width / 2, height / 2, width, height), null);
+
+//                combinedCanvas.release();
+                combinedCanvas = null;
+                bitmap = combinedBitmap;
+            }
+        }
+
+        // store the fact that we ran this code into the db to prevent multiple re-runs
+        mPlaylistStore.updateCoverArt(mPlaylistId);
+
+        if (bitmap != null) {
+            // add the image to the cache
+            mImageCache.addBitmapToCache(mKey, bitmap, true);
+        } else {
+            mImageCache.removeFromCache(mKey);
+            mFallbackToDefaultImage = true;
+        }
+
+        return bitmap;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onPostExecute(TransitionDrawable transitionDrawable) {
+        final ImageView imageView = getAttachedImageView();
+        if (imageView != null) {
+            if (transitionDrawable != null) {
+                imageView.setImageDrawable(transitionDrawable);
+            } else if (mFallbackToDefaultImage) {
+                ImageFetcher.getInstance(mContext).loadDefaultImage(imageView,
+                        ImageType.PLAYLIST, null, String.valueOf(mPlaylistId));
+            }
+        }
+    }
+
+    // the work type
+    public enum PlaylistWorkerType {
+        Artist, CoverArt
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/cache/SimpleBitmapWorkerTask.java b/twelve/src/main/java/com/dolzzo/twelve/cache/SimpleBitmapWorkerTask.java
new file mode 100755
index 0000000000..f7d1dbe09b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/cache/SimpleBitmapWorkerTask.java
@@ -0,0 +1,88 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.cache;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
+import android.widget.ImageView;
+
+import com.dolzzo.twelve.cache.ImageWorker.ImageType;
+import com.dolzzo.twelve.utils.ImageUtils;
+
+/**
+ * The actual {@link android.os.AsyncTask} that will process the image.
+ */
+public class SimpleBitmapWorkerTask extends BitmapWorkerTask<String, Void, TransitionDrawable> {
+
+    /**
+     * Constructor of <code>BitmapWorkerTask</code>
+     *
+     * @param key          the key of the image to store to
+     * @param imageView    The {@link ImageView} to use.
+     * @param imageType    The type of image URL to fetch for.
+     * @param fromDrawable what drawable to transition from
+     */
+    public SimpleBitmapWorkerTask(final String key, final ImageView imageView, final ImageType imageType,
+                                  final Drawable fromDrawable, final Context context) {
+        super(key, imageView, imageType, fromDrawable, context);
+    }
+
+    /**
+     * Constructor of <code>BitmapWorkerTask</code>
+     *
+     * @param key            the key of the image to store to
+     * @param imageView      The {@link ImageView} to use.
+     * @param imageType      The type of image URL to fetch for.
+     * @param fromDrawable   what drawable to transition from
+     * @param scaleImgToView flag to scale the bitmap to the image view bounds
+     */
+    public SimpleBitmapWorkerTask(final String key, final ImageView imageView, final ImageType imageType,
+                                  final Drawable fromDrawable, final Context context, final boolean scaleImgToView) {
+        super(key, imageView, imageType, fromDrawable, context, scaleImgToView);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected TransitionDrawable doInBackground(final String... params) {
+        if (isCancelled()) {
+            return null;
+        }
+
+        final Bitmap bitmap = getBitmapInBackground(params);
+        if (mScaleImgToView) {
+            Bitmap scaledBitmap = ImageUtils.scaleBitmapForImageView(bitmap, getAttachedImageView());
+            return createImageTransitionDrawable(scaledBitmap);
+        } else
+            return createImageTransitionDrawable(bitmap);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onPostExecute(TransitionDrawable transitionDrawable) {
+        final ImageView imageView = getAttachedImageView();
+        if (transitionDrawable != null && imageView != null) {
+            imageView.setImageDrawable(transitionDrawable);
+        } else if (imageView != null) {
+            imageView.setImageDrawable(mFromDrawable);
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/dragdrop/DragSortController.java b/twelve/src/main/java/com/dolzzo/twelve/dragdrop/DragSortController.java
new file mode 100755
index 0000000000..3d1231cf1b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/dragdrop/DragSortController.java
@@ -0,0 +1,434 @@
+
+package com.dolzzo.twelve.dragdrop;
+
+import android.graphics.Point;
+import android.view.GestureDetector;
+import android.view.HapticFeedbackConstants;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.widget.AdapterView;
+
+/**
+ * Class that starts and stops item drags on a {@link DragSortListView} based on
+ * touch gestures. This class also inherits from {@link SimpleFloatViewManager},
+ * which provides basic float View creation. An instance of this class is meant
+ * to be passed to the methods {@link DragSortListView#setTouchListener()} and
+ * {@link DragSortListView#setFloatViewManager()} of your
+ * {@link DragSortListView} instance.
+ */
+public class DragSortController extends SimpleFloatViewManager implements View.OnTouchListener,
+        GestureDetector.OnGestureListener {
+
+    public final static int ON_DOWN = 0;
+
+    public final static int ON_DRAG = 1;
+
+    public final static int ON_LONG_PRESS = 2;
+
+    public final static int FLING_RIGHT_REMOVE = 0;
+
+    public final static int FLING_LEFT_REMOVE = 1;
+
+    public final static int SLIDE_RIGHT_REMOVE = 2;
+
+    public final static int SLIDE_LEFT_REMOVE = 3;
+
+    public final static int MISS = -1;
+
+    private final GestureDetector mDetector;
+
+    private final GestureDetector mFlingRemoveDetector;
+
+    private final int mTouchSlop;
+
+    private final int[] mTempLoc = new int[2];
+
+    private final float mFlingSpeed = 500f;
+
+    private final DragSortListView mDslv;
+
+    private boolean mSortEnabled = true;
+
+    private boolean mRemoveEnabled = false;
+
+    private boolean mDragging = false;
+
+    private int mDragInitMode = ON_DOWN;
+
+    private int mRemoveMode;
+    private final GestureDetector.OnGestureListener mFlingRemoveListener = new GestureDetector.SimpleOnGestureListener() {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public final boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
+                                     float velocityY) {
+            if (mRemoveEnabled) {
+                switch (mRemoveMode) {
+                    case FLING_RIGHT_REMOVE:
+                        if (velocityX > mFlingSpeed) {
+                            mDslv.stopDrag(true);
+                        }
+                        break;
+                    case FLING_LEFT_REMOVE:
+                        if (velocityX < -mFlingSpeed) {
+                            mDslv.stopDrag(true);
+                        }
+                        break;
+                }
+            }
+            return false;
+        }
+    };
+    private int mHitPos = MISS;
+    private int mItemX;
+    private int mItemY;
+    private int mCurrX;
+    private int mCurrY;
+    private int mDragHandleId;
+    private float mOrigFloatAlpha = 1.0f;
+
+    /**
+     * Calls {@link #DragSortController(DragSortListView, int)} with a 0 drag
+     * handle id, FLING_RIGHT_REMOVE remove mode, and ON_DOWN drag init. By
+     * default, sorting is enabled, and removal is disabled.
+     *
+     * @param dslv The DSLV instance
+     */
+    public DragSortController(DragSortListView dslv) {
+        this(dslv, 0, ON_DOWN, FLING_RIGHT_REMOVE);
+    }
+
+    /**
+     * By default, sorting is enabled, and removal is disabled.
+     *
+     * @param dslv         The DSLV instance
+     * @param dragHandleId The resource id of the View that represents the drag
+     *                     handle in a list item.
+     */
+    public DragSortController(DragSortListView dslv, int dragHandleId, int dragInitMode,
+                              int removeMode) {
+        super(dslv);
+        mDslv = dslv;
+        mDetector = new GestureDetector(dslv.getContext(), this);
+        mFlingRemoveDetector = new GestureDetector(dslv.getContext(), mFlingRemoveListener);
+        mFlingRemoveDetector.setIsLongpressEnabled(false);
+        mTouchSlop = ViewConfiguration.get(dslv.getContext()).getScaledTouchSlop();
+        mDragHandleId = dragHandleId;
+        setRemoveMode(removeMode);
+        setDragInitMode(dragInitMode);
+        mOrigFloatAlpha = dslv.getFloatAlpha();
+    }
+
+    /**
+     * @return The current drag init mode.
+     */
+    public int getDragInitMode() {
+        return mDragInitMode;
+    }
+
+    /**
+     * Set how a drag is initiated. Needs to be one of {@link ON_DOWN},
+     * {@link ON_DRAG}, or {@link ON_LONG_PRESS}.
+     *
+     * @param mode The drag init mode.
+     */
+    public void setDragInitMode(int mode) {
+        mDragInitMode = mode;
+    }
+
+    /**
+     * @return True if sort is enabled, false otherwise.
+     */
+    public boolean isSortEnabled() {
+        return mSortEnabled;
+    }
+
+    /**
+     * Enable/Disable list item sorting. Disabling is useful if only item
+     * removal is desired. Prevents drags in the vertical direction.
+     *
+     * @param enabled Set <code>true</code> to enable list item sorting.
+     */
+    public void setSortEnabled(boolean enabled) {
+        mSortEnabled = enabled;
+    }
+
+    /**
+     * @return The current remove mode.
+     */
+    public int getRemoveMode() {
+        return mRemoveMode;
+    }
+
+    /**
+     * One of {@link FLING_RIGHT_REMOVE}, {@link FLING_LEFT_REMOVE},
+     * {@link SLIDE_RIGHT_REMOVE}, or {@link SLIDE_LEFT_REMOVE}.
+     */
+    public void setRemoveMode(int mode) {
+        mRemoveMode = mode;
+    }
+
+    /**
+     * @return True if remove is enabled, false otherwise.
+     */
+    public boolean isRemoveEnabled() {
+        return mRemoveEnabled;
+    }
+
+    /**
+     * Enable/Disable item removal without affecting remove mode.
+     */
+    public void setRemoveEnabled(boolean enabled) {
+        mRemoveEnabled = enabled;
+    }
+
+    /**
+     * Set the resource id for the View that represents the drag handle in a
+     * list item.
+     *
+     * @param id An android resource id.
+     */
+    public void setDragHandleId(int id) {
+        mDragHandleId = id;
+    }
+
+    /**
+     * Sets flags to restrict certain motions of the floating View based on
+     * DragSortController settings (such as remove mode). Starts the drag on the
+     * DragSortListView.
+     *
+     * @param position The list item position (includes headers).
+     * @param deltaX   Touch x-coord minus left edge of floating View.
+     * @param deltaY   Touch y-coord minus top edge of floating View.
+     * @return True if drag started, false otherwise.
+     */
+    public boolean startDrag(int position, int deltaX, int deltaY) {
+
+        int mDragFlags = 0;
+        if (mSortEnabled) {
+            mDragFlags |= DragSortListView.DRAG_POS_Y | DragSortListView.DRAG_NEG_Y;
+        }
+
+        if (mRemoveEnabled) {
+            if (mRemoveMode == FLING_RIGHT_REMOVE) {
+                mDragFlags |= DragSortListView.DRAG_POS_X;
+            } else if (mRemoveMode == FLING_LEFT_REMOVE) {
+                mDragFlags |= DragSortListView.DRAG_NEG_X;
+            }
+        }
+
+        mDragging = mDslv.startDrag(position - mDslv.getHeaderViewsCount(), mDragFlags, deltaX,
+                deltaY);
+        return mDragging;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onTouch(View v, MotionEvent ev) {
+        mDetector.onTouchEvent(ev);
+        if (mRemoveEnabled && mDragging
+                && (mRemoveMode == FLING_RIGHT_REMOVE || mRemoveMode == FLING_LEFT_REMOVE)) {
+            mFlingRemoveDetector.onTouchEvent(ev);
+        }
+
+        final int mAction = ev.getAction() & MotionEvent.ACTION_MASK;
+
+        switch (mAction) {
+            case MotionEvent.ACTION_DOWN:
+                mCurrX = (int) ev.getX();
+                mCurrY = (int) ev.getY();
+                break;
+            case MotionEvent.ACTION_UP:
+                if (mRemoveEnabled) {
+                    final int x = (int) ev.getX();
+                    int thirdW = mDslv.getWidth() / 3;
+                    int twoThirdW = mDslv.getWidth() - thirdW;
+                    if ((mRemoveMode == SLIDE_RIGHT_REMOVE && x > twoThirdW)
+                            || (mRemoveMode == SLIDE_LEFT_REMOVE && x < thirdW)) {
+                        mDslv.stopDrag(true);
+                    }
+                }
+            case MotionEvent.ACTION_CANCEL:
+                mDragging = false;
+                break;
+        }
+        return false;
+    }
+
+    /**
+     * Overrides to provide fading when slide removal is enabled.
+     */
+    @Override
+    public void onDragFloatView(View floatView, Point position, Point touch) {
+
+        if (mRemoveEnabled) {
+            int x = touch.x;
+
+            if (mRemoveMode == SLIDE_RIGHT_REMOVE) {
+                int width = mDslv.getWidth();
+                int thirdWidth = width / 3;
+
+                float alpha;
+                if (x < thirdWidth) {
+                    alpha = 1.0f;
+                } else if (x < width - thirdWidth) {
+                    alpha = ((float) (width - thirdWidth - x)) / ((float) thirdWidth);
+                } else {
+                    alpha = 0.0f;
+                }
+                mDslv.setFloatAlpha(mOrigFloatAlpha * alpha);
+            } else if (mRemoveMode == SLIDE_LEFT_REMOVE) {
+                int width = mDslv.getWidth();
+                int thirdWidth = width / 3;
+
+                float alpha;
+                if (x < thirdWidth) {
+                    alpha = 0.0f;
+                } else if (x < width - thirdWidth) {
+                    alpha = ((float) (x - thirdWidth)) / ((float) thirdWidth);
+                } else {
+                    alpha = 1.0f;
+                }
+                mDslv.setFloatAlpha(mOrigFloatAlpha * alpha);
+            }
+        }
+    }
+
+    /**
+     * Get the position to start dragging based on the ACTION_DOWN MotionEvent.
+     * This function simply calls {@link #dragHandleHitPosition(MotionEvent)}.
+     * Override to change drag handle behavior; this function is called
+     * internally when an ACTION_DOWN event is detected.
+     *
+     * @param ev The ACTION_DOWN MotionEvent.
+     * @return The list position to drag if a drag-init gesture is detected;
+     * MISS if unsuccessful.
+     */
+    public int startDragPosition(MotionEvent ev) {
+        return dragHandleHitPosition(ev);
+    }
+
+    /**
+     * Checks for the touch of an item's drag handle (specified by
+     * {@link #setDragHandleId(int)}), and returns that item's position if a
+     * drag handle touch was detected.
+     *
+     * @param ev The ACTION_DOWN MotionEvent.
+     * @return The list position of the item whose drag handle was touched; MISS
+     * if unsuccessful.
+     */
+    public int dragHandleHitPosition(MotionEvent ev) {
+        final int x = (int) ev.getX();
+        final int y = (int) ev.getY();
+
+        int touchPos = mDslv.pointToPosition(x, y);
+
+        final int numHeaders = mDslv.getHeaderViewsCount();
+        final int numFooters = mDslv.getFooterViewsCount();
+        final int count = mDslv.getCount();
+
+        if (touchPos != AdapterView.INVALID_POSITION && touchPos >= numHeaders
+                && touchPos < (count - numFooters)) {
+            final View item = mDslv.getChildAt(touchPos - mDslv.getFirstVisiblePosition());
+            final int rawX = (int) ev.getRawX();
+            final int rawY = (int) ev.getRawY();
+
+            View dragBox = item.findViewById(mDragHandleId);
+            if (dragBox != null) {
+                dragBox.getLocationOnScreen(mTempLoc);
+
+                if (rawX > mTempLoc[0] && rawY > mTempLoc[1]
+                        && rawX < mTempLoc[0] + dragBox.getWidth()
+                        && rawY < mTempLoc[1] + dragBox.getHeight()) {
+
+                    mItemX = item.getLeft();
+                    mItemY = item.getTop();
+
+                    return touchPos;
+                }
+            }
+        }
+        return MISS;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onDown(MotionEvent ev) {
+        mHitPos = startDragPosition(ev);
+
+        if (mHitPos != MISS && mDragInitMode == ON_DOWN) {
+            startDrag(mHitPos, (int) ev.getX() - mItemX, (int) ev.getY() - mItemY);
+        }
+
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
+        if (mHitPos != MISS && mDragInitMode == ON_DRAG && !mDragging) {
+            final int x1 = (int) e1.getX();
+            final int y1 = (int) e1.getY();
+            final int x2 = (int) e2.getX();
+            final int y2 = (int) e2.getY();
+
+            boolean start = false;
+            if (mRemoveEnabled && mSortEnabled) {
+                start = true;
+            } else if (mRemoveEnabled) {
+                start = Math.abs(x2 - x1) > mTouchSlop;
+            } else if (mSortEnabled) {
+                start = Math.abs(y2 - y1) > mTouchSlop;
+            }
+
+            if (start) {
+                startDrag(mHitPos, x2 - mItemX, y2 - mItemY);
+            }
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLongPress(MotionEvent e) {
+        if (mHitPos != MISS && mDragInitMode == ON_LONG_PRESS) {
+            mDslv.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
+            startDrag(mHitPos, mCurrX - mItemX, mCurrY - mItemY);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onSingleTapUp(MotionEvent ev) {
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onShowPress(MotionEvent ev) {
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/dragdrop/DragSortListView.java b/twelve/src/main/java/com/dolzzo/twelve/dragdrop/DragSortListView.java
new file mode 100755
index 0000000000..e3f52f5452
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/dragdrop/DragSortListView.java
@@ -0,0 +1,2052 @@
+/*
+ * DragSortListView. A subclass of the Android ListView component that enables
+ * drag and drop re-ordering of list items. Copyright 2012 Carl Bauer Licensed
+ * under the Apache License, Version 2.0 (the "License"); you may not use this
+ * file except in compliance with the License. You may obtain a copy of the
+ * License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by
+ * applicable law or agreed to in writing, software distributed under the
+ * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
+ * OF ANY KIND, either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.dragdrop;
+
+import android.content.Context;
+import android.database.DataSetObserver;
+import android.graphics.Canvas;
+import android.graphics.Point;
+import android.graphics.drawable.Drawable;
+import android.os.SystemClock;
+import android.util.AttributeSet;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AbsListView;
+import android.widget.BaseAdapter;
+import android.widget.HeaderViewListAdapter;
+import android.widget.ListAdapter;
+import android.widget.ListView;
+import android.widget.RelativeLayout;
+
+import com.dolzzo.twelve.R;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+
+/**
+ * ListView subclass that mediates drag and drop resorting of items.
+ *
+ * @author heycosmo
+ */
+public class DragSortListView extends ListView {
+
+    /**
+     * Drag flag bit. Floating View can move in the positive x direction.
+     */
+    public final static int DRAG_POS_X = 0x1;
+    /**
+     * Drag flag bit. Floating View can move in the negative x direction.
+     */
+    public final static int DRAG_NEG_X = 0x2;
+    /**
+     * Drag flag bit. Floating View can move in the positive y direction. This
+     * is subtle. What this actually means is that, if enabled, the floating
+     * View can be dragged below its starting position. Remove in favor of
+     * upper-bounding item position?
+     */
+    public final static int DRAG_POS_Y = 0x4;
+    /**
+     * Drag flag bit. Floating View can move in the negative y direction. This
+     * is subtle. What this actually means is that the floating View can be
+     * dragged above its starting position. Remove in favor of lower-bounding
+     * item position?
+     */
+    public final static int DRAG_NEG_Y = 0x8;
+    /**
+     * Drag state enum.
+     */
+    private final static int IDLE = 0;
+    private final static int STOPPED = 1;
+    private final static int DRAGGING = 2;
+    /**
+     * Enum telling where to cancel the ListView action when a drag-sort begins
+     */
+    private static final int NO_CANCEL = 0;
+    private static final int ON_TOUCH_EVENT = 1;
+    private static final int ON_INTERCEPT_TOUCH_EVENT = 2;
+    /**
+     * A proposed float View location based on touch location and given deltaX
+     * and deltaY.
+     */
+    private final Point mFloatLoc = new Point();
+    /**
+     * Watch the Adapter for data changes. Cancel a drag if coincident with a
+     * change.
+     */
+    private final DataSetObserver mObserver;
+    /**
+     * Transparency for the floating View (XML attribute).
+     */
+    private final float mFloatAlpha = 1.0f;
+    /**
+     * Drag-scroll encapsulator!
+     */
+    private final DragScroller mDragScroller;
+    /**
+     * Given to ListView to cancel its action when a drag-sort begins.
+     */
+    private final MotionEvent mCancelEvent;
+    /**
+     * Turn on custom debugger.
+     */
+    private final boolean mTrackDragSort = false;
+    private final DragSortController mController;
+    /**
+     * The View that floats above the ListView and represents the dragged item.
+     */
+    private View mFloatView;
+    /**
+     * The middle (in the y-direction) of the floating View.
+     */
+    private int mFloatViewMid;
+    /**
+     * Left edge of floating View.
+     */
+    private int mFloatViewLeft;
+    /**
+     * Top edge of floating View.
+     */
+    private int mFloatViewTop;
+    private float mCurrFloatAlpha = 1.0f;
+    /**
+     * While drag-sorting, the current position of the floating View. If
+     * dropped, the dragged item will land in this position.
+     */
+    private int mFloatPos;
+    /**
+     * The amount to scroll during the next layout pass. Used only for
+     * drag-scrolling, not standard ListView scrolling.
+     */
+    private int mScrollY = 0;
+    /**
+     * The first expanded ListView position that helps represent the drop slot
+     * tracking the floating View.
+     */
+    private int mFirstExpPos;
+    /**
+     * The second expanded ListView position that helps represent the drop slot
+     * tracking the floating View. This can equal mFirstExpPos if there is no
+     * slide shuffle occurring; otherwise it is equal to mFirstExpPos + 1.
+     */
+    private int mSecondExpPos;
+    /**
+     * Flag set if slide shuffling is enabled.
+     */
+    private boolean mAnimate = false;
+    /**
+     * The user dragged from this position.
+     */
+    private int mSrcPos;
+    /**
+     * Offset (in x) within the dragged item at which the user picked it up (or
+     * first touched down with the digitalis).
+     */
+    private int mDragDeltaX;
+    /**
+     * Offset (in y) within the dragged item at which the user picked it up (or
+     * first touched down with the digitalis).
+     */
+    private int mDragDeltaY;
+    /**
+     * A listener that receives callbacks whenever the floating View hovers over
+     * a new position.
+     */
+    private DragListener mDragListener;
+    /**
+     * A listener that receives a callback when the floating View is dropped.
+     */
+    private DropListener mDropListener;
+    /**
+     * A listener that receives a callback when the floating View (or more
+     * precisely the originally dragged item) is removed by one of the provided
+     * gestures.
+     */
+    private RemoveListener mRemoveListener;
+    /**
+     * Enable/Disable item dragging
+     */
+    private boolean mDragEnabled = true;
+    private int mDragState = IDLE;
+    /**
+     * Height in pixels to which the originally dragged item is collapsed during
+     * a drag-sort. Currently, this value must be greater than zero.
+     */
+    private int mItemHeightCollapsed = 1;
+    /**
+     * Height of the floating View. Stored for the purpose of providing the
+     * tracking drop slot.
+     */
+    private int mFloatViewHeight;
+    /**
+     * Convenience member. See above.
+     */
+    private int mFloatViewHeightHalf;
+    /**
+     * Save the given width spec for use in measuring children
+     */
+    private int mWidthMeasureSpec = 0;
+    /**
+     * Sample Views ultimately used for calculating the height of ListView items
+     * that are off-screen.
+     */
+    private View[] mSampleViewTypes = new View[1];
+    /**
+     * Determines the start of the upward drag-scroll region at the top of the
+     * ListView. Specified by a fraction of the ListView height, thus screen
+     * resolution agnostic.
+     */
+    private float mDragUpScrollStartFrac = 1.0f / 3.0f;
+    /**
+     * Determines the start of the downward drag-scroll region at the bottom of
+     * the ListView. Specified by a fraction of the ListView height, thus screen
+     * resolution agnostic.
+     */
+    private float mDragDownScrollStartFrac = 1.0f / 3.0f;
+    /**
+     * The following are calculated from the above fracs.
+     */
+    private int mUpScrollStartY;
+    private int mDownScrollStartY;
+    private float mDownScrollStartYF;
+    private float mUpScrollStartYF;
+    /**
+     * Calculated from above above and current ListView height.
+     */
+    private float mDragUpScrollHeight;
+    /**
+     * Calculated from above above and current ListView height.
+     */
+    private float mDragDownScrollHeight;
+    /**
+     * Maximum drag-scroll speed in pixels per ms. Only used with default linear
+     * drag-scroll profile.
+     */
+    private float mMaxScrollSpeed = 0.3f;
+    /**
+     * Defines the scroll speed during a drag-scroll. User can provide their
+     * own; this default is a simple linear profile where scroll speed increases
+     * linearly as the floating View nears the top/bottom of the ListView.
+     */
+    private DragScrollProfile mScrollProfile = new DragScrollProfile() {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public float getSpeed(final float w, final long t) {
+            return mMaxScrollSpeed * w;
+        }
+    };
+    /**
+     * Current touch x.
+     */
+    private int mX;
+    /**
+     * Current touch y.
+     */
+    private int mY;
+    /**
+     * Last touch y.
+     */
+    private int mLastY;
+    /**
+     * Flags that determine limits on the motion of the floating View. See flags
+     * above.
+     */
+    private int mDragFlags = 0;
+    /**
+     * Last call to an on*TouchEvent was a call to onInterceptTouchEvent.
+     */
+    private boolean mLastCallWasIntercept = false;
+    /**
+     * A touch event is in progress.
+     */
+    private boolean mInTouchEvent = false;
+    /**
+     * Let the user customize the floating View.
+     */
+    private FloatViewManager mFloatViewManager = null;
+    /**
+     * Where to cancel the ListView action when a drag-sort begins
+     */
+    private int mCancelMethod = NO_CANCEL;
+    /**
+     * Determines when a slide shuffle animation starts. That is, defines how
+     * close to the edge of the drop slot the floating View must be to initiate
+     * the slide.
+     */
+    private float mSlideRegionFrac = 0.25f;
+    /**
+     * Number between 0 and 1 indicating the relative location of a sliding item
+     * (only used if drag-sort animations are turned on). Nearly 1 means the
+     * item is at the top of the slide region (nearly full blank item is
+     * directly below).
+     */
+    private float mSlideFrac = 0.0f;
+    /**
+     * Wraps the user-provided ListAdapter. This is used to wrap each item View
+     * given by the user inside another View (currenly a RelativeLayout) which
+     * expands and collapses to simulate the item shuffling.
+     */
+    private AdapterWrapper mAdapterWrapper;
+    /**
+     * Debugging class.
+     */
+    private DragSortTracker mDragSortTracker;
+    /**
+     * Needed for adjusting item heights from within layoutChildren
+     */
+    private boolean mBlockLayoutRequests = false;
+
+    /**
+     * @param context The {@link Context} to use
+     * @param attrs   The attributes of the XML tag that is inflating the view.
+     */
+    public DragSortListView(final Context context, final AttributeSet attrs) {
+        super(context, attrs);
+        mItemHeightCollapsed = 1;
+
+        mCurrFloatAlpha = mFloatAlpha;
+
+        mSlideRegionFrac = 0.75f;
+
+        mAnimate = mSlideRegionFrac > 0.0f;
+
+        setDragScrollStart(mDragUpScrollStartFrac);
+
+        mController = new DragSortController(this, R.id.edit_track_list_item_handle,
+                DragSortController.ON_DOWN, DragSortController.FLING_RIGHT_REMOVE);
+        mController.setRemoveEnabled(true);
+        mController.setSortEnabled(true);
+        mController
+                .setBackgroundColor(getResources().getColor(R.color.accent));
+
+        mFloatViewManager = mController;
+        setOnTouchListener(mController);
+
+        mDragScroller = new DragScroller();
+        setOnScrollListener(mDragScroller);
+
+        mCancelEvent = MotionEvent.obtain(0, 0, MotionEvent.ACTION_CANCEL, 0f, 0f, 0f, 0f, 0, 0f,
+                0f, 0, 0);
+
+        mObserver = new DataSetObserver() {
+            private void cancel() {
+                if (mDragState == DRAGGING) {
+                    stopDrag(false);
+                }
+            }
+
+            /**
+             * {@inheritDoc}
+             */
+            @Override
+            public void onChanged() {
+                cancel();
+            }
+
+            /**
+             * {@inheritDoc}
+             */
+            @Override
+            public void onInvalidated() {
+                cancel();
+            }
+        };
+    }
+
+    public float getFloatAlpha() {
+        return mCurrFloatAlpha;
+    }
+
+    /**
+     * Usually called from a FloatViewManager. The float alpha will be reset to
+     * the xml-defined value every time a drag is stopped.
+     */
+    public void setFloatAlpha(final float alpha) {
+        mCurrFloatAlpha = alpha;
+    }
+
+    /**
+     * Set maximum drag scroll speed in positions/second. Only applies if using
+     * default ScrollSpeedProfile.
+     *
+     * @param max Maximum scroll speed.
+     */
+    public void setMaxScrollSpeed(final float max) {
+        mMaxScrollSpeed = max;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setAdapter(final ListAdapter adapter) {
+        mAdapterWrapper = new AdapterWrapper(adapter);
+        adapter.registerDataSetObserver(mObserver);
+        super.setAdapter(mAdapterWrapper);
+    }
+
+    /**
+     * As opposed to {@link ListView#getAdapter()}, which returns a heavily
+     * wrapped ListAdapter (DragSortListView wraps the input ListAdapter {\emph
+     * and} ListView wraps the wrapped one).
+     *
+     * @return The ListAdapter set as the argument of {@link setAdapter()}
+     */
+    public ListAdapter getInputAdapter() {
+        if (mAdapterWrapper == null) {
+            return null;
+        } else {
+            return mAdapterWrapper.getAdapter();
+        }
+    }
+
+    private void drawDivider(final int expPosition, final Canvas canvas) {
+
+        final Drawable divider = getDivider();
+        final int dividerHeight = getDividerHeight();
+
+        if (divider != null && dividerHeight != 0) {
+            final ViewGroup expItem = (ViewGroup) getChildAt(expPosition - getFirstVisiblePosition());
+            if (expItem != null) {
+                final int l = getPaddingLeft();
+                final int r = getWidth() - getPaddingRight();
+                final int t;
+                final int b;
+
+                final int childHeight = expItem.getChildAt(0).getHeight();
+
+                if (expPosition > mSrcPos) {
+                    t = expItem.getTop() + childHeight;
+                    b = t + dividerHeight;
+                } else {
+                    b = expItem.getBottom() - childHeight;
+                    t = b - dividerHeight;
+                }
+
+                divider.setBounds(l, t, r, b);
+                divider.draw(canvas);
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void dispatchDraw(final Canvas canvas) {
+        super.dispatchDraw(canvas);
+
+        if (mFloatView != null) {
+            if (mFirstExpPos != mSrcPos) {
+                drawDivider(mFirstExpPos, canvas);
+            }
+            if (mSecondExpPos != mFirstExpPos && mSecondExpPos != mSrcPos) {
+                drawDivider(mSecondExpPos, canvas);
+            }
+
+            final int w = mFloatView.getWidth();
+            final int h = mFloatView.getHeight();
+            final int alpha = (int) (255f * mCurrFloatAlpha);
+
+            canvas.save();
+            canvas.translate(mFloatViewLeft, mFloatViewTop);
+            canvas.clipRect(0, 0, w, h);
+
+            canvas.saveLayerAlpha(0, 0, w, h, alpha, Canvas.ALL_SAVE_FLAG);
+            mFloatView.draw(canvas);
+            canvas.restore();
+            canvas.restore();
+        }
+    }
+
+    private void measureItemAndGetHeights(final int position, final View item,
+                                          final ItemHeights heights) {
+        ViewGroup.LayoutParams lp = item.getLayoutParams();
+
+        final boolean isHeadFoot = position < getHeaderViewsCount()
+                || position >= getCount() - getFooterViewsCount();
+
+        int height = lp == null ? 0 : lp.height;
+        if (height > 0) {
+            heights.item = height;
+
+            // get height of child, measure if we have to
+            if (isHeadFoot) {
+                heights.child = heights.item;
+            } else if (position == mSrcPos) {
+                heights.child = 0;
+            } else {
+                final View child = ((ViewGroup) item).getChildAt(0);
+                lp = child.getLayoutParams();
+                height = lp == null ? 0 : lp.height;
+                if (height > 0) {
+                    heights.child = height;
+                } else {
+                    final int hspec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+                    final int wspec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,
+                            getListPaddingLeft() + getListPaddingRight(), lp.width);
+                    child.measure(wspec, hspec);
+                    heights.child = child.getMeasuredHeight();
+                }
+            }
+        } else {
+            final int hspec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+            final int wspec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, getListPaddingLeft()
+                    + getListPaddingRight(), lp == null ? ViewGroup.LayoutParams.MATCH_PARENT
+                    : lp.width);
+            item.measure(wspec, hspec);
+
+            heights.item = item.getMeasuredHeight();
+            if (isHeadFoot) {
+                heights.child = heights.item;
+            } else if (position == mSrcPos) {
+                heights.child = 0;
+            } else {
+                heights.child = ((ViewGroup) item).getChildAt(0).getMeasuredHeight();
+            }
+        }
+    }
+
+    /**
+     * Get the height of the given wrapped item and its child.
+     *
+     * @param position Position from which item was obtained.
+     * @param item     List item (usually obtained from
+     *                 {@link ListView#getChildAt()}).
+     * @param heights  Object to fill with heights of item.
+     */
+    private void getItemHeights(final int position, final View item, final ItemHeights heights) {
+        final boolean isHeadFoot = position < getHeaderViewsCount()
+                || position >= getCount() - getFooterViewsCount();
+
+        heights.item = item.getHeight();
+
+        if (isHeadFoot) {
+            heights.child = heights.item;
+        } else if (position == mSrcPos) {
+            heights.child = 0;
+        } else {
+            heights.child = ((ViewGroup) item).getChildAt(0).getHeight();
+        }
+    }
+
+    /**
+     * This function works for arbitrary positions (could be off-screen). If
+     * requested position is off-screen, this function calls
+     * <code>getView</code> to get height information.
+     *
+     * @param position ListView position.
+     * @param heights  Object to fill with heights of item at
+     *                 <code>position</code>.
+     */
+    private void getItemHeights(final int position, final ItemHeights heights) {
+
+        final int first = getFirstVisiblePosition();
+        final int last = getLastVisiblePosition();
+
+        if (position >= first && position <= last) {
+            getItemHeights(position, getChildAt(position - first), heights);
+        } else {
+            // Log.d("mobeta", "getView for height");
+
+            final ListAdapter adapter = getAdapter();
+            final int type = adapter.getItemViewType(position);
+
+            // There might be a better place for checking for the following
+            final int typeCount = adapter.getViewTypeCount();
+            if (typeCount != mSampleViewTypes.length) {
+                mSampleViewTypes = new View[typeCount];
+            }
+
+            View v;
+            if (type >= 0) {
+                if (mSampleViewTypes[type] == null) {
+                    v = adapter.getView(position, null, this);
+                    mSampleViewTypes[type] = v;
+                } else {
+                    v = adapter.getView(position, mSampleViewTypes[type], this);
+                }
+            } else {
+                // type is HEADER_OR_FOOTER or IGNORE
+                v = adapter.getView(position, null, this);
+            }
+
+            measureItemAndGetHeights(position, v, heights);
+        }
+
+    }
+
+    private int getShuffleEdge(final int position, final int top) {
+        return getShuffleEdge(position, top, null);
+    }
+
+    /**
+     * Get the shuffle edge for item at position when top of item is at y-coord
+     * top
+     *
+     * @param position
+     * @param top
+     * @param height   Height of item at position. If -1, this function calculates
+     *                 this height.
+     * @return Shuffle line between position-1 and position (for the given view
+     * of the list; that is, for when top of item at position has
+     * y-coord of given `top`). If floating View (treated as horizontal
+     * line) is dropped immediately above this line, it lands in
+     * position-1. If dropped immediately below this line, it lands in
+     * position.
+     */
+    private int getShuffleEdge(final int position, final int top, ItemHeights heights) {
+
+        final int numHeaders = getHeaderViewsCount();
+        final int numFooters = getFooterViewsCount();
+
+        // shuffle edges are defined between items that can be
+        // dragged; there are N-1 of them if there are N draggable
+        // items.
+
+        if (position <= numHeaders || position >= getCount() - numFooters) {
+            return top;
+        }
+
+        final int divHeight = getDividerHeight();
+
+        int edge;
+
+        final int maxBlankHeight = mFloatViewHeight - mItemHeightCollapsed;
+
+        if (heights == null) {
+            heights = new ItemHeights();
+            getItemHeights(position, heights);
+        }
+
+        // first calculate top of item given that floating View is
+        // centered over src position
+        int otop = top;
+        if (mSecondExpPos <= mSrcPos) {
+            // items are expanded on and/or above the source position
+
+            if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {
+                if (position == mSrcPos) {
+                    otop = top + heights.item - mFloatViewHeight;
+                } else {
+                    final int blankHeight = heights.item - heights.child;
+                    otop = top + blankHeight - maxBlankHeight;
+                }
+            } else if (position > mSecondExpPos && position <= mSrcPos) {
+                otop = top - maxBlankHeight;
+            }
+
+        } else {
+            // items are expanded on and/or below the source position
+
+            if (position > mSrcPos && position <= mFirstExpPos) {
+                otop = top + maxBlankHeight;
+            } else if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {
+                final int blankHeight = heights.item - heights.child;
+                otop = top + blankHeight;
+            }
+        }
+
+        // otop is set
+        if (position <= mSrcPos) {
+            final ItemHeights tmpHeights = new ItemHeights();
+            getItemHeights(position - 1, tmpHeights);
+            edge = otop + (mFloatViewHeight - divHeight - tmpHeights.child) / 2;
+        } else {
+            edge = otop + (heights.child - divHeight - mFloatViewHeight) / 2;
+        }
+
+        return edge;
+    }
+
+    private boolean updatePositions() {
+
+        final int first = getFirstVisiblePosition();
+        int startPos = mFirstExpPos;
+        View startView = getChildAt(startPos - first);
+
+        if (startView == null) {
+            startPos = first + getChildCount() / 2;
+            startView = getChildAt(startPos - first);
+        }
+        final int startTop = startView.getTop() + mScrollY;
+
+        final ItemHeights itemHeights = new ItemHeights();
+        getItemHeights(startPos, startView, itemHeights);
+
+        int edge = getShuffleEdge(startPos, startTop, itemHeights);
+        int lastEdge = edge;
+
+        final int divHeight = getDividerHeight();
+
+        // Log.d("mobeta", "float mid="+mFloatViewMid);
+
+        int itemPos = startPos;
+        int itemTop = startTop;
+        if (mFloatViewMid < edge) {
+            // scanning up for float position
+            // Log.d("mobeta", "    edge="+edge);
+            while (itemPos >= 0) {
+                itemPos--;
+                getItemHeights(itemPos, itemHeights);
+
+                // if (itemPos <= 0)
+                if (itemPos == 0) {
+                    edge = itemTop - divHeight - itemHeights.item;
+                    // itemPos = 0;
+                    break;
+                }
+
+                itemTop -= itemHeights.item + divHeight;
+                edge = getShuffleEdge(itemPos, itemTop, itemHeights);
+                // Log.d("mobeta", "    edge="+edge);
+
+                if (mFloatViewMid >= edge) {
+                    break;
+                }
+
+                lastEdge = edge;
+            }
+        } else {
+            // scanning down for float position
+            // Log.d("mobeta", "    edge="+edge);
+            final int count = getCount();
+            while (itemPos < count) {
+                if (itemPos == count - 1) {
+                    edge = itemTop + divHeight + itemHeights.item;
+                    break;
+                }
+
+                itemTop += divHeight + itemHeights.item;
+                getItemHeights(itemPos + 1, itemHeights);
+                edge = getShuffleEdge(itemPos + 1, itemTop, itemHeights);
+                // Log.d("mobeta", "    edge="+edge);
+
+                // test for hit
+                if (mFloatViewMid < edge) {
+                    break;
+                }
+
+                lastEdge = edge;
+                itemPos++;
+            }
+        }
+
+        final int numHeaders = getHeaderViewsCount();
+        final int numFooters = getFooterViewsCount();
+
+        boolean updated = false;
+
+        final int oldFirstExpPos = mFirstExpPos;
+        final int oldSecondExpPos = mSecondExpPos;
+        final float oldSlideFrac = mSlideFrac;
+
+        if (mAnimate) {
+            final int edgeToEdge = Math.abs(edge - lastEdge);
+
+            int edgeTop, edgeBottom;
+            if (mFloatViewMid < edge) {
+                edgeBottom = edge;
+                edgeTop = lastEdge;
+            } else {
+                edgeTop = edge;
+                edgeBottom = lastEdge;
+            }
+            // Log.d("mobeta", "edgeTop="+edgeTop+" edgeBot="+edgeBottom);
+
+            final int slideRgnHeight = (int) (0.5f * mSlideRegionFrac * edgeToEdge);
+            final int slideEdgeTop = edgeTop + slideRgnHeight;
+            final int slideEdgeBottom = edgeBottom - slideRgnHeight;
+
+            // Three regions
+            if (mFloatViewMid < slideEdgeTop) {
+                mFirstExpPos = itemPos - 1;
+                mSecondExpPos = itemPos;
+                mSlideFrac = 0.5f * (slideEdgeTop - mFloatViewMid) / (float) slideRgnHeight;
+                // Log.d("mobeta",
+                // "firstExp="+mFirstExpPos+" secExp="+mSecondExpPos+" slideFrac="+mSlideFrac);
+            } else if (mFloatViewMid < slideEdgeBottom) {
+                mFirstExpPos = itemPos;
+                mSecondExpPos = itemPos;
+            } else {
+                mFirstExpPos = itemPos;
+                mSecondExpPos = itemPos + 1;
+                mSlideFrac = 0.5f * (1.0f + (edgeBottom - mFloatViewMid) / (float) slideRgnHeight);
+                // Log.d("mobeta",
+                // "firstExp="+mFirstExpPos+" secExp="+mSecondExpPos+" slideFrac="+mSlideFrac);
+            }
+
+        } else {
+            mFirstExpPos = itemPos;
+            mSecondExpPos = itemPos;
+        }
+
+        // correct for headers and footers
+        if (mFirstExpPos < numHeaders) {
+            itemPos = numHeaders;
+            mFirstExpPos = itemPos;
+            mSecondExpPos = itemPos;
+        } else if (mSecondExpPos >= getCount() - numFooters) {
+            itemPos = getCount() - numFooters - 1;
+            mFirstExpPos = itemPos;
+            mSecondExpPos = itemPos;
+        }
+
+        if (mFirstExpPos != oldFirstExpPos || mSecondExpPos != oldSecondExpPos
+                || mSlideFrac != oldSlideFrac) {
+            updated = true;
+        }
+
+        if (itemPos != mFloatPos) {
+            if (mDragListener != null) {
+                mDragListener.drag(mFloatPos - numHeaders, itemPos - numHeaders);
+            }
+
+            mFloatPos = itemPos;
+            updated = true;
+        }
+
+        return updated;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onDraw(final Canvas canvas) {
+        super.onDraw(canvas);
+
+        if (mTrackDragSort) {
+            mDragSortTracker.appendState();
+        }
+    }
+
+    /**
+     * Stop a drag in progress. Pass <code>true</code> if you would like to
+     * remove the dragged item from the list.
+     *
+     * @param remove Remove the dragged item from the list. Calls a registered
+     *               DropListener, if one exists.
+     * @return True if the stop was successful.
+     */
+    public boolean stopDrag(final boolean remove) {
+        if (mFloatView != null) {
+            mDragState = STOPPED;
+
+            // stop the drag
+            dropFloatView(remove);
+
+            return true;
+        } else {
+            // stop failed
+            return false;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onTouchEvent(final MotionEvent ev) {
+
+        if (!mDragEnabled) {
+            return super.onTouchEvent(ev);
+        }
+
+        boolean more = false;
+
+        final boolean lastCallWasIntercept = mLastCallWasIntercept;
+        mLastCallWasIntercept = false;
+
+        if (!lastCallWasIntercept) {
+            saveTouchCoords(ev);
+        }
+
+        if (mFloatView != null) {
+            onDragTouchEvent(ev);
+            more = true; // give us more!
+        } else {
+            // what if float view is null b/c we dropped in middle
+            // of drag touch event?
+
+            if (mDragState != STOPPED) {
+                if (super.onTouchEvent(ev)) {
+                    more = true;
+                }
+            }
+
+            final int action = ev.getAction() & MotionEvent.ACTION_MASK;
+            switch (action) {
+                case MotionEvent.ACTION_CANCEL:
+                case MotionEvent.ACTION_UP:
+                    doActionUpOrCancel();
+                    break;
+                default:
+                    if (more) {
+                        mCancelMethod = ON_TOUCH_EVENT;
+                    }
+            }
+        }
+
+        return more;
+
+    }
+
+    private void doActionUpOrCancel() {
+        mCancelMethod = NO_CANCEL;
+        mInTouchEvent = false;
+        mDragState = IDLE;
+        mCurrFloatAlpha = mFloatAlpha;
+    }
+
+    private void saveTouchCoords(final MotionEvent ev) {
+        final int action = ev.getAction() & MotionEvent.ACTION_MASK;
+        if (action != MotionEvent.ACTION_DOWN) {
+            mLastY = mY;
+        }
+        mX = (int) ev.getX();
+        mY = (int) ev.getY();
+        if (action == MotionEvent.ACTION_DOWN) {
+            mLastY = mY;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onInterceptTouchEvent(final MotionEvent ev) {
+        if (!mDragEnabled) {
+            return super.onInterceptTouchEvent(ev);
+        }
+
+        saveTouchCoords(ev);
+        mLastCallWasIntercept = true;
+
+        boolean intercept = false;
+
+        final int action = ev.getAction() & MotionEvent.ACTION_MASK;
+
+        if (action == MotionEvent.ACTION_DOWN) {
+            mInTouchEvent = true;
+        }
+
+        // the following deals with calls to super.onInterceptTouchEvent
+        if (mFloatView != null) {
+            // super's touch event canceled in startDrag
+            intercept = true;
+        } else {
+            if (super.onInterceptTouchEvent(ev)) {
+                intercept = true;
+            }
+
+            switch (action) {
+                case MotionEvent.ACTION_CANCEL:
+                case MotionEvent.ACTION_UP:
+                    doActionUpOrCancel();
+                    break;
+                default:
+                    if (intercept) {
+                        mCancelMethod = ON_TOUCH_EVENT;
+                    } else {
+                        mCancelMethod = ON_INTERCEPT_TOUCH_EVENT;
+                    }
+            }
+        }
+
+        // check for startDragging
+
+        if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
+            mInTouchEvent = false;
+        }
+
+        return intercept;
+    }
+
+    /**
+     * Set the width of each drag scroll region by specifying a fraction of the
+     * ListView height.
+     *
+     * @param heightFraction Fraction of ListView height. Capped at 0.5f.
+     */
+    public void setDragScrollStart(final float heightFraction) {
+        setDragScrollStarts(heightFraction, heightFraction);
+    }
+
+    /**
+     * Set the width of each drag scroll region by specifying a fraction of the
+     * ListView height.
+     *
+     * @param upperFrac Fraction of ListView height for up-scroll bound. Capped
+     *                  at 0.5f.
+     * @param lowerFrac Fraction of ListView height for down-scroll bound.
+     *                  Capped at 0.5f.
+     */
+    public void setDragScrollStarts(final float upperFrac, final float lowerFrac) {
+        if (lowerFrac > 0.5f) {
+            mDragDownScrollStartFrac = 0.5f;
+        } else {
+            mDragDownScrollStartFrac = lowerFrac;
+        }
+
+        if (upperFrac > 0.5f) {
+            mDragUpScrollStartFrac = 0.5f;
+        } else {
+            mDragUpScrollStartFrac = upperFrac;
+        }
+
+        if (getHeight() != 0) {
+            updateScrollStarts();
+        }
+    }
+
+    private void continueDrag(final int x, final int y) {
+
+        // Log.d("mobeta", "move");
+        dragView(x, y);
+
+        // if (mTrackDragSort) {
+        // mDragSortTracker.appendState();
+        // }
+
+        requestLayout();
+
+        final int minY = Math.min(y, mFloatViewMid + mFloatViewHeightHalf);
+        final int maxY = Math.max(y, mFloatViewMid - mFloatViewHeightHalf);
+
+        // get the current scroll direction
+        final int currentScrollDir = mDragScroller.getScrollDir();
+
+        if (minY > mLastY && minY > mDownScrollStartY && currentScrollDir != DragScroller.DOWN) {
+            // dragged down, it is below the down scroll start and it is not
+            // scrolling up
+
+            if (currentScrollDir != DragScroller.STOP) {
+                // moved directly from up scroll to down scroll
+                mDragScroller.stopScrolling(true);
+            }
+
+            // start scrolling down
+            mDragScroller.startScrolling(DragScroller.DOWN);
+        } else if (maxY < mLastY && maxY < mUpScrollStartY && currentScrollDir != DragScroller.UP) {
+            // dragged up, it is above the up scroll start and it is not
+            // scrolling up
+
+            if (currentScrollDir != DragScroller.STOP) {
+                // moved directly from down scroll to up scroll
+                mDragScroller.stopScrolling(true);
+            }
+
+            // start scrolling up
+            mDragScroller.startScrolling(DragScroller.UP);
+        } else if (maxY >= mUpScrollStartY && minY <= mDownScrollStartY
+                && mDragScroller.isScrolling()) {
+            // not in the upper nor in the lower drag-scroll regions but it is
+            // still scrolling
+
+            mDragScroller.stopScrolling(true);
+        }
+    }
+
+    private void updateScrollStarts() {
+        final int padTop = getPaddingTop();
+        final int listHeight = getHeight() - padTop - getPaddingBottom();
+
+        mUpScrollStartYF = padTop + mDragUpScrollStartFrac * (float) listHeight;
+        mDownScrollStartYF = padTop + (1.0f - mDragDownScrollStartFrac) * (float) listHeight;
+
+        mUpScrollStartY = (int) mUpScrollStartYF;
+        mDownScrollStartY = (int) mDownScrollStartYF;
+
+        mDragUpScrollHeight = mUpScrollStartYF - padTop;
+        mDragDownScrollHeight = padTop + listHeight - mDownScrollStartYF;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onSizeChanged(final int w, final int h, final int oldw, final int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        updateScrollStarts();
+    }
+
+    private void dropFloatView(final boolean removeSrcItem) {
+
+        mDragScroller.stopScrolling(true);
+
+        if (removeSrcItem) {
+            if (mRemoveListener != null) {
+                mRemoveListener.remove(mSrcPos - getHeaderViewsCount());
+            }
+        } else {
+            if (mDropListener != null && mFloatPos >= 0 && mFloatPos < getCount()) {
+                final int numHeaders = getHeaderViewsCount();
+                mDropListener.drop(mSrcPos - numHeaders, mFloatPos - numHeaders);
+            }
+
+            // adjustAllItems();
+
+            final int firstPos = getFirstVisiblePosition();
+            if (mSrcPos < firstPos) {
+                // collapsed src item is off screen;
+                // adjust the scroll after item heights have been fixed
+                final View v = getChildAt(0);
+                int top = 0;
+                if (v != null) {
+                    top = v.getTop();
+                }
+                // Log.d("mobeta", "top="+top+" fvh="+mFloatViewHeight);
+                setSelectionFromTop(firstPos - 1, top - getPaddingTop());
+            }
+        }
+
+        mSrcPos = -1;
+        mFirstExpPos = -1;
+        mSecondExpPos = -1;
+        mFloatPos = -1;
+
+        removeFloatView();
+
+        if (mTrackDragSort) {
+            mDragSortTracker.stopTracking();
+        }
+    }
+
+    private void adjustAllItems() {
+        final int first = getFirstVisiblePosition();
+        final int last = getLastVisiblePosition();
+
+        final int begin = Math.max(0, getHeaderViewsCount() - first);
+        final int end = Math.min(last - first, getCount() - 1 - getFooterViewsCount() - first);
+
+        for (int i = begin; i <= end; ++i) {
+            final View v = getChildAt(i);
+            if (v != null) {
+                adjustItem(first + i, v, false);
+            }
+        }
+    }
+
+    private void adjustItem(final int position, final View v, final boolean needsMeasure) {
+
+        final ViewGroup.LayoutParams lp = v.getLayoutParams();
+        final int oldHeight = lp.height;
+        int height = oldHeight;
+
+        getDividerHeight();
+
+        final boolean isSliding = mAnimate && mFirstExpPos != mSecondExpPos;
+        final int maxNonSrcBlankHeight = mFloatViewHeight - mItemHeightCollapsed;
+        final int slideHeight = (int) (mSlideFrac * maxNonSrcBlankHeight);
+
+        if (position == mSrcPos) {
+            if (mSrcPos == mFirstExpPos) {
+                if (isSliding) {
+                    height = slideHeight + mItemHeightCollapsed;
+                } else {
+                    height = mFloatViewHeight;
+                }
+            } else if (mSrcPos == mSecondExpPos) {
+                // if gets here, we know an item is sliding
+                height = mFloatViewHeight - slideHeight;
+            } else {
+                height = mItemHeightCollapsed;
+            }
+        } else if (position == mFirstExpPos || position == mSecondExpPos) {
+            // position is not src
+
+            final ItemHeights itemHeights = new ItemHeights();
+            if (needsMeasure) {
+                measureItemAndGetHeights(position, v, itemHeights);
+            } else {
+                getItemHeights(position, v, itemHeights);
+            }
+
+            if (position == mFirstExpPos) {
+                if (isSliding) {
+                    height = itemHeights.child + slideHeight;
+                } else {
+                    height = itemHeights.child + maxNonSrcBlankHeight;
+                }
+            } else { // position=mSecondExpPos
+                // we know an item is sliding (b/c 2ndPos != 1stPos)
+                height = itemHeights.child + maxNonSrcBlankHeight - slideHeight;
+            }
+        } else {
+            height = ViewGroup.LayoutParams.WRAP_CONTENT;
+        }
+
+        if (height != oldHeight) {
+            lp.height = height;
+
+            v.setLayoutParams(lp);
+        }
+
+        // Adjust item gravity
+
+        if (position == mFirstExpPos || position == mSecondExpPos) {
+            if (position < mSrcPos) {
+                ((RelativeLayout) v).setGravity(Gravity.BOTTOM);
+            } else if (position > mSrcPos) {
+                ((RelativeLayout) v).setGravity(Gravity.TOP);
+            }
+        }
+
+        // Finally adjust item visibility
+
+        final int oldVis = v.getVisibility();
+        int vis = View.VISIBLE;
+
+        if (position == mSrcPos && mFloatView != null) {
+            vis = View.INVISIBLE;
+        }
+
+        if (vis != oldVis) {
+            v.setVisibility(vis);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void requestLayout() {
+        if (!mBlockLayoutRequests) {
+            super.requestLayout();
+        }
+    }
+
+    private void doDragScroll(final int oldFirstExpPos, final int oldSecondExpPos) {
+        if (mScrollY == 0) {
+            return;
+        }
+
+        final int padTop = getPaddingTop();
+        final int listHeight = getHeight() - padTop - getPaddingBottom();
+        final int first = getFirstVisiblePosition();
+        final int last = getLastVisiblePosition();
+
+        int movePos;
+
+        if (mScrollY >= 0) {
+            mScrollY = Math.min(listHeight, mScrollY);
+            movePos = first;
+        } else {
+            mScrollY = Math.max(-listHeight, mScrollY);
+            movePos = last;
+        }
+
+        final View moveItem = getChildAt(movePos - first);
+        int top = moveItem.getTop() + mScrollY;
+
+        if (movePos == 0 && top > padTop) {
+            top = padTop;
+        }
+
+        final ItemHeights itemHeightsBefore = new ItemHeights();
+        getItemHeights(movePos, moveItem, itemHeightsBefore);
+        final int moveHeightBefore = itemHeightsBefore.item;
+        final int moveBlankBefore = moveHeightBefore - itemHeightsBefore.child;
+
+        final ItemHeights itemHeightsAfter = new ItemHeights();
+        measureItemAndGetHeights(movePos, moveItem, itemHeightsAfter);
+        final int moveHeightAfter = itemHeightsAfter.item;
+        final int moveBlankAfter = moveHeightAfter - itemHeightsAfter.child;
+
+        if (movePos <= oldFirstExpPos) {
+            if (movePos > mFirstExpPos) {
+                top += mFloatViewHeight - moveBlankAfter;
+            }
+        } else if (movePos == oldSecondExpPos) {
+            if (movePos <= mFirstExpPos) {
+                top += moveBlankBefore - mFloatViewHeight;
+            } else if (movePos == mSecondExpPos) {
+                top += moveHeightBefore - moveHeightAfter;
+            } else {
+                top += moveBlankBefore;
+            }
+        } else {
+            if (movePos <= mFirstExpPos) {
+                top -= mFloatViewHeight;
+            } else if (movePos == mSecondExpPos) {
+                top -= moveBlankAfter;
+            }
+        }
+
+        setSelectionFromTop(movePos, top - padTop);
+
+        mScrollY = 0;
+    }
+
+    private void measureFloatView() {
+        if (mFloatView != null) {
+            ViewGroup.LayoutParams lp = mFloatView.getLayoutParams();
+            if (lp == null) {
+                lp = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
+                        ViewGroup.LayoutParams.WRAP_CONTENT);
+            }
+            final int wspec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, getListPaddingLeft()
+                    + getListPaddingRight(), lp.width);
+            int hspec;
+            if (lp.height > 0) {
+                hspec = MeasureSpec.makeMeasureSpec(lp.height, MeasureSpec.EXACTLY);
+            } else {
+                hspec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+            }
+            mFloatView.measure(wspec, hspec);
+            mFloatViewHeight = mFloatView.getMeasuredHeight();
+            mFloatViewHeightHalf = mFloatViewHeight / 2;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onMeasure(final int widthMeasureSpec, final int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        if (mFloatView != null) {
+            if (mFloatView.isLayoutRequested()) {
+                measureFloatView();
+            }
+        }
+        mWidthMeasureSpec = widthMeasureSpec;
+        mDragScroller.setListHeight(getHeight());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void layoutChildren() {
+
+        if (mFloatView != null) {
+            mFloatView.layout(0, 0, mFloatView.getMeasuredWidth(), mFloatView.getMeasuredHeight());
+
+            // Log.d("mobeta", "layout children");
+            final int oldFirstExpPos = mFirstExpPos;
+            final int oldSecondExpPos = mSecondExpPos;
+
+            mBlockLayoutRequests = true;
+
+            if (getChildCount() > 0 && updatePositions()) {
+                adjustAllItems();
+            }
+
+            if (mScrollY != 0) {
+                doDragScroll(oldFirstExpPos, oldSecondExpPos);
+            }
+
+            mBlockLayoutRequests = false;
+        }
+
+        super.layoutChildren();
+    }
+
+    protected boolean onDragTouchEvent(final MotionEvent ev) {
+        switch (ev.getAction() & MotionEvent.ACTION_MASK) {
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP:
+                stopDrag(false);
+                doActionUpOrCancel();
+                break;
+            case MotionEvent.ACTION_MOVE:
+                continueDrag((int) ev.getX(), (int) ev.getY());
+                break;
+        }
+
+        return true;
+    }
+
+    /**
+     * Start a drag of item at <code>position</code> using the registered
+     * FloatViewManager. Calls through to
+     * {@link #startDrag(int, View, int, int, int)} after obtaining the floating
+     * View from the FloatViewManager.
+     *
+     * @param position  Item to drag.
+     * @param dragFlags Flags that restrict some movements of the floating View.
+     *                  For example, set <code>dragFlags |=
+     *                  ~{@link #DRAG_NEG_X}</code> to allow dragging the floating View in all
+     *                  directions except off the screen to the left.
+     * @param deltaX    Offset in x of the touch coordinate from the left edge of
+     *                  the floating View (i.e. touch-x minus float View left).
+     * @param deltaY    Offset in y of the touch coordinate from the top edge of
+     *                  the floating View (i.e. touch-y minus float View top).
+     * @return True if the drag was started, false otherwise. This
+     * <code>startDrag</code> will fail if we are not currently in a
+     * touch event, there is no registered FloatViewManager, or the
+     * FloatViewManager returns a null View.
+     */
+    public boolean startDrag(final int position, final int dragFlags, final int deltaX,
+                             final int deltaY) {
+        if (!mInTouchEvent || mFloatViewManager == null) {
+            return false;
+        }
+
+        final View v = mFloatViewManager.onCreateFloatView(position);
+
+        if (v == null) {
+            return false;
+        } else {
+            return startDrag(position, v, dragFlags, deltaX, deltaY);
+        }
+
+    }
+
+    /**
+     * Start a drag of item at <code>position</code> without using a
+     * FloatViewManager.
+     *
+     * @param position  Item to drag.
+     * @param floatView Floating View.
+     * @param dragFlags Flags that restrict some movements of the floating View.
+     *                  For example, set <code>dragFlags |=
+     *                  ~{@link #DRAG_NEG_X}</code> to allow dragging the floating View in all
+     *                  directions except off the screen to the left.
+     * @param deltaX    Offset in x of the touch coordinate from the left edge of
+     *                  the floating View (i.e. touch-x minus float View left).
+     * @param deltaY    Offset in y of the touch coordinate from the top edge of
+     *                  the floating View (i.e. touch-y minus float View top).
+     * @return True if the drag was started, false otherwise. This
+     * <code>startDrag</code> will fail if we are not currently in a
+     * touch event, <code>floatView</code> is null, or there is a drag
+     * in progress.
+     */
+    public boolean startDrag(final int position, final View floatView, final int dragFlags,
+                             final int deltaX, final int deltaY) {
+        if (!mInTouchEvent || mFloatView != null || floatView == null) {
+            return false;
+        }
+
+        if (getParent() != null) {
+            getParent().requestDisallowInterceptTouchEvent(true);
+        }
+
+        final int pos = position + getHeaderViewsCount();
+        mFirstExpPos = pos;
+        mSecondExpPos = pos;
+        mSrcPos = pos;
+        mFloatPos = pos;
+
+        // mDragState = dragType;
+        mDragState = DRAGGING;
+        mDragFlags = 0;
+        mDragFlags |= dragFlags;
+
+        mFloatView = floatView;
+        measureFloatView(); // sets mFloatViewHeight
+
+        mDragDeltaX = deltaX;
+        mDragDeltaY = deltaY;
+        updateFloatView(mX - mDragDeltaX, mY - mDragDeltaY);
+
+        // set src item invisible
+        final View srcItem = getChildAt(mSrcPos - getFirstVisiblePosition());
+        if (srcItem != null) {
+            srcItem.setVisibility(View.INVISIBLE);
+        }
+
+        if (mTrackDragSort) {
+            mDragSortTracker.startTracking();
+        }
+
+        // once float view is created, events are no longer passed
+        // to ListView
+        switch (mCancelMethod) {
+            case ON_TOUCH_EVENT:
+                super.onTouchEvent(mCancelEvent);
+                break;
+            case ON_INTERCEPT_TOUCH_EVENT:
+                super.onInterceptTouchEvent(mCancelEvent);
+                break;
+        }
+
+        requestLayout();
+
+        return true;
+    }
+
+    /**
+     * Sets float View location based on suggested values and constraints set in
+     * mDragFlags.
+     */
+    private void updateFloatView(final int floatX, final int floatY) {
+
+        // restrict x motion
+        final int padLeft = getPaddingLeft();
+        if ((mDragFlags & DRAG_POS_X) == 0 && floatX > padLeft) {
+            mFloatViewLeft = padLeft;
+        } else if ((mDragFlags & DRAG_NEG_X) == 0 && floatX < padLeft) {
+            mFloatViewLeft = padLeft;
+        } else {
+            mFloatViewLeft = floatX;
+        }
+
+        // keep floating view from going past bottom of last header view
+        final int numHeaders = getHeaderViewsCount();
+        final int numFooters = getFooterViewsCount();
+        final int firstPos = getFirstVisiblePosition();
+        final int lastPos = getLastVisiblePosition();
+
+        // Log.d("mobeta",
+        // "nHead="+numHeaders+" nFoot="+numFooters+" first="+firstPos+" last="+lastPos);
+        int topLimit = getPaddingTop();
+        if (firstPos < numHeaders) {
+            topLimit = getChildAt(numHeaders - firstPos - 1).getBottom();
+        }
+        if ((mDragFlags & DRAG_NEG_Y) == 0) {
+            if (firstPos <= mSrcPos) {
+                topLimit = Math.max(getChildAt(mSrcPos - firstPos).getTop(), topLimit);
+            }
+        }
+        // bottom limit is top of first footer View or
+        // bottom of last item in list
+        int bottomLimit = getHeight() - getPaddingBottom();
+        if (lastPos >= getCount() - numFooters - 1) {
+            bottomLimit = getChildAt(getCount() - numFooters - 1 - firstPos).getBottom();
+        }
+        if ((mDragFlags & DRAG_POS_Y) == 0) {
+            if (lastPos >= mSrcPos) {
+                bottomLimit = Math.min(getChildAt(mSrcPos - firstPos).getBottom(), bottomLimit);
+            }
+        }
+
+        // Log.d("mobeta", "dragView top=" + (y - mDragDeltaY));
+        // Log.d("mobeta", "limit=" + limit);
+        // Log.d("mobeta", "mDragDeltaY=" + mDragDeltaY);
+
+        if (floatY < topLimit) {
+            mFloatViewTop = topLimit;
+        } else if (floatY + mFloatViewHeight > bottomLimit) {
+            mFloatViewTop = bottomLimit - mFloatViewHeight;
+        } else {
+            mFloatViewTop = floatY;
+        }
+
+        // get y-midpoint of floating view (constrained to ListView bounds)
+        mFloatViewMid = mFloatViewTop + mFloatViewHeightHalf;
+    }
+
+    private void dragView(final int x, final int y) {
+        // Log.d("mobeta", "float view pure x=" + x + " y=" + y);
+
+        // proposed position
+        mFloatLoc.x = x - mDragDeltaX;
+        mFloatLoc.y = y - mDragDeltaY;
+
+        final Point touch = new Point(x, y);
+
+        // let manager adjust proposed position first
+        if (mFloatViewManager != null) {
+            mFloatViewManager.onDragFloatView(mFloatView, mFloatLoc, touch);
+        }
+
+        // then we override if manager gives an unsatisfactory
+        // position (e.g. over a header/footer view). Also,
+        // dragFlags override manager adjustments.
+        updateFloatView(mFloatLoc.x, mFloatLoc.y);
+    }
+
+    private void removeFloatView() {
+        if (mFloatView != null) {
+            mFloatView.setVisibility(GONE);
+            if (mFloatViewManager != null) {
+                mFloatViewManager.onDestroyFloatView(mFloatView);
+            }
+            mFloatView = null;
+        }
+    }
+
+    public void setFloatViewManager(final FloatViewManager manager) {
+        mFloatViewManager = manager;
+    }
+
+    public void setDragListener(final DragListener l) {
+        mDragListener = l;
+    }
+
+    public boolean isDragEnabled() {
+        return mDragEnabled;
+    }
+
+    /**
+     * Allows for easy toggling between a DragSortListView and a regular old
+     * ListView. If enabled, items are draggable, where the drag init mode
+     * determines how items are lifted (see {@link setDragInitMode(int)}). If
+     * disabled, items cannot be dragged.
+     *
+     * @param enabled Set <code>true</code> to enable list item dragging
+     */
+    public void setDragEnabled(final boolean enabled) {
+        mDragEnabled = enabled;
+    }
+
+    /**
+     * This better reorder your ListAdapter! DragSortListView does not do this
+     * for you; doesn't make sense to. Make sure
+     * {@link BaseAdapter#notifyDataSetChanged()} or something like it is called
+     * in your implementation.
+     *
+     * @param l
+     */
+    public void setDropListener(final DropListener l) {
+        mDropListener = l;
+    }
+
+    /**
+     * Probably a no-brainer, but make sure that your remove listener calls
+     * {@link BaseAdapter#notifyDataSetChanged()} or something like it. When an
+     * item removal occurs, DragSortListView relies on a redraw of all the items
+     * to recover invisible views and such. Strictly speaking, if you remove
+     * something, your dataset has changed...
+     *
+     * @param l
+     */
+    public void setRemoveListener(final RemoveListener l) {
+        if (mController != null && l == null) {
+            mController.setRemoveEnabled(false);
+        }
+        mRemoveListener = l;
+    }
+
+    public void setDragSortListener(final DragSortListener l) {
+        setDropListener(l);
+        setDragListener(l);
+        setRemoveListener(l);
+    }
+
+    /**
+     * Completely custom scroll speed profile. Default increases linearly with
+     * position and is constant in time. Create your own by implementing
+     * {@link DragSortListView.DragScrollProfile}.
+     *
+     * @param ssp
+     */
+    public void setDragScrollProfile(final DragScrollProfile ssp) {
+        if (ssp != null) {
+            mScrollProfile = ssp;
+        }
+    }
+
+    /**
+     * Interface for customization of the floating View appearance and dragging
+     * behavior. Implement your own and pass it to {@link #setFloatViewManager}.
+     * If your own is not passed, the default {@link SimpleFloatViewManager}
+     * implementation is used.
+     */
+    public interface FloatViewManager {
+        /**
+         * Return the floating View for item at <code>position</code>.
+         * DragSortListView will measure and layout this View for you, so feel
+         * free to just inflate it. You can help DSLV by setting some
+         * {@link ViewGroup.LayoutParams} on this View; otherwise it will set
+         * some for you (with a width of FILL_PARENT and a height of
+         * WRAP_CONTENT).
+         *
+         * @param position Position of item to drag (NOTE: <code>position</code>
+         *                 excludes header Views; thus, if you want to call
+         *                 {@link ListView#getChildAt(int)}, you will need to add
+         *                 {@link ListView#getHeaderViewsCount()} to the index).
+         * @return The View you wish to display as the floating View.
+         */
+        public View onCreateFloatView(int position);
+
+        /**
+         * Called whenever the floating View is dragged. Float View properties
+         * can be changed here. Also, the upcoming location of the float View
+         * can be altered by setting <code>location.x</code> and
+         * <code>location.y</code>.
+         *
+         * @param floatView The floating View.
+         * @param location  The location (top-left; relative to DSLV top-left) at
+         *                  which the float View would like to appear, given the
+         *                  current touch location and the offset provided in
+         *                  {@link DragSortListView#startDrag}.
+         * @param touch     The current touch location (relative to DSLV top-left).
+         */
+        public void onDragFloatView(View floatView, Point location, Point touch);
+
+        /**
+         * Called when the float View is dropped; lets you perform any necessary
+         * cleanup. The internal DSLV floating View reference is set to null
+         * immediately after this is called.
+         *
+         * @param floatView The floating View passed to
+         *                  {@link #onCreateFloatView(int)}.
+         */
+        public void onDestroyFloatView(View floatView);
+    }
+
+    public interface DragListener {
+        public void drag(int from, int to);
+    }
+
+    /**
+     * Your implementation of this has to reorder your ListAdapter! Make sure to
+     * call {@link BaseAdapter#notifyDataSetChanged()} or something like it in
+     * your implementation.
+     *
+     * @author heycosmo
+     */
+    public interface DropListener {
+        public void drop(int from, int to);
+    }
+
+    /**
+     * Make sure to call {@link BaseAdapter#notifyDataSetChanged()} or something
+     * like it in your implementation.
+     *
+     * @author heycosmo
+     */
+    public interface RemoveListener {
+        public void remove(int which);
+    }
+
+    public interface DragSortListener extends DropListener, DragListener, RemoveListener {
+    }
+
+    /**
+     * Interface for controlling scroll speed as a function of touch position
+     * and time. Use
+     * {@link DragSortListView#setDragScrollProfile(DragScrollProfile)} to set
+     * custom profile.
+     *
+     * @author heycosmo
+     */
+    public interface DragScrollProfile {
+        /**
+         * Return a scroll speed in pixels/millisecond. Always return a positive
+         * number.
+         *
+         * @param w Normalized position in scroll region (i.e. w \in [0,1]).
+         *          Small w typically means slow scrolling.
+         * @param t Time (in milliseconds) since start of scroll (handy if you
+         *          want scroll acceleration).
+         * @return Scroll speed at position w and time t in pixels/ms.
+         */
+        float getSpeed(float w, long t);
+    }
+
+    private class AdapterWrapper extends HeaderViewListAdapter {
+        private final ListAdapter mAdapter;
+
+        public AdapterWrapper(final ListAdapter adapter) {
+            super(null, null, adapter);
+            mAdapter = adapter;
+        }
+
+        public ListAdapter getAdapter() {
+            return mAdapter;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public View getView(final int position, final View convertView, final ViewGroup parent) {
+
+            RelativeLayout v;
+            View child;
+            if (convertView != null) {
+
+                v = (RelativeLayout) convertView;
+                final View oldChild = v.getChildAt(0);
+                try {
+                    child = mAdapter.getView(position, oldChild, v);
+                    if (child != oldChild) {
+                        v.removeViewAt(0);
+                        v.addView(child);
+                    }
+                } catch (final Exception nullz) {
+
+                }
+            } else {
+                final AbsListView.LayoutParams params = new AbsListView.LayoutParams(
+                        ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+                v = new RelativeLayout(getContext());
+                v.setLayoutParams(params);
+                try {
+                    child = mAdapter.getView(position, null, v);
+                    v.addView(child);
+                } catch (final Exception todo) {
+
+                }
+            }
+            adjustItem(position + getHeaderViewsCount(), v, true);
+            return v;
+        }
+    }
+
+    private class ItemHeights {
+        int item;
+
+        int child;
+    }
+
+    private class DragScroller implements Runnable, AbsListView.OnScrollListener {
+
+        public final static int STOP = -1;
+        public final static int UP = 0;
+        public final static int DOWN = 1;
+        private boolean mAbort;
+        private long mPrevTime;
+        private int dy;
+        private float dt;
+        private long tStart;
+        private int scrollDir;
+        private float mScrollSpeed; // pixels per ms
+
+        private boolean mScrolling = false;
+
+        private int mMaxScrollSpeed;
+
+        public DragScroller() {
+        }
+
+        public boolean isScrolling() {
+            return mScrolling;
+        }
+
+        public int getScrollDir() {
+            return mScrolling ? scrollDir : STOP;
+        }
+
+        public void startScrolling(final int dir) {
+            if (!mScrolling) {
+                // Debug.startMethodTracing("dslv-scroll");
+                mAbort = false;
+                mScrolling = true;
+                tStart = SystemClock.uptimeMillis();
+                mPrevTime = tStart;
+                scrollDir = dir;
+                post(this);
+            }
+        }
+
+        public void stopScrolling(final boolean now) {
+            if (now) {
+                removeCallbacks(this);
+                mScrolling = false;
+            } else {
+                mAbort = true;
+            }
+
+        }
+
+        public void setListHeight(final int height) {
+            // cap the max scroll speed per frame to be 1/5 of the list height
+            mMaxScrollSpeed = height / 5;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void run() {
+            if (mAbort) {
+                mScrolling = false;
+                return;
+            }
+
+            final int first = getFirstVisiblePosition();
+            final int last = getLastVisiblePosition();
+            final int count = getCount();
+            final int padTop = getPaddingTop();
+            final int listHeight = getHeight() - padTop - getPaddingBottom();
+
+            final int minY = Math.min(mY, mFloatViewMid + mFloatViewHeightHalf);
+            final int maxY = Math.max(mY, mFloatViewMid - mFloatViewHeightHalf);
+
+            if (scrollDir == UP) {
+                final View v = getChildAt(0);
+                if (v == null) {
+                    mScrolling = false;
+                    return;
+                } else {
+                    if (first == 0 && v.getTop() == padTop) {
+                        mScrolling = false;
+                        return;
+                    }
+                }
+                mScrollSpeed = mScrollProfile.getSpeed((mUpScrollStartYF - maxY)
+                        / mDragUpScrollHeight, mPrevTime);
+            } else {
+                final View v = getChildAt(last - first);
+                if (v == null) {
+                    mScrolling = false;
+                    return;
+                } else {
+                    if (last == count - 1 && v.getBottom() <= listHeight + padTop) {
+                        mScrolling = false;
+                        return;
+                    }
+                }
+                mScrollSpeed = -mScrollProfile.getSpeed((minY - mDownScrollStartYF)
+                        / mDragDownScrollHeight, mPrevTime);
+            }
+
+            dt = SystemClock.uptimeMillis() - mPrevTime;
+            // dy is change in View position of a list item; i.e. positive dy
+            // means user is scrolling up (list item moves down the screen,
+            // remember
+            // y=0 is at top of View).
+            dy = Math.round(mScrollSpeed * dt);
+            mScrollY += dy;
+
+            // cap the scroll speed
+            mScrollY = Math.max(Math.min(mScrollY, mMaxScrollSpeed), -mMaxScrollSpeed);
+
+            requestLayout();
+
+            mPrevTime += dt;
+
+            post(this);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onScroll(final AbsListView view, final int firstVisibleItem,
+                             final int visibleItemCount, final int totalItemCount) {
+            if (mScrolling && visibleItemCount != 0) {
+                dragView(mX, mY);
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onScrollStateChanged(final AbsListView view, final int scrollState) {
+        }
+
+    }
+
+    private class DragSortTracker {
+        StringBuilder mBuilder = new StringBuilder();
+
+        File mFile;
+
+        private int mNumInBuffer = 0;
+
+        private int mNumFlushes = 0;
+
+        private boolean mTracking = false;
+
+        public void startTracking() {
+            mBuilder.append("<DSLVStates>\n");
+            mNumFlushes = 0;
+            mTracking = true;
+        }
+
+        public void appendState() {
+            if (!mTracking) {
+                return;
+            }
+
+            mBuilder.append("<DSLVState>\n");
+            final int children = getChildCount();
+            final int first = getFirstVisiblePosition();
+            final ItemHeights itemHeights = new ItemHeights();
+            mBuilder.append("    <Positions>");
+            for (int i = 0; i < children; ++i) {
+                mBuilder.append(first + i).append(",");
+            }
+            mBuilder.append("</Positions>\n");
+
+            mBuilder.append("    <Tops>");
+            for (int i = 0; i < children; ++i) {
+                mBuilder.append(getChildAt(i).getTop()).append(",");
+            }
+            mBuilder.append("</Tops>\n");
+            mBuilder.append("    <Bottoms>");
+            for (int i = 0; i < children; ++i) {
+                mBuilder.append(getChildAt(i).getBottom()).append(",");
+            }
+            mBuilder.append("</Bottoms>\n");
+
+            mBuilder.append("    <FirstExpPos>").append(mFirstExpPos).append("</FirstExpPos>\n");
+            getItemHeights(mFirstExpPos, itemHeights);
+            mBuilder.append("    <FirstExpBlankHeight>")
+                    .append(itemHeights.item - itemHeights.child)
+                    .append("</FirstExpBlankHeight>\n");
+            mBuilder.append("    <SecondExpPos>").append(mSecondExpPos).append("</SecondExpPos>\n");
+            getItemHeights(mSecondExpPos, itemHeights);
+            mBuilder.append("    <SecondExpBlankHeight>")
+                    .append(itemHeights.item - itemHeights.child)
+                    .append("</SecondExpBlankHeight>\n");
+            mBuilder.append("    <SrcPos>").append(mSrcPos).append("</SrcPos>\n");
+            mBuilder.append("    <SrcHeight>").append(mFloatViewHeight + getDividerHeight())
+                    .append("</SrcHeight>\n");
+            mBuilder.append("    <ViewHeight>").append(getHeight()).append("</ViewHeight>\n");
+            mBuilder.append("    <LastY>").append(mLastY).append("</LastY>\n");
+            mBuilder.append("    <FloatY>").append(mFloatViewMid).append("</FloatY>\n");
+            mBuilder.append("    <ShuffleEdges>");
+            for (int i = 0; i < children; ++i) {
+                mBuilder.append(getShuffleEdge(first + i, getChildAt(i).getTop())).append(",");
+            }
+            mBuilder.append("</ShuffleEdges>\n");
+
+            mBuilder.append("</DSLVState>\n");
+            mNumInBuffer++;
+
+            if (mNumInBuffer > 1000) {
+                flush();
+                mNumInBuffer = 0;
+            }
+        }
+
+        public void flush() {
+            if (!mTracking) {
+                return;
+            }
+
+            // save to file on sdcard
+            try {
+                boolean append = true;
+                if (mNumFlushes == 0) {
+                    append = false;
+                }
+                final FileWriter writer = new FileWriter(mFile, append);
+
+                writer.write(mBuilder.toString());
+                mBuilder.delete(0, mBuilder.length());
+
+                writer.flush();
+                writer.close();
+
+                mNumFlushes++;
+            } catch (final IOException e) {
+                // do nothing
+            }
+        }
+
+        public void stopTracking() {
+            if (mTracking) {
+                mBuilder.append("</DSLVStates>\n");
+                flush();
+                mTracking = false;
+            }
+        }
+
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/dragdrop/SimpleFloatViewManager.java b/twelve/src/main/java/com/dolzzo/twelve/dragdrop/SimpleFloatViewManager.java
new file mode 100755
index 0000000000..31850ae29b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/dragdrop/SimpleFloatViewManager.java
@@ -0,0 +1,77 @@
+
+package com.dolzzo.twelve.dragdrop;
+
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.Point;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.ListView;
+
+/**
+ * Simple implementation of the FloatViewManager class. Uses list items as they
+ * appear in the ListView to create the floating View.
+ */
+public class SimpleFloatViewManager implements DragSortListView.FloatViewManager {
+
+    private final ListView mListView;
+
+    private Bitmap mFloatBitmap;
+
+    private int mFloatBGColor = Color.BLACK;
+
+    public SimpleFloatViewManager(ListView lv) {
+        mListView = lv;
+    }
+
+    public void setBackgroundColor(int color) {
+        mFloatBGColor = color;
+    }
+
+    /**
+     * This simple implementation creates a Bitmap copy of the list item
+     * currently shown at ListView <code>position</code>.
+     */
+    @Override
+    public View onCreateFloatView(int position) {
+        View v = mListView.getChildAt(position + mListView.getHeaderViewsCount()
+                - mListView.getFirstVisiblePosition());
+
+        if (v == null) {
+            return null;
+        }
+
+        v.setPressed(false);
+
+        v.setDrawingCacheEnabled(true);
+        mFloatBitmap = Bitmap.createBitmap(v.getDrawingCache());
+        v.setDrawingCacheEnabled(false);
+
+        ImageView iv = new ImageView(mListView.getContext());
+        iv.setBackgroundColor(mFloatBGColor);
+        iv.setPadding(0, 0, 0, 0);
+        iv.setImageBitmap(mFloatBitmap);
+
+        return iv;
+    }
+
+    /**
+     * Removes the Bitmap from the ImageView created in onCreateFloatView() and
+     * tells the system to recycle it.
+     */
+    @Override
+    public void onDestroyFloatView(View floatView) {
+        ((ImageView) floatView).setImageDrawable(null);
+
+        mFloatBitmap.recycle();
+        mFloatBitmap = null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onDragFloatView(View floatView, Point position, Point touch) {
+        /* Nothing to do */
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/format/Capitalize.java b/twelve/src/main/java/com/dolzzo/twelve/format/Capitalize.java
new file mode 100755
index 0000000000..ecd65d6be1
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/format/Capitalize.java
@@ -0,0 +1,60 @@
+
+package com.dolzzo.twelve.format;
+
+import android.text.TextUtils;
+
+public class Capitalize {
+
+    /* This class is never initiated */
+    public Capitalize() {
+    }
+
+    public static final String capitalize(String str) {
+        return capitalize(str, null);
+    }
+
+    /**
+     * Capitalizes the first character in a string
+     *
+     * @param str        The string to capitalize
+     * @param delimiters The delimiters
+     * @return A captitalized string
+     */
+    public static final String capitalize(String str, char... delimiters) {
+        final int delimLen = delimiters == null ? -1 : delimiters.length;
+        if (TextUtils.isEmpty(str) || delimLen == 0) {
+            return str;
+        }
+        final char[] buffer = str.toCharArray();
+        boolean capitalizeNext = true;
+        for (int i = 0; i < buffer.length; i++) {
+            char ch = buffer[i];
+            if (isDelimiter(ch, delimiters)) {
+                capitalizeNext = true;
+            } else if (capitalizeNext) {
+                buffer[i] = Character.toTitleCase(ch);
+                capitalizeNext = false;
+            }
+        }
+        return new String(buffer);
+    }
+
+    /**
+     * Is the character a delimiter.
+     *
+     * @param ch         the character to check
+     * @param delimiters the delimiters
+     * @return true if it is a delimiter
+     */
+    private static final boolean isDelimiter(char ch, char[] delimiters) {
+        if (delimiters == null) {
+            return Character.isWhitespace(ch);
+        }
+        for (char delimiter : delimiters) {
+            if (ch == delimiter) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/format/PrefixHighlighter.java b/twelve/src/main/java/com/dolzzo/twelve/format/PrefixHighlighter.java
new file mode 100755
index 0000000000..a607ad546f
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/format/PrefixHighlighter.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project Licensed under the Apache
+ * License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.format;
+
+import android.content.Context;
+import android.text.SpannableString;
+import android.text.TextUtils;
+import android.text.style.ForegroundColorSpan;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.utils.PreferenceUtils;
+
+/**
+ * Highlights the text in a text field.
+ */
+public class PrefixHighlighter {
+
+    /* Color used when highlighting the prefixes */
+    private final int mPrefixHighlightColor;
+
+    private ForegroundColorSpan mPrefixColorSpan;
+
+    /**
+     * @param prefixHighlightColor The color used to highlight the prefixes.
+     */
+    public PrefixHighlighter(final Context context) {
+        mPrefixHighlightColor = PreferenceUtils.getInstance(context).getDefaultThemeColor(context);
+    }
+
+    /**
+     * Sets the text on the given {@link TextView}, highlighting the word that
+     * matches the given prefix.
+     *
+     * @param view   The {@link TextView} on which to set the text
+     * @param text   The string to use as the text
+     * @param prefix The prefix to look for
+     */
+    public void setText(final TextView view, final String text, final char[] prefix) {
+        if (view == null || TextUtils.isEmpty(text) || prefix == null || prefix.length == 0) {
+            return;
+        }
+        view.setText(apply(text, prefix));
+    }
+
+    /**
+     * Returns a {@link CharSequence} which highlights the given prefix if found
+     * in the given text.
+     *
+     * @param text   the text to which to apply the highlight
+     * @param prefix the prefix to look for
+     */
+    public CharSequence apply(final CharSequence text, final char[] prefix) {
+        int mIndex = indexOfPrefix(text, prefix, true);
+        // prefer word prefix, if not search through the entire word
+        if (mIndex == -1) {
+            mIndex = indexOfPrefix(text, prefix, false);
+        }
+
+        if (mIndex != -1) {
+            if (mPrefixColorSpan == null) {
+                mPrefixColorSpan = new ForegroundColorSpan(mPrefixHighlightColor);
+            }
+            final SpannableString mResult = new SpannableString(text);
+            mResult.setSpan(mPrefixColorSpan, mIndex, mIndex + prefix.length, 0);
+            return mResult;
+        } else {
+            return text;
+        }
+    }
+
+    /**
+     * Finds the index of the first character that starts with the given prefix. If
+     * not found, returns -1.
+     *
+     * @param text     the text in which to search for the prefix
+     * @param prefix   the text to find, in upper case letters
+     * @param wordOnly only search for word prefixes if true
+     */
+    private int indexOfPrefix(final CharSequence text, final char[] prefix, boolean wordOnly) {
+        if (TextUtils.isEmpty(text) || prefix == null) {
+            return -1;
+        }
+
+        final int mTextLength = text.length();
+        final int mPrefixLength = prefix.length;
+
+        if (mPrefixLength == 0 || mTextLength < mPrefixLength) {
+            return -1;
+        }
+
+        int i = 0;
+        while (i < mTextLength) {
+            /* Skip non-word characters */
+            while (i < mTextLength && !Character.isLetterOrDigit(text.charAt(i))) {
+                i++;
+            }
+
+            if (i + mPrefixLength > mTextLength) {
+                return -1;
+            }
+
+            /* Compare the prefixes */
+            int j;
+            for (j = 0; j < mPrefixLength; j++) {
+                if (Character.toUpperCase(text.charAt(i + j)) != prefix[j]) {
+                    break;
+                }
+            }
+            if (j == mPrefixLength) {
+                return i;
+            }
+
+            if (wordOnly) {
+                /* Skip this word */
+                while (i < mTextLength && Character.isLetterOrDigit(text.charAt(i))) {
+                    i++;
+                }
+            } else {
+                i++;
+            }
+        }
+        return -1;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/AlbumLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/AlbumLoader.java
new file mode 100755
index 0000000000..c7e6e948e3
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/AlbumLoader.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.BaseColumns;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.AlbumColumns;
+
+import com.dolzzo.twelve.model.Album;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.utils.Lists;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PreferenceUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used to query {@link MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI} and return
+ * the albums on a user's device.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class AlbumLoader extends SectionCreator.SimpleListLoader<Album> {
+
+    /**
+     * Additional selection filter
+     */
+    protected Long mArtistId;
+    /**
+     * The result
+     */
+    private ArrayList<Album> mAlbumsList = Lists.newArrayList();
+    /**
+     * The {@link Cursor} used to run the query.
+     */
+    private Cursor mCursor;
+
+    /**
+     * @param context The {@link Context} to use
+     */
+    public AlbumLoader(final Context context) {
+        this(context, null);
+    }
+
+    /**
+     * @param context  The {@link Context} to use
+     * @param artistId The artistId to filter against or null if none
+     */
+    public AlbumLoader(final Context context, final Long artistId) {
+        super(context);
+
+        mArtistId = artistId;
+    }
+
+    /**
+     * Creates the {@link Cursor} used to run the query.
+     *
+     * @param context  The {@link Context} to use.
+     * @param artistId The artistId we want to find albums for or null if we want all albums
+     * @return The {@link Cursor} used to run the album query.
+     */
+    public static final Cursor makeAlbumCursor(final Context context, final Long artistId) {
+        if (MusicUtils.isPermissionGranted(context) == false) {
+            return null;
+        }
+        // requested album ordering
+        final String albumSortOrder = PreferenceUtils.getInstance(context).getAlbumSortOrder();
+        Uri uri = MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI;
+        if (artistId != null) {
+            uri = MediaStore.Audio.Artists.Albums.getContentUri("external", artistId);
+        }
+
+        Cursor cursor = context.getContentResolver().query(uri,
+                new String[]{
+                        /* 0 */
+                        BaseColumns._ID,
+                        /* 1 */
+                        AlbumColumns.ALBUM,
+                        /* 2 */
+                        AlbumColumns.ARTIST,
+                        /* 3 */
+                        AlbumColumns.NUMBER_OF_SONGS,
+                        /* 4 */
+                        AlbumColumns.FIRST_YEAR
+                }, null, null, albumSortOrder);
+
+        return cursor;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<Album> loadInBackground() {
+        // Create the Cursor
+        mCursor = makeAlbumCursor(getContext(), mArtistId);
+        // Gather the data
+        if (mCursor != null && mCursor.moveToFirst()) {
+            do {
+                // Copy the album id
+                final long id = mCursor.getLong(0);
+
+                // Copy the album name
+                final String albumName = mCursor.getString(1);
+
+                // Copy the artist name
+                final String artist = mCursor.getString(2);
+
+                // Copy the number of songs
+                final int songCount = mCursor.getInt(3);
+
+                // Copy the release year
+                final String year = mCursor.getString(4);
+
+                // as per designer's request, don't show unknown albums
+                if (MediaStore.UNKNOWN_STRING.equals(albumName)) {
+                    continue;
+                }
+
+                // Create a new album
+                final Album album = new Album(id, albumName, artist, songCount, year);
+
+                if (mCursor instanceof SortedCursor) {
+                    album.mBucketLabel = (String) ((SortedCursor) mCursor).getExtraData();
+                }
+
+                // Add everything up
+                mAlbumsList.add(album);
+            } while (mCursor.moveToNext());
+        }
+        // Close the cursor
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+
+        return mAlbumsList;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/AlbumSongLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/AlbumSongLoader.java
new file mode 100755
index 0000000000..e41514ea6e
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/AlbumSongLoader.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.provider.BaseColumns;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.AudioColumns;
+
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.utils.Lists;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PreferenceUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used to query {@link MediaStore.Audio.Media.EXTERNAL_CONTENT_URI} and return
+ * the Song for a particular album.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class AlbumSongLoader extends WrappedAsyncTaskLoader<List<Song>> {
+
+    /**
+     * The result
+     */
+    private final ArrayList<Song> mSongList = Lists.newArrayList();
+    /**
+     * The Id of the album the songs belong to.
+     */
+    private final Long mAlbumID;
+    /**
+     * The {@link Cursor} used to run the query.
+     */
+    private Cursor mCursor;
+
+    /**
+     * Constructor of <code>AlbumSongHandler</code>
+     *
+     * @param context The {@link Context} to use.
+     * @param albumId The Id of the album the songs belong to.
+     */
+    public AlbumSongLoader(final Context context, final Long albumId) {
+        super(context);
+        mAlbumID = albumId;
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @param albumId The Id of the album the songs belong to.
+     * @return The {@link Cursor} used to run the query.
+     */
+    public static final Cursor makeAlbumSongCursor(final Context context, final Long albumId) {
+        if (MusicUtils.isPermissionGranted(context) == false) {
+            return null;
+        }
+
+        // Match the songs up with the artist
+        String selection = (AudioColumns.IS_MUSIC + "=1") +
+                " AND " + AudioColumns.TITLE + " != ''" +
+                " AND " + AudioColumns.ALBUM_ID + "=" + albumId;
+        return context.getContentResolver().query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                new String[]{
+                        /* 0 */
+                        BaseColumns._ID,
+                        /* 1 */
+                        AudioColumns.TITLE,
+                        /* 2 */
+                        AudioColumns.ARTIST,
+                        /* 3 */
+                        AudioColumns.ALBUM,
+                        /* 4 */
+                        AudioColumns.DURATION,
+                        /* 5 */
+                        AudioColumns.YEAR,
+                }, selection, null,
+                PreferenceUtils.getInstance(context).getAlbumSongSortOrder());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<Song> loadInBackground() {
+        // Create the Cursor
+        mCursor = makeAlbumSongCursor(getContext(), mAlbumID);
+        // Gather the data
+        if (mCursor != null && mCursor.moveToFirst()) {
+            do {
+                // Copy the song Id
+                final long id = mCursor.getLong(0);
+
+                // Copy the song name
+                final String songName = mCursor.getString(1);
+
+                // Copy the artist name
+                final String artist = mCursor.getString(2);
+
+                // Copy the album name
+                final String album = mCursor.getString(3);
+
+                // Copy the duration
+                final long duration = mCursor.getLong(4);
+
+                // Make the duration label
+                final int seconds = (int) (duration / 1000);
+
+                // Grab the Song Year
+                final int year = mCursor.getInt(5);
+
+                // Create a new song
+                final Song song = new Song(id, songName, artist, album, mAlbumID, seconds, year);
+
+                // Add everything up
+                mSongList.add(song);
+            } while (mCursor.moveToNext());
+        }
+        // Close the cursor
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        return mSongList;
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/ArtistLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/ArtistLoader.java
new file mode 100755
index 0000000000..87c668d80a
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/ArtistLoader.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.Artists;
+
+import com.dolzzo.twelve.model.Artist;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.utils.Lists;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PreferenceUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used to query {@link MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI} and
+ * return the artists on a user's device.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class ArtistLoader extends SectionCreator.SimpleListLoader<Artist> {
+
+    /**
+     * The result
+     */
+    private ArrayList<Artist> mArtistsList = Lists.newArrayList();
+
+    /**
+     * The {@link Cursor} used to run the query.
+     */
+    private Cursor mCursor;
+
+    /**
+     * Constructor of <code>ArtistLoader</code>
+     *
+     * @param context The {@link Context} to use
+     */
+    public ArtistLoader(final Context context) {
+        super(context);
+    }
+
+    /**
+     * Creates the {@link Cursor} used to run the query.
+     *
+     * @param context The {@link Context} to use.
+     * @return The {@link Cursor} used to run the artist query.
+     */
+    public static final Cursor makeArtistCursor(final Context context) {
+        if (MusicUtils.isPermissionGranted(context)  == false) {
+            return null;
+        }
+
+        // requested artist ordering
+        final String artistSortOrder = PreferenceUtils.getInstance(context).getArtistSortOrder();
+
+        Cursor cursor = context.getContentResolver().query(Artists.EXTERNAL_CONTENT_URI,
+                new String[]{
+                        /* 0 */
+                        Artists._ID,
+                        /* 1 */
+                        Artists.ARTIST,
+                        /* 2 */
+                        Artists.NUMBER_OF_ALBUMS,
+                        /* 3 */
+                        Artists.NUMBER_OF_TRACKS
+                }, null, null, artistSortOrder);
+
+        return cursor;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<Artist> loadInBackground() {
+        // Create the Cursor
+        mCursor = makeArtistCursor(getContext());
+        // Gather the data
+        if (mCursor != null && mCursor.moveToFirst()) {
+            do {
+                // Copy the artist id
+                final long id = mCursor.getLong(0);
+
+                // Copy the artist name
+                final String artistName = mCursor.getString(1);
+
+                // Copy the number of albums
+                final int albumCount = mCursor.getInt(2);
+
+                // Copy the number of songs
+                final int songCount = mCursor.getInt(3);
+
+                // as per designer's request, don't show unknown artist
+                if (MediaStore.UNKNOWN_STRING.equals(artistName)) {
+                    continue;
+                }
+
+                // Create a new artist
+                final Artist artist = new Artist(id, artistName, songCount, albumCount);
+
+                if (mCursor instanceof SortedCursor) {
+                    artist.mBucketLabel = (String) ((SortedCursor) mCursor).getExtraData();
+                }
+
+                mArtistsList.add(artist);
+            } while (mCursor.moveToNext());
+        }
+        // Close the cursor
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+
+        return mArtistsList;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/AsyncHandler.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/AsyncHandler.java
new file mode 100755
index 0000000000..78ca9634ef
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/AsyncHandler.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project Licensed under the Apache
+ * License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.os.Handler;
+import android.os.HandlerThread;
+
+/**
+ * Helper class for managing the background thread used to perform io operations
+ * and handle async broadcasts.
+ */
+public final class AsyncHandler {
+
+    private static final HandlerThread sHandlerThread = new HandlerThread("AsyncHandler");
+
+    private static final Handler sHandler;
+
+    static {
+        sHandlerThread.start();
+        sHandler = new Handler(sHandlerThread.getLooper());
+    }
+
+    /* This class is never initiated */
+    private AsyncHandler() {
+    }
+
+    /**
+     * @param r The {@link Runnable} to execute.
+     */
+    public static void post(final Runnable r) {
+        sHandler.post(r);
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/LastAddedLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/LastAddedLoader.java
new file mode 100755
index 0000000000..ed420af934
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/LastAddedLoader.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.provider.BaseColumns;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.AudioColumns;
+
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.utils.Lists;
+import com.dolzzo.twelve.utils.PreferenceUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used to query {@link MediaStore.Audio.Media.EXTERNAL_CONTENT_URI} and return
+ * the Song the user added over the past four of weeks.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class LastAddedLoader extends SectionCreator.SimpleListLoader<Song> {
+    /**
+     * The result
+     */
+    private final ArrayList<Song> mSongList = Lists.newArrayList();
+
+    /**
+     * The {@link Cursor} used to run the query.
+     */
+    private Cursor mCursor;
+
+    /**
+     * Constructor of <code>LastAddedHandler</code>
+     *
+     * @param context The {@link Context} to use.
+     */
+    public LastAddedLoader(final Context context) {
+        super(context);
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @return The {@link Cursor} used to run the song query.
+     */
+    public static final Cursor makeLastAddedCursor(final Context context) {
+        // timestamp of four weeks ago
+        long fourWeeksAgo = (System.currentTimeMillis() / 1000) - (4 * 3600 * 24 * 7);
+        // possible saved timestamp caused by user "clearing" the last added playlist
+        long cutoff = PreferenceUtils.getInstance(context).getLastAddedCutoff() / 1000;
+        // use the most recent of the two timestamps
+        if (cutoff < fourWeeksAgo) {
+            cutoff = fourWeeksAgo;
+        }
+
+        String selection = (AudioColumns.IS_MUSIC + "=1") +
+                " AND " + AudioColumns.TITLE + " != ''" +
+                " AND " + MediaStore.Audio.Media.DATE_ADDED + ">" +
+                cutoff;
+
+        return context.getContentResolver().query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                new String[]{
+                        /* 0 */
+                        BaseColumns._ID,
+                        /* 1 */
+                        AudioColumns.TITLE,
+                        /* 2 */
+                        AudioColumns.ARTIST,
+                        /* 3 */
+                        AudioColumns.ALBUM_ID,
+                        /* 4 */
+                        AudioColumns.ALBUM,
+                        /* 5 */
+                        AudioColumns.DURATION,
+                        /* 6 */
+                        AudioColumns.YEAR,
+                }, selection, null, MediaStore.Audio.Media.DATE_ADDED + " DESC");
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<Song> loadInBackground() {
+        // Create the xCursor
+        mCursor = makeLastAddedCursor(getContext());
+        // Gather the data
+        if (mCursor != null && mCursor.moveToFirst()) {
+            do {
+                // Copy the song Id
+                final long id = mCursor.getLong(0);
+
+                // Copy the song name
+                final String songName = mCursor.getString(1);
+
+                // Copy the artist name
+                final String artist = mCursor.getString(2);
+
+                // Copy the album id
+                final long albumId = mCursor.getLong(3);
+
+                // Copy the album name
+                final String album = mCursor.getString(4);
+
+                // Copy the duration
+                final long duration = mCursor.getLong(5);
+
+                // Convert the duration into seconds
+                final int durationInSecs = (int) duration / 1000;
+
+                // Grab the Song Year
+                final int year = mCursor.getInt(6);
+
+                // Create a new song
+                final Song song = new Song(id, songName, artist, album, albumId, durationInSecs, year);
+
+                // Add everything up
+                mSongList.add(song);
+            } while (mCursor.moveToNext());
+        }
+        // Close the cursor
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        return mSongList;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/NowPlayingCursor.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/NowPlayingCursor.java
new file mode 100755
index 0000000000..ad68dc1095
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/NowPlayingCursor.java
@@ -0,0 +1,296 @@
+
+package com.dolzzo.twelve.loaders;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.database.AbstractCursor;
+import android.database.Cursor;
+import android.os.RemoteException;
+import android.provider.BaseColumns;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.AudioColumns;
+
+import com.dolzzo.twelve.utils.MusicUtils;
+
+import java.util.Arrays;
+
+import static com.dolzzo.twelve.utils.MusicUtils.mService;
+
+/**
+ * A custom {@link Cursor} used to return the queue and allow for easy dragging
+ * and dropping of the items in it.
+ */
+@SuppressLint("NewApi")
+public class NowPlayingCursor extends AbstractCursor {
+
+    private static final String[] PROJECTION = new String[]{
+            /* 0 */
+            BaseColumns._ID,
+            /* 1 */
+            AudioColumns.TITLE,
+            /* 2 */
+            AudioColumns.ARTIST,
+            /* 3 */
+            AudioColumns.ALBUM_ID,
+            /* 4 */
+            AudioColumns.ALBUM,
+            /* 5 */
+            AudioColumns.DURATION,
+            /* 6 */
+            AudioColumns.YEAR,
+    };
+
+    private final Context mContext;
+
+    private long[] mNowPlaying;
+
+    private long[] mCursorIndexes;
+
+    private int mSize;
+
+    private int mCurPos;
+
+    private Cursor mQueueCursor;
+
+    /**
+     * Constructor of <code>NowPlayingCursor</code>
+     *
+     * @param context The {@link Context} to use
+     */
+    public NowPlayingCursor(final Context context) {
+        mContext = context;
+        makeNowPlayingCursor();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getCount() {
+        return mSize;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onMove(final int oldPosition, final int newPosition) {
+        if (oldPosition == newPosition) {
+            return true;
+        }
+
+        if (mNowPlaying == null || mCursorIndexes == null || newPosition >= mNowPlaying.length) {
+            return false;
+        }
+
+        final long id = mNowPlaying[newPosition];
+        final int cursorIndex = Arrays.binarySearch(mCursorIndexes, id);
+        mQueueCursor.moveToPosition(cursorIndex);
+        mCurPos = newPosition;
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String getString(final int column) {
+        try {
+            return mQueueCursor.getString(column);
+        } catch (final Exception ignored) {
+            onChange(true);
+            return "";
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public short getShort(final int column) {
+        return mQueueCursor.getShort(column);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getInt(final int column) {
+        try {
+            return mQueueCursor.getInt(column);
+        } catch (final Exception ignored) {
+            onChange(true);
+            return 0;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public long getLong(final int column) {
+        try {
+            return mQueueCursor.getLong(column);
+        } catch (final Exception ignored) {
+            onChange(true);
+            return 0;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public float getFloat(final int column) {
+        return mQueueCursor.getFloat(column);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public double getDouble(final int column) {
+        return mQueueCursor.getDouble(column);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getType(final int column) {
+        return mQueueCursor.getType(column);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isNull(final int column) {
+        return mQueueCursor.isNull(column);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String[] getColumnNames() {
+        return PROJECTION;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @SuppressWarnings("deprecation")
+    @Override
+    public void deactivate() {
+        if (mQueueCursor != null) {
+            mQueueCursor.deactivate();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean requery() {
+        makeNowPlayingCursor();
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void close() {
+        try {
+            if (mQueueCursor != null) {
+                mQueueCursor.close();
+                mQueueCursor = null;
+            }
+        } catch (final Exception close) {
+        }
+        super.close();
+    }
+
+    ;
+
+    /**
+     * Actually makes the queue
+     */
+    private void makeNowPlayingCursor() {
+        mQueueCursor = null;
+        mNowPlaying = MusicUtils.getQueue();
+        mSize = mNowPlaying.length;
+        if (mSize == 0) {
+            return;
+        }
+
+        final StringBuilder selection = new StringBuilder();
+        selection.append(MediaStore.Audio.Media._ID + " IN (");
+        for (int i = 0; i < mSize; i++) {
+            selection.append(mNowPlaying[i]);
+            if (i < mSize - 1) {
+                selection.append(",");
+            }
+        }
+        selection.append(")");
+
+        mQueueCursor = mContext.getContentResolver().query(
+                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, PROJECTION, selection.toString(),
+                null, MediaStore.Audio.Media._ID);
+
+        if (mQueueCursor == null) {
+            mSize = 0;
+            return;
+        }
+
+        final int playlistSize = mQueueCursor.getCount();
+        mCursorIndexes = new long[playlistSize];
+        mQueueCursor.moveToFirst();
+        final int columnIndex = mQueueCursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID);
+        for (int i = 0; i < playlistSize; i++) {
+            mCursorIndexes[i] = mQueueCursor.getLong(columnIndex);
+            mQueueCursor.moveToNext();
+        }
+        mQueueCursor.moveToFirst();
+        mCurPos = -1;
+
+        int removed = 0;
+        for (int i = mNowPlaying.length - 1; i >= 0; i--) {
+            final long trackId = mNowPlaying[i];
+            final int cursorIndex = Arrays.binarySearch(mCursorIndexes, trackId);
+            if (cursorIndex < 0) {
+                removed += MusicUtils.removeTrack(trackId);
+            }
+        }
+        if (removed > 0) {
+            mNowPlaying = MusicUtils.getQueue();
+            mSize = mNowPlaying.length;
+            if (mSize == 0) {
+                mCursorIndexes = null;
+                return;
+            }
+        }
+    }
+
+    /**
+     * @param which The position to remove
+     * @return True if sucessfull, false othersise
+     */
+    public boolean removeItem(final int which) {
+        try {
+            if (mService.removeTracks(which, which) == 0) {
+                return false;
+            }
+            int i = which;
+            mSize--;
+            while (i < mSize) {
+                mNowPlaying[i] = mNowPlaying[i + 1];
+                i++;
+            }
+            onMove(-1, mCurPos);
+        } catch (final RemoteException ignored) {
+        }
+        return true;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/PlaylistLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/PlaylistLoader.java
new file mode 100755
index 0000000000..5846ca48c7
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/PlaylistLoader.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.database.Cursor;
+import android.provider.BaseColumns;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.PlaylistsColumns;
+
+import com.dolzzo.twelve.Config.SmartPlaylistType;
+import com.dolzzo.twelve.model.Playlist;
+import com.dolzzo.twelve.utils.Lists;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used to query {@link MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI} and
+ * return the playlists on a user's device.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class PlaylistLoader extends WrappedAsyncTaskLoader<List<Playlist>> {
+
+    /**
+     * The result
+     */
+    private final ArrayList<Playlist> mPlaylistList = Lists.newArrayList();
+
+    /**
+     * The {@link Cursor} used to run the query.
+     */
+    private Cursor mCursor;
+
+    /**
+     * Constructor of <code>PlaylistLoader</code>
+     *
+     * @param context The {@link Context} to use
+     */
+    public PlaylistLoader(final Context context) {
+        super(context);
+    }
+
+    /**
+     * Creates the {@link Cursor} used to run the query.
+     *
+     * @param context The {@link Context} to use.
+     * @return The {@link Cursor} used to run the playlist query.
+     */
+    public static final Cursor makePlaylistCursor(final Context context) {
+        if (MusicUtils.isPermissionGranted(context) == false) {
+            return null;
+        }
+
+        return context.getContentResolver().query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
+                new String[]{
+                        /* 0 */
+                        BaseColumns._ID,
+                        /* 1 */
+                        PlaylistsColumns.NAME
+                }, null, null, MediaStore.Audio.Playlists.DEFAULT_SORT_ORDER);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<Playlist> loadInBackground() {
+        // Add the deafult playlits to the adapter
+        makeDefaultPlaylists();
+
+        // Create the Cursor
+        mCursor = makePlaylistCursor(getContext());
+        // Gather the data
+        if (mCursor != null && mCursor.moveToFirst()) {
+            do {
+                // Copy the playlist id
+                final long id = mCursor.getLong(0);
+
+                // Copy the playlist name
+                final String name = mCursor.getString(1);
+
+                final int songCount = MusicUtils.getSongCountForPlaylist(getContext(), id);
+
+                // Create a new playlist
+                final Playlist playlist = new Playlist(id, name, songCount);
+
+                // Add everything up
+                mPlaylistList.add(playlist);
+            } while (mCursor.moveToNext());
+        }
+        // Close the cursor
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        return mPlaylistList;
+    }
+
+    /* Adds the favorites and last added playlists */
+    private void makeDefaultPlaylists() {
+        final Resources resources = getContext().getResources();
+
+        /* Last added list */
+        final Playlist lastAdded = new Playlist(SmartPlaylistType.LastAdded.mId,
+                resources.getString(SmartPlaylistType.LastAdded.mTitleId), -1);
+        mPlaylistList.add(lastAdded);
+
+        /* Recently Played */
+        final Playlist recentlyPlayed = new Playlist(SmartPlaylistType.RecentlyPlayed.mId,
+                resources.getString(SmartPlaylistType.RecentlyPlayed.mTitleId), -1);
+        mPlaylistList.add(recentlyPlayed);
+
+        /* Top Tracks */
+        final Playlist topTracks = new Playlist(SmartPlaylistType.TopTracks.mId,
+                resources.getString(SmartPlaylistType.TopTracks.mTitleId), -1);
+        mPlaylistList.add(topTracks);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/PlaylistSongLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/PlaylistSongLoader.java
new file mode 100755
index 0000000000..29ab6a6172
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/PlaylistSongLoader.java
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.ContentProviderOperation;
+import android.content.Context;
+import android.content.OperationApplicationException;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.RemoteException;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.AudioColumns;
+import android.provider.MediaStore.Audio.Playlists;
+import android.util.Log;
+
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.utils.Lists;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used to query {@link MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI} and
+ * return the songs for a particular playlist.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class PlaylistSongLoader extends WrappedAsyncTaskLoader<List<Song>> {
+    private static final String TAG = PlaylistSongLoader.class.getSimpleName();
+
+    /**
+     * The result
+     */
+    private final ArrayList<Song> mSongList = Lists.newArrayList();
+    /**
+     * The Id of the playlist the songs belong to.
+     */
+    private final long mPlaylistID;
+    /**
+     * The {@link Cursor} used to run the query.
+     */
+    private Cursor mCursor;
+
+    /**
+     * Constructor of <code>SongLoader</code>
+     *
+     * @param context    The {@link Context} to use
+     * @param playlistId The Id of the playlist the songs belong to.
+     */
+    public PlaylistSongLoader(final Context context, final long playlistId) {
+        super(context);
+        mPlaylistID = playlistId;
+    }
+
+    /**
+     * Cleans up the playlist based on the passed in cursor's data
+     *
+     * @param context    The {@link Context} to use
+     * @param playlistId playlistId to clean up
+     * @param cursor     data to repopulate the playlist with
+     */
+    private static void cleanupPlaylist(final Context context, final long playlistId,
+                                        final Cursor cursor) {
+        Log.w(TAG, "Cleaning up playlist: " + playlistId);
+
+        final int idCol = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.Members.AUDIO_ID);
+        final Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
+
+        ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();
+
+        // Delete all results in the playlist
+        ops.add(ContentProviderOperation.newDelete(uri).build());
+
+        // yield the db every 100 records to prevent ANRs
+        final int YIELD_FREQUENCY = 100;
+
+        // for each item, reset the play order position
+        if (cursor.moveToFirst() && cursor.getCount() > 0) {
+            do {
+                final ContentProviderOperation.Builder builder =
+                        ContentProviderOperation.newInsert(uri)
+                                .withValue(Playlists.Members.PLAY_ORDER, cursor.getPosition())
+                                .withValue(Playlists.Members.AUDIO_ID, cursor.getLong(idCol));
+
+                // yield at the end and not at 0 by incrementing by 1
+                if ((cursor.getPosition() + 1) % YIELD_FREQUENCY == 0) {
+                    builder.withYieldAllowed(true);
+                }
+                ops.add(builder.build());
+            } while (cursor.moveToNext());
+        }
+
+        try {
+            // run the batch operation
+            context.getContentResolver().applyBatch(MediaStore.AUTHORITY, ops);
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException " + e + " while cleaning up playlist " + playlistId);
+        } catch (OperationApplicationException e) {
+            Log.e(TAG, "OperationApplicationException " + e + " while cleaning up playlist "
+                    + playlistId);
+        }
+    }
+
+    /**
+     * Returns the playlist count for the raw playlist mapping table
+     *
+     * @param context    The {@link Context} to use
+     * @param playlistId playlistId to count
+     * @return the number of tracks in the raw playlist mapping table
+     */
+    private static int countPlaylist(final Context context, final long playlistId) {
+        Cursor c = null;
+        try {
+            // when we query using only the audio_id column we will get the raw mapping table
+            // results - which will tell us if the table has rows that don't exist in the normal
+            // table
+            c = context.getContentResolver().query(
+                    MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId),
+                    new String[]{
+                            MediaStore.Audio.Playlists.Members.AUDIO_ID,
+                    }, null, null,
+                    MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);
+
+            if (c != null) {
+                return c.getCount();
+            }
+        } finally {
+            if (c != null) {
+                c.close();
+                c = null;
+            }
+        }
+
+        return 0;
+    }
+
+    /**
+     * Creates the {@link Cursor} used to run the query.
+     *
+     * @param context    The {@link Context} to use.
+     * @param playlistID The playlist the songs belong to.
+     * @return The {@link Cursor} used to run the song query.
+     */
+    public static final Cursor makePlaylistSongCursor(final Context context, final Long playlistID) {
+        String mSelection = (AudioColumns.IS_MUSIC + "=1") +
+                " AND " + AudioColumns.TITLE + " != ''";
+        return context.getContentResolver().query(
+                MediaStore.Audio.Playlists.Members.getContentUri("external", playlistID),
+                new String[]{
+                        /* 0 */
+                        MediaStore.Audio.Playlists.Members._ID,
+                        /* 1 */
+                        MediaStore.Audio.Playlists.Members.AUDIO_ID,
+                        /* 2 */
+                        AudioColumns.TITLE,
+                        /* 3 */
+                        AudioColumns.ARTIST,
+                        /* 4 */
+                        AudioColumns.ALBUM_ID,
+                        /* 5 */
+                        AudioColumns.ALBUM,
+                        /* 6 */
+                        AudioColumns.DURATION,
+                        /* 7 */
+                        AudioColumns.YEAR,
+                        /* 8 */
+                        Playlists.Members.PLAY_ORDER,
+                }, mSelection, null,
+                MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<Song> loadInBackground() {
+        final int playlistCount = countPlaylist(getContext(), mPlaylistID);
+
+        // Create the Cursor
+        mCursor = makePlaylistSongCursor(getContext(), mPlaylistID);
+
+        if (mCursor != null) {
+            boolean runCleanup = false;
+
+            // if the raw playlist count differs from the mapped playlist count (ie the raw mapping
+            // table vs the mapping table join the audio table) that means the playlist mapping table
+            // is messed up
+            if (mCursor.getCount() != playlistCount) {
+                Log.w(TAG, "Count Differs - raw is: " + playlistCount + " while cursor is " +
+                        mCursor.getCount());
+
+                runCleanup = true;
+            }
+
+            // check if the play order is already messed up by duplicates
+            if (!runCleanup && mCursor.moveToFirst()) {
+                final int playOrderCol = mCursor.getColumnIndexOrThrow(Playlists.Members.PLAY_ORDER);
+
+                int lastPlayOrder = -1;
+                do {
+                    int playOrder = mCursor.getInt(playOrderCol);
+                    // if we have duplicate play orders, we need to recreate the playlist
+                    if (playOrder == lastPlayOrder) {
+                        runCleanup = true;
+                        break;
+                    }
+                    lastPlayOrder = playOrder;
+                } while (mCursor.moveToNext());
+            }
+
+            if (runCleanup) {
+                Log.w(TAG, "Playlist order has flaws - recreating playlist");
+
+                // cleanup the playlist
+                cleanupPlaylist(getContext(), mPlaylistID, mCursor);
+
+                // create a new cursor
+                mCursor.close();
+                mCursor = makePlaylistSongCursor(getContext(), mPlaylistID);
+                if (mCursor != null) {
+                    Log.d(TAG, "New Count is: " + mCursor.getCount());
+                }
+            }
+        }
+
+        // Gather the data
+        if (mCursor != null && mCursor.moveToFirst()) {
+            do {
+                // Copy the song Id
+                final long id = mCursor.getLong(mCursor
+                        .getColumnIndexOrThrow(MediaStore.Audio.Playlists.Members.AUDIO_ID));
+
+                // Copy the song name
+                final String songName = mCursor.getString(mCursor
+                        .getColumnIndexOrThrow(AudioColumns.TITLE));
+
+                // Copy the artist name
+                final String artist = mCursor.getString(mCursor
+                        .getColumnIndexOrThrow(AudioColumns.ARTIST));
+
+                // Copy the album id
+                final long albumId = mCursor.getLong(mCursor
+                        .getColumnIndexOrThrow(AudioColumns.ALBUM_ID));
+
+                // Copy the album name
+                final String album = mCursor.getString(mCursor
+                        .getColumnIndexOrThrow(AudioColumns.ALBUM));
+
+                // Copy the duration
+                final long duration = mCursor.getLong(mCursor
+                        .getColumnIndexOrThrow(AudioColumns.DURATION));
+
+                // Convert the duration into seconds
+                final int durationInSecs = (int) duration / 1000;
+
+                // Grab the Song Year
+                final int year = mCursor.getInt(mCursor
+                        .getColumnIndexOrThrow(AudioColumns.YEAR));
+
+                // Create a new song
+                final Song song = new Song(id, songName, artist, album, albumId, durationInSecs, year);
+
+                // Add everything up
+                mSongList.add(song);
+            } while (mCursor.moveToNext());
+        }
+        // Close the cursor
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        return mSongList;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/QueueLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/QueueLoader.java
new file mode 100755
index 0000000000..4711ade34b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/QueueLoader.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.database.Cursor;
+
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.utils.Lists;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used to return the current playlist or queue.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class QueueLoader extends WrappedAsyncTaskLoader<List<Song>> {
+
+    /**
+     * The result
+     */
+    private final ArrayList<Song> mSongList = Lists.newArrayList();
+
+    /**
+     * The {@link Cursor} used to run the query.
+     */
+    private NowPlayingCursor mCursor;
+
+    /**
+     * Constructor of <code>QueueLoader</code>
+     *
+     * @param context The {@link Context} to use
+     */
+    public QueueLoader(final Context context) {
+        super(context);
+    }
+
+    /**
+     * Creates the {@link Cursor} used to run the query.
+     *
+     * @param context The {@link Context} to use.
+     * @return The {@link Cursor} used to run the song query.
+     */
+    public static final Cursor makeQueueCursor(final Context context) {
+        return new NowPlayingCursor(context);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<Song> loadInBackground() {
+        // Create the Cursor
+        mCursor = new NowPlayingCursor(getContext());
+        // Gather the data
+        if (mCursor != null && mCursor.moveToFirst()) {
+            do {
+                // Copy the song Id
+                final long id = mCursor.getLong(0);
+
+                // Copy the song name
+                final String songName = mCursor.getString(1);
+
+                // Copy the artist name
+                final String artist = mCursor.getString(2);
+
+                // Copy the album id
+                final long albumId = mCursor.getLong(3);
+
+                // Copy the album name
+                final String album = mCursor.getString(4);
+
+                // Copy the duration
+                final long duration = mCursor.getLong(5);
+
+                // Convert the duration into seconds
+                final int durationInSecs = (int) duration / 1000;
+
+                // Copy the year
+                final int year = mCursor.getInt(6);
+
+                // Create a new song
+                final Song song = new Song(id, songName, artist, album, albumId, durationInSecs, year);
+
+                // Add everything up
+                mSongList.add(song);
+            } while (mCursor.moveToNext());
+        }
+        // Close the cursor
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        return mSongList;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/SearchLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/SearchLoader.java
new file mode 100755
index 0000000000..fb39b83fcf
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/SearchLoader.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.BaseColumns;
+import android.provider.MediaStore;
+import android.text.TextUtils;
+
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.utils.Lists;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class SearchLoader extends WrappedAsyncTaskLoader<List<Song>> {
+
+    /**
+     * The result
+     */
+    private final ArrayList<Song> mSongList = Lists.newArrayList();
+
+    /**
+     * The {@link Cursor} used to run the query.
+     */
+    private Cursor mCursor;
+
+    /**
+     * Constructor of <code>SongLoader</code>
+     *
+     * @param context The {@link Context} to use
+     * @param query   The search query
+     */
+    public SearchLoader(final Context context, final String query) {
+        super(context);
+        // Create the Cursor
+        mCursor = makeSearchCursor(context, query);
+    }
+
+    /**
+     * * @param context The {@link Context} to use.
+     *
+     * @param query The user's query.
+     * @return The {@link Cursor} used to perform the search.
+     */
+    public static final Cursor makeSearchCursor(final Context context, final String query) {
+        return context.getContentResolver().query(
+                Uri.parse("content://media/external/audio/search/fancy/" + Uri.encode(query)),
+                new String[]{
+                        BaseColumns._ID, MediaStore.Audio.Media.MIME_TYPE,
+                        MediaStore.Audio.Artists.ARTIST, MediaStore.Audio.Albums.ALBUM_ID,
+                        MediaStore.Audio.Albums.ALBUM, MediaStore.Audio.Media.TITLE, "data1", "data2" //$NON-NLS-2$
+                }, null, null, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<Song> loadInBackground() {
+        // Gather the data
+        if (mCursor != null && mCursor.moveToFirst()) {
+            do {
+                // Copy the song Id
+                long id = -1;
+
+                // Copy the song name
+                final String songName = mCursor.getString(mCursor
+                        .getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE));
+
+                // Check for a song Id
+                if (!TextUtils.isEmpty(songName)) {
+                    id = mCursor.getLong(mCursor
+                            .getColumnIndexOrThrow(MediaStore.Audio.Media._ID));
+                }
+
+                // Copy the album name
+                final String album = mCursor.getString(mCursor
+                        .getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));
+
+                // Copy the album id
+                final long albumId = mCursor.getLong(mCursor
+                        .getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM_ID));
+
+                // Check for a album Id
+                if (id < 0 && !TextUtils.isEmpty(album)) {
+                    id = mCursor.getLong(mCursor
+                            .getColumnIndexOrThrow(MediaStore.Audio.Albums._ID));
+                }
+
+                // Copy the artist name
+                final String artist = mCursor.getString(mCursor
+                        .getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));
+
+                // Check for a artist Id
+                if (id < 0 && !TextUtils.isEmpty(artist)) {
+                    id = mCursor.getLong(mCursor
+                            .getColumnIndexOrThrow(MediaStore.Audio.Artists._ID));
+                }
+
+                // Create a new song
+                final Song song = new Song(id, songName, artist, album, albumId, -1, -1);
+
+                // Add everything up
+                mSongList.add(song);
+            } while (mCursor.moveToNext());
+        }
+        // Close the cursor
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+        return mSongList;
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/SongLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/SongLoader.java
new file mode 100755
index 0000000000..a0fb384ea6
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/SongLoader.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio;
+import android.text.TextUtils;
+
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.utils.Lists;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PreferenceUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used to query {@link MediaStore.Audio.Media.EXTERNAL_CONTENT_URI} and return
+ * the songs on a user's device.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class SongLoader extends SectionCreator.SimpleListLoader<Song> {
+
+    /**
+     * The result
+     */
+    protected ArrayList<Song> mSongList = Lists.newArrayList();
+
+    /**
+     * The {@link Cursor} used to run the query.
+     */
+    protected Cursor mCursor;
+
+    /**
+     * Additional selection filter
+     */
+    protected String mSelection;
+
+    /**
+     * @param context The {@link Context} to use
+     */
+    public SongLoader(final Context context) {
+        this(context, null);
+    }
+
+    /**
+     * @param context   The {@link Context} to use
+     * @param selection Additional selection filter to apply to the loader
+     */
+    public SongLoader(final Context context, final String selection) {
+        super(context);
+
+        mSelection = selection;
+    }
+
+    /**
+     * Creates the {@link Cursor} used to run the query.
+     *
+     * @param context   The {@link Context} to use.
+     * @param selection Additional selection statement to use
+     * @return The {@link Cursor} used to run the song query.
+     */
+    public static final Cursor makeSongCursor(final Context context, final String selection) {
+        return makeSongCursor(context, selection, true);
+    }
+
+    /**
+     * Creates the {@link Cursor} used to run the query.
+     *
+     * @param context   The {@link Context} to use.
+     * @param selection Additional selection statement to use
+     * @param runSort   For localized sorts this can enable/disable the logic for running the
+     *                  additional localization sort.  Queries that apply their own sorts can pass
+     *                  in false for a boost in perf
+     * @return The {@link Cursor} used to run the song query.
+     */
+    public static final Cursor makeSongCursor(final Context context, final String selection,
+                                              final boolean runSort) {
+        if (MusicUtils.isPermissionGranted(context) == false) {
+            return null;
+        }
+
+        String selectionStatement = MusicUtils.MUSIC_ONLY_SELECTION;
+        if (!TextUtils.isEmpty(selection)) {
+            selectionStatement += " AND " + selection;
+        }
+
+        final String songSortOrder = PreferenceUtils.getInstance(context).getSongSortOrder();
+
+        Cursor cursor = context.getContentResolver().query(Audio.Media.EXTERNAL_CONTENT_URI,
+                new String[]{
+                        /* 0 */
+                        Audio.Media._ID,
+                        /* 1 */
+                        Audio.Media.TITLE,
+                        /* 2 */
+                        Audio.Media.ARTIST,
+                        /* 3 */
+                        Audio.Media.ALBUM_ID,
+                        /* 4 */
+                        Audio.Media.ALBUM,
+                        /* 5 */
+                        Audio.Media.DURATION,
+                        /* 6 */
+                        Audio.Media.YEAR,
+                }, selectionStatement, null, songSortOrder);
+
+        return cursor;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public List<Song> loadInBackground() {
+        // Create the Cursor
+        mCursor = getCursor();
+
+        // Gather the data
+        if (mCursor != null && mCursor.moveToFirst()) {
+            do {
+                // Copy the song Id
+                final long id = mCursor.getLong(0);
+
+                // Copy the song name
+                final String songName = mCursor.getString(1);
+
+                // Copy the artist name
+                final String artist = mCursor.getString(2);
+
+                // Copy the album id
+                final long albumId = mCursor.getLong(3);
+
+                // Copy the album name
+                final String album = mCursor.getString(4);
+
+                // Copy the duration
+                final long duration = mCursor.getLong(5);
+
+                // Convert the duration into seconds
+                final int durationInSecs = (int) duration / 1000;
+
+                // Copy the Year
+                final int year = mCursor.getInt(6);
+
+                // Create a new song
+                final Song song = new Song(id, songName, artist, album, albumId,
+                        durationInSecs, year);
+
+                if (mCursor instanceof SortedCursor) {
+                    song.mBucketLabel = (String) ((SortedCursor) mCursor).getExtraData();
+                }
+
+                mSongList.add(song);
+            } while (mCursor.moveToNext());
+        }
+        // Close the cursor
+        if (mCursor != null) {
+            mCursor.close();
+            mCursor = null;
+        }
+
+        return mSongList;
+    }
+
+    /**
+     * Gets the cursor for the loader - can be overriden
+     *
+     * @return cursor to load
+     */
+    protected Cursor getCursor() {
+        return makeSongCursor(mContext, mSelection);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/SortedCursor.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/SortedCursor.java
new file mode 100755
index 0000000000..631d056e15
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/SortedCursor.java
@@ -0,0 +1,186 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.loaders;
+
+import android.database.AbstractCursor;
+import android.database.Cursor;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * This cursor basically wraps a song cursor and is given a list of the order of the ids of the
+ * contents of the cursor. It wraps the Cursor and simulates the internal cursor being sorted
+ * by moving the point to the appropriate spot
+ */
+public class SortedCursor extends AbstractCursor {
+    // cursor to wrap
+    private final Cursor mCursor;
+    // the map of external indices to internal indices
+    private ArrayList<Integer> mOrderedPositions;
+    // this contains the ids that weren't found in the underlying cursor
+    private ArrayList<Long> mMissingIds;
+    // this contains the mapped cursor positions and afterwards the extra ids that weren't found
+    private HashMap<Long, Integer> mMapCursorPositions;
+    // extra we want to store with the cursor
+    private ArrayList<Object> mExtraData;
+
+    /**
+     * @param cursor     to wrap
+     * @param order      the list of unique ids in sorted order to display
+     * @param columnName the column name of the id to look up in the internal cursor
+     */
+    public SortedCursor(final Cursor cursor, final long[] order, final String columnName,
+                        final List<? extends Object> extraData) {
+        if (cursor == null) {
+            throw new IllegalArgumentException("Non-null cursor is needed");
+        }
+
+        mCursor = cursor;
+        mMissingIds = buildCursorPositionMapping(order, columnName, extraData);
+    }
+
+    /**
+     * This function populates mOrderedPositions with the cursor positions in the order based
+     * on the order passed in
+     *
+     * @param order     the target order of the internal cursor
+     * @param extraData Extra data we want to add to the cursor
+     * @return returns the ids that aren't found in the underlying cursor
+     */
+    private ArrayList<Long> buildCursorPositionMapping(final long[] order,
+                                                       final String columnName, final List<? extends Object> extraData) {
+        ArrayList<Long> missingIds = new ArrayList<Long>();
+
+        mOrderedPositions = new ArrayList<Integer>(mCursor.getCount());
+        mExtraData = new ArrayList<Object>();
+
+        mMapCursorPositions = new HashMap<Long, Integer>(mCursor.getCount());
+        final int idPosition = mCursor.getColumnIndex(columnName);
+
+        if (mCursor.moveToFirst()) {
+            // first figure out where each of the ids are in the cursor
+            do {
+                mMapCursorPositions.put(mCursor.getLong(idPosition), mCursor.getPosition());
+            } while (mCursor.moveToNext());
+
+            // now create the ordered positions to map to the internal cursor given the
+            // external sort order
+            for (int i = 0; order != null && i < order.length; i++) {
+                final long id = order[i];
+                if (mMapCursorPositions.containsKey(id)) {
+                    mOrderedPositions.add(mMapCursorPositions.get(id));
+                    mMapCursorPositions.remove(id);
+                    if (extraData != null) {
+                        mExtraData.add(extraData.get(i));
+                    }
+                } else {
+                    missingIds.add(id);
+                }
+            }
+
+            mCursor.moveToFirst();
+        }
+
+        return missingIds;
+    }
+
+    /**
+     * @return the list of ids that weren't found in the underlying cursor
+     */
+    public ArrayList<Long> getMissingIds() {
+        return mMissingIds;
+    }
+
+    /**
+     * @return the list of ids that were in the underlying cursor but not part of the ordered list
+     */
+    public Collection<Long> getExtraIds() {
+        return mMapCursorPositions.keySet();
+    }
+
+    /**
+     * @return the extra object data that was passed in to be attached to the current row
+     */
+    public Object getExtraData() {
+        int position = getPosition();
+        return position < mExtraData.size() ? mExtraData.get(position) : null;
+    }
+
+    @Override
+    public void close() {
+        mCursor.close();
+
+        super.close();
+    }
+
+    @Override
+    public int getCount() {
+        return mOrderedPositions.size();
+    }
+
+    @Override
+    public String[] getColumnNames() {
+        return mCursor.getColumnNames();
+    }
+
+    @Override
+    public String getString(int column) {
+        return mCursor.getString(column);
+    }
+
+    @Override
+    public short getShort(int column) {
+        return mCursor.getShort(column);
+    }
+
+    @Override
+    public int getInt(int column) {
+        return mCursor.getInt(column);
+    }
+
+    @Override
+    public long getLong(int column) {
+        return mCursor.getLong(column);
+    }
+
+    @Override
+    public float getFloat(int column) {
+        return mCursor.getFloat(column);
+    }
+
+    @Override
+    public double getDouble(int column) {
+        return mCursor.getDouble(column);
+    }
+
+    @Override
+    public boolean isNull(int column) {
+        return mCursor.isNull(column);
+    }
+
+    @Override
+    public boolean onMove(int oldPosition, int newPosition) {
+        if (newPosition >= 0 && newPosition < getCount()) {
+            mCursor.moveToPosition(mOrderedPositions.get(newPosition));
+            return true;
+        }
+
+        return false;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/TopTracksLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/TopTracksLoader.java
new file mode 100755
index 0000000000..7f3fb719d7
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/TopTracksLoader.java
@@ -0,0 +1,163 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.provider.BaseColumns;
+
+import com.dolzzo.twelve.provider.RecentStore;
+import com.dolzzo.twelve.provider.SongPlayCount;
+import com.dolzzo.twelve.provider.SongPlayCount.SongPlayCountColumns;
+
+import java.util.ArrayList;
+
+/**
+ * Used to query {@link android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI} and return
+ * a sorted list of songs based on either the TopTracks or the RecentSongs
+ */
+public class TopTracksLoader extends SongLoader {
+    // used for the top played results
+    public static final int NUMBER_OF_SONGS = 99;
+    protected QueryType mQueryType;
+
+    public TopTracksLoader(final Context context, QueryType type) {
+        super(context);
+
+        mQueryType = type;
+    }
+
+    /**
+     * This creates a sorted cursor based on the top played results
+     *
+     * @param context Android context
+     * @return sorted cursor
+     */
+    public static final SortedCursor makeTopTracksCursor(final Context context) {
+        // first get the top results ids from the internal database
+        Cursor songs = SongPlayCount.getInstance(context).getTopPlayedResults(NUMBER_OF_SONGS);
+
+        try {
+            return makeSortedCursor(context, songs,
+                    songs.getColumnIndex(SongPlayCountColumns.ID));
+        } finally {
+            if (songs != null) {
+                songs.close();
+                songs = null;
+            }
+        }
+    }
+
+    /**
+     * This creates a sorted cursor based on the recently played tracks
+     *
+     * @param context Android context
+     * @return sorted cursor
+     */
+    public static final SortedCursor makeRecentTracksCursor(final Context context) {
+        // first get the top results ids from the internal database
+        Cursor songs = RecentStore.getInstance(context).queryRecentIds(null);
+
+        try {
+            return makeSortedCursor(context, songs,
+                    songs.getColumnIndex(SongPlayCountColumns.ID));
+        } finally {
+            if (songs != null) {
+                songs.close();
+                songs = null;
+            }
+        }
+    }
+
+    /**
+     * This creates a sorted song cursor given a cursor that contains the sort order
+     *
+     * @param context  Android context
+     * @param cursor   This is the cursor used to determine the order of the ids
+     * @param idColumn the id column index of the cursor
+     * @return a Sorted Cursor of songs
+     */
+    public static final SortedCursor makeSortedCursor(final Context context, final Cursor cursor,
+                                                      final int idColumn) {
+        if (cursor != null && cursor.moveToFirst()) {
+            // create the list of ids to select against
+            StringBuilder selection = new StringBuilder();
+            selection.append(BaseColumns._ID);
+            selection.append(" IN (");
+
+            // this tracks the order of the ids
+            long[] order = new long[cursor.getCount()];
+
+            long id = cursor.getLong(idColumn);
+            selection.append(id);
+            order[cursor.getPosition()] = id;
+
+            while (cursor.moveToNext()) {
+                selection.append(",");
+
+                id = cursor.getLong(idColumn);
+                order[cursor.getPosition()] = id;
+                selection.append(String.valueOf(id));
+            }
+
+            selection.append(")");
+
+            // get a list of songs with the data given the selection statement
+            Cursor songCursor = makeSongCursor(context, selection.toString(), false);
+            if (songCursor != null) {
+                // now return the wrapped TopTracksCursor to handle sorting given order
+                return new SortedCursor(songCursor, order, BaseColumns._ID, null);
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    protected Cursor getCursor() {
+        SortedCursor retCursor = null;
+        if (mQueryType == QueryType.TopTracks) {
+            retCursor = makeTopTracksCursor(mContext);
+        } else if (mQueryType == QueryType.RecentSongs) {
+            retCursor = makeRecentTracksCursor(mContext);
+        }
+
+        // clean up the databases with any ids not found
+        if (retCursor != null) {
+            ArrayList<Long> missingIds = retCursor.getMissingIds();
+            if (missingIds != null && missingIds.size() > 0) {
+                // for each unfound id, remove it from the database
+                // this codepath should only really be hit if the user removes songs
+                // outside of the Eleven app
+                for (long id : missingIds) {
+                    if (mQueryType == QueryType.TopTracks) {
+                        SongPlayCount.getInstance(mContext).removeItem(id);
+                    } else if (mQueryType == QueryType.RecentSongs) {
+                        RecentStore.getInstance(mContext).removeItem(id);
+                    }
+                }
+            }
+        }
+
+        return retCursor;
+    }
+
+    public enum QueryType {
+        TopTracks,
+        RecentSongs,
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/loaders/WrappedAsyncTaskLoader.java b/twelve/src/main/java/com/dolzzo/twelve/loaders/WrappedAsyncTaskLoader.java
new file mode 100755
index 0000000000..0ba0de0d37
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/loaders/WrappedAsyncTaskLoader.java
@@ -0,0 +1,70 @@
+
+package com.dolzzo.twelve.loaders;
+
+import android.content.Context;
+import android.support.v4.content.AsyncTaskLoader;
+
+/**
+ * <a href="http://code.google.com/p/android/issues/detail?id=14944">Issue
+ * 14944</a>
+ *
+ * @author Alexander Blom
+ */
+public abstract class WrappedAsyncTaskLoader<D> extends AsyncTaskLoader<D> {
+
+    private D mData;
+
+    /**
+     * Constructor of <code>WrappedAsyncTaskLoader</code>
+     *
+     * @param context The {@link Context} to use.
+     */
+    public WrappedAsyncTaskLoader(Context context) {
+        super(context);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void deliverResult(D data) {
+        if (!isReset()) {
+            this.mData = data;
+            super.deliverResult(data);
+        } else {
+            // An asynchronous query came in while the loader is stopped
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onStartLoading() {
+        if (this.mData != null) {
+            deliverResult(this.mData);
+        } else if (takeContentChanged() || this.mData == null) {
+            forceLoad();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onStopLoading() {
+        // Attempt to cancel the current load task if possible
+        cancelLoad();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onReset() {
+        super.onReset();
+        // Ensure the loader is stopped
+        onStopLoading();
+        this.mData = null;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/menu/BasePlaylistDialog.java b/twelve/src/main/java/com/dolzzo/twelve/menu/BasePlaylistDialog.java
new file mode 100755
index 0000000000..6c6ec90b60
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/menu/BasePlaylistDialog.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.menu;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.os.Bundle;
+import android.support.v4.app.DialogFragment;
+import android.text.Editable;
+import android.text.InputType;
+import android.text.TextWatcher;
+import android.view.WindowManager;
+import android.widget.Button;
+import android.widget.EditText;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * A simple base class for the playlist dialogs.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public abstract class BasePlaylistDialog extends DialogFragment {
+
+    /**
+     * Simple {@link TextWatcher}
+     */
+    private final TextWatcher mTextWatcher = new TextWatcher() {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onTextChanged(final CharSequence s, final int start, final int before,
+                                  final int count) {
+            onTextChangedListener();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void afterTextChanged(final Editable s) {
+            /* Nothing to do */
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void beforeTextChanged(final CharSequence s, final int start, final int count,
+                                      final int after) {
+            /* Nothing to do */
+        }
+    };
+    /* The actual dialog */
+    protected AlertDialog mPlaylistDialog;
+    /* Used to make new playlist names */
+    protected EditText mPlaylist;
+    /* The dialog save button */
+    protected Button mSaveButton;
+    /* The dialog prompt */
+    protected String mPrompt;
+    /* The default edit text text */
+    protected String mDefaultname;
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Dialog onCreateDialog(final Bundle savedInstanceState) {
+        // Initialize the alert dialog
+        mPlaylistDialog = new AlertDialog.Builder(getActivity()).create();
+        // Initialize the edit text
+        mPlaylist = new EditText(getActivity());
+        // To show the "done" button on the soft keyboard
+        mPlaylist.setSingleLine(true);
+        // All caps
+        mPlaylist.setInputType(mPlaylist.getInputType() | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS
+                | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
+        // Set the save button action
+        mPlaylistDialog.setButton(Dialog.BUTTON_POSITIVE, getString(R.string.save),
+                new OnClickListener() {
+
+                    @Override
+                    public void onClick(final DialogInterface dialog, final int which) {
+                        onSaveClick();
+                        MusicUtils.refresh();
+                        dialog.dismiss();
+                    }
+                });
+        // Set the cancel button action
+        mPlaylistDialog.setButton(Dialog.BUTTON_NEGATIVE, getString(R.string.cancel),
+                new OnClickListener() {
+
+                    @Override
+                    public void onClick(final DialogInterface dialog, final int which) {
+                        MusicUtils.refresh();
+                        dialog.dismiss();
+                    }
+                });
+
+        mPlaylist.post(new Runnable() {
+
+            @Override
+            public void run() {
+                // Request focus to the edit text
+                mPlaylist.requestFocus();
+                // Select the playlist name
+                mPlaylist.selectAll();
+            }
+
+            ;
+        });
+
+        initObjects(savedInstanceState);
+        mPlaylistDialog.setTitle(mPrompt);
+        mPlaylistDialog.setView(mPlaylist);
+        mPlaylist.setText(mDefaultname);
+        mPlaylist.setSelection(mDefaultname.length());
+        mPlaylist.addTextChangedListener(mTextWatcher);
+        mPlaylistDialog.getWindow().setSoftInputMode(
+                WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
+        mPlaylistDialog.show();
+        return mPlaylistDialog;
+    }
+
+    /**
+     * Initializes the prompt and default name
+     */
+    public abstract void initObjects(Bundle savedInstanceState);
+
+    /**
+     * Called when the save button of our {@link AlertDialog} is pressed
+     */
+    public abstract void onSaveClick();
+
+    /**
+     * Called in our {@link TextWatcher} during a text change
+     */
+    public abstract void onTextChangedListener();
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/menu/ConfirmDialog.java b/twelve/src/main/java/com/dolzzo/twelve/menu/ConfirmDialog.java
new file mode 100755
index 0000000000..6dac6eab04
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/menu/ConfirmDialog.java
@@ -0,0 +1,79 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.dolzzo.twelve.menu;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.os.Bundle;
+import android.support.v4.app.DialogFragment;
+import android.support.v4.app.Fragment;
+
+import com.dolzzo.twelve.R;
+
+/**
+ * Dialog to confirm a non-reversible action
+ */
+public class ConfirmDialog extends DialogFragment {
+    private static final String TITLE_ID = "titleId";
+    private static final String OK_ID = "okId";
+
+    public ConfirmDialog() {
+    }
+
+    /**
+     * @param title describes action user is confirming
+     * @param okId  text for Ok button
+     */
+    public static void show(Fragment target, int requestCode, int titleId, int okId) {
+        final ConfirmDialog frag = new ConfirmDialog();
+        final Bundle args = new Bundle();
+        args.putInt(TITLE_ID, titleId);
+        args.putInt(OK_ID, okId);
+        frag.setArguments(args);
+        frag.setTargetFragment(target, requestCode);
+        frag.show(target.getFragmentManager(), "ConfirmDialog");
+    }
+
+    @Override
+    public Dialog onCreateDialog(final Bundle savedInstanceState) {
+        Bundle args = getArguments();
+        return new AlertDialog.Builder(getActivity())
+                .setTitle(args.getInt(TITLE_ID))
+                .setMessage(R.string.cannot_be_undone)
+                .setPositiveButton(args.getInt(OK_ID), new OnClickListener() {
+                    @Override
+                    public void onClick(final DialogInterface dialog, final int which) {
+                        Fragment target = getTargetFragment();
+                        if (target instanceof ConfirmCallback) {
+                            ((ConfirmCallback) target).confirmOk(getTargetRequestCode());
+                        }
+                        dialog.dismiss();
+                    }
+                }).setNegativeButton(R.string.cancel, new OnClickListener() {
+                    @Override
+                    public void onClick(final DialogInterface dialog, final int which) {
+                        dialog.dismiss();
+                    }
+                }).create();
+    }
+
+    public interface ConfirmCallback {
+        public void confirmOk(int requestCode);
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/menu/CreateNewPlaylist.java b/twelve/src/main/java/com/dolzzo/twelve/menu/CreateNewPlaylist.java
new file mode 100755
index 0000000000..671a214ccd
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/menu/CreateNewPlaylist.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.menu;
+
+import android.app.Dialog;
+import android.content.ContentResolver;
+import android.database.Cursor;
+import android.os.Bundle;
+import android.provider.MediaStore;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.format.Capitalize;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * @author Andrew Neal (andrewdneal@gmail.com) TODO - The playlist names are
+ *         automatically capitalized to help when you want to play one via voice
+ *         actions, but it really needs to work either way. As in, capitalized
+ *         or not.
+ */
+public class CreateNewPlaylist extends BasePlaylistDialog {
+
+    // The playlist list
+    private long[] mPlaylistList = new long[]{};
+
+    /**
+     * @param list The list of tracks to add to the playlist
+     * @return A new instance of this dialog.
+     */
+    public static CreateNewPlaylist getInstance(final long[] list) {
+        final CreateNewPlaylist frag = new CreateNewPlaylist();
+        final Bundle args = new Bundle();
+        args.putLongArray("playlist_list", list);
+        frag.setArguments(args);
+        return frag;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onSaveInstanceState(final Bundle outcicle) {
+        outcicle.putString("defaultname", mPlaylist.getText().toString());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void initObjects(final Bundle savedInstanceState) {
+        mPlaylistList = getArguments().getLongArray("playlist_list");
+        mDefaultname = savedInstanceState != null ? savedInstanceState.getString("defaultname")
+                : makePlaylistName();
+        if (mDefaultname == null) {
+            getDialog().dismiss();
+            return;
+        }
+        final String prromptformat = getString(R.string.create_playlist_prompt);
+        mPrompt = String.format(prromptformat, mDefaultname);
+    }
+
+    @Override
+    public void onSaveClick() {
+        final String playlistName = mPlaylist.getText().toString();
+        if (playlistName != null && playlistName.length() > 0) {
+            final int playlistId = (int) MusicUtils.getIdForPlaylist(getActivity(),
+                    playlistName);
+            if (playlistId >= 0) {
+                MusicUtils.clearPlaylist(getActivity(), playlistId);
+                MusicUtils.addToPlaylist(getActivity(), mPlaylistList, playlistId);
+            } else {
+                final long newId = MusicUtils.createPlaylist(getActivity(),
+                        Capitalize.capitalize(playlistName));
+                MusicUtils.addToPlaylist(getActivity(), mPlaylistList, newId);
+            }
+            getDialog().dismiss();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onTextChangedListener() {
+        final String playlistName = mPlaylist.getText().toString();
+        mSaveButton = mPlaylistDialog.getButton(Dialog.BUTTON_POSITIVE);
+        if (mSaveButton == null) {
+            return;
+        }
+        if (playlistName.trim().length() == 0) {
+            mSaveButton.setEnabled(false);
+        } else {
+            mSaveButton.setEnabled(true);
+            if (MusicUtils.getIdForPlaylist(getActivity(), playlistName) >= 0) {
+                mSaveButton.setText(R.string.overwrite);
+            } else {
+                mSaveButton.setText(R.string.save);
+            }
+        }
+    }
+
+    private String makePlaylistName() {
+        final String template = getString(R.string.new_playlist_name_template);
+        int num = 1;
+        final String[] projection = new String[]{
+                MediaStore.Audio.Playlists.NAME
+        };
+        final ContentResolver resolver = getActivity().getContentResolver();
+        final String selection = MediaStore.Audio.Playlists.NAME + " != ''";
+        Cursor cursor = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, projection,
+                selection, null, MediaStore.Audio.Playlists.NAME);
+        if (cursor == null) {
+            return null;
+        }
+
+        String suggestedname;
+        suggestedname = String.format(template, num++);
+        boolean done = false;
+        while (!done) {
+            done = true;
+            cursor.moveToFirst();
+            while (!cursor.isAfterLast()) {
+                final String playlistname = cursor.getString(0);
+                if (playlistname.compareToIgnoreCase(suggestedname) == 0) {
+                    suggestedname = String.format(template, num++);
+                    done = false;
+                }
+                cursor.moveToNext();
+            }
+        }
+        cursor.close();
+        cursor = null;
+        return suggestedname;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/menu/DeleteDialog.java b/twelve/src/main/java/com/dolzzo/twelve/menu/DeleteDialog.java
new file mode 100755
index 0000000000..e8dd2d4062
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/menu/DeleteDialog.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.menu;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.os.Bundle;
+import android.support.v4.app.DialogFragment;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * Alert dialog used to delete tracks.
+ * <p>
+ * TODO: Remove albums from the recents list upon deletion.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class DeleteDialog extends DialogFragment {
+
+    /**
+     * The item(s) to delete
+     */
+    private long[] mItemList;
+    /**
+     * The image cache
+     */
+    private ImageFetcher mFetcher;
+
+    /**
+     * Empty constructor as per the {@link Fragment} documentation
+     */
+    public DeleteDialog() {
+    }
+
+    /**
+     * @param title The title of the artist, album, or song to delete
+     * @param items The item(s) to delete
+     * @param key   The key used to remove items from the cache.
+     * @return A new instance of the dialog
+     */
+    public static DeleteDialog newInstance(final String title, final long[] items, final String key) {
+        final DeleteDialog frag = new DeleteDialog();
+        final Bundle args = new Bundle();
+        args.putString(Config.NAME, title);
+        args.putLongArray("items", items);
+        args.putString("cachekey", key);
+        frag.setArguments(args);
+        return frag;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Dialog onCreateDialog(final Bundle savedInstanceState) {
+        final String delete = getString(R.string.context_menu_delete);
+        final Bundle arguments = getArguments();
+        // Get the image cache key
+        final String key = arguments.getString("cachekey");
+        // Get the track(s) to delete
+        mItemList = arguments.getLongArray("items");
+        // Get the dialog title
+        final String title = arguments.getString(Config.NAME);
+        final String dialogTitle = getString(R.string.delete_dialog_title, title);
+        // Initialize the image cache
+        mFetcher = ApolloUtils.getImageFetcher(getActivity());
+        // Build the dialog
+        return new AlertDialog.Builder(getActivity()).setTitle(dialogTitle)
+                .setMessage(R.string.cannot_be_undone)
+                .setPositiveButton(delete, new OnClickListener() {
+
+                    @Override
+                    public void onClick(final DialogInterface dialog, final int which) {
+                        // Remove the items from the image cache
+                        mFetcher.removeFromCache(key);
+                        // Delete the selected item(s)
+                        MusicUtils.deleteTracks(getActivity(), mItemList);
+                        if (getActivity() instanceof DeleteDialogCallback) {
+                            ((DeleteDialogCallback) getActivity()).onDelete(mItemList);
+                        }
+                        dialog.dismiss();
+                    }
+                }).setNegativeButton(R.string.cancel, new OnClickListener() {
+
+                    @Override
+                    public void onClick(final DialogInterface dialog, final int which) {
+                        dialog.dismiss();
+                    }
+                }).create();
+    }
+
+    public interface DeleteDialogCallback {
+        public void onDelete(long[] id);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/menu/FragmentMenuItems.java b/twelve/src/main/java/com/dolzzo/twelve/menu/FragmentMenuItems.java
new file mode 100755
index 0000000000..1fadd4952f
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/menu/FragmentMenuItems.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.menu;
+
+/**
+ * Several of the context menu items used in Apollo are reused. This class helps
+ * keep things tidy. The integer values of the items are used both as the menu IDs
+ * _and_ to determine the sort order of the items.
+ */
+public interface FragmentMenuItems {
+    int PLAY_SELECTION = 10; // play the selected song, album, etc.
+    int PLAY_NEXT = 20; // queue a track to be played next
+    int PLAY_ALBUM = 25; // play the album that this track belongs to
+    //  SHUFFLE             =  30  // defined in res/menu
+    int ADD_TO_QUEUE = 40; // add to end of current queue
+    int ADD_TO_PLAYLIST = 50; // append to a playlist
+    int REMOVE_FROM_QUEUE = 60; // remove track from play queue
+    int REMOVE_FROM_PLAYLIST = 70; // remove track from playlist
+    int REMOVE_FROM_RECENT = 80; // remove track from recently played list
+    int RENAME_PLAYLIST = 90; // change name of playlist
+    int MORE_BY_ARTIST = 100; // jump to artist detail page
+    int USE_AS_RINGTONE = 110; // set track as ringtone
+    int DELETE = 120; // delete track from device
+    int NEW_PLAYLIST = 130; // create new playlist - also in res/menu!
+    int PLAYLIST_SELECTED = 140; // this is used for existing playlists
+    int CHANGE_IMAGE = 150; // set new art for artist/album
+
+    // not currently in use
+    int FETCH_ARTIST_IMAGE = 200;
+    int FETCH_ALBUM_ART = 210;
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/menu/PhotoSelectionDialog.java b/twelve/src/main/java/com/dolzzo/twelve/menu/PhotoSelectionDialog.java
new file mode 100755
index 0000000000..609f76328e
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/menu/PhotoSelectionDialog.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.menu;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import android.support.v4.app.DialogFragment;
+import android.widget.ArrayAdapter;
+import android.widget.ListAdapter;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.activities.HomeActivity;
+import com.dolzzo.twelve.utils.Lists;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+import java.util.ArrayList;
+
+/**
+ * Used when the user requests to modify Album art or Artist image
+ * It provides an easy interface for them to choose a new image, use the old
+ * image, or search Google for one.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class PhotoSelectionDialog extends DialogFragment {
+
+    private static final int NEW_PHOTO = 0;
+
+    private static final int OLD_PHOTO = 1;
+    private static ProfileType mProfileType;
+    private final ArrayList<String> mChoices = Lists.newArrayList();
+    private String mKey;
+
+    /**
+     * Empty constructor as per the {@link Fragment} documentation
+     */
+    public PhotoSelectionDialog() {
+    }
+
+    /**
+     * @param title The dialog title.
+     * @param type  Either Artist or Album
+     * @param key   key to query ImageFetcher
+     * @return A new instance of the dialog.
+     */
+    public static PhotoSelectionDialog newInstance(final String title, final ProfileType type,
+                                                   String key) {
+        final PhotoSelectionDialog frag = new PhotoSelectionDialog();
+        final Bundle args = new Bundle();
+        args.putString(Config.NAME, title);
+        frag.setArguments(args);
+        mProfileType = type;
+        frag.mKey = key;
+        return frag;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Dialog onCreateDialog(final Bundle savedInstanceState) {
+        final String title = getArguments().getString(Config.NAME);
+        switch (mProfileType) {
+            case ARTIST:
+                setArtistChoices();
+                break;
+            case ALBUM:
+                setAlbumChoices();
+                break;
+            case OTHER:
+                setOtherChoices();
+                break;
+            default:
+                break;
+        }
+        // Dialog item Adapter
+        final HomeActivity activity = (HomeActivity) getActivity();
+        final ListAdapter adapter = new ArrayAdapter<String>(activity,
+                android.R.layout.select_dialog_item, mChoices);
+        return new AlertDialog.Builder(activity).setTitle(title)
+                .setAdapter(adapter, new DialogInterface.OnClickListener() {
+
+                    @Override
+                    public void onClick(final DialogInterface dialog, final int which) {
+                        switch (which) {
+                            case NEW_PHOTO:
+                                activity.selectNewPhoto(mKey);
+                                break;
+                            case OLD_PHOTO:
+                                MusicUtils.selectOldPhoto(activity, mKey);
+                                break;
+                            default:
+                                break;
+                        }
+                    }
+                }).create();
+    }
+
+    /**
+     * Adds the choices for the artist profile image.
+     */
+    private void setArtistChoices() {
+        // Select a photo from the gallery
+        mChoices.add(NEW_PHOTO, getString(R.string.new_photo));
+        /* Disable fetching image until we find a last.fm replacement
+        if (ApolloUtils.isOnline(getActivity())) {
+            // Option to fetch the old artist image
+            mChoices.add(OLD_PHOTO, getString(R.string.context_menu_fetch_artist_image));
+        }*/
+    }
+
+    /**
+     * Adds the choices for the album profile image.
+     */
+    private void setAlbumChoices() {
+        // Select a photo from the gallery
+        mChoices.add(NEW_PHOTO, getString(R.string.new_photo));
+        /* Disable fetching image until we find a last.fm replacement
+        // Option to fetch the old album image
+        if (ApolloUtils.isOnline(getActivity())) {
+            // Option to fetch the old artist image
+            mChoices.add(OLD_PHOTO, getString(R.string.context_menu_fetch_album_art));
+        }*/
+    }
+
+    /**
+     * Adds the choices for the genre and playlist images.
+     */
+    private void setOtherChoices() {
+        // Select a photo from the gallery
+        mChoices.add(NEW_PHOTO, getString(R.string.new_photo));
+        // Disable fetching image until we find a last.fm replacement
+        // Option to use the default image
+        // mChoices.add(OLD_PHOTO, getString(R.string.use_default));
+    }
+
+    /**
+     * Easily detect the MIME type
+     */
+    public enum ProfileType {
+        ARTIST, ALBUM, ProfileType, OTHER
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/menu/RenamePlaylist.java b/twelve/src/main/java/com/dolzzo/twelve/menu/RenamePlaylist.java
new file mode 100755
index 0000000000..941c541575
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/menu/RenamePlaylist.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.menu;
+
+import android.app.Dialog;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.os.Bundle;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.format.Capitalize;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * Alert dialog used to rename playlits.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class RenamePlaylist extends BasePlaylistDialog {
+
+    private String mOriginalName;
+
+    private long mRenameId;
+
+    /**
+     * @param id The Id of the playlist to rename
+     * @return A new instance of this dialog.
+     */
+    public static RenamePlaylist getInstance(final Long id) {
+        final RenamePlaylist frag = new RenamePlaylist();
+        final Bundle args = new Bundle();
+        args.putLong("rename", id);
+        frag.setArguments(args);
+        return frag;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onSaveInstanceState(final Bundle outcicle) {
+        outcicle.putString("defaultname", mPlaylist.getText().toString());
+        outcicle.putLong("rename", mRenameId);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void initObjects(final Bundle savedInstanceState) {
+        mRenameId = savedInstanceState != null ? savedInstanceState.getLong("rename")
+                : getArguments().getLong("rename", -1);
+        mOriginalName = getPlaylistNameFromId(mRenameId);
+        mDefaultname = savedInstanceState != null ? savedInstanceState.getString("defaultname")
+                : mOriginalName;
+        if (mRenameId < 0 || mOriginalName == null || mDefaultname == null) {
+            getDialog().dismiss();
+            return;
+        }
+        final String promptformat = getString(R.string.create_playlist_prompt);
+        mPrompt = String.format(promptformat, mOriginalName, mDefaultname);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onSaveClick() {
+        final String playlistName = mPlaylist.getText().toString();
+        if (playlistName != null && playlistName.length() > 0) {
+            final ContentResolver resolver = getActivity().getContentResolver();
+            final ContentValues values = new ContentValues(1);
+            values.put(Audio.Playlists.NAME, Capitalize.capitalize(playlistName));
+            resolver.update(Audio.Playlists.EXTERNAL_CONTENT_URI, values,
+                    MediaStore.Audio.Playlists._ID + "=?", new String[]{
+                            String.valueOf(mRenameId)
+                    });
+            getDialog().dismiss();
+        }
+    }
+
+    @Override
+    public void onTextChangedListener() {
+        final String playlistName = mPlaylist.getText().toString();
+        mSaveButton = mPlaylistDialog.getButton(Dialog.BUTTON_POSITIVE);
+        if (mSaveButton == null) {
+            return;
+        }
+        if (playlistName.trim().length() == 0) {
+            mSaveButton.setEnabled(false);
+        } else {
+            mSaveButton.setEnabled(true);
+            if (MusicUtils.getIdForPlaylist(getActivity(), playlistName) >= 0) {
+                mSaveButton.setText(R.string.overwrite);
+            } else {
+                mSaveButton.setText(R.string.save);
+            }
+        }
+    }
+
+    /**
+     * @param id The Id of the playlist
+     * @return The name of the playlist
+     */
+    private String getPlaylistNameFromId(final long id) {
+        Cursor cursor = getActivity().getContentResolver().query(
+                MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, new String[]{
+                        MediaStore.Audio.Playlists.NAME
+                }, MediaStore.Audio.Playlists._ID + "=?", new String[]{
+                        String.valueOf(id)
+                }, MediaStore.Audio.Playlists.NAME);
+        String playlistName = null;
+        if (cursor != null) {
+            cursor.moveToFirst();
+            if (!cursor.isAfterLast()) {
+                playlistName = cursor.getString(0);
+            }
+        }
+        cursor.close();
+        cursor = null;
+        return playlistName;
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/model/Album.java b/twelve/src/main/java/com/dolzzo/twelve/model/Album.java
new file mode 100755
index 0000000000..3b6397285d
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/model/Album.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.model;
+
+import android.text.TextUtils;
+
+/**
+ * A class that represents an album.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class Album {
+
+    /**
+     * The unique Id of the album
+     */
+    public long mAlbumId;
+
+    /**
+     * The name of the album
+     */
+    public String mAlbumName;
+
+    /**
+     * The album artist
+     */
+    public String mArtistName;
+
+    /**
+     * The number of songs in the album
+     */
+    public int mSongNumber;
+
+    /**
+     * The year the album was released
+     */
+    public String mYear;
+
+    /**
+     * Bucket label for the name - may not necessarily be the name - for example albums sorted by
+     * artists would be the artist bucket label and not the album name bucket label
+     */
+    public String mBucketLabel;
+
+    /**
+     * Constructor of <code>Album</code>
+     *
+     * @param albumId    The Id of the album
+     * @param albumName  The name of the album
+     * @param artistName The album artist
+     * @param songNumber The number of songs in the album
+     * @param albumYear  The year the album was released
+     */
+    public Album(final long albumId, final String albumName, final String artistName,
+                 final int songNumber, final String albumYear) {
+        super();
+        mAlbumId = albumId;
+        mAlbumName = albumName;
+        mArtistName = artistName;
+        mSongNumber = songNumber;
+        mYear = albumYear;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + (int) mAlbumId;
+        result = prime * result + (mAlbumName == null ? 0 : mAlbumName.hashCode());
+        result = prime * result + (mArtistName == null ? 0 : mArtistName.hashCode());
+        result = prime * result + mSongNumber;
+        result = prime * result + (mYear == null ? 0 : mYear.hashCode());
+        return result;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        final Album other = (Album) obj;
+        if (mAlbumId != other.mAlbumId) {
+            return false;
+        }
+        if (!TextUtils.equals(mAlbumName, other.mAlbumName)) {
+            return false;
+        }
+        if (!TextUtils.equals(mArtistName, other.mArtistName)) {
+            return false;
+        }
+        if (mSongNumber != other.mSongNumber) {
+            return false;
+        }
+        if (!TextUtils.equals(mYear, other.mYear)) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        return mAlbumName;
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/model/AlbumArtistDetails.java b/twelve/src/main/java/com/dolzzo/twelve/model/AlbumArtistDetails.java
new file mode 100755
index 0000000000..0c360cbded
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/model/AlbumArtistDetails.java
@@ -0,0 +1,26 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.model;
+
+/**
+ * Simple containing class to query for album art
+ */
+public class AlbumArtistDetails {
+    public long mAudioId;
+    public long mAlbumId;
+    public String mAlbumName;
+    public String mArtistName;
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/model/Artist.java b/twelve/src/main/java/com/dolzzo/twelve/model/Artist.java
new file mode 100755
index 0000000000..43124364e9
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/model/Artist.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.model;
+
+import android.text.TextUtils;
+
+/**
+ * A class that represents an artist.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class Artist {
+
+    /**
+     * The unique Id of the artist
+     */
+    public long mArtistId;
+
+    /**
+     * The artist name
+     */
+    public String mArtistName;
+
+    /**
+     * The number of albums for the artist
+     */
+    public int mAlbumNumber;
+
+    /**
+     * The number of songs for the artist
+     */
+    public int mSongNumber;
+
+    /**
+     * Bucket label for the artist name if it exists
+     */
+    public String mBucketLabel;
+
+    /**
+     * Constructor of <code>Artist</code>
+     *
+     * @param artistId    The Id of the artist
+     * @param artistName  The artist name
+     * @param songNumber  The number of songs for the artist
+     * @param albumNumber The number of albums for the artist
+     */
+    public Artist(final long artistId, final String artistName, final int songNumber,
+                  final int albumNumber) {
+        super();
+        mArtistId = artistId;
+        mArtistName = artistName;
+        mSongNumber = songNumber;
+        mAlbumNumber = albumNumber;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + mAlbumNumber;
+        result = prime * result + (int) mArtistId;
+        result = prime * result + (mArtistName == null ? 0 : mArtistName.hashCode());
+        result = prime * result + mSongNumber;
+        return result;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        final Artist other = (Artist) obj;
+        if (mAlbumNumber != other.mAlbumNumber) {
+            return false;
+        }
+        if (mArtistId != other.mArtistId) {
+            return false;
+        }
+        if (!TextUtils.equals(mArtistName, other.mArtistName)) {
+            return false;
+        }
+        if (mSongNumber != other.mSongNumber) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        return mArtistName;
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/model/Genre.java b/twelve/src/main/java/com/dolzzo/twelve/model/Genre.java
new file mode 100755
index 0000000000..e1b6377036
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/model/Genre.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.model;
+
+import android.text.TextUtils;
+
+/**
+ * A class that represents a genre.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class Genre {
+
+    /**
+     * The unique Id of the genre
+     */
+    public long mGenreId;
+
+    /**
+     * The genre name
+     */
+    public String mGenreName;
+
+    /**
+     * Constructor of <code>Genre</code>
+     *
+     * @param genreId   The Id of the genre
+     * @param genreName The genre name
+     */
+    public Genre(final long genreId, final String genreName) {
+        super();
+        mGenreId = genreId;
+        mGenreName = genreName;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + (int) mGenreId;
+        result = prime * result + (mGenreName == null ? 0 : mGenreName.hashCode());
+        return result;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        final Genre other = (Genre) obj;
+        if (mGenreId != other.mGenreId) {
+            return false;
+        }
+        return TextUtils.equals(mGenreName, other.mGenreName);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        return mGenreName;
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/model/Playlist.java b/twelve/src/main/java/com/dolzzo/twelve/model/Playlist.java
new file mode 100755
index 0000000000..76d256c007
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/model/Playlist.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.model;
+
+import android.text.TextUtils;
+
+/**
+ * A class that represents a playlist.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class Playlist {
+
+    /**
+     * The unique Id of the playlist
+     */
+    public long mPlaylistId;
+
+    /**
+     * The playlist name
+     */
+    public String mPlaylistName;
+
+    /**
+     * The number of songs in this playlist
+     */
+    public int mSongCount;
+
+    /**
+     * Constructor of <code>Genre</code>
+     *
+     * @param playlistId   The Id of the playlist
+     * @param playlistName The playlist name
+     */
+    public Playlist(final long playlistId, final String playlistName, final int songCount) {
+        super();
+        mPlaylistId = playlistId;
+        mPlaylistName = playlistName;
+        mSongCount = songCount;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + (int) mPlaylistId;
+        result = prime * result + (mPlaylistName == null ? 0 : mPlaylistName.hashCode());
+        result = prime * result + mSongCount;
+        return result;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        final Playlist other = (Playlist) obj;
+        if (mPlaylistId != other.mPlaylistId) {
+            return false;
+        }
+
+        if (mSongCount != other.mSongCount) {
+            return false;
+        }
+
+        return TextUtils.equals(mPlaylistName, other.mPlaylistName);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        return mPlaylistName;
+    }
+
+    /**
+     * @return true if this is a smart playlist
+     */
+    public boolean isSmartPlaylist() {
+        return mPlaylistId < 0;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/model/SearchResult.java b/twelve/src/main/java/com/dolzzo/twelve/model/SearchResult.java
new file mode 100755
index 0000000000..0e7eb09979
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/model/SearchResult.java
@@ -0,0 +1,150 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.model;
+
+import android.database.Cursor;
+import android.provider.MediaStore;
+import android.util.Log;
+
+import com.dolzzo.twelve.Config;
+
+import java.util.Comparator;
+
+public class SearchResult {
+    public static final Comparator COMPARATOR = new Comparator<SearchResult>() {
+        @Override
+        public int compare(final SearchResult lhs, final SearchResult rhs) {
+            return lhs.mType.ordinal() - rhs.mType.ordinal();
+        }
+    };
+    private static final String TAG = SearchResult.class.getSimpleName();
+    public ResultType mType;
+    ;
+    public String mArtist;
+    public String mAlbum;
+    public String mTitle;
+    public long mId;
+    public long mAlbumId;
+    public int mAlbumCount;
+    public int mSongCount;
+
+    public static SearchResult createSearchResult(final Cursor cursor) {
+        SearchResult result = new SearchResult();
+
+        result.mType = ResultType.getResultType(cursor);
+
+        // not a valid mime type - quitting
+        if (result.mType == ResultType.Unknown) {
+            Log.e(TAG, "No valid mime type found!");
+            return null;
+        }
+
+        // Get the Id of the content
+        result.mId = cursor.getLong(cursor
+                .getColumnIndexOrThrow(android.provider.BaseColumns._ID));
+
+        // title
+        result.mTitle = cursor.getString(cursor
+                .getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE));
+
+        // Get the artist name
+        result.mArtist = cursor.getString(cursor
+                .getColumnIndexOrThrow(MediaStore.Audio.Artists.ARTIST));
+
+        // Get the album name
+        result.mAlbum = cursor.getString(cursor
+                .getColumnIndexOrThrow(MediaStore.Audio.Albums.ALBUM));
+
+        // album count
+        result.mAlbumCount = cursor.getInt(cursor.getColumnIndexOrThrow("data1"));
+
+        // song count
+        result.mSongCount = cursor.getInt(cursor.getColumnIndexOrThrow("data2"));
+
+        return result;
+    }
+
+    public static SearchResult createPlaylistResult(final Cursor cursor) {
+        SearchResult result = new SearchResult();
+
+        result.mType = ResultType.Playlist;
+
+        // Get the Id of the content
+        result.mId = cursor.getLong(cursor
+                .getColumnIndexOrThrow(android.provider.BaseColumns._ID));
+
+        // title
+        result.mTitle = cursor.getString(cursor
+                .getColumnIndexOrThrow(MediaStore.Audio.PlaylistsColumns.NAME));
+
+        return result;
+    }
+
+    public static enum ResultType {
+        Song,
+        Artist,
+        Album,
+        Playlist,
+        Unknown;
+
+        public static int getNumTypes() {
+            // # of items minus the unknown
+            return ResultType.values().length - 1;
+        }
+
+        public static ResultType getResultType(final String mimetype) {
+            if (mimetype != null) {
+                if (mimetype.equals("artist")) {
+                    return Artist;
+                } else if (mimetype.equals("album")) {
+                    return Album;
+                } else if (mimetype.startsWith("audio/") || mimetype.equals("application/ogg")
+                        || mimetype.equals("application/x-ogg")) {
+                    return Song;
+                }
+            }
+
+            return Unknown;
+        }
+
+        public static ResultType getResultType(final Cursor cursor, int index) {
+            return getResultType(cursor.getString(index));
+        }
+
+        public static ResultType getResultType(final Cursor cursor) {
+            try {
+                return getResultType(cursor,
+                        cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.MIME_TYPE));
+            } catch (IllegalArgumentException ex) {
+                return Unknown;
+            }
+        }
+
+        public Config.IdType getSourceType() {
+            switch (this) {
+                case Artist:
+                    return Config.IdType.Artist;
+                case Album:
+                    return Config.IdType.Album;
+                case Playlist:
+                    return Config.IdType.Playlist;
+                case Song:
+                default:
+                    return Config.IdType.NA;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/model/Song.java b/twelve/src/main/java/com/dolzzo/twelve/model/Song.java
new file mode 100755
index 0000000000..ca38ccd13b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/model/Song.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.model;
+
+import android.text.TextUtils;
+
+/**
+ * A class that represents a song.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class Song {
+
+    /**
+     * The unique Id of the song
+     */
+    public long mSongId;
+
+    /**
+     * The song name
+     */
+    public String mSongName;
+
+    /**
+     * The song artist
+     */
+    public String mArtistName;
+
+    /**
+     * The song album
+     */
+    public String mAlbumName;
+
+    /**
+     * The album id
+     */
+    public long mAlbumId;
+
+    /**
+     * The song duration in seconds
+     */
+    public int mDuration;
+
+    /**
+     * The year the song was recorded
+     */
+    public int mYear;
+
+    /**
+     * Bucket label for the name - may not necessarily be the name - for example songs sorted by
+     * artists would be the artist bucket label and not the song name bucket label
+     */
+    public String mBucketLabel;
+
+    /**
+     * Constructor of <code>Song</code>
+     *
+     * @param songId     The Id of the song
+     * @param songName   The name of the song
+     * @param artistName The song artist
+     * @param albumName  The song album
+     * @param duration   The duration of a song in seconds
+     * @param year       The year the song was recorded
+     */
+    public Song(final long songId, final String songName, final String artistName,
+                final String albumName, final long albumId, final int duration, final int year) {
+        mSongId = songId;
+        mSongName = songName;
+        mArtistName = artistName;
+        mAlbumName = albumName;
+        mAlbumId = albumId;
+        mDuration = duration;
+        mYear = year;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + (mAlbumName == null ? 0 : mAlbumName.hashCode());
+        result = prime * result + (int) mAlbumId;
+        result = prime * result + (mArtistName == null ? 0 : mArtistName.hashCode());
+        result = prime * result + mDuration;
+        result = prime * result + (int) mSongId;
+        result = prime * result + (mSongName == null ? 0 : mSongName.hashCode());
+        result = prime * result + mYear;
+        return result;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        final Song other = (Song) obj;
+        if (mSongId != other.mSongId) {
+            return false;
+        }
+        if (!TextUtils.equals(mAlbumName, other.mAlbumName)) {
+            return false;
+        }
+        if (mAlbumId != other.mAlbumId) {
+            return false;
+        }
+        if (!TextUtils.equals(mArtistName, other.mArtistName)) {
+            return false;
+        }
+        if (mDuration != other.mDuration) {
+            return false;
+        }
+        if (!TextUtils.equals(mSongName, other.mSongName)) {
+            return false;
+        }
+
+        if (mYear != other.mYear) {
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        return mSongName;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/provider/MusicDB.java b/twelve/src/main/java/com/dolzzo/twelve/provider/MusicDB.java
new file mode 100755
index 0000000000..a636a76402
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/provider/MusicDB.java
@@ -0,0 +1,93 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.provider;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.util.Log;
+
+public class MusicDB extends SQLiteOpenHelper {
+    /* Name of database file */
+    public static final String DATABASENAME = "musicdb.db";
+    /**
+     * Version History
+     * v1 Sept 22 2014  Initial Merge of tables
+     * Has PlaylistArtworkstore, RecentStore, SearchHistory, SongPlayCount
+     * v2 Oct 7 2014    Added a new class MusicPlaybackState - need to bump version so the new
+     * tables are created, but need to remove all drops from other classes to
+     * maintain data
+     * v3 Dec 4 2014    Add Sorting tables similar to Contacts to enable other languages like
+     * Chinese to properly sort as they would expect
+     * v4 Jan 6 2015    Missed Collate keyword on the LocalizedSongSortTable
+     */
+
+
+    /* Version constant to increment when the database should be rebuilt */
+    private static final int VERSION = 4;
+    private static MusicDB sInstance = null;
+
+    private final Context mContext;
+
+    public MusicDB(final Context context) {
+        super(context, DATABASENAME, null, VERSION);
+
+        mContext = context;
+    }
+
+    /**
+     * @param context The {@link android.content.Context} to use
+     * @return A new instance of this class.
+     */
+    public static final synchronized MusicDB getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new MusicDB(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        PropertiesStore.getInstance(mContext).onCreate(db);
+        PlaylistArtworkStore.getInstance(mContext).onCreate(db);
+        RecentStore.getInstance(mContext).onCreate(db);
+        SongPlayCount.getInstance(mContext).onCreate(db);
+        SearchHistory.getInstance(mContext).onCreate(db);
+        MusicPlaybackState.getInstance(mContext).onCreate(db);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        PropertiesStore.getInstance(mContext).onUpgrade(db, oldVersion, newVersion);
+        PlaylistArtworkStore.getInstance(mContext).onUpgrade(db, oldVersion, newVersion);
+        RecentStore.getInstance(mContext).onUpgrade(db, oldVersion, newVersion);
+        SongPlayCount.getInstance(mContext).onUpgrade(db, oldVersion, newVersion);
+        SearchHistory.getInstance(mContext).onUpgrade(db, oldVersion, newVersion);
+        MusicPlaybackState.getInstance(mContext).onUpgrade(db, oldVersion, newVersion);
+    }
+
+    @Override
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        Log.w(MusicDB.class.getSimpleName(),
+                "Downgrading from: " + oldVersion + " to " + newVersion + ". Dropping tables");
+        PropertiesStore.getInstance(mContext).onDowngrade(db, oldVersion, newVersion);
+        PlaylistArtworkStore.getInstance(mContext).onDowngrade(db, oldVersion, newVersion);
+        RecentStore.getInstance(mContext).onDowngrade(db, oldVersion, newVersion);
+        SongPlayCount.getInstance(mContext).onDowngrade(db, oldVersion, newVersion);
+        SearchHistory.getInstance(mContext).onDowngrade(db, oldVersion, newVersion);
+        MusicPlaybackState.getInstance(mContext).onDowngrade(db, oldVersion, newVersion);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/provider/MusicPlaybackState.java b/twelve/src/main/java/com/dolzzo/twelve/provider/MusicPlaybackState.java
new file mode 100755
index 0000000000..ef8a12b5f1
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/provider/MusicPlaybackState.java
@@ -0,0 +1,243 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.provider;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.service.MusicPlaybackTrack;
+import com.dolzzo.twelve.utils.Lists;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedList;
+
+/**
+ * This keeps track of the music playback and history state of the playback service
+ */
+public class MusicPlaybackState {
+    private static MusicPlaybackState sInstance = null;
+
+    private MusicDB mMusicDatabase = null;
+
+    /**
+     * Constructor of <code>MusicPlaybackState</code>
+     *
+     * @param context The {@link android.content.Context} to use
+     */
+    public MusicPlaybackState(final Context context) {
+        mMusicDatabase = MusicDB.getInstance(context);
+    }
+
+    /**
+     * @param context The {@link android.content.Context} to use
+     * @return A new instance of this class.
+     */
+    public static final synchronized MusicPlaybackState getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new MusicPlaybackState(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    public void onCreate(final SQLiteDatabase db) {
+        StringBuilder builder = new StringBuilder();
+        builder.append("CREATE TABLE IF NOT EXISTS ");
+        builder.append(PlaybackQueueColumns.NAME);
+        builder.append("(");
+
+        builder.append(PlaybackQueueColumns.TRACK_ID);
+        builder.append(" LONG NOT NULL,");
+
+        builder.append(PlaybackQueueColumns.SOURCE_ID);
+        builder.append(" LONG NOT NULL,");
+
+        builder.append(PlaybackQueueColumns.SOURCE_TYPE);
+        builder.append(" INT NOT NULL,");
+
+        builder.append(PlaybackQueueColumns.SOURCE_POSITION);
+        builder.append(" INT NOT NULL);");
+
+        db.execSQL(builder.toString());
+
+        builder = new StringBuilder();
+        builder.append("CREATE TABLE IF NOT EXISTS ");
+        builder.append(PlaybackHistoryColumns.NAME);
+        builder.append("(");
+
+        builder.append(PlaybackHistoryColumns.POSITION);
+        builder.append(" INT NOT NULL);");
+
+        db.execSQL(builder.toString());
+    }
+
+    public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {
+        // this table was created in version 2 so call the onCreate method if we hit that scenario
+        if (oldVersion < 2 && newVersion >= 2) {
+            onCreate(db);
+        }
+    }
+
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        // If we ever have downgrade, drop the table to be safe
+        db.execSQL("DROP TABLE IF EXISTS " + PlaybackQueueColumns.NAME);
+        db.execSQL("DROP TABLE IF EXISTS " + PlaybackHistoryColumns.NAME);
+        onCreate(db);
+    }
+
+    /**
+     * Clears the existing database and saves the queue and history into the db so that when the
+     * app is restarted, the tracks you were listening to is restored
+     *
+     * @param queue   the queue to save
+     * @param history the history to save
+     */
+    public synchronized void saveState(final ArrayList<MusicPlaybackTrack> queue,
+                                       LinkedList<Integer> history) {
+        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+        database.beginTransaction();
+
+        try {
+            database.delete(PlaybackQueueColumns.NAME, null, null);
+            database.delete(PlaybackHistoryColumns.NAME, null, null);
+            database.setTransactionSuccessful();
+        } finally {
+            database.endTransaction();
+        }
+
+        final int NUM_PROCESS = 20;
+        int position = 0;
+        while (position < queue.size()) {
+            database.beginTransaction();
+            try {
+                for (int i = position; i < queue.size() && i < position + NUM_PROCESS; i++) {
+                    MusicPlaybackTrack track = queue.get(i);
+                    ContentValues values = new ContentValues(4);
+
+                    values.put(PlaybackQueueColumns.TRACK_ID, track.mId);
+                    values.put(PlaybackQueueColumns.SOURCE_ID, track.mSourceId);
+                    values.put(PlaybackQueueColumns.SOURCE_TYPE, track.mSourceType.mId);
+                    values.put(PlaybackQueueColumns.SOURCE_POSITION, track.mSourcePosition);
+
+                    database.insert(PlaybackQueueColumns.NAME, null, values);
+                }
+                database.setTransactionSuccessful();
+            } finally {
+                database.endTransaction();
+                position += NUM_PROCESS;
+            }
+        }
+
+        if (history != null) {
+            Iterator<Integer> iter = history.iterator();
+            while (iter.hasNext()) {
+                database.beginTransaction();
+                try {
+                    for (int i = 0; iter.hasNext() && i < NUM_PROCESS; i++) {
+                        ContentValues values = new ContentValues(1);
+                        values.put(PlaybackHistoryColumns.POSITION, iter.next());
+
+                        database.insert(PlaybackHistoryColumns.NAME, null, values);
+                    }
+
+                    database.setTransactionSuccessful();
+                } finally {
+                    database.endTransaction();
+                }
+            }
+        }
+    }
+
+    public ArrayList<MusicPlaybackTrack> getQueue() {
+        ArrayList<MusicPlaybackTrack> results = Lists.newArrayList();
+
+        Cursor cursor = null;
+        try {
+            cursor = mMusicDatabase.getReadableDatabase().query(PlaybackQueueColumns.NAME, null,
+                    null, null, null, null, null);
+
+            if (cursor != null && cursor.moveToFirst()) {
+                results.ensureCapacity(cursor.getCount());
+
+                do {
+                    results.add(new MusicPlaybackTrack(cursor.getLong(0), cursor.getLong(1),
+                            Config.IdType.getTypeById(cursor.getInt(2)), cursor.getInt(3)));
+                } while (cursor.moveToNext());
+            }
+
+            return results;
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+                cursor = null;
+            }
+        }
+    }
+
+    public LinkedList<Integer> getHistory(final int playlistSize) {
+        LinkedList<Integer> results = Lists.newLinkedList();
+
+        Cursor cursor = null;
+        try {
+            cursor = mMusicDatabase.getReadableDatabase().query(PlaybackHistoryColumns.NAME, null,
+                    null, null, null, null, null);
+
+            if (cursor != null && cursor.moveToFirst()) {
+                do {
+                    int pos = cursor.getInt(0);
+                    if (pos >= 0 && pos < playlistSize) {
+                        results.add(pos);
+                    }
+                } while (cursor.moveToNext());
+            }
+
+            return results;
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+                cursor = null;
+            }
+        }
+    }
+
+    public class PlaybackQueueColumns {
+        /* Table name */
+        public static final String NAME = "playbackqueue";
+
+        /* track id */
+        public static final String TRACK_ID = "trackid";
+
+        /* the id of the source where this track is being played from (artist/album/playlist) */
+        public static final String SOURCE_ID = "sourceid";
+
+        /* the type of the source where this track is being played from (artist/album/playlist) */
+        public static final String SOURCE_TYPE = "sourcetype";
+
+        /* the position - this is used in playlists where the song appears multiple times */
+        public static final String SOURCE_POSITION = "sourceposition";
+    }
+
+    public class PlaybackHistoryColumns {
+        /* Table name */
+        public static final String NAME = "playbackhistory";
+
+        /* the position of the history item within the queue */
+        public static final String POSITION = "position";
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/provider/PlaylistArtworkStore.java b/twelve/src/main/java/com/dolzzo/twelve/provider/PlaylistArtworkStore.java
new file mode 100755
index 0000000000..7b2b4d1c63
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/provider/PlaylistArtworkStore.java
@@ -0,0 +1,260 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.provider;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * This db stores the details to generate the playlist artwork including when it was
+ * last updated and the # of songs in the playlist when it last updated
+ */
+public class PlaylistArtworkStore {
+    private static final long ONE_DAY_IN_MS = 1000 * 60 * 60 * 24;
+
+    private static PlaylistArtworkStore sInstance = null;
+    private final Context mContext;
+    private MusicDB mMusicDatabase = null;
+
+    /**
+     * Constructor of <code>RecentStore</code>
+     *
+     * @param context The {@link android.content.Context} to use
+     */
+    public PlaylistArtworkStore(final Context context) {
+        mMusicDatabase = MusicDB.getInstance(context);
+
+        mContext = context;
+    }
+
+    /**
+     * @param context The {@link android.content.Context} to use
+     * @return A new instance of this class.
+     */
+    public static final synchronized PlaylistArtworkStore getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new PlaylistArtworkStore(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    /**
+     * @param playlistId playlist identifier
+     * @return the key used for the imagae cache for the cover art
+     */
+    public static final String getCoverCacheKey(final long playlistId) {
+        return "playlist_cover_" + playlistId;
+    }
+
+    /**
+     * @param playlistId playlist identifier
+     * @return the key used for the imagae cache for the top artist image
+     */
+    public static final String getArtistCacheKey(final long playlistId) {
+        return "playlist_artist_" + playlistId;
+    }
+
+    public void onCreate(final SQLiteDatabase db) {
+        // create the table
+        String builder = "CREATE TABLE IF NOT EXISTS " +
+                PlaylistArtworkStoreColumns.NAME +
+                "(" +
+                PlaylistArtworkStoreColumns.ID +
+                " INT UNIQUE," +
+                PlaylistArtworkStoreColumns.LAST_UPDATE_ARTIST +
+                " LONG DEFAULT 0," +
+                PlaylistArtworkStoreColumns.NUM_SONGS_LAST_UPDATE_ARTIST +
+                " INT DEFAULT 0," +
+                PlaylistArtworkStoreColumns.LAST_UPDATE_COVER +
+                " LONG DEFAULT 0," +
+                PlaylistArtworkStoreColumns.NUM_SONGS_LAST_UPDATE_COVER +
+                " INT DEFAULT 0);";
+
+        db.execSQL(builder);
+    }
+
+    public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {
+        // No upgrade path needed yet
+    }
+
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        // If we ever have downgrade, drop the table to be safe
+        db.execSQL("DROP TABLE IF EXISTS " + PlaylistArtworkStoreColumns.NAME);
+        onCreate(db);
+    }
+
+    /**
+     * @param playlistId playlist identifier
+     * @return true if the artist artwork should be updated based on time since last update and
+     * whether the # of songs for the playlist has changed
+     */
+    public boolean needsArtistArtUpdate(final long playlistId) {
+        return needsUpdate(playlistId, PlaylistArtworkStoreColumns.LAST_UPDATE_ARTIST,
+                PlaylistArtworkStoreColumns.NUM_SONGS_LAST_UPDATE_ARTIST);
+    }
+
+    /**
+     * @param playlistId playlist identifier
+     * @return true if the cover artwork should be updated based on time since last update and
+     * whether the # of songs for the playlist has changed
+     */
+    public boolean needsCoverArtUpdate(final long playlistId) {
+        return needsUpdate(playlistId, PlaylistArtworkStoreColumns.LAST_UPDATE_COVER,
+                PlaylistArtworkStoreColumns.NUM_SONGS_LAST_UPDATE_COVER);
+    }
+
+    /**
+     * Updates the time and the # of songs in the db for the artist section of the table
+     *
+     * @param playlistId playlist identifier
+     */
+    public void updateArtistArt(final long playlistId) {
+        updateOrInsertTime(playlistId, PlaylistArtworkStoreColumns.LAST_UPDATE_ARTIST,
+                PlaylistArtworkStoreColumns.NUM_SONGS_LAST_UPDATE_ARTIST);
+    }
+
+    /**
+     * Updates the time and the # of songs in the db for the cover art of the table
+     *
+     * @param playlistId playlist identifier
+     */
+    public void updateCoverArt(final long playlistId) {
+        updateOrInsertTime(playlistId, PlaylistArtworkStoreColumns.LAST_UPDATE_COVER,
+                PlaylistArtworkStoreColumns.NUM_SONGS_LAST_UPDATE_COVER);
+    }
+
+    /**
+     * Internal function to update the entry for the columns passed in
+     *
+     * @param playlistId      playlist identifier
+     * @param columnName      the column to update to the current time
+     * @param countColumnName the column to set the # of songs to based on the playlist
+     */
+    private void updateOrInsertTime(final long playlistId, final String columnName, final String countColumnName) {
+        SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+
+        database.beginTransaction();
+
+        // gets the existing values for the entry if it exists
+        ContentValues values = getExistingContentValues(playlistId);
+        boolean existingEntry = values.size() > 0;
+        // update the values
+        values.put(PlaylistArtworkStoreColumns.ID, playlistId);
+        values.put(columnName, System.currentTimeMillis());
+        values.put(countColumnName, MusicUtils.getSongCountForPlaylist(mContext, playlistId));
+
+        // if it is an existing entry, update, otherwise insert
+        if (existingEntry) {
+            database.update(PlaylistArtworkStoreColumns.NAME, values,
+                    PlaylistArtworkStoreColumns.ID + "=" + playlistId, null);
+        } else {
+            database.insert(PlaylistArtworkStoreColumns.NAME, null, values);
+        }
+
+        database.setTransactionSuccessful();
+        database.endTransaction();
+    }
+
+    /**
+     * Internal function to get the existing values for a playlist entry
+     *
+     * @param playlistId playlist identifier
+     * @return the content values
+     */
+    private ContentValues getExistingContentValues(final long playlistId) {
+        ContentValues values = new ContentValues(4);
+        Cursor c = getEntry(playlistId);
+        if (c != null && c.moveToFirst()) {
+            values.put(PlaylistArtworkStoreColumns.ID, c.getLong(0));
+            values.put(PlaylistArtworkStoreColumns.LAST_UPDATE_ARTIST, c.getLong(1));
+            values.put(PlaylistArtworkStoreColumns.NUM_SONGS_LAST_UPDATE_ARTIST, c.getInt(2));
+            values.put(PlaylistArtworkStoreColumns.LAST_UPDATE_COVER, c.getLong(3));
+            values.put(PlaylistArtworkStoreColumns.NUM_SONGS_LAST_UPDATE_COVER, c.getInt(4));
+            c.close();
+            c = null;
+        }
+
+        return values;
+    }
+
+    /**
+     * Internal function to return whether the columns show that this needs an update
+     *
+     * @param playlistId      playlist identifier
+     * @param columnName      the column to inspect
+     * @param countColumnName the column count to inspect
+     * @return
+     */
+    private boolean needsUpdate(final long playlistId, final String columnName, final String countColumnName) {
+        // get the entry
+        Cursor c = getEntry(playlistId);
+
+        if (c != null && c.moveToFirst()) {
+            final long lastUpdate = c.getLong(c.getColumnIndex(columnName));
+            final long msSinceEpoch = System.currentTimeMillis();
+            final int songCount = MusicUtils.getSongCountForPlaylist(mContext, playlistId);
+            final int lastUpdatedSongCount = c.getInt(c.getColumnIndex(countColumnName));
+
+            c.close();
+            c = null;
+
+            // if the elapsed time since our last update is less than a day and the
+            // number of songs in the playlist hasn't changed, then don't update
+            if (msSinceEpoch - lastUpdate < ONE_DAY_IN_MS &&
+                    songCount == lastUpdatedSongCount) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Internal function to get the cursor entry for the playlist
+     *
+     * @param playlistId playlist identifier
+     * @return cursor
+     */
+    private Cursor getEntry(final long playlistId) {
+        SQLiteDatabase db = mMusicDatabase.getReadableDatabase();
+        return db.query(PlaylistArtworkStoreColumns.NAME, null,
+                PlaylistArtworkStoreColumns.ID + "=" + playlistId, null, null, null, null);
+    }
+
+    public interface PlaylistArtworkStoreColumns {
+        /* Table name */
+        public static final String NAME = "playlist_details";
+
+        /* Playlist ID column */
+        public static final String ID = "playlistid";
+
+        /* When the top artist was last updated */
+        public static final String LAST_UPDATE_ARTIST = "last_updated_artist";
+
+        /* The number of songs when we last updated the artist */
+        public static final String NUM_SONGS_LAST_UPDATE_ARTIST = "num_songs_last_updated_artist";
+
+        /* When the cover art was last updated */
+        public static final String LAST_UPDATE_COVER = "last_updated_cover";
+
+        /* The number of songs when we last updated the cover */
+        public static final String NUM_SONGS_LAST_UPDATE_COVER = "num_songs_last_updated_cover";
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/provider/PropertiesStore.java b/twelve/src/main/java/com/dolzzo/twelve/provider/PropertiesStore.java
new file mode 100755
index 0000000000..f00bea8c93
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/provider/PropertiesStore.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package com.dolzzo.twelve.provider;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+
+public class PropertiesStore {
+    private static PropertiesStore sInstance = null;
+    private final MusicDB mMusicDatabase;
+
+    private PropertiesStore(final Context context) {
+        mMusicDatabase = MusicDB.getInstance(context);
+    }
+
+    public static final synchronized PropertiesStore getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new PropertiesStore(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    public void onCreate(final SQLiteDatabase db) {
+        db.execSQL("CREATE TABLE IF NOT EXISTS " + PropertiesColumns.TABLE_NAME + "(" +
+                PropertiesColumns.PROPERTY_KEY + " STRING PRIMARY KEY," +
+                PropertiesColumns.PROPERTY_VALUE + " TEXT);");
+    }
+
+    public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {
+        // this table was created in version 3 so call the onCreate method if we hit that scenario
+        if (oldVersion < 3 && newVersion >= 3) {
+            onCreate(db);
+        }
+    }
+
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        // If we ever have downgrade, drop the table to be safe
+        db.execSQL("DROP TABLE IF EXISTS " + PropertiesColumns.TABLE_NAME);
+        onCreate(db);
+    }
+
+    public String getProperty(String key) {
+        return getProperty(key, null);
+    }
+
+    public String getProperty(String key, String defaultValue) {
+        Cursor cursor = mMusicDatabase.getReadableDatabase().query(PropertiesColumns.TABLE_NAME,
+                new String[]{PropertiesColumns.PROPERTY_VALUE},
+                PropertiesColumns.PROPERTY_KEY + "=?",
+                new String[]{key}, null, null, null);
+        try {
+            if (cursor != null && cursor.moveToFirst()) {
+                return cursor.getString(0);
+            }
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+                cursor = null;
+            }
+        }
+
+        return defaultValue;
+    }
+
+    public void storeProperty(String key, String value) {
+        ContentValues values = new ContentValues(2);
+        values.put(PropertiesColumns.PROPERTY_KEY, key);
+        values.put(PropertiesColumns.PROPERTY_VALUE, value);
+        mMusicDatabase.getWritableDatabase().replace(PropertiesColumns.TABLE_NAME,
+                null, values);
+    }
+
+    public interface DbProperties {
+        String ICU_VERSION = "icu_version";
+        String LOCALE = "locale";
+    }
+
+    private static final class PropertiesColumns {
+        public static final String TABLE_NAME = "properties";
+        public static final String PROPERTY_KEY = "property_key";
+        public static final String PROPERTY_VALUE = "property_value";
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/provider/RecentStore.java b/twelve/src/main/java/com/dolzzo/twelve/provider/RecentStore.java
new file mode 100755
index 0000000000..7a60df30a3
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/provider/RecentStore.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.provider;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+
+public class RecentStore {
+    /* Maximum # of items in the db */
+    private static final int MAX_ITEMS_IN_DB = 100;
+
+    private static RecentStore sInstance = null;
+
+    private MusicDB mMusicDatabase = null;
+
+    /**
+     * Constructor of <code>RecentStore</code>
+     *
+     * @param context The {@link Context} to use
+     */
+    public RecentStore(final Context context) {
+        mMusicDatabase = MusicDB.getInstance(context);
+    }
+
+    /**
+     * @param context The {@link Context} to use
+     * @return A new instance of this class.
+     */
+    public static final synchronized RecentStore getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new RecentStore(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    public void onCreate(final SQLiteDatabase db) {
+        db.execSQL("CREATE TABLE IF NOT EXISTS " + RecentStoreColumns.NAME + " ("
+                + RecentStoreColumns.ID + " LONG NOT NULL," + RecentStoreColumns.TIMEPLAYED
+                + " LONG NOT NULL);");
+    }
+
+    public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {
+        // No upgrade path needed yet
+    }
+
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        // If we ever have downgrade, drop the table to be safe
+        db.execSQL("DROP TABLE IF EXISTS " + RecentStoreColumns.NAME);
+        onCreate(db);
+    }
+
+    /**
+     * Used to store song IDs in the database.
+     *
+     * @param songId The song id to store
+     */
+    public void addSongId(final long songId) {
+        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+        database.beginTransaction();
+
+        try {
+            // see if the most recent item is the same song id, if it is then don't insert
+            Cursor mostRecentItem = null;
+            try {
+                mostRecentItem = queryRecentIds("1");
+                if (mostRecentItem != null && mostRecentItem.moveToFirst()) {
+                    if (songId == mostRecentItem.getLong(0)) {
+                        return;
+                    }
+                }
+            } finally {
+                if (mostRecentItem != null) {
+                    mostRecentItem.close();
+                    mostRecentItem = null;
+                }
+            }
+
+            // add the entry
+            final ContentValues values = new ContentValues(2);
+            values.put(RecentStoreColumns.ID, songId);
+            values.put(RecentStoreColumns.TIMEPLAYED, System.currentTimeMillis());
+            database.insert(RecentStoreColumns.NAME, null, values);
+
+            // if our db is too large, delete the extra items
+            Cursor oldest = null;
+            try {
+                oldest = database.query(RecentStoreColumns.NAME,
+                        new String[]{RecentStoreColumns.TIMEPLAYED}, null, null, null, null,
+                        RecentStoreColumns.TIMEPLAYED + " ASC");
+
+                if (oldest != null && oldest.getCount() > MAX_ITEMS_IN_DB) {
+                    oldest.moveToPosition(oldest.getCount() - MAX_ITEMS_IN_DB);
+                    long timeOfRecordToKeep = oldest.getLong(0);
+
+                    database.delete(RecentStoreColumns.NAME,
+                            RecentStoreColumns.TIMEPLAYED + " < ?",
+                            new String[]{String.valueOf(timeOfRecordToKeep)});
+
+                }
+            } finally {
+                if (oldest != null) {
+                    oldest.close();
+                    oldest = null;
+                }
+            }
+        } finally {
+            database.setTransactionSuccessful();
+            database.endTransaction();
+        }
+    }
+
+    /**
+     * @param songId to remove.
+     */
+    public void removeItem(final long songId) {
+        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+        database.delete(RecentStoreColumns.NAME, RecentStoreColumns.ID + " = ?", new String[]{
+                String.valueOf(songId)
+        });
+
+    }
+
+    public void deleteAll() {
+        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+        database.delete(RecentStoreColumns.NAME, null, null);
+    }
+
+    /**
+     * Gets a cursor to the list of recently played content
+     *
+     * @param limit # of songs to limit the result to
+     * @return cursor
+     */
+    public Cursor queryRecentIds(final String limit) {
+        final SQLiteDatabase database = mMusicDatabase.getReadableDatabase();
+        return database.query(RecentStoreColumns.NAME,
+                new String[]{RecentStoreColumns.ID}, null, null, null, null,
+                RecentStoreColumns.TIMEPLAYED + " DESC", limit);
+    }
+
+    public interface RecentStoreColumns {
+        /* Table name */
+        public static final String NAME = "recenthistory";
+
+        /* Album IDs column */
+        public static final String ID = "songid";
+
+        /* Time played column */
+        public static final String TIMEPLAYED = "timeplayed";
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/provider/SearchHistory.java b/twelve/src/main/java/com/dolzzo/twelve/provider/SearchHistory.java
new file mode 100755
index 0000000000..7e87a40fb4
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/provider/SearchHistory.java
@@ -0,0 +1,175 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.provider;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+
+import java.util.ArrayList;
+
+public class SearchHistory {
+    /* Maximum # of items in the db */
+    private static final int MAX_ITEMS_IN_DB = 25;
+
+    private static SearchHistory sInstance = null;
+
+    private MusicDB mMusicDatabase = null;
+
+    public SearchHistory(final Context context) {
+        mMusicDatabase = MusicDB.getInstance(context);
+    }
+
+    /**
+     * @param context The {@link android.content.Context} to use
+     * @return A new instance of this class.
+     */
+    public static final synchronized SearchHistory getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new SearchHistory(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    public void onCreate(final SQLiteDatabase db) {
+        db.execSQL("CREATE TABLE IF NOT EXISTS " + SearchHistoryColumns.NAME + " ("
+                + SearchHistoryColumns.SEARCHSTRING + " STRING NOT NULL,"
+                + SearchHistoryColumns.TIMESEARCHED + " LONG NOT NULL);");
+    }
+
+    public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {
+        // No upgrade path needed yet
+    }
+
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        // If we ever have downgrade, drop the table to be safe
+        db.execSQL("DROP TABLE IF EXISTS " + SearchHistoryColumns.NAME);
+        onCreate(db);
+    }
+
+    /**
+     * Used to save a search request into the db.  This function will remove any old
+     * searches for that string before inserting it into the db
+     *
+     * @param searchString The string that has been searched
+     */
+    public void addSearchString(final String searchString) {
+        if (searchString == null) {
+            return;
+        }
+
+        String trimmedString = searchString.trim();
+
+        if (trimmedString.isEmpty()) {
+            return;
+        }
+
+        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+        database.beginTransaction();
+
+        try {
+            // delete existing searches with the same search string
+            database.delete(SearchHistoryColumns.NAME,
+                    SearchHistoryColumns.SEARCHSTRING + " = ? COLLATE NOCASE",
+                    new String[]{trimmedString});
+
+            // add the entry
+            final ContentValues values = new ContentValues(2);
+            values.put(SearchHistoryColumns.SEARCHSTRING, trimmedString);
+            values.put(SearchHistoryColumns.TIMESEARCHED, System.currentTimeMillis());
+            database.insert(SearchHistoryColumns.NAME, null, values);
+
+            // if our db is too large, delete the extra items
+            Cursor oldest = null;
+            try {
+                database.query(SearchHistoryColumns.NAME,
+                        new String[]{SearchHistoryColumns.TIMESEARCHED}, null, null, null, null,
+                        SearchHistoryColumns.TIMESEARCHED + " ASC");
+
+                if (oldest != null && oldest.getCount() > MAX_ITEMS_IN_DB) {
+                    oldest.moveToPosition(oldest.getCount() - MAX_ITEMS_IN_DB);
+                    long timeOfRecordToKeep = oldest.getLong(0);
+
+                    database.delete(SearchHistoryColumns.NAME,
+                            SearchHistoryColumns.TIMESEARCHED + " < ?",
+                            new String[]{String.valueOf(timeOfRecordToKeep)});
+
+                }
+            } finally {
+                if (oldest != null) {
+                    oldest.close();
+                    oldest = null;
+                }
+            }
+        } finally {
+            database.setTransactionSuccessful();
+            database.endTransaction();
+        }
+    }
+
+    /**
+     * Gets a cursor to the list of recently searched strings
+     *
+     * @param limit number of items to limit to
+     * @return cursor
+     */
+    public Cursor queryRecentSearches(final String limit) {
+        final SQLiteDatabase database = mMusicDatabase.getReadableDatabase();
+        return database.query(SearchHistoryColumns.NAME,
+                new String[]{SearchHistoryColumns.SEARCHSTRING}, null, null, null, null,
+                SearchHistoryColumns.TIMESEARCHED + " DESC", limit);
+    }
+
+    /**
+     * Gets the recently searched strings
+     *
+     * @return list of esarched strings
+     */
+    public ArrayList<String> getRecentSearches() {
+        Cursor searches = queryRecentSearches(String.valueOf(MAX_ITEMS_IN_DB));
+
+        ArrayList<String> results = new ArrayList<String>(MAX_ITEMS_IN_DB);
+
+        try {
+            if (searches != null && searches.moveToFirst()) {
+                int colIdx = searches.getColumnIndex(SearchHistoryColumns.SEARCHSTRING);
+
+                do {
+                    results.add(searches.getString(colIdx));
+                } while (searches.moveToNext());
+            }
+        } finally {
+            if (searches != null) {
+                searches.close();
+                searches = null;
+            }
+        }
+
+        return results;
+    }
+
+    public interface SearchHistoryColumns {
+        /* Table name */
+        public static final String NAME = "searchhistory";
+
+        /* What was searched */
+        public static final String SEARCHSTRING = "searchstring";
+
+        /* Time of search */
+        public static final String TIMESEARCHED = "timesearched";
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/provider/SongPlayCount.java b/twelve/src/main/java/com/dolzzo/twelve/provider/SongPlayCount.java
new file mode 100755
index 0000000000..a9453412ac
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/provider/SongPlayCount.java
@@ -0,0 +1,478 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.dolzzo.twelve.provider;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.view.animation.AccelerateInterpolator;
+import android.view.animation.Interpolator;
+
+import java.util.HashSet;
+import java.util.Iterator;
+
+/**
+ * This database tracks the number of play counts for an individual song.  This is used to drive
+ * the top played tracks as well as the playlist images
+ */
+public class SongPlayCount {
+    // how many weeks worth of playback to track
+    private static final int NUM_WEEKS = 52;
+    private static SongPlayCount sInstance = null;
+    // interpolator curve applied for measuring the curve
+    private static Interpolator sInterpolator = new AccelerateInterpolator(1.5f);
+    // how high to multiply the interpolation curve
+    private static int INTERPOLATOR_HEIGHT = 50;
+    // how high the base value is. The ratio of the Height to Base is what really matters
+    private static int INTERPOLATOR_BASE = 25;
+    private static int ONE_WEEK_IN_MS = 1000 * 60 * 60 * 24 * 7;
+    private static String WHERE_ID_EQUALS = SongPlayCountColumns.ID + "=?";
+    private MusicDB mMusicDatabase = null;
+    // number of weeks since epoch time
+    private int mNumberOfWeeksSinceEpoch;
+
+    // used to track if we've walkd through the db and updated all the rows
+    private boolean mDatabaseUpdated;
+
+    /**
+     * Constructor of <code>RecentStore</code>
+     *
+     * @param context The {@link android.content.Context} to use
+     */
+    public SongPlayCount(final Context context) {
+        mMusicDatabase = MusicDB.getInstance(context);
+
+        long msSinceEpoch = System.currentTimeMillis();
+        mNumberOfWeeksSinceEpoch = (int) (msSinceEpoch / ONE_WEEK_IN_MS);
+
+        mDatabaseUpdated = false;
+    }
+
+    /**
+     * @param context The {@link android.content.Context} to use
+     * @return A new instance of this class.
+     */
+    public static final synchronized SongPlayCount getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new SongPlayCount(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    /**
+     * Calculates the score of the song given the play counts
+     *
+     * @param playCounts an array of the # of times a song has been played for each week
+     *                   where playCounts[N] is the # of times it was played N weeks ago
+     * @return the score
+     */
+    private static float calculateScore(final int[] playCounts) {
+        if (playCounts == null) {
+            return 0;
+        }
+
+        float score = 0;
+        for (int i = 0; i < Math.min(playCounts.length, NUM_WEEKS); i++) {
+            score += playCounts[i] * getScoreMultiplierForWeek(i);
+        }
+
+        return score;
+    }
+
+    /**
+     * Gets the column name for each week #
+     *
+     * @param week number
+     * @return the column name
+     */
+    private static String getColumnNameForWeek(final int week) {
+        return SongPlayCountColumns.WEEK_PLAY_COUNT + String.valueOf(week);
+    }
+
+    /**
+     * Gets the score multiplier for each week
+     *
+     * @param week number
+     * @return the multiplier to apply
+     */
+    private static float getScoreMultiplierForWeek(final int week) {
+        return sInterpolator.getInterpolation(1 - (week / (float) NUM_WEEKS)) * INTERPOLATOR_HEIGHT
+                + INTERPOLATOR_BASE;
+    }
+
+    /**
+     * For some performance gain, return a static value for the column index for a week
+     * WARNIGN: This function assumes you have selected all columns for it to work
+     *
+     * @param week number
+     * @return column index of that week
+     */
+    private static int getColumnIndexForWeek(final int week) {
+        // ID, followed by the weeks columns
+        return 1 + week;
+    }
+
+    public void onCreate(final SQLiteDatabase db) {
+        // create the play count table
+        // WARNING: If you change the order of these columns
+        // please update getColumnIndexForWeek
+        StringBuilder builder = new StringBuilder();
+        builder.append("CREATE TABLE IF NOT EXISTS ");
+        builder.append(SongPlayCountColumns.NAME);
+        builder.append("(");
+        builder.append(SongPlayCountColumns.ID);
+        builder.append(" INT UNIQUE,");
+
+        for (int i = 0; i < NUM_WEEKS; i++) {
+            builder.append(getColumnNameForWeek(i));
+            builder.append(" INT DEFAULT 0,");
+        }
+
+        builder.append(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX);
+        builder.append(" INT NOT NULL,");
+
+        builder.append(SongPlayCountColumns.PLAYCOUNTSCORE);
+        builder.append(" REAL DEFAULT 0);");
+
+        db.execSQL(builder.toString());
+    }
+
+    public void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {
+        // No upgrade path needed yet
+    }
+
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        // If we ever have downgrade, drop the table to be safe
+        db.execSQL("DROP TABLE IF EXISTS " + SongPlayCountColumns.NAME);
+        onCreate(db);
+    }
+
+    /**
+     * Increases the play count of a song by 1
+     *
+     * @param songId The song id to increase the play count
+     */
+    public void bumpSongCount(final long songId) {
+        if (songId < 0) {
+            return;
+        }
+
+        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+        updateExistingRow(database, songId, true);
+    }
+
+    /**
+     * This creates a new entry that indicates a song has been played once as well as its score
+     *
+     * @param database a writeable database
+     * @param songId   the id of the track
+     */
+    private void createNewPlayedEntry(final SQLiteDatabase database, final long songId) {
+        // no row exists, create a new one
+        float newScore = getScoreMultiplierForWeek(0);
+        int newPlayCount = 1;
+
+        final ContentValues values = new ContentValues(3);
+        values.put(SongPlayCountColumns.ID, songId);
+        values.put(SongPlayCountColumns.PLAYCOUNTSCORE, newScore);
+        values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX, mNumberOfWeeksSinceEpoch);
+        values.put(getColumnNameForWeek(0), newPlayCount);
+
+        database.insert(SongPlayCountColumns.NAME, null, values);
+    }
+
+    /**
+     * This function will take a song entry and update it to the latest week and increase the count
+     * for the current week by 1 if necessary
+     *
+     * @param database  a writeable database
+     * @param id        the id of the track to bump
+     * @param bumpCount whether to bump the current's week play count by 1 and adjust the score
+     */
+    private void updateExistingRow(final SQLiteDatabase database, final long id, boolean bumpCount) {
+        String stringId = String.valueOf(id);
+
+        // begin the transaction
+        database.beginTransaction();
+
+        // get the cursor of this content inside the transaction
+        final Cursor cursor = database.query(SongPlayCountColumns.NAME, null, WHERE_ID_EQUALS,
+                new String[]{stringId}, null, null, null);
+
+        // if we have a result
+        if (cursor != null && cursor.moveToFirst()) {
+            // figure how many weeks since we last updated
+            int lastUpdatedIndex = cursor.getColumnIndex(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX);
+            int lastUpdatedWeek = cursor.getInt(lastUpdatedIndex);
+            int weekDiff = mNumberOfWeeksSinceEpoch - lastUpdatedWeek;
+
+            // if it's more than the number of weeks we track, delete it and create a new entry
+            if (Math.abs(weekDiff) >= NUM_WEEKS) {
+                // this entry needs to be dropped since it is too outdated
+                deleteEntry(database, stringId);
+                if (bumpCount) {
+                    createNewPlayedEntry(database, id);
+                }
+            } else if (weekDiff != 0) {
+                // else, shift the weeks
+                int[] playCounts = new int[NUM_WEEKS];
+
+                if (weekDiff > 0) {
+                    // time is shifted forwards
+                    for (int i = 0; i < NUM_WEEKS - weekDiff; i++) {
+                        playCounts[i + weekDiff] = cursor.getInt(getColumnIndexForWeek(i));
+                    }
+                } else if (weekDiff < 0) {
+                    // time is shifted backwards (by user) - nor typical behavior but we
+                    // will still handle it
+
+                    // since weekDiff is -ve, NUM_WEEKS + weekDiff is the real # of weeks we have to
+                    // transfer.  Then we transfer the old week i - weekDiff to week i
+                    // for example if the user shifted back 2 weeks, ie -2, then for 0 to
+                    // NUM_WEEKS + (-2) we set the new week i = old week i - (-2) or i+2
+                    for (int i = 0; i < NUM_WEEKS + weekDiff; i++) {
+                        playCounts[i] = cursor.getInt(getColumnIndexForWeek(i - weekDiff));
+                    }
+                }
+
+                // bump the count
+                if (bumpCount) {
+                    playCounts[0]++;
+                }
+
+                float score = calculateScore(playCounts);
+
+                // if the score is non-existant, then delete it
+                if (score < .01f) {
+                    deleteEntry(database, stringId);
+                } else {
+                    // create the content values
+                    ContentValues values = new ContentValues(NUM_WEEKS + 2);
+                    values.put(SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX, mNumberOfWeeksSinceEpoch);
+                    values.put(SongPlayCountColumns.PLAYCOUNTSCORE, score);
+
+                    for (int i = 0; i < NUM_WEEKS; i++) {
+                        values.put(getColumnNameForWeek(i), playCounts[i]);
+                    }
+
+                    // update the entry
+                    database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS,
+                            new String[]{stringId});
+                }
+            } else if (bumpCount) {
+                // else no shifting, just update the scores
+                ContentValues values = new ContentValues(2);
+
+                // increase the score by a single score amount
+                int scoreIndex = cursor.getColumnIndex(SongPlayCountColumns.PLAYCOUNTSCORE);
+                float score = cursor.getFloat(scoreIndex) + getScoreMultiplierForWeek(0);
+                values.put(SongPlayCountColumns.PLAYCOUNTSCORE, score);
+
+                // increase the play count by 1
+                values.put(getColumnNameForWeek(0), cursor.getInt(getColumnIndexForWeek(0)) + 1);
+
+                // update the entry
+                database.update(SongPlayCountColumns.NAME, values, WHERE_ID_EQUALS,
+                        new String[]{stringId});
+            }
+
+            cursor.close();
+        } else if (bumpCount) {
+            // if we have no existing results, create a new one
+            createNewPlayedEntry(database, id);
+        }
+
+        database.setTransactionSuccessful();
+        database.endTransaction();
+    }
+
+    public void deleteAll() {
+        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+        database.delete(SongPlayCountColumns.NAME, null, null);
+    }
+
+    /**
+     * Gets a cursor containing the top songs played.  Note this only returns songs that have been
+     * played at least once in the past NUM_WEEKS
+     *
+     * @param numResults number of results to limit by.  If <= 0 it returns all results
+     * @return the top tracks
+     */
+    public Cursor getTopPlayedResults(int numResults) {
+        updateResults();
+
+        final SQLiteDatabase database = mMusicDatabase.getReadableDatabase();
+        return database.query(SongPlayCountColumns.NAME, new String[]{SongPlayCountColumns.ID},
+                null, null, null, null, SongPlayCountColumns.PLAYCOUNTSCORE + " DESC",
+                (numResults <= 0 ? null : String.valueOf(numResults)));
+    }
+
+    /**
+     * Given a list of ids, it sorts the results based on the most played results
+     *
+     * @param ids list
+     * @return sorted list - this may be smaller than the list passed in for performance reasons
+     */
+    public long[] getTopPlayedResultsForList(long[] ids) {
+        final int MAX_NUMBER_SONGS_TO_ANALYZE = 250;
+
+        if (ids == null || ids.length == 0) {
+            return null;
+        }
+
+        HashSet<Long> uniqueIds = new HashSet<Long>(ids.length);
+
+        // create the list of ids to select against
+        StringBuilder selection = new StringBuilder();
+        selection.append(SongPlayCountColumns.ID);
+        selection.append(" IN (");
+
+        // add the first element to handle the separator case for the first element
+        uniqueIds.add(ids[0]);
+        selection.append(ids[0]);
+
+        for (int i = 1; i < ids.length; i++) {
+            // if the new id doesn't exist
+            if (uniqueIds.add(ids[i])) {
+                // append a separator
+                selection.append(",");
+
+                // append the id
+                selection.append(ids[i]);
+
+                // for performance reasons, only look at a certain number of songs
+                // in case their playlist is ridiculously large
+                if (uniqueIds.size() >= MAX_NUMBER_SONGS_TO_ANALYZE) {
+                    break;
+                }
+            }
+        }
+
+        // close out the selection
+        selection.append(")");
+
+        long[] sortedList = new long[uniqueIds.size()];
+
+        // now query for the songs
+        final SQLiteDatabase database = mMusicDatabase.getReadableDatabase();
+        Cursor topSongsCursor = null;
+        int idx = 0;
+
+        try {
+            topSongsCursor = database.query(SongPlayCountColumns.NAME,
+                    new String[]{SongPlayCountColumns.ID}, selection.toString(), null, null,
+                    null, SongPlayCountColumns.PLAYCOUNTSCORE + " DESC");
+
+            if (topSongsCursor != null && topSongsCursor.moveToFirst()) {
+                do {
+                    // for each id found, add it to the list and remove it from the unique ids
+                    long id = topSongsCursor.getLong(0);
+                    sortedList[idx++] = id;
+                    uniqueIds.remove(id);
+                } while (topSongsCursor.moveToNext());
+            }
+        } finally {
+            if (topSongsCursor != null) {
+                topSongsCursor.close();
+                topSongsCursor = null;
+            }
+        }
+
+        // append the remaining items - these are songs that haven't been played recently
+        Iterator<Long> iter = uniqueIds.iterator();
+        while (iter.hasNext()) {
+            sortedList[idx++] = iter.next();
+        }
+
+        return sortedList;
+    }
+
+    /**
+     * This updates all the results for the getTopPlayedResults so that we can get an
+     * accurate list of the top played results
+     */
+    private synchronized void updateResults() {
+        if (mDatabaseUpdated) {
+            return;
+        }
+
+        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+
+        database.beginTransaction();
+
+        int oldestWeekWeCareAbout = mNumberOfWeeksSinceEpoch - NUM_WEEKS + 1;
+        // delete rows we don't care about anymore
+        database.delete(SongPlayCountColumns.NAME, SongPlayCountColumns.LAST_UPDATED_WEEK_INDEX
+                + " < " + oldestWeekWeCareAbout, null);
+
+        // get the remaining rows
+        Cursor cursor = database.query(SongPlayCountColumns.NAME,
+                new String[]{SongPlayCountColumns.ID},
+                null, null, null, null, null);
+
+        if (cursor != null && cursor.moveToFirst()) {
+            // for each row, update it
+            do {
+                updateExistingRow(database, cursor.getLong(0), false);
+            } while (cursor.moveToNext());
+
+            cursor.close();
+            cursor = null;
+        }
+
+        mDatabaseUpdated = true;
+        database.setTransactionSuccessful();
+        database.endTransaction();
+    }
+
+    /**
+     * @param songId The song Id to remove.
+     */
+    public void removeItem(final long songId) {
+        final SQLiteDatabase database = mMusicDatabase.getWritableDatabase();
+        deleteEntry(database, String.valueOf(songId));
+    }
+
+    /**
+     * Deletes the entry
+     *
+     * @param database database to use
+     * @param stringId id to delete
+     */
+    private void deleteEntry(final SQLiteDatabase database, final String stringId) {
+        database.delete(SongPlayCountColumns.NAME, WHERE_ID_EQUALS, new String[]{stringId});
+    }
+
+    public interface SongPlayCountColumns {
+
+        /* Table name */
+        public static final String NAME = "songplaycount";
+
+        /* Song IDs column */
+        public static final String ID = "songid";
+
+        /* Week Play Count */
+        public static final String WEEK_PLAY_COUNT = "week";
+
+        /* Weeks since Epoch */
+        public static final String LAST_UPDATED_WEEK_INDEX = "weekindex";
+
+        /* Play count */
+        public static final String PLAYCOUNTSCORE = "playcountscore";
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/recycler/RecycleHolder.java b/twelve/src/main/java/com/dolzzo/twelve/recycler/RecycleHolder.java
new file mode 100755
index 0000000000..a2d9d8419f
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/recycler/RecycleHolder.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.recycler;
+
+import android.view.View;
+import android.widget.AbsListView.RecyclerListener;
+
+import com.dolzzo.twelve.cache.ImageWorker;
+import com.dolzzo.twelve.ui.MusicHolder;
+
+/**
+ * A @ {@link RecyclerListener} for {@link MusicHolder}'s views.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class RecycleHolder implements RecyclerListener {
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onMovedToScrapHeap(final View view) {
+        MusicHolder holder = (MusicHolder) view.getTag();
+        if (holder == null) {
+            holder = new MusicHolder(view);
+            view.setTag(holder);
+        }
+
+        // Release mImage's reference
+        if (holder.mImage.get() != null) {
+            ImageWorker.cancelWork(holder.mImage.get());
+            holder.mImage.get().setImageDrawable(null);
+            holder.mImage.get().setImageBitmap(null);
+        }
+
+        // Release mLineOne's reference
+        if (holder.mLineOne.get() != null) {
+            holder.mLineOne.get().setText(null);
+        }
+
+        // Release mLineTwo's reference
+        if (holder.mLineTwo.get() != null) {
+            holder.mLineTwo.get().setText(null);
+        }
+
+        // Stop the play pause button logic
+        if (holder.mPlayPauseProgressButton.get() != null) {
+            holder.mPlayPauseProgressButton.get().disableAndHide();
+        }
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/sectionadapter/SectionAdapter.java b/twelve/src/main/java/com/dolzzo/twelve/sectionadapter/SectionAdapter.java
new file mode 100755
index 0000000000..7b615ee48b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/sectionadapter/SectionAdapter.java
@@ -0,0 +1,434 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.sectionadapter;
+
+import android.app.Activity;
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.BaseAdapter;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.MusicHolder;
+import com.dolzzo.twelve.utils.SectionCreatorUtils.Section;
+import com.dolzzo.twelve.utils.SectionCreatorUtils.SectionType;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+
+import java.util.TreeMap;
+
+/**
+ * This class wraps an ArrayAdapter that implements BasicAdapter and allows Sections to be inserted
+ * into the list.  This wraps the methods for getting the view/indices and returns the section
+ * heads and if it is an underlying item it flows it through the underlying adapter
+ *
+ * @param <TItem>         The underlying item that is in the array adapter
+ * @param <TArrayAdapter> the arrayadapter that contains TItem and implements BasicAdapter
+ */
+public class SectionAdapter<TItem,
+        TArrayAdapter extends ArrayAdapter<TItem> & SectionAdapter.BasicAdapter & IPopupMenuCallback>
+        extends BaseAdapter implements IPopupMenuCallback, IPopupMenuCallback.IListener {
+    /**
+     * {@link Context}
+     */
+    protected final Context mContext;
+    /**
+     * The underlying adapter to wrap
+     */
+    protected TArrayAdapter mUnderlyingAdapter;
+
+    /**
+     * A map of external position to the Section type and Identifier
+     */
+    protected TreeMap<Integer, Section> mSections;
+
+    protected int mHeaderLayoutId;
+    protected boolean mHeaderEnabled;
+
+    protected int mFooterLayoutId;
+    protected boolean mFooterEnabled;
+
+    /**
+     * Popup menu click listener
+     */
+    protected IListener mListener;
+
+    /**
+     * Creates a SectionAdapter
+     *
+     * @param context           The {@link Context} to use.
+     * @param underlyingAdapter the underlying adapter to wrap
+     */
+    public SectionAdapter(final Activity context, final TArrayAdapter underlyingAdapter) {
+        mContext = context;
+        mUnderlyingAdapter = underlyingAdapter;
+        mUnderlyingAdapter.setPopupMenuClickedListener(this);
+        mSections = new TreeMap<Integer, Section>();
+        setupHeaderParameters(R.layout.list_header, false);
+        // since we have no good default footer, just re-use the header layout
+        setupFooterParameters(R.layout.list_header, false);
+    }
+
+    /**
+     * Gets the underlying array adapter
+     *
+     * @return the underlying array adapter
+     */
+    public TArrayAdapter getUnderlyingAdapter() {
+        return mUnderlyingAdapter;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View getView(final int position, View convertView, final ViewGroup parent) {
+        if (isSection(position)) {
+            if (convertView == null) {
+                int layoutId = mHeaderLayoutId;
+                if (isSectionFooter(position)) {
+                    layoutId = mFooterLayoutId;
+                }
+
+                convertView = LayoutInflater.from(mContext).inflate(layoutId, parent, false);
+            }
+
+            TextView title = (TextView) convertView.findViewById(R.id.title);
+            title.setText(mSections.get(position).mIdentifier);
+        } else {
+            convertView = mUnderlyingAdapter.getView(
+                    getInternalPosition(position), convertView, parent);
+
+            Object tag = convertView.getTag();
+            if (tag instanceof MusicHolder) {
+                MusicHolder holder = (MusicHolder) tag;
+                View divider = holder.mDivider.get();
+                if (divider != null) {
+                    // if it is the last item in the list, or it is an item before a section divider
+                    // then hide the divider, otherwise show it
+                    if (position == getCount() - 1 || isSection(position + 1)) {
+                        divider.setVisibility(View.INVISIBLE);
+                    } else {
+                        divider.setVisibility(View.VISIBLE);
+                    }
+                }
+            }
+        }
+
+        return convertView;
+    }
+
+    /**
+     * Setup the header parameters
+     *
+     * @param layoutId the layout id used to inflate
+     * @param enabled  whether clicking is enabled on the header
+     */
+    public void setupHeaderParameters(int layoutId, boolean enabled) {
+        mHeaderLayoutId = layoutId;
+        mHeaderEnabled = enabled;
+    }
+
+    /**
+     * Setup the footer parameters
+     *
+     * @param layoutId the layout id used to inflate
+     * @param enabled  whether clicking is enabled on the footer
+     */
+    public void setupFooterParameters(int layoutId, boolean enabled) {
+        mFooterLayoutId = layoutId;
+        mFooterEnabled = enabled;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getCount() {
+        return mSections.size() + mUnderlyingAdapter.getCount();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Object getItem(int position) {
+        if (isSection(position)) {
+            return mSections.get(position);
+        }
+
+        return mUnderlyingAdapter.getItem(getInternalPosition(position));
+    }
+
+    /**
+     * Gets the underlying adapter's item
+     *
+     * @param position position to query for
+     * @return the underlying item or null if a section header is queried
+     */
+    public TItem getTItem(int position) {
+        if (isSection(position)) {
+            return null;
+        }
+
+        return mUnderlyingAdapter.getItem(getInternalPosition(position));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public long getItemId(int position) {
+        return position;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getItemViewType(int position) {
+        if (isSectionHeader(position)) {
+            // use the last view type id as the section header
+            return getViewTypeCount() - 1;
+        } else if (isSectionFooter(position)) {
+            // use the last view type id as the section header
+            return getViewTypeCount() - 2;
+        }
+
+        return mUnderlyingAdapter.getItemViewType(getInternalPosition(position));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getViewTypeCount() {
+        // increment view type count by 2 for section headers and section footers
+        return mUnderlyingAdapter.getViewTypeCount() + 2;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void notifyDataSetChanged() {
+        super.notifyDataSetChanged();
+
+        mUnderlyingAdapter.notifyDataSetChanged();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void notifyDataSetInvalidated() {
+        super.notifyDataSetInvalidated();
+
+        mUnderlyingAdapter.notifyDataSetInvalidated();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isEnabled(int position) {
+        if (isSectionHeader(position)) {
+            return mHeaderEnabled;
+        } else if (isSectionFooter(position)) {
+            return mFooterEnabled;
+        }
+
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean areAllItemsEnabled() {
+        return false;
+    }
+
+    /**
+     * Determines whether the item at the position is a section header
+     *
+     * @param position position in the overall lis
+     * @return true if a section header
+     */
+    public boolean isSectionHeader(int position) {
+        return mSections.containsKey(position) && mSections.get(position).mType == SectionType.Header;
+    }
+
+    /**
+     * Determines whether the item at the position is a section footer
+     *
+     * @param position position in the overall lis
+     * @return true if a section footer
+     */
+    public boolean isSectionFooter(int position) {
+        return mSections.containsKey(position) && mSections.get(position).mType == SectionType.Footer;
+    }
+
+    /**
+     * Determines whether the item at the position is a section of some type
+     *
+     * @param position position in the overall lis
+     * @return true if the item is a section
+     */
+    public boolean isSection(int position) {
+        return mSections.containsKey(position);
+    }
+
+    /**
+     * Converts the external position to the internal position.  This is needed to determine
+     * the position to pass into the underlying adapter
+     *
+     * @param position external position
+     * @return the internal position
+     */
+    public int getInternalPosition(int position) {
+        if (isSection(position)) {
+            return -1;
+        }
+
+        int countSectionHeaders = 0;
+
+        for (Integer sectionPosition : mSections.keySet()) {
+            if (sectionPosition <= position) {
+                countSectionHeaders++;
+            } else {
+                break;
+            }
+        }
+
+        return position - countSectionHeaders;
+    }
+
+    /**
+     * Converts the underlaying adapter position to wrapped adapter position
+     *
+     * @param internalPosition the position of the underlying adapter
+     * @return the position of the wrapped adapter
+     */
+    public int getExternalPosition(int internalPosition) {
+        int externalPosition = internalPosition;
+        for (Integer sectionPosition : mSections.keySet()) {
+            // because the section headers are tracking the 'merged' lists, we need to keep bumping
+            // our position for each found section header
+            if (sectionPosition <= externalPosition) {
+                externalPosition++;
+            } else {
+                break;
+            }
+        }
+
+        return externalPosition;
+    }
+
+    /**
+     * Sets the data on the adapter
+     *
+     * @param data data to set
+     */
+    public void setData(SectionListContainer<TItem> data) {
+        mUnderlyingAdapter.unload();
+
+        if (data.mSections == null) {
+            mSections.clear();
+        } else {
+            mSections = data.mSections;
+        }
+
+        mUnderlyingAdapter.addAll(data.mListResults);
+
+        mUnderlyingAdapter.buildCache();
+
+        notifyDataSetChanged();
+    }
+
+    /**
+     * unloads the underlying adapter
+     */
+    public void unload() {
+        mSections.clear();
+        mUnderlyingAdapter.unload();
+        notifyDataSetChanged();
+    }
+
+    /**
+     * flushes the underlying adapter
+     */
+    public void flush() {
+        mUnderlyingAdapter.flush();
+        notifyDataSetChanged();
+    }
+
+    public void clear() {
+        mSections.clear();
+        mUnderlyingAdapter.clear();
+        mSections.clear();
+    }
+
+    /**
+     * Gets the item position for the given identifier
+     *
+     * @param identifier used to identify the object
+     * @return item position, or -1 if not found
+     */
+    public int getItemPosition(long identifier) {
+        int internalPosition = mUnderlyingAdapter.getItemPosition(identifier);
+        if (internalPosition >= 0) {
+            return getExternalPosition(internalPosition);
+        }
+
+        return -1;
+    }
+
+    @Override
+    public void setPopupMenuClickedListener(IListener listener) {
+        mListener = listener;
+    }
+
+    @Override
+    public void onPopupMenuClicked(View v, int position) {
+        if (mListener != null) {
+            mListener.onPopupMenuClicked(v, getExternalPosition(position));
+        }
+    }
+
+    /**
+     * Basic interface that the adapters implement
+     */
+    public interface BasicAdapter {
+        public void unload();
+
+        public void buildCache();
+
+        public void flush();
+
+        public int getItemPosition(long id);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/sectionadapter/SectionCreator.java b/twelve/src/main/java/com/dolzzo/twelve/sectionadapter/SectionCreator.java
new file mode 100755
index 0000000000..f8c6822612
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/sectionadapter/SectionCreator.java
@@ -0,0 +1,81 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.sectionadapter;
+
+import android.content.Context;
+
+import com.dolzzo.twelve.loaders.WrappedAsyncTaskLoader;
+import com.dolzzo.twelve.utils.SectionCreatorUtils;
+
+import java.util.List;
+import java.util.TreeMap;
+
+/**
+ * This class wraps a SimpleListLoader and creates header sections for the sections
+ *
+ * @param <T> The type of item that is loaded
+ */
+public class SectionCreator<T> extends WrappedAsyncTaskLoader<SectionListContainer<T>> {
+    private SimpleListLoader<T> mLoader;
+    private SectionCreatorUtils.IItemCompare<T> mComparator;
+
+    /**
+     * Creates a SectionCreator object which loads @loader
+     *
+     * @param context    The {@link Context} to use.
+     * @param loader     loader to wrap
+     * @param comparator the comparison object to run to create the sections
+     */
+    public SectionCreator(Context context, SimpleListLoader<T> loader,
+                          SectionCreatorUtils.IItemCompare<T> comparator) {
+        super(context);
+        mLoader = loader;
+        mComparator = comparator;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public SectionListContainer<T> loadInBackground() {
+        List<T> results = mLoader.loadInBackground();
+        TreeMap<Integer, SectionCreatorUtils.Section> sections = null;
+
+        if (mComparator != null) {
+            sections = SectionCreatorUtils.createSections(results, mComparator);
+        }
+
+        return new SectionListContainer<T>(sections, results);
+    }
+
+    /**
+     * Simple list loader class that exposes a load method
+     *
+     * @param <T> type of item to load
+     */
+    public static abstract class SimpleListLoader<T> extends WrappedAsyncTaskLoader<List<T>> {
+        protected Context mContext;
+
+        public SimpleListLoader(Context context) {
+            super(context);
+            mContext = context;
+        }
+
+        public Context getContext() {
+            return mContext;
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/sectionadapter/SectionListContainer.java b/twelve/src/main/java/com/dolzzo/twelve/sectionadapter/SectionListContainer.java
new file mode 100755
index 0000000000..eed7f79c7d
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/sectionadapter/SectionListContainer.java
@@ -0,0 +1,37 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.sectionadapter;
+
+import com.dolzzo.twelve.utils.SectionCreatorUtils;
+
+import java.util.List;
+import java.util.TreeMap;
+
+/**
+ * Simple Container that contains a list of T items as well as the map of section information
+ *
+ * @param <T> the type of item that the list contains
+ */
+public class SectionListContainer<T> {
+    public TreeMap<Integer, SectionCreatorUtils.Section> mSections;
+    public List<T> mListResults;
+
+    public SectionListContainer(final TreeMap<Integer, SectionCreatorUtils.Section> sections,
+                                final List<T> results) {
+        mSections = sections;
+        mListResults = results;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/service/MusicPlaybackTrack.java b/twelve/src/main/java/com/dolzzo/twelve/service/MusicPlaybackTrack.java
new file mode 100755
index 0000000000..1839fc5cee
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/service/MusicPlaybackTrack.java
@@ -0,0 +1,107 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.service;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.dolzzo.twelve.Config;
+
+/**
+ * This is used by the music playback service to track the music tracks it is playing
+ * It has extra meta data to determine where the track came from so that we can show the appropriate
+ * song playing indicator
+ */
+public class MusicPlaybackTrack implements Parcelable {
+    /**
+     * Parcelable creator
+     */
+    public static final Creator<MusicPlaybackTrack> CREATOR = new Creator<MusicPlaybackTrack>() {
+        @Override
+        public MusicPlaybackTrack createFromParcel(Parcel source) {
+            return new MusicPlaybackTrack(source);
+        }
+
+        @Override
+        public MusicPlaybackTrack[] newArray(int size) {
+            return new MusicPlaybackTrack[size];
+        }
+    };
+    /**
+     * The track id
+     */
+    public long mId;
+    /**
+     * Where was this track added from? Artist id/Album id/Playlist id
+     */
+    public long mSourceId;
+    /**
+     * Where was this track added from?  Artist/Album/Playlist
+     */
+    public Config.IdType mSourceType;
+    /**
+     * This is only used for playlists since it is possible that a playlist can contain the same
+     * song multiple times.  So to prevent the song indicator showing up multiple times, we need
+     * to keep track of the position
+     */
+    public int mSourcePosition;
+
+    public MusicPlaybackTrack(long id, long sourceId, Config.IdType type, int sourcePosition) {
+        mId = id;
+        mSourceId = sourceId;
+        mSourceType = type;
+        mSourcePosition = sourcePosition;
+    }
+
+    public MusicPlaybackTrack(Parcel in) {
+        mId = in.readLong();
+        mSourceId = in.readLong();
+        mSourceType = Config.IdType.getTypeById(in.readInt());
+        mSourcePosition = in.readInt();
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(mId);
+        dest.writeLong(mSourceId);
+        dest.writeInt(mSourceType.mId);
+        dest.writeInt(mSourcePosition);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof MusicPlaybackTrack) {
+            MusicPlaybackTrack other = (MusicPlaybackTrack) o;
+            if (other != null) {
+                if (mId == other.mId
+                        && mSourceId == other.mSourceId
+                        && mSourceType == other.mSourceType
+                        && mSourcePosition == other.mSourcePosition) {
+                    return true;
+                }
+
+                return false;
+            }
+        }
+
+        return super.equals(o);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/slidinguppanel/SlidingUpPanelLayout.java b/twelve/src/main/java/com/dolzzo/twelve/slidinguppanel/SlidingUpPanelLayout.java
new file mode 100755
index 0000000000..aa72b3530c
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/slidinguppanel/SlidingUpPanelLayout.java
@@ -0,0 +1,1352 @@
+package com.dolzzo.twelve.slidinguppanel;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.v4.view.MotionEventCompat;
+import android.support.v4.view.ViewCompat;
+import android.util.AttributeSet;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.accessibility.AccessibilityEvent;
+
+import com.dolzzo.twelve.R;
+
+public class SlidingUpPanelLayout extends ViewGroup {
+
+    private static final String TAG = SlidingUpPanelLayout.class.getSimpleName();
+
+    /**
+     * Default peeking out panel height
+     */
+    private static final int DEFAULT_PANEL_HEIGHT = 68; // dp;
+
+    /**
+     * Default anchor point height
+     */
+    private static final float DEFAULT_ANCHOR_POINT = 1.0f; // In relative %
+    /**
+     * Default height of the shadow above the peeking out panel
+     */
+    private static final int DEFAULT_SHADOW_HEIGHT = 4; // dp;
+    /**
+     * If no fade color is given by default it will fade to 80% gray.
+     */
+    private static final int DEFAULT_FADE_COLOR = 0x99000000;
+    /**
+     * Whether we should hook up the drag view clickable state
+     */
+    private static final boolean DEFAULT_DRAG_VIEW_CLICKABLE = true;
+    /**
+     * Default Minimum velocity that will be detected as a fling
+     */
+    private static final int DEFAULT_MIN_FLING_VELOCITY = 400; // dips per second
+    /**
+     * Default is set to false because that is how it was written
+     */
+    private static final boolean DEFAULT_OVERLAY_FLAG = false;
+    /**
+     * Default attributes for layout
+     */
+    private static final int[] DEFAULT_ATTRS = new int[]{
+            android.R.attr.gravity
+    };
+    /**
+     * Default paralax length of the main view
+     */
+    private static final int DEFAULT_PARALAX_OFFSET = 0;
+    /**
+     * Default slide panel offset when collapsed
+     */
+    private static final int DEFAULT_SLIDE_PANEL_OFFSET = 0;
+    /**
+     * Default direct offset flag
+     */
+    private static final boolean DEFAULT_DIRECT_OFFSET_FLAG = false;
+    /**
+     * Default initial state for the component
+     */
+    private static SlideState DEFAULT_SLIDE_STATE = SlideState.COLLAPSED;
+    /**
+     * The paint used to dim the main layout when sliding
+     */
+    private final Paint mCoveredFadePaint = new Paint();
+    /**
+     * Drawable used to draw the shadow between panes.
+     */
+    private final Drawable mShadowDrawable;
+    private final ViewDragHelper mDragHelper;
+    private final Rect mTmpRect = new Rect();
+    /**
+     * Minimum velocity that will be detected as a fling
+     */
+    private int mMinFlingVelocity = DEFAULT_MIN_FLING_VELOCITY;
+    /**
+     * The fade color used for the panel covered by the slider. 0 = no fading.
+     */
+    private int mCoveredFadeColor = DEFAULT_FADE_COLOR;
+    /**
+     * The size of the overhang in pixels.
+     */
+    private int mPanelHeight = -1;
+    /**
+     * Determines how much to slide the panel off when expanded
+     */
+    private int mSlidePanelOffset = 0;
+    /**
+     * The size of the shadow in pixels.
+     */
+    private int mShadowHeight = -1;
+    /**
+     * Paralax offset
+     */
+    private int mParallaxOffset = -1;
+    /**
+     * Clamps the Main view to the slideable view
+     */
+    private boolean mDirectOffset = false;
+    /**
+     * True if the collapsed panel should be dragged up.
+     */
+    private boolean mIsSlidingUp;
+    /**
+     * Panel overlays the windows instead of putting it underneath it.
+     */
+    private boolean mOverlayContent = DEFAULT_OVERLAY_FLAG;
+    /**
+     * If provided, the panel can be dragged by only this view. Otherwise, the entire panel can be
+     * used for dragging.
+     */
+    private View mDragView;
+    /**
+     * If provided, the panel can be dragged by only this view. Otherwise, the entire panel can be
+     * used for dragging.
+     */
+    private int mDragViewResId = -1;
+    /**
+     * Whether clicking on the drag view will expand/collapse
+     */
+    private boolean mDragViewClickable = DEFAULT_DRAG_VIEW_CLICKABLE;
+    /**
+     * The child view that can slide, if any.
+     */
+    private View mSlideableView;
+    /**
+     * The main view
+     */
+    private View mMainView;
+    /**
+     * The background view
+     */
+    private View mBackgroundView;
+    private SlideState mSlideState = SlideState.COLLAPSED;
+    /**
+     * How far the panel is offset from its expanded position.
+     * range [0, 1] where 0 = collapsed, 1 = expanded.
+     */
+    private float mSlideOffset;
+    /**
+     * How far in pixels the slideable panel may move.
+     */
+    private int mSlideRange;
+    /**
+     * A panel view is locked into internal scrolling or another condition that
+     * is preventing a drag.
+     */
+    private boolean mIsUnableToDrag;
+    /**
+     * Flag indicating that sliding feature is enabled\disabled
+     */
+    private boolean mIsSlidingEnabled;
+    /**
+     * Flag indicating if a drag view can have its own touch events.  If set
+     * to true, a drag view can scroll horizontally and have its own click listener.
+     * <p>
+     * Default is set to false.
+     */
+    private boolean mIsUsingDragViewTouchEvents;
+    private float mInitialMotionX;
+    private float mInitialMotionY;
+    private float mAnchorPoint = 1.f;
+    private PanelSlideListener mPanelSlideListener;
+    /**
+     * Stores whether or not the pane was expanded the last time it was slideable.
+     * If expand/collapse operations are invoked this state is modified. Used by
+     * instance state save/restore.
+     */
+    private boolean mFirstLayout = true;
+
+    public SlidingUpPanelLayout(Context context) {
+        this(context, null);
+    }
+
+    public SlidingUpPanelLayout(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public SlidingUpPanelLayout(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+        if (isInEditMode()) {
+            mShadowDrawable = null;
+            mDragHelper = null;
+            return;
+        }
+
+        if (attrs != null) {
+            TypedArray defAttrs = context.obtainStyledAttributes(attrs, DEFAULT_ATTRS);
+
+            if (defAttrs != null) {
+                int gravity = defAttrs.getInt(0, Gravity.NO_GRAVITY);
+                if (gravity != Gravity.TOP && gravity != Gravity.BOTTOM) {
+                    throw new IllegalArgumentException("gravity must be set to either top or bottom");
+                }
+                mIsSlidingUp = gravity == Gravity.BOTTOM;
+            }
+
+            defAttrs.recycle();
+
+            TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.SlidingUpPanelLayout);
+
+            if (ta != null) {
+                mPanelHeight = ta.getDimensionPixelSize(R.styleable.SlidingUpPanelLayout_panelHeight, -1);
+                mSlidePanelOffset = ta.getDimensionPixelSize(R.styleable.SlidingUpPanelLayout_slidePanelOffset, DEFAULT_SLIDE_PANEL_OFFSET);
+                mShadowHeight = ta.getDimensionPixelSize(R.styleable.SlidingUpPanelLayout_shadowHeight, -1);
+                mParallaxOffset = ta.getDimensionPixelSize(R.styleable.SlidingUpPanelLayout_paralaxOffset, -1);
+                mDirectOffset = ta.getBoolean(R.styleable.SlidingUpPanelLayout_directOffset, DEFAULT_DIRECT_OFFSET_FLAG);
+
+                mMinFlingVelocity = ta.getInt(R.styleable.SlidingUpPanelLayout_flingVelocity, DEFAULT_MIN_FLING_VELOCITY);
+                mCoveredFadeColor = ta.getColor(R.styleable.SlidingUpPanelLayout_fadeColor, DEFAULT_FADE_COLOR);
+
+                mDragViewResId = ta.getResourceId(R.styleable.SlidingUpPanelLayout_dragView, -1);
+                mDragViewClickable = ta.getBoolean(R.styleable.SlidingUpPanelLayout_dragViewClickable, DEFAULT_DRAG_VIEW_CLICKABLE);
+
+                mOverlayContent = ta.getBoolean(R.styleable.SlidingUpPanelLayout_overlay, DEFAULT_OVERLAY_FLAG);
+
+                mAnchorPoint = ta.getFloat(R.styleable.SlidingUpPanelLayout_anchorPoint, DEFAULT_ANCHOR_POINT);
+
+                mSlideState = SlideState.values()[ta.getInt(R.styleable.SlidingUpPanelLayout_initialState, DEFAULT_SLIDE_STATE.ordinal())];
+            }
+
+            ta.recycle();
+        }
+
+        final float density = context.getResources().getDisplayMetrics().density;
+        if (mPanelHeight == -1) {
+            mPanelHeight = (int) (DEFAULT_PANEL_HEIGHT * density + 0.5f);
+        }
+        if (mShadowHeight == -1) {
+            mShadowHeight = (int) (DEFAULT_SHADOW_HEIGHT * density + 0.5f);
+        }
+        if (mParallaxOffset == -1) {
+            mParallaxOffset = (int) (DEFAULT_PARALAX_OFFSET * density);
+        }
+        // If the shadow height is zero, don't show the shadow
+        if (mShadowHeight > 0) {
+            if (mIsSlidingUp) {
+                mShadowDrawable = getResources().getDrawable(R.drawable.above_shadow);
+            } else {
+                mShadowDrawable = getResources().getDrawable(R.drawable.below_shadow);
+            }
+
+        } else {
+            mShadowDrawable = null;
+        }
+
+        setWillNotDraw(false);
+
+        mDragHelper = ViewDragHelper.create(this, 0.5f, new DragHelperCallback());
+        mDragHelper.setMinVelocity(mMinFlingVelocity * density);
+
+        mIsSlidingEnabled = true;
+    }
+
+    private static boolean hasOpaqueBackground(View v) {
+        final Drawable bg = v.getBackground();
+        return bg != null && bg.getOpacity() == PixelFormat.OPAQUE;
+    }
+
+    /**
+     * Set the Drag View after the view is inflated
+     */
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+        if (mDragViewResId != -1) {
+            setDragView(findViewById(mDragViewResId));
+        }
+    }
+
+    /**
+     * @return The ARGB-packed color value used to fade the fixed pane
+     */
+    public int getCoveredFadeColor() {
+        return mCoveredFadeColor;
+    }
+
+    /**
+     * Set the color used to fade the pane covered by the sliding pane out when the pane
+     * will become fully covered in the expanded state.
+     *
+     * @param color An ARGB-packed color value
+     */
+    public void setCoveredFadeColor(int color) {
+        mCoveredFadeColor = color;
+        invalidate();
+    }
+
+    public boolean isSlidingEnabled() {
+        return mIsSlidingEnabled && mSlideableView != null;
+    }
+
+    /**
+     * Set sliding enabled flag
+     *
+     * @param enabled flag value
+     */
+    public void setSlidingEnabled(boolean enabled) {
+        mIsSlidingEnabled = enabled;
+    }
+
+    /**
+     * @return The current collapsed panel height
+     */
+    public int getPanelHeight() {
+        return mPanelHeight;
+    }
+
+    /**
+     * Set the collapsed panel height in pixels
+     *
+     * @param val A height in pixels
+     */
+    public void setPanelHeight(int val) {
+        mPanelHeight = val;
+        requestLayout();
+    }
+
+    /**
+     * Sets the panel offset when collapsed so you can exit
+     * the boundaries of the top of the screen
+     *
+     * @param val Offset in pixels
+     */
+    public void setSlidePanelOffset(int val) {
+        mSlidePanelOffset = val;
+        requestLayout();
+    }
+
+    /**
+     * @return The current paralax offset
+     */
+    public int getCurrentParalaxOffset() {
+        if (mParallaxOffset < 0) {
+            return 0;
+        }
+
+        return (int) (mParallaxOffset * getDirectionalSlideOffset());
+    }
+
+    /**
+     * @return The directional slide offset
+     */
+    protected float getDirectionalSlideOffset() {
+        return mIsSlidingUp ? -mSlideOffset : mSlideOffset;
+    }
+
+    /**
+     * Sets the panel slide listener
+     *
+     * @param listener
+     */
+    public void setPanelSlideListener(PanelSlideListener listener) {
+        mPanelSlideListener = listener;
+    }
+
+    /**
+     * Set the draggable view portion. Use to null, to allow the whole panel to be draggable
+     *
+     * @param dragView A view that will be used to drag the panel.
+     */
+    public void setDragView(View dragView) {
+        if (mDragView != null && mDragViewClickable) {
+            mDragView.setOnClickListener(null);
+        }
+        mDragView = dragView;
+        if (mDragView != null) {
+            mDragView.setClickable(true);
+            mDragView.setFocusable(false);
+            mDragView.setFocusableInTouchMode(false);
+            if (mDragViewClickable) {
+                mDragView.setOnClickListener(new OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        if (!isEnabled()) return;
+                        if (!isPanelExpanded() && !isPanelAnchored()) {
+                            expandPanel(mAnchorPoint);
+                        } else {
+                            collapsePanel();
+                        }
+                    }
+                });
+            }
+        }
+    }
+
+    /**
+     * Gets the currently set anchor point
+     *
+     * @return the currently set anchor point
+     */
+    public float getAnchorPoint() {
+        return mAnchorPoint;
+    }
+
+    /**
+     * Set an anchor point where the panel can stop during sliding
+     *
+     * @param anchorPoint A value between 0 and 1, determining the position of the anchor point
+     *                    starting from the top of the layout.
+     */
+    public void setAnchorPoint(float anchorPoint) {
+        if (anchorPoint > 0 && anchorPoint <= 1) {
+            mAnchorPoint = anchorPoint;
+        }
+    }
+
+    /**
+     * Check if the panel is set as an overlay.
+     */
+    public boolean isOverlayed() {
+        return mOverlayContent;
+    }
+
+    /**
+     * Sets whether or not the panel overlays the content
+     *
+     * @param overlayed
+     */
+    public void setOverlayed(boolean overlayed) {
+        mOverlayContent = overlayed;
+    }
+
+    void dispatchOnPanelSlide(View panel) {
+        if (mPanelSlideListener != null) {
+            mPanelSlideListener.onPanelSlide(panel, mSlideOffset);
+        }
+    }
+
+    void dispatchOnPanelExpanded(View panel) {
+        if (mPanelSlideListener != null) {
+            mPanelSlideListener.onPanelExpanded(panel);
+        }
+        sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
+    }
+
+    void dispatchOnPanelCollapsed(View panel) {
+        if (mPanelSlideListener != null) {
+            mPanelSlideListener.onPanelCollapsed(panel);
+        }
+        sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
+    }
+
+    void dispatchOnPanelAnchored(View panel) {
+        if (mPanelSlideListener != null) {
+            mPanelSlideListener.onPanelAnchored(panel);
+        }
+        sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
+    }
+
+    void dispatchOnPanelHidden(View panel) {
+        if (mPanelSlideListener != null) {
+            mPanelSlideListener.onPanelHidden(panel);
+        }
+        sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
+    }
+
+    void updateObscuredViewVisibility() {
+        if (getChildCount() == 0) {
+            return;
+        }
+        final int leftBound = getPaddingLeft();
+        final int rightBound = getWidth() - getPaddingRight();
+        final int topBound = getPaddingTop();
+        final int bottomBound = getHeight() - getPaddingBottom();
+        final int left;
+        final int right;
+        final int top;
+        final int bottom;
+        if (mSlideableView != null && hasOpaqueBackground(mSlideableView)) {
+            left = mSlideableView.getLeft();
+            right = mSlideableView.getRight();
+            top = mSlideableView.getTop();
+            bottom = mSlideableView.getBottom();
+        } else {
+            left = right = top = bottom = 0;
+        }
+        View child = mMainView;
+        final int clampedChildLeft = Math.max(leftBound, child.getLeft());
+        final int clampedChildTop = Math.max(topBound, child.getTop());
+        final int clampedChildRight = Math.min(rightBound, child.getRight());
+        final int clampedChildBottom = Math.min(bottomBound, child.getBottom());
+        final int vis;
+        if (clampedChildLeft >= left && clampedChildTop >= top &&
+                clampedChildRight <= right && clampedChildBottom <= bottom) {
+            vis = INVISIBLE;
+        } else {
+            vis = VISIBLE;
+        }
+        child.setVisibility(vis);
+    }
+
+    void setAllChildrenVisible() {
+        for (int i = 0, childCount = getChildCount(); i < childCount; i++) {
+            final View child = getChildAt(i);
+            if (child.getVisibility() == INVISIBLE) {
+                child.setVisibility(VISIBLE);
+            }
+        }
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        mFirstLayout = true;
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        mFirstLayout = true;
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+        final int widthSize = MeasureSpec.getSize(widthMeasureSpec);
+        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+        final int heightSize = MeasureSpec.getSize(heightMeasureSpec);
+
+        if (widthMode != MeasureSpec.EXACTLY) {
+            throw new IllegalStateException("Width must have an exact value or MATCH_PARENT");
+        } else if (heightMode != MeasureSpec.EXACTLY) {
+            throw new IllegalStateException("Height must have an exact value or MATCH_PARENT");
+        }
+
+        final int childCount = getChildCount();
+
+        if (childCount != 2 && childCount != 3) {
+            throw new IllegalStateException("Sliding up panel layout must have exactly 2 or 3 children!");
+        }
+
+        if (childCount == 2) {
+            mMainView = getChildAt(0);
+            mSlideableView = getChildAt(1);
+        } else {
+            mBackgroundView = getChildAt(0);
+            mMainView = getChildAt(1);
+            mSlideableView = getChildAt(2);
+        }
+
+        if (mDragView == null) {
+            setDragView(mSlideableView);
+        }
+
+        // If the sliding panel is not visible, then put the whole view in the hidden state
+        if (mSlideableView.getVisibility() == GONE) {
+            mSlideState = SlideState.HIDDEN;
+        }
+
+        int layoutHeight = heightSize - getPaddingTop() - getPaddingBottom();
+
+        // First pass. Measure based on child LayoutParams width/height.
+        for (int i = 0; i < childCount; i++) {
+            final View child = getChildAt(i);
+            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+
+            // We always measure the sliding panel in order to know it's height (needed for show panel)
+            if (child.getVisibility() == GONE && child == mMainView) {
+                continue;
+            }
+
+            int height = layoutHeight;
+            if (child == mMainView && !mOverlayContent && mSlideState != SlideState.HIDDEN) {
+                height -= mPanelHeight;
+            }
+
+            int childWidthSpec;
+            if (lp.width == LayoutParams.WRAP_CONTENT) {
+                childWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.AT_MOST);
+            } else if (lp.width == LayoutParams.MATCH_PARENT) {
+                childWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY);
+            } else {
+                childWidthSpec = MeasureSpec.makeMeasureSpec(lp.width, MeasureSpec.EXACTLY);
+            }
+
+            int childHeightSpec;
+            if (lp.height == LayoutParams.WRAP_CONTENT) {
+                childHeightSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.AT_MOST);
+            } else if (lp.height == LayoutParams.MATCH_PARENT) {
+                childHeightSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
+            } else {
+                childHeightSpec = MeasureSpec.makeMeasureSpec(lp.height, MeasureSpec.EXACTLY);
+            }
+
+            if (child == mSlideableView) {
+                mSlideRange = MeasureSpec.getSize(childHeightSpec) - mPanelHeight + mSlidePanelOffset;
+                childHeightSpec += mSlidePanelOffset;
+            }
+
+            child.measure(childWidthSpec, childHeightSpec);
+        }
+
+        setMeasuredDimension(widthSize, heightSize);
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        final int paddingLeft = getPaddingLeft();
+        final int paddingTop = getPaddingTop();
+
+        final int childCount = getChildCount();
+
+        if (mFirstLayout) {
+            switch (mSlideState) {
+                case EXPANDED:
+                    mSlideOffset = 1.0f;
+                    break;
+                case ANCHORED:
+                    mSlideOffset = mAnchorPoint;
+                    break;
+                case HIDDEN:
+                    int newTop = computePanelTopPosition(0.0f) + (mIsSlidingUp ? +mPanelHeight : -mPanelHeight);
+                    mSlideOffset = computeSlideOffset(newTop);
+                    break;
+                default:
+                    mSlideOffset = 0.f;
+                    break;
+            }
+        }
+
+        for (int i = 0; i < childCount; i++) {
+            final View child = getChildAt(i);
+
+            // Always layout the sliding view on the first layout
+            if (child.getVisibility() == GONE && (child == mMainView || mFirstLayout)) {
+                continue;
+            }
+
+            final int childHeight = child.getMeasuredHeight();
+            int childTop = paddingTop;
+
+            if (child == mSlideableView) {
+                childTop = computePanelTopPosition(mSlideOffset);
+            }
+
+            if (!mIsSlidingUp) {
+                if (child == mMainView && !mOverlayContent) {
+                    childTop = computePanelTopPosition(mSlideOffset) + mSlideableView.getMeasuredHeight();
+                }
+            }
+            final int childBottom = childTop + childHeight;
+            final int childLeft = paddingLeft;
+            final int childRight = childLeft + child.getMeasuredWidth();
+
+            child.layout(childLeft, childTop, childRight, childBottom);
+        }
+
+        if (mFirstLayout) {
+            updateObscuredViewVisibility();
+        }
+
+        mFirstLayout = false;
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        // Recalculate sliding panes and their details
+        if (h != oldh) {
+            mFirstLayout = true;
+        }
+    }
+
+    /**
+     * Set if the drag view can have its own touch events.  If set
+     * to true, a drag view can scroll horizontally and have its own click listener.
+     * <p>
+     * Default is set to false.
+     */
+    public void setEnableDragViewTouchEvents(boolean enabled) {
+        mIsUsingDragViewTouchEvents = enabled;
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) {
+        if (!enabled) {
+            collapsePanel();
+        }
+        super.setEnabled(enabled);
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent ev) {
+        final int action = MotionEventCompat.getActionMasked(ev);
+
+
+        if (!isEnabled() || !mIsSlidingEnabled || (mIsUnableToDrag && action != MotionEvent.ACTION_DOWN)) {
+            mDragHelper.cancel();
+            return super.onInterceptTouchEvent(ev);
+        }
+
+        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
+            mDragHelper.cancel();
+            return false;
+        }
+
+        final float x = ev.getX();
+        final float y = ev.getY();
+
+        switch (action) {
+            case MotionEvent.ACTION_DOWN: {
+                mIsUnableToDrag = false;
+                mInitialMotionX = x;
+                mInitialMotionY = y;
+                break;
+            }
+
+            case MotionEvent.ACTION_MOVE: {
+                final float adx = Math.abs(x - mInitialMotionX);
+                final float ady = Math.abs(y - mInitialMotionY);
+                final int dragSlop = mDragHelper.getTouchSlop();
+
+                // Handle any horizontal scrolling on the drag view.
+                if (mIsUsingDragViewTouchEvents && adx > dragSlop && ady < dragSlop) {
+                    return super.onInterceptTouchEvent(ev);
+                }
+
+                if ((ady > dragSlop && adx > ady) || !isDragViewUnder((int) mInitialMotionX, (int) mInitialMotionY)) {
+                    mDragHelper.cancel();
+                    mIsUnableToDrag = true;
+                    return false;
+                }
+                break;
+            }
+        }
+
+        return mDragHelper.shouldInterceptTouchEvent(ev);
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+        if (!isSlidingEnabled()) {
+            return super.onTouchEvent(ev);
+        }
+        mDragHelper.processTouchEvent(ev);
+        return true;
+    }
+
+    private boolean isDragViewUnder(int x, int y) {
+        if (mDragView == null) return false;
+        int[] viewLocation = new int[2];
+        mDragView.getLocationOnScreen(viewLocation);
+        int[] parentLocation = new int[2];
+        this.getLocationOnScreen(parentLocation);
+        int screenX = parentLocation[0] + x;
+        int screenY = parentLocation[1] + y;
+        return screenX >= viewLocation[0] && screenX < viewLocation[0] + mDragView.getWidth() &&
+                screenY >= viewLocation[1] && screenY < viewLocation[1] + mDragView.getHeight();
+    }
+
+    private boolean expandPanel(View pane, int initialVelocity, float mSlideOffset) {
+        return mFirstLayout || smoothSlideTo(mSlideOffset, initialVelocity);
+    }
+
+    private boolean collapsePanel(View pane, int initialVelocity) {
+        return mFirstLayout || smoothSlideTo(0.0f, initialVelocity);
+    }
+
+    /*
+     * Computes the top position of the panel based on the slide offset.
+     */
+    private int computePanelTopPosition(float slideOffset) {
+        int slidingViewHeight = mSlideableView != null ? mSlideableView.getMeasuredHeight() : 0;
+        int slidePixelOffset = (int) (slideOffset * mSlideRange);
+        // Compute the top of the panel if its collapsed
+        return mIsSlidingUp
+                ? getMeasuredHeight() - getPaddingBottom() - mPanelHeight - slidePixelOffset
+                : getPaddingTop() - slidingViewHeight + mPanelHeight + slidePixelOffset;
+    }
+
+    /*
+     * Computes the slide offset based on the top position of the panel
+     */
+    private float computeSlideOffset(int topPosition) {
+        // Compute the panel top position if the panel is collapsed (offset 0)
+        final int topBoundCollapsed = computePanelTopPosition(0);
+
+        // Determine the new slide offset based on the collapsed top position and the new required
+        // top position
+        return (mIsSlidingUp
+                ? (float) (topBoundCollapsed - topPosition) / mSlideRange
+                : (float) (topPosition - topBoundCollapsed) / mSlideRange);
+    }
+
+    /**
+     * Collapse the sliding pane if it is currently slideable. If first layout
+     * has already completed this will animate.
+     *
+     * @return true if the pane was slideable and is now collapsed/in the process of collapsing
+     */
+    public boolean collapsePanel() {
+        if (mFirstLayout) {
+            mSlideState = SlideState.COLLAPSED;
+            return true;
+        } else {
+            if (mSlideState == SlideState.HIDDEN || mSlideState == SlideState.COLLAPSED)
+                return false;
+            return collapsePanel(mSlideableView, 0);
+        }
+    }
+
+    /**
+     * Expand the sliding pane if it is currently slideable.
+     *
+     * @return true if the pane was slideable and is now expanded/in the process of expading
+     */
+    public boolean expandPanel() {
+        if (mFirstLayout) {
+            mSlideState = SlideState.EXPANDED;
+            return true;
+        } else {
+            return expandPanel(1.0f);
+        }
+    }
+
+    /**
+     * Expand the sliding pane to the anchor point if it is currently slideable.
+     *
+     * @return true if the pane was slideable and is now expanded/in the process of expading
+     */
+    public boolean anchorPanel() {
+        if (mFirstLayout) {
+            mSlideState = SlideState.ANCHORED;
+            return true;
+        } else {
+            return expandPanel(mAnchorPoint);
+        }
+    }
+
+    /**
+     * Partially expand the sliding panel up to a specific offset
+     *
+     * @param mSlideOffset Value between 0 and 1, where 0 is completely expanded.
+     * @return true if the pane was slideable and is now expanded/in the process of expanding
+     */
+    public boolean expandPanel(float mSlideOffset) {
+        if (mSlideableView == null || mSlideState == SlideState.EXPANDED) return false;
+        mSlideableView.setVisibility(View.VISIBLE);
+        return expandPanel(mSlideableView, 0, mSlideOffset);
+    }
+
+    /**
+     * Check if the sliding panel in this layout is fully expanded.
+     *
+     * @return true if sliding panel is completely expanded
+     */
+    public boolean isPanelExpanded() {
+        return mSlideState == SlideState.EXPANDED;
+    }
+
+    /**
+     * Check if the sliding panel in this layout is anchored.
+     *
+     * @return true if sliding panel is anchored
+     */
+    public boolean isPanelAnchored() {
+        return mSlideState == SlideState.ANCHORED;
+    }
+
+    /**
+     * Check if the sliding panel in this layout is currently visible.
+     *
+     * @return true if the sliding panel is visible.
+     */
+    public boolean isPanelHidden() {
+        return mSlideState == SlideState.HIDDEN;
+    }
+
+    /**
+     * Shows the panel from the hidden state
+     */
+    public void showPanel() {
+        if (mFirstLayout) {
+            mSlideState = SlideState.COLLAPSED;
+        } else {
+            if (mSlideableView == null || mSlideState != SlideState.HIDDEN) return;
+            mSlideableView.setVisibility(View.VISIBLE);
+            requestLayout();
+            smoothSlideTo(0, 0);
+        }
+    }
+
+    /**
+     * Hides the sliding panel entirely.
+     */
+    public void hidePanel() {
+        if (mFirstLayout) {
+            mSlideState = SlideState.HIDDEN;
+        } else {
+            if (mSlideState == SlideState.DRAGGING || mSlideState == SlideState.HIDDEN) return;
+            int newTop = computePanelTopPosition(0.0f) + (mIsSlidingUp ? +mPanelHeight : -mPanelHeight);
+            smoothSlideTo(computeSlideOffset(newTop), 0);
+        }
+    }
+
+    @SuppressLint("NewApi")
+    private void onPanelDragged(int newTop) {
+        mSlideState = SlideState.DRAGGING;
+        // Recompute the slide offset based on the new top position
+        mSlideOffset = computeSlideOffset(newTop);
+        // Update the parallax based on the new slide offset
+        if ((mParallaxOffset > 0 || mDirectOffset) && mSlideOffset >= 0) {
+            int mainViewOffset = 0;
+            if (mParallaxOffset > 0) {
+                mainViewOffset = getCurrentParalaxOffset();
+            } else {
+                mainViewOffset = (int) (getDirectionalSlideOffset() * mSlideRange);
+            }
+
+            mMainView.setTranslationY(mainViewOffset);
+        }
+
+        // Dispatch the slide event
+        dispatchOnPanelSlide(mSlideableView);
+        // If the slide offset is negative, and overlay is not on, we need to increase the
+        // height of the main content
+        if (mSlideOffset <= 0 && !mOverlayContent) {
+            // expand the main view
+            LayoutParams lp = (LayoutParams) mMainView.getLayoutParams();
+            lp.height = mIsSlidingUp ? (newTop - getPaddingBottom()) : (getHeight() - getPaddingBottom() - mSlideableView.getMeasuredHeight() - newTop);
+            mMainView.requestLayout();
+        }
+    }
+
+    @Override
+    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
+        boolean result;
+        final int save = canvas.save(Canvas.CLIP_SAVE_FLAG);
+
+        if (isSlidingEnabled() && mMainView == child) {
+            // Clip against the slider; no sense drawing what will immediately be covered,
+            // Unless the panel is set to overlay content
+            if (!mOverlayContent) {
+                canvas.getClipBounds(mTmpRect);
+                if (mIsSlidingUp) {
+                    mTmpRect.bottom = Math.min(mTmpRect.bottom, mSlideableView.getTop());
+                } else {
+                    mTmpRect.top = Math.max(mTmpRect.top, mSlideableView.getBottom());
+                }
+                canvas.clipRect(mTmpRect);
+            }
+        }
+
+        result = super.drawChild(canvas, child, drawingTime);
+        canvas.restoreToCount(save);
+
+        if (mCoveredFadeColor != 0 && mSlideOffset > 0) {
+            final int baseAlpha = (mCoveredFadeColor & 0xff000000) >>> 24;
+            final int imag = (int) (baseAlpha * mSlideOffset);
+            final int color = imag << 24 | (mCoveredFadeColor & 0xffffff);
+            mCoveredFadePaint.setColor(color);
+            canvas.drawRect(mTmpRect, mCoveredFadePaint);
+        }
+
+        return result;
+    }
+
+    /**
+     * Smoothly animate mDraggingPane to the target X position within its range.
+     *
+     * @param slideOffset position to animate to
+     * @param velocity    initial velocity in case of fling, or 0.
+     */
+    boolean smoothSlideTo(float slideOffset, int velocity) {
+        if (!isSlidingEnabled()) {
+            // Nothing to do.
+            return false;
+        }
+
+        int panelTop = computePanelTopPosition(slideOffset);
+        if (mDragHelper.smoothSlideViewTo(mSlideableView, mSlideableView.getLeft(), panelTop)) {
+            setAllChildrenVisible();
+            ViewCompat.postInvalidateOnAnimation(this);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void computeScroll() {
+        if (mDragHelper != null && mDragHelper.continueSettling(true)) {
+            if (!isSlidingEnabled()) {
+                mDragHelper.abort();
+                return;
+            }
+
+            ViewCompat.postInvalidateOnAnimation(this);
+        }
+    }
+
+    @Override
+    public void draw(Canvas c) {
+        super.draw(c);
+
+        if (!isSlidingEnabled()) {
+            // No need to draw a shadow if we don't have one.
+            return;
+        }
+
+        final int right = mSlideableView.getRight();
+        final int top;
+        final int bottom;
+        if (mIsSlidingUp) {
+            top = mSlideableView.getTop() - mShadowHeight;
+            bottom = mSlideableView.getTop();
+        } else {
+            top = mSlideableView.getBottom();
+            bottom = mSlideableView.getBottom() + mShadowHeight;
+        }
+        final int left = mSlideableView.getLeft();
+
+        if (mShadowDrawable != null) {
+            mShadowDrawable.setBounds(left, top, right, bottom);
+            mShadowDrawable.draw(c);
+        }
+    }
+
+    /**
+     * Tests scrollability within child views of v given a delta of dx.
+     *
+     * @param v      View to test for horizontal scrollability
+     * @param checkV Whether the view v passed should itself be checked for scrollability (true),
+     *               or just its children (false).
+     * @param dx     Delta scrolled in pixels
+     * @param x      X coordinate of the active touch point
+     * @param y      Y coordinate of the active touch point
+     * @return true if child views of v can be scrolled by delta of dx.
+     */
+    protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {
+        if (v instanceof ViewGroup) {
+            final ViewGroup group = (ViewGroup) v;
+            final int scrollX = v.getScrollX();
+            final int scrollY = v.getScrollY();
+            final int count = group.getChildCount();
+            // Count backwards - let topmost views consume scroll distance first.
+            for (int i = count - 1; i >= 0; i--) {
+                final View child = group.getChildAt(i);
+                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&
+                        y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&
+                        canScroll(child, true, dx, x + scrollX - child.getLeft(),
+                                y + scrollY - child.getTop())) {
+                    return true;
+                }
+            }
+        }
+        return checkV && ViewCompat.canScrollHorizontally(v, -dx);
+    }
+
+    @Override
+    protected ViewGroup.LayoutParams generateDefaultLayoutParams() {
+        return new LayoutParams();
+    }
+
+    @Override
+    protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
+        return p instanceof MarginLayoutParams
+                ? new LayoutParams((MarginLayoutParams) p)
+                : new LayoutParams(p);
+    }
+
+    @Override
+    protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
+        return p instanceof LayoutParams && super.checkLayoutParams(p);
+    }
+
+    @Override
+    public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
+        return new LayoutParams(getContext(), attrs);
+    }
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+        Parcelable superState = super.onSaveInstanceState();
+
+        SavedState ss = new SavedState(superState);
+        ss.mSlideState = mSlideState;
+
+        return ss;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+        SavedState ss = (SavedState) state;
+        super.onRestoreInstanceState(ss.getSuperState());
+        mSlideState = ss.mSlideState;
+    }
+
+    /**
+     * Current state of the slideable view.
+     */
+    private enum SlideState {
+        EXPANDED,
+        COLLAPSED,
+        ANCHORED,
+        HIDDEN,
+        DRAGGING
+    }
+
+    /**
+     * Listener for monitoring events about sliding panes.
+     */
+    public interface PanelSlideListener {
+        /**
+         * Called when a sliding pane's position changes.
+         *
+         * @param panel       The child view that was moved
+         * @param slideOffset The new offset of this sliding pane within its range, from 0-1
+         */
+        public void onPanelSlide(View panel, float slideOffset);
+
+        /**
+         * Called when a sliding panel becomes slid completely collapsed.
+         *
+         * @param panel The child view that was slid to an collapsed position
+         */
+        public void onPanelCollapsed(View panel);
+
+        /**
+         * Called when a sliding panel becomes slid completely expanded.
+         *
+         * @param panel The child view that was slid to a expanded position
+         */
+        public void onPanelExpanded(View panel);
+
+        /**
+         * Called when a sliding panel becomes anchored.
+         *
+         * @param panel The child view that was slid to a anchored position
+         */
+        public void onPanelAnchored(View panel);
+
+        /**
+         * Called when a sliding panel becomes completely hidden.
+         *
+         * @param panel The child view that was slid to a hidden position
+         */
+        public void onPanelHidden(View panel);
+    }
+
+    /**
+     * No-op stubs for {@link PanelSlideListener}. If you only want to implement a subset
+     * of the listener methods you can extend this instead of implement the full interface.
+     */
+    public static class SimplePanelSlideListener implements PanelSlideListener {
+        @Override
+        public void onPanelSlide(View panel, float slideOffset) {
+        }
+
+        @Override
+        public void onPanelCollapsed(View panel) {
+        }
+
+        @Override
+        public void onPanelExpanded(View panel) {
+        }
+
+        @Override
+        public void onPanelAnchored(View panel) {
+        }
+
+        @Override
+        public void onPanelHidden(View panel) {
+        }
+    }
+
+    public static class LayoutParams extends ViewGroup.MarginLayoutParams {
+        private static final int[] ATTRS = new int[]{
+                android.R.attr.layout_weight
+        };
+
+        public LayoutParams() {
+            super(MATCH_PARENT, MATCH_PARENT);
+        }
+
+        public LayoutParams(int width, int height) {
+            super(width, height);
+        }
+
+        public LayoutParams(android.view.ViewGroup.LayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(MarginLayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(LayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(Context c, AttributeSet attrs) {
+            super(c, attrs);
+
+            final TypedArray a = c.obtainStyledAttributes(attrs, ATTRS);
+            a.recycle();
+        }
+
+    }
+
+    static class SavedState extends BaseSavedState {
+        public static final Parcelable.Creator<SavedState> CREATOR =
+                new Parcelable.Creator<SavedState>() {
+                    @Override
+                    public SavedState createFromParcel(Parcel in) {
+                        return new SavedState(in);
+                    }
+
+                    @Override
+                    public SavedState[] newArray(int size) {
+                        return new SavedState[size];
+                    }
+                };
+        SlideState mSlideState;
+
+        SavedState(Parcelable superState) {
+            super(superState);
+        }
+
+        private SavedState(Parcel in) {
+            super(in);
+            try {
+                mSlideState = Enum.valueOf(SlideState.class, in.readString());
+            } catch (IllegalArgumentException e) {
+                mSlideState = SlideState.COLLAPSED;
+            }
+        }
+
+        @Override
+        public void writeToParcel(Parcel out, int flags) {
+            super.writeToParcel(out, flags);
+            out.writeString(mSlideState.toString());
+        }
+    }
+
+    private class DragHelperCallback extends ViewDragHelper.Callback {
+
+        @Override
+        public boolean tryCaptureView(View child, int pointerId) {
+            if (mIsUnableToDrag) {
+                return false;
+            }
+
+            return child == mSlideableView;
+        }
+
+        @Override
+        public void onViewDragStateChanged(int state) {
+            if (mDragHelper.getViewDragState() == ViewDragHelper.STATE_IDLE) {
+                mSlideOffset = computeSlideOffset(mSlideableView.getTop());
+
+                if (mSlideOffset == 1) {
+                    if (mSlideState != SlideState.EXPANDED) {
+                        updateObscuredViewVisibility();
+                        mSlideState = SlideState.EXPANDED;
+                        dispatchOnPanelExpanded(mSlideableView);
+                    }
+                } else if (mSlideOffset == 0) {
+                    if (mSlideState != SlideState.COLLAPSED) {
+                        mSlideState = SlideState.COLLAPSED;
+                        dispatchOnPanelCollapsed(mSlideableView);
+                    }
+                } else if (mSlideOffset < 0) {
+                    mSlideState = SlideState.HIDDEN;
+                    mSlideableView.setVisibility(View.GONE);
+                    dispatchOnPanelHidden(mSlideableView);
+                } else if (mSlideState != SlideState.ANCHORED) {
+                    updateObscuredViewVisibility();
+                    mSlideState = SlideState.ANCHORED;
+                    dispatchOnPanelAnchored(mSlideableView);
+                }
+            }
+        }
+
+        @Override
+        public void onViewCaptured(View capturedChild, int activePointerId) {
+            setAllChildrenVisible();
+        }
+
+        @Override
+        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
+            onPanelDragged(top);
+            invalidate();
+        }
+
+        @Override
+        public void onViewReleased(View releasedChild, float xvel, float yvel) {
+            int target = 0;
+
+            // direction is always positive if we are sliding in the expanded direction
+            float direction = mIsSlidingUp ? -yvel : yvel;
+
+            if (direction > 0) {
+                // swipe up -> expand
+                target = computePanelTopPosition(1.0f);
+            } else if (direction < 0) {
+                // swipe down -> collapse
+                target = computePanelTopPosition(0.0f);
+            } else if (mAnchorPoint != 1 && mSlideOffset >= (1.f + mAnchorPoint) / 2) {
+                // zero velocity, and far enough from anchor point => expand to the top
+                target = computePanelTopPosition(1.0f);
+            } else if (mAnchorPoint == 1 && mSlideOffset >= 0.5f) {
+                // zero velocity, and far enough from anchor point => expand to the top
+                target = computePanelTopPosition(1.0f);
+            } else if (mAnchorPoint != 1 && mSlideOffset >= mAnchorPoint) {
+                target = computePanelTopPosition(mAnchorPoint);
+            } else if (mAnchorPoint != 1 && mSlideOffset >= mAnchorPoint / 2) {
+                target = computePanelTopPosition(mAnchorPoint);
+            } else {
+                // settle at the bottom
+                target = computePanelTopPosition(0.0f);
+            }
+
+            mDragHelper.settleCapturedViewAt(releasedChild.getLeft(), target);
+            invalidate();
+        }
+
+        @Override
+        public int getViewVerticalDragRange(View child) {
+            return mSlideRange;
+        }
+
+        @Override
+        public int clampViewPositionVertical(View child, int top, int dy) {
+            final int collapsedTop = computePanelTopPosition(0.f);
+            final int expandedTop = computePanelTopPosition(1.0f);
+            if (mIsSlidingUp) {
+                return Math.min(Math.max(top, expandedTop), collapsedTop);
+            } else {
+                return Math.min(Math.max(top, collapsedTop), expandedTop);
+            }
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/slidinguppanel/ViewDragHelper.java b/twelve/src/main/java/com/dolzzo/twelve/slidinguppanel/ViewDragHelper.java
new file mode 100755
index 0000000000..dfd5704d13
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/slidinguppanel/ViewDragHelper.java
@@ -0,0 +1,1430 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package com.dolzzo.twelve.slidinguppanel;
+
+import android.content.Context;
+import android.support.v4.view.MotionEventCompat;
+import android.support.v4.view.VelocityTrackerCompat;
+import android.support.v4.view.ViewCompat;
+import android.support.v4.widget.ScrollerCompat;
+import android.view.MotionEvent;
+import android.view.VelocityTracker;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.animation.Interpolator;
+
+import java.util.Arrays;
+
+/**
+ * ViewDragHelper is a utility class for writing custom ViewGroups. It offers a number
+ * of useful operations and state tracking for allowing a user to drag and reposition
+ * views within their parent ViewGroup.
+ */
+public class ViewDragHelper {
+    /**
+     * A null/invalid pointer ID.
+     */
+    public static final int INVALID_POINTER = -1;
+    /**
+     * A view is not currently being dragged or animating as a result of a fling/snap.
+     */
+    public static final int STATE_IDLE = 0;
+    /**
+     * A view is currently being dragged. The position is currently changing as a result
+     * of user input or simulated user input.
+     */
+    public static final int STATE_DRAGGING = 1;
+    /**
+     * A view is currently settling into place as a result of a fling or
+     * predefined non-interactive motion.
+     */
+    public static final int STATE_SETTLING = 2;
+    /**
+     * Edge flag indicating that the left edge should be affected.
+     */
+    public static final int EDGE_LEFT = 1 << 0;
+    /**
+     * Edge flag indicating that the right edge should be affected.
+     */
+    public static final int EDGE_RIGHT = 1 << 1;
+    /**
+     * Edge flag indicating that the top edge should be affected.
+     */
+    public static final int EDGE_TOP = 1 << 2;
+    /**
+     * Edge flag indicating that the bottom edge should be affected.
+     */
+    public static final int EDGE_BOTTOM = 1 << 3;
+    /**
+     * Edge flag set indicating all edges should be affected.
+     */
+    public static final int EDGE_ALL = EDGE_LEFT | EDGE_TOP | EDGE_RIGHT | EDGE_BOTTOM;
+    /**
+     * Indicates that a check should occur along the horizontal axis
+     */
+    public static final int DIRECTION_HORIZONTAL = 1 << 0;
+    /**
+     * Indicates that a check should occur along the vertical axis
+     */
+    public static final int DIRECTION_VERTICAL = 1 << 1;
+    /**
+     * Indicates that a check should occur along all axes
+     */
+    public static final int DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
+    private static final String TAG = "ViewDragHelper";
+    private static final int EDGE_SIZE = 20; // dp
+
+    private static final int BASE_SETTLE_DURATION = 256; // ms
+    private static final int MAX_SETTLE_DURATION = 600; // ms
+    /**
+     * Interpolator defining the animation curve for mScroller
+     */
+    private static final Interpolator sInterpolator = new Interpolator() {
+        public float getInterpolation(float t) {
+            t -= 1.0f;
+            return t * t * t * t * t + 1.0f;
+        }
+    };
+    private final Callback mCallback;
+    private final ViewGroup mParentView;
+    // Current drag state; idle, dragging or settling
+    private int mDragState;
+    // Distance to travel before a drag may begin
+    private int mTouchSlop;
+    // Last known position/pointer tracking
+    private int mActivePointerId = INVALID_POINTER;
+    private float[] mInitialMotionX;
+    private float[] mInitialMotionY;
+    private float[] mLastMotionX;
+    private float[] mLastMotionY;
+    private int[] mInitialEdgesTouched;
+    private int[] mEdgeDragsInProgress;
+    private int[] mEdgeDragsLocked;
+    private int mPointersDown;
+    private VelocityTracker mVelocityTracker;
+    private float mMaxVelocity;
+    private float mMinVelocity;
+    private int mEdgeSize;
+    private int mTrackingEdges;
+    private ScrollerCompat mScroller;
+    private View mCapturedView;
+    private final Runnable mSetIdleRunnable = new Runnable() {
+        public void run() {
+            setDragState(STATE_IDLE);
+        }
+    };
+    private boolean mReleaseInProgress;
+
+    /**
+     * Apps should use ViewDragHelper.create() to get a new instance.
+     * This will allow VDH to use internal compatibility implementations for different
+     * platform versions.
+     *
+     * @param context   Context to initialize config-dependent params from
+     * @param forParent Parent view to monitor
+     */
+    private ViewDragHelper(Context context, ViewGroup forParent, Callback cb) {
+        if (forParent == null) {
+            throw new IllegalArgumentException("Parent view may not be null");
+        }
+        if (cb == null) {
+            throw new IllegalArgumentException("Callback may not be null");
+        }
+
+        mParentView = forParent;
+        mCallback = cb;
+
+        final ViewConfiguration vc = ViewConfiguration.get(context);
+        final float density = context.getResources().getDisplayMetrics().density;
+        mEdgeSize = (int) (EDGE_SIZE * density + 0.5f);
+
+        mTouchSlop = vc.getScaledTouchSlop();
+        mMaxVelocity = vc.getScaledMaximumFlingVelocity();
+        mMinVelocity = vc.getScaledMinimumFlingVelocity();
+        mScroller = ScrollerCompat.create(context, sInterpolator);
+    }
+
+    /**
+     * Factory method to create a new ViewDragHelper.
+     *
+     * @param forParent Parent view to monitor
+     * @param cb        Callback to provide information and receive events
+     * @return a new ViewDragHelper instance
+     */
+    public static ViewDragHelper create(ViewGroup forParent, Callback cb) {
+        return new ViewDragHelper(forParent.getContext(), forParent, cb);
+    }
+
+    /**
+     * Factory method to create a new ViewDragHelper.
+     *
+     * @param forParent   Parent view to monitor
+     * @param sensitivity Multiplier for how sensitive the helper should be about detecting
+     *                    the start of a drag. Larger values are more sensitive. 1.0f is normal.
+     * @param cb          Callback to provide information and receive events
+     * @return a new ViewDragHelper instance
+     */
+    public static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb) {
+        final ViewDragHelper helper = create(forParent, cb);
+        helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity));
+        return helper;
+    }
+
+    /**
+     * Return the currently configured minimum velocity. Any flings with a magnitude less
+     * than this value in pixels per second. Callback methods accepting a velocity will receive
+     * zero as a velocity value if the real detected velocity was below this threshold.
+     *
+     * @return the minimum velocity that will be detected
+     */
+    public float getMinVelocity() {
+        return mMinVelocity;
+    }
+
+    /**
+     * Set the minimum velocity that will be detected as having a magnitude greater than zero
+     * in pixels per second. Callback methods accepting a velocity will be clamped appropriately.
+     *
+     * @param minVel Minimum velocity to detect
+     */
+    public void setMinVelocity(float minVel) {
+        mMinVelocity = minVel;
+    }
+
+    /**
+     * Retrieve the current drag state of this helper. This will return one of
+     * {@link #STATE_IDLE}, {@link #STATE_DRAGGING} or {@link #STATE_SETTLING}.
+     *
+     * @return The current drag state
+     */
+    public int getViewDragState() {
+        return mDragState;
+    }
+
+    /**
+     * Enable edge tracking for the selected edges of the parent view.
+     * The callback's {@link Callback#onEdgeTouched(int, int)} and
+     * {@link Callback#onEdgeDragStarted(int, int)} methods will only be invoked
+     * for edges for which edge tracking has been enabled.
+     *
+     * @param edgeFlags Combination of edge flags describing the edges to watch
+     * @see #EDGE_LEFT
+     * @see #EDGE_TOP
+     * @see #EDGE_RIGHT
+     * @see #EDGE_BOTTOM
+     */
+    public void setEdgeTrackingEnabled(int edgeFlags) {
+        mTrackingEdges = edgeFlags;
+    }
+
+    /**
+     * Return the size of an edge. This is the range in pixels along the edges of this view
+     * that will actively detect edge touches or drags if edge tracking is enabled.
+     *
+     * @return The size of an edge in pixels
+     * @see #setEdgeTrackingEnabled(int)
+     */
+    public int getEdgeSize() {
+        return mEdgeSize;
+    }
+
+    /**
+     * Capture a specific child view for dragging within the parent. The callback will be notified
+     * but {@link Callback#tryCaptureView(android.view.View, int)} will not be asked permission to
+     * capture this view.
+     *
+     * @param childView       Child view to capture
+     * @param activePointerId ID of the pointer that is dragging the captured child view
+     */
+    public void captureChildView(View childView, int activePointerId) {
+        if (childView.getParent() != mParentView) {
+            throw new IllegalArgumentException("captureChildView: parameter must be a descendant " +
+                    "of the ViewDragHelper's tracked parent view (" + mParentView + ")");
+        }
+
+        mCapturedView = childView;
+        mActivePointerId = activePointerId;
+        mCallback.onViewCaptured(childView, activePointerId);
+        setDragState(STATE_DRAGGING);
+    }
+
+    /**
+     * @return The currently captured view, or null if no view has been captured.
+     */
+    public View getCapturedView() {
+        return mCapturedView;
+    }
+
+    /**
+     * @return The ID of the pointer currently dragging the captured view,
+     * or {@link #INVALID_POINTER}.
+     */
+    public int getActivePointerId() {
+        return mActivePointerId;
+    }
+
+    /**
+     * @return The minimum distance in pixels that the user must travel to initiate a drag
+     */
+    public int getTouchSlop() {
+        return mTouchSlop;
+    }
+
+    /**
+     * The result of a call to this method is equivalent to
+     * {@link #processTouchEvent(android.view.MotionEvent)} receiving an ACTION_CANCEL event.
+     */
+    public void cancel() {
+        mActivePointerId = INVALID_POINTER;
+        clearMotionHistory();
+
+        if (mVelocityTracker != null) {
+            mVelocityTracker.recycle();
+            mVelocityTracker = null;
+        }
+    }
+
+    /**
+     * {@link #cancel()}, but also abort all motion in progress and snap to the end of any
+     * animation.
+     */
+    public void abort() {
+        cancel();
+        if (mDragState == STATE_SETTLING) {
+            final int oldX = mScroller.getCurrX();
+            final int oldY = mScroller.getCurrY();
+            mScroller.abortAnimation();
+            final int newX = mScroller.getCurrX();
+            final int newY = mScroller.getCurrY();
+            mCallback.onViewPositionChanged(mCapturedView, newX, newY, newX - oldX, newY - oldY);
+        }
+        setDragState(STATE_IDLE);
+    }
+
+    /**
+     * Animate the view <code>child</code> to the given (left, top) position.
+     * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}
+     * on each subsequent frame to continue the motion until it returns false. If this method
+     * returns false there is no further work to do to complete the movement.
+     * <p>
+     * <p>This operation does not count as a capture event, though {@link #getCapturedView()}
+     * will still report the sliding view while the slide is in progress.</p>
+     *
+     * @param child     Child view to capture and animate
+     * @param finalLeft Final left position of child
+     * @param finalTop  Final top position of child
+     * @return true if animation should continue through {@link #continueSettling(boolean)} calls
+     */
+    public boolean smoothSlideViewTo(View child, int finalLeft, int finalTop) {
+        mCapturedView = child;
+        mActivePointerId = INVALID_POINTER;
+
+        return forceSettleCapturedViewAt(finalLeft, finalTop, 0, 0);
+    }
+
+    /**
+     * Settle the captured view at the given (left, top) position.
+     * The appropriate velocity from prior motion will be taken into account.
+     * If this method returns true, the caller should invoke {@link #continueSettling(boolean)}
+     * on each subsequent frame to continue the motion until it returns false. If this method
+     * returns false there is no further work to do to complete the movement.
+     *
+     * @param finalLeft Settled left edge position for the captured view
+     * @param finalTop  Settled top edge position for the captured view
+     * @return true if animation should continue through {@link #continueSettling(boolean)} calls
+     */
+    public boolean settleCapturedViewAt(int finalLeft, int finalTop) {
+        if (!mReleaseInProgress) {
+            throw new IllegalStateException("Cannot settleCapturedViewAt outside of a call to " +
+                    "Callback#onViewReleased");
+        }
+
+        return forceSettleCapturedViewAt(finalLeft, finalTop,
+                (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),
+                (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId));
+    }
+
+    /**
+     * Settle the captured view at the given (left, top) position.
+     *
+     * @param finalLeft Target left position for the captured view
+     * @param finalTop  Target top position for the captured view
+     * @param xvel      Horizontal velocity
+     * @param yvel      Vertical velocity
+     * @return true if animation should continue through {@link #continueSettling(boolean)} calls
+     */
+    private boolean forceSettleCapturedViewAt(int finalLeft, int finalTop, int xvel, int yvel) {
+        final int startLeft = mCapturedView.getLeft();
+        final int startTop = mCapturedView.getTop();
+        final int dx = finalLeft - startLeft;
+        final int dy = finalTop - startTop;
+
+        if (dx == 0 && dy == 0) {
+            // Nothing to do. Send callbacks, be done.
+            mScroller.abortAnimation();
+            setDragState(STATE_IDLE);
+            return false;
+        }
+
+        final int duration = computeSettleDuration(mCapturedView, dx, dy, xvel, yvel);
+        mScroller.startScroll(startLeft, startTop, dx, dy, duration);
+
+        setDragState(STATE_SETTLING);
+        return true;
+    }
+
+    private int computeSettleDuration(View child, int dx, int dy, int xvel, int yvel) {
+        xvel = clampMag(xvel, (int) mMinVelocity, (int) mMaxVelocity);
+        yvel = clampMag(yvel, (int) mMinVelocity, (int) mMaxVelocity);
+        final int absDx = Math.abs(dx);
+        final int absDy = Math.abs(dy);
+        final int absXVel = Math.abs(xvel);
+        final int absYVel = Math.abs(yvel);
+        final int addedVel = absXVel + absYVel;
+        final int addedDistance = absDx + absDy;
+
+        final float xweight = xvel != 0 ? (float) absXVel / addedVel :
+                (float) absDx / addedDistance;
+        final float yweight = yvel != 0 ? (float) absYVel / addedVel :
+                (float) absDy / addedDistance;
+
+        int xduration = computeAxisDuration(dx, xvel, mCallback.getViewHorizontalDragRange(child));
+        int yduration = computeAxisDuration(dy, yvel, mCallback.getViewVerticalDragRange(child));
+
+        return (int) (xduration * xweight + yduration * yweight);
+    }
+
+    private int computeAxisDuration(int delta, int velocity, int motionRange) {
+        if (delta == 0) {
+            return 0;
+        }
+
+        final int width = mParentView.getWidth();
+        final int halfWidth = width / 2;
+        final float distanceRatio = Math.min(1f, (float) Math.abs(delta) / width);
+        final float distance = halfWidth + halfWidth *
+                distanceInfluenceForSnapDuration(distanceRatio);
+
+        int duration;
+        velocity = Math.abs(velocity);
+        if (velocity > 0) {
+            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
+        } else {
+            final float range = (float) Math.abs(delta) / motionRange;
+            duration = (int) ((range + 1) * BASE_SETTLE_DURATION);
+        }
+        return Math.min(duration, MAX_SETTLE_DURATION);
+    }
+
+    /**
+     * Clamp the magnitude of value for absMin and absMax.
+     * If the value is below the minimum, it will be clamped to zero.
+     * If the value is above the maximum, it will be clamped to the maximum.
+     *
+     * @param value  Value to clamp
+     * @param absMin Absolute value of the minimum significant value to return
+     * @param absMax Absolute value of the maximum value to return
+     * @return The clamped value with the same sign as <code>value</code>
+     */
+    private int clampMag(int value, int absMin, int absMax) {
+        final int absValue = Math.abs(value);
+        if (absValue < absMin) return 0;
+        if (absValue > absMax) return value > 0 ? absMax : -absMax;
+        return value;
+    }
+
+    /**
+     * Clamp the magnitude of value for absMin and absMax.
+     * If the value is below the minimum, it will be clamped to zero.
+     * If the value is above the maximum, it will be clamped to the maximum.
+     *
+     * @param value  Value to clamp
+     * @param absMin Absolute value of the minimum significant value to return
+     * @param absMax Absolute value of the maximum value to return
+     * @return The clamped value with the same sign as <code>value</code>
+     */
+    private float clampMag(float value, float absMin, float absMax) {
+        final float absValue = Math.abs(value);
+        if (absValue < absMin) return 0;
+        if (absValue > absMax) return value > 0 ? absMax : -absMax;
+        return value;
+    }
+
+    private float distanceInfluenceForSnapDuration(float f) {
+        f -= 0.5f; // center the values about 0.
+        f *= 0.3f * Math.PI / 2.0f;
+        return (float) Math.sin(f);
+    }
+
+    /**
+     * Settle the captured view based on standard free-moving fling behavior.
+     * The caller should invoke {@link #continueSettling(boolean)} on each subsequent frame
+     * to continue the motion until it returns false.
+     *
+     * @param minLeft Minimum X position for the view's left edge
+     * @param minTop  Minimum Y position for the view's top edge
+     * @param maxLeft Maximum X position for the view's left edge
+     * @param maxTop  Maximum Y position for the view's top edge
+     */
+    public void flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop) {
+        if (!mReleaseInProgress) {
+            throw new IllegalStateException("Cannot flingCapturedView outside of a call to " +
+                    "Callback#onViewReleased");
+        }
+
+        mScroller.fling(mCapturedView.getLeft(), mCapturedView.getTop(),
+                (int) VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),
+                (int) VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),
+                minLeft, maxLeft, minTop, maxTop);
+
+        setDragState(STATE_SETTLING);
+    }
+
+    /**
+     * Move the captured settling view by the appropriate amount for the current time.
+     * If <code>continueSettling</code> returns true, the caller should call it again
+     * on the next frame to continue.
+     *
+     * @param deferCallbacks true if state callbacks should be deferred via posted message.
+     *                       Set this to true if you are calling this method from
+     *                       {@link android.view.View#computeScroll()} or similar methods
+     *                       invoked as part of layout or drawing.
+     * @return true if settle is still in progress
+     */
+    public boolean continueSettling(boolean deferCallbacks) {
+        if (mDragState == STATE_SETTLING) {
+            boolean keepGoing = mScroller.computeScrollOffset();
+            final int x = mScroller.getCurrX();
+            final int y = mScroller.getCurrY();
+            final int dx = x - mCapturedView.getLeft();
+            final int dy = y - mCapturedView.getTop();
+
+            if (dx != 0) {
+                mCapturedView.offsetLeftAndRight(dx);
+            }
+            if (dy != 0) {
+                mCapturedView.offsetTopAndBottom(dy);
+            }
+
+            if (dx != 0 || dy != 0) {
+                mCallback.onViewPositionChanged(mCapturedView, x, y, dx, dy);
+            }
+
+            if (keepGoing && x == mScroller.getFinalX() && y == mScroller.getFinalY()) {
+                // Close enough. The interpolator/scroller might think we're still moving
+                // but the user sure doesn't.
+                mScroller.abortAnimation();
+                keepGoing = mScroller.isFinished();
+            }
+
+            if (!keepGoing) {
+                if (deferCallbacks) {
+                    mParentView.post(mSetIdleRunnable);
+                } else {
+                    setDragState(STATE_IDLE);
+                }
+            }
+        }
+
+        return mDragState == STATE_SETTLING;
+    }
+
+    /**
+     * Like all callback events this must happen on the UI thread, but release
+     * involves some extra semantics. During a release (mReleaseInProgress)
+     * is the only time it is valid to call {@link #settleCapturedViewAt(int, int)}
+     * or {@link #flingCapturedView(int, int, int, int)}.
+     */
+    private void dispatchViewReleased(float xvel, float yvel) {
+        mReleaseInProgress = true;
+        mCallback.onViewReleased(mCapturedView, xvel, yvel);
+        mReleaseInProgress = false;
+
+        if (mDragState == STATE_DRAGGING) {
+            // onViewReleased didn't call a method that would have changed this. Go idle.
+            setDragState(STATE_IDLE);
+        }
+    }
+
+    private void clearMotionHistory() {
+        if (mInitialMotionX == null) {
+            return;
+        }
+        Arrays.fill(mInitialMotionX, 0);
+        Arrays.fill(mInitialMotionY, 0);
+        Arrays.fill(mLastMotionX, 0);
+        Arrays.fill(mLastMotionY, 0);
+        Arrays.fill(mInitialEdgesTouched, 0);
+        Arrays.fill(mEdgeDragsInProgress, 0);
+        Arrays.fill(mEdgeDragsLocked, 0);
+        mPointersDown = 0;
+    }
+
+    private void clearMotionHistory(int pointerId) {
+        if (mInitialMotionX == null) {
+            return;
+        }
+        mInitialMotionX[pointerId] = 0;
+        mInitialMotionY[pointerId] = 0;
+        mLastMotionX[pointerId] = 0;
+        mLastMotionY[pointerId] = 0;
+        mInitialEdgesTouched[pointerId] = 0;
+        mEdgeDragsInProgress[pointerId] = 0;
+        mEdgeDragsLocked[pointerId] = 0;
+        mPointersDown &= ~(1 << pointerId);
+    }
+
+    private void ensureMotionHistorySizeForId(int pointerId) {
+        if (mInitialMotionX == null || mInitialMotionX.length <= pointerId) {
+            float[] imx = new float[pointerId + 1];
+            float[] imy = new float[pointerId + 1];
+            float[] lmx = new float[pointerId + 1];
+            float[] lmy = new float[pointerId + 1];
+            int[] iit = new int[pointerId + 1];
+            int[] edip = new int[pointerId + 1];
+            int[] edl = new int[pointerId + 1];
+
+            if (mInitialMotionX != null) {
+                System.arraycopy(mInitialMotionX, 0, imx, 0, mInitialMotionX.length);
+                System.arraycopy(mInitialMotionY, 0, imy, 0, mInitialMotionY.length);
+                System.arraycopy(mLastMotionX, 0, lmx, 0, mLastMotionX.length);
+                System.arraycopy(mLastMotionY, 0, lmy, 0, mLastMotionY.length);
+                System.arraycopy(mInitialEdgesTouched, 0, iit, 0, mInitialEdgesTouched.length);
+                System.arraycopy(mEdgeDragsInProgress, 0, edip, 0, mEdgeDragsInProgress.length);
+                System.arraycopy(mEdgeDragsLocked, 0, edl, 0, mEdgeDragsLocked.length);
+            }
+
+            mInitialMotionX = imx;
+            mInitialMotionY = imy;
+            mLastMotionX = lmx;
+            mLastMotionY = lmy;
+            mInitialEdgesTouched = iit;
+            mEdgeDragsInProgress = edip;
+            mEdgeDragsLocked = edl;
+        }
+    }
+
+    private void saveInitialMotion(float x, float y, int pointerId) {
+        ensureMotionHistorySizeForId(pointerId);
+        mInitialMotionX[pointerId] = mLastMotionX[pointerId] = x;
+        mInitialMotionY[pointerId] = mLastMotionY[pointerId] = y;
+        mInitialEdgesTouched[pointerId] = getEdgesTouched((int) x, (int) y);
+        mPointersDown |= 1 << pointerId;
+    }
+
+    private void saveLastMotion(MotionEvent ev) {
+        final int pointerCount = MotionEventCompat.getPointerCount(ev);
+        for (int i = 0; i < pointerCount; i++) {
+            final int pointerId = MotionEventCompat.getPointerId(ev, i);
+            final float x = MotionEventCompat.getX(ev, i);
+            final float y = MotionEventCompat.getY(ev, i);
+            mLastMotionX[pointerId] = x;
+            mLastMotionY[pointerId] = y;
+        }
+    }
+
+    /**
+     * Check if the given pointer ID represents a pointer that is currently down (to the best
+     * of the ViewDragHelper's knowledge).
+     * <p>
+     * <p>The state used to report this information is populated by the methods
+     * {@link #shouldInterceptTouchEvent(android.view.MotionEvent)} or
+     * {@link #processTouchEvent(android.view.MotionEvent)}. If one of these methods has not
+     * been called for all relevant MotionEvents to track, the information reported
+     * by this method may be stale or incorrect.</p>
+     *
+     * @param pointerId pointer ID to check; corresponds to IDs provided by MotionEvent
+     * @return true if the pointer with the given ID is still down
+     */
+    public boolean isPointerDown(int pointerId) {
+        return (mPointersDown & 1 << pointerId) != 0;
+    }
+
+    void setDragState(int state) {
+        if (mDragState != state) {
+            mDragState = state;
+            mCallback.onViewDragStateChanged(state);
+            if (state == STATE_IDLE) {
+                mCapturedView = null;
+            }
+        }
+    }
+
+    /**
+     * Attempt to capture the view with the given pointer ID. The callback will be involved.
+     * This will put us into the "dragging" state. If we've already captured this view with
+     * this pointer this method will immediately return true without consulting the callback.
+     *
+     * @param toCapture View to capture
+     * @param pointerId Pointer to capture with
+     * @return true if capture was successful
+     */
+    boolean tryCaptureViewForDrag(View toCapture, int pointerId) {
+        if (toCapture == mCapturedView && mActivePointerId == pointerId) {
+            // Already done!
+            return true;
+        }
+        if (toCapture != null && mCallback.tryCaptureView(toCapture, pointerId)) {
+            mActivePointerId = pointerId;
+            captureChildView(toCapture, pointerId);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Tests scrollability within child views of v given a delta of dx.
+     *
+     * @param v      View to test for horizontal scrollability
+     * @param checkV Whether the view v passed should itself be checked for scrollability (true),
+     *               or just its children (false).
+     * @param dx     Delta scrolled in pixels along the X axis
+     * @param dy     Delta scrolled in pixels along the Y axis
+     * @param x      X coordinate of the active touch point
+     * @param y      Y coordinate of the active touch point
+     * @return true if child views of v can be scrolled by delta of dx.
+     */
+    protected boolean canScroll(View v, boolean checkV, int dx, int dy, int x, int y) {
+        if (v instanceof ViewGroup) {
+            final ViewGroup group = (ViewGroup) v;
+            final int scrollX = v.getScrollX();
+            final int scrollY = v.getScrollY();
+            final int count = group.getChildCount();
+            // Count backwards - let topmost views consume scroll distance first.
+            for (int i = count - 1; i >= 0; i--) {
+                // TODO: Add versioned support here for transformed views.
+                // This will not work for transformed views in Honeycomb+
+                final View child = group.getChildAt(i);
+                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&
+                        y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&
+                        canScroll(child, true, dx, dy, x + scrollX - child.getLeft(),
+                                y + scrollY - child.getTop())) {
+                    return true;
+                }
+            }
+        }
+
+        return checkV && (ViewCompat.canScrollHorizontally(v, -dx) ||
+                ViewCompat.canScrollVertically(v, -dy));
+    }
+
+    /**
+     * Check if this event as provided to the parent view's onInterceptTouchEvent should
+     * cause the parent to intercept the touch event stream.
+     *
+     * @param ev MotionEvent provided to onInterceptTouchEvent
+     * @return true if the parent view should return true from onInterceptTouchEvent
+     */
+    public boolean shouldInterceptTouchEvent(MotionEvent ev) {
+        final int action = MotionEventCompat.getActionMasked(ev);
+        final int actionIndex = MotionEventCompat.getActionIndex(ev);
+
+        if (action == MotionEvent.ACTION_DOWN) {
+            // Reset things for a new event stream, just in case we didn't get
+            // the whole previous stream.
+            cancel();
+        }
+
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(ev);
+
+        switch (action) {
+            case MotionEvent.ACTION_DOWN: {
+                final float x = ev.getX();
+                final float y = ev.getY();
+                final int pointerId = MotionEventCompat.getPointerId(ev, 0);
+                saveInitialMotion(x, y, pointerId);
+
+                final View toCapture = findTopChildUnder((int) x, (int) y);
+
+                // Catch a settling view if possible.
+                if (toCapture == mCapturedView && mDragState == STATE_SETTLING) {
+                    tryCaptureViewForDrag(toCapture, pointerId);
+                }
+
+                final int edgesTouched = mInitialEdgesTouched[pointerId];
+                if ((edgesTouched & mTrackingEdges) != 0) {
+                    mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);
+                }
+                break;
+            }
+
+            case MotionEventCompat.ACTION_POINTER_DOWN: {
+                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);
+                final float x = MotionEventCompat.getX(ev, actionIndex);
+                final float y = MotionEventCompat.getY(ev, actionIndex);
+
+                saveInitialMotion(x, y, pointerId);
+
+                // A ViewDragHelper can only manipulate one view at a time.
+                if (mDragState == STATE_IDLE) {
+                    final int edgesTouched = mInitialEdgesTouched[pointerId];
+                    if ((edgesTouched & mTrackingEdges) != 0) {
+                        mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);
+                    }
+                } else if (mDragState == STATE_SETTLING) {
+                    // Catch a settling view if possible.
+                    final View toCapture = findTopChildUnder((int) x, (int) y);
+                    if (toCapture == mCapturedView) {
+                        tryCaptureViewForDrag(toCapture, pointerId);
+                    }
+                }
+                break;
+            }
+
+            case MotionEvent.ACTION_MOVE: {
+                // First to cross a touch slop over a draggable view wins. Also report edge drags.
+                final int pointerCount = MotionEventCompat.getPointerCount(ev);
+                for (int i = 0; i < pointerCount && mInitialMotionX != null && mInitialMotionY != null; i++) {
+                    final int pointerId = MotionEventCompat.getPointerId(ev, i);
+                    final float x = MotionEventCompat.getX(ev, i);
+                    final float y = MotionEventCompat.getY(ev, i);
+                    final float dx = x - mInitialMotionX[pointerId];
+                    final float dy = y - mInitialMotionY[pointerId];
+
+                    reportNewEdgeDrags(dx, dy, pointerId);
+                    if (mDragState == STATE_DRAGGING) {
+                        // Callback might have started an edge drag
+                        break;
+                    }
+
+                    final View toCapture = findTopChildUnder((int) mInitialMotionX[pointerId], (int) mInitialMotionY[pointerId]);
+                    if (toCapture != null && checkTouchSlop(toCapture, dx, dy) &&
+                            tryCaptureViewForDrag(toCapture, pointerId)) {
+                        break;
+                    }
+                }
+                saveLastMotion(ev);
+                break;
+            }
+
+            case MotionEventCompat.ACTION_POINTER_UP: {
+                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);
+                clearMotionHistory(pointerId);
+                break;
+            }
+
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_CANCEL: {
+                cancel();
+                break;
+            }
+        }
+
+        return mDragState == STATE_DRAGGING;
+    }
+
+    /**
+     * Process a touch event received by the parent view. This method will dispatch callback events
+     * as needed before returning. The parent view's onTouchEvent implementation should call this.
+     *
+     * @param ev The touch event received by the parent view
+     */
+    public void processTouchEvent(MotionEvent ev) {
+        final int action = MotionEventCompat.getActionMasked(ev);
+        final int actionIndex = MotionEventCompat.getActionIndex(ev);
+
+        if (action == MotionEvent.ACTION_DOWN) {
+            // Reset things for a new event stream, just in case we didn't get
+            // the whole previous stream.
+            cancel();
+        }
+
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(ev);
+
+        switch (action) {
+            case MotionEvent.ACTION_DOWN: {
+                final float x = ev.getX();
+                final float y = ev.getY();
+                final int pointerId = MotionEventCompat.getPointerId(ev, 0);
+                final View toCapture = findTopChildUnder((int) x, (int) y);
+
+                saveInitialMotion(x, y, pointerId);
+
+                // Since the parent is already directly processing this touch event,
+                // there is no reason to delay for a slop before dragging.
+                // Start immediately if possible.
+                tryCaptureViewForDrag(toCapture, pointerId);
+
+                final int edgesTouched = mInitialEdgesTouched[pointerId];
+                if ((edgesTouched & mTrackingEdges) != 0) {
+                    mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);
+                }
+                break;
+            }
+
+            case MotionEventCompat.ACTION_POINTER_DOWN: {
+                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);
+                final float x = MotionEventCompat.getX(ev, actionIndex);
+                final float y = MotionEventCompat.getY(ev, actionIndex);
+
+                saveInitialMotion(x, y, pointerId);
+
+                // A ViewDragHelper can only manipulate one view at a time.
+                if (mDragState == STATE_IDLE) {
+                    // If we're idle we can do anything! Treat it like a normal down event.
+
+                    final View toCapture = findTopChildUnder((int) x, (int) y);
+                    tryCaptureViewForDrag(toCapture, pointerId);
+
+                    final int edgesTouched = mInitialEdgesTouched[pointerId];
+                    if ((edgesTouched & mTrackingEdges) != 0) {
+                        mCallback.onEdgeTouched(edgesTouched & mTrackingEdges, pointerId);
+                    }
+                } else if (isCapturedViewUnder((int) x, (int) y)) {
+                    // We're still tracking a captured view. If the same view is under this
+                    // point, we'll swap to controlling it with this pointer instead.
+                    // (This will still work if we're "catching" a settling view.)
+
+                    tryCaptureViewForDrag(mCapturedView, pointerId);
+                }
+                break;
+            }
+
+            case MotionEvent.ACTION_MOVE: {
+                if (mDragState == STATE_DRAGGING) {
+                    final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId);
+                    final float x = MotionEventCompat.getX(ev, index);
+                    final float y = MotionEventCompat.getY(ev, index);
+                    final int idx = (int) (x - mLastMotionX[mActivePointerId]);
+                    final int idy = (int) (y - mLastMotionY[mActivePointerId]);
+
+                    dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy);
+
+                    saveLastMotion(ev);
+                } else {
+                    // Check to see if any pointer is now over a draggable view.
+                    final int pointerCount = MotionEventCompat.getPointerCount(ev);
+                    for (int i = 0; i < pointerCount; i++) {
+                        final int pointerId = MotionEventCompat.getPointerId(ev, i);
+                        final float x = MotionEventCompat.getX(ev, i);
+                        final float y = MotionEventCompat.getY(ev, i);
+                        final float dx = x - mInitialMotionX[pointerId];
+                        final float dy = y - mInitialMotionY[pointerId];
+
+                        reportNewEdgeDrags(dx, dy, pointerId);
+                        if (mDragState == STATE_DRAGGING) {
+                            // Callback might have started an edge drag.
+                            break;
+                        }
+
+                        final View toCapture = findTopChildUnder((int) x, (int) y);
+                        if (checkTouchSlop(toCapture, dx, dy) &&
+                                tryCaptureViewForDrag(toCapture, pointerId)) {
+                            break;
+                        }
+                    }
+                    saveLastMotion(ev);
+                }
+                break;
+            }
+
+            case MotionEventCompat.ACTION_POINTER_UP: {
+                final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex);
+                if (mDragState == STATE_DRAGGING && pointerId == mActivePointerId) {
+                    // Try to find another pointer that's still holding on to the captured view.
+                    int newActivePointer = INVALID_POINTER;
+                    final int pointerCount = MotionEventCompat.getPointerCount(ev);
+                    for (int i = 0; i < pointerCount; i++) {
+                        final int id = MotionEventCompat.getPointerId(ev, i);
+                        if (id == mActivePointerId) {
+                            // This one's going away, skip.
+                            continue;
+                        }
+
+                        final float x = MotionEventCompat.getX(ev, i);
+                        final float y = MotionEventCompat.getY(ev, i);
+                        if (findTopChildUnder((int) x, (int) y) == mCapturedView &&
+                                tryCaptureViewForDrag(mCapturedView, id)) {
+                            newActivePointer = mActivePointerId;
+                            break;
+                        }
+                    }
+
+                    if (newActivePointer == INVALID_POINTER) {
+                        // We didn't find another pointer still touching the view, release it.
+                        releaseViewForPointerUp();
+                    }
+                }
+                clearMotionHistory(pointerId);
+                break;
+            }
+
+            case MotionEvent.ACTION_UP: {
+                if (mDragState == STATE_DRAGGING) {
+                    releaseViewForPointerUp();
+                }
+                cancel();
+                break;
+            }
+
+            case MotionEvent.ACTION_CANCEL: {
+                if (mDragState == STATE_DRAGGING) {
+                    dispatchViewReleased(0, 0);
+                }
+                cancel();
+                break;
+            }
+        }
+    }
+
+    private void reportNewEdgeDrags(float dx, float dy, int pointerId) {
+        int dragsStarted = 0;
+        if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_LEFT)) {
+            dragsStarted |= EDGE_LEFT;
+        }
+        if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_TOP)) {
+            dragsStarted |= EDGE_TOP;
+        }
+        if (checkNewEdgeDrag(dx, dy, pointerId, EDGE_RIGHT)) {
+            dragsStarted |= EDGE_RIGHT;
+        }
+        if (checkNewEdgeDrag(dy, dx, pointerId, EDGE_BOTTOM)) {
+            dragsStarted |= EDGE_BOTTOM;
+        }
+
+        if (dragsStarted != 0) {
+            mEdgeDragsInProgress[pointerId] |= dragsStarted;
+            mCallback.onEdgeDragStarted(dragsStarted, pointerId);
+        }
+    }
+
+    private boolean checkNewEdgeDrag(float delta, float odelta, int pointerId, int edge) {
+        final float absDelta = Math.abs(delta);
+        final float absODelta = Math.abs(odelta);
+
+        if ((mInitialEdgesTouched[pointerId] & edge) != edge || (mTrackingEdges & edge) == 0 ||
+                (mEdgeDragsLocked[pointerId] & edge) == edge ||
+                (mEdgeDragsInProgress[pointerId] & edge) == edge ||
+                (absDelta <= mTouchSlop && absODelta <= mTouchSlop)) {
+            return false;
+        }
+        if (absDelta < absODelta * 0.5f && mCallback.onEdgeLock(edge)) {
+            mEdgeDragsLocked[pointerId] |= edge;
+            return false;
+        }
+        return (mEdgeDragsInProgress[pointerId] & edge) == 0 && absDelta > mTouchSlop;
+    }
+
+    /**
+     * Check if we've crossed a reasonable touch slop for the given child view.
+     * If the child cannot be dragged along the horizontal or vertical axis, motion
+     * along that axis will not count toward the slop check.
+     *
+     * @param child Child to check
+     * @param dx    Motion since initial position along X axis
+     * @param dy    Motion since initial position along Y axis
+     * @return true if the touch slop has been crossed
+     */
+    private boolean checkTouchSlop(View child, float dx, float dy) {
+        if (child == null) {
+            return false;
+        }
+        final boolean checkHorizontal = mCallback.getViewHorizontalDragRange(child) > 0;
+        final boolean checkVertical = mCallback.getViewVerticalDragRange(child) > 0;
+
+        if (checkHorizontal && checkVertical) {
+            return dx * dx + dy * dy > mTouchSlop * mTouchSlop;
+        } else if (checkHorizontal) {
+            return Math.abs(dx) > mTouchSlop;
+        } else if (checkVertical) {
+            return Math.abs(dy) > mTouchSlop;
+        }
+        return false;
+    }
+
+    /**
+     * Check if any pointer tracked in the current gesture has crossed
+     * the required slop threshold.
+     * <p>
+     * <p>This depends on internal state populated by
+     * {@link #shouldInterceptTouchEvent(android.view.MotionEvent)} or
+     * {@link #processTouchEvent(android.view.MotionEvent)}. You should only rely on
+     * the results of this method after all currently available touch data
+     * has been provided to one of these two methods.</p>
+     *
+     * @param directions Combination of direction flags, see {@link #DIRECTION_HORIZONTAL},
+     *                   {@link #DIRECTION_VERTICAL}, {@link #DIRECTION_ALL}
+     * @return true if the slop threshold has been crossed, false otherwise
+     */
+    public boolean checkTouchSlop(int directions) {
+        final int count = mInitialMotionX.length;
+        for (int i = 0; i < count; i++) {
+            if (checkTouchSlop(directions, i)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check if the specified pointer tracked in the current gesture has crossed
+     * the required slop threshold.
+     * <p>
+     * <p>This depends on internal state populated by
+     * {@link #shouldInterceptTouchEvent(android.view.MotionEvent)} or
+     * {@link #processTouchEvent(android.view.MotionEvent)}. You should only rely on
+     * the results of this method after all currently available touch data
+     * has been provided to one of these two methods.</p>
+     *
+     * @param directions Combination of direction flags, see {@link #DIRECTION_HORIZONTAL},
+     *                   {@link #DIRECTION_VERTICAL}, {@link #DIRECTION_ALL}
+     * @param pointerId  ID of the pointer to slop check as specified by MotionEvent
+     * @return true if the slop threshold has been crossed, false otherwise
+     */
+    public boolean checkTouchSlop(int directions, int pointerId) {
+        if (!isPointerDown(pointerId)) {
+            return false;
+        }
+
+        final boolean checkHorizontal = (directions & DIRECTION_HORIZONTAL) == DIRECTION_HORIZONTAL;
+        final boolean checkVertical = (directions & DIRECTION_VERTICAL) == DIRECTION_VERTICAL;
+
+        final float dx = mLastMotionX[pointerId] - mInitialMotionX[pointerId];
+        final float dy = mLastMotionY[pointerId] - mInitialMotionY[pointerId];
+
+        if (checkHorizontal && checkVertical) {
+            return dx * dx + dy * dy > mTouchSlop * mTouchSlop;
+        } else if (checkHorizontal) {
+            return Math.abs(dx) > mTouchSlop;
+        } else if (checkVertical) {
+            return Math.abs(dy) > mTouchSlop;
+        }
+        return false;
+    }
+
+    /**
+     * Check if any of the edges specified were initially touched in the currently active gesture.
+     * If there is no currently active gesture this method will return false.
+     *
+     * @param edges Edges to check for an initial edge touch. See {@link #EDGE_LEFT},
+     *              {@link #EDGE_TOP}, {@link #EDGE_RIGHT}, {@link #EDGE_BOTTOM} and
+     *              {@link #EDGE_ALL}
+     * @return true if any of the edges specified were initially touched in the current gesture
+     */
+    public boolean isEdgeTouched(int edges) {
+        final int count = mInitialEdgesTouched.length;
+        for (int i = 0; i < count; i++) {
+            if (isEdgeTouched(edges, i)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check if any of the edges specified were initially touched by the pointer with
+     * the specified ID. If there is no currently active gesture or if there is no pointer with
+     * the given ID currently down this method will return false.
+     *
+     * @param edges Edges to check for an initial edge touch. See {@link #EDGE_LEFT},
+     *              {@link #EDGE_TOP}, {@link #EDGE_RIGHT}, {@link #EDGE_BOTTOM} and
+     *              {@link #EDGE_ALL}
+     * @return true if any of the edges specified were initially touched in the current gesture
+     */
+    public boolean isEdgeTouched(int edges, int pointerId) {
+        return isPointerDown(pointerId) && (mInitialEdgesTouched[pointerId] & edges) != 0;
+    }
+
+    private void releaseViewForPointerUp() {
+        mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity);
+        final float xvel = clampMag(
+                VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId),
+                mMinVelocity, mMaxVelocity);
+        final float yvel = clampMag(
+                VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId),
+                mMinVelocity, mMaxVelocity);
+        dispatchViewReleased(xvel, yvel);
+    }
+
+    private void dragTo(int left, int top, int dx, int dy) {
+        int clampedX = left;
+        int clampedY = top;
+        final int oldLeft = mCapturedView.getLeft();
+        final int oldTop = mCapturedView.getTop();
+        if (dx != 0) {
+            clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx);
+            mCapturedView.offsetLeftAndRight(clampedX - oldLeft);
+        }
+        if (dy != 0) {
+            clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy);
+            mCapturedView.offsetTopAndBottom(clampedY - oldTop);
+        }
+
+        if (dx != 0 || dy != 0) {
+            final int clampedDx = clampedX - oldLeft;
+            final int clampedDy = clampedY - oldTop;
+            mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY,
+                    clampedDx, clampedDy);
+        }
+    }
+
+    /**
+     * Determine if the currently captured view is under the given point in the
+     * parent view's coordinate system. If there is no captured view this method
+     * will return false.
+     *
+     * @param x X position to test in the parent's coordinate system
+     * @param y Y position to test in the parent's coordinate system
+     * @return true if the captured view is under the given point, false otherwise
+     */
+    public boolean isCapturedViewUnder(int x, int y) {
+        return isViewUnder(mCapturedView, x, y);
+    }
+
+    /**
+     * Determine if the supplied view is under the given point in the
+     * parent view's coordinate system.
+     *
+     * @param view Child view of the parent to hit test
+     * @param x    X position to test in the parent's coordinate system
+     * @param y    Y position to test in the parent's coordinate system
+     * @return true if the supplied view is under the given point, false otherwise
+     */
+    public boolean isViewUnder(View view, int x, int y) {
+        if (view == null) {
+            return false;
+        }
+        return x >= view.getLeft() &&
+                x < view.getRight() &&
+                y >= view.getTop() &&
+                y < view.getBottom();
+    }
+
+    /**
+     * Find the topmost child under the given point within the parent view's coordinate system.
+     * The child order is determined using {@link Callback#getOrderedChildIndex(int)}.
+     *
+     * @param x X position to test in the parent's coordinate system
+     * @param y Y position to test in the parent's coordinate system
+     * @return The topmost child view under (x, y) or null if none found.
+     */
+    public View findTopChildUnder(int x, int y) {
+        final int childCount = mParentView.getChildCount();
+        for (int i = childCount - 1; i >= 0; i--) {
+            final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i));
+            if (x >= child.getLeft() && x < child.getRight() &&
+                    y >= child.getTop() && y < child.getBottom()) {
+                return child;
+            }
+        }
+        return null;
+    }
+
+    private int getEdgesTouched(int x, int y) {
+        int result = 0;
+
+        if (x < mParentView.getLeft() + mEdgeSize) result |= EDGE_LEFT;
+        if (y < mParentView.getTop() + mEdgeSize) result |= EDGE_TOP;
+        if (x > mParentView.getRight() - mEdgeSize) result |= EDGE_RIGHT;
+        if (y > mParentView.getBottom() - mEdgeSize) result |= EDGE_BOTTOM;
+
+        return result;
+    }
+
+    /**
+     * A Callback is used as a communication channel with the ViewDragHelper back to the
+     * parent view using it. <code>on*</code>methods are invoked on siginficant events and several
+     * accessor methods are expected to provide the ViewDragHelper with more information
+     * about the state of the parent view upon request. The callback also makes decisions
+     * governing the range and draggability of child views.
+     */
+    public static abstract class Callback {
+        /**
+         * Called when the drag state changes. See the <code>STATE_*</code> constants
+         * for more information.
+         *
+         * @param state The new drag state
+         * @see #STATE_IDLE
+         * @see #STATE_DRAGGING
+         * @see #STATE_SETTLING
+         */
+        public void onViewDragStateChanged(int state) {
+        }
+
+        /**
+         * Called when the captured view's position changes as the result of a drag or settle.
+         *
+         * @param changedView View whose position changed
+         * @param left        New X coordinate of the left edge of the view
+         * @param top         New Y coordinate of the top edge of the view
+         * @param dx          Change in X position from the last call
+         * @param dy          Change in Y position from the last call
+         */
+        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
+        }
+
+        /**
+         * Called when a child view is captured for dragging or settling. The ID of the pointer
+         * currently dragging the captured view is supplied. If activePointerId is
+         * identified as {@link #INVALID_POINTER} the capture is programmatic instead of
+         * pointer-initiated.
+         *
+         * @param capturedChild   Child view that was captured
+         * @param activePointerId Pointer id tracking the child capture
+         */
+        public void onViewCaptured(View capturedChild, int activePointerId) {
+        }
+
+        /**
+         * Called when the child view is no longer being actively dragged.
+         * The fling velocity is also supplied, if relevant. The velocity values may
+         * be clamped to system minimums or maximums.
+         * <p>
+         * <p>Calling code may decide to fling or otherwise release the view to let it
+         * settle into place. It should do so using {@link #settleCapturedViewAt(int, int)}
+         * or {@link #flingCapturedView(int, int, int, int)}. If the Callback invokes
+         * one of these methods, the ViewDragHelper will enter {@link #STATE_SETTLING}
+         * and the view capture will not fully end until it comes to a complete stop.
+         * If neither of these methods is invoked before <code>onViewReleased</code> returns,
+         * the view will stop in place and the ViewDragHelper will return to
+         * {@link #STATE_IDLE}.</p>
+         *
+         * @param releasedChild The captured child view now being released
+         * @param xvel          X velocity of the pointer as it left the screen in pixels per second.
+         * @param yvel          Y velocity of the pointer as it left the screen in pixels per second.
+         */
+        public void onViewReleased(View releasedChild, float xvel, float yvel) {
+        }
+
+        /**
+         * Called when one of the subscribed edges in the parent view has been touched
+         * by the user while no child view is currently captured.
+         *
+         * @param edgeFlags A combination of edge flags describing the edge(s) currently touched
+         * @param pointerId ID of the pointer touching the described edge(s)
+         * @see #EDGE_LEFT
+         * @see #EDGE_TOP
+         * @see #EDGE_RIGHT
+         * @see #EDGE_BOTTOM
+         */
+        public void onEdgeTouched(int edgeFlags, int pointerId) {
+        }
+
+        /**
+         * Called when the given edge may become locked. This can happen if an edge drag
+         * was preliminarily rejected before beginning, but after {@link #onEdgeTouched(int, int)}
+         * was called. This method should return true to lock this edge or false to leave it
+         * unlocked. The default behavior is to leave edges unlocked.
+         *
+         * @param edgeFlags A combination of edge flags describing the edge(s) locked
+         * @return true to lock the edge, false to leave it unlocked
+         */
+        public boolean onEdgeLock(int edgeFlags) {
+            return false;
+        }
+
+        /**
+         * Called when the user has started a deliberate drag away from one
+         * of the subscribed edges in the parent view while no child view is currently captured.
+         *
+         * @param edgeFlags A combination of edge flags describing the edge(s) dragged
+         * @param pointerId ID of the pointer touching the described edge(s)
+         * @see #EDGE_LEFT
+         * @see #EDGE_TOP
+         * @see #EDGE_RIGHT
+         * @see #EDGE_BOTTOM
+         */
+        public void onEdgeDragStarted(int edgeFlags, int pointerId) {
+        }
+
+        /**
+         * Called to determine the Z-order of child views.
+         *
+         * @param index the ordered position to query for
+         * @return index of the view that should be ordered at position <code>index</code>
+         */
+        public int getOrderedChildIndex(int index) {
+            return index;
+        }
+
+        /**
+         * Return the magnitude of a draggable child view's horizontal range of motion in pixels.
+         * This method should return 0 for views that cannot move horizontally.
+         *
+         * @param child Child view to check
+         * @return range of horizontal motion in pixels
+         */
+        public int getViewHorizontalDragRange(View child) {
+            return 0;
+        }
+
+        /**
+         * Return the magnitude of a draggable child view's vertical range of motion in pixels.
+         * This method should return 0 for views that cannot move vertically.
+         *
+         * @param child Child view to check
+         * @return range of vertical motion in pixels
+         */
+        public int getViewVerticalDragRange(View child) {
+            return 0;
+        }
+
+        /**
+         * Called when the user's input indicates that they want to capture the given child view
+         * with the pointer indicated by pointerId. The callback should return true if the user
+         * is permitted to drag the given view with the indicated pointer.
+         * <p>
+         * <p>ViewDragHelper may call this method multiple times for the same view even if
+         * the view is already captured; this indicates that a new pointer is trying to take
+         * control of the view.</p>
+         * <p>
+         * <p>If this method returns true, a call to {@link #onViewCaptured(android.view.View, int)}
+         * will follow if the capture is successful.</p>
+         *
+         * @param child     Child the user is attempting to capture
+         * @param pointerId ID of the pointer attempting the capture
+         * @return true if capture should be allowed, false otherwise
+         */
+        public abstract boolean tryCaptureView(View child, int pointerId);
+
+        /**
+         * Restrict the motion of the dragged child view along the horizontal axis.
+         * The default implementation does not allow horizontal motion; the extending
+         * class must override this method and provide the desired clamping.
+         *
+         * @param child Child view being dragged
+         * @param left  Attempted motion along the X axis
+         * @param dx    Proposed change in position for left
+         * @return The new clamped position for left
+         */
+        public int clampViewPositionHorizontal(View child, int left, int dx) {
+            return 0;
+        }
+
+        /**
+         * Restrict the motion of the dragged child view along the vertical axis.
+         * The default implementation does not allow vertical motion; the extending
+         * class must override this method and provide the desired clamping.
+         *
+         * @param child Child view being dragged
+         * @param top   Attempted motion along the Y axis
+         * @param dy    Proposed change in position for top
+         * @return The new clamped position for top
+         */
+        public int clampViewPositionVertical(View child, int top, int dy) {
+            return 0;
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/HeaderBar.java b/twelve/src/main/java/com/dolzzo/twelve/ui/HeaderBar.java
new file mode 100755
index 0000000000..e005ecd99a
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/HeaderBar.java
@@ -0,0 +1,174 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui;
+
+import android.content.Context;
+import android.support.v4.app.Fragment;
+import android.util.AttributeSet;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.PopupMenu;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.loaders.NowPlayingCursor;
+import com.dolzzo.twelve.loaders.QueueLoader;
+import com.dolzzo.twelve.menu.CreateNewPlaylist;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.NavUtils;
+
+/**
+ * Simple Header bar wrapper class that also has its own menu bar button.
+ * It can collect a list of popup menu creators and create a pop up menu
+ * from the list
+ */
+public class HeaderBar extends LinearLayout {
+
+    private ImageView mMenuButton;
+    private ImageView mSearchButton;
+    private ImageView mBackButton;
+    private TextView mTitleText;
+    private PopupMenu mPopupMenu;
+    private Fragment mFragment;
+
+    public HeaderBar(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public void setFragment(Fragment activity) {
+        mFragment = activity;
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+
+        mMenuButton = (ImageView) findViewById(R.id.header_bar_menu_button);
+        mMenuButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                showPopupMenu();
+            }
+        });
+
+        mSearchButton = (ImageView) findViewById(R.id.header_bar_search_button);
+        mSearchButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                NavUtils.openSearch(mFragment.getActivity(), "");
+            }
+        });
+
+
+        mBackButton = (ImageView) findViewById(R.id.header_bar_up);
+
+        mTitleText = (TextView) findViewById(R.id.header_bar_title);
+    }
+
+    /**
+     * @param resId set the title text
+     */
+    public void setTitleText(int resId) {
+        mTitleText.setText(resId);
+    }
+
+    /**
+     * @param text set the title text
+     */
+    public void setTitleText(String text) {
+        mTitleText.setText(text);
+    }
+
+    /**
+     * Sets the back button listener
+     *
+     * @param listener listener
+     */
+    public void setBackListener(final OnClickListener listener) {
+        mBackButton.setOnClickListener(listener);
+        setOnClickListener(listener);
+    }
+
+    /**
+     * Sets the header bar listener
+     *
+     * @param listener listener
+     */
+    public void setHeaderClickListener(final OnClickListener listener) {
+        setOnClickListener(listener);
+    }
+
+    public void showPopupMenu() {
+        // create the popup menu
+        if (mPopupMenu == null) {
+            mPopupMenu = new PopupMenu(mFragment.getActivity(), mMenuButton);
+            mPopupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
+                @Override
+                public boolean onMenuItemClick(MenuItem item) {
+                    return onPopupMenuItemClick(item);
+                }
+            });
+        }
+
+        final Menu menu = mPopupMenu.getMenu();
+        final MenuInflater inflater = mPopupMenu.getMenuInflater();
+
+        menu.clear();
+
+        // Shuffle all
+        inflater.inflate(R.menu.shuffle_all, menu);
+        if (MusicUtils.getQueueSize() > 0) {
+            // save queue/clear queue
+            inflater.inflate(R.menu.queue, menu);
+        }
+        // Settings
+        inflater.inflate(R.menu.activity_base, menu);
+
+        // show the popup
+        mPopupMenu.show();
+    }
+
+    public boolean onPopupMenuItemClick(final MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.menu_shuffle_all:
+                // Shuffle all the songs
+                MusicUtils.shuffleAll(mFragment.getActivity());
+                return true;
+            case R.id.menu_settings:
+                // Settings
+                NavUtils.openSettings(mFragment.getActivity());
+                return true;
+            case R.id.menu_save_queue:
+                NowPlayingCursor queue = (NowPlayingCursor) QueueLoader
+                        .makeQueueCursor(mFragment.getActivity());
+                CreateNewPlaylist.getInstance(MusicUtils.getSongListForCursor(queue)).show(
+                        mFragment.getFragmentManager(), "CreatePlaylist");
+                queue.close();
+                return true;
+            case R.id.menu_clear_queue:
+                MusicUtils.clearQueue();
+                return true;
+            default:
+                break;
+        }
+
+        return false;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/MusicHolder.java b/twelve/src/main/java/com/dolzzo/twelve/ui/MusicHolder.java
new file mode 100755
index 0000000000..e1f1a5634b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/MusicHolder.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui;
+
+import android.content.Context;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.widgets.PlayPauseProgressButton;
+import com.dolzzo.twelve.widgets.PopupMenuButton;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Used to efficiently cache and recyle the {@link View}s used in the artist,
+ * album, song, playlist, and genre adapters.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class MusicHolder {
+
+    /**
+     * This is the overlay ontop of the background artist, playlist, or genre
+     * image
+     */
+    public WeakReference<RelativeLayout> mOverlay;
+
+    /**
+     * This is the artist or album image
+     */
+    public WeakReference<ImageView> mImage;
+
+    /**
+     * This is the first line displayed in the list or grid
+     *
+     * @see {@code #getView()} of a specific adapter for more detailed info
+     */
+    public WeakReference<TextView> mLineOne;
+
+    /**
+     * This is displayed on the right side of the first line in the list or grid
+     *
+     * @see {@code #getView()} of a specific adapter for more detailed info
+     */
+    public WeakReference<TextView> mLineOneRight;
+
+    /**
+     * This is the second line displayed in the list or grid
+     *
+     * @see {@code #getView()} of a specific adapter for more detailed info
+     */
+    public WeakReference<TextView> mLineTwo;
+
+    /**
+     * The container for the circular progress bar and play/pause button
+     *
+     * @see {@code #getView()} of a specific adapter for more detailed info
+     */
+    public WeakReference<PlayPauseProgressButton> mPlayPauseProgressButton;
+
+    /**
+     * The Padding container for the circular progress bar
+     */
+    public WeakReference<View> mPlayPauseProgressContainer;
+
+    /**
+     * The song indicator for the currently playing track
+     */
+    public WeakReference<View> mNowPlayingIndicator;
+
+    /**
+     * The divider for the list item
+     */
+    public WeakReference<View> mDivider;
+
+    /**
+     * The divider for the list item
+     */
+    public WeakReference<PopupMenuButton> mPopupMenuButton;
+
+    /**
+     * Constructor of <code>ViewHolder</code>
+     *
+     * @param context The {@link Context} to use.
+     */
+    public MusicHolder(final View view) {
+        super();
+        // Initialize mImage
+        mImage = new WeakReference<ImageView>((ImageView) view.findViewById(R.id.image));
+
+        // Initialize mLineOne
+        mLineOne = new WeakReference<TextView>((TextView) view.findViewById(R.id.line_one));
+
+        // Initialize mLineOneRight
+        mLineOneRight = new WeakReference<TextView>(
+                (TextView) view.findViewById(R.id.line_one_right));
+
+        // Initialize mLineTwo
+        mLineTwo = new WeakReference<TextView>((TextView) view.findViewById(R.id.line_two));
+
+        // Initialize Circular progress bar container
+        mPlayPauseProgressButton = new WeakReference<PlayPauseProgressButton>(
+                (PlayPauseProgressButton) view.findViewById(R.id.playPauseProgressButton));
+
+        // Get the padding container for the progress bar
+        mPlayPauseProgressContainer = new WeakReference<View>(
+                view.findViewById(R.id.play_pause_container));
+
+        mNowPlayingIndicator = new WeakReference<View>(view.findViewById(R.id.now_playing));
+
+        // Get the divider for the list item
+        mDivider = new WeakReference<View>(view.findViewById(R.id.divider));
+
+        // Get the pop up menu button
+        mPopupMenuButton = new WeakReference<PopupMenuButton>(
+                (PopupMenuButton) view.findViewById(R.id.popup_menu_button));
+    }
+
+    /**
+     * @param view The {@link View} used to initialize content
+     */
+    public final static class DataHolder {
+
+        /**
+         * This is the ID of the item being loaded in the adapter
+         */
+        public long mItemId;
+
+        /**
+         * This is the first line displayed in the list or grid
+         *
+         * @see {@code #getView()} of a specific adapter for more detailed info
+         */
+        public String mLineOne;
+
+        /**
+         * This is displayed on the right side of the first line in the list or grid
+         *
+         * @see {@code #getView()} of a specific adapter for more detailed info
+         */
+        public String mLineOneRight;
+
+        /**
+         * This is the second line displayed in the list or grid
+         *
+         * @see {@code #getView()} of a specific adapter for more detailed info
+         */
+        public String mLineTwo;
+
+        /**
+         * Constructor of <code>DataHolder</code>
+         */
+        public DataHolder() {
+            super();
+        }
+
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/activities/BaseActivity.java b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/BaseActivity.java
new file mode 100755
index 0000000000..c254b8b903
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/BaseActivity.java
@@ -0,0 +1,518 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.activities;
+
+import android.Manifest;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.graphics.drawable.ColorDrawable;
+import android.graphics.drawable.Drawable;
+import android.media.AudioManager;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.support.v4.app.FragmentActivity;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.util.TypedValue;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.dolzzo.twelve.IElevenService;
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.MusicStateListener;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ICacheListener;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.Lists;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.MusicUtils.ServiceToken;
+import com.dolzzo.twelve.utils.NavUtils;
+import com.dolzzo.twelve.widgets.PlayPauseProgressButton;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+
+import static com.dolzzo.twelve.utils.MusicUtils.mService;
+
+/**
+ * A base {@link FragmentActivity} used to update the bottom bar and
+ * bind to Apollo's service.
+ * <p>
+ * {@link SlidingPanelActivity} extends from this skeleton.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public abstract class BaseActivity extends AppCompatActivity implements ServiceConnection,
+        MusicStateListener, ICacheListener {
+
+    public static final int MY_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE = 121212;
+    /**
+     * Playstate and meta change listener
+     */
+    private final ArrayList<MusicStateListener> mMusicStateListener = Lists.newArrayList();
+    /**
+     * Opens the album profile of the currently playing album
+     */
+    private final View.OnClickListener mOpenCurrentAlbumProfile = new View.OnClickListener() {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onClick(final View v) {
+            if (MusicUtils.getCurrentAudioId() != -1) {
+                NavUtils.openAlbumProfile(BaseActivity.this, MusicUtils.getAlbumName(),
+                        MusicUtils.getArtistName(), MusicUtils.getCurrentAlbumId());
+            } else {
+                MusicUtils.shuffleAll(BaseActivity.this);
+            }
+        }
+    };
+    private Toolbar mToolBar;
+    private int mActionBarHeight;
+    /**
+     * The service token
+     */
+    private ServiceToken mToken;
+    /**
+     * Play pause progress button
+     */
+    private PlayPauseProgressButton mPlayPauseProgressButton;
+    /**
+     * Track name (BAB)
+     */
+    private TextView mTrackName;
+    /**
+     * Artist name (BAB)
+     */
+    private TextView mArtistName;
+    /**
+     * Album art (BAB)
+     */
+    private ImageView mAlbumArt;
+    /**
+     * Broadcast receiver
+     */
+    private PlaybackStatus mPlaybackStatus;
+    private Drawable mActionBarBackground;
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        boolean delayBinding = false;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            if (checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE)
+                    != PackageManager.PERMISSION_GRANTED) {
+                requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},
+                        MY_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE);
+                delayBinding = true;
+            }
+        }
+
+        // Fade it in
+        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
+
+        // Control the media volume
+        setVolumeControlStream(AudioManager.STREAM_MUSIC);
+
+        // Initialize the broadcast receiver
+        mPlaybackStatus = new PlaybackStatus(this);
+
+        // Calculate ActionBar height
+        TypedValue value = new TypedValue();
+        if (getTheme().resolveAttribute(android.R.attr.actionBarSize, value, true)) {
+            mActionBarHeight = TypedValue.complexToDimensionPixelSize(value.data,
+                    getResources().getDisplayMetrics());
+        }
+
+        // Set the layout
+        setContentView(setContentView());
+
+        getActionBarToolbar();
+
+        getSupportActionBar().setTitle(getString(R.string.app_name).toUpperCase());
+
+        // set the background on the root view
+        getWindow().getDecorView().getRootView().setBackgroundColor(
+                getResources().getColor(R.color.background_color));
+        // Initialze the bottom action bar
+        initBottomActionBar();
+
+        // listen to changes to the cache status
+        ImageFetcher.getInstance(this).addCacheListener(this);
+
+        if (delayBinding == false) {
+            bindService();
+        }
+    }
+
+    protected void bindService() {
+        // Bind Apollo's service
+        mToken = MusicUtils.bindToService(this, this);
+    }
+
+
+    @Override
+    public void onRequestPermissionsResult(
+            int requestCode, String permissions[], int[] grantResults) {
+        switch (requestCode) {
+            case MY_PERMISSIONS_REQUEST_READ_EXTERNAL_STORAGE:
+                if (grantResults.length == 0
+                        || grantResults[0] != PackageManager.PERMISSION_GRANTED) {
+                    finish();
+                    return;
+                }
+                bindService();
+                break;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onServiceConnected(final ComponentName name, final IBinder service) {
+        mService = IElevenService.Stub.asInterface(service);
+        // Set the playback drawables
+        updatePlaybackControls();
+        // Current info
+        onMetaChanged();
+        // if there were any pending intents while the service was started
+        handlePendingPlaybackRequests();
+    }
+
+    protected Toolbar getActionBarToolbar() {
+        if (mToolBar == null) {
+            mToolBar = (Toolbar) findViewById(R.id.toolbar);
+            if (mToolBar != null) {
+                setSupportActionBar(mToolBar);
+            }
+        }
+        return mToolBar;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onServiceDisconnected(final ComponentName name) {
+        mService = null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onCreateOptionsMenu(final Menu menu) {
+        // Search view
+        getMenuInflater().inflate(R.menu.search_btn, menu);
+        // Settings
+        getMenuInflater().inflate(R.menu.activity_base, menu);
+
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onOptionsItemSelected(final MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.menu_settings:
+                // Settings
+                NavUtils.openSettings(this);
+                return true;
+
+            case R.id.menu_search:
+                NavUtils.openSearch(BaseActivity.this, "");
+                return true;
+
+            default:
+                break;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onResume() {
+        super.onResume();
+        // Set the playback drawables
+        updatePlaybackControls();
+        // Current info
+        onMetaChanged();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onStart() {
+        super.onStart();
+        final IntentFilter filter = new IntentFilter();
+        // Play and pause changes
+        filter.addAction(MusicPlaybackService.PLAYSTATE_CHANGED);
+        // Track changes
+        filter.addAction(MusicPlaybackService.META_CHANGED);
+        // Update a list, probably the playlist fragment's
+        filter.addAction(MusicPlaybackService.REFRESH);
+        // If a playlist has changed, notify us
+        filter.addAction(MusicPlaybackService.PLAYLIST_CHANGED);
+        // If there is an error playing a track
+        filter.addAction(MusicPlaybackService.TRACK_ERROR);
+        registerReceiver(mPlaybackStatus, filter);
+
+        mPlayPauseProgressButton.resume();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onStop() {
+        super.onStop();
+
+        mPlayPauseProgressButton.pause();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        // Unbind from the service
+        if (mToken != null) {
+            MusicUtils.unbindFromService(mToken);
+            mToken = null;
+        }
+
+        // Unregister the receiver
+        try {
+            unregisterReceiver(mPlaybackStatus);
+        } catch (final Throwable e) {
+            //$FALL-THROUGH$
+        }
+
+        // Remove any music status listeners
+        mMusicStateListener.clear();
+
+        // remove cache listeners
+        ImageFetcher.getInstance(this).removeCacheListener(this);
+    }
+
+    public void setupActionBar(int resId) {
+        setupActionBar(getString(resId));
+    }
+
+    public void setupActionBar(String title) {
+        setActionBarTitle(title);
+
+        if (mActionBarBackground == null) {
+            final int actionBarColor = getResources().getColor(R.color.header_action_bar_color);
+            mActionBarBackground = new ColorDrawable(actionBarColor);
+            mToolBar.setBackgroundDrawable(mActionBarBackground);
+        }
+    }
+
+    public void setActionBarTitle(String title) {
+        getActionBarToolbar();
+        getSupportActionBar().setTitle(title.toUpperCase());
+    }
+
+    public void setActionBarAlpha(int alpha) {
+        mActionBarBackground.setAlpha(alpha);
+    }
+
+    public void setActionBarElevation(boolean isElevated) {
+        float targetElevation = isElevated
+                ? getResources().getDimension(R.dimen.action_bar_elevation) : 0;
+        getSupportActionBar().setElevation(targetElevation);
+    }
+
+    public void setFragmentPadding(boolean enablePadding) {
+        final int height = enablePadding ? mActionBarHeight : 0;
+        findViewById(R.id.activity_base_content).setPadding(0, height, 0, 0);
+    }
+
+    /**
+     * Initializes the items in the bottom action bar.
+     */
+    protected void initBottomActionBar() {
+        // Play and pause button
+        mPlayPauseProgressButton = (PlayPauseProgressButton) findViewById(R.id.playPauseProgressButton);
+        mPlayPauseProgressButton.enableAndShow();
+
+        // Track name
+        mTrackName = (TextView) findViewById(R.id.bottom_action_bar_line_one);
+        // Artist name
+        mArtistName = (TextView) findViewById(R.id.bottom_action_bar_line_two);
+        // Album art
+        mAlbumArt = (ImageView) findViewById(R.id.bottom_action_bar_album_art);
+        // Open to the currently playing album profile
+        mAlbumArt.setOnClickListener(mOpenCurrentAlbumProfile);
+    }
+
+    protected void clearMetaInfo() {
+        mAlbumArt.setImageResource(R.drawable.default_artwork);
+    }
+
+    /**
+     * Sets the track name, album name, and album art.
+     */
+    private void updateBottomActionBarInfo() {
+        // Set the track name
+        mTrackName.setText(MusicUtils.getTrackName());
+        // Set the artist name
+        mArtistName.setText(MusicUtils.getArtistName());
+        // Set the album art
+        ApolloUtils.getImageFetcher(this).loadCurrentArtwork(mAlbumArt);
+    }
+
+    /**
+     * Sets the correct drawable states for the playback controls.
+     */
+    private void updatePlaybackControls() {
+        // Set the play and pause image
+        mPlayPauseProgressButton.getPlayPauseButton().updateState();
+    }
+
+    @Override
+    public void onMetaChanged() {
+        // update action bar info
+        updateBottomActionBarInfo();
+
+        // Let the listener know to the meta chnaged
+        for (final MusicStateListener listener : mMusicStateListener) {
+            if (listener != null) {
+                listener.onMetaChanged();
+            }
+        }
+    }
+
+    @Override
+    public void restartLoader() {
+        // Let the listener know to update a list
+        for (final MusicStateListener listener : mMusicStateListener) {
+            if (listener != null) {
+                listener.restartLoader();
+            }
+        }
+    }
+
+    @Override
+    public void onPlaylistChanged() {
+        // Let the listener know to update a list
+        for (final MusicStateListener listener : mMusicStateListener) {
+            if (listener != null) {
+                listener.onPlaylistChanged();
+            }
+        }
+    }
+
+    /**
+     * @param status The {@link MusicStateListener} to use
+     */
+    public void setMusicStateListenerListener(final MusicStateListener status) {
+        if (status == this) {
+            throw new UnsupportedOperationException("Override the method, don't add a listener");
+        }
+
+        if (status != null) {
+            mMusicStateListener.add(status);
+        }
+    }
+
+    /**
+     * @param status The {@link MusicStateListener} to use
+     */
+    public void removeMusicStateListenerListener(final MusicStateListener status) {
+        if (status != null) {
+            mMusicStateListener.remove(status);
+        }
+    }
+
+    @Override
+    public void onCacheUnpaused() {
+        // Set the album art
+        ApolloUtils.getImageFetcher(this).loadCurrentArtwork(mAlbumArt);
+    }
+
+    /**
+     * @return The resource ID to be inflated.
+     */
+    public abstract int setContentView();
+
+    /**
+     * handle pending playback requests
+     */
+    public abstract void handlePendingPlaybackRequests();
+
+    /**
+     * Used to monitor the state of playback
+     */
+    private final static class PlaybackStatus extends BroadcastReceiver {
+
+        private final WeakReference<BaseActivity> mReference;
+
+        /**
+         * Constructor of <code>PlaybackStatus</code>
+         */
+        public PlaybackStatus(final BaseActivity activity) {
+            mReference = new WeakReference<BaseActivity>(activity);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            final String action = intent.getAction();
+            BaseActivity baseActivity = mReference.get();
+            if (baseActivity != null) {
+                if (action.equals(MusicPlaybackService.META_CHANGED)) {
+                    baseActivity.onMetaChanged();
+                } else if (action.equals(MusicPlaybackService.PLAYSTATE_CHANGED)) {
+                    // Set the play and pause image
+                    baseActivity.mPlayPauseProgressButton.getPlayPauseButton().updateState();
+                } else if (action.equals(MusicPlaybackService.REFRESH)) {
+                    baseActivity.restartLoader();
+                } else if (action.equals(MusicPlaybackService.PLAYLIST_CHANGED)) {
+                    baseActivity.onPlaylistChanged();
+                } else if (action.equals(MusicPlaybackService.TRACK_ERROR)) {
+                    final String errorMsg = context.getString(R.string.error_playing_track,
+                            intent.getStringExtra(MusicPlaybackService.TrackErrorExtra.TRACK_NAME));
+                    Toast.makeText(baseActivity, errorMsg, Toast.LENGTH_SHORT).show();
+                }
+            }
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/activities/HomeActivity.java b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/HomeActivity.java
new file mode 100755
index 0000000000..0173dd0aaf
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/HomeActivity.java
@@ -0,0 +1,473 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.dolzzo.twelve.ui.activities;
+
+import android.Manifest;
+import android.animation.ArgbEvaluator;
+import android.animation.ObjectAnimator;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.provider.MediaStore;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentTransaction;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.MenuItem;
+import android.view.Window;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.ui.fragments.AlbumDetailFragment;
+import com.dolzzo.twelve.ui.fragments.ArtistDetailFragment;
+import com.dolzzo.twelve.ui.fragments.AudioPlayerFragment;
+import com.dolzzo.twelve.ui.fragments.IChildFragment;
+import com.dolzzo.twelve.ui.fragments.ISetupActionBar;
+import com.dolzzo.twelve.ui.fragments.PlaylistDetailFragment;
+import com.dolzzo.twelve.ui.fragments.RecentFragment;
+import com.dolzzo.twelve.ui.fragments.phone.MusicBrowserPhoneFragment;
+import com.dolzzo.twelve.ui.fragments.profile.LastAddedFragment;
+import com.dolzzo.twelve.ui.fragments.profile.TopTracksFragment;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.BitmapWithColors;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.NavUtils;
+
+public class HomeActivity extends SlidingPanelActivity implements
+        FragmentManager.OnBackStackChangedListener {
+    public static final String EXTRA_BROWSE_PAGE_IDX = "BrowsePageIndex";
+    public static final int EQUALIZER = 2;
+    private static final String TAG = "HomeActivity";
+    private static final String ACTION_PREFIX = HomeActivity.class.getName();
+    public static final String ACTION_VIEW_ARTIST_DETAILS = ACTION_PREFIX + ".view.ArtistDetails";
+    public static final String ACTION_VIEW_ALBUM_DETAILS = ACTION_PREFIX + ".view.AlbumDetails";
+    public static final String ACTION_VIEW_PLAYLIST_DETAILS = ACTION_PREFIX + ".view.PlaylistDetails";
+    public static final String ACTION_VIEW_SMART_PLAYLIST = ACTION_PREFIX + ".view.SmartPlaylist";
+    private static final String STATE_KEY_BASE_FRAGMENT = "BaseFragment";
+    private static final int NEW_PHOTO = 1;
+
+    /**
+     * Used by the up action to determine how to handle this
+     */
+    protected boolean mTopLevelActivity = false;
+    private String mKey;
+    private boolean mLoadedBaseFragment = false;
+    private boolean mHasPendingPlaybackRequest = false;
+    private Handler mHandler = new Handler();
+    private boolean mBrowsePanelActive = true;
+    private Bundle mSavedInstanceState;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // if we've been launched by an intent, parse it
+        Intent launchIntent = getIntent();
+        boolean intentHandled = false;
+        if (launchIntent != null) {
+            intentHandled = parseIntentForFragment(launchIntent);
+        }
+
+        // if the intent didn't cause us to load a fragment, load the music browse one
+        if (savedInstanceState == null && !mLoadedBaseFragment) {
+            final MusicBrowserPhoneFragment fragment = new MusicBrowserPhoneFragment();
+            if (launchIntent != null) {
+                fragment.setDefaultPageIdx(launchIntent.getIntExtra(EXTRA_BROWSE_PAGE_IDX,
+                        MusicBrowserPhoneFragment.INVALID_PAGE_INDEX));
+            }
+            getSupportFragmentManager().beginTransaction()
+                    .replace(R.id.activity_base_content, fragment)
+                    .commit();
+
+            mLoadedBaseFragment = true;
+            mTopLevelActivity = true;
+        }
+
+        getSupportFragmentManager().addOnBackStackChangedListener(this);
+
+        // if we are resuming from a saved instance state
+        if (savedInstanceState != null) {
+            // track which fragments are loaded and if this is the top level activity
+            mTopLevelActivity = savedInstanceState.getBoolean(STATE_KEY_BASE_FRAGMENT);
+            mLoadedBaseFragment = mTopLevelActivity;
+
+            // update the action bar based on the top most fragment
+            onBackStackChanged();
+
+            // figure which panel we are on and update the status bar
+            mBrowsePanelActive = (getCurrentPanel() == Panel.Browse);
+            updateStatusBarColor();
+        }
+
+        // if intent wasn't UI related, process it as a audio playback request
+        if (!intentHandled) {
+            handlePlaybackIntent(launchIntent);
+        }
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putBoolean(STATE_KEY_BASE_FRAGMENT, mTopLevelActivity);
+    }
+
+    public Fragment getTopFragment() {
+        return getSupportFragmentManager().findFragmentById(R.id.activity_base_content);
+    }
+
+    public void postRemoveFragment(final Fragment frag) {
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                // removing the fragment doesn't cause the backstack event to be triggered even if
+                // it is the top fragment, so if it is the top fragment, we will just manually
+                // call pop back stack
+                if (frag == getTopFragment()) {
+                    getSupportFragmentManager().popBackStack();
+                } else {
+                    getSupportFragmentManager().beginTransaction().remove(frag).commit();
+                }
+            }
+        });
+    }
+
+    @Override
+    protected void onNewIntent(Intent intent) {
+        super.onNewIntent(intent);
+
+        // parse intent to ascertain whether the intent is inter UI communication
+        boolean intentHandled = parseIntentForFragment(intent);
+        // since this activity is marked 'singleTop' (launch mode), an existing activity instance
+        // could be sent media play requests
+        if (!intentHandled) {
+            handlePlaybackIntent(intent);
+        }
+    }
+
+    @Override
+    public void onMetaChanged() {
+        super.onMetaChanged();
+        updateStatusBarColor();
+    }
+
+    @Override
+    protected void onSlide(float slideOffset) {
+        boolean isInBrowser = getCurrentPanel() == Panel.Browse && slideOffset < 0.7f;
+        if (isInBrowser != mBrowsePanelActive) {
+            mBrowsePanelActive = isInBrowser;
+            updateStatusBarColor();
+        }
+    }
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+
+        getAudioPlayerFragment().setVisualizerVisible(hasFocus
+                && getCurrentPanel() == Panel.MusicPlayer);
+    }
+
+    private void updateStatusBarColor() {
+        if (mBrowsePanelActive || MusicUtils.getCurrentAlbumId() < 0) {
+            updateStatusBarColor(Color.TRANSPARENT);
+        } else {
+            new AsyncTask<Void, Void, BitmapWithColors>() {
+                @Override
+                protected BitmapWithColors doInBackground(Void... params) {
+                    ImageFetcher imageFetcher = ImageFetcher.getInstance(HomeActivity.this);
+                    return imageFetcher.getArtwork(
+                            MusicUtils.getAlbumName(), MusicUtils.getCurrentAlbumId(),
+                            MusicUtils.getArtistName(), true);
+                }
+
+                @Override
+                protected void onPostExecute(BitmapWithColors bmc) {
+                    updateVisualizerColor(bmc != null
+                            ? bmc.getContrastingColor() : Color.TRANSPARENT);
+                    updateStatusBarColor(bmc != null
+                            ? bmc.getVibrantDarkColor() : Color.TRANSPARENT);
+                }
+            }.execute();
+        }
+    }
+
+    private void updateVisualizerColor(int color) {
+        if (color == Color.TRANSPARENT) {
+            color = getResources().getColor(R.color.visualizer_fill_color);
+        }
+
+        // check for null since updatestatusBarColor is a async task
+        AudioPlayerFragment fragment = getAudioPlayerFragment();
+        if (fragment != null) {
+            fragment.setVisualizerColor(color);
+        }
+    }
+
+    private void updateStatusBarColor(int color) {
+        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
+            if (color == Color.TRANSPARENT) {
+                color = getResources().getColor(R.color.primary_dark);
+            }
+            final Window window = getWindow();
+            ObjectAnimator animator = ObjectAnimator.ofInt(window,
+                    "statusBarColor", window.getStatusBarColor(), color);
+            animator.setEvaluator(new ArgbEvaluator());
+            animator.setDuration(300);
+            animator.start();
+        }
+    }
+
+    private boolean parseIntentForFragment(Intent intent) {
+        boolean handled = false;
+        if (intent.getAction() != null) {
+            final String action = intent.getAction();
+            Fragment targetFragment = null;
+            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
+
+            if (action.equals(ACTION_VIEW_SMART_PLAYLIST)) {
+                long playlistId = intent.getExtras().getLong(Config.SMART_PLAYLIST_TYPE);
+                switch (Config.SmartPlaylistType.getTypeById(playlistId)) {
+                    case LastAdded:
+                        targetFragment = new LastAddedFragment();
+                        break;
+                    case RecentlyPlayed:
+                        targetFragment = new RecentFragment();
+                        break;
+                    case TopTracks:
+                        targetFragment = new TopTracksFragment();
+                        break;
+                }
+            } else if (action.equals(ACTION_VIEW_PLAYLIST_DETAILS)) {
+                targetFragment = new PlaylistDetailFragment();
+            } else if (action.equals(ACTION_VIEW_ALBUM_DETAILS)) {
+                targetFragment = new AlbumDetailFragment();
+            } else if (action.equals(ACTION_VIEW_ARTIST_DETAILS)) {
+                targetFragment = new ArtistDetailFragment();
+            }
+
+            if (targetFragment != null) {
+                targetFragment.setArguments(intent.getExtras());
+                transaction.setCustomAnimations(0, 0, 0, R.anim.fade_out);
+                // If we ever come back to this because of memory concerns because
+                // none of the fragments are being removed from memory, we can fix this
+                // by using "replace" instead of "add".  The caveat is that the performance of
+                // returning to previous fragments is a bit more sluggish because the fragment
+                // view needs to be recreated. If we do remove that, we can remove the back stack
+                // change listener code above
+                transaction.add(R.id.activity_base_content, targetFragment);
+                if (mLoadedBaseFragment) {
+                    transaction.addToBackStack(null);
+                    showPanel(Panel.Browse);
+                } else {
+                    // else mark the fragment as loaded so we don't load the music browse fragment.
+                    // this happens when they launch search which is its own activity and then
+                    // browse through that back to home activity
+                    mLoadedBaseFragment = true;
+                    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
+                }
+                // the current top fragment is about to be hidden by what we are replacing
+                // it with -- so tell that fragment not to make its action bar menu items visible
+                Fragment oldTop = getTopFragment();
+                if (oldTop != null) {
+                    oldTop.setMenuVisibility(false);
+                }
+
+                transaction.commit();
+                handled = true;
+            }
+        }
+        return handled;
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        if (requestCode == NEW_PHOTO && !TextUtils.isEmpty(mKey)) {
+            if (resultCode == RESULT_OK) {
+                MusicUtils.removeFromCache(this, mKey);
+                final Uri selectedImage = data.getData();
+
+                new Thread(new Runnable() {
+                    @Override
+                    public void run() {
+                        Bitmap bitmap = ImageFetcher.decodeSampledBitmapFromUri(getContentResolver(),
+                                selectedImage);
+
+                        ImageFetcher imageFetcher = ApolloUtils.getImageFetcher(HomeActivity.this);
+                        imageFetcher.addBitmapToCache(mKey, bitmap);
+
+                        MusicUtils.refresh();
+                    }
+                }).start();
+            }
+        }
+    }
+
+    /**
+     * Starts an activity for result that returns an image from the Gallery.
+     */
+    public void selectNewPhoto(String key) {
+        mKey = key;
+        // Now open the gallery
+        final Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null);
+        intent.setType("image/*");
+        startActivityForResult(intent, NEW_PHOTO);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(final MenuItem item) {
+        switch (item.getItemId()) {
+            case android.R.id.home:
+                navigateToTop();
+                return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+
+    /**
+     * Navigates to the top Activity and places the view to the correct page
+     */
+    protected void navigateToTop() {
+        final Fragment topFragment = getTopFragment();
+        int targetFragmentIndex = MusicBrowserPhoneFragment.INVALID_PAGE_INDEX;
+        if (topFragment instanceof IChildFragment) {
+            targetFragmentIndex = ((IChildFragment) topFragment).getMusicFragmentParent().ordinal();
+        }
+
+        // If we are the top activity in the stack (as determined by the activity that has loaded
+        // the MusicBrowserPhoneFragment) then clear the back stack and move the browse fragment
+        // to the appropriate page as per Android up standards
+        if (mTopLevelActivity) {
+            clearBackStack();
+            MusicBrowserPhoneFragment musicFragment = (MusicBrowserPhoneFragment) getTopFragment();
+            musicFragment.setDefaultPageIdx(targetFragmentIndex);
+            showPanel(Panel.Browse);
+        } else {
+            // I've tried all other combinations with parent activities, support.NavUtils and
+            // there is no easy way to achieve what we want that I'm aware of, so clear everything
+            // and jump to the right page
+            NavUtils.goHome(this, targetFragmentIndex);
+        }
+    }
+
+    /**
+     * Immediately clears the backstack
+     */
+    protected void clearBackStack() {
+        final FragmentManager fragmentManager = getSupportFragmentManager();
+        if (fragmentManager.getBackStackEntryCount() > 0) {
+            final int id = fragmentManager.getBackStackEntryAt(0).getId();
+            fragmentManager.popBackStackImmediate(id, FragmentManager.POP_BACK_STACK_INCLUSIVE);
+        }
+    }
+
+    @Override
+    public void handlePendingPlaybackRequests() {
+        if (mHasPendingPlaybackRequest) {
+            Intent unhandledIntent = getIntent();
+            handlePlaybackIntent(unhandledIntent);
+        }
+    }
+
+    /**
+     * Checks whether the passed intent contains a playback request,
+     * and starts playback if that's the case
+     *
+     * @return true if the intent was consumed
+     */
+    private boolean handlePlaybackIntent(Intent intent) {
+
+        if (intent == null) {
+            return false;
+        } else if (!MusicUtils.isPlaybackServiceConnected()) {
+            mHasPendingPlaybackRequest = true;
+            return false;
+        }
+
+        String mimeType = intent.getType();
+        boolean handled = false;
+
+        if (MediaStore.Audio.Playlists.CONTENT_TYPE.equals(mimeType)) {
+            long id = parseIdFromIntent(intent, "playlistId", "playlist", -1);
+            if (id >= 0) {
+                MusicUtils.playPlaylist(this, id, false);
+                handled = true;
+            }
+        } else if (MediaStore.Audio.Albums.CONTENT_TYPE.equals(mimeType)) {
+            long id = parseIdFromIntent(intent, "albumId", "album", -1);
+            if (id >= 0) {
+                int position = intent.getIntExtra("position", 0);
+                MusicUtils.playAlbum(this, id, position, false);
+                handled = true;
+            }
+        } else if (MediaStore.Audio.Artists.CONTENT_TYPE.equals(mimeType)) {
+            long id = parseIdFromIntent(intent, "artistId", "artist", -1);
+            if (id >= 0) {
+                int position = intent.getIntExtra("position", 0);
+                MusicUtils.playArtist(this, id, position, false);
+                handled = true;
+            }
+        }
+
+        // reset intent as it was handled as a playback request
+        if (handled) {
+            setIntent(new Intent());
+        }
+
+        return handled;
+
+    }
+
+    private long parseIdFromIntent(Intent intent, String longKey,
+                                   String stringKey, long defaultId) {
+        long id = intent.getLongExtra(longKey, -1);
+        if (id < 0) {
+            String idString = intent.getStringExtra(stringKey);
+            if (idString != null) {
+                try {
+                    id = Long.parseLong(idString);
+                } catch (NumberFormatException e) {
+                    Log.e(TAG, e.getMessage());
+                }
+            }
+        }
+        return id;
+    }
+
+    @Override
+    public void onBackStackChanged() {
+        Fragment topFragment = getTopFragment();
+        if (topFragment != null) {
+            // the fragment that has come back to the top should now have its menu items
+            // added to the action bar -- so tell it to make it menu items visible
+            topFragment.setMenuVisibility(true);
+            ISetupActionBar setupActionBar = (ISetupActionBar) topFragment;
+            setupActionBar.setupActionBar();
+
+            getSupportActionBar().setDisplayHomeAsUpEnabled(
+                    !(topFragment instanceof MusicBrowserPhoneFragment));
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/activities/SearchActivity.java b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/SearchActivity.java
new file mode 100755
index 0000000000..c2df1b614b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/SearchActivity.java
@@ -0,0 +1,993 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.activities;
+
+import android.app.SearchManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.database.Cursor;
+import android.graphics.drawable.ColorDrawable;
+import android.media.AudioManager;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.provider.BaseColumns;
+import android.provider.MediaStore;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.Loader;
+import android.support.v4.view.MenuItemCompat;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.SearchView;
+import android.support.v7.widget.SearchView.OnQueryTextListener;
+import android.support.v7.widget.Toolbar;
+import android.text.TextUtils;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AbsListView;
+import android.widget.AbsListView.OnScrollListener;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.IElevenService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.SummarySearchAdapter;
+import com.dolzzo.twelve.loaders.WrappedAsyncTaskLoader;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.model.AlbumArtistDetails;
+import com.dolzzo.twelve.model.SearchResult;
+import com.dolzzo.twelve.model.SearchResult.ResultType;
+import com.dolzzo.twelve.provider.SearchHistory;
+import com.dolzzo.twelve.recycler.RecycleHolder;
+import com.dolzzo.twelve.sectionadapter.SectionAdapter;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.sectionadapter.SectionCreator.SimpleListLoader;
+import com.dolzzo.twelve.sectionadapter.SectionListContainer;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.MusicUtils.ServiceToken;
+import com.dolzzo.twelve.utils.NavUtils;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.utils.SectionCreatorUtils;
+import com.dolzzo.twelve.utils.SectionCreatorUtils.IItemCompare;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+import com.dolzzo.twelve.widgets.NoResultsContainer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.TreeSet;
+
+import static android.view.View.OnTouchListener;
+import static com.dolzzo.twelve.utils.MusicUtils.mService;
+
+/**
+ * Provides the search interface for Apollo.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class SearchActivity extends AppCompatActivity implements
+        LoaderCallbacks<SectionListContainer<SearchResult>>,
+        OnScrollListener, OnQueryTextListener, OnItemClickListener, ServiceConnection,
+        OnTouchListener {
+    /**
+     * Loading delay of 500ms so we don't flash the screen too much when loading new searches
+     */
+    private static int LOADING_DELAY = 500;
+
+    /**
+     * Identifier for the search loader
+     */
+    private static int SEARCH_LOADER = 0;
+
+    /**
+     * Identifier for the search history loader
+     */
+    private static int HISTORY_LOADER = 1;
+
+    /**
+     * The service token
+     */
+    private ServiceToken mToken;
+
+    /**
+     * The query
+     */
+    private String mFilterString;
+
+    /**
+     * List view
+     */
+    private ListView mListView;
+
+    /**
+     * Used the filter the user's music
+     */
+    private SearchView mSearchView;
+
+    /**
+     * IME manager
+     */
+    private InputMethodManager mImm;
+
+    /**
+     * The view that container the no search results text and the loading progress bar
+     */
+    private LoadingEmptyContainer mLoadingEmptyContainer;
+
+    /**
+     * List view adapter
+     */
+    private SectionAdapter<SearchResult, SummarySearchAdapter> mAdapter;
+
+    /**
+     * boolean tracking whether this is the search level when the user first enters search
+     * or if the user has clicked show all
+     */
+    private boolean mTopLevelSearch;
+
+    /**
+     * If the user has clicked show all, this tells us what type (Artist, Album, etc)
+     */
+    private ResultType mSearchType;
+
+    /**
+     * Search History loader callback
+     */
+    private SearchHistoryCallback mSearchHistoryCallback;
+
+    /**
+     * List view
+     */
+    private ListView mSearchHistoryListView;
+    private VisibleState mCurrentState;
+    /**
+     * Handler for posting runnables
+     */
+    private Handler mHandler;
+    /**
+     * A runnable to show the loading view that will be posted with a delay to prevent flashing
+     */
+    private Runnable mLoadingRunnable;
+    /**
+     * Flag used to track if we are quitting so we don't flash loaders while finishing the activity
+     */
+    private boolean mQuitting = false;
+    /**
+     * Pop up menu helper
+     */
+    private PopupMenuHelper mPopupMenuHelper;
+    private Toolbar mToolBar;
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        mPopupMenuHelper = new PopupMenuHelper(this, getSupportFragmentManager()) {
+            private SearchResult mSelectedItem;
+
+            @Override
+            public PopupMenuType onPreparePopupMenu(int position) {
+                mSelectedItem = mAdapter.getTItem(position);
+
+                return PopupMenuType.SearchResult;
+            }
+
+            @Override
+            protected long[] getIdList() {
+                switch (mSelectedItem.mType) {
+                    case Artist:
+                        return MusicUtils.getSongListForArtist(SearchActivity.this,
+                                mSelectedItem.mId);
+                    case Album:
+                        return MusicUtils.getSongListForAlbum(SearchActivity.this,
+                                mSelectedItem.mId);
+                    case Song:
+                        return new long[]{mSelectedItem.mId};
+                    case Playlist:
+                        return MusicUtils.getSongListForPlaylist(SearchActivity.this,
+                                mSelectedItem.mId);
+                    default:
+                        return null;
+                }
+            }
+
+            @Override
+            protected long getSourceId() {
+                return mSelectedItem.mId;
+            }
+
+            @Override
+            protected Config.IdType getSourceType() {
+                return mSelectedItem.mType.getSourceType();
+            }
+
+            @Override
+            protected void updateMenuIds(PopupMenuType type, TreeSet<Integer> set) {
+                super.updateMenuIds(type, set);
+
+                if (mSelectedItem.mType == ResultType.Album) {
+                    set.add(FragmentMenuItems.MORE_BY_ARTIST);
+                }
+            }
+
+            @Override
+            protected String getArtistName() {
+                return mSelectedItem.mArtist;
+            }
+        };
+
+        // Fade it in
+        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
+
+        // Control the media volume
+        setVolumeControlStream(AudioManager.STREAM_MUSIC);
+
+        // Bind Apollo's service
+        mToken = MusicUtils.bindToService(this, this);
+
+        // Set the layout
+        setContentView(R.layout.activity_search);
+
+        // get the input method manager
+        mImm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
+
+        // Initialize the adapter
+        SummarySearchAdapter adapter = new SummarySearchAdapter(this);
+        mAdapter = new SectionAdapter<SearchResult, SummarySearchAdapter>(this, adapter);
+        // Set the prefix
+        mAdapter.getUnderlyingAdapter().setPrefix(mFilterString);
+        mAdapter.setupHeaderParameters(R.layout.list_search_header, false);
+        mAdapter.setupFooterParameters(R.layout.list_search_footer, true);
+        mAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mPopupMenuHelper.showPopupMenu(v, position);
+            }
+        });
+
+        mLoadingEmptyContainer = (LoadingEmptyContainer) findViewById(R.id.loading_empty_container);
+        // setup the no results container
+        NoResultsContainer noResults = mLoadingEmptyContainer.getNoResultsContainer();
+        noResults.setMainText(R.string.empty_search);
+        noResults.setSecondaryText(R.string.empty_search_check);
+
+        initListView();
+
+        // setup handler and runnable
+        mHandler = new Handler();
+        mLoadingRunnable = new Runnable() {
+            @Override
+            public void run() {
+                setState(VisibleState.Loading);
+            }
+        };
+
+        // Theme the action bar
+//        final ActionBar actionBar = getActionBar();
+
+        if (mToolBar == null) {
+            mToolBar = (Toolbar) findViewById(R.id.toolbar);
+            if (mToolBar != null) {
+                setSupportActionBar(mToolBar);
+            }
+        }
+
+        final int actionBarColor = getResources().getColor(R.color.header_action_bar_color);
+        ColorDrawable mActionBarBackground = new ColorDrawable(actionBarColor);
+        mToolBar.setBackgroundDrawable(mActionBarBackground);
+
+        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
+        // Get the query String
+        mFilterString = getIntent().getStringExtra(SearchManager.QUERY);
+
+        // if we have a non-empty search string, this is a 2nd lvl search
+        if (!TextUtils.isEmpty(mFilterString)) {
+            mTopLevelSearch = false;
+
+            // get the search type to filter by
+            int type = getIntent().getIntExtra("search_mode", -1);
+            if (type >= 0 && type < ResultType.values().length) {
+                mSearchType = ResultType.values()[type];
+            }
+
+            int resourceId = 0;
+            switch (mSearchType) {
+                case Artist:
+                    resourceId = R.string.search_title_artists;
+                    break;
+                case Album:
+                    resourceId = R.string.search_title_albums;
+                    break;
+                case Playlist:
+                    resourceId = R.string.search_title_playlists;
+                    break;
+                case Song:
+                    resourceId = R.string.search_title_songs;
+                    break;
+            }
+            getSupportActionBar().setTitle(getString(resourceId, mFilterString).toUpperCase());
+            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
+
+            // Set the prefix
+            mAdapter.getUnderlyingAdapter().setPrefix(mFilterString);
+
+            // Start the loader for the query
+            getSupportLoaderManager().initLoader(SEARCH_LOADER, null, this);
+        } else {
+            mTopLevelSearch = true;
+            mSearchHistoryCallback = new SearchHistoryCallback();
+
+            // Start the loader for the search history
+            getSupportLoaderManager().initLoader(HISTORY_LOADER, null, mSearchHistoryCallback);
+        }
+    }
+
+    /**
+     * Sets up the list view
+     */
+    private void initListView() {
+        // Initialize the grid
+        mListView = (ListView) findViewById(R.id.list_base);
+        // Set the data behind the list
+        mListView.setAdapter(mAdapter);
+        // Release any references to the recycled Views
+        mListView.setRecyclerListener(new RecycleHolder());
+        // Show the albums and songs from the selected artist
+        mListView.setOnItemClickListener(this);
+        // To help make scrolling smooth
+        mListView.setOnScrollListener(this);
+        // sets the touch listener
+        mListView.setOnTouchListener(this);
+        // If we setEmptyView with mLoadingEmptyContainer it causes a crash in DragSortListView
+        // when updating the search.  For now let's manually toggle visibility and come back
+        // to this later
+        //mListView.setEmptyView(mLoadingEmptyContainer);
+
+        // load the search history list view
+        mSearchHistoryListView = (ListView) findViewById(R.id.list_search_history);
+        mSearchHistoryListView.setOnItemClickListener(new OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                String searchItem = (String) mSearchHistoryListView.getAdapter().getItem(position);
+                mSearchView.setQuery(searchItem, true);
+            }
+        });
+        mSearchHistoryListView.setOnTouchListener(this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Loader<SectionListContainer<SearchResult>> onCreateLoader(final int id,
+                                                                     final Bundle args) {
+        IItemCompare<SearchResult> comparator = null;
+
+        // prep the loader in case the query takes a long time
+        setLoading();
+
+        // if we are at the top level, create a comparator to separate the different types into
+        // their own sections (artists, albums, etc)
+        if (mTopLevelSearch) {
+            comparator = SectionCreatorUtils.createSearchResultComparison(this);
+        }
+
+        return new SectionCreator<SearchResult>(this,
+                new SummarySearchLoader(this, mFilterString, mSearchType),
+                comparator);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onCreateOptionsMenu(final Menu menu) {
+        // if we are not a top level search view, we do not need to create the search fields
+        if (!mTopLevelSearch) {
+            return super.onCreateOptionsMenu(menu);
+        }
+
+        // Search view
+        getMenuInflater().inflate(R.menu.search, menu);
+
+        // Filter the list the user is looking it via SearchView
+        MenuItem searchItem = menu.findItem(R.id.menu_search);
+        mSearchView = (SearchView) searchItem.getActionView();
+        mSearchView.setOnQueryTextListener(this);
+        mSearchView.setQueryHint(getString(R.string.searchHint).toUpperCase());
+
+        // The SearchView has no way for you to customize or get access to the search icon in a
+        // normal fashion, so we need to manually look for the icon and change the
+        // layout params to hide it
+//        mSearchView.setIconifiedByDefault(false);
+//        mSearchView.setIconified(false);
+//        int searchButtonId = getResources().getIdentifier("android:id/search_mag_icon", null, null);
+//        ImageView searchIcon = (ImageView)mSearchView.findViewById(searchButtonId);
+//        searchIcon.setLayoutParams(new LinearLayout.LayoutParams(0, 0));
+
+        MenuItemCompat.setOnActionExpandListener(searchItem, new MenuItemCompat.OnActionExpandListener() {
+            @Override
+            public boolean onMenuItemActionExpand(MenuItem item) {
+                return true;
+            }
+
+            @Override
+            public boolean onMenuItemActionCollapse(MenuItem item) {
+                quit();
+                return false;
+            }
+        });
+
+        menu.findItem(R.id.menu_search).expandActionView();
+
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    private void quit() {
+        mQuitting = true;
+        finish();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        // Unbind from the service
+        if (mService != null) {
+            MusicUtils.unbindFromService(mToken);
+            mToken = null;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onOptionsItemSelected(final MenuItem item) {
+        switch (item.getItemId()) {
+            case android.R.id.home:
+                quit();
+                return true;
+            default:
+                break;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoadFinished(final Loader<SectionListContainer<SearchResult>> loader,
+                               final SectionListContainer<SearchResult> data) {
+        // Check for any errors
+        if (data.mListResults.isEmpty()) {
+            // clear the adapter
+            mAdapter.clear();
+            // show the empty state
+            setState(VisibleState.Empty);
+        } else {
+            // Set the data
+            mAdapter.setData(data);
+            // show the search results
+            setState(VisibleState.SearchResults);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoaderReset(final Loader<SectionListContainer<SearchResult>> loader) {
+        mAdapter.unload();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onScrollStateChanged(final AbsListView view, final int scrollState) {
+        // Pause disk cache access to ensure smoother scrolling
+        if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_FLING) {
+            mAdapter.getUnderlyingAdapter().setPauseDiskCache(true);
+        } else {
+            mAdapter.getUnderlyingAdapter().setPauseDiskCache(false);
+            mAdapter.notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onQueryTextSubmit(final String query) {
+        // simulate an on query text change
+        onQueryTextChange(query);
+        // hide the input manager
+        hideInputManager();
+
+        return true;
+    }
+
+    public void hideInputManager() {
+        // When the search is "committed" by the user, then hide the keyboard so
+        // the user can more easily browse the list of results.
+        if (mSearchView != null) {
+            if (mImm != null) {
+                mImm.hideSoftInputFromWindow(mSearchView.getWindowToken(), 0);
+            }
+            mSearchView.clearFocus();
+
+            // add our search string
+            SearchHistory.getInstance(this).addSearchString(mFilterString);
+        }
+    }
+
+    /**
+     * This posts a delayed for showing the loading screen.  The reason for the delayed is we
+     * don't want to flash the loading icon very often since searches usually are pretty fast
+     */
+    public void setLoading() {
+        if (mCurrentState != VisibleState.Loading) {
+//            if (!mHandler.hasCallbacks(mLoadingRunnable)) {
+            mHandler.postDelayed(mLoadingRunnable, LOADING_DELAY);
+//            }
+        }
+    }
+
+    /**
+     * Sets the currently visible view
+     *
+     * @param state the current visible state
+     */
+    public void setState(VisibleState state) {
+        // remove any delayed runnables.  This has to be before mCurrentState == state
+        // in case the state doesn't change but we've created a loading runnable
+        mHandler.removeCallbacks(mLoadingRunnable);
+
+        // if we are already looking at view already, just quit
+        if (mCurrentState == state) {
+            return;
+        }
+
+        mCurrentState = state;
+
+        mSearchHistoryListView.setVisibility(View.INVISIBLE);
+        mListView.setVisibility(View.INVISIBLE);
+        mLoadingEmptyContainer.setVisibility(View.INVISIBLE);
+
+        switch (mCurrentState) {
+            case SearchHistory:
+                mSearchHistoryListView.setVisibility(View.VISIBLE);
+                break;
+            case SearchResults:
+                mListView.setVisibility(View.VISIBLE);
+                break;
+            case Empty:
+                mLoadingEmptyContainer.setVisibility(View.VISIBLE);
+                mLoadingEmptyContainer.showNoResults();
+                break;
+            case Loading:
+                mLoadingEmptyContainer.setVisibility(View.VISIBLE);
+                mLoadingEmptyContainer.showLoading();
+                break;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onQueryTextChange(final String newText) {
+        if (mQuitting) {
+            return true;
+        }
+
+        if (TextUtils.isEmpty(newText)) {
+            if (!TextUtils.isEmpty(mFilterString)) {
+                mFilterString = "";
+                getSupportLoaderManager().restartLoader(HISTORY_LOADER, null,
+                        mSearchHistoryCallback);
+                getSupportLoaderManager().destroyLoader(SEARCH_LOADER);
+            }
+
+            return true;
+        }
+
+        // if the strings are the same, return
+        if (newText.equals(mFilterString)) {
+            return true;
+        }
+
+        // Called when the action bar search text has changed. Update
+        // the search filter, and restart the loader to do a new query
+        // with this filter.
+        mFilterString = newText;
+        // Set the prefix
+        mAdapter.getUnderlyingAdapter().setPrefix(mFilterString);
+        getSupportLoaderManager().restartLoader(SEARCH_LOADER, null, this);
+        getSupportLoaderManager().destroyLoader(HISTORY_LOADER);
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onItemClick(final AdapterView<?> parent, final View view, final int position,
+                            final long id) {
+        if (mAdapter.isSectionFooter(position)) {
+            // since a footer should be after a list item by definition, let's look up the type
+            // of the previous item
+            SearchResult item = mAdapter.getTItem(position - 1);
+            Intent intent = new Intent(this, SearchActivity.class);
+            intent.putExtra(SearchManager.QUERY, mFilterString);
+            intent.putExtra("search_mode", item.mType.ordinal());
+            startActivity(intent);
+        } else {
+            SearchResult item = mAdapter.getTItem(position);
+            switch (item.mType) {
+                case Artist:
+                    NavUtils.openArtistProfile(this, item.mArtist);
+                    break;
+                case Album:
+                    NavUtils.openAlbumProfile(this, item.mAlbum, item.mArtist, item.mId);
+                    break;
+                case Playlist:
+                    NavUtils.openPlaylist(this, item.mId, item.mTitle);
+                    break;
+                case Song:
+                    // If it's a song, play it and leave
+                    final long[] list = new long[]{
+                            item.mId
+                    };
+                    MusicUtils.playAll(this, list, 0, -1, Config.IdType.NA, false);
+                    break;
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onServiceConnected(final ComponentName name, final IBinder service) {
+        mService = IElevenService.Stub.asInterface(service);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onServiceDisconnected(final ComponentName name) {
+        mService = null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onScroll(final AbsListView view, final int firstVisibleItem,
+                         final int visibleItemCount, final int totalItemCount) {
+        // Nothing to do
+    }
+
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+        hideInputManager();
+        return false;
+    }
+
+    /**
+     * This tracks our current visible state between the different views
+     */
+    enum VisibleState {
+        SearchHistory,
+        Empty,
+        SearchResults,
+        Loading,
+    }
+
+    /**
+     * This class loads a search result summary of items
+     */
+    private static final class SummarySearchLoader extends SimpleListLoader<SearchResult> {
+        private final String mQuery;
+        private final ResultType mSearchType;
+
+        public SummarySearchLoader(final Context context, final String query,
+                                   final ResultType searchType) {
+            super(context);
+            mQuery = query;
+            mSearchType = searchType;
+        }
+
+        public static Cursor makePlaylistSearchCursor(final Context context,
+                                                      final String searchTerms) {
+            if (TextUtils.isEmpty(searchTerms)) {
+                return null;
+            }
+
+            // trim out special characters like % or \ as well as things like "a" "and" etc
+            String trimmedSearchTerms = MusicUtils.getTrimmedName(searchTerms);
+
+            if (TextUtils.isEmpty(trimmedSearchTerms)) {
+                return null;
+            }
+
+            String[] keywords = trimmedSearchTerms.split(" ");
+
+            // prep the keyword for like search
+            for (int i = 0; i < keywords.length; i++) {
+                keywords[i] = "%" + keywords[i] + "%";
+            }
+
+            String where = "";
+
+            // make the where clause
+            for (int i = 0; i < keywords.length; i++) {
+                if (i == 0) {
+                    where = "name LIKE ?";
+                } else {
+                    where += " AND name LIKE ?";
+                }
+            }
+
+            return context.getContentResolver().query(
+                    MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
+                    new String[]{
+                        /* 0 */
+                            BaseColumns._ID,
+                        /* 1 */
+                            MediaStore.Audio.PlaylistsColumns.NAME
+                    }, where, keywords, MediaStore.Audio.Playlists.DEFAULT_SORT_ORDER);
+        }
+
+        /**
+         * This creates a search result given the data at the cursor position
+         *
+         * @param cursor at the position for the item
+         * @param type   the type of item to create
+         * @return the search result
+         */
+        protected SearchResult createSearchResult(final Cursor cursor, ResultType type) {
+            SearchResult item = null;
+
+            switch (type) {
+                case Playlist:
+                    item = SearchResult.createPlaylistResult(cursor);
+                    item.mSongCount = MusicUtils.getSongCountForPlaylist(getContext(), item.mId);
+                    break;
+                case Song:
+                    item = SearchResult.createSearchResult(cursor);
+                    if (item != null) {
+                        AlbumArtistDetails details = MusicUtils.getAlbumArtDetails(getContext(),
+                                item.mId);
+                        if (details != null) {
+                            item.mArtist = details.mArtistName;
+                            item.mAlbum = details.mAlbumName;
+                            item.mAlbumId = details.mAlbumId;
+                        }
+                    }
+                    break;
+                case Album:
+                case Artist:
+                default:
+                    item = SearchResult.createSearchResult(cursor);
+                    break;
+            }
+
+            return item;
+        }
+
+        @Override
+        public List<SearchResult> loadInBackground() {
+            // if we are doing a specific type search, run that one
+            if (mSearchType != null && mSearchType != ResultType.Unknown) {
+                return runSearchForType();
+            }
+
+            return runGenericSearch();
+        }
+
+        /**
+         * This creates a search for a specific type given a filter string.  This will return the
+         * full list of results that matches those two requirements
+         *
+         * @return the results for that search
+         */
+        protected List<SearchResult> runSearchForType() {
+            ArrayList<SearchResult> results = new ArrayList<SearchResult>();
+            Cursor cursor = null;
+            try {
+                if (mSearchType == ResultType.Playlist) {
+                    cursor = makePlaylistSearchCursor(getContext(), mQuery);
+                } else {
+                    cursor = ApolloUtils.createSearchQueryCursor(getContext(), mQuery);
+                }
+
+                // pre-cache this index
+                final int mimeTypeIndex = cursor.getColumnIndex(MediaStore.Audio.Media.MIME_TYPE);
+
+                if (cursor != null && cursor.moveToFirst()) {
+                    do {
+                        boolean addResult = true;
+
+                        if (mSearchType != ResultType.Playlist) {
+                            // get the result type
+                            ResultType type = ResultType.getResultType(cursor, mimeTypeIndex);
+                            if (type != mSearchType) {
+                                addResult = false;
+                            }
+                        }
+
+                        if (addResult) {
+                            results.add(createSearchResult(cursor, mSearchType));
+                        }
+                    } while (cursor.moveToNext());
+                }
+
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                    cursor = null;
+                }
+            }
+
+            return results;
+        }
+
+        /**
+         * This will run a search given a filter string and return the top NUM_RESULTS_TO_GET per
+         * type
+         *
+         * @return the results for that search
+         */
+        public List<SearchResult> runGenericSearch() {
+            ArrayList<SearchResult> results = new ArrayList<SearchResult>();
+            // number of types to query for
+            final int numTypes = ResultType.getNumTypes();
+
+            // number of results we want
+            final int numResultsNeeded = Config.SEARCH_NUM_RESULTS_TO_GET * numTypes;
+
+            // current number of results we have
+            int numResultsAdded = 0;
+
+            // count for each result type
+            int[] numOfEachType = new int[numTypes];
+
+            // search playlists first
+            Cursor playlistCursor = makePlaylistSearchCursor(getContext(), mQuery);
+            if (playlistCursor != null && playlistCursor.moveToFirst()) {
+                do {
+                    // create the item
+                    SearchResult item = createSearchResult(playlistCursor, ResultType.Playlist);
+                    /// add the results
+                    numResultsAdded++;
+                    results.add(item);
+                } while (playlistCursor.moveToNext()
+                        && numResultsAdded < Config.SEARCH_NUM_RESULTS_TO_GET);
+
+                // because we deal with playlists separately,
+                // just mark that we have the full # of playlists
+                // so that logic later can quit out early if full
+                numResultsAdded = Config.SEARCH_NUM_RESULTS_TO_GET;
+
+                // close the cursor
+                playlistCursor.close();
+                playlistCursor = null;
+            }
+
+            // do fancy audio search
+            Cursor cursor = ApolloUtils.createSearchQueryCursor(getContext(), mQuery);
+
+            // pre-cache this index
+            final int mimeTypeIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.MIME_TYPE);
+
+            // walk through the cursor
+            if (cursor != null && cursor.moveToFirst()) {
+                do {
+                    // get the result type
+                    ResultType type = ResultType.getResultType(cursor, mimeTypeIndex);
+
+                    // if we still need this type
+                    if (numOfEachType[type.ordinal()] < Config.SEARCH_NUM_RESULTS_TO_GET) {
+                        // get the search result
+                        SearchResult item = createSearchResult(cursor, type);
+
+                        if (item != null) {
+                            // add it
+                            results.add(item);
+                            numOfEachType[type.ordinal()]++;
+                            numResultsAdded++;
+
+                            // if we have enough then quit
+                            if (numResultsAdded >= numResultsNeeded) {
+                                break;
+                            }
+                        }
+                    }
+                } while (cursor.moveToNext());
+
+                cursor.close();
+                cursor = null;
+            }
+
+            // sort our results
+            Collections.sort(results, SearchResult.COMPARATOR);
+
+            return results;
+        }
+    }
+
+    /**
+     * Loads the search history in the background and creates an array adapter
+     */
+    public static class SearchHistoryLoader extends WrappedAsyncTaskLoader<ArrayAdapter<String>> {
+        public SearchHistoryLoader(Context context) {
+            super(context);
+        }
+
+        @Override
+        public ArrayAdapter<String> loadInBackground() {
+            ArrayList<String> strings = SearchHistory.getInstance(getContext()).getRecentSearches();
+            ArrayAdapter<String> adapter = new ArrayAdapter<String>(getContext(),
+                    R.layout.list_item_search_history, R.id.line_one);
+            adapter.addAll(strings);
+            return adapter;
+        }
+    }
+
+    /**
+     * This handles the Loader callbacks for the search history
+     */
+    public class SearchHistoryCallback implements LoaderCallbacks<ArrayAdapter<String>> {
+        @Override
+        public Loader<ArrayAdapter<String>> onCreateLoader(int i, Bundle bundle) {
+            // prep the loader in case the query takes a long time
+            setLoading();
+
+            return new SearchHistoryLoader(SearchActivity.this);
+        }
+
+        @Override
+        public void onLoadFinished(Loader<ArrayAdapter<String>> searchHistoryAdapterLoader,
+                                   ArrayAdapter<String> searchHistoryAdapter) {
+            // show the search history
+            setState(VisibleState.SearchHistory);
+
+            mSearchHistoryListView.setAdapter(searchHistoryAdapter);
+        }
+
+        @Override
+        public void onLoaderReset(Loader<ArrayAdapter<String>> cursorAdapterLoader) {
+            ((ArrayAdapter) mSearchHistoryListView.getAdapter()).clear();
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/activities/SettingsActivity.java b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/SettingsActivity.java
new file mode 100755
index 0000000000..1998beaefe
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/SettingsActivity.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.activities;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
+import android.os.Bundle;
+import android.preference.Preference;
+import android.preference.Preference.OnPreferenceClickListener;
+import android.preference.PreferenceActivity;
+import android.view.MenuItem;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PreferenceUtils;
+
+/**
+ * Settings.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+@SuppressWarnings("deprecation")
+public class SettingsActivity extends PreferenceActivity implements OnSharedPreferenceChangeListener {
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        // Fade it in
+        overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
+
+//         UP
+//        getActionBar().setDisplayHomeAsUpEnabled(true);
+
+        // Add the preferences
+        addPreferencesFromResource(R.xml.settings);
+
+        // Removes the cache entries
+        deleteCache();
+
+        PreferenceUtils.getInstance(this).setOnSharedPreferenceChangeListener(this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onOptionsItemSelected(final MenuItem item) {
+        switch (item.getItemId()) {
+            case android.R.id.home:
+                onBackPressed();
+                finish();
+                return true;
+            default:
+                break;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    /**
+     * Removes all of the cache entries.
+     */
+    private void deleteCache() {
+        final Preference deleteCache = findPreference("delete_cache");
+        deleteCache.setOnPreferenceClickListener(new OnPreferenceClickListener() {
+            @Override
+            public boolean onPreferenceClick(final Preference preference) {
+                new AlertDialog.Builder(SettingsActivity.this).setMessage(R.string.delete_warning)
+                        .setPositiveButton(android.R.string.ok, new OnClickListener() {
+                            @Override
+                            public void onClick(final DialogInterface dialog, final int which) {
+                                ImageFetcher.getInstance(SettingsActivity.this).clearCaches();
+                            }
+                        })
+                        .setNegativeButton(R.string.cancel, new OnClickListener() {
+                            @Override
+                            public void onClick(final DialogInterface dialog, final int which) {
+                                dialog.dismiss();
+                            }
+                        })
+                        .create().show();
+                return true;
+            }
+        });
+    }
+
+    @Override
+    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
+                                          String key) {
+        if (key.equals(PreferenceUtils.SHAKE_TO_PLAY)) {
+            MusicUtils.setShakeToPlayEnabled(sharedPreferences.getBoolean(key, false));
+        } else if (key.equals(PreferenceUtils.SHOW_ALBUM_ART_ON_LOCKSCREEN)) {
+            MusicUtils.setShowAlbumArtOnLockscreen(sharedPreferences.getBoolean(key, true));
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/activities/SlidingPanelActivity.java b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/SlidingPanelActivity.java
new file mode 100755
index 0000000000..9d49922b6c
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/SlidingPanelActivity.java
@@ -0,0 +1,320 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.activities;
+
+import android.graphics.Color;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.view.ViewPager;
+import android.view.View;
+import android.widget.LinearLayout;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.slidinguppanel.SlidingUpPanelLayout;
+import com.dolzzo.twelve.slidinguppanel.SlidingUpPanelLayout.SimplePanelSlideListener;
+import com.dolzzo.twelve.ui.HeaderBar;
+import com.dolzzo.twelve.ui.fragments.AudioPlayerFragment;
+import com.dolzzo.twelve.ui.fragments.QueueFragment;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.BlurScrimImage;
+
+/**
+ * This class is used to display the {@link ViewPager} used to swipe between the
+ * main {@link Fragment}s used to browse the user's music.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public abstract class SlidingPanelActivity extends BaseActivity {
+
+    private static final String STATE_KEY_CURRENT_PANEL = "CurrentPanel";
+    private final ShowPanelClickListener mShowBrowse = new ShowPanelClickListener(Panel.Browse);
+    private final ShowPanelClickListener mShowMusicPlayer = new ShowPanelClickListener(Panel.MusicPlayer);
+    protected Panel mTargetNavigatePanel;
+    private SlidingUpPanelLayout mFirstPanel;
+    private SlidingUpPanelLayout mSecondPanel;
+    /**
+     * Opens the now playing screen
+     */
+    private final View.OnClickListener mOpenNowPlaying = new View.OnClickListener() {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onClick(final View v) {
+            if (MusicUtils.getCurrentAudioId() != -1) {
+                openAudioPlayer();
+            } else {
+                MusicUtils.shuffleAll(SlidingPanelActivity.this);
+            }
+        }
+    };
+    // this is the blurred image that goes behind the now playing and queue fragments
+    private BlurScrimImage mBlurScrimImage;
+
+    @Override
+    protected void initBottomActionBar() {
+        super.initBottomActionBar();
+        // Bottom action bar
+        final LinearLayout bottomActionBar = (LinearLayout) findViewById(R.id.bottom_action_bar);
+        // Display the now playing screen or shuffle if this isn't anything
+        // playing
+        bottomActionBar.setOnClickListener(mOpenNowPlaying);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        mTargetNavigatePanel = Panel.None;
+
+        setupFirstPanel();
+        setupSecondPanel();
+
+        // get the blur scrim image
+        mBlurScrimImage = (BlurScrimImage) findViewById(R.id.blurScrimImage);
+
+        if (savedInstanceState != null) {
+            int panelIndex = savedInstanceState.getInt(STATE_KEY_CURRENT_PANEL,
+                    Panel.Browse.ordinal());
+            Panel targetPanel = Panel.values()[panelIndex];
+
+            showPanel(targetPanel);
+            mTargetNavigatePanel = Panel.None;
+
+            if (targetPanel == Panel.Queue) {
+                mFirstPanel.setSlidingEnabled(false);
+            }
+        }
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        outState.putInt(STATE_KEY_CURRENT_PANEL, getCurrentPanel().ordinal());
+    }
+
+    private void setupFirstPanel() {
+        mFirstPanel = (SlidingUpPanelLayout) findViewById(R.id.sliding_layout);
+        mFirstPanel.setPanelSlideListener(new SimplePanelSlideListener() {
+            @Override
+            public void onPanelSlide(View panel, float slideOffset) {
+                onSlide(slideOffset);
+            }
+
+            @Override
+            public void onPanelExpanded(View panel) {
+                checkTargetNavigation();
+            }
+
+            @Override
+            public void onPanelCollapsed(View panel) {
+                checkTargetNavigation();
+            }
+        });
+    }
+
+    private void setupSecondPanel() {
+        mSecondPanel = (SlidingUpPanelLayout) findViewById(R.id.sliding_layout2);
+        mSecondPanel.setPanelSlideListener(new SimplePanelSlideListener() {
+            @Override
+            public void onPanelSlide(View panel, float slideOffset) {
+                // if we are not going to a specific panel, then disable sliding to prevent
+                // the two sliding panels from fighting for touch input
+                if (mTargetNavigatePanel == Panel.None) {
+                    mFirstPanel.setSlidingEnabled(false);
+                }
+
+                onSlide(slideOffset);
+            }
+
+            @Override
+            public void onPanelExpanded(View panel) {
+                checkTargetNavigation();
+            }
+
+            @Override
+            public void onPanelCollapsed(View panel) {
+                // re-enable sliding when the second panel is collapsed
+                mFirstPanel.setSlidingEnabled(true);
+                checkTargetNavigation();
+            }
+        });
+
+        // setup the header bar
+        setupHeaderBar(R.id.secondHeaderBar, R.string.page_play_queue, mShowMusicPlayer);
+
+        // set the drag view offset to allow the panel to go past the top of the viewport
+        // since the previous view's is hiding the slide offset, we need to subtract that
+        // from action bat height
+        int slideOffset = getResources().getDimensionPixelOffset(R.dimen.sliding_panel_indicator_height);
+        slideOffset -= ApolloUtils.getActionBarHeight(this);
+        mSecondPanel.setSlidePanelOffset(slideOffset);
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int setContentView() {
+        return R.layout.activity_base;
+    }
+
+    @Override
+    public void onBackPressed() {
+        Panel panel = getCurrentPanel();
+        switch (panel) {
+            case Browse:
+                super.onBackPressed();
+                break;
+            default:
+            case MusicPlayer:
+                showPanel(Panel.Browse);
+                break;
+            case Queue:
+                showPanel(Panel.MusicPlayer);
+                break;
+        }
+    }
+
+    public void openAudioPlayer() {
+        showPanel(Panel.MusicPlayer);
+    }
+
+    public void showPanel(Panel panel) {
+        // if we are already at our target panel, then don't do anything
+        if (panel == getCurrentPanel()) {
+            return;
+        }
+
+        // TODO: Add ability to do this instantaneously as opposed to animate
+        switch (panel) {
+            case Browse:
+                // if we are two panels over, we need special logic to jump twice
+                mTargetNavigatePanel = panel;
+                mSecondPanel.collapsePanel();
+                // re-enable sliding on first panel so we can collapse it
+                mFirstPanel.setSlidingEnabled(true);
+                mFirstPanel.collapsePanel();
+                break;
+            case MusicPlayer:
+                mSecondPanel.collapsePanel();
+                mFirstPanel.expandPanel();
+                break;
+            case Queue:
+                // if we are two panels over, we need special logic to jump twice
+                mTargetNavigatePanel = panel;
+                mSecondPanel.expandPanel();
+                mFirstPanel.expandPanel();
+                break;
+        }
+    }
+
+    protected void onSlide(float slideOffset) {
+
+    }
+
+    /**
+     * This checks if we are at our target panel and resets our flag if we are there
+     */
+    protected void checkTargetNavigation() {
+        if (mTargetNavigatePanel == getCurrentPanel()) {
+            mTargetNavigatePanel = Panel.None;
+        }
+
+        getAudioPlayerFragment().setVisualizerVisible(getCurrentPanel() == Panel.MusicPlayer);
+    }
+
+    public Panel getCurrentPanel() {
+        if (mSecondPanel.isPanelExpanded()) {
+            return Panel.Queue;
+        } else if (mFirstPanel.isPanelExpanded()) {
+            return Panel.MusicPlayer;
+        } else {
+            return Panel.Browse;
+        }
+    }
+
+    public void clearMetaInfo() {
+        super.clearMetaInfo();
+        mBlurScrimImage.transitionToDefaultState();
+    }
+
+    @Override
+    public void onMetaChanged() {
+        super.onMetaChanged();
+
+        // load the blurred image
+        mBlurScrimImage.loadBlurImage(ApolloUtils.getImageFetcher(this));
+    }
+
+    @Override
+    public void onCacheUnpaused() {
+        super.onCacheUnpaused();
+
+        // load the blurred image
+        mBlurScrimImage.loadBlurImage(ApolloUtils.getImageFetcher(this));
+    }
+
+    protected AudioPlayerFragment getAudioPlayerFragment() {
+        return (AudioPlayerFragment) getSupportFragmentManager().findFragmentById(R.id.audioPlayerFragment);
+    }
+
+    protected QueueFragment getQueueFragment() {
+        return (QueueFragment) getSupportFragmentManager().findFragmentById(R.id.queueFragment);
+    }
+
+    protected HeaderBar setupHeaderBar(final int containerId, final int textId,
+                                       final View.OnClickListener headerClickListener) {
+        final HeaderBar headerBar = (HeaderBar) findViewById(containerId);
+        headerBar.setFragment(getQueueFragment());
+        headerBar.setTitleText(textId);
+        headerBar.setBackgroundColor(Color.TRANSPARENT);
+        headerBar.setBackListener(mShowBrowse);
+        headerBar.setHeaderClickListener(headerClickListener);
+
+        return headerBar;
+    }
+
+    public enum Panel {
+        Browse,
+        MusicPlayer,
+        Queue,
+        None,
+    }
+
+    private class ShowPanelClickListener implements View.OnClickListener {
+
+        private Panel mTargetPanel;
+
+        public ShowPanelClickListener(Panel targetPanel) {
+            mTargetPanel = targetPanel;
+        }
+
+        @Override
+        public void onClick(View v) {
+            showPanel(mTargetPanel);
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/activities/preview/AudioPreviewActivity.java b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/preview/AudioPreviewActivity.java
new file mode 100755
index 0000000000..60c612a981
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/preview/AudioPreviewActivity.java
@@ -0,0 +1,747 @@
+/*
+* Copyright (C) 2015 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.dolzzo.twelve.ui.activities.preview;
+
+import android.app.Activity;
+import android.content.AsyncQueryHandler;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.database.Cursor;
+import android.graphics.Rect;
+import android.media.AudioManager;
+import android.media.AudioManager.OnAudioFocusChangeListener;
+import android.media.MediaPlayer;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.provider.MediaStore.Audio.Media;
+import android.text.TextUtils;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnTouchListener;
+import android.view.Window;
+import android.widget.ImageButton;
+import android.widget.ProgressBar;
+import android.widget.SeekBar;
+import android.widget.SeekBar.OnSeekBarChangeListener;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.activities.preview.util.Logger;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+
+/**
+ * AudioPreview
+ * <pre>
+ *     Preview plays external audio files in a dialog over the application
+ * </pre>
+ *
+ * @see {@link Activity}
+ * @see {@link android.media.MediaPlayer.OnCompletionListener}
+ * @see {@link android.media.MediaPlayer.OnErrorListener}
+ * @see {@link android.media.MediaPlayer.OnPreparedListener}
+ * @see {@link OnClickListener}
+ * @see {@link OnAudioFocusChangeListener}
+ * @see {@link OnSeekBarChangeListener}
+ */
+public class AudioPreviewActivity extends Activity implements MediaPlayer.OnCompletionListener,
+        MediaPlayer.OnErrorListener, MediaPlayer.OnPreparedListener, OnClickListener,
+        OnAudioFocusChangeListener, OnSeekBarChangeListener, OnTouchListener {
+
+    // Constants
+    private static final String TAG = AudioPreviewActivity.class.getSimpleName();
+    private static final int PROGRESS_DELAY_INTERVAL = 250;
+    private static final String SCHEME_CONTENT = "content";
+    private static final String SCHEME_FILE = "file";
+    private static final String SCHEME_HTTP = "http";
+    private static final String AUTHORITY_MEDIA = "media";
+    private static final int CONTENT_QUERY_TOKEN = 1000;
+    private static final int CONTENT_BAD_QUERY_TOKEN = CONTENT_QUERY_TOKEN + 1;
+    private static final String[] MEDIA_PROJECTION = new String[]{
+            Media.TITLE,
+            Media.ARTIST
+    };
+    private static AsyncQueryHandler sAsyncQueryHandler;
+    // Seeking flag
+    private boolean mIsSeeking = false;
+    private boolean mWasPlaying = false;
+    private UiHandler mHandler = new UiHandler();
+    private AudioManager mAudioManager;
+    private PreviewPlayer mPreviewPlayer;
+    private PreviewSong mPreviewSong = new PreviewSong();
+    private int mDuration = 0;
+    private int mLastOrientationWhileBuffering;
+    // Views
+    private TextView mTitleTextView;
+    private TextView mArtistTextView;
+    private SeekBar mSeekBar;
+    private ProgressBar mProgressBar;
+    private ImageButton mPlayPauseBtn;
+    private View mContainerView;
+    // Flags
+    private boolean mIsReceiverRegistered = false;
+    private State mCurrentState = State.INIT;
+    // Members
+    private final BroadcastReceiver mAudioNoisyReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            // [NOTE][MSB]: Handle any audio output changes
+            if (intent != null) {
+                if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction())) {
+                    pausePlayback();
+                }
+            }
+        }
+    };
+
+    @Override
+    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+        if (mPreviewPlayer != null && mIsSeeking) {
+            mPreviewPlayer.seekTo(progress);
+        }
+    }
+
+    @Override
+    public void onStartTrackingTouch(SeekBar seekBar) {
+        mIsSeeking = true;
+        if (mCurrentState == State.PLAYING) {
+            mWasPlaying = true;
+            pausePlayback(false);
+        }
+    }
+
+    @Override
+    public void onStopTrackingTouch(SeekBar seekBar) {
+        if (mWasPlaying) {
+            startPlayback();
+        }
+        mWasPlaying = false;
+        mIsSeeking = false;
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        overridePendingTransition(0, 0);
+        super.onCreate(savedInstanceState);
+        mLastOrientationWhileBuffering = getRequestedOrientation();
+        Logger.logd(TAG, "onCreate(" + savedInstanceState + ")");
+        Intent intent = getIntent();
+        if (intent == null) {
+            Logger.loge(TAG, "No intent");
+            finish();
+            return;
+        }
+        Uri uri = intent.getData();
+        if (uri == null) {
+            Logger.loge(TAG, "No uri data");
+            finish();
+            return;
+        }
+        Logger.logd(TAG, "URI: " + uri);
+        mPreviewSong.URI = uri;
+        PreviewPlayer localPlayer = (PreviewPlayer) getLastNonConfigurationInstance();
+        if (localPlayer == null) {
+            mPreviewPlayer = new PreviewPlayer();
+            mPreviewPlayer.setCallbackActivity(this);
+            try {
+                mPreviewPlayer.setDataSourceAndPrepare(mPreviewSong.URI);
+            } catch (IOException e) {
+                Logger.loge(TAG, e.getMessage());
+                onError(mPreviewPlayer, MediaPlayer.MEDIA_ERROR_IO, 0);
+                return;
+            }
+        } else {
+            mPreviewPlayer = localPlayer;
+            mPreviewPlayer.setCallbackActivity(this);
+        }
+        mAudioManager = ((AudioManager) getSystemService(Context.AUDIO_SERVICE));
+        sAsyncQueryHandler = new AsyncQueryHandler(getContentResolver()) {
+            @Override
+            protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
+                AudioPreviewActivity.this.onQueryComplete(token, cookie, cursor);
+            }
+        };
+        initializeInterface();
+        registerNoisyAudioReceiver();
+        if (savedInstanceState == null) {
+            processUri();
+        } else {
+            mPreviewSong.TITLE = savedInstanceState.getString(Media.TITLE);
+            mPreviewSong.ARTIST = savedInstanceState.getString(Media.ARTIST);
+            setNames();
+        }
+        if (localPlayer != null) {
+            sendStateChange(State.PREPARED);
+            if (localPlayer.isPlaying()) {
+                startProgressUpdates();
+                sendStateChange(State.PLAYING);
+            }
+        }
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        if (mIsReceiverRegistered) {
+            unregisterReceiver(mAudioNoisyReceiver);
+            mIsReceiverRegistered = false;
+        }
+        outState.putString(Media.TITLE, mPreviewSong.TITLE);
+        outState.putString(Media.ARTIST, mPreviewSong.ARTIST);
+        super.onSaveInstanceState(outState);
+    }
+
+    @Override
+    public Object onRetainNonConfigurationInstance() {
+        mPreviewPlayer.clearCallbackActivity();
+        PreviewPlayer localPlayer = mPreviewPlayer;
+        mPreviewPlayer = null;
+        return localPlayer;
+    }
+
+    @Override
+    public void onPause() {
+        overridePendingTransition(0, 0);
+        super.onPause();
+    }
+
+    @Override
+    public void onDestroy() {
+        if (mIsReceiverRegistered) {
+            unregisterReceiver(mAudioNoisyReceiver);
+            mIsReceiverRegistered = false;
+        }
+        stopPlaybackAndTeardown();
+        super.onDestroy();
+    }
+
+    private void sendStateChange(State newState) {
+        mCurrentState = newState;
+        handleStateChangeForUi();
+    }
+
+    private void handleStateChangeForUi() {
+        switch (mCurrentState) {
+            case INIT:
+                Logger.logd(TAG, "INIT");
+                break;
+            case PREPARED:
+                Logger.logd(TAG, "PREPARED");
+                if (mPreviewPlayer != null) {
+                    mDuration = mPreviewPlayer.getDuration();
+                }
+                if (mDuration > 0 && mSeekBar != null) {
+                    mSeekBar.setMax(mDuration);
+                    mSeekBar.setEnabled(true);
+                    mSeekBar.setVisibility(View.VISIBLE);
+                }
+                if (mProgressBar != null) {
+                    mProgressBar.setVisibility(View.INVISIBLE);
+                    setRequestedOrientation(mLastOrientationWhileBuffering);
+                }
+                if (mPlayPauseBtn != null) {
+                    mPlayPauseBtn.setImageResource(R.drawable.btn_playback_play);
+                    mPlayPauseBtn.setEnabled(true);
+                    mPlayPauseBtn.setOnClickListener(this);
+                }
+                break;
+            case PLAYING:
+                Logger.logd(TAG, "PLAYING");
+                if (mPlayPauseBtn != null) {
+                    mPlayPauseBtn.setImageResource(R.drawable.btn_playback_pause);
+                    mPlayPauseBtn.setEnabled(true);
+                }
+                break;
+            case PAUSED:
+                Logger.logd(TAG, "PAUSED");
+                if (mPlayPauseBtn != null) {
+                    mPlayPauseBtn.setImageResource(R.drawable.btn_playback_play);
+                    mPlayPauseBtn.setEnabled(true);
+                }
+                break;
+        }
+        setNames();
+    }
+
+    private void onQueryComplete(int token, Object cookie, Cursor cursor) {
+        String title = null;
+        String artist = null;
+        if (cursor == null || cursor.getCount() < 1) {
+            Logger.loge(TAG, "Null or empty cursor!");
+            return;
+        }
+        boolean moved = cursor.moveToFirst();
+        if (!moved) {
+            Logger.loge(TAG, "Failed to read cursor!");
+            return;
+        }
+        int index = -1;
+        switch (token) {
+            case CONTENT_QUERY_TOKEN:
+                index = cursor.getColumnIndex(Media.TITLE);
+                if (index > -1) {
+                    title = cursor.getString(index);
+                }
+                index = cursor.getColumnIndex(Media.ARTIST);
+                if (index > -1) {
+                    artist = cursor.getString(index);
+                }
+                break;
+            case CONTENT_BAD_QUERY_TOKEN:
+                index = cursor.getColumnIndex(Media.DISPLAY_NAME);
+                if (index > -1) {
+                    title = cursor.getString(index);
+                }
+                break;
+            default:
+                title = null;
+                break;
+        }
+        cursor.close();
+
+        // Well if we didn't get the name lets fallback to something else
+        if (TextUtils.isEmpty(title)) {
+            title = getNameFromPath();
+        }
+
+        mPreviewSong.TITLE = title;
+        mPreviewSong.ARTIST = artist;
+
+        setNames();
+    }
+
+    private String getNameFromPath() {
+        String path = "Unknown"; // [TODO][MSB]: Localize
+        if (mPreviewSong != null) {
+            if (mPreviewSong.URI != null) {
+                path = mPreviewSong.URI.getLastPathSegment();
+            }
+        }
+        return path;
+    }
+
+    private void setNames() {
+        // Set the text
+        mTitleTextView.setText(mPreviewSong.TITLE);
+        mArtistTextView.setText(mPreviewSong.ARTIST);
+    }
+
+    private void initializeInterface() {
+        setVolumeControlStream(AudioManager.STREAM_MUSIC);
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        setContentView(R.layout.activity_audio_preview);
+        mContainerView = findViewById(R.id.grp_container_view);
+        // Make it so if the user touches the background overlay we exit
+        View v = findViewById(R.id.grp_transparent_wrapper);
+        v.setOnTouchListener(this);
+        mTitleTextView = (TextView) findViewById(R.id.tv_title);
+        mArtistTextView = (TextView) findViewById(R.id.tv_artist);
+        mSeekBar = (SeekBar) findViewById(R.id.sb_progress);
+        mSeekBar.setOnSeekBarChangeListener(this);
+        mProgressBar = (ProgressBar) findViewById(R.id.pb_loader);
+        mPlayPauseBtn = (ImageButton) findViewById(R.id.ib_playpause);
+    }
+
+    private void processUri() {
+        String scheme = mPreviewSong.URI.getScheme();
+        Logger.logd(TAG, "Uri Scheme: " + scheme);
+        if (SCHEME_CONTENT.equalsIgnoreCase(scheme)) {
+            handleContentScheme();
+        } else if (SCHEME_FILE.equalsIgnoreCase(scheme)) {
+            handleFileScheme();
+        } else if (SCHEME_HTTP.equalsIgnoreCase(scheme)) {
+            handleHttpScheme();
+        }
+    }
+
+    private void startProgressUpdates() {
+        if (mHandler != null) {
+            mHandler.removeMessages(UiHandler.MSG_UPDATE_PROGRESS);
+            Message msg = mHandler.obtainMessage(UiHandler.MSG_UPDATE_PROGRESS);
+            mHandler.sendMessage(msg);
+        }
+    }
+
+    private void updateProgressForPlayer() {
+        if (mSeekBar != null && mPreviewPlayer != null) {
+            if (mPreviewPlayer.isPrepared()) {
+                mSeekBar.setProgress(mPreviewPlayer.getCurrentPosition());
+            }
+        }
+        if (mHandler != null) {
+            mHandler.removeMessages(UiHandler.MSG_UPDATE_PROGRESS);
+            Message msg = mHandler.obtainMessage(UiHandler.MSG_UPDATE_PROGRESS);
+            mHandler.sendMessageDelayed(msg, PROGRESS_DELAY_INTERVAL);
+        }
+    }
+
+    private void handleContentScheme() {
+        String authority = mPreviewSong.URI.getAuthority();
+        if (!AUTHORITY_MEDIA.equalsIgnoreCase(authority)) {
+            Logger.logd(TAG, "Bad authority!");
+            sAsyncQueryHandler
+                    .startQuery(CONTENT_BAD_QUERY_TOKEN, null, mPreviewSong.URI, null, null, null,
+                            null);
+        } else {
+            sAsyncQueryHandler
+                    .startQuery(CONTENT_QUERY_TOKEN, null, mPreviewSong.URI, MEDIA_PROJECTION, null,
+                            null, null);
+        }
+    }
+
+    private void handleFileScheme() {
+        if (MusicUtils.isPermissionGranted(getApplicationContext()) == false) {
+            return;
+        }
+
+        String path = mPreviewSong.URI.getPath();
+        sAsyncQueryHandler.startQuery(CONTENT_QUERY_TOKEN, null, Media.EXTERNAL_CONTENT_URI,
+                MEDIA_PROJECTION, "_data=?", new String[]{path}, null);
+    }
+
+    private void handleHttpScheme() {
+        if (mProgressBar != null) {
+            mProgressBar.setVisibility(View.VISIBLE);
+            mLastOrientationWhileBuffering = getRequestedOrientation();
+            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
+        }
+        mPreviewSong.TITLE = getNameFromPath();
+        setNames();
+    }
+
+    private void registerNoisyAudioReceiver() {
+        IntentFilter localIntentFilter = new IntentFilter();
+        localIntentFilter.addAction(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
+        registerReceiver(this.mAudioNoisyReceiver, localIntentFilter);
+        mIsReceiverRegistered = true;
+    }
+
+    @Override
+    public void onCompletion(MediaPlayer mp) {
+        mHandler.removeMessages(UiHandler.MSG_UPDATE_PROGRESS);
+        if (mSeekBar != null && mPreviewPlayer != null) {
+            mSeekBar.setProgress(mPreviewPlayer.getDuration());
+        }
+        sendStateChange(State.PREPARED);
+    }
+
+    @Override
+    public boolean onError(MediaPlayer mp, int what, int extra) {
+        switch (what) {
+            case MediaPlayer.MEDIA_ERROR_SERVER_DIED:
+                Toast.makeText(this, "Server has died!", Toast.LENGTH_SHORT).show();
+                break;
+            case MediaPlayer.MEDIA_ERROR_IO:
+                Toast.makeText(this, "I/O error!", Toast.LENGTH_SHORT).show();
+                break;
+            case MediaPlayer.MEDIA_ERROR_MALFORMED:
+                Toast.makeText(this, "Malformed media!", Toast.LENGTH_SHORT).show();
+                break;
+            case MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK:
+                Toast.makeText(this, "Not valid for progressive playback!", Toast.LENGTH_SHORT)
+                        .show();
+                break;
+            case MediaPlayer.MEDIA_ERROR_TIMED_OUT:
+                Toast.makeText(this, "Media server timed out!", Toast.LENGTH_SHORT).show();
+                break;
+            case MediaPlayer.MEDIA_ERROR_UNSUPPORTED:
+                Toast.makeText(this, "Media is unsupported!", Toast.LENGTH_SHORT).show();
+                break;
+            case MediaPlayer.MEDIA_ERROR_UNKNOWN:
+            default:
+                Toast.makeText(this, "An unkown error has occurred: " + what, Toast.LENGTH_LONG)
+                        .show();
+                break;
+        }
+        stopPlaybackAndTeardown();
+        finish();
+        return true; // false causes flow to not call onCompletion
+    }
+
+    @Override
+    public void onPrepared(MediaPlayer mp) {
+        sendStateChange(State.PREPARED);
+        startPlayback();
+    }
+
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+        int x = (int) event.getX();
+        int y = (int) event.getY();
+        int containerX1 = (int) mContainerView.getX();
+        int containerY1 = (int) mContainerView.getY();
+        int containerX2 = (int) (mContainerView.getX() + mContainerView.getWidth());
+        int containerY2 = (int) (mContainerView.getY() + mContainerView.getHeight());
+
+        Rect r = new Rect();
+        r.set(containerX1, containerY1, containerX2, containerY2);
+        if (!r.contains(x, y)) {
+            stopPlaybackAndTeardown();
+            finish();
+        }
+
+        return false;
+    }
+
+    @Override
+    public void onClick(View v) {
+        switch (v.getId()) {
+            case R.id.ib_playpause:
+                if (mCurrentState == State.PREPARED || mCurrentState == State.PAUSED) {
+                    startPlayback();
+                } else {
+                    pausePlayback();
+                }
+                break;
+            case R.id.grp_transparent_wrapper:
+                stopPlaybackAndTeardown();
+                finish();
+                break;
+            default:
+                break;
+        }
+    }
+
+    private boolean gainAudioFocus() {
+        if (mAudioManager == null) {
+            return false;
+        }
+        int r = mAudioManager.requestAudioFocus(this, AudioManager.STREAM_MUSIC,
+                AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);
+        return r == AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
+    }
+
+    private void abandonAudioFocus() {
+        if (mAudioManager != null) {
+            mAudioManager.abandonAudioFocus(this);
+        }
+    }
+
+    private void startPlayback() {
+        if (mPreviewPlayer != null && !mPreviewPlayer.isPlaying()) {
+            if (mPreviewPlayer.isPrepared()) {
+                if (gainAudioFocus()) {
+                    mPreviewPlayer.start();
+                    sendStateChange(State.PLAYING);
+                    startProgressUpdates();
+                } else {
+                    Logger.loge(TAG, "Failed to gain audio focus!");
+                    onError(mPreviewPlayer, MediaPlayer.MEDIA_ERROR_TIMED_OUT, 0);
+                }
+            } else {
+                Logger.loge(TAG, "Not prepared!");
+            }
+        } else {
+            Logger.logd(TAG, "No player or is not playing!");
+        }
+    }
+
+    private void stopPlaybackAndTeardown() {
+        if (mPreviewPlayer != null) {
+            if (mPreviewPlayer.isPlaying()) {
+                mPreviewPlayer.stop();
+            }
+            mPreviewPlayer.release();
+            mPreviewPlayer = null;
+        }
+        abandonAudioFocus();
+    }
+
+    private void pausePlayback() {
+        pausePlayback(true);
+    }
+
+    private void pausePlayback(boolean updateUi) {
+        if (mPreviewPlayer != null && mPreviewPlayer.isPlaying()) {
+            mPreviewPlayer.pause();
+            if (updateUi) {
+                sendStateChange(State.PAUSED);
+            }
+            mHandler.removeMessages(UiHandler.MSG_UPDATE_PROGRESS);
+        }
+    }
+
+    @Override
+    public void onAudioFocusChange(int focusChange) {
+        if (mPreviewPlayer == null) {
+            if (mAudioManager != null) {
+                mAudioManager.abandonAudioFocus(this);
+            }
+        }
+        Logger.logd(TAG, "Focus change: " + focusChange);
+        switch (focusChange) {
+            case AudioManager.AUDIOFOCUS_LOSS:
+                stopPlaybackAndTeardown();
+                finish();
+                break;
+            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
+                pausePlayback();
+                break;
+            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
+                mPreviewPlayer.setVolume(0.2f, 0.2f);
+                break;
+            case AudioManager.AUDIOFOCUS_GAIN:
+                mPreviewPlayer.setVolume(1.0f, 1.0f);
+                startPlayback();
+                break;
+            case AudioManager.AUDIOFOCUS_GAIN_TRANSIENT:
+            case AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK:
+                break;
+        }
+    }
+
+    @Override
+    public void onUserLeaveHint() {
+        stopPlaybackAndTeardown();
+        finish();
+        super.onUserLeaveHint();
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent keyEvent) {
+        boolean result = true;
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_HEADSETHOOK:
+                pausePlayback();
+                break;
+            case KeyEvent.KEYCODE_MEDIA_NEXT:
+            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+            case KeyEvent.KEYCODE_MEDIA_REWIND:
+            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
+                return result;
+            case KeyEvent.KEYCODE_MEDIA_PLAY:
+                startPlayback();
+                return result;
+            case KeyEvent.KEYCODE_MEDIA_PAUSE:
+                pausePlayback();
+                return result;
+            case KeyEvent.KEYCODE_VOLUME_UP:
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+            case KeyEvent.KEYCODE_VOLUME_MUTE:
+                result = super.onKeyDown(keyCode, keyEvent);
+                return result;
+            default:
+                result = super.onKeyDown(keyCode, keyEvent);
+                break;
+        }
+        stopPlaybackAndTeardown();
+        finish();
+        return result;
+    }
+
+    private enum State {
+        INIT,
+        PREPARED,
+        PLAYING,
+        PAUSED
+    }
+
+    /**
+     * <pre>
+     *     Media player specifically tweaked for use in this audio preview context
+     * </pre>
+     */
+    private static class PreviewPlayer extends MediaPlayer
+            implements MediaPlayer.OnPreparedListener {
+
+        // Members
+        private WeakReference<AudioPreviewActivity> mActivityReference; // weakref from static class
+        private boolean mIsPrepared = false;
+
+        /* package */ PreviewPlayer() {
+            setOnPreparedListener(this);
+        }
+
+        /* package */ boolean isPrepared() {
+            return mIsPrepared;
+        }
+
+        /* package */ void clearCallbackActivity() {
+            mActivityReference.clear();
+            mActivityReference = null;
+            setOnErrorListener(null);
+            setOnCompletionListener(null);
+        }
+
+        /* package */ void setCallbackActivity(AudioPreviewActivity activity)
+                throws IllegalArgumentException {
+            if (activity == null) {
+                throw new IllegalArgumentException("'activity' cannot be null!");
+            }
+            mActivityReference = new WeakReference<AudioPreviewActivity>(activity);
+            setOnErrorListener(activity);
+            setOnCompletionListener(activity);
+        }
+
+        /* package */ void setDataSourceAndPrepare(Uri uri)
+                throws IllegalArgumentException, IOException {
+            if (uri == null || uri.toString().length() < 1) {
+                throw new IllegalArgumentException("'uri' cannot be null or empty!");
+            }
+            AudioPreviewActivity activity = mActivityReference.get();
+            if (activity != null && !activity.isFinishing()) {
+                setDataSource(activity, uri);
+                prepareAsync();
+            }
+        }
+
+        @Override
+        public void onPrepared(MediaPlayer mp) {
+            mIsPrepared = true;
+            if (mActivityReference != null) {
+                AudioPreviewActivity activity = mActivityReference.get();
+                if (activity != null && !activity.isFinishing()) {
+                    activity.onPrepared(mp);
+                }
+            }
+        }
+
+    }
+
+    /**
+     * <pre>
+     *     Handle some ui events
+     * </pre>
+     *
+     * @see {@link Handler}
+     */
+    private class UiHandler extends Handler {
+
+        public static final int MSG_UPDATE_PROGRESS = 1000;
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_UPDATE_PROGRESS:
+                    updateProgressForPlayer();
+                    break;
+                default:
+                    super.handleMessage(msg);
+            }
+        }
+
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/activities/preview/PreviewSong.java b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/preview/PreviewSong.java
new file mode 100755
index 0000000000..2c28e865ad
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/preview/PreviewSong.java
@@ -0,0 +1,33 @@
+/*
+* Copyright (C) 2015 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.dolzzo.twelve.ui.activities.preview;
+
+import android.net.Uri;
+
+/**
+ * PreviewSong
+ * <pre>
+ *     A POJO representation of a previewable external song
+ * </pre>
+ */
+/* package */ class PreviewSong {
+
+    public Uri URI = null;
+    public String TITLE = null;
+    public String ARTIST = null;
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/activities/preview/util/Logger.java b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/preview/util/Logger.java
new file mode 100755
index 0000000000..7db74d16ff
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/activities/preview/util/Logger.java
@@ -0,0 +1,71 @@
+/*
+ *  Copyright (c) 2015. The CyanogenMod Project
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.activities.preview.util;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+/**
+ * <pre>
+ *     Debug logging
+ * </pre>
+ */
+public class Logger {
+
+    private static final String TAG = "AudioPreview";
+
+    private static boolean isDebugging() {
+        return Log.isLoggable(TAG, Log.DEBUG);
+    }
+
+    /**
+     * Log a debug message
+     *
+     * @param tag {@link String}
+     * @param msg {@link String }
+     * @throws IllegalArgumentException {@link IllegalArgumentException}
+     */
+    public static void logd(String tag, String msg) throws IllegalArgumentException {
+        if (TextUtils.isEmpty(tag)) {
+            throw new IllegalArgumentException("'tag' cannot be empty!");
+        }
+        if (TextUtils.isEmpty(msg)) {
+            throw new IllegalArgumentException("'msg' cannot be empty!");
+        }
+        if (isDebugging()) {
+            Log.d(TAG, tag + " [ " + msg + " ]");
+        }
+    }
+
+    /**
+     * Log a debug message
+     *
+     * @param tag {@link String}
+     * @param msg {@link String }
+     * @throws IllegalArgumentException {@link IllegalArgumentException}
+     */
+    public static void loge(String tag, String msg) throws IllegalArgumentException {
+        if (TextUtils.isEmpty(tag)) {
+            throw new IllegalArgumentException("'tag' cannot be empty!");
+        }
+        if (TextUtils.isEmpty(msg)) {
+            throw new IllegalArgumentException("'msg' cannot be empty!");
+        }
+        Log.e(TAG, tag + " [ " + msg + " ]");
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/AlbumDetailFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/AlbumDetailFragment.java
new file mode 100755
index 0000000000..94726c6596
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/AlbumDetailFragment.java
@@ -0,0 +1,217 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments;
+
+import android.os.Bundle;
+import android.support.v4.app.LoaderManager;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.ListView;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.AlbumDetailSongAdapter;
+import com.dolzzo.twelve.adapters.DetailSongAdapter;
+import com.dolzzo.twelve.adapters.PagerAdapter;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.model.Album;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.utils.AlbumPopupMenuHelper;
+import com.dolzzo.twelve.utils.GenreFetcher;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.utils.SongPopupMenuHelper;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+
+import java.util.List;
+
+public class AlbumDetailFragment extends DetailFragment implements IChildFragment {
+    private static final int LOADER_ID = 1;
+
+    private ListView mSongs;
+    private DetailSongAdapter mSongAdapter;
+    private TextView mAlbumDuration;
+    private TextView mGenre;
+    private ImageView mAlbumArt;
+    private PopupMenuHelper mSongMenuHelper;
+    private long mAlbumId;
+    private String mArtistName;
+    private String mAlbumName;
+    private LoadingEmptyContainer mLoadingEmptyContainer;
+
+    @Override
+    protected int getLayoutToInflate() {
+        return R.layout.activity_album_detail;
+    }
+
+    @Override
+    protected String getTitle() {
+        return getArguments().getString(Config.ARTIST_NAME);
+    }
+
+    @Override
+    protected void onViewCreated() {
+        super.onViewCreated();
+
+        Bundle arguments = getArguments();
+        String artistName = arguments.getString(Config.ARTIST_NAME);
+
+        setupPopupMenuHelper();
+        setupHeader(artistName, arguments);
+        setupSongList();
+
+        LoaderManager lm = getLoaderManager();
+        lm.initLoader(LOADER_ID, arguments, mSongAdapter);
+    }
+
+    @Override // DetailFragment
+    protected PopupMenuHelper createActionMenuHelper() {
+        return new AlbumPopupMenuHelper(getActivity(), getChildFragmentManager()) {
+            public Album getAlbum(int position) {
+                return new Album(mAlbumId, mAlbumName, mArtistName, -1, null);
+            }
+        };
+    }
+
+    @Override // DetailFragment
+    protected int getShuffleTitleId() {
+        return R.string.menu_shuffle_album;
+    }
+
+    @Override // DetailFragment
+    protected void playShuffled() {
+        MusicUtils.playAlbum(getActivity(), mAlbumId, -1, true);
+    }
+
+    private void setupHeader(String artist, Bundle arguments) {
+        mAlbumId = arguments.getLong(Config.ID);
+        mArtistName = artist;
+        mAlbumName = arguments.getString(Config.NAME);
+        String year = arguments.getString(Config.ALBUM_YEAR);
+        int songCount = arguments.getInt(Config.SONG_COUNT);
+
+        mAlbumArt = (ImageView) mRootView.findViewById(R.id.album_art);
+        mAlbumArt.setContentDescription(mAlbumName);
+        ImageFetcher.getInstance(getActivity()).loadAlbumImage(artist, mAlbumName, mAlbumId, mAlbumArt);
+
+        TextView title = (TextView) mRootView.findViewById(R.id.title);
+        title.setText(mAlbumName);
+
+        setupCountAndYear(mRootView, year, songCount);
+
+        // will be updated once we have song data
+        mAlbumDuration = (TextView) mRootView.findViewById(R.id.duration);
+        mGenre = (TextView) mRootView.findViewById(R.id.genre);
+    }
+
+    private void setupCountAndYear(View root, String year, int songCount) {
+        TextView songCountAndYear = (TextView) root.findViewById(R.id.song_count_and_year);
+        if (songCount > 0) {
+            String countText = getResources().
+                    getQuantityString(R.plurals.Nsongs, songCount, songCount);
+            if (year == null) {
+                songCountAndYear.setText(countText);
+            } else {
+                songCountAndYear.setText(getString(R.string.combine_two_strings, countText, year));
+            }
+        } else if (year != null) {
+            songCountAndYear.setText(year);
+        }
+    }
+
+    private void setupPopupMenuHelper() {
+        mSongMenuHelper = new SongPopupMenuHelper(getActivity(), getChildFragmentManager()) {
+            @Override
+            public Song getSong(int position) {
+                return mSongAdapter.getItem(position);
+            }
+
+            @Override
+            protected long getSourceId() {
+                return mAlbumId;
+            }
+
+            @Override
+            protected Config.IdType getSourceType() {
+                return Config.IdType.Album;
+            }
+        };
+    }
+
+    private void setupSongList() {
+        mSongs = (ListView) mRootView.findViewById(R.id.songs);
+        mSongAdapter = new AlbumDetailSongAdapter(getActivity(), this) {
+            @Override
+            protected void onLoading() {
+                mLoadingEmptyContainer.showLoading();
+            }
+
+            @Override
+            protected void onNoResults() {
+                getContainingActivity().postRemoveFragment(AlbumDetailFragment.this);
+            }
+        };
+        mSongAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mSongMenuHelper.showPopupMenu(v, position);
+            }
+        });
+        mSongs.setAdapter(mSongAdapter);
+        mSongs.setOnItemClickListener(mSongAdapter);
+        mLoadingEmptyContainer =
+                (LoadingEmptyContainer) mRootView.findViewById(R.id.loading_empty_container);
+        mSongs.setEmptyView(mLoadingEmptyContainer);
+    }
+
+    /**
+     * called back by song loader
+     */
+    public void update(List<Song> songs) {
+        /** compute total run time for album */
+        int duration = 0;
+        for (Song s : songs) {
+            duration += s.mDuration;
+        }
+        mAlbumDuration.setText(MusicUtils.makeLongTimeString(getActivity(), duration));
+
+        /** use the first song on the album to get a genre */
+        if (!songs.isEmpty()) {
+            GenreFetcher.fetch(getActivity(), (int) songs.get(0).mSongId, mGenre);
+        }
+    }
+
+    @Override
+    public void restartLoader() {
+        getLoaderManager().restartLoader(LOADER_ID, getArguments(), mSongAdapter);
+        ImageFetcher.getInstance(getActivity()).loadAlbumImage(mArtistName, mAlbumName, mAlbumId,
+                mAlbumArt);
+    }
+
+    @Override
+    public void onMetaChanged() {
+        super.onMetaChanged();
+
+        mSongAdapter.setCurrentlyPlayingTrack(MusicUtils.getCurrentTrack());
+    }
+
+    @Override
+    public PagerAdapter.MusicFragments getMusicFragmentParent() {
+        return PagerAdapter.MusicFragments.ALBUM;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/AlbumFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/AlbumFragment.java
new file mode 100755
index 0000000000..b69be9dbcc
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/AlbumFragment.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments;
+
+import android.os.Bundle;
+import android.os.SystemClock;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.Loader;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AbsListView;
+import android.widget.AbsListView.OnScrollListener;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.GridView;
+
+import com.dolzzo.twelve.MusicStateListener;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.AlbumAdapter;
+import com.dolzzo.twelve.adapters.PagerAdapter;
+import com.dolzzo.twelve.loaders.AlbumLoader;
+import com.dolzzo.twelve.model.Album;
+import com.dolzzo.twelve.recycler.RecycleHolder;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.sectionadapter.SectionListContainer;
+import com.dolzzo.twelve.ui.activities.BaseActivity;
+import com.dolzzo.twelve.ui.fragments.phone.MusicBrowserFragment;
+import com.dolzzo.twelve.utils.AlbumPopupMenuHelper;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.NavUtils;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+
+/**
+ * This class is used to display all of the albums on a user's device.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class AlbumFragment extends MusicBrowserFragment implements
+        LoaderCallbacks<SectionListContainer<Album>>, OnScrollListener,
+        OnItemClickListener, MusicStateListener {
+
+    /**
+     * Grid view column count. ONE - list, TWO - normal grid, FOUR - landscape
+     */
+    private static final int TWO = 2, FOUR = 4;
+
+    /**
+     * Fragment UI
+     */
+    private ViewGroup mRootView;
+
+    /**
+     * The adapter for the grid
+     */
+    private AlbumAdapter mAdapter;
+
+    /**
+     * The grid view
+     */
+    private GridView mGridView;
+
+    /**
+     * Pop up menu helper
+     */
+    private PopupMenuHelper mPopupMenuHelper;
+
+    /**
+     * This holds the loading progress bar as well as the no results message
+     */
+    private LoadingEmptyContainer mLoadingEmptyContainer;
+
+    @Override
+    public int getLoaderId() {
+        return PagerAdapter.MusicFragments.ALBUM.ordinal();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        mPopupMenuHelper = new AlbumPopupMenuHelper(getActivity(), getFragmentManager()) {
+            public Album getAlbum(int position) {
+                return mAdapter.getItem(position);
+            }
+        };
+
+        int layout = R.layout.grid_items_normal;
+
+        mAdapter = new AlbumAdapter(getActivity(), layout);
+        mAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mPopupMenuHelper.showPopupMenu(v, position);
+            }
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+                             final Bundle savedInstanceState) {
+        mRootView = (ViewGroup) inflater.inflate(R.layout.grid_base, null);
+        initGridView();
+
+        // Register the music status listener
+        ((BaseActivity) getActivity()).setMusicStateListenerListener(this);
+
+        return mRootView;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        // Enable the options menu
+        setHasOptionsMenu(true);
+        // Start the loader
+        initLoader(null, this);
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+
+        ((BaseActivity) getActivity()).removeMusicStateListenerListener(this);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onPause() {
+        super.onPause();
+        mAdapter.flush();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onScrollStateChanged(final AbsListView view, final int scrollState) {
+        // Pause disk cache access to ensure smoother scrolling
+        if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_FLING) {
+            mAdapter.setPauseDiskCache(true);
+        } else {
+            mAdapter.setPauseDiskCache(false);
+            mAdapter.notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onItemClick(final AdapterView<?> parent, final View view, final int position,
+                            final long id) {
+        Album album = mAdapter.getItem(position);
+        NavUtils.openAlbumProfile(getActivity(), album.mAlbumName, album.mArtistName, album.mAlbumId);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Loader<SectionListContainer<Album>> onCreateLoader(final int id, final Bundle args) {
+        mLoadingEmptyContainer.showLoading();
+        // if we ever decide to add section headers for grid items, we can pass a compartor
+        // instead of null
+        return new SectionCreator<Album>(getActivity(), new AlbumLoader(getActivity()), null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoadFinished(final Loader<SectionListContainer<Album>> loader,
+                               final SectionListContainer<Album> data) {
+        if (data.mListResults.isEmpty()) {
+            mAdapter.unload();
+            mLoadingEmptyContainer.showNoResults();
+            return;
+        }
+
+        mAdapter.setData(data.mListResults);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoaderReset(final Loader<SectionListContainer<Album>> loader) {
+        // Clear the data in the adapter
+        mAdapter.unload();
+    }
+
+    /**
+     * Scrolls the list to the currently playing album when the user touches the
+     * header in the {@link TitlePageIndicator}.
+     */
+    public void scrollToCurrentAlbum() {
+        final int currentAlbumPosition = getItemPositionByAlbum();
+
+        if (currentAlbumPosition != 0) {
+            mGridView.setSelection(currentAlbumPosition);
+        }
+    }
+
+    /**
+     * @return The position of an item in the list or grid based on the id of
+     * the currently playing album.
+     */
+    private int getItemPositionByAlbum() {
+        final long albumId = MusicUtils.getCurrentAlbumId();
+        if (mAdapter == null) {
+            return 0;
+        }
+
+        int position = mAdapter.getItemPosition(albumId);
+
+        // if for some reason we don't find the item, just jump to the top
+        if (position < 0) {
+            return 0;
+        }
+
+        return position;
+    }
+
+    /**
+     * Restarts the loader.
+     */
+    public void refresh() {
+        // Wait a moment for the preference to change.
+        SystemClock.sleep(10);
+        restartLoader();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onScroll(final AbsListView view, final int firstVisibleItem,
+                         final int visibleItemCount, final int totalItemCount) {
+        // Nothing to do
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void restartLoader() {
+        // Update the list when the user deletes any items
+        restartLoader(null, this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onMetaChanged() {
+        // Nothing to do
+    }
+
+    @Override
+    public void onPlaylistChanged() {
+        // Nothing to do
+    }
+
+    /**
+     * Sets up various helpers for both the list and grid
+     *
+     * @param list The list or grid
+     */
+    private void initAbsListView(final AbsListView list) {
+        // Release any references to the recycled Views
+        list.setRecyclerListener(new RecycleHolder());
+        // Show the albums and songs from the selected artist
+        list.setOnItemClickListener(this);
+        // To help make scrolling smooth
+        list.setOnScrollListener(this);
+    }
+
+    /**
+     * Sets up the grid view
+     */
+    private void initGridView() {
+        int columns = ApolloUtils.isLandscape(getActivity()) ? FOUR : TWO;
+        mAdapter.setNumColumns(columns);
+        // Initialize the grid
+        mGridView = (GridView) mRootView.findViewById(R.id.grid_base);
+        // Set the data behind the grid
+        mGridView.setAdapter(mAdapter);
+        // Set up the helpers
+        initAbsListView(mGridView);
+        mGridView.setNumColumns(columns);
+
+        // Show progress bar
+        mLoadingEmptyContainer = (LoadingEmptyContainer) mRootView.findViewById(R.id.loading_empty_container);
+        mGridView.setEmptyView(mLoadingEmptyContainer);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/ArtistDetailFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/ArtistDetailFragment.java
new file mode 100755
index 0000000000..5d67defa00
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/ArtistDetailFragment.java
@@ -0,0 +1,259 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments;
+
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.LoaderManager;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewTreeObserver;
+import android.widget.ImageView;
+import android.widget.ListView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.ArtistDetailAlbumAdapter;
+import com.dolzzo.twelve.adapters.ArtistDetailSongAdapter;
+import com.dolzzo.twelve.adapters.PagerAdapter;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.model.Album;
+import com.dolzzo.twelve.model.Artist;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.utils.AlbumPopupMenuHelper;
+import com.dolzzo.twelve.utils.ArtistPopupMenuHelper;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.utils.SongPopupMenuHelper;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+
+import java.util.TreeSet;
+
+public class ArtistDetailFragment extends FadingBarFragment implements IChildFragment {
+    private final int ALBUM_LOADER_ID = 0;
+    private final int SONG_LOADER_ID = 1;
+
+    private long mArtistId;
+    private String mArtistName;
+
+    private ImageView mHero;
+    private View mHeader;
+
+    private ListView mSongs;
+    private ArtistDetailSongAdapter mSongAdapter;
+
+    private RecyclerView mAlbums;
+    private ArtistDetailAlbumAdapter mAlbumAdapter;
+
+    private PopupMenuHelper mSongPopupMenuHelper;
+    private PopupMenuHelper mAlbumPopupMenuHelper;
+
+    private LoadingEmptyContainer mLoadingEmptyContainer;
+
+    @Override
+    protected int getLayoutToInflate() {
+        return R.layout.activity_artist_detail;
+    }
+
+    @Override
+    protected String getTitle() {
+        return getArguments().getString(Config.ARTIST_NAME);
+    }
+
+    protected long getArtistId() {
+        return getArguments().getLong(Config.ID);
+    }
+
+    @Override
+    protected void onViewCreated() {
+        super.onViewCreated();
+
+        getContainingActivity().setFragmentPadding(true);
+
+        Bundle arguments = getArguments();
+        mArtistName = arguments.getString(Config.ARTIST_NAME);
+        mArtistId = arguments.getLong(Config.ID);
+
+        setupPopupMenuHelpers();
+        setupSongList();
+        setupAlbumList();
+        setupHero(mArtistName);
+
+        LoaderManager lm = getLoaderManager();
+        lm.initLoader(ALBUM_LOADER_ID, arguments, mAlbumAdapter);
+        lm.initLoader(SONG_LOADER_ID, arguments, mSongAdapter);
+    }
+
+    @Override // DetailFragment
+    protected PopupMenuHelper createActionMenuHelper() {
+        return new ArtistPopupMenuHelper(getActivity(), getChildFragmentManager()) {
+            public Artist getArtist(int position) {
+                return new Artist(mArtistId, mArtistName, 0, 0);
+            }
+        };
+    }
+
+    @Override // DetailFragment
+    protected int getShuffleTitleId() {
+        return R.string.menu_shuffle_artist;
+    }
+
+    @Override // DetailFragment
+    protected void playShuffled() {
+        MusicUtils.playArtist(getActivity(), mArtistId, -1, true);
+    }
+
+    private void setupHero(String artistName) {
+        mHero = (ImageView) mHeader.findViewById(R.id.hero);
+        mHero.setContentDescription(artistName);
+        // initiate loading the artist image
+        // since the artist image needs to be scaled to the image view bounds, we need to wait till the first layout
+        // traversal to be able to get the image view dimensions in the helper method that scales the image
+        mHero.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+                    mHero.getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                } else {
+                    mHero.getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                }
+                ImageFetcher.getInstance(getActivity()).loadArtistImage(mArtistName, mHero, true);
+            }
+        });
+    }
+
+    private void setupAlbumList() {
+        mAlbums = (RecyclerView) mHeader.findViewById(R.id.albums);
+        mAlbums.setHasFixedSize(true);
+        mAlbums.setLayoutManager(new LinearLayoutManager(getActivity(), LinearLayoutManager.HORIZONTAL, false));
+        mAlbumAdapter = new ArtistDetailAlbumAdapter(getActivity());
+        mAlbumAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mAlbumPopupMenuHelper.showPopupMenu(v, position);
+            }
+        });
+        mAlbums.setAdapter(mAlbumAdapter);
+    }
+
+    private void setupSongList() {
+        mSongs = (ListView) mRootView.findViewById(R.id.songs);
+        mHeader = LayoutInflater.from(getActivity()).
+                inflate(R.layout.artist_detail_header, mSongs, false);
+        mSongs.addHeaderView(mHeader);
+        mSongs.setOnScrollListener(this);
+        mSongAdapter = new ArtistDetailSongAdapter(getActivity()) {
+            @Override
+            protected void onLoading() {
+                mLoadingEmptyContainer.showLoading();
+            }
+
+            @Override
+            protected void onNoResults() {
+                // no results - because the user deleted the last item - pop our fragment
+                // from the stack
+                getContainingActivity().postRemoveFragment(ArtistDetailFragment.this);
+            }
+        };
+        mSongAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mSongPopupMenuHelper.showPopupMenu(v, position);
+            }
+        });
+        mSongs.setAdapter(mSongAdapter);
+        mSongs.setOnItemClickListener(mSongAdapter);
+        mLoadingEmptyContainer =
+                (LoadingEmptyContainer) mRootView.findViewById(R.id.loading_empty_container);
+        mSongs.setEmptyView(mLoadingEmptyContainer);
+    }
+
+    private void setupPopupMenuHelpers() {
+        mSongPopupMenuHelper = new SongPopupMenuHelper(getActivity(), getChildFragmentManager()) {
+            @Override
+            public Song getSong(int position) {
+                return mSongAdapter.getItem(position);
+            }
+
+            @Override
+            protected long getSourceId() {
+                return getArtistId();
+            }
+
+            @Override
+            protected Config.IdType getSourceType() {
+                return Config.IdType.Artist;
+            }
+
+            @Override
+            protected void updateMenuIds(PopupMenuType type, TreeSet<Integer> set) {
+                super.updateMenuIds(type, set);
+
+                // since we are already on the artist page, this item doesn't make sense
+                set.remove(FragmentMenuItems.MORE_BY_ARTIST);
+            }
+        };
+
+        mAlbumPopupMenuHelper = new AlbumPopupMenuHelper(getActivity(), getChildFragmentManager()) {
+            @Override
+            public Album getAlbum(int position) {
+                return mAlbumAdapter.getItem(position);
+            }
+
+            @Override
+            protected void updateMenuIds(PopupMenuType type, TreeSet<Integer> set) {
+                super.updateMenuIds(type, set);
+
+                // since we are already on the artist page, this item doesn't make sense
+                set.remove(FragmentMenuItems.MORE_BY_ARTIST);
+            }
+        };
+    }
+
+    // TODO: change this class to use the same header strategy as PlaylistDetail
+    protected int getHeaderHeight() {
+        return mHero.getHeight();
+    }
+
+    protected void setHeaderPosition(float y) {
+    }
+
+    @Override
+    public void restartLoader() {
+        Bundle arguments = getArguments();
+        LoaderManager lm = getLoaderManager();
+        lm.restartLoader(ALBUM_LOADER_ID, arguments, mAlbumAdapter);
+        lm.restartLoader(SONG_LOADER_ID, arguments, mSongAdapter);
+
+        ImageFetcher.getInstance(getActivity()).loadArtistImage(mArtistName, mHero, true);
+    }
+
+    @Override
+    public void onMetaChanged() {
+        super.onMetaChanged();
+
+        mSongAdapter.setCurrentlyPlayingTrack(MusicUtils.getCurrentTrack());
+    }
+
+    @Override
+    public PagerAdapter.MusicFragments getMusicFragmentParent() {
+        return PagerAdapter.MusicFragments.ARTIST;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/ArtistFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/ArtistFragment.java
new file mode 100755
index 0000000000..c8f5dce2cd
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/ArtistFragment.java
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.os.SystemClock;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.Loader;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AbsListView;
+import android.widget.AbsListView.OnScrollListener;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ListView;
+
+import com.dolzzo.twelve.MusicStateListener;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.ArtistAdapter;
+import com.dolzzo.twelve.adapters.PagerAdapter;
+import com.dolzzo.twelve.loaders.ArtistLoader;
+import com.dolzzo.twelve.model.Artist;
+import com.dolzzo.twelve.recycler.RecycleHolder;
+import com.dolzzo.twelve.sectionadapter.SectionAdapter;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.sectionadapter.SectionListContainer;
+import com.dolzzo.twelve.ui.activities.BaseActivity;
+import com.dolzzo.twelve.ui.fragments.phone.MusicBrowserFragment;
+import com.dolzzo.twelve.utils.ArtistPopupMenuHelper;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.NavUtils;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.utils.SectionCreatorUtils;
+import com.dolzzo.twelve.utils.SectionCreatorUtils.IItemCompare;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+
+/**
+ * This class is used to display all of the artists on a user's device.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class ArtistFragment extends MusicBrowserFragment implements
+        LoaderCallbacks<SectionListContainer<Artist>>,
+        OnScrollListener, OnItemClickListener, MusicStateListener {
+
+    /**
+     * Fragment UI
+     */
+    private ViewGroup mRootView;
+
+    /**
+     * The adapter for the grid
+     */
+    private SectionAdapter<Artist, ArtistAdapter> mAdapter;
+
+    /**
+     * The list view
+     */
+    private ListView mListView;
+
+    /**
+     * Pop up menu helper
+     */
+    private PopupMenuHelper mPopupMenuHelper;
+
+    /**
+     * Loading container and no results container
+     */
+    private LoadingEmptyContainer mLoadingEmptyContainer;
+
+    /**
+     * Empty constructor as per the {@link Fragment} documentation
+     */
+    public ArtistFragment() {
+    }
+
+    @Override
+    public int getLoaderId() {
+        return PagerAdapter.MusicFragments.ARTIST.ordinal();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        mPopupMenuHelper = new ArtistPopupMenuHelper(getActivity(), getFragmentManager()) {
+            @Override
+            public Artist getArtist(int position) {
+                return mAdapter.getTItem(position);
+            }
+        };
+
+        // Create the adapter
+        final int layout = R.layout.list_item_normal;
+        ArtistAdapter adapter = new ArtistAdapter(getActivity(), layout);
+        mAdapter = new SectionAdapter<Artist, ArtistAdapter>(getActivity(), adapter);
+        mAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mPopupMenuHelper.showPopupMenu(v, position);
+            }
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+                             final Bundle savedInstanceState) {
+        // The View for the fragment's UI
+        mRootView = (ViewGroup) inflater.inflate(R.layout.list_base, null);
+        initListView();
+
+        // Register the music status listener
+        ((BaseActivity) getActivity()).setMusicStateListenerListener(this);
+
+        return mRootView;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+
+        ((BaseActivity) getActivity()).removeMusicStateListenerListener(this);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        // Enable the options menu
+        setHasOptionsMenu(true);
+        // Start the loader
+        initLoader(null, this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onPause() {
+        super.onPause();
+        mAdapter.flush();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onScrollStateChanged(final AbsListView view, final int scrollState) {
+        // Pause disk cache access to ensure smoother scrolling
+        if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_FLING) {
+            mAdapter.getUnderlyingAdapter().setPauseDiskCache(true);
+        } else {
+            mAdapter.getUnderlyingAdapter().setPauseDiskCache(false);
+            mAdapter.notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onItemClick(final AdapterView<?> parent, final View view, final int position,
+                            final long id) {
+        Artist artist = mAdapter.getTItem(position);
+        NavUtils.openArtistProfile(getActivity(), artist.mArtistName);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Loader<SectionListContainer<Artist>> onCreateLoader(final int id, final Bundle args) {
+        mLoadingEmptyContainer.showLoading();
+        final Context context = getActivity();
+        IItemCompare<Artist> comparator = SectionCreatorUtils.createArtistComparison(context);
+        return new SectionCreator<Artist>(getActivity(), new ArtistLoader(context), comparator);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoadFinished(final Loader<SectionListContainer<Artist>> loader,
+                               final SectionListContainer<Artist> data) {
+        if (data.mListResults.isEmpty()) {
+            mAdapter.unload();
+            mLoadingEmptyContainer.showNoResults();
+            return;
+        }
+
+        mAdapter.setData(data);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoaderReset(final Loader<SectionListContainer<Artist>> loader) {
+        // Clear the data in the adapter
+        mAdapter.unload();
+    }
+
+    /**
+     * Scrolls the list to the currently playing artist when the user touches
+     * the header in the {@link TitlePageIndicator}.
+     */
+    public void scrollToCurrentArtist() {
+        final int currentArtistPosition = getItemPositionByArtist();
+
+        if (currentArtistPosition != 0) {
+            mListView.setSelection(currentArtistPosition);
+        }
+    }
+
+    /**
+     * @return The position of an item in the list or grid based on the name of
+     * the currently playing artist.
+     */
+    private int getItemPositionByArtist() {
+        final long artistId = MusicUtils.getCurrentArtistId();
+        if (mAdapter == null) {
+            return 0;
+        }
+
+        int position = mAdapter.getItemPosition(artistId);
+
+        // if for some reason we don't find the item, just jump to the top
+        if (position < 0) {
+            return 0;
+        }
+
+        return position;
+    }
+
+    /**
+     * Restarts the loader.
+     */
+    public void refresh() {
+        // Wait a moment for the preference to change.
+        SystemClock.sleep(10);
+        restartLoader();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onScroll(final AbsListView view, final int firstVisibleItem,
+                         final int visibleItemCount, final int totalItemCount) {
+        // Nothing to do
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void restartLoader() {
+        // Update the list when the user deletes any items
+        restartLoader(null, this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onMetaChanged() {
+        // Nothing to do
+    }
+
+    @Override
+    public void onPlaylistChanged() {
+        // Nothing to do
+    }
+
+    /**
+     * Sets up various helpers for both the list and grid
+     *
+     * @param list The list or grid
+     */
+    private void initAbsListView(final AbsListView list) {
+        // Release any references to the recycled Views
+        list.setRecyclerListener(new RecycleHolder());
+        // Show the albums and songs from the selected artist
+        list.setOnItemClickListener(this);
+        // To help make scrolling smooth
+        list.setOnScrollListener(this);
+    }
+
+    /**
+     * Sets up the list view
+     */
+    private void initListView() {
+        // Initialize the grid
+        mListView = (ListView) mRootView.findViewById(R.id.list_base);
+        // Set the data behind the list
+        mListView.setAdapter(mAdapter);
+        // set the loading and empty view container
+        mLoadingEmptyContainer = (LoadingEmptyContainer) mRootView.findViewById(R.id.loading_empty_container);
+        mListView.setEmptyView(mLoadingEmptyContainer);
+        // Set up the helpers
+        initAbsListView(mListView);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/AudioPlayerFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/AudioPlayerFragment.java
new file mode 100755
index 0000000000..0bbb227a58
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/AudioPlayerFragment.java
@@ -0,0 +1,834 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments;
+
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.graphics.Outline;
+import android.media.AudioManager;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.PowerManager;
+import android.support.v4.app.Fragment;
+import android.support.v4.view.ViewPager;
+import android.text.Html;
+import android.text.Spanned;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.ContextMenu;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewOutlineProvider;
+import android.widget.ImageView;
+import android.widget.PopupMenu;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.AlbumArtPagerAdapter;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.loaders.NowPlayingCursor;
+import com.dolzzo.twelve.loaders.QueueLoader;
+import com.dolzzo.twelve.menu.CreateNewPlaylist;
+import com.dolzzo.twelve.menu.DeleteDialog;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.ui.activities.HomeActivity;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.NavUtils;
+import com.dolzzo.twelve.utils.PreferenceUtils;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+import com.dolzzo.twelve.widgets.NoResultsContainer;
+import com.dolzzo.twelve.widgets.PlayPauseProgressButton;
+import com.dolzzo.twelve.widgets.RepeatButton;
+import com.dolzzo.twelve.widgets.RepeatingImageButton;
+import com.dolzzo.twelve.widgets.ShuffleButton;
+import com.dolzzo.twelve.widgets.VisualizerView;
+
+import java.lang.ref.WeakReference;
+
+import static com.dolzzo.twelve.utils.MusicUtils.mService;
+
+public class AudioPlayerFragment extends Fragment implements ServiceConnection {
+    private static final String TAG = AudioPlayerFragment.class.getSimpleName();
+
+    /**
+     * Used to keep context menu items from bleeding into other fragments
+     */
+    private static final int GROUP_ID = 15;
+    // Message to refresh the time
+    private static final int REFRESH_TIME = 1;
+    // Message to refresh the total time
+    private static final int REFRESH_TOTAL_TIME = 2;
+    // fragment view
+    private ViewGroup mRootView;
+    // Header views
+    private TextView mSongTitle;
+    private TextView mArtistName;
+    // Playlist Button
+    private ImageView mAddToPlaylistButton;
+    // Menu Button
+    private ImageView mMenuButton;
+    // The service token
+    private MusicUtils.ServiceToken mToken;
+
+    // Play pause and progress button
+    private PlayPauseProgressButton mPlayPauseProgressButton;
+
+    // Repeat button
+    private RepeatButton mRepeatButton;
+
+    // Shuffle button
+    private ShuffleButton mShuffleButton;
+
+    // Previous button
+    private RepeatingImageButton mPreviousButton;
+
+    // Next button
+    private RepeatingImageButton mNextButton;
+
+    // Album art ListView
+    private ViewPager mAlbumArtViewPager;
+    private LoadingEmptyContainer mQueueEmpty;
+
+    private AlbumArtPagerAdapter mAlbumArtPagerAdapter;
+
+    // Current time
+    private TextView mCurrentTime;
+    /**
+     * Used to scan backwards through the track
+     */
+    private final RepeatingImageButton.RepeatListener mRewindListener = new RepeatingImageButton.RepeatListener() {
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onRepeat(final View v, final long howlong, final int repcnt) {
+            seekRelative(repcnt, howlong, false);
+        }
+    };
+    /**
+     * Used to scan ahead through the track
+     */
+    private final RepeatingImageButton.RepeatListener mFastForwardListener = new RepeatingImageButton.RepeatListener() {
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onRepeat(final View v, final long howlong, final int repcnt) {
+            seekRelative(repcnt, howlong, true);
+        }
+    };
+    // Total time
+    private TextView mTotalTime;
+    // Visualizer View
+    private VisualizerView mVisualizerView;
+    // Broadcast receiver
+    private PlaybackStatus mPlaybackStatus;
+    // Handler used to update the current time
+    private TimeHandler mTimeHandler;
+    // Image cache
+    private ImageFetcher mImageFetcher;
+    // popup menu for pressing the menu icon
+    private PopupMenu mPopupMenu;
+    // Lyrics text view
+    private TextView mLyricsText;
+    private long mSelectedId = -1;
+    private boolean mIsPaused = false;
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        // Control the media volume
+        getActivity().setVolumeControlStream(AudioManager.STREAM_MUSIC);
+
+        // Bind Apollo's service
+        mToken = MusicUtils.bindToService(getActivity(), this);
+
+        // Initialize the image fetcher/cache
+        mImageFetcher = ApolloUtils.getImageFetcher(getActivity());
+
+        // Initialize the handler used to update the current time
+        mTimeHandler = new TimeHandler(this);
+
+        // Initialize the broadcast receiver
+        mPlaybackStatus = new PlaybackStatus(this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+                             final Bundle savedInstanceState) {
+        // The View for the fragment's UI
+        mRootView = (ViewGroup) inflater.inflate(R.layout.activity_player_fragment, null);
+
+        // Header title values
+        initHeaderBar();
+
+        initPlaybackControls();
+
+        mVisualizerView = (VisualizerView) mRootView.findViewById(R.id.visualizerView);
+        mVisualizerView.initialize(getActivity());
+        updateVisualizerPowerSaveMode();
+
+        mLyricsText = (TextView) mRootView.findViewById(R.id.audio_player_lyrics);
+
+        return mRootView;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onServiceConnected(final ComponentName name, final IBinder service) {
+        // Set the playback drawables
+        updatePlaybackControls();
+        // Setup the adapter
+        createAndSetAdapter();
+        // Current info
+        updateNowPlayingInfo();
+    }
+
+    @Override
+    public void onServiceDisconnected(ComponentName name) {
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        final IntentFilter filter = new IntentFilter();
+        // Play and pause changes
+        filter.addAction(MusicPlaybackService.PLAYSTATE_CHANGED);
+        // Shuffle and repeat changes
+        filter.addAction(MusicPlaybackService.SHUFFLEMODE_CHANGED);
+        filter.addAction(MusicPlaybackService.REPEATMODE_CHANGED);
+        // Track changes
+        filter.addAction(MusicPlaybackService.META_CHANGED);
+        // Update a list, probably the playlist fragment's
+        filter.addAction(MusicPlaybackService.REFRESH);
+        // Listen to changes to the entire queue
+        filter.addAction(MusicPlaybackService.QUEUE_CHANGED);
+        // Listen for lyrics text for the audio track
+        filter.addAction(MusicPlaybackService.NEW_LYRICS);
+        // Listen for power save mode changed
+        filter.addAction(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED);
+        // Register the intent filters
+        getActivity().registerReceiver(mPlaybackStatus, filter);
+        // Refresh the current time
+        final long next = refreshCurrentTime();
+        queueNextRefresh(next);
+
+        // resumes the update callback for the play pause progress button
+        mPlayPauseProgressButton.resume();
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+
+        // pause the update callback for the play pause progress button
+        mPlayPauseProgressButton.pause();
+
+        mImageFetcher.flush();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        mIsPaused = false;
+        mTimeHandler.removeMessages(REFRESH_TIME);
+        // Unbind from the service
+        if (mService != null) {
+            MusicUtils.unbindFromService(mToken);
+            mToken = null;
+        }
+
+        // Unregister the receiver
+        try {
+            getActivity().unregisterReceiver(mPlaybackStatus);
+        } catch (final Throwable e) {
+            //$FALL-THROUGH$
+        }
+    }
+
+    /**
+     * Initializes the header bar
+     */
+    private void initHeaderBar() {
+        View headerBar = mRootView.findViewById(R.id.audio_player_header);
+        final int bottomActionBarHeight =
+                getResources().getDimensionPixelSize(R.dimen.bottom_action_bar_height);
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            headerBar.setOutlineProvider(new ViewOutlineProvider() {
+                @Override
+                public void getOutline(View view, Outline outline) {
+                    // since we only want the top and bottom shadows, pad the horizontal width
+                    // to hide the shadows. Can't seem to find a better way to do this
+                    int padWidth = (int) (0.2f * view.getWidth());
+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                        outline.setRect(-padWidth, -bottomActionBarHeight, view.getWidth() + padWidth,
+                                view.getHeight());
+                    }
+                }
+            });
+        }
+
+        // Title text
+        mSongTitle = (TextView) mRootView.findViewById(R.id.header_bar_song_title);
+        mArtistName = (TextView) mRootView.findViewById(R.id.header_bar_artist_title);
+
+        // Buttons
+        // Search Button
+        View v = mRootView.findViewById(R.id.header_bar_search_button);
+        v.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                NavUtils.openSearch(getActivity(), "");
+            }
+        });
+
+        // Add to Playlist Button
+        // Setup the playlist button - add a click listener to show the context
+        mAddToPlaylistButton = (ImageView) mRootView.findViewById(R.id.header_bar_add_button);
+
+        // Create the context menu when requested
+        mAddToPlaylistButton.setOnCreateContextMenuListener(new View.OnCreateContextMenuListener() {
+            @Override
+            public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
+                MusicUtils.makePlaylistMenu(getActivity(), GROUP_ID, menu);
+                menu.setHeaderTitle(R.string.add_to_playlist);
+            }
+        });
+
+        // add a click listener to show the context
+        mAddToPlaylistButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                // save the current track id
+                mSelectedId = MusicUtils.getCurrentAudioId();
+                mAddToPlaylistButton.showContextMenu();
+            }
+        });
+
+        // Add the menu button
+        // menu button
+        mMenuButton = (ImageView) mRootView.findViewById(R.id.header_bar_menu_button);
+        mMenuButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                showPopupMenu();
+            }
+        });
+    }
+
+    /**
+     * Initializes the items in the now playing screen
+     */
+    private void initPlaybackControls() {
+        mPlayPauseProgressButton = (PlayPauseProgressButton) mRootView.findViewById(R.id.playPauseProgressButton);
+        mPlayPauseProgressButton.setDragEnabled(true);
+        mShuffleButton = (ShuffleButton) mRootView.findViewById(R.id.action_button_shuffle);
+        mRepeatButton = (RepeatButton) mRootView.findViewById(R.id.action_button_repeat);
+        mPreviousButton = (RepeatingImageButton) mRootView.findViewById(R.id.action_button_previous);
+        mNextButton = (RepeatingImageButton) mRootView.findViewById(R.id.action_button_next);
+
+        // Album art view pager
+        mAlbumArtViewPager = (ViewPager) mRootView.findViewById(R.id.audio_player_album_art_viewpager);
+        mAlbumArtViewPager.setOnPageChangeListener(new ViewPager.SimpleOnPageChangeListener() {
+            @Override
+            public void onPageSelected(int position) {
+                super.onPageSelected(position);
+
+                int currentPosition = 0;
+                if (MusicUtils.getShuffleMode() == MusicPlaybackService.SHUFFLE_NONE) {
+                    // if we aren't shuffling, base the position on the queue position
+                    currentPosition = MusicUtils.getQueuePosition();
+                } else {
+                    // if we are shuffling, use the history size as the position
+                    currentPosition = MusicUtils.getQueueHistorySize();
+                }
+
+                // check if we are going to next or previous track
+                if (position - currentPosition == 1) {
+                    MusicUtils.asyncNext(getActivity());
+                } else if (position - currentPosition == -1) {
+                    MusicUtils.previous(getActivity(), true);
+                } else if (currentPosition != position) {
+                    Log.w(TAG, "Unexpected page position of " + position
+                            + " when current is: " + currentPosition);
+                }
+            }
+        });
+        // view to show in place of album art if queue is empty
+        mQueueEmpty = (LoadingEmptyContainer) mRootView.findViewById(R.id.loading_empty_container);
+        setupNoResultsContainer(mQueueEmpty.getNoResultsContainer());
+
+        // Current time
+        mCurrentTime = (TextView) mRootView.findViewById(R.id.audio_player_current_time);
+        // Total time
+        mTotalTime = (TextView) mRootView.findViewById(R.id.audio_player_total_time);
+
+        // Set the repeat listener for the previous button
+        mPreviousButton.setRepeatListener(mRewindListener);
+        // Set the repeat listener for the next button
+        mNextButton.setRepeatListener(mFastForwardListener);
+
+        mPlayPauseProgressButton.enableAndShow();
+    }
+
+    private void setupNoResultsContainer(NoResultsContainer empty) {
+        int color = getResources().getColor(R.color.no_results_light);
+        empty.setTextColor(color);
+        empty.setMainText(R.string.empty_queue_main);
+        empty.setSecondaryText(R.string.empty_queue_secondary);
+    }
+
+    /**
+     * Sets the track name, album name, and album art.
+     */
+    private void updateNowPlayingInfo() {
+        // Set the track name
+        mSongTitle.setText(MusicUtils.getTrackName());
+        mArtistName.setText(MusicUtils.getArtistName());
+
+        // Set the total time
+        long duration = MusicUtils.duration();
+
+        if (duration > 0) {
+            String totalTime = MusicUtils.makeShortTimeString(getActivity(), duration / 1000);
+            if (!mTotalTime.getText().equals(totalTime)) {
+                mTotalTime.setText(totalTime);
+            }
+        } else {
+            mCurrentTime.setText("--:--");
+            final Message message = mTimeHandler.obtainMessage(REFRESH_TOTAL_TIME);
+            mTimeHandler.removeMessages(REFRESH_TOTAL_TIME);
+            mTimeHandler.sendMessageDelayed(message, 500);
+        }
+
+        if (MusicUtils.getRepeatMode() == MusicPlaybackService.REPEAT_CURRENT) {
+            // we are repeating 1 so just jump to the 1st and only item
+            mAlbumArtViewPager.setCurrentItem(0, false);
+        } else if (MusicUtils.getShuffleMode() == MusicPlaybackService.SHUFFLE_NONE) {
+            // we are playing in-order, base the position on the queue position
+            mAlbumArtViewPager.setCurrentItem(MusicUtils.getQueuePosition(), true);
+        } else {
+            // if we are shuffling, just based our index based on the history
+            mAlbumArtViewPager.setCurrentItem(MusicUtils.getQueueHistorySize(), true);
+        }
+
+        // Update the current time
+        queueNextRefresh(1);
+    }
+
+    /**
+     * This creates the adapter based on the repeat and shuffle configuration and sets it into the
+     * page adapter
+     */
+    private void createAndSetAdapter() {
+        mAlbumArtPagerAdapter = new AlbumArtPagerAdapter(getChildFragmentManager());
+
+        int repeatMode = MusicUtils.getRepeatMode();
+        int targetSize = 0;
+        int targetIndex = 0;
+        int queueSize = MusicUtils.getQueueSize();
+
+        if (repeatMode == MusicPlaybackService.REPEAT_CURRENT) {
+            targetSize = 1;
+            targetIndex = 0;
+        } else if (MusicUtils.getShuffleMode() == MusicPlaybackService.SHUFFLE_NONE) {
+            // if we aren't shuffling, use the queue to determine where we are
+            targetSize = queueSize;
+            targetIndex = MusicUtils.getQueuePosition();
+        } else {
+            // otherwise, set it to the max history size
+            targetSize = MusicPlaybackService.MAX_HISTORY_SIZE;
+            targetIndex = MusicUtils.getQueueHistorySize();
+        }
+
+        mAlbumArtPagerAdapter.setPlaylistLength(targetSize);
+        mAlbumArtViewPager.setAdapter(mAlbumArtPagerAdapter);
+        mAlbumArtViewPager.setCurrentItem(targetIndex);
+
+        if (queueSize == 0) {
+            mAlbumArtViewPager.setVisibility(View.GONE);
+            mQueueEmpty.showNoResults();
+            mAddToPlaylistButton.setVisibility(View.GONE);
+        } else {
+            mAlbumArtViewPager.setVisibility(View.VISIBLE);
+            mQueueEmpty.hideAll();
+            mAddToPlaylistButton.setVisibility(View.VISIBLE);
+        }
+    }
+
+    /**
+     * Sets the correct drawable states for the playback controls.
+     */
+    private void updatePlaybackControls() {
+        // Set the play and pause image
+        mPlayPauseProgressButton.getPlayPauseButton().updateState();
+        // Set the shuffle image
+        mShuffleButton.updateShuffleState();
+        // Set the repeat image
+        mRepeatButton.updateRepeatState();
+    }
+
+    /**
+     * @param delay When to update
+     */
+    private void queueNextRefresh(final long delay) {
+        if (!mIsPaused) {
+            final Message message = mTimeHandler.obtainMessage(REFRESH_TIME);
+            mTimeHandler.removeMessages(REFRESH_TIME);
+            mTimeHandler.sendMessageDelayed(message, delay);
+        }
+    }
+
+    /**
+     * Used to seek forwards or backwards in time through the current track
+     *
+     * @param repcnt   The repeat count
+     * @param delta    The long press duration
+     * @param forwards Whether it was seeking forwards or backwards
+     */
+    private void seekRelative(final int repcnt, long delta, boolean forwards) {
+        if (mService == null) {
+            return;
+        }
+        if (repcnt > 0) {
+            final long EXTRA_FAST_CUTOFF = 10000;
+            if (delta < EXTRA_FAST_CUTOFF) {
+                // seek at 10x speed for the first 5 seconds
+                delta = delta * 10;
+            } else {
+                // seek at 40x after that
+                delta = EXTRA_FAST_CUTOFF * 10 + (delta - EXTRA_FAST_CUTOFF) * 40;
+            }
+
+            MusicUtils.seekRelative(forwards ? delta : -delta);
+
+            refreshCurrentTime();
+        }
+    }
+
+    private void refreshCurrentTimeText(final long pos) {
+        if (mPlayPauseProgressButton.isDragging()) {
+            mCurrentTime.setText(MusicUtils.makeShortTimeString(getActivity(),
+                    mPlayPauseProgressButton.getDragProgressInMs() / 1000));
+        } else {
+            mCurrentTime.setText(MusicUtils.makeShortTimeString(getActivity(), pos / 1000));
+        }
+    }
+
+    /* Used to update the current time string */
+    private long refreshCurrentTime() {
+        if (mService == null) {
+            return MusicUtils.UPDATE_FREQUENCY_MS;
+        }
+        try {
+            final long pos = MusicUtils.position();
+            if (pos >= 0 && MusicUtils.duration() > 0) {
+                refreshCurrentTimeText(pos);
+
+                if (mPlayPauseProgressButton.isDragging()) {
+                    mCurrentTime.setVisibility(View.VISIBLE);
+                    return MusicUtils.UPDATE_FREQUENCY_FAST_MS;
+                } else if (MusicUtils.isPlaying()) {
+                    mCurrentTime.setVisibility(View.VISIBLE);
+
+                    // calculate the number of milliseconds until the next full second,
+                    // so the counter can be updated at just the right time
+                    return Math.max(20, 1000 - pos % 1000);
+                } else {
+                    // blink the counter
+                    final int vis = mCurrentTime.getVisibility();
+                    mCurrentTime.setVisibility(vis == View.INVISIBLE ? View.VISIBLE
+                            : View.INVISIBLE);
+                }
+            } else {
+                mCurrentTime.setText("--:--");
+            }
+        } catch (final Exception ignored) {
+            if (ignored.getMessage() != null) {
+                Log.e(TAG, ignored.getMessage());
+            }
+        }
+        return MusicUtils.UPDATE_FREQUENCY_MS;
+    }
+
+    private void refreshTotalTime() {
+        long duration = MusicUtils.duration();
+
+        if (duration > 0) {
+            String totalTime = MusicUtils.makeShortTimeString(getActivity(), duration / 1000);
+            if (!mTotalTime.getText().equals(totalTime)) {
+                mTotalTime.setText(totalTime);
+            }
+        } else {
+            mCurrentTime.setText("--:--");
+            final Message message = mTimeHandler.obtainMessage(REFRESH_TOTAL_TIME);
+            mTimeHandler.removeMessages(REFRESH_TOTAL_TIME);
+            mTimeHandler.sendMessageDelayed(message, 500);
+        }
+    }
+
+    public void showPopupMenu() {
+        // create the popup menu
+        if (mPopupMenu == null) {
+            mPopupMenu = new PopupMenu(getActivity(), mMenuButton);
+            mPopupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
+                @Override
+                public boolean onMenuItemClick(MenuItem item) {
+                    return onPopupMenuItemClick(item);
+                }
+            });
+        }
+
+        final Menu menu = mPopupMenu.getMenu();
+        final MenuInflater inflater = mPopupMenu.getMenuInflater();
+        menu.clear();
+
+        // Shuffle all
+        inflater.inflate(R.menu.shuffle_all, menu);
+        if (MusicUtils.getQueueSize() > 0) {
+            // ringtone, and equalizer
+            inflater.inflate(R.menu.audio_player, menu);
+
+            if (!NavUtils.hasEffectsPanel(getActivity())) {
+                menu.removeItem(R.id.menu_audio_player_equalizer);
+            }
+
+            // save queue/clear queue
+            inflater.inflate(R.menu.queue, menu);
+        }
+        // Settings
+        inflater.inflate(R.menu.activity_base, menu);
+
+        // show the popup
+        mPopupMenu.show();
+    }
+
+    public boolean onPopupMenuItemClick(final MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.menu_shuffle_all:
+                // Shuffle all the songs
+                MusicUtils.shuffleAll(getActivity());
+                return true;
+            case R.id.menu_audio_player_ringtone:
+                // Set the current track as a ringtone
+                MusicUtils.setRingtone(getActivity(), MusicUtils.getCurrentAudioId());
+                return true;
+            case R.id.menu_audio_player_equalizer:
+                // Sound effects
+                NavUtils.openEffectsPanel(getActivity(), HomeActivity.EQUALIZER);
+                return true;
+            case R.id.menu_settings:
+                // Settings
+                NavUtils.openSettings(getActivity());
+                return true;
+            case R.id.menu_audio_player_more_by_artist:
+                NavUtils.openArtistProfile(getActivity(), MusicUtils.getArtistName());
+                return true;
+            case R.id.menu_audio_player_delete:
+                // Delete current song
+                DeleteDialog.newInstance(MusicUtils.getTrackName(), new long[]{
+                        MusicUtils.getCurrentAudioId()
+                }, null).show(getActivity().getSupportFragmentManager(), "DeleteDialog");
+                return true;
+            case R.id.menu_save_queue:
+                NowPlayingCursor queue = (NowPlayingCursor) QueueLoader
+                        .makeQueueCursor(getActivity());
+                CreateNewPlaylist.getInstance(MusicUtils.getSongListForCursor(queue)).show(
+                        getFragmentManager(), "CreatePlaylist");
+                queue.close();
+                return true;
+            case R.id.menu_clear_queue:
+                MusicUtils.clearQueue();
+                return true;
+            default:
+                break;
+        }
+
+        return false;
+    }
+
+    public void dismissPopupMenu() {
+        if (mPopupMenu != null) {
+            mPopupMenu.dismiss();
+        }
+    }
+
+    @Override
+    public boolean onContextItemSelected(MenuItem item) {
+        if (item.getGroupId() == GROUP_ID) {
+            switch (item.getItemId()) {
+                case FragmentMenuItems.NEW_PLAYLIST:
+                    CreateNewPlaylist.getInstance(new long[]{
+                            mSelectedId
+                    }).show(getFragmentManager(), "CreatePlaylist");
+                    return true;
+                case FragmentMenuItems.PLAYLIST_SELECTED:
+                    final long mPlaylistId = item.getIntent().getLongExtra("playlist", 0);
+                    MusicUtils.addToPlaylist(getActivity(), new long[]{
+                            mSelectedId
+                    }, mPlaylistId);
+                    return true;
+                default:
+                    break;
+            }
+        }
+
+        return super.onContextItemSelected(item);
+    }
+
+    public void onLyrics(String lyrics) {
+        if (TextUtils.isEmpty(lyrics)
+                || !PreferenceUtils.getInstance(getActivity()).getShowLyrics()) {
+            mLyricsText.animate().alpha(0).setDuration(200);
+        } else {
+            lyrics = lyrics.replace("\n", "<br/>");
+            Spanned span = Html.fromHtml(lyrics);
+            mLyricsText.setText(span);
+
+            mLyricsText.animate().alpha(1).setDuration(200);
+        }
+    }
+
+    public void setVisualizerVisible(boolean visible) {
+        if (visible && PreferenceUtils.getInstance(getActivity()).getShowVisualizer()) {
+            mVisualizerView.setVisible(true);
+        } else {
+            mVisualizerView.setVisible(false);
+        }
+    }
+
+    public void updateVisualizerPowerSaveMode() {
+        PowerManager pm = (PowerManager) getActivity().getSystemService(Context.POWER_SERVICE);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            mVisualizerView.setPowerSaveMode(pm.isPowerSaveMode());
+        }
+    }
+
+    public void setVisualizerColor(int color) {
+        mVisualizerView.setColor(color);
+    }
+
+    /**
+     * Used to update the current time string
+     */
+    private static final class TimeHandler extends Handler {
+
+        private final WeakReference<AudioPlayerFragment> mAudioPlayer;
+
+        /**
+         * Constructor of <code>TimeHandler</code>
+         */
+        public TimeHandler(final AudioPlayerFragment player) {
+            mAudioPlayer = new WeakReference<AudioPlayerFragment>(player);
+        }
+
+        @Override
+        public void handleMessage(final Message msg) {
+
+            AudioPlayerFragment ref = mAudioPlayer.get();
+            if (ref == null) {
+                return;
+            }
+
+            switch (msg.what) {
+                case REFRESH_TIME:
+                    final long next = mAudioPlayer.get().refreshCurrentTime();
+                    mAudioPlayer.get().queueNextRefresh(next);
+                    break;
+                case REFRESH_TOTAL_TIME:
+                    mAudioPlayer.get().refreshTotalTime();
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    /**
+     * Used to monitor the state of playback
+     */
+    private static final class PlaybackStatus extends BroadcastReceiver {
+
+        private final WeakReference<AudioPlayerFragment> mReference;
+
+        /**
+         * Constructor of <code>PlaybackStatus</code>
+         */
+        public PlaybackStatus(final AudioPlayerFragment fragment) {
+            mReference = new WeakReference<AudioPlayerFragment>(fragment);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            final AudioPlayerFragment audioPlayerFragment = mReference.get();
+            final String action = intent.getAction();
+            if (action.equals(MusicPlaybackService.META_CHANGED)) {
+                // if we are repeating current and the track has changed, re-create the adapter
+                if (MusicUtils.getRepeatMode() == MusicPlaybackService.REPEAT_CURRENT) {
+                    mReference.get().createAndSetAdapter();
+                }
+
+                // Current info
+                audioPlayerFragment.updateNowPlayingInfo();
+                audioPlayerFragment.dismissPopupMenu();
+            } else if (action.equals(MusicPlaybackService.PLAYSTATE_CHANGED)) {
+                // Set the play and pause image
+                audioPlayerFragment.mPlayPauseProgressButton.getPlayPauseButton().updateState();
+                audioPlayerFragment.mVisualizerView.setPlaying(MusicUtils.isPlaying());
+            } else if (action.equals(MusicPlaybackService.REPEATMODE_CHANGED)
+                    || action.equals(MusicPlaybackService.SHUFFLEMODE_CHANGED)) {
+                // Set the repeat image
+                audioPlayerFragment.mRepeatButton.updateRepeatState();
+                // Set the shuffle image
+                audioPlayerFragment.mShuffleButton.updateShuffleState();
+
+                // Update the queue
+                audioPlayerFragment.createAndSetAdapter();
+            } else if (action.equals(MusicPlaybackService.QUEUE_CHANGED)) {
+                audioPlayerFragment.createAndSetAdapter();
+            } else if (action.equals(MusicPlaybackService.NEW_LYRICS)) {
+                audioPlayerFragment.onLyrics(intent.getStringExtra("lyrics"));
+            } else if (action.equals(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED)) {
+                audioPlayerFragment.updateVisualizerPowerSaveMode();
+            }
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/BaseFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/BaseFragment.java
new file mode 100755
index 0000000000..915236272f
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/BaseFragment.java
@@ -0,0 +1,101 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.dolzzo.twelve.MusicStateListener;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.activities.HomeActivity;
+
+public abstract class BaseFragment extends Fragment implements MusicStateListener,
+        ISetupActionBar {
+
+    protected ViewGroup mRootView;
+
+    protected abstract String getTitle();
+
+    protected abstract int getLayoutToInflate();
+
+    protected boolean needsElevatedActionBar() {
+        return true;
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setRetainInstance(true);
+    }
+
+    @Override
+    public void setupActionBar() {
+        getContainingActivity().setupActionBar(getTitle());
+        getContainingActivity().setActionBarAlpha(255);
+        getContainingActivity().setFragmentPadding(true);
+        getContainingActivity().setActionBarElevation(needsElevatedActionBar());
+    }
+
+    protected HomeActivity getContainingActivity() {
+        return (HomeActivity) getActivity();
+    }
+
+    @Override
+    public final View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        // The View for the fragment's UI
+        mRootView = (ViewGroup) inflater.inflate(getLayoutToInflate(), null);
+        // set the background color
+        mRootView.setBackgroundColor(getResources().getColor(R.color.background_color));
+        // eat any touches that fall through to the root so they aren't
+        // passed on to fragments "behind" the current one.
+        mRootView.setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent me) {
+                return true;
+            }
+        });
+
+        setupActionBar();
+        onViewCreated();
+
+        return mRootView;
+    }
+
+    protected void onViewCreated() {
+        getContainingActivity().setMusicStateListenerListener(this);
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+
+        getContainingActivity().removeMusicStateListenerListener(this);
+    }
+
+    @Override
+    public void onMetaChanged() {
+
+    }
+
+    @Override
+    public void onPlaylistChanged() {
+
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/DetailFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/DetailFragment.java
new file mode 100755
index 0000000000..ba2ebd13d2
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/DetailFragment.java
@@ -0,0 +1,79 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments;
+
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+
+public abstract class DetailFragment extends BaseFragment {
+    protected PopupMenuHelper mActionMenuHelper;
+
+    /**
+     * create the popup menu helper used by the type of item
+     * for which this is a detail screen
+     */
+    protected abstract PopupMenuHelper createActionMenuHelper();
+
+    /**
+     * menu title for the shuffle option for this screen
+     */
+    protected abstract int getShuffleTitleId();
+
+    /**
+     * action to take if the shuffle menu is selected
+     */
+    protected abstract void playShuffled();
+
+    @Override
+    protected void onViewCreated() {
+        super.onViewCreated();
+        setHasOptionsMenu(true);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {
+        inflater.inflate(R.menu.shuffle_item, menu);
+        menu.findItem(R.id.menu_shuffle_item).setTitle(getShuffleTitleId());
+
+        // use the same popup menu to provide actions for the item
+        // represented by this detail screen as would be used elsewhere
+        mActionMenuHelper = createActionMenuHelper();
+        mActionMenuHelper.onPreparePopupMenu(0);
+        mActionMenuHelper.createPopupMenu(menu);
+
+        super.onCreateOptionsMenu(menu, inflater);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(final MenuItem item) {
+        if (item.getItemId() == R.id.menu_shuffle_item) {
+            playShuffled();
+            return true;
+        }
+
+        // delegate to the popup menu that represents the item
+        // for which this is a detail screen
+        if (mActionMenuHelper.onMenuItemClick(item)) {
+            return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/FadingBarFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/FadingBarFragment.java
new file mode 100755
index 0000000000..9636321107
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/FadingBarFragment.java
@@ -0,0 +1,74 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments;
+
+import android.view.View;
+import android.widget.AbsListView;
+import android.widget.AbsListView.OnScrollListener;
+
+import com.dolzzo.twelve.ui.activities.HomeActivity;
+
+public abstract class FadingBarFragment extends DetailFragment implements OnScrollListener {
+    protected static final int ACTION_BAR_DEFAULT_OPACITY = 100;
+
+    @Override
+    public void setupActionBar() {
+        super.setupActionBar();
+
+        getContainingActivity().setActionBarAlpha(ACTION_BAR_DEFAULT_OPACITY);
+        getContainingActivity().setFragmentPadding(true);
+    }
+
+    protected abstract int getHeaderHeight();
+
+    protected abstract void setHeaderPosition(float y);
+
+    @Override // OnScrollListener
+    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
+        View firstChild = view.getChildAt(0);
+        if (firstChild == null) {
+            return;
+        }
+
+        float firstChildY = firstChild.getY();
+
+        int alpha = 255;
+        if (firstVisibleItem == 0) {
+            // move header to current top of list
+            setHeaderPosition(firstChildY);
+            // calculate alpha for the action bar
+            alpha = ACTION_BAR_DEFAULT_OPACITY +
+                    (int) ((255 - ACTION_BAR_DEFAULT_OPACITY) * -firstChildY /
+                            (float) (firstChild.getHeight()));
+            if (alpha > 255) {
+                alpha = 255;
+            }
+        } else {
+            // header off screen
+            setHeaderPosition(-getHeaderHeight());
+        }
+
+        HomeActivity home = getContainingActivity();
+        if (home != null && home.getTopFragment() == this) {
+            home.setActionBarAlpha(alpha);
+        }
+    }
+
+    @Override // OnScrollListener
+    public void onScrollStateChanged(AbsListView view, int scrollState) {
+
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/IChildFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/IChildFragment.java
new file mode 100755
index 0000000000..675c356fc0
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/IChildFragment.java
@@ -0,0 +1,22 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments;
+
+import com.dolzzo.twelve.adapters.PagerAdapter;
+
+public interface IChildFragment {
+    PagerAdapter.MusicFragments getMusicFragmentParent();
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/ISetupActionBar.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/ISetupActionBar.java
new file mode 100755
index 0000000000..576093c03c
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/ISetupActionBar.java
@@ -0,0 +1,20 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments;
+
+public interface ISetupActionBar {
+    public void setupActionBar();
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/PlaylistDetailFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/PlaylistDetailFragment.java
new file mode 100755
index 0000000000..a8b8601827
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/PlaylistDetailFragment.java
@@ -0,0 +1,427 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments;
+
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.MediaStore;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.Loader;
+import android.view.View;
+import android.widget.AbsListView;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.PagerAdapter;
+import com.dolzzo.twelve.adapters.ProfileSongAdapter;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.dragdrop.DragSortListView;
+import com.dolzzo.twelve.dragdrop.DragSortListView.DragScrollProfile;
+import com.dolzzo.twelve.dragdrop.DragSortListView.DropListener;
+import com.dolzzo.twelve.dragdrop.DragSortListView.RemoveListener;
+import com.dolzzo.twelve.loaders.PlaylistSongLoader;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.model.Playlist;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.recycler.RecycleHolder;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PlaylistPopupMenuHelper;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.utils.PopupMenuHelper.PopupMenuType;
+import com.dolzzo.twelve.utils.SongPopupMenuHelper;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+import com.dolzzo.twelve.widgets.NoResultsContainer;
+
+import java.util.List;
+import java.util.TreeSet;
+
+public class PlaylistDetailFragment extends FadingBarFragment implements
+        LoaderCallbacks<List<Song>>, OnItemClickListener, DropListener,
+        RemoveListener, DragScrollProfile, IChildFragment {
+
+    /**
+     * LoaderCallbacks identifier
+     */
+    private static final int LOADER = 0;
+
+    private DragSortListView mListView;
+    private ProfileSongAdapter mAdapter;
+
+    private View mHeaderContainer;
+    private ImageView mPlaylistImageView;
+
+    private LoadingEmptyContainer mLoadingEmptyContainer;
+
+    private TextView mNumberOfSongs;
+    private TextView mDurationOfPlaylist;
+
+    /**
+     * The Id of the playlist the songs belong to
+     */
+    private long mPlaylistId;
+    private String mPlaylistName;
+
+    /**
+     * Pop up menu helper
+     */
+    private PopupMenuHelper mPopupMenuHelper;
+
+    @Override
+    protected String getTitle() {
+        return mPlaylistName;
+    }
+
+    @Override
+    protected int getLayoutToInflate() {
+        return R.layout.playlist_detail;
+    }
+
+    @Override
+    protected void onViewCreated() {
+        super.onViewCreated();
+        setupHero();
+        setupSongList();
+    }
+
+    private void lookupName() {
+        mPlaylistName = MusicUtils.getNameForPlaylist(getActivity(), mPlaylistId);
+    }
+
+    @Override // DetailFragment
+    protected PopupMenuHelper createActionMenuHelper() {
+        return new PlaylistPopupMenuHelper(
+                getActivity(), getChildFragmentManager(), PopupMenuType.Playlist) {
+            public Playlist getPlaylist(int position) {
+                return new Playlist(mPlaylistId, getTitle(), 0);
+            }
+        };
+    }
+
+    @Override // DetailFragment
+    protected int getShuffleTitleId() {
+        return R.string.menu_shuffle_playlist;
+    }
+
+    @Override // DetailFragment
+    protected void playShuffled() {
+        MusicUtils.playPlaylist(getActivity(), mPlaylistId, true);
+    }
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        LoaderManager lm = getLoaderManager();
+        lm.initLoader(0, getArguments(), this);
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        mPopupMenuHelper = new SongPopupMenuHelper(getActivity(), getFragmentManager()) {
+            @Override
+            public Song getSong(int position) {
+                if (position == 0) {
+                    return null;
+                }
+
+                return mAdapter.getItem(position);
+            }
+
+            @Override
+            protected void updateMenuIds(PopupMenuType type, TreeSet<Integer> set) {
+                super.updateMenuIds(type, set);
+
+                set.add(FragmentMenuItems.REMOVE_FROM_PLAYLIST);
+                set.remove(FragmentMenuItems.DELETE);
+            }
+
+            @Override
+            protected long getSourceId() {
+                return mPlaylistId;
+            }
+
+            @Override
+            protected Config.IdType getSourceType() {
+                return Config.IdType.Playlist;
+            }
+
+            @Override
+            protected void removeFromPlaylist() {
+                mAdapter.remove(mSong);
+                mAdapter.buildCache();
+                mAdapter.notifyDataSetChanged();
+                MusicUtils.removeFromPlaylist(getActivity(), mSong.mSongId, mPlaylistId);
+                getLoaderManager().restartLoader(LOADER, null, PlaylistDetailFragment.this);
+            }
+        };
+
+        mPlaylistId = getArguments().getLong(Config.ID);
+        lookupName();
+    }
+
+    private void setupHero() {
+        mPlaylistImageView = (ImageView) mRootView.findViewById(R.id.image);
+        mHeaderContainer = mRootView.findViewById(R.id.playlist_header);
+        mNumberOfSongs = (TextView) mRootView.findViewById(R.id.number_of_songs_text);
+        mDurationOfPlaylist = (TextView) mRootView.findViewById(R.id.duration_text);
+
+        final ImageFetcher imageFetcher = ImageFetcher.getInstance(getActivity());
+        imageFetcher.loadPlaylistArtistImage(mPlaylistId, mPlaylistImageView);
+    }
+
+    private void setupSongList() {
+        mListView = (DragSortListView) mRootView.findViewById(R.id.list_base);
+        mListView.setOnScrollListener(PlaylistDetailFragment.this);
+
+        mAdapter = new ProfileSongAdapter(
+                mPlaylistId,
+                getActivity(),
+                R.layout.edit_track_list_item,
+                R.layout.faux_playlist_header
+        );
+        mAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mPopupMenuHelper.showPopupMenu(v, position);
+            }
+        });
+        mListView.setAdapter(mAdapter);
+        // Release any references to the recycled Views
+        mListView.setRecyclerListener(new RecycleHolder());
+        // Play the selected song
+        mListView.setOnItemClickListener(this);
+        // Set the drop listener
+        mListView.setDropListener(this);
+        // Set the swipe to remove listener
+        mListView.setRemoveListener(this);
+        // Quick scroll while dragging
+        mListView.setDragScrollProfile(this);
+
+        // Adjust the progress bar padding to account for the header
+        int padTop = getResources().getDimensionPixelSize(R.dimen.playlist_detail_header_height);
+        mRootView.findViewById(R.id.progressbar).setPadding(0, padTop, 0, 0);
+
+        // set the loading and empty view container
+        mLoadingEmptyContainer =
+                (LoadingEmptyContainer) mRootView.findViewById(R.id.loading_empty_container);
+        setupNoResultsContainer(mLoadingEmptyContainer.getNoResultsContainer());
+        mListView.setEmptyView(mLoadingEmptyContainer);
+    }
+
+    private void setupNoResultsContainer(final NoResultsContainer container) {
+        container.setMainText(R.string.empty_playlist_main);
+        container.setSecondaryText(R.string.empty_playlist_secondary);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public float getSpeed(final float w, final long t) {
+        if (w > 0.8f) {
+            return mAdapter.getCount() / 0.001f;
+        } else {
+            return 10.0f * w;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void remove(final int which) {
+        if (which == 0) {
+            return;
+        }
+
+        Song song = mAdapter.getItem(which);
+        mAdapter.remove(song);
+        mAdapter.buildCache();
+        mAdapter.notifyDataSetChanged();
+        final Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", mPlaylistId);
+        getActivity().getContentResolver().delete(uri,
+                MediaStore.Audio.Playlists.Members.AUDIO_ID + "=" + song.mSongId,
+                null);
+
+        MusicUtils.refresh();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void drop(int from, int to) {
+        from = Math.max(ProfileSongAdapter.NUM_HEADERS, from);
+        to = Math.max(ProfileSongAdapter.NUM_HEADERS, to);
+
+        Song song = mAdapter.getItem(from);
+        mAdapter.remove(song);
+        mAdapter.insert(song, to);
+        mAdapter.buildCache();
+        mAdapter.notifyDataSetChanged();
+
+        final int realFrom = from - ProfileSongAdapter.NUM_HEADERS;
+        final int realTo = to - ProfileSongAdapter.NUM_HEADERS;
+        MediaStore.Audio.Playlists.Members.moveItem(getActivity().getContentResolver(),
+                mPlaylistId, realFrom, realTo);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onItemClick(final AdapterView<?> parent, final View view, final int position,
+                            final long id) {
+        if (position == 0) {
+            return;
+        }
+        Cursor cursor = PlaylistSongLoader.makePlaylistSongCursor(getActivity(),
+                mPlaylistId);
+        final long[] list = MusicUtils.getSongListForCursor(cursor);
+        MusicUtils.playAll(getActivity(), list, position - ProfileSongAdapter.NUM_HEADERS,
+                mPlaylistId, Config.IdType.Playlist, false);
+        cursor.close();
+        cursor = null;
+    }
+
+    @Override
+    public void onScrollStateChanged(AbsListView view, int scrollState) {
+        super.onScrollStateChanged(view, scrollState);
+
+        if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_FLING) {
+            mAdapter.setPauseDiskCache(true);
+        } else {
+            mAdapter.setPauseDiskCache(false);
+            mAdapter.notifyDataSetChanged();
+        }
+    }
+
+    protected int getHeaderHeight() {
+        return mHeaderContainer.getHeight();
+    }
+
+    protected void setHeaderPosition(float y) {
+        // Offset the header height to account for the faux header
+        y = y - getResources().getDimension(R.dimen.header_bar_height);
+        mHeaderContainer.setY(y);
+    }
+
+    @Override
+    public Loader<List<Song>> onCreateLoader(int i, Bundle bundle) {
+        mLoadingEmptyContainer.showLoading();
+
+        return new PlaylistSongLoader(getActivity(), mPlaylistId);
+    }
+
+    @Override
+    public void onLoadFinished(final Loader<List<Song>> loader, final List<Song> data) {
+        if (data.isEmpty()) {
+            mLoadingEmptyContainer.showNoResults();
+
+            // hide the header container
+            mHeaderContainer.setVisibility(View.INVISIBLE);
+
+            // Start fresh
+            mAdapter.unload();
+        } else {
+            // show the header container
+            mHeaderContainer.setVisibility(View.VISIBLE);
+
+            // pause notifying the adapter and make changes before re-enabling it so that the list
+            // view doesn't reset to the top of the list
+            mAdapter.setNotifyOnChange(false);
+            // Start fresh
+            mAdapter.unload();
+            // Return the correct count
+            mAdapter.addAll(data);
+            // build the cache
+            mAdapter.buildCache();
+            // re-enable the notify by calling notify dataset changes
+            mAdapter.notifyDataSetChanged();
+            // set the number of songs
+            String numberOfSongs = MusicUtils.makeLabel(getActivity(), R.plurals.Nsongs,
+                    data.size());
+            mNumberOfSongs.setText(numberOfSongs);
+
+            long duration = 0;
+
+            // Add the data to the adapter
+            for (final Song song : data) {
+                duration += song.mDuration;
+            }
+
+            // set the duration
+            String durationString = MusicUtils.makeLongTimeString(getActivity(), duration);
+            mDurationOfPlaylist.setText(durationString);
+        }
+    }
+
+    @Override
+    public void onLoaderReset(final Loader<List<Song>> loader) {
+        // Clear the data in the adapter
+        mAdapter.unload();
+    }
+
+    @Override
+    public void restartLoader() {
+        lookupName(); // playlist name may have changed
+        if (mPlaylistName == null) {
+            // if name is null, we've been deleted, so close the this fragment
+            getContainingActivity().postRemoveFragment(this);
+            return;
+        }
+
+        // since onCreateOptionsMenu can be called after onCreate it is possible for
+        // mActionMenuHelper to be null.  In this case, don't bother updating the Name since when
+        // it does create it, it will use the updated name anyways
+        if (mActionMenuHelper != null) {
+            // update action bar title and popup menu handler
+            ((PlaylistPopupMenuHelper) mActionMenuHelper).updateName(mPlaylistName);
+        }
+
+        getContainingActivity().setActionBarTitle(mPlaylistName);
+        // and reload the song list
+        getLoaderManager().restartLoader(0, getArguments(), this);
+    }
+
+    @Override
+    public void onMetaChanged() {
+        super.onMetaChanged();
+
+        mAdapter.setCurrentlyPlayingTrack(MusicUtils.getCurrentTrack());
+    }
+
+    @Override
+    public void onPlaylistChanged() {
+        super.onPlaylistChanged();
+
+        restartLoader();
+    }
+
+    @Override
+    public PagerAdapter.MusicFragments getMusicFragmentParent() {
+        return PagerAdapter.MusicFragments.PLAYLIST;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/PlaylistFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/PlaylistFragment.java
new file mode 100755
index 0000000000..61a0439a17
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/PlaylistFragment.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.Loader;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ListView;
+
+import com.dolzzo.twelve.Config.SmartPlaylistType;
+import com.dolzzo.twelve.MusicStateListener;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.PagerAdapter;
+import com.dolzzo.twelve.adapters.PlaylistAdapter;
+import com.dolzzo.twelve.loaders.PlaylistLoader;
+import com.dolzzo.twelve.model.Playlist;
+import com.dolzzo.twelve.recycler.RecycleHolder;
+import com.dolzzo.twelve.ui.activities.BaseActivity;
+import com.dolzzo.twelve.ui.fragments.phone.MusicBrowserFragment;
+import com.dolzzo.twelve.utils.NavUtils;
+import com.dolzzo.twelve.utils.PlaylistPopupMenuHelper;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+
+import java.util.List;
+
+/**
+ * This class is used to display all of the playlists on a user's device.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class PlaylistFragment extends MusicBrowserFragment implements
+        LoaderCallbacks<List<Playlist>>,
+        OnItemClickListener, MusicStateListener {
+
+    /**
+     * The adapter for the list
+     */
+    private PlaylistAdapter mAdapter;
+
+    /**
+     * The list view
+     */
+    private ListView mListView;
+
+    /**
+     * Pop up menu helper
+     */
+    private PopupMenuHelper mPopupMenuHelper;
+
+    /**
+     * This holds the loading progress bar as well as the no results message
+     */
+    private LoadingEmptyContainer mLoadingEmptyContainer;
+
+    /**
+     * Empty constructor as per the {@link Fragment} documentation
+     */
+    public PlaylistFragment() {
+    }
+
+    @Override
+    public int getLoaderId() {
+        return PagerAdapter.MusicFragments.PLAYLIST.ordinal();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mPopupMenuHelper = new PlaylistPopupMenuHelper(getActivity(), getFragmentManager(), null) {
+            @Override
+            public Playlist getPlaylist(int position) {
+                return mAdapter.getItem(position);
+            }
+        };
+
+        // Create the adapter
+        mAdapter = new PlaylistAdapter(getActivity());
+        mAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mPopupMenuHelper.showPopupMenu(v, position);
+            }
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+                             final Bundle savedInstanceState) {
+        // The View for the fragment's UI
+        final ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.list_base, null);
+        // Initialize the list
+        mListView = (ListView) rootView.findViewById(R.id.list_base);
+        // Set the data behind the grid
+        mListView.setAdapter(mAdapter);
+        // Release any references to the recycled Views
+        mListView.setRecyclerListener(new RecycleHolder());
+        // Play the selected song
+        mListView.setOnItemClickListener(this);
+        // Setup the loading and empty state
+        mLoadingEmptyContainer =
+                (LoadingEmptyContainer) rootView.findViewById(R.id.loading_empty_container);
+        mListView.setEmptyView(mLoadingEmptyContainer);
+
+        // Register the music status listener
+        ((BaseActivity) getActivity()).setMusicStateListenerListener(this);
+
+        return rootView;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+
+        ((BaseActivity) getActivity()).removeMusicStateListenerListener(this);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        // Enable the options menu
+        setHasOptionsMenu(true);
+        // Start the loader
+        initLoader(null, this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onItemClick(final AdapterView<?> parent, final View view, final int position,
+                            final long id) {
+        Playlist playlist = mAdapter.getItem(position);
+
+        SmartPlaylistType playlistType = SmartPlaylistType.getTypeById(playlist.mPlaylistId);
+        if (playlistType != null) {
+            NavUtils.openSmartPlaylist(getActivity(), playlistType);
+        } else {
+            NavUtils.openPlaylist(getActivity(), playlist.mPlaylistId, playlist.mPlaylistName);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Loader<List<Playlist>> onCreateLoader(final int id, final Bundle args) {
+        // show the loading progress bar
+        mLoadingEmptyContainer.showLoading();
+        return new PlaylistLoader(getActivity());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoadFinished(final Loader<List<Playlist>> loader, final List<Playlist> data) {
+        // Check for any errors
+        if (data.isEmpty()) {
+            mLoadingEmptyContainer.showNoResults();
+            return;
+        }
+
+        // Start fresh
+        mAdapter.unload();
+        // Add the data to the adpater
+        for (final Playlist playlist : data) {
+            mAdapter.add(playlist);
+        }
+        // Build the cache
+        mAdapter.buildCache();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoaderReset(final Loader<List<Playlist>> loader) {
+        // Clear the data in the adapter
+        mAdapter.unload();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void restartLoader() {
+        restartLoader(null, this);
+    }
+
+    @Override
+    public void onPlaylistChanged() {
+        restartLoader();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onMetaChanged() {
+        // Nothing to do
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/QueueFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/QueueFragment.java
new file mode 100755
index 0000000000..71cd5f27a5
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/QueueFragment.java
@@ -0,0 +1,481 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments;
+
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.provider.MediaStore;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.Loader;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.SongAdapter;
+import com.dolzzo.twelve.dragdrop.DragSortListView;
+import com.dolzzo.twelve.dragdrop.DragSortListView.DragScrollProfile;
+import com.dolzzo.twelve.dragdrop.DragSortListView.DropListener;
+import com.dolzzo.twelve.dragdrop.DragSortListView.RemoveListener;
+import com.dolzzo.twelve.loaders.NowPlayingCursor;
+import com.dolzzo.twelve.loaders.QueueLoader;
+import com.dolzzo.twelve.menu.DeleteDialog;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.recycler.RecycleHolder;
+import com.dolzzo.twelve.service.MusicPlaybackTrack;
+import com.dolzzo.twelve.ui.activities.SlidingPanelActivity;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+import com.dolzzo.twelve.widgets.NoResultsContainer;
+import com.dolzzo.twelve.widgets.PlayPauseProgressButton;
+
+import java.lang.ref.WeakReference;
+import java.util.List;
+import java.util.TreeSet;
+
+import static com.dolzzo.twelve.utils.MusicUtils.mService;
+
+/**
+ * This class is used to display all of the songs in the queue.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class QueueFragment extends Fragment implements LoaderCallbacks<List<Song>>,
+        OnItemClickListener, DropListener, RemoveListener, DragScrollProfile, ServiceConnection {
+
+    /**
+     * LoaderCallbacks identifier
+     */
+    private static final int LOADER = 0;
+
+    /**
+     * Service token for binding to the music service
+     */
+    private MusicUtils.ServiceToken mToken;
+
+    /**
+     * The listener to the playback service that will trigger updates to the ui
+     */
+    private QueueUpdateListener mQueueUpdateListener;
+
+    /**
+     * The adapter for the list
+     */
+    private SongAdapter mAdapter;
+
+    /**
+     * The list view
+     */
+    private DragSortListView mListView;
+
+    /**
+     * Pop up menu helper
+     */
+    private PopupMenuHelper mPopupMenuHelper;
+
+    /**
+     * Root view
+     */
+    private ViewGroup mRootView;
+
+    /**
+     * This holds the loading progress bar as well as the no results message
+     */
+    private LoadingEmptyContainer mLoadingEmptyContainer;
+
+    /**
+     * Empty constructor as per the {@link Fragment} documentation
+     */
+    public QueueFragment() {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mPopupMenuHelper = new PopupMenuHelper(getActivity(), getFragmentManager()) {
+            private Song mSong;
+            private int mSelectedPosition;
+            private MusicPlaybackTrack mSelectedTrack;
+
+            @Override
+            public PopupMenuType onPreparePopupMenu(int position) {
+                mSelectedPosition = position;
+                mSong = mAdapter.getItem(mSelectedPosition);
+                mSelectedTrack = MusicUtils.getTrack(mSelectedPosition);
+
+                return PopupMenuType.Queue;
+            }
+
+            @Override
+            protected long[] getIdList() {
+                return new long[]{mSong.mSongId};
+            }
+
+            @Override
+            protected long getSourceId() {
+                if (mSelectedTrack == null) {
+                    return -1;
+                }
+
+                return mSelectedTrack.mSourceId;
+            }
+
+            @Override
+            protected Config.IdType getSourceType() {
+                if (mSelectedTrack == null) {
+                    return Config.IdType.NA;
+                }
+
+                return mSelectedTrack.mSourceType;
+            }
+
+            @Override
+            protected String getArtistName() {
+                return mSong.mArtistName;
+            }
+
+            @Override
+            protected void onDeleteClicked() {
+                DeleteDialog.newInstance(mSong.mSongName,
+                        new long[]{getId()}, null).show(getFragmentManager(), "DeleteDialog");
+            }
+
+            @Override
+            protected void playNext() {
+                NowPlayingCursor queue = (NowPlayingCursor) QueueLoader
+                        .makeQueueCursor(getActivity());
+                queue.removeItem(mSelectedPosition);
+                queue.close();
+                queue = null;
+                MusicUtils.playNext(getIdList(), getSourceId(), getSourceType());
+                refreshQueue();
+            }
+
+            @Override
+            protected void removeFromQueue() {
+                MusicUtils.removeTrackAtPosition(getId(), mSelectedPosition);
+                refreshQueue();
+            }
+
+            @Override
+            protected void updateMenuIds(PopupMenuType type, TreeSet<Integer> set) {
+                super.updateMenuIds(type, set);
+
+                // Don't show more by artist if it is an unknown artist
+                if (MediaStore.UNKNOWN_STRING.equals(mSong.mArtistName)) {
+                    set.remove(FragmentMenuItems.MORE_BY_ARTIST);
+                }
+            }
+        };
+
+        // Create the adapter
+        mAdapter = new SongAdapter(getActivity(), R.layout.edit_queue_list_item,
+                -1, Config.IdType.NA);
+        mAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mPopupMenuHelper.showPopupMenu(v, position);
+            }
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+                             final Bundle savedInstanceState) {
+        // The View for the fragment's UI
+        mRootView = (ViewGroup) inflater.inflate(R.layout.list_base, null);
+        // Initialize the list
+        mListView = (DragSortListView) mRootView.findViewById(R.id.list_base);
+        // Set the data behind the list
+        mListView.setAdapter(mAdapter);
+        // Release any references to the recycled Views
+        mListView.setRecyclerListener(new RecycleHolder());
+        // Play the selected song
+        mListView.setOnItemClickListener(this);
+        // Set the drop listener
+        mListView.setDropListener(this);
+        // Set the swipe to remove listener
+        mListView.setRemoveListener(this);
+        // Quick scroll while dragging
+        mListView.setDragScrollProfile(this);
+        // Enable fast scroll bars
+        mListView.setFastScrollEnabled(true);
+        // Setup the loading and empty state
+        mLoadingEmptyContainer =
+                (LoadingEmptyContainer) mRootView.findViewById(R.id.loading_empty_container);
+        // Setup the container strings
+        setupNoResultsContainer(mLoadingEmptyContainer.getNoResultsContainer());
+        mListView.setEmptyView(mLoadingEmptyContainer);
+        return mRootView;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        // Initialize the broadcast receiver
+        mQueueUpdateListener = new QueueUpdateListener(this);
+
+        // Bind Apollo's service
+        mToken = MusicUtils.bindToService(getActivity(), this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onServiceConnected(final ComponentName name, final IBinder service) {
+        refreshQueue();
+    }
+
+    @Override
+    public void onServiceDisconnected(ComponentName name) {
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        final IntentFilter filter = new IntentFilter();
+        // Play and pause changes
+        filter.addAction(MusicPlaybackService.PLAYSTATE_CHANGED);
+        // Queue changes
+        filter.addAction(MusicPlaybackService.QUEUE_CHANGED);
+        // Track changes
+        filter.addAction(MusicPlaybackService.META_CHANGED);
+
+        getActivity().registerReceiver(mQueueUpdateListener, filter);
+
+        // resume the progress listeners
+        setPlayPauseProgressButtonStates(false);
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+
+        // stops the progress listeners
+        setPlayPauseProgressButtonStates(true);
+    }
+
+    /**
+     * Sets the state for any play pause progress buttons under the listview
+     * This is neede because the buttons update themselves so if the activity
+     * is hidden, we want to pause those handlers
+     *
+     * @param pause the state to set it to
+     */
+    public void setPlayPauseProgressButtonStates(boolean pause) {
+        if (mListView != null) {
+            // walk through the visible list items
+            for (int i = mListView.getFirstVisiblePosition();
+                 i <= mListView.getLastVisiblePosition(); i++) {
+                View childView = mListView.getChildAt(i);
+                if (childView != null) {
+                    PlayPauseProgressButton button =
+                            (PlayPauseProgressButton) childView.findViewById(R.id.playPauseProgressButton);
+                    // pause or resume based on the flag
+                    if (pause) {
+                        button.pause();
+                    } else {
+                        button.resume();
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        try {
+            getActivity().unregisterReceiver(mQueueUpdateListener);
+        } catch (final Throwable e) {
+            //$FALL-THROUGH$
+        }
+
+        if (mService != null) {
+            MusicUtils.unbindFromService(mToken);
+            mToken = null;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onItemClick(final AdapterView<?> parent, final View view, final int position,
+                            final long id) {
+        // When selecting a track from the queue, just jump there instead of
+        // reloading the queue. This is both faster, and prevents accidentally
+        // dropping out of party shuffle.
+        MusicUtils.setQueuePosition(position);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Loader<List<Song>> onCreateLoader(final int id, final Bundle args) {
+        mLoadingEmptyContainer.showLoading();
+        return new QueueLoader(getActivity());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoadFinished(final Loader<List<Song>> loader, final List<Song> data) {
+        // pause notifying the adapter and make changes before re-enabling it so that the list
+        // view doesn't reset to the top of the list
+        mAdapter.setNotifyOnChange(false);
+        mAdapter.unload(); // Start fresh
+
+        if (data.isEmpty()) {
+            mLoadingEmptyContainer.showNoResults();
+            mAdapter.setCurrentQueuePosition(SongAdapter.NOTHING_PLAYING);
+            ((SlidingPanelActivity) getActivity()).clearMetaInfo();
+        } else {
+            // Add the songs found to the adapter
+            for (final Song song : data) {
+                mAdapter.add(song);
+            }
+            // Build the cache
+            mAdapter.buildCache();
+            // Set the currently playing audio
+            mAdapter.setCurrentQueuePosition(MusicUtils.getQueuePosition());
+        }
+        // re-enable the notify by calling notify dataset changes
+        mAdapter.notifyDataSetChanged();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoaderReset(final Loader<List<Song>> loader) {
+        // Clear the data in the adapter
+        mAdapter.unload();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public float getSpeed(final float w, final long t) {
+        if (w > 0.8f) {
+            return mAdapter.getCount() / 0.001f;
+        } else {
+            return 10.0f * w;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void remove(final int which) {
+        Song song = mAdapter.getItem(which);
+        mAdapter.remove(song);
+        mAdapter.notifyDataSetChanged();
+        MusicUtils.removeTrackAtPosition(song.mSongId, which);
+        // Build the cache
+        mAdapter.buildCache();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void drop(final int from, final int to) {
+        Song song = mAdapter.getItem(from);
+        mAdapter.remove(song);
+        mAdapter.insert(song, to);
+        mAdapter.notifyDataSetChanged();
+        MusicUtils.moveQueueItem(from, to);
+        // Build the cache
+        mAdapter.buildCache();
+    }
+
+    /**
+     * Called to restart the loader callbacks
+     */
+    public void refreshQueue() {
+        if (isAdded()) {
+            getLoaderManager().restartLoader(LOADER, null, this);
+        }
+    }
+
+    private void setupNoResultsContainer(NoResultsContainer empty) {
+        int color = getResources().getColor(R.color.no_results_light);
+        empty.setTextColor(color);
+        empty.setMainText(R.string.empty_queue_main);
+        empty.setSecondaryText(R.string.empty_queue_secondary);
+    }
+
+    /**
+     * Used to monitor the state of playback
+     */
+    private static final class QueueUpdateListener extends BroadcastReceiver {
+
+        private final WeakReference<QueueFragment> mReference;
+
+        /**
+         * Constructor of <code>PlaybackStatus</code>
+         */
+        public QueueUpdateListener(final QueueFragment fragment) {
+            mReference = new WeakReference<QueueFragment>(fragment);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void onReceive(final Context context, final Intent intent) {
+            // TODO: Invalid options menu if opened?
+            final String action = intent.getAction();
+            if (action.equals(MusicPlaybackService.META_CHANGED)) {
+                mReference.get().mAdapter.setCurrentQueuePosition(MusicUtils.getQueuePosition());
+            } else if (action.equals(MusicPlaybackService.PLAYSTATE_CHANGED)) {
+                mReference.get().mAdapter.notifyDataSetChanged();
+            } else if (action.equals(MusicPlaybackService.QUEUE_CHANGED)) {
+                mReference.get().refreshQueue();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/RecentFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/RecentFragment.java
new file mode 100755
index 0000000000..bc5d9c1d69
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/RecentFragment.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.support.v4.content.Loader;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.Config.SmartPlaylistType;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.SongAdapter;
+import com.dolzzo.twelve.loaders.TopTracksLoader;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.sectionadapter.SectionListContainer;
+import com.dolzzo.twelve.ui.activities.BaseActivity;
+import com.dolzzo.twelve.ui.fragments.profile.SmartPlaylistFragment;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.NoResultsContainer;
+
+import java.util.TreeSet;
+
+/**
+ * This class is used to display all of the recently listened to songs by the
+ * user.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class RecentFragment extends SmartPlaylistFragment implements ISetupActionBar {
+
+    @Override
+    protected SmartPlaylistType getSmartPlaylistType() {
+        return Config.SmartPlaylistType.RecentlyPlayed;
+    }
+
+    @Override
+    protected void updateMenuIds(TreeSet<Integer> set) {
+        set.add(FragmentMenuItems.REMOVE_FROM_RECENT);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Loader<SectionListContainer<Song>> onCreateLoader(final int id, final Bundle args) {
+        // show the loading progress bar
+        mLoadingEmptyContainer.showLoading();
+
+        TopTracksLoader loader = new TopTracksLoader(getActivity(),
+                TopTracksLoader.QueryType.RecentSongs);
+        return new SectionCreator<Song>(getActivity(), loader, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onMetaChanged() {
+        super.onMetaChanged();
+
+        // refresh the list since a track playing means it should be recently played
+        restartLoader();
+    }
+
+    @Override
+    public void setupNoResultsContainer(NoResultsContainer empty) {
+        super.setupNoResultsContainer(empty);
+
+        empty.setMainText(R.string.empty_recent_main);
+        empty.setSecondaryText(R.string.empty_recent);
+    }
+
+    @Override
+    public final View onCreateView(LayoutInflater inflater, ViewGroup container,
+                                   Bundle savedInstanceState) {
+        setupActionBar();
+        return super.onCreateView(inflater, container, savedInstanceState);
+    }
+
+    @Override
+    public void setupActionBar() {
+        ((BaseActivity) getActivity()).setupActionBar(R.string.playlist_recently_played);
+        ((BaseActivity) getActivity()).setActionBarElevation(true);
+    }
+
+    @Override
+    protected long getFragmentSourceId() {
+        return Config.SmartPlaylistType.RecentlyPlayed.mId;
+    }
+
+    @Override
+    protected SongAdapter createAdapter() {
+        return new RecentAdapter(
+                getActivity(),
+                R.layout.list_item_normal,
+                getFragmentSourceId(),
+                getFragmentSourceType()
+        );
+    }
+
+    @Override
+    protected int getShuffleTitleId() {
+        return R.string.menu_shuffle_recent;
+    }
+
+    @Override
+    protected int getClearTitleId() {
+        return R.string.clear_recent_title;
+    }
+
+    @Override
+    protected void clearList() {
+        MusicUtils.clearRecent(getActivity());
+    }
+
+    private class RecentAdapter extends SongAdapter {
+        public RecentAdapter(Activity context, int layoutId, long sourceId, Config.IdType sourceType) {
+            super(context, layoutId, sourceId, sourceType);
+        }
+
+        @Override
+        protected boolean showNowPlayingIndicator(Song song, int position) {
+            return position == 0 && super.showNowPlayingIndicator(song, position);
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/SongFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/SongFragment.java
new file mode 100755
index 0000000000..34941ee9c4
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/SongFragment.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.content.Loader;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.adapters.PagerAdapter;
+import com.dolzzo.twelve.loaders.SongLoader;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.sectionadapter.SectionListContainer;
+import com.dolzzo.twelve.ui.fragments.profile.BasicSongFragment;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.SectionCreatorUtils;
+
+/**
+ * This class is used to display all of the songs on a user's device.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class SongFragment extends BasicSongFragment {
+
+    /**
+     * {@inheritDoc}
+     */
+    public void playAll(int position) {
+        int internalPosition = mAdapter.getInternalPosition(position);
+        final long[] list = mAdapter.getUnderlyingAdapter().getSongIds();
+        if (list != null) {
+            MusicUtils.playAll(getActivity(), list, internalPosition, -1, Config.IdType.NA, false);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Loader<SectionListContainer<Song>> onCreateLoader(final int id, final Bundle args) {
+        // show the loading progress bar
+        mLoadingEmptyContainer.showLoading();
+
+        // get the context
+        Context context = getActivity();
+
+        // create the underlying song loader
+        SongLoader songLoader = new SongLoader(context);
+
+        // get the song comparison method to create the headers with
+        SectionCreatorUtils.IItemCompare<Song> songComparison = SectionCreatorUtils.createSongComparison(context);
+
+        // return the wrapped section creator
+        return new SectionCreator<Song>(context, songLoader, songComparison);
+    }
+
+
+    @Override
+    public int getLoaderId() {
+        return PagerAdapter.MusicFragments.SONG.ordinal();
+    }
+
+    /**
+     * Scrolls the list to the currently playing song when the user touches the
+     * header in the {@link TitlePageIndicator}.
+     */
+    public void scrollToCurrentSong() {
+        final int currentSongPosition = getItemPositionBySong();
+
+        if (currentSongPosition != 0) {
+            mListView.setSelection(currentSongPosition);
+        }
+    }
+
+    /**
+     * @return The position of an item in the list based on the name of the
+     * currently playing song.
+     */
+    private int getItemPositionBySong() {
+        final long trackId = MusicUtils.getCurrentAudioId();
+        if (mAdapter == null) {
+            return 0;
+        }
+
+        int position = mAdapter.getItemPosition(trackId);
+
+        // if for some reason we don't find the item, just jump to the top
+        if (position < 0) {
+            return 0;
+        }
+
+        return position;
+    }
+
+    @Override
+    public LoaderManager getFragmentLoaderManager() {
+        return getParentFragment().getLoaderManager();
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/phone/MusicBrowserFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/phone/MusicBrowserFragment.java
new file mode 100755
index 0000000000..20df383cf9
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/phone/MusicBrowserFragment.java
@@ -0,0 +1,43 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments.phone;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+
+/**
+ * This class is used for fragments under the {@link MusicBrowserFragment}
+ * Even though the containing view pager creates all the fragments, the loader
+ * does not load complete until the user navigates to that page.  To get around this
+ * we will use the containing fragment's loader manager
+ */
+public abstract class MusicBrowserFragment extends Fragment {
+    public abstract int getLoaderId();
+
+    public LoaderManager getContainingLoaderManager() {
+        return getParentFragment().getLoaderManager();
+    }
+
+    protected void initLoader(Bundle args, LoaderCallbacks<? extends Object> callback) {
+        getContainingLoaderManager().initLoader(getLoaderId(), args, callback);
+    }
+
+    protected void restartLoader(Bundle args, LoaderCallbacks<? extends Object> callback) {
+        getContainingLoaderManager().restartLoader(getLoaderId(), args, callback);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/phone/MusicBrowserPhoneFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/phone/MusicBrowserPhoneFragment.java
new file mode 100755
index 0000000000..fae4fcf954
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/phone/MusicBrowserPhoneFragment.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments.phone;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v4.view.ViewPager;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.PagerAdapter;
+import com.dolzzo.twelve.adapters.PagerAdapter.MusicFragments;
+import com.dolzzo.twelve.menu.CreateNewPlaylist;
+import com.dolzzo.twelve.ui.fragments.AlbumFragment;
+import com.dolzzo.twelve.ui.fragments.ArtistFragment;
+import com.dolzzo.twelve.ui.fragments.BaseFragment;
+import com.dolzzo.twelve.ui.fragments.SongFragment;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PreferenceUtils;
+import com.dolzzo.twelve.utils.SortOrder;
+import com.dolzzo.twelve.widgets.ViewPagerTabs;
+
+/**
+ * This class is used to hold the {@link ViewPager} used for swiping between the
+ * playlists, recent, artists, albums, songs, and genre {@link Fragment}
+ * s for phones.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ * @NOTE: The reason the sort orders are taken care of in this fragment rather
+ * than the individual fragments is to keep from showing all of the menu
+ * items on tablet interfaces. That being said, I have a tablet interface
+ * worked out, but I'm going to keep it in the Play Store version of
+ * Apollo for a couple of weeks or so before merging it with CM.
+ */
+public class MusicBrowserPhoneFragment extends BaseFragment {
+    public static final int INVALID_PAGE_INDEX = -1;
+
+    /**
+     * Pager
+     */
+    private ViewPager mViewPager;
+
+    /**
+     * VP's adapter
+     */
+    private PagerAdapter mPagerAdapter;
+
+    private PreferenceUtils mPreferences;
+
+    /**
+     * A pre-defined page index to navigate to
+     */
+    private int mDefaultPageIdx = INVALID_PAGE_INDEX;
+
+    /**
+     * Empty constructor as per the {@link Fragment} documentation
+     */
+    public MusicBrowserPhoneFragment() {
+    }
+
+    @Override
+    protected int getLayoutToInflate() {
+        return R.layout.fragment_music_browser_phone;
+    }
+
+    @Override
+    protected String getTitle() {
+        return getString(R.string.app_name);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        // Get the preferences
+        mPreferences = PreferenceUtils.getInstance(getActivity());
+    }
+
+    @Override
+    protected void onViewCreated() {
+        super.onViewCreated();
+
+        // create the adapter - on rotation the view gets created again and we need to recreate
+        // the child fragments (fragments of fragments cannot be retained)
+        mPagerAdapter = new PagerAdapter(getActivity(), getChildFragmentManager());
+        final MusicFragments[] mFragments = MusicFragments.values();
+        for (final MusicFragments mFragment : mFragments) {
+            mPagerAdapter.add(mFragment.getFragmentClass(), null);
+        }
+
+        // Initialize the ViewPager
+        mViewPager = (ViewPager) mRootView.findViewById(R.id.fragment_home_phone_pager);
+        // Attch the adapter
+        mViewPager.setAdapter(mPagerAdapter);
+        // Offscreen pager loading limit
+        mViewPager.setOffscreenPageLimit(mPagerAdapter.getCount() - 1);
+
+        // Initialize the tab strip
+        final ViewPagerTabs tabs = (ViewPagerTabs)
+                mRootView.findViewById(R.id.fragment_home_phone_pager_titles);
+        // Attach the ViewPager
+        tabs.setViewPager(mViewPager);
+        mViewPager.setOnPageChangeListener(tabs);
+
+        if (mDefaultPageIdx != INVALID_PAGE_INDEX) {
+            navigateToPage(mDefaultPageIdx);
+        } else {
+            // Start on the last page the user was on
+            navigateToPage(mPreferences.getStartPage());
+        }
+    }
+
+    public void setDefaultPageIdx(final int pageIdx) {
+        mDefaultPageIdx = pageIdx;
+        navigateToPage(mDefaultPageIdx);
+    }
+
+    private void navigateToPage(final int idx) {
+        // this may be called before the view is created, so do a check for mViewPager
+        if (idx != INVALID_PAGE_INDEX && mViewPager != null) {
+            mViewPager.setCurrentItem(idx);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        // Enable the options menu
+        setHasOptionsMenu(true);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onPause() {
+        super.onPause();
+        // Save the last page the use was on
+        mPreferences.setStartPage(mViewPager.getCurrentItem());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onPrepareOptionsMenu(final Menu menu) {
+        super.onPrepareOptionsMenu(menu);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {
+        super.onCreateOptionsMenu(menu, inflater);
+
+        inflater.inflate(R.menu.shuffle_all, menu); // Shuffle all
+        if (isArtistPage()) {
+            inflater.inflate(R.menu.artist_sort_by, menu);
+        } else if (isAlbumPage()) {
+            inflater.inflate(R.menu.album_sort_by, menu);
+        } else if (isSongPage()) {
+            inflater.inflate(R.menu.song_sort_by, menu);
+        } else if (isPlaylistPage()) {
+            inflater.inflate(R.menu.new_playlist, menu);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onOptionsItemSelected(final MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.menu_shuffle_all:
+                // Shuffle all the songs
+                MusicUtils.shuffleAll(getActivity());
+                return true;
+            case R.id.menu_sort_by_az:
+                if (isArtistPage()) {
+                    mPreferences.setArtistSortOrder(SortOrder.ArtistSortOrder.ARTIST_A_Z);
+                    getArtistFragment().refresh();
+                } else if (isAlbumPage()) {
+                    mPreferences.setAlbumSortOrder(SortOrder.AlbumSortOrder.ALBUM_A_Z);
+                    getAlbumFragment().refresh();
+                } else if (isSongPage()) {
+                    mPreferences.setSongSortOrder(SortOrder.SongSortOrder.SONG_A_Z);
+                    getSongFragment().refresh();
+                }
+                return true;
+            case R.id.menu_sort_by_za:
+                if (isArtistPage()) {
+                    mPreferences.setArtistSortOrder(SortOrder.ArtistSortOrder.ARTIST_Z_A);
+                    getArtistFragment().refresh();
+                } else if (isAlbumPage()) {
+                    mPreferences.setAlbumSortOrder(SortOrder.AlbumSortOrder.ALBUM_Z_A);
+                    getAlbumFragment().refresh();
+                } else if (isSongPage()) {
+                    mPreferences.setSongSortOrder(SortOrder.SongSortOrder.SONG_Z_A);
+                    getSongFragment().refresh();
+                }
+                return true;
+            case R.id.menu_sort_by_artist:
+                if (isAlbumPage()) {
+                    mPreferences.setAlbumSortOrder(SortOrder.AlbumSortOrder.ALBUM_ARTIST);
+                    getAlbumFragment().refresh();
+                } else if (isSongPage()) {
+                    mPreferences.setSongSortOrder(SortOrder.SongSortOrder.SONG_ARTIST);
+                    getSongFragment().refresh();
+                }
+                return true;
+            case R.id.menu_sort_by_album:
+                if (isSongPage()) {
+                    mPreferences.setSongSortOrder(SortOrder.SongSortOrder.SONG_ALBUM);
+                    getSongFragment().refresh();
+                }
+                return true;
+            case R.id.menu_sort_by_year:
+                if (isAlbumPage()) {
+                    mPreferences.setAlbumSortOrder(SortOrder.AlbumSortOrder.ALBUM_YEAR);
+                    getAlbumFragment().refresh();
+                } else if (isSongPage()) {
+                    mPreferences.setSongSortOrder(SortOrder.SongSortOrder.SONG_YEAR);
+                    getSongFragment().refresh();
+                }
+                return true;
+            case R.id.menu_sort_by_duration:
+                if (isSongPage()) {
+                    mPreferences.setSongSortOrder(SortOrder.SongSortOrder.SONG_DURATION);
+                    getSongFragment().refresh();
+                }
+                return true;
+            case R.id.menu_sort_by_number_of_songs:
+                if (isArtistPage()) {
+                    mPreferences
+                            .setArtistSortOrder(SortOrder.ArtistSortOrder.ARTIST_NUMBER_OF_SONGS);
+                    getArtistFragment().refresh();
+                } else if (isAlbumPage()) {
+                    mPreferences.setAlbumSortOrder(SortOrder.AlbumSortOrder.ALBUM_NUMBER_OF_SONGS);
+                    getAlbumFragment().refresh();
+                }
+                return true;
+            case R.id.menu_sort_by_number_of_albums:
+                if (isArtistPage()) {
+                    mPreferences
+                            .setArtistSortOrder(SortOrder.ArtistSortOrder.ARTIST_NUMBER_OF_ALBUMS);
+                    getArtistFragment().refresh();
+                }
+                return true;
+            case R.id.menu_sort_by_filename:
+                if (isSongPage()) {
+                    mPreferences.setSongSortOrder(SortOrder.SongSortOrder.SONG_FILENAME);
+                    getSongFragment().refresh();
+                }
+                return true;
+            case R.id.menu_new_playlist:
+                if (isPlaylistPage()) {
+                    CreateNewPlaylist.getInstance(new long[0]).show(getFragmentManager(), "CreatePlaylist");
+                }
+                return true;
+            default:
+                break;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    protected boolean needsElevatedActionBar() {
+        // our view pager already has elevation
+        return false;
+    }
+
+    private boolean isArtistPage() {
+        return mViewPager.getCurrentItem() == MusicFragments.ARTIST.ordinal();
+    }
+
+    public ArtistFragment getArtistFragment() {
+        return (ArtistFragment) mPagerAdapter.getFragment(MusicFragments.ARTIST.ordinal());
+    }
+
+    private boolean isAlbumPage() {
+        return mViewPager.getCurrentItem() == MusicFragments.ALBUM.ordinal();
+    }
+
+    public AlbumFragment getAlbumFragment() {
+        return (AlbumFragment) mPagerAdapter.getFragment(MusicFragments.ALBUM.ordinal());
+    }
+
+    private boolean isSongPage() {
+        return mViewPager.getCurrentItem() == MusicFragments.SONG.ordinal();
+    }
+
+    public SongFragment getSongFragment() {
+        return (SongFragment) mPagerAdapter.getFragment(MusicFragments.SONG.ordinal());
+    }
+
+    @Override
+    public void restartLoader() {
+        // do nothing
+    }
+
+    private boolean isPlaylistPage() {
+        return mViewPager.getCurrentItem() == MusicFragments.PLAYLIST.ordinal();
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/BasicSongFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/BasicSongFragment.java
new file mode 100755
index 0000000000..1a7dd2bfb3
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/BasicSongFragment.java
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments.profile;
+
+import android.os.Bundle;
+import android.os.SystemClock;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.Loader;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AbsListView;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ListView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.MusicStateListener;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.SongAdapter;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.recycler.RecycleHolder;
+import com.dolzzo.twelve.sectionadapter.SectionAdapter;
+import com.dolzzo.twelve.sectionadapter.SectionListContainer;
+import com.dolzzo.twelve.service.MusicPlaybackTrack;
+import com.dolzzo.twelve.ui.activities.BaseActivity;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.utils.SongPopupMenuHelper;
+import com.dolzzo.twelve.widgets.IPopupMenuCallback;
+import com.dolzzo.twelve.widgets.LoadingEmptyContainer;
+import com.dolzzo.twelve.widgets.NoResultsContainer;
+
+import java.util.TreeSet;
+
+/**
+ * This class is used to display all of the songs
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public abstract class BasicSongFragment extends Fragment implements
+        LoaderCallbacks<SectionListContainer<Song>>, OnItemClickListener, MusicStateListener {
+
+    /**
+     * Fragment UI
+     */
+    protected ViewGroup mRootView;
+
+    /**
+     * The adapter for the list
+     */
+    protected SectionAdapter<Song, SongAdapter> mAdapter;
+
+    /**
+     * The list view
+     */
+    protected ListView mListView;
+
+    /**
+     * Pop up menu helper
+     */
+    protected PopupMenuHelper mPopupMenuHelper;
+
+    /**
+     * This holds the loading progress bar as well as the no results message
+     */
+    protected LoadingEmptyContainer mLoadingEmptyContainer;
+
+    /**
+     * Empty constructor as per the {@link Fragment} documentation
+     */
+    public BasicSongFragment() {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onCreate(final Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mPopupMenuHelper = new SongPopupMenuHelper(getActivity(), getFragmentManager()) {
+            @Override
+            public Song getSong(int position) {
+                return mAdapter.getTItem(position);
+            }
+
+            @Override
+            protected long getSourceId() {
+                return getFragmentSourceId();
+            }
+
+            @Override
+            protected Config.IdType getSourceType() {
+                return getFragmentSourceType();
+            }
+
+            @Override
+            protected void updateMenuIds(PopupMenuType type, TreeSet<Integer> set) {
+                super.updateMenuIds(type, set);
+                BasicSongFragment.this.updateMenuIds(set);
+            }
+        };
+
+        // Create the adapter
+        mAdapter = new SectionAdapter<Song, SongAdapter>(getActivity(), createAdapter());
+        mAdapter.setPopupMenuClickedListener(new IPopupMenuCallback.IListener() {
+            @Override
+            public void onPopupMenuClicked(View v, int position) {
+                mPopupMenuHelper.showPopupMenu(v, position);
+            }
+        });
+    }
+
+    protected long getFragmentSourceId() {
+        return -1;
+    }
+
+    protected Config.IdType getFragmentSourceType() {
+        return Config.IdType.NA;
+    }
+
+    protected void updateMenuIds(TreeSet<Integer> set) {
+        // do nothing - let subclasses override
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View onCreateView(final LayoutInflater inflater, final ViewGroup container,
+                             final Bundle savedInstanceState) {
+        // The View for the fragment's UI
+        mRootView = (ViewGroup) inflater.inflate(R.layout.list_base, null);
+        // set the background on the root view
+        mRootView.setBackgroundColor(getResources().getColor(R.color.background_color));
+        // Initialize the list
+        mListView = (ListView) mRootView.findViewById(R.id.list_base);
+        // Set the data behind the list
+        mListView.setAdapter(mAdapter);
+        // Release any references to the recycled Views
+        mListView.setRecyclerListener(new RecycleHolder());
+        // Play the selected song
+        mListView.setOnItemClickListener(this);
+        // To help make scrolling smooth
+        mListView.setOnScrollListener(new AbsListView.OnScrollListener() {
+            @Override
+            public void onScrollStateChanged(AbsListView view, int scrollState) {
+                // Pause disk cache access to ensure smoother scrolling
+                if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_FLING) {
+                    mAdapter.getUnderlyingAdapter().setPauseDiskCache(true);
+                } else {
+                    mAdapter.getUnderlyingAdapter().setPauseDiskCache(false);
+                    mAdapter.notifyDataSetChanged();
+                }
+            }
+
+            @Override
+            public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
+
+            }
+        });
+
+        // Show progress bar
+        mLoadingEmptyContainer = (LoadingEmptyContainer) mRootView.findViewById(R.id.loading_empty_container);
+        // Setup the container strings
+        setupNoResultsContainer(mLoadingEmptyContainer.getNoResultsContainer());
+        mListView.setEmptyView(mLoadingEmptyContainer);
+
+        // Register the music status listener
+        ((BaseActivity) getActivity()).setMusicStateListenerListener(this);
+
+        return mRootView;
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+
+        ((BaseActivity) getActivity()).removeMusicStateListenerListener(this);
+    }
+
+    /**
+     * This allows subclasses to customize the look and feel of the no results container
+     *
+     * @param empty NoResultsContainer class
+     */
+    public void setupNoResultsContainer(final NoResultsContainer empty) {
+        // do nothing
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onActivityCreated(final Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        // Start the loader
+        getFragmentLoaderManager().initLoader(getLoaderId(), null, this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onItemClick(final AdapterView<?> parent, final View view, final int position,
+                            final long id) {
+        playAll(position);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoadFinished(final Loader<SectionListContainer<Song>> loader,
+                               final SectionListContainer<Song> data) {
+        if (data.mListResults.isEmpty()) {
+            mAdapter.unload();
+            mLoadingEmptyContainer.showNoResults();
+            return;
+        }
+
+        mAdapter.setData(data);
+    }
+
+    /**
+     * @return Gets the list of song ids from the adapter, or null if none
+     */
+    protected long[] getSongIdsFromAdapter() {
+        if (mAdapter != null) {
+            final SongAdapter adapter = mAdapter.getUnderlyingAdapter();
+            if (adapter != null) {
+                return adapter.getSongIds();
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Restarts the loader.
+     */
+    public void refresh() {
+        // Wait a moment for the preference to change.
+        SystemClock.sleep(10);
+        restartLoader();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void restartLoader() {
+        // Update the list when the user deletes any items
+        getFragmentLoaderManager().restartLoader(getLoaderId(), null, this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLoaderReset(final Loader<SectionListContainer<Song>> loader) {
+        // Clear the data in the adapter
+        mAdapter.unload();
+    }
+
+    /**
+     * If the subclasses want to use a customized SongAdapter they can override this method
+     *
+     * @return the Song adapter
+     */
+    protected SongAdapter createAdapter() {
+        return new SongAdapter(
+                getActivity(),
+                R.layout.list_item_normal,
+                getFragmentSourceId(),
+                getFragmentSourceType()
+        );
+    }
+
+    /**
+     * Allow subclasses to specify a different loader manager
+     *
+     * @return Loader Manager to use
+     */
+    public LoaderManager getFragmentLoaderManager() {
+        return getLoaderManager();
+    }
+
+    @Override
+    public void onMetaChanged() {
+        MusicPlaybackTrack currentTrack = MusicUtils.getCurrentTrack();
+        if (mAdapter.getUnderlyingAdapter().setCurrentlyPlayingTrack(currentTrack)) {
+            mAdapter.notifyDataSetChanged();
+        }
+    }
+
+    @Override
+    public void onPlaylistChanged() {
+        // Nothing to do
+    }
+
+    /**
+     * LoaderCallbacks identifier
+     */
+    public abstract int getLoaderId();
+
+    /**
+     * If the user clisk play all
+     *
+     * @param position the position of the item clicked or -1 if shuffle all
+     */
+    public abstract void playAll(int position);
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/LastAddedFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/LastAddedFragment.java
new file mode 100755
index 0000000000..b941decdc4
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/LastAddedFragment.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments.profile;
+
+import android.os.Bundle;
+import android.support.v4.content.Loader;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.Config.SmartPlaylistType;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.loaders.LastAddedLoader;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.sectionadapter.SectionListContainer;
+import com.dolzzo.twelve.ui.activities.BaseActivity;
+import com.dolzzo.twelve.ui.fragments.ISetupActionBar;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.NoResultsContainer;
+
+/**
+ * This class is used to display all of the songs the user put on their device
+ * within the last four weeks.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class LastAddedFragment extends SmartPlaylistFragment implements ISetupActionBar {
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Loader<SectionListContainer<Song>> onCreateLoader(final int id, final Bundle args) {
+        // show the loading progress bar
+        mLoadingEmptyContainer.showLoading();
+
+        LastAddedLoader loader = new LastAddedLoader(getActivity());
+        return new SectionCreator<Song>(getActivity(), loader, null);
+    }
+
+    @Override
+    public void setupNoResultsContainer(NoResultsContainer empty) {
+        super.setupNoResultsContainer(empty);
+
+        empty.setMainText(R.string.empty_last_added_main);
+        empty.setSecondaryText(R.string.empty_last_added);
+    }
+
+    @Override
+    public final View onCreateView(LayoutInflater inflater, ViewGroup container,
+                                   Bundle savedInstanceState) {
+        setupActionBar();
+        return super.onCreateView(inflater, container, savedInstanceState);
+    }
+
+    @Override
+    public void setupActionBar() {
+        ((BaseActivity) getActivity()).setupActionBar(R.string.playlist_last_added);
+        ((BaseActivity) getActivity()).setActionBarElevation(true);
+    }
+
+    @Override
+    protected long getFragmentSourceId() {
+        return Config.SmartPlaylistType.LastAdded.mId;
+    }
+
+    protected SmartPlaylistType getSmartPlaylistType() {
+        return Config.SmartPlaylistType.LastAdded;
+    }
+
+    @Override
+    protected int getShuffleTitleId() {
+        return R.string.menu_shuffle_last_added;
+    }
+
+    @Override
+    protected int getClearTitleId() {
+        return R.string.clear_last_added;
+    }
+
+    @Override
+    protected void clearList() {
+        MusicUtils.clearLastAdded(getActivity());
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/SmartPlaylistFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/SmartPlaylistFragment.java
new file mode 100755
index 0000000000..25cadc3fa1
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/SmartPlaylistFragment.java
@@ -0,0 +1,152 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.ui.fragments.profile;
+
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.Config.SmartPlaylistType;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.PagerAdapter;
+import com.dolzzo.twelve.menu.ConfirmDialog;
+import com.dolzzo.twelve.model.Playlist;
+import com.dolzzo.twelve.ui.fragments.IChildFragment;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.utils.PlaylistPopupMenuHelper;
+import com.dolzzo.twelve.utils.PopupMenuHelper;
+import com.dolzzo.twelve.utils.PopupMenuHelper.PopupMenuType;
+
+public abstract class SmartPlaylistFragment extends BasicSongFragment
+        implements ConfirmDialog.ConfirmCallback, IChildFragment {
+    /**
+     * LoaderCallbacks identifier
+     */
+    private static final int LOADER = 0;
+    private static final int CLEAR_REQUEST = 1;
+    private PopupMenuHelper mActionMenuHelper;
+
+    @Override
+    public int getLoaderId() {
+        return LOADER;
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+                             Bundle savedInstanceState) {
+        setHasOptionsMenu(true);
+        return super.onCreateView(inflater, container, savedInstanceState);
+    }
+
+    @Override
+    protected Config.IdType getFragmentSourceType() {
+        return Config.IdType.Playlist;
+    }
+
+    @Override
+    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {
+        inflater.inflate(R.menu.shuffle_item, menu);
+        menu.findItem(R.id.menu_shuffle_item).setTitle(getShuffleTitleId());
+
+        // use the same popup menu to provide actions for smart playlist
+        // as is used in the PlaylistFragment
+        mActionMenuHelper = new PlaylistPopupMenuHelper(
+                getActivity(), getChildFragmentManager(), PopupMenuType.SmartPlaylist) {
+            public Playlist getPlaylist(int position) {
+                SmartPlaylistType type = getSmartPlaylistType();
+                return new Playlist(type.mId, getString(type.mTitleId), 0);
+            }
+        };
+        mActionMenuHelper.onPreparePopupMenu(0);
+        mActionMenuHelper.createPopupMenu(menu);
+
+        inflater.inflate(R.menu.clear_list, menu);
+        super.onCreateOptionsMenu(menu, inflater);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(final MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.menu_shuffle_item:
+                playAll(-1, true);
+                return true;
+            case R.id.clear_list:
+                ConfirmDialog.show(
+                        this, CLEAR_REQUEST, getClearTitleId(), R.string.clear);
+                return true;
+            default:
+                if (mActionMenuHelper.onMenuItemClick(item)) {
+                    return true;
+                }
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public void confirmOk(int requestCode) {
+        if (requestCode == CLEAR_REQUEST) {
+            mAdapter.unload();
+            clearList();
+            restartLoader();
+        }
+    }
+
+    @Override
+    public void playAll(int position) {
+        playAll(position, false);
+    }
+
+    public void playAll(int position, boolean shuffle) {
+        // we grab the song ids from the adapter instead of querying the cursor because the user
+        // expects what they see to be what they play.  The counter argument of updating the list
+        // could be made, but refreshing the smart playlists so often will be annoying and
+        // confusing for the user so this is an intermediate compromise.  An example is the top
+        // tracks list is based on the # of times you play a song, but near the beginning each
+        // song being played will change the list and the compromise is to update only when you
+        // enter the page.
+        long[] songIds = getSongIdsFromAdapter();
+        if (songIds != null) {
+            MusicUtils.playAll(getActivity(), songIds, position, getSmartPlaylistType().mId,
+                    Config.IdType.Playlist, shuffle);
+        }
+    }
+
+    public PagerAdapter.MusicFragments getMusicFragmentParent() {
+        return PagerAdapter.MusicFragments.PLAYLIST;
+    }
+
+    protected abstract SmartPlaylistType getSmartPlaylistType();
+
+    /**
+     * text for menu item that shuffles items in this playlist
+     */
+    protected abstract int getShuffleTitleId();
+
+    /**
+     * text for confirmation dialog that clears this playlist
+     */
+    protected abstract int getClearTitleId();
+
+    /**
+     * action that clears this playlist
+     */
+    protected abstract void clearList();
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/TopTracksFragment.java b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/TopTracksFragment.java
new file mode 100755
index 0000000000..491319ae83
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/ui/fragments/profile/TopTracksFragment.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.ui.fragments.profile;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.support.v4.content.Loader;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.Config.SmartPlaylistType;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.adapters.SongAdapter;
+import com.dolzzo.twelve.loaders.TopTracksLoader;
+import com.dolzzo.twelve.model.Song;
+import com.dolzzo.twelve.sectionadapter.SectionCreator;
+import com.dolzzo.twelve.sectionadapter.SectionListContainer;
+import com.dolzzo.twelve.ui.activities.BaseActivity;
+import com.dolzzo.twelve.ui.fragments.ISetupActionBar;
+import com.dolzzo.twelve.utils.MusicUtils;
+import com.dolzzo.twelve.widgets.NoResultsContainer;
+
+/**
+ * This class is used to display all of the songs the user put on their device
+ * within the last four weeks.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class TopTracksFragment extends SmartPlaylistFragment
+        implements ISetupActionBar {
+
+    @Override
+    protected SmartPlaylistType getSmartPlaylistType() {
+        return Config.SmartPlaylistType.TopTracks;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Loader<SectionListContainer<Song>> onCreateLoader(final int id, final Bundle args) {
+        // show the loading progress bar
+        mLoadingEmptyContainer.showLoading();
+
+        TopTracksLoader loader = new TopTracksLoader(getActivity(),
+                TopTracksLoader.QueryType.TopTracks);
+        return new SectionCreator<Song>(getActivity(), loader, null);
+    }
+
+    @Override
+    protected SongAdapter createAdapter() {
+        return new TopTracksAdapter(
+                getActivity(),
+                R.layout.list_item_top_tracks
+        );
+    }
+
+    @Override
+    public final View onCreateView(LayoutInflater inflater, ViewGroup container,
+                                   Bundle savedInstanceState) {
+        setupActionBar();
+        return super.onCreateView(inflater, container, savedInstanceState);
+    }
+
+    public void setupActionBar() {
+        ((BaseActivity) getActivity()).setupActionBar(R.string.playlist_top_tracks);
+        ((BaseActivity) getActivity()).setActionBarElevation(true);
+    }
+
+    @Override
+    public void setupNoResultsContainer(NoResultsContainer empty) {
+        super.setupNoResultsContainer(empty);
+
+        empty.setMainText(R.string.empty_top_tracks_main);
+        empty.setSecondaryText(R.string.empty_top_tracks_secondary);
+    }
+
+    @Override
+    protected long getFragmentSourceId() {
+        return Config.SmartPlaylistType.TopTracks.mId;
+    }
+
+    protected int getShuffleTitleId() {
+        return R.string.menu_shuffle_top_tracks;
+    }
+
+    @Override
+    protected int getClearTitleId() {
+        return R.string.clear_top_tracks_title;
+    }
+
+    @Override
+    protected void clearList() {
+        MusicUtils.clearTopTracks(getActivity());
+    }
+
+    public class TopTracksAdapter extends SongAdapter {
+        public TopTracksAdapter(final Activity context, final int layoutId) {
+            super(context, layoutId, getFragmentSourceId(), getFragmentSourceType());
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            View view = super.getView(position, convertView, parent);
+            TextView positionText = (TextView) view.findViewById(R.id.position_number);
+            positionText.setText(String.valueOf(position + 1));
+            return view;
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/AlbumPopupMenuHelper.java b/twelve/src/main/java/com/dolzzo/twelve/utils/AlbumPopupMenuHelper.java
new file mode 100755
index 0000000000..2016d0b546
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/AlbumPopupMenuHelper.java
@@ -0,0 +1,108 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.utils;
+
+import android.app.Activity;
+import android.provider.MediaStore;
+import android.support.v4.app.FragmentManager;
+import android.view.MenuItem;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.menu.DeleteDialog;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.menu.PhotoSelectionDialog;
+import com.dolzzo.twelve.model.Album;
+
+import java.util.TreeSet;
+
+public abstract class AlbumPopupMenuHelper extends PopupMenuHelper {
+    protected Album mAlbum;
+
+    public AlbumPopupMenuHelper(Activity activity, FragmentManager fragmentManager) {
+        super(activity, fragmentManager);
+        mType = PopupMenuType.Album;
+    }
+
+    public abstract Album getAlbum(int position);
+
+    @Override
+    public PopupMenuType onPreparePopupMenu(int position) {
+        mAlbum = getAlbum(position);
+
+        if (mAlbum == null) {
+            return null;
+        }
+
+        return PopupMenuType.Album;
+    }
+
+    @Override
+    protected long[] getIdList() {
+        return MusicUtils.getSongListForAlbum(mActivity, mAlbum.mAlbumId);
+    }
+
+    @Override
+    protected long getSourceId() {
+        return mAlbum.mAlbumId;
+    }
+
+    @Override
+    protected Config.IdType getSourceType() {
+        return Config.IdType.Album;
+    }
+
+    @Override
+    protected void onDeleteClicked() {
+        final String album = mAlbum.mAlbumName;
+        DeleteDialog.newInstance(album, getIdList(),
+                ImageFetcher.generateAlbumCacheKey(album, mAlbum.mArtistName))
+                .show(mFragmentManager, "DeleteDialog");
+    }
+
+    @Override
+    protected String getArtistName() {
+        return mAlbum.mArtistName;
+    }
+
+    @Override
+    public boolean onMenuItemClick(MenuItem item) {
+        boolean handled = super.onMenuItemClick(item);
+        if (!handled && item.getGroupId() == getGroupId()) {
+            switch (item.getItemId()) {
+                case FragmentMenuItems.CHANGE_IMAGE:
+                    String key = ImageFetcher.generateAlbumCacheKey(mAlbum.mAlbumName,
+                            getArtistName());
+                    PhotoSelectionDialog.newInstance(mAlbum.mAlbumName,
+                            PhotoSelectionDialog.ProfileType.ALBUM, key)
+                            .show(mFragmentManager, "PhotoSelectionDialog");
+                    return true;
+            }
+        }
+
+        return handled;
+    }
+
+    @Override
+    protected void updateMenuIds(PopupMenuType type, TreeSet<Integer> set) {
+        super.updateMenuIds(type, set);
+
+        // Don't show more by artist if it is an unknown artist
+        if (MediaStore.UNKNOWN_STRING.equals(mAlbum.mArtistName)) {
+            set.remove(FragmentMenuItems.MORE_BY_ARTIST);
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/ApolloUtils.java b/twelve/src/main/java/com/dolzzo/twelve/utils/ApolloUtils.java
new file mode 100755
index 0000000000..02fc2f4892
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/ApolloUtils.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.utils;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.database.Cursor;
+import android.graphics.Color;
+import android.graphics.Rect;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.provider.BaseColumns;
+import android.provider.MediaStore;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewTreeObserver.OnGlobalLayoutListener;
+import android.widget.Toast;
+
+import com.dolzzo.twelve.cache.ImageCache;
+import com.dolzzo.twelve.cache.ImageFetcher;
+
+import java.util.concurrent.RejectedExecutionHandler;
+import java.util.concurrent.ThreadPoolExecutor;
+
+/**
+ * Mostly general and UI helpers.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public final class ApolloUtils {
+
+    /**
+     * The threshold used calculate if a color is light or dark
+     */
+    private static final int BRIGHTNESS_THRESHOLD = 130;
+
+    static {
+        ((ThreadPoolExecutor) AsyncTask.THREAD_POOL_EXECUTOR).setRejectedExecutionHandler(
+                new PurgePolicy()
+        );
+    }
+
+    ;
+
+    /* This class is never initiated */
+    public ApolloUtils() {
+    }
+
+    /**
+     * Used to determine if the device is a tablet or not
+     *
+     * @param context The {@link Context} to use.
+     * @return True if the device is a tablet, false otherwise.
+     */
+    public static final boolean isTablet(final Context context) {
+        final int layout = context.getResources().getConfiguration().screenLayout;
+        return (layout & Configuration.SCREENLAYOUT_SIZE_MASK) >= Configuration.SCREENLAYOUT_SIZE_LARGE;
+    }
+
+    /**
+     * Used to determine if the device is currently in landscape mode
+     *
+     * @param context The {@link Context} to use.
+     * @return True if the device is in landscape mode, false otherwise.
+     */
+    public static final boolean isLandscape(final Context context) {
+        final int orientation = context.getResources().getConfiguration().orientation;
+        return orientation == Configuration.ORIENTATION_LANDSCAPE;
+    }
+
+    /**
+     * Execute an {@link AsyncTask} on a thread pool
+     *
+     * @param forceSerial True to force the task to run in serial order
+     * @param task        Task to execute
+     * @param args        Optional arguments to pass to
+     *                    {@link AsyncTask#execute(Object[])}
+     * @param <T>         Task argument type
+     */
+    @SuppressLint("NewApi")
+    public static <T> void execute(final boolean forceSerial, final AsyncTask<T, ?, ?> task,
+                                   final T... args) {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.DONUT) {
+            throw new UnsupportedOperationException(
+                    "This class can only be used on API 4 and newer.");
+        }
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB || forceSerial) {
+            task.execute(args);
+        } else {
+            task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, args);
+        }
+    }
+
+    /**
+     * Used to determine if there is an active data connection and what type of
+     * connection it is if there is one
+     *
+     * @param context The {@link Context} to use
+     * @return True if there is an active data connection, false otherwise.
+     * Also, if the user has checked to only download via Wi-Fi in the
+     * settings, the mobile data and other network connections aren't
+     * returned at all
+     */
+    public static final boolean isOnline(final Context context) {
+        /*
+         * This sort of handles a sudden configuration change, but I think it
+         * should be dealt with in a more professional way.
+         */
+        if (context == null) {
+            return false;
+        }
+
+        boolean state = false;
+        final boolean onlyOnWifi = PreferenceUtils.getInstance(context).onlyOnWifi();
+
+        /* Monitor network connections */
+        final ConnectivityManager connectivityManager = (ConnectivityManager) context
+                .getSystemService(Context.CONNECTIVITY_SERVICE);
+
+        /* Wi-Fi connection */
+        final NetworkInfo wifiNetwork = connectivityManager
+                .getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+        if (wifiNetwork != null) {
+            state = wifiNetwork.isConnectedOrConnecting();
+        }
+
+        /* Mobile data connection */
+        final NetworkInfo mbobileNetwork = connectivityManager
+                .getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
+        if (mbobileNetwork != null) {
+            if (!onlyOnWifi) {
+                state = mbobileNetwork.isConnectedOrConnecting();
+            }
+        }
+
+        /* Other networks */
+        final NetworkInfo activeNetwork = connectivityManager.getActiveNetworkInfo();
+        if (activeNetwork != null) {
+            if (!onlyOnWifi) {
+                state = activeNetwork.isConnectedOrConnecting();
+            }
+        }
+
+        return state;
+    }
+
+    /**
+     * Display a {@link Toast} letting the user know what an item does when long
+     * pressed.
+     *
+     * @param view The {@link View} to copy the content description from.
+     */
+    public static void showCheatSheet(final View view) {
+
+        final int[] screenPos = new int[2]; // origin is device display
+        final Rect displayFrame = new Rect(); // includes decorations (e.g.
+        // status bar)
+        view.getLocationOnScreen(screenPos);
+        view.getWindowVisibleDisplayFrame(displayFrame);
+
+        final Context context = view.getContext();
+        final int viewWidth = view.getWidth();
+        final int viewHeight = view.getHeight();
+        final int viewCenterX = screenPos[0] + viewWidth / 2;
+        final int screenWidth = context.getResources().getDisplayMetrics().widthPixels;
+        final int estimatedToastHeight = (int) (48 * context.getResources().getDisplayMetrics().density);
+
+        final Toast cheatSheet = Toast.makeText(context, view.getContentDescription(),
+                Toast.LENGTH_SHORT);
+        final boolean showBelow = screenPos[1] < estimatedToastHeight;
+        if (showBelow) {
+            // Show below
+            // Offsets are after decorations (e.g. status bar) are factored in
+            cheatSheet.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL, viewCenterX
+                    - screenWidth / 2, screenPos[1] - displayFrame.top + viewHeight);
+        } else {
+            // Show above
+            // Offsets are after decorations (e.g. status bar) are factored in
+            cheatSheet.setGravity(Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL, viewCenterX
+                    - screenWidth / 2, displayFrame.bottom - screenPos[1]);
+        }
+        cheatSheet.show();
+    }
+
+    /**
+     * Calculate whether a color is light or dark, based on a commonly known
+     * brightness formula.
+     *
+     * @see {@literal http://en.wikipedia.org/wiki/HSV_color_space%23Lightness}
+     */
+    public static final boolean isColorDark(final int color) {
+        return (30 * Color.red(color) + 59 * Color.green(color) + 11 * Color.blue(color)) / 100 <= BRIGHTNESS_THRESHOLD;
+    }
+
+    /**
+     * Runs a piece of code after the next layout run
+     *
+     * @param view     The {@link View} used.
+     * @param runnable The {@link Runnable} used after the next layout run
+     */
+    @SuppressLint("NewApi")
+    public static void doAfterLayout(final View view, final Runnable runnable) {
+        final OnGlobalLayoutListener listener = new OnGlobalLayoutListener() {
+            @SuppressWarnings("deprecation")
+            @Override
+            public void onGlobalLayout() {
+                /* Layout pass done, unregister for further events */
+                view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                runnable.run();
+            }
+        };
+        view.getViewTreeObserver().addOnGlobalLayoutListener(listener);
+    }
+
+    /**
+     * Creates a new instance of the {@link ImageCache} and {@link ImageFetcher}
+     *
+     * @param activity The {@link Activity} to use.
+     * @return A new {@link ImageFetcher} used to fetch images asynchronously.
+     */
+    public static final ImageFetcher getImageFetcher(final Activity activity) {
+        final ImageFetcher imageFetcher = ImageFetcher.getInstance(activity);
+        imageFetcher.setImageCache(ImageCache.findOrCreateCache(activity));
+        return imageFetcher;
+    }
+
+    /**
+     * Method that removes the support for HardwareAcceleration from a {@link View}.<br/>
+     * <br/>
+     * Check AOSP notice:<br/>
+     * <pre>
+     * 'ComposeShader can only contain shaders of different types (a BitmapShader and a
+     * LinearGradient for instance, but not two instances of BitmapShader)'. But, 'If your
+     * application is affected by any of these missing features or limitations, you can turn
+     * off hardware acceleration for just the affected portion of your application by calling
+     * setLayerType(View.LAYER_TYPE_SOFTWARE, null).'</pre>
+     *
+     * @param v The view
+     */
+    public static void removeHardwareAccelerationSupport(View v) {
+        if (v.getLayerType() != View.LAYER_TYPE_SOFTWARE) {
+            v.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
+        }
+    }
+
+    /**
+     * Gets the action bar height in pixels
+     *
+     * @param context
+     * @return action bar height in pixels
+     */
+    public static int getActionBarHeight(Context context) {
+        TypedValue tv = new TypedValue();
+        View view = new View(context);
+        if (context.getTheme().resolveAttribute(android.R.attr.actionBarSize, tv, true)) {
+            return TypedValue.complexToDimensionPixelSize(tv.data, context.getResources().getDisplayMetrics());
+        }
+
+        return 0;
+    }
+
+    /**
+     * Returns a fancy search query cursor
+     *
+     * @param context
+     * @param query   query string
+     * @return cursor of the results
+     */
+    public static Cursor createSearchQueryCursor(final Context context, final String query) {
+        final Uri uri = Uri.parse("content://media/external/audio/search/fancy/"
+                + Uri.encode(query));
+        final String[] projection = new String[]{
+                BaseColumns._ID, MediaStore.Audio.Media.MIME_TYPE, MediaStore.Audio.Artists.ARTIST,
+                MediaStore.Audio.Albums.ALBUM, MediaStore.Audio.Media.TITLE, "data1", "data2"
+        };
+
+        // no selection/selection/sort args - they are ignored by fancy search anyways
+        return context.getContentResolver().query(uri, projection, null, null, null);
+    }
+
+    /**
+     * make a useful message from an exception without the stack track
+     */
+    public static String formatException(String message, Exception e) {
+        StringBuilder builder = new StringBuilder();
+        if (message != null) {
+            builder.append(message);
+            if (e != null) {
+                builder.append(" - ");
+            }
+        }
+
+        if (e != null) {
+            builder.append(e.getClass().getSimpleName());
+
+            String exceptionMessage = e.getMessage();
+            if (exceptionMessage != null) {
+                builder.append(": ");
+                builder.append(exceptionMessage);
+            }
+
+            for (Throwable cause = e.getCause(); cause != null; cause = cause.getCause()) {
+                builder.append(" (cause ");
+                builder.append(cause.getClass().getSimpleName());
+                String causeMessage = e.getMessage();
+                if (causeMessage != null) {
+                    builder.append(": ");
+                    builder.append(exceptionMessage);
+                }
+                builder.append(")");
+            }
+        }
+
+        return builder.toString();
+    }
+
+    /**
+     * Because cancelled tasks are not automatically removed from the queue, we can easily
+     * run over the queue limit - so here we will have a purge policy to purge those tasks
+     */
+    public static class PurgePolicy implements RejectedExecutionHandler {
+        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
+            // try purging all cancelled work items and re-executing
+            if (!e.isShutdown()) {
+                Log.d(PurgePolicy.class.getSimpleName(), "Before Purge: " + e.getQueue().size());
+                e.purge();
+                Log.d(PurgePolicy.class.getSimpleName(), "After Purge: " + e.getQueue().size());
+                e.execute(r);
+            }
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/ArtistPopupMenuHelper.java b/twelve/src/main/java/com/dolzzo/twelve/utils/ArtistPopupMenuHelper.java
new file mode 100755
index 0000000000..641a91bd98
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/ArtistPopupMenuHelper.java
@@ -0,0 +1,86 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.utils;
+
+import android.app.Activity;
+import android.support.v4.app.FragmentManager;
+import android.view.MenuItem;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.menu.DeleteDialog;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.menu.PhotoSelectionDialog;
+import com.dolzzo.twelve.model.Artist;
+
+public abstract class ArtistPopupMenuHelper extends PopupMenuHelper {
+    private Artist mArtist;
+
+    public ArtistPopupMenuHelper(Activity activity, FragmentManager fragmentManager) {
+        super(activity, fragmentManager);
+        mType = PopupMenuType.Artist;
+    }
+
+    public abstract Artist getArtist(int position);
+
+    @Override
+    public PopupMenuType onPreparePopupMenu(int position) {
+        mArtist = getArtist(position);
+        return mArtist == null ? null : PopupMenuType.Artist;
+    }
+
+    @Override
+    protected long getSourceId() {
+        return mArtist.mArtistId;
+    }
+
+    @Override
+    protected Config.IdType getSourceType() {
+        return Config.IdType.Artist;
+    }
+
+    @Override
+    protected long[] getIdList() {
+        return MusicUtils.getSongListForArtist(mActivity, mArtist.mArtistId);
+    }
+
+    @Override
+    protected void onDeleteClicked() {
+        final String artist = mArtist.mArtistName;
+        DeleteDialog.newInstance(artist, getIdList(), artist)
+                .show(mFragmentManager, "DeleteDialog");
+    }
+
+    @Override
+    protected String getArtistName() {
+        return mArtist.mArtistName;
+    }
+
+    @Override
+    public boolean onMenuItemClick(MenuItem item) {
+        boolean handled = super.onMenuItemClick(item);
+        if (!handled && item.getGroupId() == getGroupId()) {
+            switch (item.getItemId()) {
+                case FragmentMenuItems.CHANGE_IMAGE:
+                    PhotoSelectionDialog.newInstance(getArtistName(),
+                            PhotoSelectionDialog.ProfileType.ARTIST, getArtistName())
+                            .show(mFragmentManager, "PhotoSelectionDialog");
+                    return true;
+            }
+        }
+
+        return handled;
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/BitmapWithColors.java b/twelve/src/main/java/com/dolzzo/twelve/utils/BitmapWithColors.java
new file mode 100755
index 0000000000..0f69a9dcaa
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/BitmapWithColors.java
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package com.dolzzo.twelve.utils;
+
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.os.Looper;
+import android.support.v7.graphics.Palette;
+import android.util.LruCache;
+
+public class BitmapWithColors {
+    private static final int CACHE_SIZE_MAX = 20;
+    private static final LruCache<Integer, BitmapColors> sCachedColors =
+            new LruCache<Integer, BitmapColors>(CACHE_SIZE_MAX);
+    private Bitmap mBitmap;
+    private int mBitmapKey;
+    private BitmapColors mColors;
+
+    public BitmapWithColors(Bitmap bitmap, int bitmapKey) {
+        mBitmap = bitmap;
+        mBitmapKey = bitmapKey;
+
+        if (Thread.currentThread() != Looper.getMainLooper().getThread()) {
+            // we're already running in background, so do the
+            // (costly) palette initialization immediately
+            loadColorsIfNeeded();
+        }
+    }
+
+    public BitmapWithColors(Bitmap bitmap, int bitmapKey, int vibrantColor, int vibrantDarkColor) {
+        mBitmap = bitmap;
+        mBitmapKey = bitmapKey;
+        mColors = new BitmapColors(vibrantColor, vibrantDarkColor);
+    }
+
+    /**
+     * Calculates the constrast between two colors, using the algorithm provided by the WCAG v2.
+     */
+    private static float computeContrastBetweenColors(int bg, int fg) {
+        if (bg == Color.TRANSPARENT || fg == Color.TRANSPARENT || bg == fg) {
+            return -1;
+        }
+
+        float bgR = Color.red(bg) / 255f;
+        float bgG = Color.green(bg) / 255f;
+        float bgB = Color.blue(bg) / 255f;
+        bgR = (bgR < 0.03928f) ? bgR / 12.92f : (float) Math.pow((bgR + 0.055f) / 1.055f, 2.4f);
+        bgG = (bgG < 0.03928f) ? bgG / 12.92f : (float) Math.pow((bgG + 0.055f) / 1.055f, 2.4f);
+        bgB = (bgB < 0.03928f) ? bgB / 12.92f : (float) Math.pow((bgB + 0.055f) / 1.055f, 2.4f);
+        float bgL = 0.2126f * bgR + 0.7152f * bgG + 0.0722f * bgB;
+
+        float fgR = Color.red(fg) / 255f;
+        float fgG = Color.green(fg) / 255f;
+        float fgB = Color.blue(fg) / 255f;
+        fgR = (fgR < 0.03928f) ? fgR / 12.92f : (float) Math.pow((fgR + 0.055f) / 1.055f, 2.4f);
+        fgG = (fgG < 0.03928f) ? fgG / 12.92f : (float) Math.pow((fgG + 0.055f) / 1.055f, 2.4f);
+        fgB = (fgB < 0.03928f) ? fgB / 12.92f : (float) Math.pow((fgB + 0.055f) / 1.055f, 2.4f);
+        float fgL = 0.2126f * fgR + 0.7152f * fgG + 0.0722f * fgB;
+
+        return Math.abs((fgL + 0.05f) / (bgL + 0.05f));
+    }
+
+    public Bitmap getBitmap() {
+        return mBitmap;
+    }
+
+    public int getVibrantColor() {
+        loadColorsIfNeeded();
+        if (mColors.mVibrantColor == Color.TRANSPARENT) {
+            return mColors.mVibrantDarkColor;
+        }
+        return mColors.mVibrantColor;
+    }
+
+    public int getVibrantDarkColor() {
+        loadColorsIfNeeded();
+        if (mColors.mVibrantDarkColor == Color.TRANSPARENT) {
+            return mColors.mVibrantColor;
+        }
+        return mColors.mVibrantDarkColor;
+    }
+
+    public int getContrastingColor() {
+        loadColorsIfNeeded();
+
+        float contrastToDark = computeContrastBetweenColors(mColors.mDominantColor,
+                mColors.mVibrantDarkColor);
+        float contrastToLight = computeContrastBetweenColors(mColors.mDominantColor,
+                mColors.mVibrantLightColor);
+        float contrastToVibrant = computeContrastBetweenColors(mColors.mDominantColor,
+                mColors.mVibrantColor);
+
+        int bestColor = mColors.mDominantColor;
+        float bestContrast = -1;
+        if (contrastToVibrant > bestContrast) {
+            bestColor = mColors.mVibrantColor;
+            bestContrast = contrastToVibrant;
+        }
+        if (contrastToDark > bestContrast) {
+            bestColor = mColors.mVibrantDarkColor;
+            bestContrast = contrastToDark;
+        }
+        if (contrastToLight > bestContrast) {
+            bestColor = mColors.mVibrantLightColor;
+            bestContrast = contrastToLight;
+        }
+
+        return bestColor;
+    }
+
+    private synchronized void loadColorsIfNeeded() {
+        if (mColors != null) {
+            return;
+        }
+
+        synchronized (sCachedColors) {
+            mColors = sCachedColors.get(mBitmapKey);
+        }
+        if (mColors != null) {
+            return;
+        }
+
+        final Palette p = Palette.from(mBitmap).generate();
+        if (p == null) {
+            return;
+        }
+
+        mColors = new BitmapColors(p);
+        synchronized (sCachedColors) {
+            sCachedColors.put(mBitmapKey, mColors);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "BitmapWithColors[key=" + mBitmapKey + ", colors=" + mColors + "]";
+    }
+
+    private static final class BitmapColors {
+        public final int mVibrantColor;
+        public final int mVibrantDarkColor;
+        public final int mVibrantLightColor;
+        public final int mDominantColor;
+
+        public BitmapColors(Palette palette) {
+            mVibrantColor = determineColor(palette.getVibrantSwatch());
+            mVibrantDarkColor = determineColor(palette.getDarkVibrantSwatch());
+            mVibrantLightColor = determineColor(palette.getLightVibrantSwatch());
+            mDominantColor = determineColor(getDominantSwatch(palette));
+        }
+
+        public BitmapColors(int vibrantColor, int vibrantDarkColor) {
+            mVibrantColor = vibrantColor;
+            mVibrantDarkColor = vibrantDarkColor;
+            mVibrantLightColor = Color.TRANSPARENT;
+            mDominantColor = vibrantColor;
+        }
+
+        private static Palette.Swatch getDominantSwatch(Palette palette) {
+            Palette.Swatch dominant = null;
+            for (Palette.Swatch swatch : palette.getSwatches()) {
+                if (dominant == null || swatch.getPopulation() > dominant.getPopulation()) {
+                    dominant = swatch;
+                }
+            }
+            return dominant;
+        }
+
+        private int determineColor(Palette.Swatch swatch) {
+            return swatch != null ? swatch.getRgb() : Color.TRANSPARENT;
+        }
+
+        @Override
+        public String toString() {
+            return "BitmapColors[vibrant=" + Integer.toHexString(mVibrantColor)
+                    + ", vibrantDark=" + Integer.toHexString(mVibrantDarkColor)
+                    + ", vibrantLight=" + Integer.toHexString(mVibrantLightColor)
+                    + ", dominant=" + Integer.toHexString(mDominantColor) + "]";
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/ContextMenuBuilder.java b/twelve/src/main/java/com/dolzzo/twelve/utils/ContextMenuBuilder.java
new file mode 100755
index 0000000000..c4999521e0
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/ContextMenuBuilder.java
@@ -0,0 +1,66 @@
+package com.dolzzo.twelve.utils;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.os.IBinder;
+import android.support.v7.view.menu.MenuBuilder;
+import android.util.EventLog;
+import android.view.ContextMenu;
+import android.view.View;
+
+public class ContextMenuBuilder extends MenuBuilder implements ContextMenu {
+
+    public ContextMenuBuilder(Context context) {
+        super(context);
+    }
+
+    public ContextMenu setHeaderIcon(Drawable icon) {
+        return (ContextMenu) super.setHeaderIconInt(icon);
+    }
+
+    public ContextMenu setHeaderIcon(int iconRes) {
+        return (ContextMenu) super.setHeaderIconInt(iconRes);
+    }
+
+    public ContextMenu setHeaderTitle(CharSequence title) {
+        return (ContextMenu) super.setHeaderTitleInt(title);
+    }
+
+    public ContextMenu setHeaderTitle(int titleRes) {
+        return (ContextMenu) super.setHeaderTitleInt(titleRes);
+    }
+
+    public ContextMenu setHeaderView(View view) {
+        return (ContextMenu) super.setHeaderViewInt(view);
+    }
+
+    /**
+     * Shows this context menu, allowing the optional original view (and its
+     * ancestors) to add items.
+     *
+     * @param originalView Optional, the original view that triggered the
+     *                     context menu.
+     * @param token        Optional, the window token that should be set on the context
+     *                     menu's window.
+     * @return If the context menu was shown, the {@link MenuDialogHelper} for
+     * dismissing it. Otherwise, null.
+     */
+    public MenuDialogHelper show(View originalView, IBinder token) {
+        if (originalView != null) {
+            // Let relevant views and their populate context listeners populate
+            // the context menu
+            originalView.createContextMenu(this);
+        }
+        if (getVisibleItems().size() > 0) {
+            EventLog.writeEvent(50001, 1);
+
+            MenuDialogHelper helper = new MenuDialogHelper(this);
+            helper.show(token);
+
+            return helper;
+        }
+
+        return null;
+    }
+
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/GenreFetcher.java b/twelve/src/main/java/com/dolzzo/twelve/utils/GenreFetcher.java
new file mode 100755
index 0000000000..f46da82fb2
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/GenreFetcher.java
@@ -0,0 +1,57 @@
+package com.dolzzo.twelve.utils;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.os.Bundle;
+import android.provider.MediaStore;
+import android.support.v4.app.FragmentActivity;
+import android.support.v4.app.LoaderManager;
+import android.support.v4.app.LoaderManager.LoaderCallbacks;
+import android.support.v4.content.CursorLoader;
+import android.support.v4.content.Loader;
+import android.view.View;
+import android.widget.TextView;
+
+public class GenreFetcher implements LoaderCallbacks<Cursor> {
+    private static final String[] GENRE_PROJECTION = new String[]{MediaStore.Audio.Genres.NAME};
+
+    private Context mContext;
+    private int mSongId;
+    private TextView mTextView;
+
+    private GenreFetcher(Context context, int songId, TextView textView) {
+        mContext = context;
+        mSongId = songId;
+        mTextView = textView;
+    }
+
+    public static void fetch(FragmentActivity activity, int songId, TextView textView) {
+        LoaderManager lm = activity.getSupportLoaderManager();
+        lm.initLoader(0, null, new GenreFetcher(activity, songId, textView));
+    }
+
+    @Override
+    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
+        return new CursorLoader(mContext,
+                MediaStore.Audio.Genres.getContentUriForAudioId("external", mSongId),
+                GENRE_PROJECTION, null, null, null);
+    }
+
+    @Override
+    public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) {
+        if (mTextView != null && cursor.moveToFirst()) {
+            String genre = cursor.getString(0);
+            if (!MusicUtils.isBlank(genre)) {
+                mTextView.setText(genre);
+                mTextView.setVisibility(View.VISIBLE);
+                return;
+            }
+        }
+        // no displayable genre found
+        mTextView.setVisibility(View.GONE);
+    }
+
+    @Override
+    public void onLoaderReset(Loader<Cursor> loader) {
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/ImageUtils.java b/twelve/src/main/java/com/dolzzo/twelve/utils/ImageUtils.java
new file mode 100755
index 0000000000..d2f6cb1d2b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/ImageUtils.java
@@ -0,0 +1,288 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.utils;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.widget.ImageView;
+
+import com.dolzzo.twelve.cache.ImageCache;
+import com.dolzzo.twelve.cache.ImageWorker;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class ImageUtils {
+    public static final int IO_BUFFER_SIZE_BYTES = 1024;
+    private static final String DEFAULT_HTTP_CACHE_DIR = "http"; //$NON-NLS-1$
+    private static final int DEFAULT_MAX_IMAGE_HEIGHT = 1024;
+
+    private static final int DEFAULT_MAX_IMAGE_WIDTH = 1024;
+
+    private static AtomicInteger sInteger = new AtomicInteger(0);
+
+    /**
+     * Gets the image url based on the imageType
+     *
+     * @param artistName The artist name param used in the Last.fm API.
+     * @param albumName  The album name param used in the Last.fm API.
+     * @param imageType  The type of image URL to fetch for.
+     * @return The image URL for an artist image or album image.
+     */
+    public static String processImageUrl(final Context context, final String artistName,
+                                         final String albumName, final ImageWorker.ImageType imageType) {
+        switch (imageType) {
+            case ARTIST:
+                // Disable last.fm calls - TODO: Find an alternative artwork provider that has
+                // the proper license rights for artwork
+                /*if (!TextUtils.isEmpty(artistName)) {
+                    if (PreferenceUtils.getInstance(context).downloadMissingArtistImages()) {
+                        final Artist artist = Artist.getInfo(context, artistName);
+                        if (artist != null) {
+                            return getBestImage(artist);
+                        }
+                    }
+                }*/
+                break;
+            case ALBUM:
+                // Disable last.fm calls - TODO: Find an alternative artwork provider that has
+                // the proper license rights for artwork
+                /*if (!TextUtils.isEmpty(artistName) && !TextUtils.isEmpty(albumName)) {
+                    if (PreferenceUtils.getInstance(context).downloadMissingArtwork()) {
+                        final Artist correction = Artist.getCorrection(context, artistName);
+                        if (correction != null) {
+                            final Album album = Album.getInfo(context, correction.getName(),
+                                    albumName);
+                            if (album != null) {
+                                return getBestImage(album);
+                            }
+                        }
+                    }
+                }*/
+                break;
+            default:
+                break;
+        }
+        return null;
+    }
+
+    /**
+     * Downloads the bitmap from the url and returns it after some processing
+     *
+     * @param key The key to identify which image to process, as provided by
+     *            {@link ImageWorker#loadImage(mKey, android.widget.ImageView)}
+     * @return The processed {@link Bitmap}.
+     */
+    public static Bitmap processBitmap(final Context context, final String url) {
+        if (url == null) {
+            return null;
+        }
+        final File file = downloadBitmapToFile(context, url, DEFAULT_HTTP_CACHE_DIR);
+        if (file != null) {
+            // Return a sampled down version
+            final Bitmap bitmap = decodeSampledBitmapFromFile(file.toString());
+            file.delete();
+            if (bitmap != null) {
+                return bitmap;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Decode and sample down a {@link Bitmap} from a file to the requested
+     * width and height.
+     *
+     * @param filename  The full path of the file to decode
+     * @param reqWidth  The requested width of the resulting bitmap
+     * @param reqHeight The requested height of the resulting bitmap
+     * @return A {@link Bitmap} sampled down from the original with the same
+     * aspect ratio and dimensions that are equal to or greater than the
+     * requested width and height
+     */
+    public static Bitmap decodeSampledBitmapFromFile(final String filename) {
+
+        // First decode with inJustDecodeBounds=true to check dimensions
+        final BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inJustDecodeBounds = true;
+        BitmapFactory.decodeFile(filename, options);
+
+        // Calculate inSampleSize
+        options.inSampleSize = calculateInSampleSize(options, DEFAULT_MAX_IMAGE_WIDTH,
+                DEFAULT_MAX_IMAGE_HEIGHT);
+
+        // Decode bitmap with inSampleSize set
+        options.inJustDecodeBounds = false;
+        return BitmapFactory.decodeFile(filename, options);
+    }
+
+    /**
+     * Calculate an inSampleSize for use in a
+     * {@link android.graphics.BitmapFactory.Options} object when decoding
+     * bitmaps using the decode* methods from {@link BitmapFactory}. This
+     * implementation calculates the closest inSampleSize that will result in
+     * the final decoded bitmap having a width and height equal to or larger
+     * than the requested width and height. This implementation does not ensure
+     * a power of 2 is returned for inSampleSize which can be faster when
+     * decoding but results in a larger bitmap which isn't as useful for caching
+     * purposes.
+     *
+     * @param options   An options object with out* params already populated (run
+     *                  through a decode* method with inJustDecodeBounds==true
+     * @param reqWidth  The requested width of the resulting bitmap
+     * @param reqHeight The requested height of the resulting bitmap
+     * @return The value to be used for inSampleSize
+     */
+    public static final int calculateInSampleSize(final BitmapFactory.Options options,
+                                                  final int reqWidth, final int reqHeight) {
+        /* Raw height and width of image */
+        final int height = options.outHeight;
+        final int width = options.outWidth;
+        int inSampleSize = 1;
+
+        if (height > reqHeight || width > reqWidth) {
+            if (width > height) {
+                inSampleSize = Math.round((float) height / (float) reqHeight);
+            } else {
+                inSampleSize = Math.round((float) width / (float) reqWidth);
+            }
+
+            // This offers some additional logic in case the image has a strange
+            // aspect ratio. For example, a panorama may have a much larger
+            // width than height. In these cases the total pixels might still
+            // end up being too large to fit comfortably in memory, so we should
+            // be more aggressive with sample down the image (=larger
+            // inSampleSize).
+
+            final float totalPixels = width * height;
+
+            /* More than 2x the requested pixels we'll sample down further */
+            final float totalReqPixelsCap = reqWidth * reqHeight * 2;
+
+            while (totalPixels / (inSampleSize * inSampleSize) > totalReqPixelsCap) {
+                inSampleSize++;
+            }
+        }
+        return inSampleSize;
+    }
+
+    /**
+     * Download a {@link Bitmap} from a URL, write it to a disk and return the
+     * File pointer. This implementation uses a simple disk cache.
+     *
+     * @param context   The context to use
+     * @param urlString The URL to fetch
+     * @return A {@link File} pointing to the fetched bitmap
+     */
+    public static final File downloadBitmapToFile(final Context context, final String urlString,
+                                                  final String uniqueName) {
+        final File cacheDir = ImageCache.getDiskCacheDir(context, uniqueName);
+
+        if (!cacheDir.exists()) {
+            cacheDir.mkdir();
+        }
+
+        HttpURLConnection urlConnection = null;
+        BufferedOutputStream out = null;
+
+        try {
+            // increment the number to not collisions on the temp file name.  A collision can
+            // potentially cause up to 50s on the first creation of the temp file but not on
+            // subsequent ones for some reason.
+            int number = sInteger.getAndIncrement() % 10;
+            final File tempFile = File.createTempFile("bitmap" + number, null, cacheDir); //$NON-NLS-1$
+
+            final URL url = new URL(urlString);
+            urlConnection = (HttpURLConnection) url.openConnection();
+            if (urlConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
+                return null;
+            }
+            int contentLength = urlConnection.getContentLength();
+            final InputStream in = new BufferedInputStream(urlConnection.getInputStream(),
+                    IO_BUFFER_SIZE_BYTES);
+            out = new BufferedOutputStream(new FileOutputStream(tempFile), IO_BUFFER_SIZE_BYTES);
+
+            final byte[] buffer = new byte[IO_BUFFER_SIZE_BYTES];
+            int numBytes;
+            while ((numBytes = in.read(buffer)) != -1) {
+                out.write(buffer, 0, numBytes);
+                contentLength -= numBytes;
+            }
+
+            // valid values for contentLength are either -ve (meaning it wasn't set) or 0
+            // if it is  > 0 that means we got a value but didn't fully download the content
+            if (contentLength > 0) {
+                return null;
+            }
+
+            return tempFile;
+        } catch (final IOException ignored) {
+        } finally {
+            if (urlConnection != null) {
+                urlConnection.disconnect();
+            }
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (final IOException ignored) {
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Scale the bitmap to an image view. The bitmap will fill the image view bounds. The bitmap will be scaled
+     * while maintaining the aspect ratio and cropped if it exceeds the image-view bounds.
+     */
+    public static Bitmap scaleBitmapForImageView(Bitmap src, ImageView imageView) {
+        if (src == null || imageView == null) {
+            return src;
+        }
+        // get bitmap properties
+        int srcHeight = src.getHeight();
+        int srcWidth = src.getWidth();
+
+        // get image view bounds
+        int viewHeight = imageView.getHeight();
+        int viewWidth = imageView.getWidth();
+
+        int deltaWidth = viewWidth - srcWidth;
+        int deltaHeight = viewHeight - srcHeight;
+
+        if (deltaWidth <= 0 && deltaWidth <= 0)     // nothing to do if src bitmap is bigger than image-view
+            return src;
+
+        // scale bitmap along the dimension that is lacking the greatest
+        float scale = Math.max(((float) viewWidth) / srcWidth, ((float) viewHeight) / srcHeight);
+
+        // calculate the new bitmap dimensions
+        int dstHeight = (int) Math.ceil(srcHeight * scale);
+        int dstWidth = (int) Math.ceil(srcWidth * scale);
+        Bitmap scaledBitmap = Bitmap.createScaledBitmap(src, dstWidth, dstHeight, false);
+
+        return Bitmap.createBitmap(scaledBitmap, 0, 0, viewWidth, viewHeight);
+
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/Lists.java b/twelve/src/main/java/com/dolzzo/twelve/utils/Lists.java
new file mode 100755
index 0000000000..1f60632026
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/Lists.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2012 Google Inc. Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.utils;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+
+/**
+ * Provides static methods for creating {@code List} instances easily, and other
+ * utility methods for working with lists.
+ */
+public final class Lists {
+
+    /**
+     * This class is never instantiated
+     */
+    public Lists() {
+    }
+
+    /**
+     * Creates an empty {@code ArrayList} instance.
+     * <p>
+     * <b>Note:</b> if you only need an <i>immutable</i> empty List, use
+     * {@link Collections#emptyList} instead.
+     *
+     * @return a newly-created, initially-empty {@code ArrayList}
+     */
+    public static final <E> ArrayList<E> newArrayList() {
+        return new ArrayList<E>();
+    }
+
+    /**
+     * Creates an empty {@code LinkedList} instance.
+     * <p>
+     * <b>Note:</b> if you only need an <i>immutable</i> empty List, use
+     * {@link Collections#emptyList} instead.
+     *
+     * @return a newly-created, initially-empty {@code LinkedList}
+     */
+    public static final <E> LinkedList<E> newLinkedList() {
+        return new LinkedList<E>();
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/MenuDialogHelper.java b/twelve/src/main/java/com/dolzzo/twelve/utils/MenuDialogHelper.java
new file mode 100755
index 0000000000..20bc24be38
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/MenuDialogHelper.java
@@ -0,0 +1,150 @@
+package com.dolzzo.twelve.utils;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.DialogInterface;
+import android.os.IBinder;
+import android.support.v7.view.menu.ListMenuPresenter;
+import android.support.v7.view.menu.MenuBuilder;
+import android.support.v7.view.menu.MenuItemImpl;
+import android.support.v7.view.menu.MenuPresenter;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.Window;
+import android.view.WindowManager;
+
+import com.dolzzo.twelve.R;
+
+
+public class MenuDialogHelper implements DialogInterface.OnKeyListener,
+        DialogInterface.OnClickListener,
+        DialogInterface.OnDismissListener,
+        MenuPresenter.Callback {
+    ListMenuPresenter mPresenter;
+    private MenuBuilder mMenu;
+    private AlertDialog mDialog;
+    private MenuPresenter.Callback mPresenterCallback;
+
+    public MenuDialogHelper(MenuBuilder menu) {
+        mMenu = menu;
+    }
+
+    /**
+     * Shows menu as a dialog.
+     *
+     * @param windowToken Optional token to assign to the window.
+     */
+    public void show(IBinder windowToken) {
+        // Many references to mMenu, create local reference
+        final MenuBuilder menu = mMenu;
+
+        // Get the builder for the dialog
+        final AlertDialog.Builder builder = new AlertDialog.Builder(menu.getContext());
+        mPresenter = new ListMenuPresenter(builder.getContext(),
+                R.layout.list_menu_item_layout);
+        mPresenter.setCallback(this);
+        mMenu.addMenuPresenter(mPresenter);
+        builder.setAdapter(mPresenter.getAdapter(), this);
+        // Set the title
+        final View headerView = menu.getHeaderView();
+        if (headerView != null) {
+            // Menu's client has given a custom header view, use it
+            builder.setCustomTitle(headerView);
+        } else {
+            // Otherwise use the (text) title and icon
+            builder.setIcon(menu.getHeaderIcon()).setTitle(menu.getHeaderTitle());
+        }
+
+        // Set the key listener
+        builder.setOnKeyListener(this);
+
+        // Show the menu
+        mDialog = builder.create();
+        mDialog.setOnDismissListener(this);
+
+        WindowManager.LayoutParams lp = mDialog.getWindow().getAttributes();
+        lp.type = WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG;
+        if (windowToken != null) {
+            lp.token = windowToken;
+        }
+        lp.flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
+
+        mDialog.show();
+    }
+
+    public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_MENU || keyCode == KeyEvent.KEYCODE_BACK) {
+            if (event.getAction() == KeyEvent.ACTION_DOWN
+                    && event.getRepeatCount() == 0) {
+                Window win = mDialog.getWindow();
+                if (win != null) {
+                    View decor = win.getDecorView();
+                    if (decor != null) {
+                        KeyEvent.DispatcherState ds = decor.getKeyDispatcherState();
+                        if (ds != null) {
+                            ds.startTracking(event, this);
+                            return true;
+                        }
+                    }
+                }
+            } else if (event.getAction() == KeyEvent.ACTION_UP && !event.isCanceled()) {
+                Window win = mDialog.getWindow();
+                if (win != null) {
+                    View decor = win.getDecorView();
+                    if (decor != null) {
+                        KeyEvent.DispatcherState ds = decor.getKeyDispatcherState();
+                        if (ds != null && ds.isTracking(event)) {
+                            mMenu.close(true);
+                            dialog.dismiss();
+                            return true;
+                        }
+                    }
+                }
+            }
+        }
+        // Menu shortcut matching
+        return mMenu.performShortcut(keyCode, event, 0);
+    }
+
+    public void setPresenterCallback(MenuPresenter.Callback cb) {
+        mPresenterCallback = cb;
+    }
+
+    /**
+     * Dismisses the menu's dialog.
+     *
+     * @see Dialog#dismiss()
+     */
+    public void dismiss() {
+        if (mDialog != null) {
+            mDialog.dismiss();
+        }
+    }
+
+    @Override
+    public void onDismiss(DialogInterface dialog) {
+        mPresenter.onCloseMenu(mMenu, true);
+    }
+
+    @Override
+    public void onCloseMenu(MenuBuilder menu, boolean allMenusAreClosing) {
+        if (allMenusAreClosing || menu == mMenu) {
+            dismiss();
+        }
+        if (mPresenterCallback != null) {
+            mPresenterCallback.onCloseMenu(menu, allMenusAreClosing);
+        }
+    }
+
+    @Override
+    public boolean onOpenSubMenu(MenuBuilder subMenu) {
+        if (mPresenterCallback != null) {
+            return mPresenterCallback.onOpenSubMenu(subMenu);
+        }
+        return false;
+    }
+
+    public void onClick(DialogInterface dialog, int which) {
+        mMenu.performItemAction((MenuItemImpl) mPresenter.getAdapter().getItem(which), 0);
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/MusicUtils.java b/twelve/src/main/java/com/dolzzo/twelve/utils/MusicUtils.java
new file mode 100755
index 0000000000..b07678374e
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/MusicUtils.java
@@ -0,0 +1,1849 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.utils;
+
+import android.Manifest;
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Build;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.SystemClock;
+import android.provider.BaseColumns;
+import android.provider.MediaStore;
+import android.provider.MediaStore.Audio.AlbumColumns;
+import android.provider.MediaStore.Audio.ArtistColumns;
+import android.provider.MediaStore.Audio.AudioColumns;
+import android.provider.MediaStore.Audio.Playlists;
+import android.provider.MediaStore.Audio.PlaylistsColumns;
+import android.provider.MediaStore.MediaColumns;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.Menu;
+import android.widget.Toast;
+
+import com.dolzzo.twelve.Config.IdType;
+import com.dolzzo.twelve.Config.SmartPlaylistType;
+import com.dolzzo.twelve.IElevenService;
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.loaders.LastAddedLoader;
+import com.dolzzo.twelve.loaders.PlaylistLoader;
+import com.dolzzo.twelve.loaders.PlaylistSongLoader;
+import com.dolzzo.twelve.loaders.SongLoader;
+import com.dolzzo.twelve.loaders.TopTracksLoader;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.model.AlbumArtistDetails;
+import com.dolzzo.twelve.provider.RecentStore;
+import com.dolzzo.twelve.provider.SongPlayCount;
+import com.dolzzo.twelve.service.MusicPlaybackTrack;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.WeakHashMap;
+
+/**
+ * A collection of helpers directly related to music or Apollo's service.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public final class MusicUtils {
+
+    public static final String MUSIC_ONLY_SELECTION = AudioColumns.IS_MUSIC + "=1"
+            + " AND " + AudioColumns.TITLE + " != ''" + " AND " + AudioColumns.DURATION + " > 0"; //$NON-NLS-2$
+    public static final long UPDATE_FREQUENCY_MS = 500;
+    public static final long UPDATE_FREQUENCY_FAST_MS = 30;
+    private static final WeakHashMap<Context, ServiceBinder> mConnectionMap;
+    private static final long[] sEmptyList;
+    private static final int MIN_VALID_YEAR = 1900; // used to remove invalid years from metadata
+    public static IElevenService mService = null;
+    private static ContentValues[] mContentValuesCache = null;
+
+    static {
+        mConnectionMap = new WeakHashMap<Context, ServiceBinder>();
+        sEmptyList = new long[0];
+    }
+
+    /* This class is never initiated */
+    public MusicUtils() {
+    }
+
+    /**
+     * @param context  The {@link Context} to use
+     * @param callback The {@link ServiceConnection} to use
+     * @return The new instance of {@link ServiceToken}
+     */
+    public static final ServiceToken bindToService(final Context context,
+                                                   final ServiceConnection callback) {
+        if (!isPermissionGranted(context)) {
+            return null;
+        }
+
+        Activity realActivity = ((Activity) context).getParent();
+        if (realActivity == null) {
+            realActivity = (Activity) context;
+        }
+        final ContextWrapper contextWrapper = new ContextWrapper(realActivity);
+        contextWrapper.startService(new Intent(contextWrapper, MusicPlaybackService.class));
+        final ServiceBinder binder = new ServiceBinder(callback,
+                contextWrapper.getApplicationContext());
+        if (contextWrapper.bindService(
+                new Intent().setClass(contextWrapper, MusicPlaybackService.class), binder, 0)) {
+            mConnectionMap.put(contextWrapper, binder);
+            return new ServiceToken(contextWrapper);
+        }
+        return null;
+    }
+
+    public static boolean isPermissionGranted(Context context) {
+
+        if (context.checkCallingOrSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE)
+                != PackageManager.PERMISSION_GRANTED) {
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * @param token The {@link ServiceToken} to unbind from
+     */
+    public static void unbindFromService(final ServiceToken token) {
+        if (token == null) {
+            return;
+        }
+        final ContextWrapper mContextWrapper = token.mWrappedContext;
+        final ServiceBinder mBinder = mConnectionMap.remove(mContextWrapper);
+        if (mBinder == null) {
+            return;
+        }
+        mContextWrapper.unbindService(mBinder);
+        if (mConnectionMap.isEmpty()) {
+            mService = null;
+        }
+    }
+
+    public static final boolean isPlaybackServiceConnected() {
+        return mService != null;
+    }
+
+    /**
+     * Used to make number of labels for the number of artists, albums, songs,
+     * genres, and playlists.
+     *
+     * @param context   The {@link Context} to use.
+     * @param pluralInt The ID of the plural string to use.
+     * @param number    The number of artists, albums, songs, genres, or playlists.
+     * @return A {@link String} used as a label for the number of artists,
+     * albums, songs, genres, and playlists.
+     */
+    public static final String makeLabel(final Context context, final int pluralInt,
+                                         final int number) {
+        return context.getResources().getQuantityString(pluralInt, number, number);
+    }
+
+    /**
+     * * Used to create a formatted time string for the duration of tracks.
+     *
+     * @param context The {@link Context} to use.
+     * @param secs    The track in seconds.
+     * @return Duration of a track that's properly formatted.
+     */
+    public static final String makeShortTimeString(final Context context, long secs) {
+        long hours, mins;
+
+        hours = secs / 3600;
+        secs %= 3600;
+        mins = secs / 60;
+        secs %= 60;
+
+        final String durationFormat = context.getResources().getString(
+                hours == 0 ? R.string.durationformatshort : R.string.durationformatlong);
+        return String.format(durationFormat, hours, mins, secs);
+    }
+
+    /**
+     * Used to create a formatted time string in the format of #h #m or #m if there is only minutes
+     *
+     * @param context The {@link Context} to use.
+     * @param secs    The duration seconds.
+     * @return Duration properly formatted in #h #m format
+     */
+    public static final String makeLongTimeString(final Context context, long secs) {
+        long hours, mins;
+
+        hours = secs / 3600;
+        secs %= 3600;
+        mins = secs / 60;
+
+        String hoursString = MusicUtils.makeLabel(context, R.plurals.Nhours, (int) hours);
+        String minutesString = MusicUtils.makeLabel(context, R.plurals.Nminutes, (int) mins);
+
+        if (hours == 0) {
+            return minutesString;
+        } else if (mins == 0) {
+            return hoursString;
+        }
+
+        final String durationFormat = context.getResources().getString(R.string.duration_format);
+        return String.format(durationFormat, hoursString, minutesString);
+    }
+
+    /**
+     * Used to combine two strings with some kind of separator in between
+     *
+     * @param context The {@link Context} to use.
+     * @param first   string to combine
+     * @param second  string to combine
+     * @return the combined string
+     */
+    public static final String makeCombinedString(final Context context, final String first,
+                                                  final String second) {
+        final String formatter = context.getResources().getString(R.string.combine_two_strings);
+        return String.format(formatter, first, second);
+    }
+
+    /**
+     * Changes to the next track
+     */
+    public static void next() {
+        try {
+            if (mService != null) {
+                mService.next();
+            }
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * Initialize playback service with values from Settings
+     */
+    public static void initPlaybackServiceWithSettings(final Context context) {
+        MusicUtils.setShakeToPlayEnabled(
+                PreferenceUtils.getInstance(context).getShakeToPlay());
+        MusicUtils.setShowAlbumArtOnLockscreen(
+                PreferenceUtils.getInstance(context).getShowAlbumArtOnLockscreen());
+    }
+
+    /**
+     * Set shake to play status
+     */
+    public static void setShakeToPlayEnabled(final boolean enabled) {
+        try {
+            if (mService != null) {
+                mService.setShakeToPlayEnabled(enabled);
+            }
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * Set show album art on lockscreen
+     */
+    public static void setShowAlbumArtOnLockscreen(final boolean enabled) {
+        try {
+            if (mService != null) {
+                mService.setLockscreenAlbumArt(enabled);
+            }
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * Changes to the next track asynchronously
+     */
+    public static void asyncNext(final Context context) {
+        final Intent previous = new Intent(context, MusicPlaybackService.class);
+        previous.setAction(MusicPlaybackService.NEXT_ACTION);
+        context.startService(previous);
+    }
+
+    /**
+     * Changes to the previous track.
+     *
+     * @NOTE The AIDL isn't used here in order to properly use the previous
+     * action. When the user is shuffling, because {@link
+     * MusicPlaybackService.#openCurrentAndNext()} is used, the user won't
+     * be able to travel to the previously skipped track. To remedy this,
+     * {@link MusicPlaybackService.#openCurrent()} is called in {@link
+     * MusicPlaybackService.#prev()}. {@code #startService(Intent intent)}
+     * is called here to specifically invoke the onStartCommand used by
+     * {@link MusicPlaybackService}, which states if the current position
+     * less than 2000 ms, start the track over, otherwise move to the
+     * previously listened track.
+     */
+    public static void previous(final Context context, final boolean force) {
+        final Intent previous = new Intent(context, MusicPlaybackService.class);
+        if (force) {
+            previous.setAction(MusicPlaybackService.PREVIOUS_FORCE_ACTION);
+        } else {
+            previous.setAction(MusicPlaybackService.PREVIOUS_ACTION);
+        }
+        context.startService(previous);
+    }
+
+    /**
+     * Plays or pauses the music.
+     */
+    public static void playOrPause() {
+        try {
+            if (mService != null) {
+                if (mService.isPlaying()) {
+                    mService.pause();
+                } else {
+                    mService.play();
+                }
+            }
+        } catch (final Exception ignored) {
+        }
+    }
+
+    /**
+     * Cycles through the repeat options.
+     */
+    public static void cycleRepeat() {
+        try {
+            if (mService != null) {
+                switch (mService.getRepeatMode()) {
+                    case MusicPlaybackService.REPEAT_NONE:
+                        mService.setRepeatMode(MusicPlaybackService.REPEAT_ALL);
+                        break;
+                    case MusicPlaybackService.REPEAT_ALL:
+                        mService.setRepeatMode(MusicPlaybackService.REPEAT_CURRENT);
+                        if (mService.getShuffleMode() != MusicPlaybackService.SHUFFLE_NONE) {
+                            mService.setShuffleMode(MusicPlaybackService.SHUFFLE_NONE);
+                        }
+                        break;
+                    default:
+                        mService.setRepeatMode(MusicPlaybackService.REPEAT_NONE);
+                        break;
+                }
+            }
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * Cycles through the shuffle options.
+     */
+    public static void cycleShuffle() {
+        try {
+            if (mService != null) {
+                switch (mService.getShuffleMode()) {
+                    case MusicPlaybackService.SHUFFLE_NONE:
+                        mService.setShuffleMode(MusicPlaybackService.SHUFFLE_NORMAL);
+                        if (mService.getRepeatMode() == MusicPlaybackService.REPEAT_CURRENT) {
+                            mService.setRepeatMode(MusicPlaybackService.REPEAT_ALL);
+                        }
+                        break;
+                    case MusicPlaybackService.SHUFFLE_NORMAL:
+                        mService.setShuffleMode(MusicPlaybackService.SHUFFLE_NONE);
+                        break;
+                    case MusicPlaybackService.SHUFFLE_AUTO:
+                        mService.setShuffleMode(MusicPlaybackService.SHUFFLE_NONE);
+                        break;
+                    default:
+                        break;
+                }
+            }
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * @return True if we're playing music, false otherwise.
+     */
+    public static final boolean isPlaying() {
+        if (mService != null) {
+            try {
+                return mService.isPlaying();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return false;
+    }
+
+    /**
+     * @return The current shuffle mode.
+     */
+    public static final int getShuffleMode() {
+        if (mService != null) {
+            try {
+                return mService.getShuffleMode();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * @return The current repeat mode.
+     */
+    public static final int getRepeatMode() {
+        if (mService != null) {
+            try {
+                return mService.getRepeatMode();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * @return The current track name.
+     */
+    public static final String getTrackName() {
+        if (mService != null) {
+            try {
+                return mService.getTrackName();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @return The current artist name.
+     */
+    public static final String getArtistName() {
+        if (mService != null) {
+            try {
+                return mService.getArtistName();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @return The current album name.
+     */
+    public static final String getAlbumName() {
+        if (mService != null) {
+            try {
+                return mService.getAlbumName();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @return The current album Id.
+     */
+    public static final long getCurrentAlbumId() {
+        if (mService != null) {
+            try {
+                return mService.getAlbumId();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * @return The current song Id.
+     */
+    public static final long getCurrentAudioId() {
+        if (mService != null) {
+            try {
+                return mService.getAudioId();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * @return The current Music Playback Track
+     */
+    public static final MusicPlaybackTrack getCurrentTrack() {
+        if (mService != null) {
+            try {
+                return mService.getCurrentTrack();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @return The Music Playback Track at the specified index
+     */
+    public static final MusicPlaybackTrack getTrack(int index) {
+        if (mService != null) {
+            try {
+                return mService.getTrack(index);
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @return The next song Id.
+     */
+    public static final long getNextAudioId() {
+        if (mService != null) {
+            try {
+                return mService.getNextAudioId();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * @return The previous song Id.
+     */
+    public static final long getPreviousAudioId() {
+        if (mService != null) {
+            try {
+                return mService.getPreviousAudioId();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * @return The current artist Id.
+     */
+    public static final long getCurrentArtistId() {
+        if (mService != null) {
+            try {
+                return mService.getArtistId();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * @return The audio session Id.
+     */
+    public static final int getAudioSessionId() {
+        if (mService != null) {
+            try {
+                return mService.getAudioSessionId();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * @return The queue.
+     */
+    public static final long[] getQueue() {
+        try {
+            if (mService != null) {
+                return mService.getQueue();
+            } else {
+            }
+        } catch (final RemoteException ignored) {
+        }
+        return sEmptyList;
+    }
+
+    /**
+     * @param position
+     * @return the id of the track in the queue at the given position
+     */
+    public static final long getQueueItemAtPosition(int position) {
+        try {
+            if (mService != null) {
+                return mService.getQueueItemAtPosition(position);
+            } else {
+            }
+        } catch (final RemoteException ignored) {
+        }
+        return -1;
+    }
+
+    /**
+     * @return the current queue size
+     */
+    public static final int getQueueSize() {
+        try {
+            if (mService != null) {
+                return mService.getQueueSize();
+            } else {
+            }
+        } catch (final RemoteException ignored) {
+        }
+        return 0;
+    }
+
+    /**
+     * @return The position of the current track in the queue.
+     */
+    public static final int getQueuePosition() {
+        try {
+            if (mService != null) {
+                return mService.getQueuePosition();
+            }
+        } catch (final RemoteException ignored) {
+        }
+        return 0;
+    }
+
+    /**
+     * @param position The position to move the queue to
+     */
+    public static void setQueuePosition(final int position) {
+        if (mService != null) {
+            try {
+                mService.setQueuePosition(position);
+            } catch (final RemoteException ignored) {
+            }
+        }
+    }
+
+    /**
+     * @return The queue history size
+     */
+    public static final int getQueueHistorySize() {
+        if (mService != null) {
+            try {
+                return mService.getQueueHistorySize();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * @return The queue history position at the position
+     */
+    public static final int getQueueHistoryPosition(int position) {
+        if (mService != null) {
+            try {
+                return mService.getQueueHistoryPosition(position);
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * @return The queue history
+     */
+    public static final int[] getQueueHistoryList() {
+        if (mService != null) {
+            try {
+                return mService.getQueueHistoryList();
+            } catch (final RemoteException ignored) {
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @param id The ID of the track to remove.
+     * @return removes track from a playlist or the queue.
+     */
+    public static final int removeTrack(final long id) {
+        try {
+            if (mService != null) {
+                return mService.removeTrack(id);
+            }
+        } catch (final RemoteException ingored) {
+        }
+        return 0;
+    }
+
+    /**
+     * Remove song at a specified position in the list
+     *
+     * @param id       The ID of the track to remove
+     * @param position The position of the song
+     * @return true if successful, false otherwise
+     */
+    public static final boolean removeTrackAtPosition(final long id, final int position) {
+        try {
+            if (mService != null) {
+                return mService.removeTrackAtPosition(id, position);
+            }
+        } catch (final RemoteException ingored) {
+        }
+        return false;
+    }
+
+    /**
+     * @param cursor The {@link Cursor} used to perform our query.
+     * @return The song list for a MIME type.
+     */
+    public static final long[] getSongListForCursor(Cursor cursor) {
+        if (cursor == null) {
+            return sEmptyList;
+        }
+        final int len = cursor.getCount();
+        final long[] list = new long[len];
+        cursor.moveToFirst();
+        int columnIndex = -1;
+        try {
+            columnIndex = cursor.getColumnIndexOrThrow(MediaStore.Audio.Playlists.Members.AUDIO_ID);
+        } catch (final IllegalArgumentException notaplaylist) {
+            columnIndex = cursor.getColumnIndexOrThrow(BaseColumns._ID);
+        }
+        for (int i = 0; i < len; i++) {
+            list[i] = cursor.getLong(columnIndex);
+            cursor.moveToNext();
+        }
+        cursor.close();
+        cursor = null;
+        return list;
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @param id      The ID of the artist.
+     * @return The song list for an artist.
+     */
+    public static final long[] getSongListForArtist(final Context context, final long id) {
+        if (isPermissionGranted(context) == false) {
+            return sEmptyList;
+        }
+
+        final String[] projection = new String[]{
+                BaseColumns._ID
+        };
+        final String selection = AudioColumns.ARTIST_ID + "=" + id + " AND "
+                + AudioColumns.IS_MUSIC + "=1";
+        Cursor cursor = context.getContentResolver().query(
+                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, projection, selection, null,
+                AudioColumns.ALBUM_KEY + "," + AudioColumns.TRACK);
+        if (cursor != null) {
+            final long[] mList = getSongListForCursor(cursor);
+            cursor.close();
+            cursor = null;
+            return mList;
+        }
+        return sEmptyList;
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @param id      The ID of the album.
+     * @return The song list for an album.
+     */
+    public static final long[] getSongListForAlbum(final Context context, final long id) {
+        if (isPermissionGranted(context) == false) {
+            return sEmptyList;
+        }
+
+        final String[] projection = new String[]{
+                BaseColumns._ID
+        };
+        final String selection = AudioColumns.ALBUM_ID + "=" + id + " AND " + AudioColumns.IS_MUSIC
+                + "=1";
+        Cursor cursor = context.getContentResolver().query(
+                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, projection, selection, null,
+                AudioColumns.TRACK + ", " + MediaStore.Audio.Media.DEFAULT_SORT_ORDER);
+        if (cursor != null) {
+            final long[] mList = getSongListForCursor(cursor);
+            cursor.close();
+            cursor = null;
+            return mList;
+        }
+        return sEmptyList;
+    }
+
+    /**
+     * Plays songs by an artist.
+     *
+     * @param context  The {@link Context} to use.
+     * @param artistId The artist Id.
+     * @param position Specify where to start.
+     */
+    public static void playArtist(final Context context, final long artistId, int position, boolean shuffle) {
+        final long[] artistList = getSongListForArtist(context, artistId);
+        if (artistList != null) {
+            playAll(context, artistList, position, artistId, IdType.Artist, shuffle);
+        }
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @param id      The ID of the genre.
+     * @return The song list for an genre.
+     */
+    public static final long[] getSongListForGenre(final Context context, final long id) {
+        final String[] projection = new String[]{
+                BaseColumns._ID
+        };
+        String selection = (AudioColumns.IS_MUSIC + "=1") +
+                " AND " + MediaColumns.TITLE + "!=''";
+        final Uri uri = MediaStore.Audio.Genres.Members.getContentUri("external", Long.valueOf(id));
+        Cursor cursor = context.getContentResolver().query(uri, projection, selection,
+                null, null);
+        if (cursor != null) {
+            final long[] mList = getSongListForCursor(cursor);
+            cursor.close();
+            cursor = null;
+            return mList;
+        }
+        return sEmptyList;
+    }
+
+    /**
+     * @param context The {@link Context} to use
+     * @param uri     The source of the file
+     */
+    public static void playFile(final Context context, final Uri uri) {
+        if (uri == null || mService == null) {
+            return;
+        }
+
+        // If this is a file:// URI, just use the path directly instead
+        // of going through the open-from-filedescriptor codepath.
+        String filename;
+        String scheme = uri.getScheme();
+        if ("file".equals(scheme)) {
+            filename = uri.getPath();
+        } else {
+            filename = uri.toString();
+        }
+
+        try {
+            mService.stop();
+            mService.openFile(filename);
+            mService.play();
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * @param context      The {@link Context} to use.
+     * @param list         The list of songs to play.
+     * @param position     Specify where to start.
+     * @param forceShuffle True to force a shuffle, false otherwise.
+     */
+    public static void playAll(final Context context, final long[] list, int position,
+                               final long sourceId, final IdType sourceType,
+                               final boolean forceShuffle) {
+        if (list == null || list.length == 0 || mService == null) {
+            return;
+        }
+        try {
+            if (forceShuffle) {
+                mService.setShuffleMode(MusicPlaybackService.SHUFFLE_NORMAL);
+            }
+            if (position < 0) {
+                position = 0;
+            }
+            mService.open(list, forceShuffle ? -1 : position, sourceId, sourceType.mId);
+            mService.play();
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * @param list The list to enqueue.
+     */
+    public static void playNext(final long[] list, final long sourceId, final IdType sourceType) {
+        if (mService == null) {
+            return;
+        }
+        try {
+            mService.enqueue(list, MusicPlaybackService.NEXT, sourceId, sourceType.mId);
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     */
+    public static void shuffleAll(final Context context) {
+        Cursor cursor = SongLoader.makeSongCursor(context, null);
+        final long[] mTrackList = getSongListForCursor(cursor);
+        if (mTrackList.length == 0 || mService == null) {
+            return;
+        }
+        try {
+            mService.setShuffleMode(MusicPlaybackService.SHUFFLE_NORMAL);
+            final long mCurrentId = mService.getAudioId();
+            final int mCurrentQueuePosition = getQueuePosition();
+            if (mCurrentQueuePosition == 0
+                    && mCurrentId == mTrackList[0]) {
+                final long[] mPlaylist = getQueue();
+                if (Arrays.equals(mTrackList, mPlaylist)) {
+                    mService.play();
+                    return;
+                }
+            }
+            mService.open(mTrackList, -1, -1, IdType.NA.mId);
+            mService.play();
+            cursor.close();
+            cursor = null;
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * Returns The ID for a playlist.
+     *
+     * @param context The {@link Context} to use.
+     * @param name    The name of the playlist.
+     * @return The ID for a playlist.
+     */
+    public static final long getIdForPlaylist(final Context context, final String name) {
+        if (isPermissionGranted(context) == false) {
+            return -1;
+        }
+
+        Cursor cursor = context.getContentResolver().query(
+                MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, new String[]{
+                        BaseColumns._ID
+                }, PlaylistsColumns.NAME + "=?", new String[]{
+                        name
+                }, PlaylistsColumns.NAME);
+        int id = -1;
+        if (cursor != null) {
+            cursor.moveToFirst();
+            if (!cursor.isAfterLast()) {
+                id = cursor.getInt(0);
+            }
+            cursor.close();
+            cursor = null;
+        }
+        return id;
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @param id      The id of the playlist.
+     * @return The name for a playlist.
+     */
+    public static final String getNameForPlaylist(final Context context, final long id) {
+        if (isPermissionGranted(context) == false) {
+            return null;
+        }
+
+        Cursor cursor = context.getContentResolver().query(
+                MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
+                new String[]{PlaylistsColumns.NAME},
+                BaseColumns._ID + "=?",
+                new String[]{Long.toString(id)},
+                null);
+        if (cursor != null) {
+            try {
+                if (cursor.moveToFirst()) {
+                    return cursor.getString(0);
+                }
+            } finally {
+                cursor.close();
+            }
+        }
+        // nothing found
+        return null;
+    }
+
+    /**
+     * Returns the Id for an artist.
+     *
+     * @param context The {@link Context} to use.
+     * @param name    The name of the artist.
+     * @return The ID for an artist.
+     */
+    public static final long getIdForArtist(final Context context, final String name) {
+        if (isPermissionGranted(context) == false) {
+            return -1;
+        }
+
+        Cursor cursor = context.getContentResolver().query(
+                MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI, new String[]{
+                        BaseColumns._ID
+                }, ArtistColumns.ARTIST + "=?", new String[]{
+                        name
+                }, ArtistColumns.ARTIST);
+        int id = -1;
+        if (cursor != null) {
+            cursor.moveToFirst();
+            if (!cursor.isAfterLast()) {
+                id = cursor.getInt(0);
+            }
+            cursor.close();
+            cursor = null;
+        }
+        return id;
+    }
+
+    /**
+     * Returns the ID for an album.
+     *
+     * @param context    The {@link Context} to use.
+     * @param albumName  The name of the album.
+     * @param artistName The name of the artist
+     * @return The ID for an album.
+     */
+    public static final long getIdForAlbum(final Context context, final String albumName,
+                                           final String artistName) {
+        if (isPermissionGranted(context) == false) {
+            return -1;
+        }
+
+        Cursor cursor = context.getContentResolver().query(
+                MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI, new String[]{
+                        BaseColumns._ID
+                }, AlbumColumns.ALBUM + "=? AND " + AlbumColumns.ARTIST + "=?", new String[]{
+                        albumName, artistName
+                }, AlbumColumns.ALBUM);
+        int id = -1;
+        if (cursor != null) {
+            cursor.moveToFirst();
+            if (!cursor.isAfterLast()) {
+                id = cursor.getInt(0);
+            }
+            cursor.close();
+            cursor = null;
+        }
+        return id;
+    }
+
+    /**
+     * Plays songs from an album.
+     *
+     * @param context  The {@link Context} to use.
+     * @param albumId  The album Id.
+     * @param position Specify where to start.
+     */
+    public static void playAlbum(final Context context, final long albumId, int position, boolean shuffle) {
+        final long[] albumList = getSongListForAlbum(context, albumId);
+        if (albumList != null) {
+            playAll(context, albumList, position, albumId, IdType.Album, shuffle);
+        }
+    }
+
+    /*  */
+    public static void makeInsertItems(final long[] ids, final int offset, int len, final int base) {
+        if (offset + len > ids.length) {
+            len = ids.length - offset;
+        }
+
+        if (mContentValuesCache == null || mContentValuesCache.length != len) {
+            mContentValuesCache = new ContentValues[len];
+        }
+        for (int i = 0; i < len; i++) {
+            if (mContentValuesCache[i] == null) {
+                mContentValuesCache[i] = new ContentValues();
+            }
+            mContentValuesCache[i].put(Playlists.Members.PLAY_ORDER, base + offset + i);
+            mContentValuesCache[i].put(Playlists.Members.AUDIO_ID, ids[offset + i]);
+        }
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @param name    The name of the new playlist.
+     * @return A new playlist ID.
+     */
+    public static final long createPlaylist(final Context context, final String name) {
+        if (name != null && name.length() > 0) {
+            if (isPermissionGranted(context) == false) {
+                return -1;
+            }
+
+            final ContentResolver resolver = context.getContentResolver();
+            final String[] projection = new String[]{
+                    PlaylistsColumns.NAME
+            };
+            final String selection = PlaylistsColumns.NAME + " = '" + name + "'";
+            Cursor cursor = resolver.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
+                    projection, selection, null, null);
+            if (cursor.getCount() <= 0) {
+                final ContentValues values = new ContentValues(1);
+                values.put(PlaylistsColumns.NAME, name);
+                final Uri uri = resolver.insert(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
+                        values);
+                return Long.parseLong(uri.getLastPathSegment());
+            }
+            if (cursor != null) {
+                cursor.close();
+                cursor = null;
+            }
+            return -1;
+        }
+        return -1;
+    }
+
+    /**
+     * @param context    The {@link Context} to use.
+     * @param playlistId The playlist ID.
+     */
+    public static void clearPlaylist(final Context context, final int playlistId) {
+        final Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
+        context.getContentResolver().delete(uri, null, null);
+        return;
+    }
+
+    /**
+     * remove all backing data for top tracks playlist
+     */
+    public static void clearTopTracks(Context context) {
+        SongPlayCount.getInstance(context).deleteAll();
+    }
+
+    /**
+     * remove all backing data for top tracks playlist
+     */
+    public static void clearRecent(Context context) {
+        RecentStore.getInstance(context).deleteAll();
+    }
+
+    /**
+     * move up cutoff for last added songs so playlist will be cleared
+     */
+    public static void clearLastAdded(Context context) {
+        PreferenceUtils.getInstance(context)
+                .setLastAddedCutoff(System.currentTimeMillis());
+    }
+
+    /**
+     * @param context    The {@link Context} to use.
+     * @param ids        The id of the song(s) to add.
+     * @param playlistid The id of the playlist being added to.
+     */
+    public static void addToPlaylist(final Context context, final long[] ids, final long playlistid) {
+        final int size = ids.length;
+        final ContentResolver resolver = context.getContentResolver();
+        final String[] projection = new String[]{
+                "max(" + Playlists.Members.PLAY_ORDER + ")",
+        };
+        final Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistid);
+        Cursor cursor = null;
+        int base = 0;
+
+        try {
+            cursor = resolver.query(uri, projection, null, null, null);
+
+            if (cursor != null && cursor.moveToFirst()) {
+                base = cursor.getInt(0) + 1;
+            }
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+                cursor = null;
+            }
+        }
+
+        int numinserted = 0;
+        for (int offSet = 0; offSet < size; offSet += 1000) {
+            makeInsertItems(ids, offSet, 1000, base);
+            numinserted += resolver.bulkInsert(uri, mContentValuesCache);
+        }
+        final String message = context.getResources().getQuantityString(
+                R.plurals.NNNtrackstoplaylist, numinserted, numinserted);
+        Toast.makeText((Activity) context, message, Toast.LENGTH_SHORT).show();
+        playlistChanged();
+    }
+
+    /**
+     * Removes a single track from a given playlist
+     *
+     * @param context    The {@link Context} to use.
+     * @param id         The id of the song to remove.
+     * @param playlistId The id of the playlist being removed from.
+     */
+    public static void removeFromPlaylist(final Context context, final long id,
+                                          final long playlistId) {
+        final Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId);
+        final ContentResolver resolver = context.getContentResolver();
+        resolver.delete(uri, Playlists.Members.AUDIO_ID + " = ? ", new String[]{
+                Long.toString(id)
+        });
+        final String message = context.getResources().getQuantityString(
+                R.plurals.NNNtracksfromplaylist, 1, 1);
+        Toast.makeText((Activity) context, message, Toast.LENGTH_SHORT).show();
+        playlistChanged();
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @param list    The list to enqueue.
+     */
+    public static void addToQueue(final Context context, final long[] list, long sourceId,
+                                  IdType sourceType) {
+        if (mService == null) {
+            return;
+        }
+        try {
+            mService.enqueue(list, MusicPlaybackService.LAST, sourceId, sourceType.mId);
+            final String message = makeLabel(context, R.plurals.NNNtrackstoqueue, list.length);
+            Toast.makeText((Activity) context, message, Toast.LENGTH_SHORT).show();
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * @param context The {@link Context} to use
+     * @param id      The song ID.
+     */
+    public static void setRingtone(final Context context, final long id) {
+        if (isPermissionGranted(context) == false) {
+            return;
+        }
+
+        final ContentResolver resolver = context.getContentResolver();
+        final Uri uri = ContentUris.withAppendedId(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);
+        try {
+            final ContentValues values = new ContentValues(2);
+            values.put(AudioColumns.IS_RINGTONE, "1");
+            values.put(AudioColumns.IS_ALARM, "1");
+            resolver.update(uri, values, null, null);
+        } catch (final UnsupportedOperationException ingored) {
+            return;
+        }
+
+        final String[] projection = new String[]{
+                BaseColumns._ID, MediaColumns.DATA, MediaColumns.TITLE
+        };
+
+        final String selection = BaseColumns._ID + "=" + id;
+        Cursor cursor = resolver.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, projection,
+                selection, null, null);
+        try {
+            if (cursor != null && cursor.getCount() == 1) {
+                cursor.moveToFirst();
+                Settings.System.putString(resolver, Settings.System.RINGTONE, uri.toString());
+                final String message = context.getString(R.string.set_as_ringtone,
+                        cursor.getString(2));
+                Toast.makeText((Activity) context, message, Toast.LENGTH_SHORT).show();
+            }
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+                cursor = null;
+            }
+        }
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @param id      The id of the album.
+     * @return The song count for an album.
+     */
+    public static final int getSongCountForAlbumInt(final Context context, final long id) {
+        int songCount = 0;
+        if (id == -1) {
+            return songCount;
+        }
+
+        if (isPermissionGranted(context) == false) {
+            return songCount;
+        }
+
+        Uri uri = ContentUris.withAppendedId(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI, id);
+        Cursor cursor = context.getContentResolver().query(uri,
+                new String[]{AlbumColumns.NUMBER_OF_SONGS}, null, null, null);
+        if (cursor != null) {
+            cursor.moveToFirst();
+            if (!cursor.isAfterLast()) {
+                if (!cursor.isNull(0)) {
+                    songCount = cursor.getInt(0);
+                }
+            }
+            cursor.close();
+            cursor = null;
+        }
+
+        return songCount;
+    }
+
+    /**
+     * Gets the number of songs for a playlist
+     *
+     * @param context    The {@link Context} to use.
+     * @param playlistId the id of the playlist
+     * @return the # of songs in the playlist
+     */
+    public static final int getSongCountForPlaylist(final Context context, final long playlistId) {
+        Cursor c = context.getContentResolver().query(
+                MediaStore.Audio.Playlists.Members.getContentUri("external", playlistId),
+                new String[]{BaseColumns._ID}, MusicUtils.MUSIC_ONLY_SELECTION, null, null);
+
+        if (c != null) {
+            int count = 0;
+            if (c.moveToFirst()) {
+                count = c.getCount();
+            }
+            c.close();
+            c = null;
+            return count;
+        }
+
+        return 0;
+    }
+
+    public static final AlbumArtistDetails getAlbumArtDetails(final Context context, final long trackId) {
+        if (isPermissionGranted(context) == false) {
+            return null;
+        }
+
+        String selection = (AudioColumns.IS_MUSIC + "=1") +
+                " AND " + BaseColumns._ID + " = '" + trackId + "'";
+
+        Cursor cursor = context.getContentResolver().query(
+                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                new String[]{
+                    /* 0 */
+                        MediaStore.Audio.AudioColumns.ALBUM_ID,
+                    /* 1 */
+                        MediaStore.Audio.AudioColumns.ALBUM,
+                    /* 2 */
+                        MediaStore.Audio.AlbumColumns.ARTIST,
+                }, selection, null, null
+        );
+
+        if (!cursor.moveToFirst()) {
+            cursor.close();
+            return null;
+        }
+
+        AlbumArtistDetails result = new AlbumArtistDetails();
+        result.mAudioId = trackId;
+        result.mAlbumId = cursor.getLong(0);
+        result.mAlbumName = cursor.getString(1);
+        result.mArtistName = cursor.getString(2);
+        cursor.close();
+
+        return result;
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @param id      The id of the album.
+     * @return The release date for an album.
+     */
+    public static final String getReleaseDateForAlbum(final Context context, final long id) {
+        if (id == -1) {
+            return null;
+        }
+
+        if (isPermissionGranted(context) == false) {
+            return null;
+        }
+
+        Uri uri = ContentUris.withAppendedId(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI, id);
+        Cursor cursor = context.getContentResolver().query(uri, new String[]{
+                AlbumColumns.FIRST_YEAR
+        }, null, null, null);
+        String releaseDate = null;
+        if (cursor != null) {
+            cursor.moveToFirst();
+            if (!cursor.isAfterLast()) {
+                releaseDate = cursor.getString(0);
+            }
+            cursor.close();
+            cursor = null;
+        }
+        return releaseDate;
+    }
+
+    /**
+     * @return The path to the currently playing file as {@link String}
+     */
+    public static final String getFilePath() {
+        try {
+            if (mService != null) {
+                return mService.getPath();
+            }
+        } catch (final RemoteException ignored) {
+        }
+        return null;
+    }
+
+    /**
+     * @param from The index the item is currently at.
+     * @param to   The index the item is moving to.
+     */
+    public static void moveQueueItem(final int from, final int to) {
+        try {
+            if (mService != null) {
+                mService.moveQueueItem(from, to);
+            } else {
+            }
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * @param context    The {@link Context} to sue
+     * @param playlistId The playlist Id
+     * @return The track list for a playlist
+     */
+    public static final long[] getSongListForPlaylist(final Context context, final long playlistId) {
+        Cursor cursor = PlaylistSongLoader.makePlaylistSongCursor(context, playlistId);
+
+        if (cursor != null) {
+            final long[] list = getSongListForCursor(cursor);
+            cursor.close();
+            cursor = null;
+            return list;
+        }
+        return sEmptyList;
+    }
+
+    /**
+     * Plays a user created playlist.
+     *
+     * @param context    The {@link Context} to use.
+     * @param playlistId The playlist Id.
+     */
+    public static void playPlaylist(final Context context, final long playlistId, boolean shuffle) {
+        final long[] playlistList = getSongListForPlaylist(context, playlistId);
+        if (playlistList != null) {
+            playAll(context, playlistList, -1, playlistId, IdType.Playlist, shuffle);
+        }
+    }
+
+    /**
+     * @param context The {@link Context} to use
+     * @param type    The Smart Playlist Type
+     * @return The song list for the last added playlist
+     */
+    public static final long[] getSongListForSmartPlaylist(final Context context,
+                                                           final SmartPlaylistType type) {
+        Cursor cursor = null;
+        try {
+            switch (type) {
+                case LastAdded:
+                    cursor = LastAddedLoader.makeLastAddedCursor(context);
+                    break;
+                case RecentlyPlayed:
+                    cursor = TopTracksLoader.makeRecentTracksCursor(context);
+                    break;
+                case TopTracks:
+                    cursor = TopTracksLoader.makeTopTracksCursor(context);
+                    break;
+            }
+            return MusicUtils.getSongListForCursor(cursor);
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+                cursor = null;
+            }
+        }
+    }
+
+    /**
+     * Plays the smart playlist
+     *
+     * @param context  The {@link Context} to use
+     * @param position the position to start playing from
+     * @param type     The Smart Playlist Type
+     */
+    public static void playSmartPlaylist(final Context context, final int position,
+                                         final SmartPlaylistType type, final boolean shuffle) {
+        final long[] list = getSongListForSmartPlaylist(context, type);
+        MusicUtils.playAll(context, list, position, type.mId, IdType.Playlist, shuffle);
+    }
+
+    /**
+     * Creates a sub menu used to add items to a new playlist or an existsing
+     * one.
+     *
+     * @param context The {@link Context} to use.
+     * @param groupId The group Id of the menu.
+     * @param menu    The {@link Menu} to add to.
+     */
+    public static void makePlaylistMenu(final Context context, final int groupId,
+                                        final Menu menu) {
+        menu.clear();
+        menu.add(groupId, FragmentMenuItems.NEW_PLAYLIST, Menu.NONE, R.string.new_playlist);
+        Cursor cursor = PlaylistLoader.makePlaylistCursor(context);
+        if (cursor != null && cursor.getCount() > 0 && cursor.moveToFirst()) {
+            while (!cursor.isAfterLast()) {
+                final Intent intent = new Intent();
+                String name = cursor.getString(1);
+                if (name != null) {
+                    intent.putExtra("playlist", getIdForPlaylist(context, name));
+                    menu.add(groupId, FragmentMenuItems.PLAYLIST_SELECTED, Menu.NONE,
+                            name).setIntent(intent);
+                }
+                cursor.moveToNext();
+            }
+        }
+        if (cursor != null) {
+            cursor.close();
+            cursor = null;
+        }
+    }
+
+    /**
+     * Called when one of the lists should refresh or requery.
+     */
+    public static void refresh() {
+        try {
+            if (mService != null) {
+                mService.refresh();
+            }
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * Called when one of playlists have changed
+     */
+    public static void playlistChanged() {
+        try {
+            if (mService != null) {
+                mService.playlistChanged();
+            }
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * Seeks the current track to a desired position
+     *
+     * @param position The position to seek to
+     */
+    public static void seek(final long position) {
+        if (mService != null) {
+            try {
+                mService.seek(position);
+            } catch (final RemoteException ignored) {
+            }
+        }
+    }
+
+    /**
+     * Seeks the current track to a desired relative position.  This can be used
+     * to simulate fastforward and rewind
+     *
+     * @param deltaInMs The delta in ms to seek from the current position
+     */
+    public static void seekRelative(final long deltaInMs) {
+        if (mService != null) {
+            try {
+                mService.seekRelative(deltaInMs);
+            } catch (final RemoteException ignored) {
+            } catch (final IllegalStateException ignored) {
+                // Illegal State Exception message is empty so logging will actually throw an
+                // exception.  We should come back and figure out why we get an exception in the
+                // first place and make sure we understand it completely.  I will use
+                // https://cyanogen.atlassian.net/browse/MUSIC-125 to track investigating this more
+            }
+        }
+    }
+
+    /**
+     * @return The current position time of the track
+     */
+    public static final long position() {
+        if (mService != null) {
+            try {
+                return mService.position();
+            } catch (final RemoteException ignored) {
+            } catch (final IllegalStateException ex) {
+                // Illegal State Exception message is empty so logging will actually throw an
+                // exception.  We should come back and figure out why we get an exception in the
+                // first place and make sure we understand it completely.  I will use
+                // https://cyanogen.atlassian.net/browse/MUSIC-125 to track investigating this more
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * @return The total length of the current track
+     */
+    public static final long duration() {
+        if (mService != null) {
+            try {
+                return mService.duration();
+            } catch (final RemoteException ignored) {
+            } catch (final IllegalStateException ignored) {
+                // Illegal State Exception message is empty so logging will actually throw an
+                // exception.  We should come back and figure out why we get an exception in the
+                // first place and make sure we understand it completely.  I will use
+                // https://cyanogen.atlassian.net/browse/MUSIC-125 to track investigating this more
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * Clears the qeueue
+     */
+    public static void clearQueue() {
+        try {
+            mService.removeTracks(0, Integer.MAX_VALUE);
+        } catch (final RemoteException ignored) {
+        }
+    }
+
+    /**
+     * Perminately deletes item(s) from the user's device
+     *
+     * @param context The {@link Context} to use.
+     * @param list    The item(s) to delete.
+     */
+    public static void deleteTracks(final Context context, final long[] list) {
+        if (isPermissionGranted(context) == false) {
+            return;
+        }
+
+        final String[] projection = new String[]{
+                BaseColumns._ID, MediaColumns.DATA, AudioColumns.ALBUM_ID
+        };
+        final StringBuilder selection = new StringBuilder();
+        selection.append(BaseColumns._ID + " IN (");
+        for (int i = 0; i < list.length; i++) {
+            selection.append(list[i]);
+            if (i < list.length - 1) {
+                selection.append(",");
+            }
+        }
+        selection.append(")");
+        final Cursor c = context.getContentResolver().query(
+                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, projection, selection.toString(),
+                null, null);
+        if (c != null) {
+            // Step 1: Remove selected tracks from the current playlist, as well
+            // as from the album art cache
+            c.moveToFirst();
+            while (!c.isAfterLast()) {
+                // Remove from current playlist
+                final long id = c.getLong(0);
+                removeTrack(id);
+                // Remove the track from the play count
+                SongPlayCount.getInstance(context).removeItem(id);
+                // Remove any items in the recents database
+                RecentStore.getInstance(context).removeItem(id);
+                c.moveToNext();
+            }
+
+            // Step 2: Remove selected tracks from the database
+            context.getContentResolver().delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                    selection.toString(), null);
+
+            // Step 3: Remove files from card
+            c.moveToFirst();
+            while (!c.isAfterLast()) {
+                final String name = c.getString(1);
+                final File f = new File(name);
+                try { // File.delete can throw a security exception
+                    if (!f.delete()) {
+                        // I'm not sure if we'd ever get here (deletion would
+                        // have to fail, but no exception thrown)
+                        Log.e("MusicUtils", "Failed to delete file " + name);
+                    }
+                    c.moveToNext();
+                } catch (final SecurityException ex) {
+                    c.moveToNext();
+                }
+            }
+            c.close();
+        }
+
+        final String message = makeLabel(context, R.plurals.NNNtracksdeleted, list.length);
+
+        Toast.makeText((Activity) context, message, Toast.LENGTH_SHORT).show();
+        // We deleted a number of tracks, which could affect any number of
+        // things
+        // in the media content domain, so update everything.
+        context.getContentResolver().notifyChange(Uri.parse("content://media"), null);
+        // Notify the lists to update
+        refresh();
+    }
+
+    /**
+     * Simple function used to determine if the song/album year is invalid
+     *
+     * @param year value to test
+     * @return true if the app considers it valid
+     */
+    public static boolean isInvalidYear(int year) {
+        return year < MIN_VALID_YEAR;
+    }
+
+    /**
+     * A snippet is taken from MediaStore.Audio.keyFor method
+     * This will take a name, removes things like "the", "an", etc
+     * as well as special characters and return it
+     *
+     * @param name the string to trim
+     * @return the trimmed name
+     */
+    public static String getTrimmedName(String name) {
+        if (name == null || name.length() == 0) {
+            return name;
+        }
+
+        name = name.trim().toLowerCase();
+        if (name.startsWith("the ")) {
+            name = name.substring(4);
+        }
+        if (name.startsWith("an ")) {
+            name = name.substring(3);
+        }
+        if (name.startsWith("a ")) {
+            name = name.substring(2);
+        }
+        if (name.endsWith(", the") || name.endsWith(",the") ||
+                name.endsWith(", an") || name.endsWith(",an") ||
+                name.endsWith(", a") || name.endsWith(",a")) {
+            name = name.substring(0, name.lastIndexOf(','));
+        }
+        name = name.replaceAll("[\\[\\]\\(\\)\"'.,?!]", "").trim();
+
+        return name;
+    }
+
+    /**
+     * A snippet is taken from MediaStore.Audio.keyFor method
+     * This will take a name, removes things like "the", "an", etc
+     * as well as special characters, then find the localized label
+     *
+     * @param name Name to get the label of
+     * @return the localized label of the bucket that the name falls into
+     */
+    public static String getLocalizedBucketLetter(String name) {
+        if (name == null || name.length() == 0) {
+            return null;
+        }
+
+        name = getTrimmedName(name);
+
+        return null;
+    }
+
+    /**
+     * @return true if a string is null, empty, or contains only whitespace
+     */
+    public static boolean isBlank(String s) {
+        if (s == null) {
+            return true;
+        }
+        if (s.isEmpty()) {
+            return true;
+        }
+        for (int i = 0; i < s.length(); i++) {
+            char c = s.charAt(i);
+            if (!Character.isWhitespace(c)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Removes the header image from the cache.
+     */
+    public static void removeFromCache(Activity activity, String key) {
+        ImageFetcher imageFetcher = ApolloUtils.getImageFetcher(activity);
+        imageFetcher.removeFromCache(key);
+        // Give the disk cache a little time before requesting a new image.
+        SystemClock.sleep(80);
+    }
+
+    /**
+     * Removes image from cache so that the stock image is retrieved on reload
+     */
+    public static void selectOldPhoto(Activity activity, String key) {
+        // First remove the old image
+        removeFromCache(activity, key);
+        MusicUtils.refresh();
+    }
+
+    /**
+     * @param sortOrder values are mostly derived from SortOrder.class or could also be any sql
+     *                  order clause
+     * @return
+     */
+    public static boolean isSortOrderDesending(String sortOrder) {
+        return sortOrder.endsWith(" DESC");
+    }
+
+    /**
+     * Takes a collection of items and builds a comma-separated list of them
+     *
+     * @param items collection of items
+     * @return comma-separted list of items
+     */
+    public static final <E> String buildCollectionAsString(Collection<E> items) {
+        Iterator<E> iterator = items.iterator();
+        StringBuilder str = new StringBuilder();
+        if (iterator.hasNext()) {
+            str.append(iterator.next());
+            while (iterator.hasNext()) {
+                str.append(",");
+                str.append(iterator.next());
+            }
+        }
+
+        return str.toString();
+    }
+
+    public static final class ServiceBinder implements ServiceConnection {
+        private final ServiceConnection mCallback;
+        private final Context mContext;
+
+        /**
+         * Constructor of <code>ServiceBinder</code>
+         *
+         * @param context The {@link ServiceConnection} to use
+         */
+        public ServiceBinder(final ServiceConnection callback, final Context context) {
+            mCallback = callback;
+            mContext = context;
+        }
+
+        @Override
+        public void onServiceConnected(final ComponentName className, final IBinder service) {
+            mService = IElevenService.Stub.asInterface(service);
+            if (mCallback != null) {
+                mCallback.onServiceConnected(className, service);
+            }
+            MusicUtils.initPlaybackServiceWithSettings(mContext);
+        }
+
+        @Override
+        public void onServiceDisconnected(final ComponentName className) {
+            if (mCallback != null) {
+                mCallback.onServiceDisconnected(className);
+            }
+            mService = null;
+        }
+    }
+
+    public static final class ServiceToken {
+        public ContextWrapper mWrappedContext;
+
+        /**
+         * Constructor of <code>ServiceToken</code>
+         *
+         * @param context The {@link ContextWrapper} to use
+         */
+        public ServiceToken(final ContextWrapper context) {
+            mWrappedContext = context;
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/NavUtils.java b/twelve/src/main/java/com/dolzzo/twelve/utils/NavUtils.java
new file mode 100755
index 0000000000..10672a7361
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/NavUtils.java
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.utils;
+
+import android.app.Activity;
+import android.app.SearchManager;
+import android.content.ActivityNotFoundException;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.media.audiofx.AudioEffect;
+import android.os.Bundle;
+import android.provider.MediaStore;
+import android.widget.Toast;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.activities.HomeActivity;
+import com.dolzzo.twelve.ui.activities.SearchActivity;
+import com.dolzzo.twelve.ui.activities.SettingsActivity;
+
+/**
+ * Various navigation helpers.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public final class NavUtils {
+
+    /**
+     * Opens the profile of an artist.
+     *
+     * @param context    The {@link Activity} to use.
+     * @param artistName The name of the artist
+     */
+    public static void openArtistProfile(final Activity context, final String artistName) {
+        // Create a new bundle to transfer the artist info
+        final Bundle bundle = new Bundle();
+        bundle.putLong(Config.ID, MusicUtils.getIdForArtist(context, artistName));
+        bundle.putString(Config.MIME_TYPE, MediaStore.Audio.Artists.CONTENT_TYPE);
+        bundle.putString(Config.ARTIST_NAME, artistName);
+
+        // Create the intent to launch the profile activity
+        final Intent intent = new Intent(context, HomeActivity.class);
+        intent.setAction(HomeActivity.ACTION_VIEW_ARTIST_DETAILS);
+        intent.putExtras(bundle);
+        context.startActivity(intent);
+    }
+
+    /**
+     * Opens the profile of an album.
+     *
+     * @param context    The {@link Activity} to use.
+     * @param albumName  The name of the album
+     * @param artistName The name of the album artist
+     * @param albumId    The id of the album
+     */
+    public static void openAlbumProfile(final Activity context,
+                                        final String albumName, final String artistName, final long albumId) {
+
+        // Create a new bundle to transfer the album info
+        final Bundle bundle = new Bundle();
+        bundle.putString(Config.ALBUM_YEAR, MusicUtils.getReleaseDateForAlbum(context, albumId));
+        bundle.putInt(Config.SONG_COUNT, MusicUtils.getSongCountForAlbumInt(context, albumId));
+        bundle.putString(Config.ARTIST_NAME, artistName);
+        bundle.putString(Config.MIME_TYPE, MediaStore.Audio.Albums.CONTENT_TYPE);
+        bundle.putLong(Config.ID, albumId);
+        bundle.putString(Config.NAME, albumName);
+
+        // Create the intent to launch the profile activity
+        final Intent intent = new Intent(context, HomeActivity.class);
+        intent.setAction(HomeActivity.ACTION_VIEW_ALBUM_DETAILS);
+        intent.putExtras(bundle);
+        context.startActivity(intent);
+    }
+
+    public static void openSmartPlaylist(final Activity context, final Config.SmartPlaylistType type) {
+        // Create the intent to launch the profile activity
+        final Intent intent = new Intent(context, HomeActivity.class);
+        intent.setAction(HomeActivity.ACTION_VIEW_SMART_PLAYLIST);
+        intent.putExtra(Config.SMART_PLAYLIST_TYPE, type.mId);
+        context.startActivity(intent);
+    }
+
+    /**
+     * Opens the playlist view
+     *
+     * @param context      The {@link Activity} to use.
+     * @param playlistId   the id of the playlist
+     * @param playlistName the playlist name
+     */
+    public static void openPlaylist(final Activity context, final long playlistId,
+                                    final String playlistName) {
+        final Bundle bundle = new Bundle();
+        bundle.putLong(Config.ID, playlistId);
+        bundle.putString(Config.MIME_TYPE, MediaStore.Audio.Playlists.CONTENT_TYPE);
+        bundle.putString(Config.NAME, playlistName);
+
+        // Create the intent to launch the profile activity
+        final Intent intent = new Intent(context, HomeActivity.class);
+        intent.setAction(HomeActivity.ACTION_VIEW_PLAYLIST_DETAILS);
+        intent.putExtras(bundle);
+        context.startActivity(intent);
+    }
+
+    /**
+     * @return the intent to launch the effects panel/dsp manager
+     */
+    private static Intent createEffectsIntent() {
+        final Intent effects = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);
+        effects.putExtra(AudioEffect.EXTRA_AUDIO_SESSION, MusicUtils.getAudioSessionId());
+        return effects;
+    }
+
+    /**
+     * Opens the sound effects panel or DSP manager in CM
+     *
+     * @param context     The {@link Activity} to use.
+     * @param requestCode The request code passed into startActivityForResult
+     */
+    public static void openEffectsPanel(final Activity context, final int requestCode) {
+        try {
+            // The google MusicFX apps need to be started using startActivityForResult
+            context.startActivityForResult(createEffectsIntent(), requestCode);
+        } catch (final ActivityNotFoundException notFound) {
+            Toast.makeText(context, context.getString(R.string.no_effects_for_you),
+                    Toast.LENGTH_SHORT).show();
+        }
+    }
+
+    /**
+     * @return true if there is an effects panel/DSK Manager
+     */
+    public static boolean hasEffectsPanel(final Activity activity) {
+        final PackageManager packageManager = activity.getPackageManager();
+        return packageManager.resolveActivity(createEffectsIntent(),
+                PackageManager.MATCH_DEFAULT_ONLY) != null;
+    }
+
+    /**
+     * Opens to {@link SettingsActivity}.
+     *
+     * @param activity The {@link Activity} to use.
+     */
+    public static void openSettings(final Activity activity) {
+        final Intent intent = new Intent(activity, SettingsActivity.class);
+        activity.startActivity(intent);
+    }
+
+    /**
+     * Opens to {@link com.dolzzo.twelve.ui.activities.SearchActivity}.
+     *
+     * @param activity The {@link Activity} to use.
+     * @param query    The search query.
+     */
+    public static void openSearch(final Activity activity, final String query) {
+        final Bundle bundle = new Bundle();
+        final Intent intent = new Intent(activity, SearchActivity.class);
+        intent.putExtra(SearchManager.QUERY, query);
+        intent.putExtras(bundle);
+        activity.startActivity(intent);
+    }
+
+    /**
+     * Opens to {@link com.dolzzo.twelve.ui.activities.HomeActivity}.
+     *
+     * @param activity The {@link Activity} to use.
+     */
+    public static void goHome(final Activity activity, final int browseIndex) {
+        final Intent intent = new Intent(activity, HomeActivity.class);
+        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK
+                | Intent.FLAG_ACTIVITY_NEW_TASK);
+        intent.putExtra(HomeActivity.EXTRA_BROWSE_PAGE_IDX, browseIndex);
+        activity.startActivity(intent);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/PlaylistPopupMenuHelper.java b/twelve/src/main/java/com/dolzzo/twelve/utils/PlaylistPopupMenuHelper.java
new file mode 100755
index 0000000000..f057810952
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/PlaylistPopupMenuHelper.java
@@ -0,0 +1,114 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.utils;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ContentUris;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.net.Uri;
+import android.provider.MediaStore;
+import android.support.v4.app.FragmentManager;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.Config.SmartPlaylistType;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.model.Playlist;
+
+public abstract class PlaylistPopupMenuHelper extends PopupMenuHelper {
+    private Playlist mPlaylist;
+
+    public PlaylistPopupMenuHelper(Activity activity, FragmentManager fragmentManager, PopupMenuType type) {
+        super(activity, fragmentManager);
+        mType = type;
+    }
+
+    public abstract Playlist getPlaylist(int position);
+
+    @Override
+    public PopupMenuType onPreparePopupMenu(int position) {
+        mPlaylist = getPlaylist(position);
+        return mPlaylist.isSmartPlaylist() ?
+                PopupMenuType.SmartPlaylist : PopupMenuType.Playlist;
+    }
+
+    public void updateName(String name) {
+        if (mPlaylist != null) {
+            mPlaylist.mPlaylistName = name;
+        }
+    }
+
+    @Override
+    protected long getSourceId() {
+        return mPlaylist.mPlaylistId;
+    }
+
+    @Override
+    protected Config.IdType getSourceType() {
+        return Config.IdType.Playlist;
+    }
+
+    @Override
+    protected long[] getIdList() {
+        if (mPlaylist.isSmartPlaylist()) {
+            return MusicUtils.getSongListForSmartPlaylist(mActivity,
+                    SmartPlaylistType.getTypeById(getSourceId()));
+        } else {
+            return MusicUtils.getSongListForPlaylist(mActivity, getSourceId());
+        }
+    }
+
+    @Override
+    protected void onDeleteClicked() {
+        // TODO: do this with a proper DialogFragment
+        buildDeleteDialog(getId(), mPlaylist.mPlaylistName).show();
+    }
+
+    @Override // FIXME: is this really the right thing?
+    protected long getId() {
+        return mPlaylist.mPlaylistId;
+    }
+
+    /**
+     * Create a new {@link AlertDialog} for easy playlist deletion
+     *
+     * @param playlistName The title of the playlist being deleted
+     * @param playlistId   The ID of the playlist being deleted
+     * @return A new {@link AlertDialog} used to delete playlists
+     */
+    private final AlertDialog buildDeleteDialog(final long playlistId, final String playlistName) {
+        return new AlertDialog.Builder(mActivity)
+                .setTitle(mActivity.getString(R.string.delete_dialog_title, playlistName))
+                .setPositiveButton(R.string.context_menu_delete, new OnClickListener() {
+
+                    @Override
+                    public void onClick(final DialogInterface dialog, final int which) {
+                        final Uri mUri = ContentUris.withAppendedId(
+                                MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
+                                playlistId);
+                        mActivity.getContentResolver().delete(mUri, null, null);
+                        MusicUtils.refresh();
+                    }
+                }).setNegativeButton(R.string.cancel, new OnClickListener() {
+
+                    @Override
+                    public void onClick(final DialogInterface dialog, final int which) {
+                        dialog.dismiss();
+                    }
+                }).setMessage(R.string.cannot_be_undone).create();
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/PopupMenuHelper.java b/twelve/src/main/java/com/dolzzo/twelve/utils/PopupMenuHelper.java
new file mode 100755
index 0000000000..1d4b6c678f
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/PopupMenuHelper.java
@@ -0,0 +1,401 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.utils;
+
+import android.app.Activity;
+import android.support.v4.app.FragmentManager;
+import android.support.v7.view.menu.MenuBuilder;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.PopupMenu;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.menu.CreateNewPlaylist;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.menu.RenamePlaylist;
+import com.dolzzo.twelve.provider.RecentStore;
+
+import java.util.TreeSet;
+
+/**
+ * Simple helper class that does most of the popup menu inflating and handling
+ * It has a few hooks around so that if the class wants customization they can add it on
+ * without changing this class too much
+ */
+public abstract class PopupMenuHelper implements PopupMenu.OnMenuItemClickListener {
+    protected Activity mActivity;
+    protected PopupMenuType mType;
+    protected FragmentManager mFragmentManager;
+
+    public PopupMenuHelper(final Activity activity, final FragmentManager fragmentManager) {
+        mActivity = activity;
+        mFragmentManager = fragmentManager;
+    }
+
+    /**
+     * Gets the default menu items for the specified type
+     *
+     * @param type of pop up menu to create
+     * @return list of menu items to inflate
+     */
+    private static int[] getIdsForType(PopupMenuType type) {
+        switch (type) {
+            case Artist:
+                return new int[]{
+                        FragmentMenuItems.PLAY_SELECTION,
+                        FragmentMenuItems.ADD_TO_QUEUE,
+                        FragmentMenuItems.ADD_TO_PLAYLIST,
+                        FragmentMenuItems.DELETE,
+                        FragmentMenuItems.CHANGE_IMAGE,
+                };
+            case Album:
+                return new int[]{
+                        FragmentMenuItems.PLAY_SELECTION,
+                        FragmentMenuItems.ADD_TO_QUEUE,
+                        FragmentMenuItems.ADD_TO_PLAYLIST,
+                        FragmentMenuItems.MORE_BY_ARTIST,
+                        FragmentMenuItems.DELETE,
+                        FragmentMenuItems.CHANGE_IMAGE,
+                };
+            case Song:
+                return new int[]{
+                        FragmentMenuItems.PLAY_SELECTION,
+                        FragmentMenuItems.PLAY_NEXT,
+                        FragmentMenuItems.PLAY_ALBUM,
+                        FragmentMenuItems.ADD_TO_QUEUE,
+                        FragmentMenuItems.ADD_TO_PLAYLIST,
+                        FragmentMenuItems.MORE_BY_ARTIST,
+                        FragmentMenuItems.USE_AS_RINGTONE,
+                        FragmentMenuItems.DELETE,
+                };
+            case Playlist:
+                return new int[]{
+                        FragmentMenuItems.PLAY_SELECTION,
+                        FragmentMenuItems.ADD_TO_QUEUE,
+                        FragmentMenuItems.RENAME_PLAYLIST,
+                        FragmentMenuItems.DELETE,
+                };
+            case SmartPlaylist:
+                return new int[]{
+                        FragmentMenuItems.PLAY_SELECTION,
+                        FragmentMenuItems.ADD_TO_QUEUE,
+                };
+            case SearchResult:
+                return new int[]{
+                        FragmentMenuItems.PLAY_SELECTION,
+                        FragmentMenuItems.ADD_TO_QUEUE,
+                        FragmentMenuItems.ADD_TO_PLAYLIST,
+                };
+            case Queue:
+                return new int[]{
+                        FragmentMenuItems.PLAY_NEXT,
+                        FragmentMenuItems.ADD_TO_PLAYLIST,
+                        FragmentMenuItems.REMOVE_FROM_QUEUE,
+                        FragmentMenuItems.MORE_BY_ARTIST,
+                        FragmentMenuItems.USE_AS_RINGTONE,
+                        FragmentMenuItems.DELETE,
+                };
+        }
+
+        return null;
+    }
+
+    /**
+     * Gets the string resource for an id
+     *
+     * @param id the menu id
+     * @return string resource id
+     */
+    public static int getStringResourceForId(final int id) {
+        switch (id) {
+            case FragmentMenuItems.REMOVE_FROM_RECENT:
+                return R.string.context_menu_remove_from_recent;
+            case FragmentMenuItems.PLAY_SELECTION:
+                return R.string.context_menu_play_selection;
+            case FragmentMenuItems.ADD_TO_QUEUE:
+                return R.string.add_to_queue;
+            case FragmentMenuItems.ADD_TO_PLAYLIST:
+                return R.string.add_to_playlist;
+            case FragmentMenuItems.NEW_PLAYLIST:
+                return R.string.new_playlist;
+            case FragmentMenuItems.RENAME_PLAYLIST:
+                return R.string.context_menu_rename_playlist;
+            case FragmentMenuItems.PLAYLIST_SELECTED:
+                return 0; // no string here expected
+            case FragmentMenuItems.MORE_BY_ARTIST:
+                return R.string.context_menu_more_by_artist;
+            case FragmentMenuItems.DELETE:
+                return R.string.context_menu_delete;
+            case FragmentMenuItems.FETCH_ARTIST_IMAGE:
+                return R.string.context_menu_fetch_artist_image;
+            case FragmentMenuItems.FETCH_ALBUM_ART:
+                return R.string.context_menu_fetch_album_art;
+            case FragmentMenuItems.USE_AS_RINGTONE:
+                return R.string.context_menu_use_as_ringtone;
+            case FragmentMenuItems.REMOVE_FROM_PLAYLIST:
+                return R.string.context_menu_remove_from_playlist;
+            case FragmentMenuItems.REMOVE_FROM_QUEUE:
+                return R.string.remove_from_queue;
+            case FragmentMenuItems.PLAY_NEXT:
+                return R.string.context_menu_play_next;
+            case FragmentMenuItems.PLAY_ALBUM:
+                return R.string.context_menu_play_album;
+            case FragmentMenuItems.CHANGE_IMAGE:
+                return R.string.context_menu_change_image;
+        }
+
+        return 0;
+    }
+
+    /**
+     * Call this to inflate and show the pop up menu
+     *
+     * @param view     the view to anchor the popup menu against
+     * @param position the item that was clicked in the popup menu (or -1 if not relevant)
+     */
+    public void showPopupMenu(final View view, final int position) {
+        // create the popup menu
+        PopupMenu popupMenu = new PopupMenu(mActivity, view);
+        final Menu menu = popupMenu.getMenu();
+
+        // hook up the click listener
+        popupMenu.setOnMenuItemClickListener(this);
+
+        // figure what type of pop up menu it is
+        mType = onPreparePopupMenu(position);
+        if (mType != null) {
+            // inflate the menu
+            createPopupMenu(menu);
+            // show it
+            popupMenu.show();
+        }
+    }
+
+    /**
+     * This function allows classes to setup any variables before showing the popup menu
+     *
+     * @param position the position passed in from showPopupMenu
+     * @return the pop up menu type, or null if we shouldn't show a pop up menu
+     */
+    public abstract PopupMenuType onPreparePopupMenu(final int position);
+
+    /**
+     * @return the list of ids needed for some menu actions like playing a list of songs
+     */
+    protected abstract long[] getIdList();
+
+    protected abstract long getSourceId();
+
+    protected abstract Config.IdType getSourceType();
+
+    /**
+     * @return the group id to be used for pop up menu inflating
+     */
+    protected int getGroupId() {
+        return 0;
+    }
+
+    /**
+     * called when the delete item is pressed.
+     */
+    protected void onDeleteClicked() {
+        throw new UnsupportedOperationException("Method Not Implemented!");
+    }
+
+    /**
+     * @return the artist name (when needed) for "more by this artist"
+     */
+    protected String getArtistName() {
+        throw new UnsupportedOperationException("Method Not Implemented!");
+    }
+
+    /**
+     * @return the single id that is needed for the "set as my ringtone"
+     */
+    protected long getId() {
+        long[] idList = getIdList();
+        if (idList.length == 1) {
+            return idList[0];
+        }
+
+        throw new UnsupportedOperationException("Method Not Implemented!");
+    }
+
+    /**
+     * Called when the user clicks "remove from playlist"
+     */
+    protected void removeFromPlaylist() {
+        throw new UnsupportedOperationException("Method Not Implemented!");
+    }
+
+    /**
+     * Called when the user clicks "remove from queue"
+     */
+    protected void removeFromQueue() {
+        throw new UnsupportedOperationException("Method Not Implemented!");
+    }
+
+    /**
+     * Called when the user clicks "play next".  Has a default implementation
+     */
+    protected void playNext() {
+        MusicUtils.playNext(getIdList(), getSourceId(), getSourceType());
+    }
+
+    /**
+     * Called when the user clicks "play album".
+     */
+    protected void playAlbum() {
+        throw new UnsupportedOperationException("Method Not Implemented!");
+    }
+
+    /**
+     * Creates the pop up menu by inflating the menu items
+     *
+     * @param menu Menu to use for adding to
+     */
+    public void createPopupMenu(final Menu menu) {
+        TreeSet<Integer> menuItems = new TreeSet<Integer>();
+
+        // get the default items and add them
+        int[] defaultItems = getIdsForType(mType);
+        if (defaultItems != null) {
+            for (int id : defaultItems) {
+                menuItems.add(id);
+            }
+        }
+
+        updateMenuIds(mType, menuItems);
+
+        for (int id : menuItems) {
+            addToMenu(menu, id, getAdditionalStringResourceForId(id));
+        }
+    }
+
+    /**
+     * Allows containing classes to add/remove ids to the menu
+     *
+     * @param type the pop up menu type
+     * @param set  the treeset to add/remove menu items
+     */
+    protected void updateMenuIds(PopupMenuType type, TreeSet<Integer> set) {
+        // do nothing
+    }
+
+    /**
+     * Gets the string resource for an id - if the string resource doesn't exist in this class
+     * the containing class can override this method
+     *
+     * @param id the menu id
+     * @return string resource id
+     */
+    protected int getAdditionalStringResourceForId(final int id) {
+        return getStringResourceForId(id);
+    }
+
+    /**
+     * Simple helper function for adding an item to the menu
+     */
+    public void addToMenu(final Menu menu, final int id, final int resourceId) {
+        menu.add(getGroupId(), id, id /*as order*/, mActivity.getString(resourceId));
+    }
+
+    @Override
+    public boolean onMenuItemClick(MenuItem item) {
+        if (item.getGroupId() == getGroupId()) {
+            switch (item.getItemId()) {
+                case FragmentMenuItems.REMOVE_FROM_RECENT:
+                    RecentStore.getInstance(mActivity).removeItem(getId());
+                    MusicUtils.refresh();
+                    return true;
+                case FragmentMenuItems.PLAY_SELECTION:
+                    MusicUtils.playAll(mActivity, getIdList(), 0, getSourceId(), getSourceType(),
+                            false);
+                    return true;
+                case FragmentMenuItems.ADD_TO_QUEUE:
+                    MusicUtils.addToQueue(mActivity, getIdList(), getSourceId(), getSourceType());
+                    return true;
+                case FragmentMenuItems.ADD_TO_PLAYLIST:
+                    ContextMenuBuilder builder = new ContextMenuBuilder(mActivity);
+                    MusicUtils.makePlaylistMenu(mActivity, getGroupId(), builder);
+                    builder.setHeaderTitle(R.string.add_to_playlist);
+                    builder.setCallback(new MenuBuilder.Callback() {
+                        @Override
+                        public boolean onMenuItemSelected(MenuBuilder menu, MenuItem item) {
+                            return onMenuItemClick(item);
+                        }
+
+                        @Override
+                        public void onMenuModeChange(MenuBuilder menu) {
+                            // do nothing
+                        }
+                    });
+                    builder.show(null, null);
+                    return true;
+                case FragmentMenuItems.NEW_PLAYLIST:
+                    CreateNewPlaylist.getInstance(getIdList()).show(
+                            mFragmentManager, "CreatePlaylist");
+                    return true;
+                case FragmentMenuItems.RENAME_PLAYLIST:
+                    RenamePlaylist.getInstance(getId()).show(
+                            mFragmentManager, "RenameDialog");
+                    return true;
+                case FragmentMenuItems.PLAYLIST_SELECTED:
+                    final long mPlaylistId = item.getIntent().getLongExtra("playlist", 0);
+                    MusicUtils.addToPlaylist(mActivity, getIdList(), mPlaylistId);
+                    return true;
+                case FragmentMenuItems.MORE_BY_ARTIST:
+                    NavUtils.openArtistProfile(mActivity, getArtistName());
+                    return true;
+                case FragmentMenuItems.DELETE:
+                    onDeleteClicked();
+                    return true;
+                case FragmentMenuItems.USE_AS_RINGTONE:
+                    MusicUtils.setRingtone(mActivity, getId());
+                    return true;
+                case FragmentMenuItems.REMOVE_FROM_PLAYLIST:
+                    removeFromPlaylist();
+                    return true;
+                case FragmentMenuItems.REMOVE_FROM_QUEUE:
+                    removeFromQueue();
+                    return true;
+                case FragmentMenuItems.PLAY_NEXT:
+                    playNext();
+                    return true;
+                case FragmentMenuItems.PLAY_ALBUM:
+                    playAlbum();
+                    return true;
+                default:
+                    break;
+            }
+        }
+
+        return false;
+    }
+
+    // the different types of pop up menus
+    public static enum PopupMenuType {
+        Artist,
+        Album,
+        Song,
+        Playlist,
+        SmartPlaylist,
+        SearchResult,
+        Queue,
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/PreferenceUtils.java b/twelve/src/main/java/com/dolzzo/twelve/utils/PreferenceUtils.java
new file mode 100755
index 0000000000..d06ec375c4
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/PreferenceUtils.java
@@ -0,0 +1,351 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.utils;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
+import android.os.AsyncTask;
+import android.preference.PreferenceManager;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.ui.fragments.AlbumFragment;
+import com.dolzzo.twelve.ui.fragments.ArtistFragment;
+import com.dolzzo.twelve.ui.fragments.SongFragment;
+import com.dolzzo.twelve.ui.fragments.phone.MusicBrowserPhoneFragment;
+
+/**
+ * A collection of helpers designed to get and set various preferences across
+ * Apollo.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public final class PreferenceUtils {
+
+    /* Default start page (Artist page) */
+    public static final int DEFFAULT_PAGE = 2;
+
+    /* Saves the last page the pager was on in {@link MusicBrowserPhoneFragment} */
+    public static final String START_PAGE = "start_page";
+
+    // Sort order for the artist list
+    public static final String ARTIST_SORT_ORDER = "artist_sort_order";
+
+    // Sort order for the artist song list
+    public static final String ARTIST_SONG_SORT_ORDER = "artist_song_sort_order";
+
+    // Sort order for the artist album list
+    public static final String ARTIST_ALBUM_SORT_ORDER = "artist_album_sort_order";
+
+    // Sort order for the album list
+    public static final String ALBUM_SORT_ORDER = "album_sort_order";
+
+    // Sort order for the album song list
+    public static final String ALBUM_SONG_SORT_ORDER = "album_song_sort_order";
+
+    // Sort order for the song list
+    public static final String SONG_SORT_ORDER = "song_sort_order";
+
+    // Key used to download images only on Wi-Fi
+    public static final String ONLY_ON_WIFI = "only_on_wifi";
+
+    // Key that gives permissions to download missing album covers
+    public static final String DOWNLOAD_MISSING_ARTWORK = "download_missing_artwork";
+
+    // Key that gives permissions to download missing artist images
+    public static final String DOWNLOAD_MISSING_ARTIST_IMAGES = "download_missing_artist_images";
+
+    // Key used to set the overall theme color
+    public static final String DEFAULT_THEME_COLOR = "default_theme_color";
+
+    // datetime cutoff for determining which songs go in last added playlist
+    public static final String LAST_ADDED_CUTOFF = "last_added_cutoff";
+
+    // show lyrics option
+    public static final String SHOW_LYRICS = "show_lyrics";
+
+    // show visualizer flag
+    public static final String SHOW_VISUALIZER = "music_visualization";
+
+    // shake to play flag
+    public static final String SHAKE_TO_PLAY = "shake_to_play";
+
+    // show/hide album art on lockscreen
+    public static final String SHOW_ALBUM_ART_ON_LOCKSCREEN = "lockscreen_album_art";
+
+    private static PreferenceUtils sInstance;
+
+    private final SharedPreferences mPreferences;
+
+    /**
+     * Constructor for <code>PreferenceUtils</code>
+     *
+     * @param context The {@link Context} to use.
+     */
+    public PreferenceUtils(final Context context) {
+        mPreferences = PreferenceManager.getDefaultSharedPreferences(context);
+    }
+
+    /**
+     * @param context The {@link Context} to use.
+     * @return A singleton of this class
+     */
+    public static final PreferenceUtils getInstance(final Context context) {
+        if (sInstance == null) {
+            sInstance = new PreferenceUtils(context.getApplicationContext());
+        }
+        return sInstance;
+    }
+
+    /**
+     * Set the listener for preference change
+     *
+     * @param listener
+     */
+    public void setOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
+        mPreferences.registerOnSharedPreferenceChangeListener(listener);
+    }
+
+    /**
+     * Returns the last page the user was on when the app was exited.
+     *
+     * @return The page to start on when the app is opened.
+     */
+    public final int getStartPage() {
+        return mPreferences.getInt(START_PAGE, DEFFAULT_PAGE);
+    }
+
+    /**
+     * Saves the current page the user is on when they close the app.
+     *
+     * @param value The last page the pager was on when the onDestroy is called
+     *              in {@link MusicBrowserPhoneFragment}.
+     */
+    public void setStartPage(final int value) {
+        ApolloUtils.execute(false, new AsyncTask<Void, Void, Void>() {
+            @Override
+            protected Void doInBackground(final Void... unused) {
+                final SharedPreferences.Editor editor = mPreferences.edit();
+                editor.putInt(START_PAGE, value);
+                editor.apply();
+
+                return null;
+            }
+        }, (Void[]) null);
+    }
+
+    /**
+     * Sets the new theme color.
+     *
+     * @param value The new theme color to use.
+     */
+    public void setDefaultThemeColor(final int value) {
+        ApolloUtils.execute(false, new AsyncTask<Void, Void, Void>() {
+            @Override
+            protected Void doInBackground(final Void... unused) {
+                final SharedPreferences.Editor editor = mPreferences.edit();
+                editor.putInt(DEFAULT_THEME_COLOR, value);
+                editor.apply();
+
+                return null;
+            }
+        }, (Void[]) null);
+    }
+
+    /**
+     * Returns the current theme color.
+     *
+     * @param context The {@link Context} to use.
+     * @return The default theme color.
+     */
+    public final int getDefaultThemeColor(final Context context) {
+        return mPreferences.getInt(DEFAULT_THEME_COLOR,
+                context.getResources().getColor(R.color.blue));
+    }
+
+    /**
+     * @return True if the user has checked to only download images on Wi-Fi,
+     * false otherwise
+     */
+    public final boolean onlyOnWifi() {
+        return mPreferences.getBoolean(ONLY_ON_WIFI, true);
+    }
+
+    /**
+     * @return True if the user has checked to download missing album covers,
+     * false otherwise.
+     */
+    public final boolean downloadMissingArtwork() {
+        return mPreferences.getBoolean(DOWNLOAD_MISSING_ARTWORK, true);
+    }
+
+    /**
+     * @return True if the user has checked to download missing artist images,
+     * false otherwise.
+     */
+    public final boolean downloadMissingArtistImages() {
+        return mPreferences.getBoolean(DOWNLOAD_MISSING_ARTIST_IMAGES, true);
+    }
+
+    /**
+     * Saves the sort order for a list.
+     *
+     * @param key   Which sort order to change
+     * @param value The new sort order
+     */
+    private void setSortOrder(final String key, final String value) {
+        ApolloUtils.execute(false, new AsyncTask<Void, Void, Void>() {
+            @Override
+            protected Void doInBackground(final Void... unused) {
+                final SharedPreferences.Editor editor = mPreferences.edit();
+                editor.putString(key, value);
+                editor.apply();
+
+                return null;
+            }
+        }, (Void[]) null);
+    }
+
+    /**
+     * @return The sort order used for the artist list in {@link ArtistFragment}
+     */
+    public final String getArtistSortOrder() {
+        return mPreferences.getString(ARTIST_SORT_ORDER, SortOrder.ArtistSortOrder.ARTIST_A_Z);
+    }
+
+    /**
+     * Sets the sort order for the artist list.
+     *
+     * @param value The new sort order
+     */
+    public void setArtistSortOrder(final String value) {
+        setSortOrder(ARTIST_SORT_ORDER, value);
+    }
+
+    /**
+     * @return The sort order used for the artist song list in
+     * {@link ArtistDetailSongAdapter}
+     */
+    public final String getArtistSongSortOrder() {
+        return mPreferences.getString(ARTIST_SONG_SORT_ORDER,
+                SortOrder.ArtistSongSortOrder.SONG_A_Z);
+    }
+
+    /**
+     * Sets the sort order for the artist song list.
+     *
+     * @param value The new sort order
+     */
+    public void setArtistSongSortOrder(final String value) {
+        setSortOrder(ARTIST_SONG_SORT_ORDER, value);
+    }
+
+    /**
+     * @return The sort order used for the artist album list in
+     * {@link com.dolzzo.twelve.ui.fragments.ArtistDetailFragment}
+     */
+    public final String getArtistAlbumSortOrder() {
+        return mPreferences.getString(ARTIST_ALBUM_SORT_ORDER,
+                SortOrder.ArtistAlbumSortOrder.ALBUM_A_Z);
+    }
+
+    /**
+     * Sets the sort order for the artist album list.
+     *
+     * @param value The new sort order
+     */
+    public void setArtistAlbumSortOrder(final String value) {
+        setSortOrder(ARTIST_ALBUM_SORT_ORDER, value);
+    }
+
+    /**
+     * @return The sort order used for the album list in {@link AlbumFragment}
+     */
+    public final String getAlbumSortOrder() {
+        return mPreferences.getString(ALBUM_SORT_ORDER, SortOrder.AlbumSortOrder.ALBUM_A_Z);
+    }
+
+    /**
+     * Sets the sort order for the album list.
+     *
+     * @param value The new sort order
+     */
+    public void setAlbumSortOrder(final String value) {
+        setSortOrder(ALBUM_SORT_ORDER, value);
+    }
+
+    /**
+     * @return The sort order used for the album song in
+     * {@link AlbumSongFragment}
+     */
+    public final String getAlbumSongSortOrder() {
+        return mPreferences.getString(ALBUM_SONG_SORT_ORDER,
+                SortOrder.AlbumSongSortOrder.SONG_TRACK_LIST);
+    }
+
+    /**
+     * Sets the sort order for the album song list.
+     *
+     * @param value The new sort order
+     */
+    public void setAlbumSongSortOrder(final String value) {
+        setSortOrder(ALBUM_SONG_SORT_ORDER, value);
+    }
+
+    /**
+     * @return The sort order used for the song list in {@link SongFragment}
+     */
+    public final String getSongSortOrder() {
+        return mPreferences.getString(SONG_SORT_ORDER, SortOrder.SongSortOrder.SONG_A_Z);
+    }
+
+    /**
+     * Sets the sort order for the song list.
+     *
+     * @param value The new sort order
+     */
+    public void setSongSortOrder(final String value) {
+        setSortOrder(SONG_SORT_ORDER, value);
+    }
+
+    public long getLastAddedCutoff() {
+        return mPreferences.getLong(LAST_ADDED_CUTOFF, 0L);
+    }
+
+    /**
+     * @parm lastAddedMillis timestamp in millis used as a cutoff for last added playlist
+     */
+    public void setLastAddedCutoff(long lastAddedMillis) {
+        mPreferences.edit().putLong(LAST_ADDED_CUTOFF, lastAddedMillis).commit();
+    }
+
+    /**
+     * @return Whether we want to show lyrics
+     */
+    public final boolean getShowLyrics() {
+        return mPreferences.getBoolean(SHOW_LYRICS, true);
+    }
+
+    public boolean getShowVisualizer() {
+        return mPreferences.getBoolean(SHOW_VISUALIZER, true);
+    }
+
+    public boolean getShakeToPlay() {
+        return mPreferences.getBoolean(SHAKE_TO_PLAY, false);
+    }
+
+    public boolean getShowAlbumArtOnLockscreen() {
+        return mPreferences.getBoolean(SHOW_ALBUM_ART_ON_LOCKSCREEN, true);
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/SectionCreatorUtils.java b/twelve/src/main/java/com/dolzzo/twelve/utils/SectionCreatorUtils.java
new file mode 100755
index 0000000000..ea302717b9
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/SectionCreatorUtils.java
@@ -0,0 +1,690 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.utils;
+
+import android.content.Context;
+import android.text.TextUtils;
+
+import com.dolzzo.twelve.Config;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.model.Album;
+import com.dolzzo.twelve.model.Artist;
+import com.dolzzo.twelve.model.SearchResult;
+import com.dolzzo.twelve.model.Song;
+
+import java.util.List;
+import java.util.TreeMap;
+
+/**
+ * This Utils class contains code that compares two different items and determines whether
+ * a section should be created
+ */
+public class SectionCreatorUtils {
+    /**
+     * This creates the sections given a list of items and the comparison algorithm
+     *
+     * @param list       The list of items to analyze
+     * @param comparator The comparison function to use
+     * @param <T>        the type of item to compare
+     * @return Creates a TreeMap of indices (if the headers were part of the list) to section labels
+     */
+    public static <T> TreeMap<Integer, Section> createSections(final List<T> list,
+                                                               final IItemCompare<T> comparator) {
+        if (list != null && list.size() > 0) {
+            TreeMap<Integer, Section> sections = new TreeMap<Integer, Section>();
+            for (int i = 0; i < list.size() + 1; i++) {
+                T first = (i == 0 ? null : list.get(i - 1));
+                T second = (i == list.size() ? null : list.get(i));
+
+                // create the footer first because if we need both it should be footer,header,item
+                // not header,footer,item
+                if (first != null) {
+                    String footer = comparator.createSectionFooter(first, second, list, i - 1);
+                    if (footer != null) {
+                        // add sectionHeaders.size() to store the indices of the combined list
+                        sections.put(sections.size() + i, new Section(SectionType.Footer, footer));
+                    }
+                }
+
+                if (second != null) {
+                    String header = comparator.createSectionHeader(first, second, list, i - 1);
+                    if (header != null) {
+                        // add sectionHeaders.size() to store the indices of the combined list
+                        sections.put(sections.size() + i, new Section(SectionType.Header, header));
+                        // stop section creation
+                        if (comparator.shouldStopSectionCreation()) {
+                            break;
+                        }
+                    }
+                }
+            }
+
+            return sections;
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns an artist comparison based on the current sort
+     *
+     * @param context Context for string generation
+     * @return the artist comparison method
+     */
+    public static IItemCompare<Artist> createArtistComparison(final Context context) {
+        IItemCompare<Artist> sectionCreator = null;
+
+        String sortOrder = PreferenceUtils.getInstance(context).getArtistSortOrder();
+        if (sortOrder.equals(SortOrder.ArtistSortOrder.ARTIST_A_Z)
+                || sortOrder.equals(SortOrder.ArtistSortOrder.ARTIST_Z_A)) {
+            sectionCreator = new SectionCreatorUtils.LocalizedCompare<Artist>(context) {
+                @Override
+                public String getString(Artist item) {
+                    return item.mArtistName;
+                }
+
+                @Override
+                public String createHeaderLabel(Artist item) {
+                    if (item.mBucketLabel != null) {
+                        return super.createHeaderLabel(item.mBucketLabel);
+                    }
+
+                    return super.createHeaderLabel(item);
+                }
+            };
+        } else if (sortOrder.equals(SortOrder.ArtistSortOrder.ARTIST_NUMBER_OF_ALBUMS)) {
+            sectionCreator = new SectionCreatorUtils.NumberOfAlbumsCompare<Artist>(context) {
+                @Override
+                public int getInt(Artist item) {
+                    return item.mAlbumNumber;
+                }
+            };
+        } else if (sortOrder.equals(SortOrder.ArtistSortOrder.ARTIST_NUMBER_OF_SONGS)) {
+            sectionCreator = new NumberOfSongsCompare<Artist>(context) {
+                @Override
+                public int getInt(Artist item) {
+                    return item.mSongNumber;
+                }
+            };
+        }
+
+        return sectionCreator;
+    }
+
+    /**
+     * Returns an album comparison based on the current sort
+     *
+     * @param context Context for string generation
+     * @return the album comparison method
+     */
+    public static IItemCompare<Album> createAlbumComparison(final Context context) {
+        IItemCompare<Album> sectionCreator = null;
+
+        String sortOrder = PreferenceUtils.getInstance(context).getAlbumSortOrder();
+        if (sortOrder.equals(SortOrder.AlbumSortOrder.ALBUM_A_Z)
+                || sortOrder.equals(SortOrder.AlbumSortOrder.ALBUM_Z_A)) {
+            sectionCreator = new LocalizedCompare<Album>(context) {
+                @Override
+                public String getString(Album item) {
+                    return item.mAlbumName;
+                }
+
+                @Override
+                public String createHeaderLabel(Album item) {
+                    if (item.mBucketLabel != null) {
+                        return super.createHeaderLabel(item.mBucketLabel);
+                    }
+
+                    return super.createHeaderLabel(item);
+                }
+            };
+        } else if (sortOrder.equals(SortOrder.AlbumSortOrder.ALBUM_ARTIST)) {
+            sectionCreator = new LocalizedCompare<Album>(context) {
+                @Override
+                public String getString(Album item) {
+                    return item.mArtistName;
+                }
+
+                @Override
+                public String createHeaderLabel(Album item) {
+                    if (item.mBucketLabel != null) {
+                        return super.createHeaderLabel(item.mBucketLabel);
+                    }
+
+                    return super.createHeaderLabel(item);
+                }
+            };
+        } else if (sortOrder.equals(SortOrder.AlbumSortOrder.ALBUM_NUMBER_OF_SONGS)) {
+            sectionCreator = new NumberOfSongsCompare<Album>(context) {
+                @Override
+                public int getInt(Album item) {
+                    return item.mSongNumber;
+                }
+            };
+        } else if (sortOrder.equals(SortOrder.AlbumSortOrder.ALBUM_YEAR)) {
+            sectionCreator = new IntCompare<Album>() {
+                private static final int INVALID_YEAR = -1;
+
+                @Override
+                public int getInt(Album item) {
+                    // if we don't have a year, treat it as invalid
+                    if (item.mYear == null) {
+                        return INVALID_YEAR;
+                    }
+
+                    int year = Integer.valueOf(item.mYear);
+
+                    // if the year is extremely low, treat it as invalid too
+                    if (MusicUtils.isInvalidYear(year)) {
+                        return INVALID_YEAR;
+                    }
+
+                    return year;
+                }
+
+                @Override
+                public String createHeaderLabel(Album item) {
+                    if (MusicUtils.isInvalidYear(getInt(item))) {
+                        return context.getString(R.string.header_unknown_year);
+                    }
+
+                    return item.mYear;
+                }
+            };
+        }
+
+        return sectionCreator;
+    }
+
+    /**
+     * Returns an song comparison based on the current sort
+     *
+     * @param context Context for string generation
+     * @return the song comparison method
+     */
+    public static IItemCompare<Song> createSongComparison(final Context context) {
+        IItemCompare<Song> sectionCreator = null;
+
+        String sortOrder = PreferenceUtils.getInstance(context).getSongSortOrder();
+
+        // doesn't make sense to have headers for SONG_FILENAME
+        // so we will not return a sectionCreator for that one
+        if (sortOrder.equals(SortOrder.SongSortOrder.SONG_A_Z)
+                || sortOrder.equals(SortOrder.SongSortOrder.SONG_Z_A)) {
+            sectionCreator = new LocalizedCompare<Song>(context) {
+                @Override
+                public String getString(Song item) {
+                    return item.mSongName;
+                }
+
+                @Override
+                public String createHeaderLabel(Song item) {
+                    if (item.mBucketLabel != null) {
+                        return super.createHeaderLabel(item.mBucketLabel);
+                    }
+
+                    return super.createHeaderLabel(item);
+                }
+            };
+        } else if (sortOrder.equals(SortOrder.SongSortOrder.SONG_ALBUM)) {
+            sectionCreator = new LocalizedCompare<Song>(context) {
+                @Override
+                public String getString(Song item) {
+                    return item.mAlbumName;
+                }
+
+                @Override
+                public String createHeaderLabel(Song item) {
+                    if (item.mBucketLabel != null) {
+                        return super.createHeaderLabel(item.mBucketLabel);
+                    }
+
+                    return super.createHeaderLabel(item);
+                }
+            };
+        } else if (sortOrder.equals(SortOrder.SongSortOrder.SONG_ARTIST)) {
+            sectionCreator = new LocalizedCompare<Song>(context) {
+                @Override
+                public String getString(Song item) {
+                    return item.mArtistName;
+                }
+
+                @Override
+                public String createHeaderLabel(Song item) {
+                    if (item.mBucketLabel != null) {
+                        return super.createHeaderLabel(item.mBucketLabel);
+                    }
+
+                    return super.createHeaderLabel(item);
+                }
+            };
+        } else if (sortOrder.equals(SortOrder.SongSortOrder.SONG_DURATION)) {
+            sectionCreator = new DurationCompare<Song>(context) {
+                @Override
+                public int getInt(Song item) {
+                    return item.mDuration;
+                }
+            };
+        } else if (sortOrder.equals(SortOrder.SongSortOrder.SONG_YEAR)) {
+            sectionCreator = new SectionCreatorUtils.IntCompare<Song>() {
+                @Override
+                public int getInt(Song item) {
+                    return item.mYear;
+                }
+
+                @Override
+                public String createHeaderLabel(Song item) {
+                    // I have seen tracks in my library where it would return 0 or 2
+                    // so have this check to return a more friendly label in that case
+                    if (MusicUtils.isInvalidYear(item.mYear)) {
+                        return context.getString(R.string.header_unknown_year);
+                    }
+
+                    return super.createHeaderLabel(item);
+                }
+            };
+        }
+
+        return sectionCreator;
+    }
+
+    /**
+     * Returns an song comparison based on the current sort
+     *
+     * @param context Context for string generation
+     * @return the song comparison method
+     */
+    public static IItemCompare<SearchResult> createSearchResultComparison(final Context context) {
+        return new IItemCompare<SearchResult>() {
+
+            @Override
+            public String createSectionHeader(SearchResult first, SearchResult second) {
+                if (first == null || first.mType != second.mType) {
+                    return createHeaderLabel(second);
+                }
+
+                return null;
+            }
+
+            @Override
+            public String createHeaderLabel(SearchResult item) {
+                switch (item.mType) {
+                    case Artist:
+                        return context.getString(R.string.page_artists);
+                    case Album:
+                        return context.getString(R.string.page_albums);
+                    case Song:
+                        return context.getString(R.string.page_songs);
+                    case Playlist:
+                        return context.getString(R.string.page_playlists);
+                }
+
+                return null;
+            }
+
+            @Override
+            public String createSectionFooter(SearchResult first, SearchResult second,
+                                              List<SearchResult> items, int firstIndex) {
+                if (second == null ||
+                        (first != null && first.mType != second.mType)) {
+                    // if we don't have SEARCH_NUM_RESULTS_TO_GET # of the same type of items
+                    // then we don't have enough to show the footer.  For example, if we show 5
+                    // items but only the last 2 items are artists, that means we only have 2
+                    // so there is no point in showing the "Show All" footer
+                    // We start from 1 because we don't need to count
+                    // the first item itself
+                    for (int i = 1; i < Config.SEARCH_NUM_RESULTS_TO_GET; i++) {
+                        if (firstIndex - i < 0 || items.get(firstIndex - i).mType != first.mType) {
+                            return null;
+                        }
+                    }
+
+                    return createFooterLabel(first);
+                }
+
+                return null;
+            }
+
+            @Override
+            public String createFooterLabel(SearchResult item) {
+                switch (item.mType) {
+                    case Artist:
+                        return context.getString(R.string.footer_search_artists);
+                    case Album:
+                        return context.getString(R.string.footer_search_albums);
+                    case Song:
+                        return context.getString(R.string.footer_search_songs);
+                    case Playlist:
+                        return context.getString(R.string.footer_search_playlists);
+                }
+
+                return null;
+            }
+        };
+    }
+
+    public enum SectionType {
+        Header,
+        Footer
+    }
+
+    public static class Section {
+        public SectionType mType;
+        public String mIdentifier;
+
+        public Section(final SectionType type, final String identifier) {
+            mType = type;
+            mIdentifier = identifier;
+        }
+    }
+
+    /**
+     * Interface to compare two items and create labels
+     *
+     * @param <T> type of item to compare
+     */
+    public static class IItemCompare<T> {
+        /**
+         * Compares to items and returns a section divider T if there should
+         * be a section divider between first and second
+         *
+         * @param first      the first element in the list.  If null, it is checking to see
+         *                   if we need a divider at the beginning of the list
+         * @param second     the second element in the list.
+         * @param items      the source list of items that we are creating headers from
+         * @param firstIndex index of the first item we are looking at
+         * @return String the expected separator label or null if none
+         */
+        public String createSectionHeader(T first, T second, List<T> items, int firstIndex) {
+            return createSectionHeader(first, second);
+        }
+
+        public String createSectionHeader(T first, T second) {
+            return null;
+        }
+
+        /**
+         * Compares to items and returns a section divider T if there should
+         * be a section divider between first and second
+         *
+         * @param first      the first element in the list.
+         * @param second     the second element in the list. If null, it is checking to see if we need
+         *                   a divider at the end of the list
+         * @param items      the source list of items that we are creating footers from
+         * @param firstIndex index of the first item we are looking at
+         * @return String the expected separator label or null if none
+         */
+        public String createSectionFooter(T first, T second, List<T> items, int firstIndex) {
+            return createSectionFooter(first, second);
+        }
+
+        public String createSectionFooter(T first, T second) {
+            return null;
+        }
+
+        /**
+         * Returns the section label that corresponds to this item
+         *
+         * @param item the item
+         * @return the section label that this label falls under
+         */
+        public String createHeaderLabel(T item) {
+            return null;
+        }
+
+        /**
+         * Returns the section label that corresponds to this item
+         *
+         * @param item the item
+         * @return the section label that this label falls under
+         */
+        public String createFooterLabel(T item) {
+            return null;
+        }
+
+        // partial sectioning helper functions
+
+        public boolean shouldStopSectionCreation() {
+            return false;
+        }
+    }
+
+    /**
+     * A localized String comparison implementation of IItemCompare
+     *
+     * @param <T> the type of item to compare
+     */
+    public static abstract class LocalizedCompare<T> extends IItemCompare<T> {
+        protected Context mContext;
+        private boolean mStopSectionCreation;
+
+        public LocalizedCompare(Context context) {
+            mContext = context;
+            mStopSectionCreation = false;
+        }
+
+        @Override
+        public String createSectionHeader(T first, T second) {
+            String secondLabel = createHeaderLabel(second);
+            // if we can't determine a good label then don't bother creating a section
+            if (secondLabel == null) {
+                // stop section creation as the items further down the list
+                mStopSectionCreation = true;
+                return null;
+            }
+
+            if (first == null || !secondLabel.equals(createHeaderLabel(first))) {
+                return secondLabel;
+            }
+
+            return null;
+        }
+
+        @Override
+        public String createHeaderLabel(T item) {
+            final String label = MusicUtils.getLocalizedBucketLetter(getString(item));
+            return createHeaderLabel(label);
+        }
+
+        protected String createHeaderLabel(final String label) {
+            if (TextUtils.isEmpty(label)) {
+                return mContext.getString(R.string.header_other);
+            }
+            return label;
+        }
+
+        public abstract String getString(T item);
+
+        @Override
+        public boolean shouldStopSectionCreation() {
+            return mStopSectionCreation;
+        }
+    }
+
+    /**
+     * A simple int comparison implementation of IItemCompare
+     *
+     * @param <T> the type of item to compare
+     */
+    public static abstract class IntCompare<T> extends IItemCompare<T> {
+        @Override
+        public String createSectionHeader(T first, T second) {
+            if (first == null || getInt(first) != getInt(second)) {
+                return createHeaderLabel(second);
+            }
+
+            return null;
+        }
+
+        @Override
+        public String createHeaderLabel(T item) {
+            return String.valueOf(getInt(item));
+        }
+
+        public abstract int getInt(T item);
+    }
+
+    /**
+     * A Bounded int comparison implementation of IntCompare
+     * Basically this will take ints and determine what bounds it falls into
+     * For example, 1-5 mintes, 5-10 minutes, 10+ minutes
+     *
+     * @param <T> the type of item to compare
+     */
+    public static abstract class BoundedIntCompare<T> extends IntCompare<T> {
+        protected Context mContext;
+
+        public BoundedIntCompare(Context context) {
+            mContext = context;
+        }
+
+        protected abstract int getStringId(int value);
+
+        @Override
+        public String createSectionHeader(T first, T second) {
+            int secondStringId = getStringId(getInt(second));
+            if (first == null || getStringId(getInt(first)) != secondStringId) {
+                return createLabel(secondStringId, second);
+            }
+
+            return null;
+        }
+
+        protected String createLabel(int stringId, T item) {
+            return mContext.getString(stringId);
+        }
+
+        @Override
+        public String createHeaderLabel(T item) {
+            return createLabel(getStringId(getInt(item)), item);
+        }
+    }
+
+    /**
+     * This implements BoundedIntCompare and gives duration buckets
+     *
+     * @param <T> the type of item to compare
+     */
+    public static abstract class DurationCompare<T> extends BoundedIntCompare<T> {
+        private static final int SECONDS_PER_MINUTE = 60;
+
+        public DurationCompare(Context context) {
+            super(context);
+        }
+
+        @Override
+        protected int getStringId(int value) {
+            if (value < 30) {
+                return R.string.header_less_than_30s;
+            } else if (value < 1 * SECONDS_PER_MINUTE) {
+                return R.string.header_30_to_60_seconds;
+            } else if (value < 2 * SECONDS_PER_MINUTE) {
+                return R.string.header_1_to_2_minutes;
+            } else if (value < 3 * SECONDS_PER_MINUTE) {
+                return R.string.header_2_to_3_minutes;
+            } else if (value < 4 * SECONDS_PER_MINUTE) {
+                return R.string.header_3_to_4_minutes;
+            } else if (value < 5 * SECONDS_PER_MINUTE) {
+                return R.string.header_4_to_5_minutes;
+            } else if (value < 10 * SECONDS_PER_MINUTE) {
+                return R.string.header_5_to_10_minutes;
+            } else if (value < 30 * SECONDS_PER_MINUTE) {
+                return R.string.header_10_to_30_minutes;
+            } else if (value < 60 * SECONDS_PER_MINUTE) {
+                return R.string.header_30_to_60_minutes;
+            }
+
+            return R.string.header_greater_than_60_minutes;
+        }
+    }
+
+    /**
+     * This implements BoundedIntCompare and gives number of songs buckets
+     *
+     * @param <T> the type of item to compare
+     */
+    public static abstract class NumberOfSongsCompare<T> extends BoundedIntCompare<T> {
+        public NumberOfSongsCompare(Context context) {
+            super(context);
+        }
+
+        @Override
+        protected int getStringId(int value) {
+            if (value <= 1) {
+                return R.string.header_1_song;
+            } else if (value <= 4) {
+                return R.string.header_2_to_4_songs;
+            } else if (value <= 9) {
+                return R.string.header_5_to_9_songs;
+            }
+
+            return R.string.header_10_plus_songs;
+        }
+    }
+
+    /**
+     * This implements BoundedIntCompare and gives number of albums buckets
+     *
+     * @param <T> the type of item to compare
+     */
+    public static abstract class NumberOfAlbumsCompare<T> extends BoundedIntCompare<T> {
+        public NumberOfAlbumsCompare(Context context) {
+            super(context);
+        }
+
+        @Override
+        protected int getStringId(int value) {
+            if (value <= 4) {
+                return R.plurals.Nalbums;
+            }
+
+            return R.string.header_5_plus_albums;
+        }
+
+        @Override
+        public String createSectionHeader(T first, T second) {
+            boolean returnSeparator = false;
+            if (first == null) {
+                returnSeparator = true;
+            } else {
+                // create a separator if both album counts are different and they are
+                // not greater than 5 albums
+                int firstInt = getInt(first);
+                int secondInt = getInt(second);
+                if (firstInt != secondInt &&
+                        !(firstInt >= 5 && secondInt >= 5)) {
+                    returnSeparator = true;
+                }
+            }
+
+            if (returnSeparator) {
+                return createHeaderLabel(second);
+            }
+
+            return null;
+        }
+
+        @Override
+        protected String createLabel(int stringId, T item) {
+            if (stringId == R.plurals.Nalbums) {
+                final int numItems = getInt(item);
+                return mContext.getResources().getQuantityString(stringId, numItems, numItems);
+            }
+
+            return super.createLabel(stringId, item);
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/ShakeDetector.java b/twelve/src/main/java/com/dolzzo/twelve/utils/ShakeDetector.java
new file mode 100755
index 0000000000..4949d168a7
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/ShakeDetector.java
@@ -0,0 +1,304 @@
+
+package com.dolzzo.twelve.utils;
+
+/*
+ * Copyright 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Detects phone shaking. If > 75% of the samples taken in the past 0.5s are accelerating, the
+ * device is a) shaking, or b) free falling 1.84m (h = 1/2*g*t^2*3/4).
+ *
+ * @author Bob Lee (bob@squareup.com)
+ * @author Eric Burke (eric@squareup.com)
+ */
+public class ShakeDetector implements SensorEventListener {
+
+    /**
+     * When the magnitude of total acceleration exceeds this value, the phone is accelerating.
+     */
+    private static final int ACCELERATION_THRESHOLD = 13;
+
+    /**
+     * Minimum time between two consecutive shakes in milliseconds to invoke listener
+     */
+    private static final int MIN_TIME_BETWEEN_TWO_SHAKES = 1000;
+    private final SampleQueue queue = new SampleQueue();
+    private final Listener listener;
+    private long mDetectedShakeStartTime = 0;
+    private SensorManager sensorManager;
+    private Sensor accelerometer;
+
+    public ShakeDetector(Listener listener) {
+        this.listener = listener;
+    }
+
+    /**
+     * Starts listening for shakes on devices with appropriate hardware.
+     *
+     * @returns true if the device supports shake detection.
+     */
+    public boolean start(SensorManager sensorManager) {
+        // Already started?
+        if (accelerometer != null) {
+            return true;
+        }
+
+        accelerometer = sensorManager
+                .getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+
+        // If this phone has an accelerometer, listen to it.
+        if (accelerometer != null) {
+            this.sensorManager = sensorManager;
+            sensorManager.registerListener(this, accelerometer,
+                    SensorManager.SENSOR_DELAY_FASTEST);
+        }
+        return accelerometer != null;
+    }
+
+    /**
+     * Stops listening. Safe to call when already stopped. Ignored on devices without appropriate
+     * hardware.
+     */
+    public void stop() {
+        if (accelerometer != null) {
+            sensorManager.unregisterListener(this, accelerometer);
+            sensorManager = null;
+            accelerometer = null;
+        }
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        boolean accelerating = isAccelerating(event);
+        long timestamp = event.timestamp;
+        queue.add(timestamp, accelerating);
+        if (queue.isShaking()) {
+            /*
+             * detect time between two concecutive shakes and limit it to
+             * MIN_TIME_BETWEEN_TWO_SHAKES
+             */
+            long currentTime = System.currentTimeMillis();
+            if (currentTime - mDetectedShakeStartTime > MIN_TIME_BETWEEN_TWO_SHAKES) {
+                queue.clear();
+                listener.hearShake();
+                mDetectedShakeStartTime = System.currentTimeMillis();
+            }
+        }
+    }
+
+    /**
+     * Returns true if the device is currently accelerating.
+     */
+    private boolean isAccelerating(SensorEvent event) {
+        float ax = event.values[0];
+        float ay = event.values[1];
+        float az = event.values[2];
+
+        // Instead of comparing magnitude to ACCELERATION_THRESHOLD,
+        // compare their squares. This is equivalent and doesn't need the
+        // actual magnitude, which would be computed using (expesive)
+        // Math.sqrt().
+        final double magnitudeSquared = ax * ax + ay * ay + az * az;
+        return magnitudeSquared > ACCELERATION_THRESHOLD
+                * ACCELERATION_THRESHOLD;
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+    }
+
+    /**
+     * Listens for shakes.
+     */
+    public interface Listener {
+        /**
+         * Called on the main thread when the device is shaken.
+         */
+        void hearShake();
+    }
+
+    /**
+     * Queue of samples. Keeps a running average.
+     */
+    static class SampleQueue {
+
+        /**
+         * Window size in ns. Used to compute the average.
+         */
+        private static final long MAX_WINDOW_SIZE = 500000000; // 0.5s
+        private static final long MIN_WINDOW_SIZE = MAX_WINDOW_SIZE >> 1; // 0.25s
+
+        /**
+         * Ensure the queue size never falls below this size, even if the device fails to deliver
+         * this many events during the time window. The LG Ally is one such device.
+         */
+        private static final int MIN_QUEUE_SIZE = 4;
+
+        private final SamplePool pool = new SamplePool();
+
+        private Sample oldest;
+        private Sample newest;
+        private int sampleCount;
+        private int acceleratingCount;
+
+        /**
+         * Adds a sample.
+         *
+         * @param timestamp    in nanoseconds of sample
+         * @param accelerating true if > {@link #ACCELERATION_THRESHOLD}.
+         */
+        void add(long timestamp, boolean accelerating) {
+            // Purge samples that proceed window.
+            purge(timestamp - MAX_WINDOW_SIZE);
+
+            // Add the sample to the queue.
+            Sample added = pool.acquire();
+            added.timestamp = timestamp;
+            added.accelerating = accelerating;
+            added.next = null;
+            if (newest != null) {
+                newest.next = added;
+            }
+            newest = added;
+            if (oldest == null) {
+                oldest = added;
+            }
+
+            // Update running average.
+            sampleCount++;
+            if (accelerating) {
+                acceleratingCount++;
+            }
+        }
+
+        /**
+         * Removes all samples from this queue.
+         */
+        void clear() {
+            while (oldest != null) {
+                Sample removed = oldest;
+                oldest = removed.next;
+                pool.release(removed);
+            }
+            newest = null;
+            sampleCount = 0;
+            acceleratingCount = 0;
+        }
+
+        /**
+         * Purges samples with timestamps older than cutoff.
+         */
+        void purge(long cutoff) {
+            while (sampleCount >= MIN_QUEUE_SIZE && oldest != null
+                    && cutoff - oldest.timestamp > 0) {
+                // Remove sample.
+                Sample removed = oldest;
+                if (removed.accelerating) {
+                    acceleratingCount--;
+                }
+                sampleCount--;
+
+                oldest = removed.next;
+                if (oldest == null) {
+                    newest = null;
+                }
+                pool.release(removed);
+            }
+        }
+
+        /**
+         * Copies the samples into a list, with the oldest entry at index 0.
+         */
+        List<Sample> asList() {
+            List<Sample> list = new ArrayList<Sample>();
+            Sample s = oldest;
+            while (s != null) {
+                list.add(s);
+                s = s.next;
+            }
+            return list;
+        }
+
+        /**
+         * Returns true if we have enough samples and more than 3/4 of those samples are
+         * accelerating.
+         */
+        boolean isShaking() {
+            return newest != null
+                    && oldest != null
+                    && newest.timestamp - oldest.timestamp >= MIN_WINDOW_SIZE
+                    && acceleratingCount >= (sampleCount >> 1)
+                    + (sampleCount >> 2);
+        }
+    }
+
+    /**
+     * An accelerometer sample.
+     */
+    static class Sample {
+        /**
+         * Time sample was taken.
+         */
+        long timestamp;
+
+        /**
+         * If acceleration > {@link #ACCELERATION_THRESHOLD}.
+         */
+        boolean accelerating;
+
+        /**
+         * Next sample in the queue or pool.
+         */
+        Sample next;
+    }
+
+    /**
+     * Pools samples. Avoids garbage collection.
+     */
+    static class SamplePool {
+        private Sample head;
+
+        /**
+         * Acquires a sample from the pool.
+         */
+        Sample acquire() {
+            Sample acquired = head;
+            if (acquired == null) {
+                acquired = new Sample();
+            } else {
+                // Remove instance from pool.
+                head = acquired.next;
+            }
+            return acquired;
+        }
+
+        /**
+         * Returns a sample to the pool.
+         */
+        void release(Sample sample) {
+            sample.next = head;
+            head = sample;
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/SongPopupMenuHelper.java b/twelve/src/main/java/com/dolzzo/twelve/utils/SongPopupMenuHelper.java
new file mode 100755
index 0000000000..b505cc8020
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/SongPopupMenuHelper.java
@@ -0,0 +1,79 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.utils;
+
+
+import android.app.Activity;
+import android.provider.MediaStore;
+import android.support.v4.app.FragmentManager;
+
+import com.dolzzo.twelve.menu.DeleteDialog;
+import com.dolzzo.twelve.menu.FragmentMenuItems;
+import com.dolzzo.twelve.model.Song;
+
+import java.util.TreeSet;
+
+public abstract class SongPopupMenuHelper extends PopupMenuHelper {
+    protected Song mSong;
+
+    public SongPopupMenuHelper(Activity activity, FragmentManager fragmentManager) {
+        super(activity, fragmentManager);
+    }
+
+    public abstract Song getSong(int position);
+
+    @Override
+    public PopupMenuHelper.PopupMenuType onPreparePopupMenu(int position) {
+        mSong = getSong(position);
+
+        if (mSong == null) {
+            return null;
+        }
+
+        return PopupMenuType.Song;
+    }
+
+    @Override
+    protected void playAlbum() {
+        MusicUtils.playAlbum(mActivity, mSong.mAlbumId, 0, false);
+    }
+
+    @Override
+    protected long[] getIdList() {
+        return new long[]{mSong.mSongId};
+    }
+
+    @Override
+    protected String getArtistName() {
+        return mSong.mArtistName;
+    }
+
+    @Override
+    protected void onDeleteClicked() {
+        DeleteDialog.newInstance(mSong.mSongName, getIdList(), null)
+                .show(mFragmentManager, "DeleteDialog");
+    }
+
+    @Override
+    protected void updateMenuIds(PopupMenuType type, TreeSet<Integer> set) {
+        super.updateMenuIds(type, set);
+
+        // Don't show more by artist if it is an unknown artist
+        if (MediaStore.UNKNOWN_STRING.equals(mSong.mArtistName)) {
+            set.remove(FragmentMenuItems.MORE_BY_ARTIST);
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/SortOrder.java b/twelve/src/main/java/com/dolzzo/twelve/utils/SortOrder.java
new file mode 100755
index 0000000000..bdbfa04678
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/SortOrder.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.utils;
+
+import android.provider.MediaStore;
+
+/**
+ * Holds all of the sort orders for each list type.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public final class SortOrder {
+
+    /**
+     * This class is never instantiated
+     */
+    public SortOrder() {
+    }
+
+    /**
+     * Artist sort order entries.
+     */
+    public static interface ArtistSortOrder {
+        /* Artist sort order A-Z */
+        public final static String ARTIST_A_Z = MediaStore.Audio.Artists.DEFAULT_SORT_ORDER;
+
+        /* Artist sort order Z-A */
+        public final static String ARTIST_Z_A = ARTIST_A_Z + " DESC";
+
+        /* Artist sort order number of songs */
+        public final static String ARTIST_NUMBER_OF_SONGS = MediaStore.Audio.Artists.NUMBER_OF_TRACKS
+                + " DESC";
+
+        /* Artist sort order number of albums */
+        public final static String ARTIST_NUMBER_OF_ALBUMS = MediaStore.Audio.Artists.NUMBER_OF_ALBUMS
+                + " DESC";
+    }
+
+    /**
+     * Album sort order entries.
+     */
+    public static interface AlbumSortOrder {
+        /* Album sort order A-Z */
+        public final static String ALBUM_A_Z = MediaStore.Audio.Albums.DEFAULT_SORT_ORDER;
+
+        /* Album sort order Z-A */
+        public final static String ALBUM_Z_A = ALBUM_A_Z + " DESC";
+
+        /* Album sort order songs */
+        public final static String ALBUM_NUMBER_OF_SONGS = MediaStore.Audio.Albums.NUMBER_OF_SONGS
+                + " DESC";
+
+        /* Album sort order artist */
+        public final static String ALBUM_ARTIST = MediaStore.Audio.Albums.ARTIST;
+
+        /* Album sort order year */
+        public final static String ALBUM_YEAR = MediaStore.Audio.Albums.FIRST_YEAR + " DESC";
+
+    }
+
+    /**
+     * Song sort order entries.
+     */
+    public static interface SongSortOrder {
+        /* Song sort order A-Z */
+        public final static String SONG_A_Z = MediaStore.Audio.Media.DEFAULT_SORT_ORDER;
+
+        /* Song sort order Z-A */
+        public final static String SONG_Z_A = SONG_A_Z + " DESC";
+
+        /* Song sort order artist */
+        public final static String SONG_ARTIST = MediaStore.Audio.Media.ARTIST;
+
+        /* Song sort order album */
+        public final static String SONG_ALBUM = MediaStore.Audio.Media.ALBUM;
+
+        /* Song sort order year */
+        public final static String SONG_YEAR = MediaStore.Audio.Media.YEAR + " DESC";
+
+        /* Song sort order duration */
+        public final static String SONG_DURATION = MediaStore.Audio.Media.DURATION + " DESC";
+
+        /* Song sort order date */
+        public final static String SONG_DATE = MediaStore.Audio.Media.DATE_ADDED + " DESC";
+
+        /* Song sort order filename */
+        public final static String SONG_FILENAME = MediaStore.Audio.Media.DATA;
+    }
+
+    /**
+     * Album song sort order entries.
+     */
+    public static interface AlbumSongSortOrder {
+        /* Album song sort order A-Z */
+        public final static String SONG_A_Z = MediaStore.Audio.Media.DEFAULT_SORT_ORDER;
+
+        /* Album song sort order Z-A */
+        public final static String SONG_Z_A = SONG_A_Z + " DESC";
+
+        /* Album song sort order track list */
+        public final static String SONG_TRACK_LIST = MediaStore.Audio.Media.TRACK + ", "
+                + MediaStore.Audio.Media.DEFAULT_SORT_ORDER;
+
+        /* Album song sort order duration */
+        public final static String SONG_DURATION = SongSortOrder.SONG_DURATION;
+
+        /* Album song sort order filename */
+        public final static String SONG_FILENAME = SongSortOrder.SONG_FILENAME;
+    }
+
+    /**
+     * Artist song sort order entries.
+     */
+    public static interface ArtistSongSortOrder {
+        /* Artist song sort order A-Z */
+        public final static String SONG_A_Z = MediaStore.Audio.Media.DEFAULT_SORT_ORDER;
+
+        /* Artist song sort order Z-A */
+        public final static String SONG_Z_A = SONG_A_Z + " DESC";
+
+        /* Artist song sort order album */
+        public final static String SONG_ALBUM = MediaStore.Audio.Media.ALBUM;
+
+        /* Artist song sort order year */
+        public final static String SONG_YEAR = MediaStore.Audio.Media.YEAR + " DESC";
+
+        /* Artist song sort order duration */
+        public final static String SONG_DURATION = MediaStore.Audio.Media.DURATION + " DESC";
+
+        /* Artist song sort order date */
+        public final static String SONG_DATE = MediaStore.Audio.Media.DATE_ADDED + " DESC";
+
+        /* Artist song sort order filename */
+        public final static String SONG_FILENAME = SongSortOrder.SONG_FILENAME;
+    }
+
+    /**
+     * Artist album sort order entries.
+     */
+    public static interface ArtistAlbumSortOrder {
+        /* Artist album sort order A-Z */
+        public final static String ALBUM_A_Z = MediaStore.Audio.Albums.DEFAULT_SORT_ORDER;
+
+        /* Artist album sort order Z-A */
+        public final static String ALBUM_Z_A = ALBUM_A_Z + " DESC";
+
+        /* Artist album sort order songs */
+        public final static String ALBUM_NUMBER_OF_SONGS = MediaStore.Audio.Artists.Albums.NUMBER_OF_SONGS
+                + " DESC";
+
+        /* Artist album sort order year */
+        public final static String ALBUM_YEAR = MediaStore.Audio.Artists.Albums.FIRST_YEAR
+                + " DESC";
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/SrtManager.java b/twelve/src/main/java/com/dolzzo/twelve/utils/SrtManager.java
new file mode 100755
index 0000000000..d72d2dfc58
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/SrtManager.java
@@ -0,0 +1,211 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.utils;
+
+import android.media.MediaPlayer;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Message;
+import android.util.Log;
+
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+
+import java.io.File;
+import java.util.ArrayList;
+
+/**
+ * Class that helps signal when srt text comes and goes
+ */
+public abstract class SrtManager implements Handler.Callback {
+    private static final String TAG = SrtManager.class.getSimpleName();
+    private static final boolean DEBUG = false;
+    private static final int POST_TEXT_MSG = 0;
+
+    private ArrayList<SrtParser.SrtEntry> mEntries;
+    private Handler mHandler;
+    private HandlerThread mHandlerThread;
+
+    private Runnable mLoader;
+
+    private SimpleExoPlayer mMediaPlayer;
+    private int mNextIndex;
+
+    public SrtManager() {
+        mHandlerThread = new HandlerThread("SrtManager",
+                android.os.Process.THREAD_PRIORITY_FOREGROUND);
+        mHandlerThread.start();
+        mHandler = new Handler(mHandlerThread.getLooper(), this);
+    }
+
+    private static boolean entrySurroundsTime(SrtParser.SrtEntry entry, long time) {
+        return entry.mStartTimeMs <= time && entry.mEndTimeMs >= time;
+    }
+
+    public synchronized void reset() {
+        mHandler.removeMessages(POST_TEXT_MSG);
+        mHandler.removeCallbacks(mLoader);
+        mEntries = null;
+        mLoader = null;
+        mMediaPlayer = null;
+        mNextIndex = -1;
+
+        // post a null timed text to clear
+        onTimedText(null);
+    }
+
+    public synchronized void release() {
+        if (mHandlerThread != null) {
+            mHandler.removeMessages(POST_TEXT_MSG);
+            mHandler.removeCallbacks(mLoader);
+            mHandler = null;
+            mHandlerThread.quit();
+            mHandlerThread = null;
+        }
+    }
+
+    public synchronized void initialize(final SimpleExoPlayer player, final File f) {
+        if (player == null || f == null) {
+            throw new IllegalArgumentException("Must have a valid player and file");
+        }
+
+        reset();
+
+        if (!f.exists()) {
+            return;
+        }
+
+        mMediaPlayer = player;
+
+        mLoader = new Runnable() {
+            @Override
+            public void run() {
+                onLoaded(this, SrtParser.getSrtEntries(f));
+            }
+        };
+
+        mHandler.post(mLoader);
+    }
+
+    public synchronized void seekTo(long timeMs) {
+        mHandler.removeMessages(POST_TEXT_MSG);
+
+        mNextIndex = 0;
+
+        if (mEntries != null) {
+            if (DEBUG) {
+                Log.d(TAG, "Seeking to: " + timeMs);
+            }
+
+            // find the first entry after the current time and set mNextIndex to the one before that
+            for (int i = 0; i < mEntries.size(); i++) {
+                mNextIndex = i;
+                if (i + 1 < mEntries.size() && mEntries.get(i + 1).mStartTimeMs > timeMs) {
+                    break;
+                }
+            }
+
+            postNextTimedText();
+        }
+    }
+
+    public synchronized void pause() {
+        mHandler.removeMessages(POST_TEXT_MSG);
+    }
+
+    public synchronized void play() {
+        postNextTimedText();
+    }
+
+    private synchronized void onLoaded(Runnable r, ArrayList<SrtParser.SrtEntry> entries) {
+        // if this is the same loader
+        if (r == mLoader) {
+            mEntries = entries;
+            if (mEntries != null) {
+                if (DEBUG) {
+                    Log.d(TAG, "Loaded: " + entries.size() + " number of entries");
+                }
+
+                try {
+                    seekTo(mMediaPlayer.getCurrentPosition());
+                } catch (IllegalStateException e) {
+                    Log.d(TAG, "illegal state but failing silently");
+                    reset();
+                }
+            }
+        }
+    }
+
+    private synchronized void postNextTimedText() {
+        if (mEntries != null) {
+            long timeMs = 0;
+            try {
+                timeMs = mMediaPlayer.getCurrentPosition();
+            } catch (IllegalStateException e) {
+                Log.d(TAG, "illegal state - probably because media player has been " +
+                        "stopped/released. failing silently");
+                return;
+            }
+
+            String currentMessage = null;
+            long targetTime = -1;
+
+            // shift mNextIndex until it hits the next item we want
+            while (mNextIndex < mEntries.size() && mEntries.get(mNextIndex).mStartTimeMs < timeMs) {
+                mNextIndex++;
+            }
+
+            // if the previous entry is valid, set the message and target time
+            if (mNextIndex > 0 && entrySurroundsTime(mEntries.get(mNextIndex - 1), timeMs)) {
+                currentMessage = mEntries.get(mNextIndex - 1).mLine;
+                targetTime = mEntries.get(mNextIndex - 1).mEndTimeMs;
+            }
+
+            onTimedText(currentMessage);
+
+            // if our next index is valid, and we don't have a target time, set it
+            if (mNextIndex < mEntries.size() && targetTime == -1) {
+                targetTime = mEntries.get(mNextIndex).mStartTimeMs;
+            }
+
+            // if we have a targeted time entry and we are playing, then queue up a delayed message
+            if (targetTime >= 0 && mMediaPlayer.getPlayWhenReady() ) {
+                mHandler.removeMessages(POST_TEXT_MSG);
+
+                long delay = targetTime - timeMs;
+                mHandler.sendEmptyMessageDelayed(POST_TEXT_MSG, delay);
+
+                if (DEBUG && mNextIndex < mEntries.size()) {
+                    Log.d(TAG, "Preparing next message: " + delay + "ms from now with msg: " +
+                            mEntries.get(mNextIndex).mLine);
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean handleMessage(Message msg) {
+        switch (msg.what) {
+            case POST_TEXT_MSG:
+                postNextTimedText();
+                return true;
+        }
+
+        return false;
+    }
+
+    public abstract void onTimedText(String txt);
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/utils/SrtParser.java b/twelve/src/main/java/com/dolzzo/twelve/utils/SrtParser.java
new file mode 100755
index 0000000000..cb4b6cdac1
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/utils/SrtParser.java
@@ -0,0 +1,137 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.utils;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.ArrayList;
+
+public class SrtParser {
+    private static final String TAG = SrtParser.class.getSimpleName();
+
+    /**
+     * The SubRip file format should contain entries that follow the following format:
+     * <p>
+     * 1. A numeric counter identifying each sequential subtitle
+     * 2. The time that the subtitle should appear on the screen, followed by --> and the time it
+     * should disappear
+     * 3. Subtitle text itself on one or more lines
+     * 4. A blank line containing no text, indicating the end of this subtitle
+     * <p>
+     * The timecode format should be hours:minutes:seconds,milliseconds with time units fixed to two
+     * zero-padded digits and fractions fixed to three zero-padded digits (00:00:00,000).
+     */
+    public static ArrayList<SrtEntry> getSrtEntries(File f) {
+        ArrayList<SrtEntry> ret = null;
+        FileReader reader = null;
+        BufferedReader br = null;
+
+        try {
+            reader = new FileReader(f);
+            br = new BufferedReader(reader);
+
+            String header;
+            // since we don't really care about the 1st line of each entry (the # val) then read
+            // and discard it
+            while ((header = br.readLine()) != null) {
+                // discard subtitle number
+                header = br.readLine();
+                if (header == null) {
+                    break;
+                }
+
+                SrtEntry entry = new SrtEntry();
+
+                String[] startEnd = header.split("-->");
+                entry.mStartTimeMs = parseMs(startEnd[0]);
+                entry.mEndTimeMs = parseMs(startEnd[1]);
+
+                StringBuilder subtitleBuilder = new StringBuilder("");
+                String s = br.readLine();
+
+                if (!TextUtils.isEmpty(s)) {
+                    subtitleBuilder.append(s);
+
+                    while (!((s = br.readLine()) == null || s.trim().equals(""))) {
+                        subtitleBuilder.append("\n").append(s);
+                    }
+                }
+
+                entry.mLine = subtitleBuilder.toString();
+
+                if (ret == null) {
+                    ret = new ArrayList<SrtEntry>();
+                }
+
+                ret.add(entry);
+            }
+        } catch (NumberFormatException nfe) {
+            // The file isn't a valid srt format
+            Log.e(TAG, nfe.getMessage(), nfe);
+            ret = null;
+        } catch (IOException ioe) {
+            // shouldn't happen
+            Log.e(TAG, ioe.getMessage(), ioe);
+            ret = null;
+        } catch (ArrayIndexOutOfBoundsException e) {
+            // if the time is malformed
+            Log.e(TAG, e.getMessage());
+            ret = null;
+        } finally {
+            if (br != null) {
+                try {
+                    br.close();
+                } catch (IOException e) {
+                    Log.e(TAG, e.getMessage());
+                }
+            }
+
+            if (reader != null) {
+                try {
+                    reader.close();
+                } catch (IOException e) {
+                    Log.e(TAG, e.getMessage());
+                }
+            }
+        }
+
+        return ret;
+    }
+
+    private static long parseMs(String in) {
+        String[] timeArray = in.split(":");
+        long hours = Long.parseLong(timeArray[0].trim());
+        long minutes = Long.parseLong(timeArray[1].trim());
+
+        String[] secondTimeArray = timeArray[2].split(",");
+
+        long seconds = Long.parseLong(secondTimeArray[0].trim());
+        long millies = Long.parseLong(secondTimeArray[1].trim());
+
+        return hours * 60 * 60 * 1000 + minutes * 60 * 1000 + seconds * 1000 + millies;
+    }
+
+    public static class SrtEntry {
+        public long mStartTimeMs;
+        public long mEndTimeMs;
+        String mLine;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/AudioButton.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/AudioButton.java
new file mode 100755
index 0000000000..d006c36e5c
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/AudioButton.java
@@ -0,0 +1,43 @@
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.os.Build;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnLongClickListener;
+import android.widget.ImageButton;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.utils.ApolloUtils;
+
+public abstract class AudioButton extends ImageButton implements OnClickListener, OnLongClickListener {
+    public static float ACTIVE_ALPHA = 1.0f;
+    public static float INACTIVE_ALPHA = 0.4f;
+
+    @SuppressWarnings("deprecation")
+    public AudioButton(final Context context, final AttributeSet attrs) {
+        super(context, attrs);
+        setPadding(0, 0, 0, 0);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            setBackground(getResources().getDrawable(R.drawable.selectable_background));
+        } else {
+            setBackgroundResource(R.drawable.selectable_background);
+        }
+        // Control playback (cycle shuffle)
+        setOnClickListener(this);
+        // Show the cheat sheet
+        setOnLongClickListener(this);
+    }
+
+    @Override
+    public boolean onLongClick(final View view) {
+        if (TextUtils.isEmpty(view.getContentDescription())) {
+            return false;
+        } else {
+            ApolloUtils.showCheatSheet(view);
+            return true;
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/BlurScrimImage.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/BlurScrimImage.java
new file mode 100755
index 0000000000..a09f2ca776
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/BlurScrimImage.java
@@ -0,0 +1,101 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.TransitionDrawable;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageFetcher;
+import com.dolzzo.twelve.cache.ImageWorker;
+
+public class BlurScrimImage extends FrameLayout {
+    private ImageView mImageView;
+    private View mBlurScrim;
+
+    private boolean mUsingDefaultBlur;
+
+    public BlurScrimImage(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        mUsingDefaultBlur = true;
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+
+        mImageView = (ImageView) findViewById(R.id.blurImage);
+        mBlurScrim = findViewById(R.id.blurScrim);
+    }
+
+    public ImageView getImageView() {
+        return mImageView;
+    }
+
+    /**
+     * Transitions the image to the default state (default blur artwork)
+     */
+    public void transitionToDefaultState() {
+        // if we are already showing the default blur and we are transitioning to the default blur
+        // then don't do the transition at all
+        if (mUsingDefaultBlur) {
+            return;
+        }
+
+        Bitmap blurredBitmap = ((BitmapDrawable) getResources()
+                .getDrawable(R.drawable.default_artwork_blur)).getBitmap();
+
+        TransitionDrawable imageTransition = ImageWorker.createImageTransitionDrawable(getResources(),
+                mImageView.getDrawable(), blurredBitmap, ImageWorker.FADE_IN_TIME_SLOW, true, true);
+
+        TransitionDrawable paletteTransition = ImageWorker.createPaletteTransition(this,
+                Color.TRANSPARENT);
+
+
+        setTransitionDrawable(imageTransition, paletteTransition);
+        mUsingDefaultBlur = true;
+    }
+
+    /**
+     * Sets the transition drawable
+     *
+     * @param imageTransition   the transition for the imageview
+     * @param paletteTransition the transition for the scrim overlay
+     */
+    public void setTransitionDrawable(TransitionDrawable imageTransition,
+                                      TransitionDrawable paletteTransition) {
+        mBlurScrim.setBackground(paletteTransition);
+        mImageView.setImageDrawable(imageTransition);
+        mUsingDefaultBlur = false;
+    }
+
+    /**
+     * Loads the current artwork into this BlurScrimImage
+     *
+     * @param imageFetcher an ImageFetcher instance
+     */
+    public void loadBlurImage(ImageFetcher imageFetcher) {
+        imageFetcher.loadCurrentBlurredArtwork(this);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/IPopupMenuCallback.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/IPopupMenuCallback.java
new file mode 100755
index 0000000000..fe6d736103
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/IPopupMenuCallback.java
@@ -0,0 +1,28 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.widgets;
+
+import android.view.View;
+
+public interface IPopupMenuCallback {
+    public void setPopupMenuClickedListener(final IListener listener);
+
+    ;
+
+    public static interface IListener {
+        void onPopupMenuClicked(final View v, final int position);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/LayoutSuppressingImageView.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/LayoutSuppressingImageView.java
new file mode 100755
index 0000000000..5f65d70798
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/LayoutSuppressingImageView.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2012 Android Open Source Project Licensed under the Apache
+ * License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.widget.ImageView;
+
+/**
+ * A custom {@link ImageView} that improves the performance by not passing
+ * requestLayout() to its parent, taking advantage of knowing that image size
+ * won't change once set.
+ */
+public class LayoutSuppressingImageView extends ImageView {
+
+    /**
+     * @param context The {@link Context} to use
+     * @param attrs   The attributes of the XML tag that is inflating the view
+     */
+    public LayoutSuppressingImageView(final Context context, final AttributeSet attrs) {
+        super(context, attrs);
+
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void requestLayout() {
+        forceLayout();
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/LetterTileDrawable.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/LetterTileDrawable.java
new file mode 100755
index 0000000000..325cd90af4
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/LetterTileDrawable.java
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+import android.graphics.Rect;
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
+import android.text.TextUtils;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.cache.ImageWorker.ImageType;
+import com.dolzzo.twelve.utils.BitmapWithColors;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+import junit.framework.Assert;
+
+/**
+ * A drawable that encapsulates all the functionality needed to display a letter tile to
+ * represent a artist/album/playlist image.
+ */
+public class LetterTileDrawable extends Drawable {
+
+    /**
+     * Reusable components to avoid new allocations
+     */
+    private static final Paint sPaint = new Paint();
+    private static final Rect sRect = new Rect();
+    private static final char[] sChars = new char[2];
+    /**
+     * Letter tile
+     */
+    private static TypedArray sColors;
+    private static TypedArray sVibrantDarkColors;
+    private static int sDefaultColor;
+    private static int sTileFontColor;
+    private static float sLetterToTileRatio;
+    private static Bitmap DEFAULT_ARTIST;
+    private static Bitmap DEFAULT_ARTIST_LARGE;
+    private static Bitmap DEFAULT_ALBUM;
+    private static Bitmap DEFAULT_ALBUM_LARGE;
+    private static Bitmap DEFAULT_PLAYLIST;
+    private static Bitmap DEFAULT_PLAYLIST_LARGE;
+    private final String TAG = LetterTileDrawable.class.getSimpleName();
+    private final Paint mPaint;
+    private String mDisplayName;
+    private String mIdentifier;
+    private float mScale = 1.0f;
+    private float mOffset = 0.0f;
+    private Resources res;
+    private boolean mIsCircle = false;
+
+    private ImageType mImageType;
+
+    public LetterTileDrawable(final Context context) {
+        mPaint = new Paint();
+        mPaint.setFilterBitmap(true);
+        mPaint.setDither(true);
+        res = context.getResources();
+
+        initializeStaticVariables(res);
+    }
+
+    private static synchronized void initializeStaticVariables(final Resources res) {
+        if (sColors == null) {
+            sColors = res.obtainTypedArray(R.array.letter_tile_colors);
+            sVibrantDarkColors = res.obtainTypedArray(R.array.letter_tile_vibrant_dark_colors);
+            sDefaultColor = res.getColor(R.color.letter_tile_default_color);
+            sTileFontColor = res.getColor(R.color.letter_tile_font_color);
+            sLetterToTileRatio = res.getFraction(R.dimen.letter_to_tile_ratio, 1, 1);
+            DEFAULT_ARTIST = BitmapFactory.decodeResource(res, R.drawable.ic_artist);
+            DEFAULT_ARTIST_LARGE = BitmapFactory.decodeResource(res, R.drawable.ic_artist_lg);
+            DEFAULT_ALBUM = BitmapFactory.decodeResource(res, R.drawable.ic_album);
+            DEFAULT_ALBUM_LARGE = BitmapFactory.decodeResource(res, R.drawable.ic_album_lg);
+            DEFAULT_PLAYLIST = BitmapFactory.decodeResource(res, R.drawable.ic_playlist);
+            DEFAULT_PLAYLIST_LARGE = BitmapFactory.decodeResource(res, R.drawable.ic_playlist_lg);
+
+            sPaint.setTypeface(Typeface.create(
+                    res.getString(R.string.letter_tile_letter_font_family), Typeface.NORMAL));
+            sPaint.setTextAlign(Align.CENTER);
+            sPaint.setAntiAlias(true);
+        }
+    }
+
+    /**
+     * @return the corresponding index in the color palette based on the identifier
+     */
+    private static int getColorIndex(final String identifier) {
+        if (TextUtils.isEmpty(identifier)) {
+            return -1;
+        }
+
+        return Math.abs(identifier.hashCode()) % sColors.length();
+    }
+
+    /**
+     * Returns a deterministic color based on the provided contact identifier string.
+     */
+    private static int pickColor(final String identifier) {
+        final int idx = getColorIndex(identifier);
+        if (idx == -1) {
+            return sDefaultColor;
+        }
+
+        return sColors.getColor(idx, sDefaultColor);
+    }
+
+    /**
+     * Returns the vibrant matching color based on the provided contact identifier string.
+     */
+    private static int pickVibrantDarkColor(final String identifier) {
+        final int idx = getColorIndex(identifier);
+        if (idx == -1) {
+            return sDefaultColor;
+        }
+
+        return sVibrantDarkColors.getColor(idx, sDefaultColor);
+    }
+
+    /**
+     * Gets the default image to show for the image type.  If the bounds are large,
+     * it will use the large default bitmap
+     */
+    private static Bitmap getDefaultBitmapForImageType(ImageType type, Rect bounds) {
+        Bitmap ret = getDefaultBitmap(type, true);
+        if (Math.max(bounds.width(), bounds.height()) > Math.max(ret.getWidth(), ret.getHeight())) {
+            ret = getDefaultBitmap(type, false);
+        }
+
+        return ret;
+    }
+
+    private static Bitmap getDefaultBitmap(ImageType type, boolean small) {
+        switch (type) {
+            case ARTIST:
+                return small ? DEFAULT_ARTIST : DEFAULT_ARTIST_LARGE;
+            case ALBUM:
+                return small ? DEFAULT_ALBUM : DEFAULT_ALBUM_LARGE;
+            case PLAYLIST:
+                return small ? DEFAULT_PLAYLIST : DEFAULT_PLAYLIST_LARGE;
+            default:
+                throw new IllegalArgumentException("Unrecognized image type");
+        }
+    }
+
+    private static boolean isEnglishLetter(final char c) {
+        return ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z') || ('0' <= c && c <= '9');
+    }
+
+    /**
+     * Draw the bitmap onto the canvas at the current bounds taking into account the current scale.
+     */
+    private static void drawBitmap(final Bitmap bitmap, final int width, final int height,
+                                   final Canvas canvas, final Rect destRect, final float scale,
+                                   final float offset, final Paint paint) {
+        // Crop the destination bounds into a square, scaled and offset as appropriate
+        final int halfLength = (int) (scale * Math.min(destRect.width(), destRect.height()) / 2);
+
+        destRect.set(destRect.centerX() - halfLength,
+                (int) (destRect.centerY() - halfLength + offset * destRect.height()),
+                destRect.centerX() + halfLength,
+                (int) (destRect.centerY() + halfLength + offset * destRect.height()));
+
+        // Source rectangle remains the entire bounds of the source bitmap.
+        sRect.set(0, 0, width, height);
+
+        canvas.drawBitmap(bitmap, sRect, destRect, paint);
+    }
+
+    /**
+     * Draws the default letter tile drawable for the image type to a bitmap
+     *
+     * @param identifier   the identifier used to determine the color of the background.  For
+     *                     album, use albumId, for artist use artistName and for playlist use
+     *                     playlistId
+     * @param type         the type of item that this tile drawable corresponds to
+     * @param isCircle     whether to draw a circle or a square
+     * @param smallArtwork true if you want to draw a smaller version of the default bitmap for
+     *                     perf/memory reasons
+     */
+    public static BitmapWithColors createDefaultBitmap(Context context, String identifier,
+                                                       ImageType type, boolean isCircle, boolean smallArtwork) {
+        initializeStaticVariables(context.getResources());
+
+        identifier = MusicUtils.getTrimmedName(identifier);
+
+        // get the default bitmap to determine what to draw to
+        Bitmap defaultBitmap = getDefaultBitmap(type, smallArtwork);
+        final Rect bounds = new Rect(0, 0, defaultBitmap.getWidth(), defaultBitmap.getHeight());
+
+        // create a bitmap and canvas for drawing
+        Bitmap createdBitmap = Bitmap.createBitmap(defaultBitmap.getWidth(),
+                defaultBitmap.getHeight(), defaultBitmap.getConfig());
+        Canvas canvas = new Canvas(createdBitmap);
+
+        int color = pickColor(identifier);
+        int vibrantDarkColor = pickVibrantDarkColor(identifier);
+
+        Paint paint = new Paint();
+        paint.setColor(color);
+
+        final int minDimension = Math.min(bounds.width(), bounds.height());
+
+        if (isCircle) {
+            canvas.drawCircle(bounds.centerX(), bounds.centerY(), minDimension / 2, paint);
+        } else {
+            canvas.drawRect(bounds, paint);
+        }
+
+        // draw to the bitmap
+        drawBitmap(defaultBitmap, defaultBitmap.getWidth(), defaultBitmap.getHeight(), canvas,
+                bounds, 1, 0, paint);
+
+        return new BitmapWithColors(createdBitmap, identifier.hashCode(), color, vibrantDarkColor);
+    }
+
+    @Override
+    public void draw(final Canvas canvas) {
+        //setBounds(0, 0, 120, 120);
+        final Rect bounds = getBounds();
+        if (!isVisible() || bounds.isEmpty()) {
+            return;
+        }
+        // Draw letter tile.
+        drawLetterTile(canvas);
+    }
+
+    @Override
+    public void setBounds(Rect bounds) {
+        super.setBounds(bounds);
+    }
+
+    private void drawLetterTile(final Canvas canvas) {
+        // Draw background color.
+        sPaint.setColor(pickColor(mIdentifier));
+
+        sPaint.setAlpha(mPaint.getAlpha());
+        final Rect bounds = getBounds();
+        final int minDimension = Math.min(bounds.width(), bounds.height());
+
+        if (mIsCircle) {
+            canvas.drawCircle(bounds.centerX(), bounds.centerY(), minDimension / 2, sPaint);
+        } else {
+            canvas.drawRect(bounds, sPaint);
+        }
+
+        // Draw letter/digit only if the first character is an english letter
+        if (mDisplayName != null && !mDisplayName.isEmpty()
+                && isEnglishLetter(mDisplayName.charAt(0))) {
+            int numChars = 1;
+
+            // Draw letter or digit.
+            sChars[0] = Character.toUpperCase(mDisplayName.charAt(0));
+
+            if (mDisplayName.length() > 1 && isEnglishLetter(mDisplayName.charAt(1))) {
+                sChars[1] = Character.toLowerCase(mDisplayName.charAt(1));
+                numChars = 2;
+            }
+
+            // Scale text by canvas bounds and user selected scaling factor
+            sPaint.setTextSize(mScale * sLetterToTileRatio * minDimension);
+            //sPaint.setTextSize(sTileLetterFontSize);
+            sPaint.getTextBounds(sChars, 0, numChars, sRect);
+            sPaint.setColor(sTileFontColor);
+
+            // Draw the letter in the canvas, vertically shifted up or down by the user-defined
+            // offset
+            canvas.drawText(sChars, 0, numChars, bounds.centerX(),
+                    bounds.centerY() + mOffset * bounds.height() + sRect.height() / 2,
+                    sPaint);
+        } else {
+            // Draw the default image if there is no letter/digit to be drawn
+            final Bitmap bitmap = getDefaultBitmapForImageType(mImageType, bounds);
+
+            // The bitmap should be drawn in the middle of the canvas without changing its width to
+            // height ratio.
+            final Rect destRect = copyBounds();
+
+            drawBitmap(bitmap, bitmap.getWidth(), bitmap.getHeight(), canvas, destRect, mScale,
+                    mOffset, mPaint);
+        }
+    }
+
+    public int getColor() {
+        return pickColor(mIdentifier);
+    }
+
+    @Override
+    public void setAlpha(final int alpha) {
+        mPaint.setAlpha(alpha);
+    }
+
+    @Override
+    public void setColorFilter(final ColorFilter cf) {
+        mPaint.setColorFilter(cf);
+    }
+
+    @Override
+    public int getOpacity() {
+        return android.graphics.PixelFormat.OPAQUE;
+    }
+
+    /**
+     * Scale the drawn letter tile to a ratio of its default size
+     *
+     * @param scale The ratio the letter tile should be scaled to as a percentage of its default
+     *              size, from a scale of 0 to 2.0f. The default is 1.0f.
+     */
+    public void setScale(float scale) {
+        mScale = scale;
+    }
+
+    /**
+     * Assigns the vertical offset of the position of the letter tile to the ContactDrawable
+     *
+     * @param offset The provided offset must be within the range of -0.5f to 0.5f.
+     *               If set to -0.5f, the letter will be shifted upwards by 0.5 times the height of the canvas
+     *               it is being drawn on, which means it will be drawn with the center of the letter starting
+     *               at the top edge of the canvas.
+     *               If set to 0.5f, the letter will be shifted downwards by 0.5 times the height of the canvas
+     *               it is being drawn on, which means it will be drawn with the center of the letter starting
+     *               at the bottom edge of the canvas.
+     *               The default is 0.0f.
+     */
+    public void setOffset(float offset) {
+        Assert.assertTrue(offset >= -0.5f && offset <= 0.5f);
+        mOffset = offset;
+    }
+
+    /**
+     * Sets the tile data used to determine the display text and color
+     *
+     * @param displayName the name to display - Some logic will be applied to do some trimming
+     *                    and up to the first two letters will be displayed
+     * @param identifier  the identifier used to determine the color of the background.  For
+     *                    album, use albumId, for artist use artistName and for playlist use
+     *                    playlistId
+     * @param type        the type of item that this tile drawable corresponds to
+     */
+    public void setTileDetails(final String displayName, final String identifier,
+                               final ImageType type) {
+        mDisplayName = MusicUtils.getTrimmedName(displayName);
+        mIdentifier = MusicUtils.getTrimmedName(identifier);
+        mImageType = type;
+        invalidateSelf();
+    }
+
+    public void setIsCircular(boolean isCircle) {
+        mIsCircle = isCircle;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/LoadingEmptyContainer.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/LoadingEmptyContainer.java
new file mode 100755
index 0000000000..ad797035a0
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/LoadingEmptyContainer.java
@@ -0,0 +1,81 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.os.Handler;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.FrameLayout;
+
+import com.dolzzo.twelve.R;
+
+/**
+ * This class is the default empty state view for most listviews/fragments
+ * It allows the ability to set a main text, a main highlight text and a secondary text
+ * By default this container has some strings loaded, but other classes can call the apis to change
+ * the text
+ */
+public class LoadingEmptyContainer extends FrameLayout {
+    private static final int LOADING_DELAY = 300;
+
+    private Handler mHandler;
+    private Runnable mShowLoadingRunnable;
+
+    public LoadingEmptyContainer(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        mHandler = new Handler();
+        mShowLoadingRunnable = new Runnable() {
+            @Override
+            public void run() {
+                findViewById(R.id.progressbar).setVisibility(View.VISIBLE);
+                getNoResultsContainer().setVisibility(View.INVISIBLE);
+            }
+        };
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+
+        hideAll();
+    }
+
+    public void hideAll() {
+        findViewById(R.id.progressbar).setVisibility(View.INVISIBLE);
+        getNoResultsContainer().setVisibility(View.INVISIBLE);
+    }
+
+    public void showLoading() {
+        hideAll();
+
+//        if (!mHandler.hasCallbacks(mShowLoadingRunnable)) {
+        mHandler.postDelayed(mShowLoadingRunnable, LOADING_DELAY);
+//        }
+    }
+
+    public void showNoResults() {
+        mHandler.removeCallbacks(mShowLoadingRunnable);
+
+        findViewById(R.id.progressbar).setVisibility(View.INVISIBLE);
+        getNoResultsContainer().setVisibility(View.VISIBLE);
+    }
+
+    public NoResultsContainer getNoResultsContainer() {
+        return (NoResultsContainer) findViewById(R.id.no_results_container);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/NoResultsContainer.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/NoResultsContainer.java
new file mode 100755
index 0000000000..a97f7b8c95
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/NoResultsContainer.java
@@ -0,0 +1,66 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.dolzzo.twelve.R;
+
+/**
+ * This class is the default empty state view for most listviews/fragments
+ * It allows the ability to set a main text, a main highlight text and a secondary text
+ * By default this container has some strings loaded, but other classes can call the apis to change
+ * the text
+ */
+public class NoResultsContainer extends LinearLayout {
+    public NoResultsContainer(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    /**
+     * This changes the Main text (top-most text) of the empty container
+     *
+     * @param resId String resource id
+     */
+    public void setMainText(final int resId) {
+        ((TextView) findViewById(R.id.no_results_main_text)).setText(resId);
+    }
+
+    public void setMainHighlightText(final String text) {
+        final TextView hightlightText = (TextView) findViewById(R.id.no_results_main_highlight_text);
+
+        if (text == null || text.isEmpty()) {
+            hightlightText.setVisibility(View.GONE);
+        } else {
+            hightlightText.setText(text);
+            hightlightText.setVisibility(View.VISIBLE);
+        }
+    }
+
+    public void setSecondaryText(final int resId) {
+        ((TextView) findViewById(R.id.no_results_secondary_text)).setText(resId);
+    }
+
+    public void setTextColor(int color) {
+        ((TextView) findViewById(R.id.no_results_main_text)).setTextColor(color);
+        ((TextView) findViewById(R.id.no_results_main_highlight_text)).setTextColor(color);
+        ((TextView) findViewById(R.id.no_results_secondary_text)).setTextColor(color);
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/PlayPauseButton.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/PlayPauseButton.java
new file mode 100755
index 0000000000..1d34d9796b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/PlayPauseButton.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.widgets;
+
+import android.animation.Animator;
+import android.content.Context;
+import android.os.Build;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnLongClickListener;
+import android.view.ViewAnimationUtils;
+import android.widget.ImageButton;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * A custom {@link ImageButton} that represents the "play and pause" button.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class PlayPauseButton extends ImageButton implements OnClickListener, OnLongClickListener {
+
+    /**
+     * Play button theme resource
+     */
+    private static final String PLAY = "btn_playback_play";
+
+    /**
+     * Pause button theme resource
+     */
+    private static final String PAUSE = "btn_playback_pause";
+
+    /**
+     * @param context The {@link Context} to use
+     * @param attrs   The attributes of the XML tag that is inflating the view.
+     */
+    @SuppressWarnings("deprecation")
+    public PlayPauseButton(final Context context, final AttributeSet attrs) {
+        super(context, attrs);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            setBackground(getResources().getDrawable(R.drawable.selectable_background));
+        } else {
+            setBackgroundResource(R.drawable.selectable_background);
+        }
+        // Control playback (play/pause)
+        setOnClickListener(this);
+        // Show the cheat sheet
+        setOnLongClickListener(this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onClick(final View v) {
+        MusicUtils.playOrPause();
+
+        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
+            int centerX = (v.getLeft() + v.getRight()) / 2;
+            int centerY = (v.getTop() + v.getBottom()) / 2;
+            int startRadius = 0;
+            int endRadius = (int) Math.hypot(v.getWidth(), v.getHeight());
+
+            Animator anim = ViewAnimationUtils.createCircularReveal(
+                    v, centerX, centerY, startRadius, endRadius);
+
+            anim.setDuration(800);
+            anim.start();
+        }
+        updateState();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onLongClick(final View view) {
+        if (TextUtils.isEmpty(view.getContentDescription())) {
+            return false;
+        } else {
+            ApolloUtils.showCheatSheet(view);
+            return true;
+        }
+    }
+
+    /**
+     * Sets the correct drawable for playback.
+     */
+    public void updateState() {
+        if (MusicUtils.isPlaying()) {
+            setContentDescription(getResources().getString(R.string.accessibility_pause));
+            setImageDrawable(getResources().getDrawable(R.drawable.btn_playback_pause));
+        } else {
+            setContentDescription(getResources().getString(R.string.accessibility_play));
+            setImageDrawable(getResources().getDrawable(R.drawable.btn_playback_play));
+        }
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/PlayPauseProgressButton.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/PlayPauseProgressButton.java
new file mode 100755
index 0000000000..025429d811
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/PlayPauseProgressButton.java
@@ -0,0 +1,375 @@
+/*
+* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+* Copyright (C) 2015 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.MotionEvent;
+import android.view.ViewConfiguration;
+import android.widget.FrameLayout;
+import android.widget.ProgressBar;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * This class handles the playpause button as well as the circular progress bar
+ * it self-updates the progress bar but the containing activity/fragment
+ * needs to add code to pause/resume this button to prevent unnecessary
+ * updates while the activity/fragment is not visible
+ */
+public class PlayPauseProgressButton extends FrameLayout {
+    private static final int REVOLUTION_IN_DEGREES = 360;
+    private static final int HALF_REVOLUTION_IN_DEGREES = REVOLUTION_IN_DEGREES / 2;
+    private static String TAG = PlayPauseProgressButton.class.getSimpleName();
+    private static boolean DEBUG = false;
+    private final int mSmallDistance;
+    private ProgressBar mProgressBar;
+    private PlayPauseButton mPlayPauseButton;
+    private Runnable mUpdateProgress;
+    private boolean mPaused;
+    private float mDragPercentage = 0.0f;
+    private boolean mDragEnabled = false;
+    private boolean mDragging = false;
+    private float mDownAngle;
+    private float mDragAngle;
+    private float mDownX;
+    private float mDownY;
+    private int mWidth;
+    private long mCurrentSongDuration;
+    private long mCurrentSongProgress;
+
+    public PlayPauseProgressButton(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        // set enabled to false as default so that calling enableAndShow will execute
+        setEnabled(false);
+
+        // set paused to false since we shouldn't be typically created while not visible
+        mPaused = false;
+
+        mSmallDistance = ViewConfiguration.get(context).getScaledTouchSlop();
+    }
+
+    /**
+     * Crops the angle between 0 and 360 - if the angle is < 0, it will return 0, if it is more than
+     * 360 it will return 360
+     */
+    private static float cropAngle(float angle) {
+        return Math.min(REVOLUTION_IN_DEGREES, Math.max(0.0f, angle));
+    }
+
+    /**
+     * Wraps the angle between -180 and 180. This assumes that the passed in
+     * angle is >= -360 and <= 360
+     */
+    private static float wrapHalfRevolution(float angle) {
+        if (angle < -HALF_REVOLUTION_IN_DEGREES) {
+            return angle + REVOLUTION_IN_DEGREES;
+        } else if (angle > HALF_REVOLUTION_IN_DEGREES) {
+            return angle - REVOLUTION_IN_DEGREES;
+        }
+
+        return angle;
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+
+        mPlayPauseButton = (PlayPauseButton) findViewById(R.id.action_button_play);
+        mProgressBar = (ProgressBar) findViewById(R.id.circularProgressBar);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        // Make the play pause button size dependent on the container size
+        int horizontalPadding = getMeasuredWidth() / 4;
+        int verticalPadding = getMeasuredHeight() / 4;
+        mPlayPauseButton.setPadding(
+                horizontalPadding, horizontalPadding,
+                verticalPadding, verticalPadding);
+
+        // rotate the progress bar 90 degrees counter clockwise so that the
+        // starting position is at the top
+        mProgressBar.setPivotX(mProgressBar.getMeasuredWidth() / 2);
+        mProgressBar.setPivotY(mProgressBar.getMeasuredHeight() / 2);
+        mProgressBar.setRotation(-90);
+    }
+
+    /**
+     * Enable and shows the container
+     */
+    public void enableAndShow() {
+        // enable
+        setEnabled(true);
+
+        // make our view visible
+        setVisibility(VISIBLE);
+    }
+
+    /**
+     * Disables and sets the visibility to gone for the container
+     */
+    public void disableAndHide() {
+        // disable
+        setEnabled(false);
+
+        // hide our view
+        setVisibility(GONE);
+    }
+
+    /**
+     * Sets whether the user can drag the progress in a circular motion to seek the track
+     */
+    public void setDragEnabled(boolean enabled) {
+        mDragEnabled = enabled;
+    }
+
+    /**
+     * @return true if the user is actively dragging to seek
+     */
+    public boolean isDragging() {
+        return mDragEnabled && mDragging;
+    }
+
+    /**
+     * @return how far the user has dragged in the track in ms
+     */
+    public long getDragProgressInMs() {
+        return (long) (mDragPercentage * mCurrentSongDuration);
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) {
+        // if the enabled state isn't changed, quit
+        if (enabled == isEnabled()) return;
+
+        super.setEnabled(enabled);
+
+        // signal our state has changed
+        onStateChanged();
+    }
+
+    /**
+     * Pauses the progress bar periodic update logic
+     */
+    public void pause() {
+        if (!mPaused) {
+            mPaused = true;
+
+            // signal our state has changed
+            onStateChanged();
+        }
+    }
+
+    /**
+     * Resumes the progress bar periodic update logic
+     */
+    public void resume() {
+        if (mPaused) {
+            mPaused = false;
+
+            // signal our state has changed
+            onStateChanged();
+        }
+    }
+
+    /**
+     * @return play pause button
+     */
+    public PlayPauseButton getPlayPauseButton() {
+        return mPlayPauseButton;
+    }
+
+    /**
+     * Signaled if the state has changed (either the enabled or paused flag)
+     * When the state changes, we either kick off the updates or remove them based on those flags
+     */
+    private void onStateChanged() {
+        // if we are enabled and not paused
+        if (isEnabled() && !mPaused) {
+            // update the state of the progress bar and play/pause button
+            updateState();
+
+            // kick off update states
+            postUpdate();
+        } else {
+            // otherwise remove our update
+            removeUpdate();
+        }
+    }
+
+    /**
+     * Updates the state of the progress bar and the play pause button
+     */
+    private void updateState() {
+        mCurrentSongDuration = MusicUtils.duration();
+        mCurrentSongProgress = MusicUtils.position();
+
+        int progress = 0;
+        if (isDragging()) {
+            progress = (int) (mDragPercentage * mProgressBar.getMax());
+        } else if (mCurrentSongDuration > 0) {
+            progress = (int) (mProgressBar.getMax() * mCurrentSongProgress / mCurrentSongDuration);
+        }
+
+        mProgressBar.setProgress(progress);
+        mPlayPauseButton.updateState();
+    }
+
+    /**
+     * Creates and posts the update runnable to the handler
+     */
+    private void postUpdate() {
+        if (mUpdateProgress == null) {
+            mUpdateProgress = new Runnable() {
+                @Override
+                public void run() {
+                    updateState();
+                    postDelayed(mUpdateProgress, isDragging() ? MusicUtils.UPDATE_FREQUENCY_FAST_MS
+                            : MusicUtils.UPDATE_FREQUENCY_MS);
+                }
+            };
+        }
+
+        // remove any existing callbacks
+        removeCallbacks(mUpdateProgress);
+
+        // post ourselves as a delayed
+        post(mUpdateProgress);
+    }
+
+    /**
+     * Removes the runnable from the handler
+     */
+    private void removeUpdate() {
+        if (mUpdateProgress != null) {
+            removeCallbacks(mUpdateProgress);
+        }
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldW, int oldH) {
+        mWidth = Math.min(w, h);
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent ev) {
+        if (!mDragEnabled) {
+            return false;
+        }
+
+        return onTouchEvent(ev);
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        final float x = event.getX();
+        final float y = event.getY();
+
+        if (!mDragEnabled || mCurrentSongDuration <= 0) {
+            return false;
+        }
+
+        switch (event.getActionMasked()) {
+            case MotionEvent.ACTION_DOWN:
+                mDownX = event.getX();
+                mDownY = event.getY();
+                mDownAngle = angle(mDownX, mDownY);
+                mDragAngle = REVOLUTION_IN_DEGREES
+                        * (mCurrentSongProgress / (float) mCurrentSongDuration);
+                mDragPercentage = mDragAngle / REVOLUTION_IN_DEGREES;
+                mDragging = false;
+                break;
+            case MotionEvent.ACTION_MOVE:
+                // if the user has moved a certain distance
+                if (Math.sqrt(Math.pow(event.getX() - mDownX, 2)
+                        + Math.pow(event.getY() - mDownY, 2)) < mSmallDistance) {
+                    return false;
+                }
+
+                // if we weren't previously dragging, immediately kick off an update to reflect
+                // the change faster
+                if (!mDragging) {
+                    postUpdate();
+                }
+
+                mDragging = true;
+                getParent().requestDisallowInterceptTouchEvent(true);
+
+                // calculate the amount of angle we've moved
+                final float deltaAngle = getDelta(x, y);
+                mDragAngle = cropAngle(mDragAngle + deltaAngle);
+                mDragPercentage = mDragAngle / REVOLUTION_IN_DEGREES;
+
+                if (DEBUG) {
+                    Log.d(TAG, "Delta Angle: " + deltaAngle + ", Target Angle: " + mDownAngle);
+                }
+
+                return true;
+            case MotionEvent.ACTION_UP:
+            case MotionEvent.ACTION_CANCEL:
+                // if we were dragging, seek to where we dragged to
+                if (mDragging) {
+                    MusicUtils.seek((long) (mDragPercentage * mCurrentSongDuration));
+                }
+                mDragging = false;
+            default:
+                break;
+        }
+        return mDragging;
+    }
+
+    /**
+     * Gets the change in angle from the down angle and updates the down angle to the current angle
+     */
+    private float getDelta(float x, float y) {
+        float angle = angle(x, y);
+        float deltaAngle = wrapHalfRevolution(angle - mDownAngle);
+        mDownAngle = angle;
+        return deltaAngle;
+    }
+
+    /**
+     * Calculates the angle at the point passed in based on the center of the button
+     */
+    private float angle(float x, float y) {
+        float center = mWidth / 2.0f;
+        x -= center;
+        y -= center;
+
+        if (x == 0.0f) {
+            if (y > 0.0f) {
+                return 180.0f;
+            } else {
+                return 0.0f;
+            }
+        }
+
+        float angle = (float) (Math.atan(y / x) / Math.PI * 180.0);
+        if (x > 0.0f) {
+            angle += 90;
+        } else {
+            angle += 270;
+        }
+        return angle;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/PopupMenuButton.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/PopupMenuButton.java
new file mode 100755
index 0000000000..a9d1dd68ba
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/PopupMenuButton.java
@@ -0,0 +1,59 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.dolzzo.twelve.R;
+
+public class PopupMenuButton extends ImageView implements IPopupMenuCallback,
+        View.OnClickListener {
+    protected int mPosition = -1;
+    protected IListener mClickListener = null;
+
+    public PopupMenuButton(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        setScaleType(ScaleType.CENTER_INSIDE);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            setBackground(getResources().getDrawable(R.drawable.selectable_background_light));
+        } else {
+            setBackgroundResource(R.drawable.selectable_background_light);
+        }
+        setOnClickListener(this);
+    }
+
+    public void setPosition(final int position) {
+        mPosition = position;
+    }
+
+    @Override
+    public void setPopupMenuClickedListener(final IListener listener) {
+        mClickListener = listener;
+    }
+
+    @Override
+    public void onClick(View v) {
+        if (mClickListener != null) {
+            mClickListener.onPopupMenuClicked(v, mPosition);
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/RepeatButton.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/RepeatButton.java
new file mode 100755
index 0000000000..2b4cecbef9
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/RepeatButton.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.ImageButton;
+
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * A custom {@link ImageButton} that represents the "repeat" button.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class RepeatButton extends AudioButton {
+    public RepeatButton(final Context context, final AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    public void onClick(final View v) {
+        MusicUtils.cycleRepeat();
+        updateRepeatState();
+    }
+
+    /**
+     * Sets the correct drawable for the repeat state.
+     */
+    public void updateRepeatState() {
+        switch (MusicUtils.getRepeatMode()) {
+            case MusicPlaybackService.REPEAT_ALL:
+                setContentDescription(getResources().getString(R.string.accessibility_repeat_all));
+                setImageDrawable(getResources().getDrawable(R.drawable.btn_playback_repeat_all));
+                setAlpha(ACTIVE_ALPHA);
+                break;
+            case MusicPlaybackService.REPEAT_CURRENT:
+                setContentDescription(getResources().getString(R.string.accessibility_repeat_one));
+                setImageDrawable(getResources().getDrawable(R.drawable.btn_playback_repeat_one));
+                setAlpha(ACTIVE_ALPHA);
+                break;
+            case MusicPlaybackService.REPEAT_NONE:
+                setContentDescription(getResources().getString(R.string.accessibility_repeat));
+                setImageDrawable(getResources().getDrawable(R.drawable.btn_playback_repeat_all));
+                setAlpha(INACTIVE_ALPHA);
+                break;
+            default:
+                break;
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/RepeatingImageButton.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/RepeatingImageButton.java
new file mode 100755
index 0000000000..92010a4fe6
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/RepeatingImageButton.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project Licensed under the Apache
+ * License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.os.Build;
+import android.os.SystemClock;
+import android.util.AttributeSet;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.widget.ImageButton;
+
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.utils.ApolloUtils;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * A {@link ImageButton} that will repeatedly call a 'listener' method as long
+ * as the button is pressed, otherwise functions like a typecal
+ * {@link ImageButton}
+ */
+public class RepeatingImageButton extends ImageButton implements OnClickListener {
+
+    private static final long sInterval = 400;
+
+    private long mStartTime;
+
+    private int mRepeatCount;
+
+    private RepeatListener mListener;
+    private final Runnable mRepeater = new Runnable() {
+        @Override
+        public void run() {
+            doRepeat(false);
+            if (isPressed()) {
+                postDelayed(this, sInterval);
+            }
+        }
+    };
+
+    /**
+     * @param context The {@link Context} to use
+     * @param attrs   The attributes of the XML tag that is inflating the view.
+     */
+    @SuppressWarnings("deprecation")
+    public RepeatingImageButton(final Context context, final AttributeSet attrs) {
+        super(context, attrs);
+        setPadding(0, 0, 0, 0);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            setBackground(getResources().getDrawable(R.drawable.selectable_background));
+        } else {
+            setBackgroundResource(R.drawable.selectable_background);
+        }
+        setFocusable(true);
+        setLongClickable(true);
+        setOnClickListener(this);
+        updateState();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onClick(final View view) {
+        switch (view.getId()) {
+            case R.id.action_button_previous:
+                MusicUtils.previous(getContext(), false);
+                break;
+            case R.id.action_button_next:
+                MusicUtils.next();
+            default:
+                break;
+        }
+    }
+
+    /**
+     * Sets the listener to be called while the button is pressed and the
+     * interval in milliseconds with which it will be called.
+     *
+     * @param l        The listener that will be called
+     * @param interval The interval in milliseconds for calls
+     */
+    public void setRepeatListener(final RepeatListener l) {
+        mListener = l;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean performLongClick() {
+        if (mListener == null) {
+            ApolloUtils.showCheatSheet(this);
+        }
+        mStartTime = SystemClock.elapsedRealtime();
+        mRepeatCount = 0;
+        post(mRepeater);
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onTouchEvent(final MotionEvent event) {
+        if (event.getAction() == MotionEvent.ACTION_UP) {
+            /* Remove the repeater, but call the hook one more time */
+            removeCallbacks(mRepeater);
+            if (mStartTime != 0) {
+                doRepeat(true);
+                mStartTime = 0;
+            }
+        }
+        return super.onTouchEvent(event);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onKeyDown(final int keyCode, final KeyEvent event) {
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+            case KeyEvent.KEYCODE_ENTER:
+                /*
+                 * Need to call super to make long press work, but return true
+                 * so that the application doesn't get the down event
+                 */
+                super.onKeyDown(keyCode, event);
+                return true;
+        }
+        return super.onKeyDown(keyCode, event);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onKeyUp(final int keyCode, final KeyEvent event) {
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+            case KeyEvent.KEYCODE_ENTER:
+                /* Remove the repeater, but call the hook one more time */
+                removeCallbacks(mRepeater);
+                if (mStartTime != 0) {
+                    doRepeat(true);
+                    mStartTime = 0;
+                }
+        }
+        return super.onKeyUp(keyCode, event);
+    }
+
+    /**
+     * @param shouldRepeat If True the repeat count stops at -1, false if to add
+     *                     incrementally add the repeat count
+     */
+    private void doRepeat(final boolean shouldRepeat) {
+        final long now = SystemClock.elapsedRealtime();
+        if (mListener != null) {
+            mListener.onRepeat(this, now - mStartTime, shouldRepeat ? -1 : mRepeatCount++);
+        }
+    }
+
+    /**
+     * Sets the correct drawable for playback.
+     */
+    public void updateState() {
+        switch (getId()) {
+            case R.id.action_button_next:
+                setImageDrawable(getResources().getDrawable(R.drawable.btn_playback_next));
+                break;
+            case R.id.action_button_previous:
+                setImageDrawable(getResources().getDrawable(R.drawable.btn_playback_previous));
+                break;
+            default:
+                break;
+        }
+    }
+
+    public interface RepeatListener {
+
+        /**
+         * @param v           View to be set
+         * @param duration    Duration of the long press
+         * @param repeatcount The number of repeat counts
+         */
+        void onRepeat(View v, long duration, int repeatcount);
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/ShuffleButton.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/ShuffleButton.java
new file mode 100755
index 0000000000..579da20ecb
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/ShuffleButton.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+
+import com.dolzzo.twelve.MusicPlaybackService;
+import com.dolzzo.twelve.R;
+import com.dolzzo.twelve.utils.MusicUtils;
+
+/**
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class ShuffleButton extends AudioButton {
+    public ShuffleButton(final Context context, final AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    public void onClick(final View v) {
+        MusicUtils.cycleShuffle();
+        updateShuffleState();
+    }
+
+    /**
+     * Sets the correct drawable for the shuffle state.
+     */
+    public void updateShuffleState() {
+        switch (MusicUtils.getShuffleMode()) {
+            case MusicPlaybackService.SHUFFLE_NORMAL:
+                setContentDescription(getResources().getString(R.string.accessibility_shuffle_all));
+                setAlpha(ACTIVE_ALPHA);
+                break;
+            case MusicPlaybackService.SHUFFLE_AUTO:
+                setContentDescription(getResources().getString(R.string.accessibility_shuffle_all));
+                setAlpha(ACTIVE_ALPHA);
+                break;
+            case MusicPlaybackService.SHUFFLE_NONE:
+                setContentDescription(getResources().getString(R.string.accessibility_shuffle));
+                setAlpha(INACTIVE_ALPHA);
+                break;
+            default:
+                break;
+        }
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareFrame.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareFrame.java
new file mode 100755
index 0000000000..a34da96ece
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareFrame.java
@@ -0,0 +1,18 @@
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.widget.FrameLayout;
+
+public class SquareFrame extends FrameLayout {
+    public SquareFrame(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    public void onMeasure(final int widthSpec, final int heightSpec) {
+        super.onMeasure(widthSpec, heightSpec);
+        final int mSize = Math.min(getMeasuredWidth(), getMeasuredHeight());
+        setMeasuredDimension(mSize, mSize);
+    }
+}
\ No newline at end of file
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareImageView.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareImageView.java
new file mode 100755
index 0000000000..c36603295c
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareImageView.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.widget.ImageView;
+
+/**
+ * A custom {@link ImageView} that is sized to be a perfect square, otherwise
+ * functions like a typical {@link ImageView}.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class SquareImageView extends LayoutSuppressingImageView {
+
+    /**
+     * @param context The {@link Context} to use
+     * @param attrs   The attributes of the XML tag that is inflating the view.
+     */
+    public SquareImageView(final Context context, final AttributeSet attrs) {
+        super(context, attrs);
+
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onMeasure(final int widthSpec, final int heightSpec) {
+        super.onMeasure(widthSpec, heightSpec);
+        final int mSize = Math.min(getMeasuredWidth(), getMeasuredHeight());
+        setMeasuredDimension(mSize, mSize);
+    }
+
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareView.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareView.java
new file mode 100755
index 0000000000..34bab49edf
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareView.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2012 Andrew Neal
+ * Copyright (C) 2014 The CyanogenMod Project
+ * Licensed under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewGroup;
+
+/**
+ * A custom {@link ViewGroup} used to make it's children into perfect squares.
+ * Useful when dealing with grid images and especially album art.
+ *
+ * @author Andrew Neal (andrewdneal@gmail.com)
+ */
+public class SquareView extends ViewGroup {
+
+    /**
+     * @param context The {@link Context} to use
+     * @param attrs   The attributes of the XML tag that is inflating the view.
+     */
+    public SquareView(final Context context, final AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onMeasure(final int widthMeasureSpec, final int heightMeasureSpec) {
+        final View mChildren = getChildAt(0);
+        mChildren.measure(widthMeasureSpec, widthMeasureSpec);
+        final int mWidth = resolveSize(mChildren.getMeasuredWidth(), widthMeasureSpec);
+        mChildren.measure(mWidth, mWidth);
+        setMeasuredDimension(mWidth, mWidth);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onLayout(final boolean changed, final int l, final int u, final int r,
+                            final int d) {
+        getChildAt(0).layout(0, 0, r - l, d - u);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void requestLayout() {
+        forceLayout();
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareViewPager.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareViewPager.java
new file mode 100755
index 0000000000..5b574cd189
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/SquareViewPager.java
@@ -0,0 +1,45 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.support.v4.view.ViewPager;
+import android.util.AttributeSet;
+
+/**
+ * A custom {@link ViewPager} that is sized to be a perfect square, otherwise
+ * functions like a typical {@link ViewPager}.
+ */
+public class SquareViewPager extends ViewPager {
+
+    /**
+     * @param context The {@link Context} to use
+     * @param attrs   The attributes of the XML tag that is inflating the view.
+     */
+    public SquareViewPager(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        final int mSize = Math.min(getMeasuredWidth(), getMeasuredHeight());
+        setMeasuredDimension(mSize, mSize);
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/ViewPagerTabStrip.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/ViewPagerTabStrip.java
new file mode 100755
index 0000000000..2f0c49b270
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/ViewPagerTabStrip.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.LinearLayout;
+
+import com.dolzzo.twelve.R;
+
+public class ViewPagerTabStrip extends LinearLayout {
+    private final Paint mSelectedUnderlinePaint;
+    private int mSelectedUnderlineThickness;
+    private int mIndexForSelection;
+    private float mSelectionOffset;
+
+    public ViewPagerTabStrip(Context context) {
+        this(context, null);
+    }
+
+    public ViewPagerTabStrip(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        final Resources res = context.getResources();
+
+        mSelectedUnderlineThickness =
+                res.getDimensionPixelSize(R.dimen.tab_selected_underline_height);
+        int underlineColor = res.getColor(R.color.tab_selected_underline_color);
+        int backgroundColor = res.getColor(R.color.header_action_bar_color);
+
+        mSelectedUnderlinePaint = new Paint();
+        mSelectedUnderlinePaint.setColor(underlineColor);
+
+        setBackgroundColor(backgroundColor);
+        setWillNotDraw(false);
+    }
+
+    /**
+     * Notifies this view that view pager has been scrolled. We save the tab index
+     * and selection offset for interpolating the position and width of selection
+     * underline.
+     */
+    void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+        mIndexForSelection = position;
+        mSelectionOffset = positionOffset;
+        invalidate();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        int childCount = getChildCount();
+
+        // Thick colored underline below the current selection
+        if (childCount > 0) {
+            View selectedTitle = getChildAt(mIndexForSelection);
+            int selectedLeft = selectedTitle.getLeft();
+            int selectedRight = selectedTitle.getRight();
+            final boolean isRtl = isRtl();
+            final boolean hasNextTab = isRtl ? mIndexForSelection > 0
+                    : (mIndexForSelection < (getChildCount() - 1));
+            if ((mSelectionOffset > 0.0f) && hasNextTab) {
+                // Draw the selection partway between the tabs
+                View nextTitle = getChildAt(mIndexForSelection + (isRtl ? -1 : 1));
+                int nextLeft = nextTitle.getLeft();
+                int nextRight = nextTitle.getRight();
+
+                selectedLeft = (int) (mSelectionOffset * nextLeft +
+                        (1.0f - mSelectionOffset) * selectedLeft);
+                selectedRight = (int) (mSelectionOffset * nextRight +
+                        (1.0f - mSelectionOffset) * selectedRight);
+            }
+
+            int height = getHeight();
+            canvas.drawRect(selectedLeft, height - mSelectedUnderlineThickness,
+                    selectedRight, height, mSelectedUnderlinePaint);
+        }
+    }
+
+    private boolean isRtl() {
+        return getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/ViewPagerTabs.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/ViewPagerTabs.java
new file mode 100755
index 0000000000..2201fcb41b
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/ViewPagerTabs.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.dolzzo.twelve.widgets;
+
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.TypedArray;
+import android.graphics.Outline;
+import android.os.Build;
+import android.support.v4.view.PagerAdapter;
+import android.support.v4.view.ViewPager;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewOutlineProvider;
+import android.widget.HorizontalScrollView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.dolzzo.twelve.R;
+
+/**
+ * Lightweight implementation of ViewPager tabs. This looks similar to traditional actionBar tabs,
+ * but allows for the view containing the tabs to be placed anywhere on screen. Text-related
+ * attributes can also be assigned in XML - these will get propogated to the child TextViews
+ * automatically.
+ */
+public class ViewPagerTabs extends HorizontalScrollView implements ViewPager.OnPageChangeListener {
+
+    private static final int TAB_SIDE_PADDING_IN_DPS = 10;
+    // TODO: This should use <declare-styleable> in the future
+    private static final int[] ATTRS = new int[]{
+            android.R.attr.textSize,
+            android.R.attr.textStyle,
+            android.R.attr.textColor,
+            android.R.attr.textAllCaps
+    };
+    /**
+     * Linearlayout that will contain the TextViews serving as tabs. This is the only child
+     * of the parent HorizontalScrollView.
+     */
+    final int mTextStyle;
+    final ColorStateList mTextColor;
+    final int mTextSize;
+    final boolean mTextAllCaps;
+    ViewPager mPager;
+    int mPrevSelected = -1;
+    int mSidePadding;
+    private ViewPagerTabStrip mTabStrip;
+
+    public ViewPagerTabs(Context context) {
+        this(context, null);
+    }
+
+    public ViewPagerTabs(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public ViewPagerTabs(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        setFillViewport(true);
+
+        mSidePadding = (int) (getResources().getDisplayMetrics().density * TAB_SIDE_PADDING_IN_DPS);
+
+        final TypedArray a = context.obtainStyledAttributes(attrs, ATTRS);
+        mTextSize = a.getDimensionPixelSize(0, 0);
+        mTextStyle = a.getInt(1, 0);
+        mTextColor = a.getColorStateList(2);
+        mTextAllCaps = a.getBoolean(3, false);
+
+        mTabStrip = new ViewPagerTabStrip(context);
+        addView(mTabStrip,
+                new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT));
+        a.recycle();
+
+        // enable shadow casting from view bounds
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            setOutlineProvider(new ViewOutlineProvider() {
+                @Override
+                public void getOutline(View view, Outline outline) {
+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                        outline.setRect(0, 0, view.getWidth(), view.getHeight());
+                    }
+                }
+            });
+        }
+    }
+
+    public void setViewPager(ViewPager viewPager) {
+        mPager = viewPager;
+        addTabs(mPager.getAdapter());
+    }
+
+    private void addTabs(PagerAdapter adapter) {
+        mTabStrip.removeAllViews();
+
+        final int count = adapter.getCount();
+        for (int i = 0; i < count; i++) {
+            addTab(adapter.getPageTitle(i), i);
+        }
+    }
+
+    private void addTab(CharSequence tabTitle, final int position) {
+        final TextView textView = new TextView(getContext());
+        textView.setText(tabTitle);
+        textView.setBackgroundResource(R.drawable.view_pager_tab_background);
+        textView.setGravity(Gravity.CENTER);
+        textView.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                mPager.setCurrentItem(getRtlPosition(position));
+            }
+        });
+
+        textView.setOnLongClickListener(new OnTabLongClickListener(position));
+
+        // Assign various text appearance related attributes to child views.
+        if (mTextStyle > 0) {
+            textView.setTypeface(textView.getTypeface(), mTextStyle);
+        }
+        if (mTextSize > 0) {
+            textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextSize);
+        }
+        if (mTextColor != null) {
+            textView.setTextColor(mTextColor);
+        }
+        textView.setAllCaps(mTextAllCaps);
+        textView.setPadding(mSidePadding, 0, mSidePadding, 0);
+        mTabStrip.addView(textView, new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT,
+                LayoutParams.MATCH_PARENT, 1));
+        // Default to the first child being selected
+        if (position == 0) {
+            mPrevSelected = 0;
+            textView.setSelected(true);
+        }
+    }
+
+    @Override
+    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+        position = getRtlPosition(position);
+        int tabStripChildCount = mTabStrip.getChildCount();
+        if ((tabStripChildCount == 0) || (position < 0) || (position >= tabStripChildCount)) {
+            return;
+        }
+
+        mTabStrip.onPageScrolled(position, positionOffset, positionOffsetPixels);
+    }
+
+    @Override
+    public void onPageSelected(int position) {
+        position = getRtlPosition(position);
+        if (mPrevSelected >= 0) {
+            mTabStrip.getChildAt(mPrevSelected).setSelected(false);
+        }
+        final View selectedChild = mTabStrip.getChildAt(position);
+        selectedChild.setSelected(true);
+
+        // Update scroll position
+        final int scrollPos = selectedChild.getLeft() - (getWidth() - selectedChild.getWidth()) / 2;
+        smoothScrollTo(scrollPos, 0);
+        mPrevSelected = position;
+    }
+
+    @Override
+    public void onPageScrollStateChanged(int state) {
+    }
+
+    private int getRtlPosition(int position) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
+                return mTabStrip.getChildCount() - 1 - position;
+            }
+        }
+        return position;
+    }
+
+    /**
+     * Simulates actionbar tab behavior by showing a toast with the tab title when long clicked.
+     */
+    private class OnTabLongClickListener implements OnLongClickListener {
+        final int mPosition;
+
+        public OnTabLongClickListener(int position) {
+            mPosition = position;
+        }
+
+        @Override
+        public boolean onLongClick(View v) {
+            final int[] screenPos = new int[2];
+            getLocationOnScreen(screenPos);
+
+            final Context context = getContext();
+            final int width = getWidth();
+            final int height = getHeight();
+            final int screenWidth = context.getResources().getDisplayMetrics().widthPixels;
+
+            Toast toast = Toast.makeText(context, mPager.getAdapter().getPageTitle(mPosition),
+                    Toast.LENGTH_SHORT);
+
+            // Show the toast under the tab
+            toast.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL,
+                    (screenPos[0] + width / 2) - screenWidth / 2, screenPos[1] + height);
+
+            toast.show();
+            return true;
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/dolzzo/twelve/widgets/VisualizerView.java b/twelve/src/main/java/com/dolzzo/twelve/widgets/VisualizerView.java
new file mode 100755
index 0000000000..ec36dc74ec
--- /dev/null
+++ b/twelve/src/main/java/com/dolzzo/twelve/widgets/VisualizerView.java
@@ -0,0 +1,223 @@
+/*
+* Copyright (C) 2014 The CyanogenMod Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package com.dolzzo.twelve.widgets;
+
+import android.animation.ObjectAnimator;
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.media.audiofx.Visualizer;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.util.AttributeSet;
+import android.view.View;
+
+import com.dolzzo.twelve.R;
+
+public class VisualizerView extends View {
+    private Paint mPaint;
+    private Visualizer mVisualizer;
+    private final Runnable mUnlinkVisualizer = new Runnable() {
+        @Override
+        public void run() {
+            mVisualizer.setEnabled(false);
+            mVisualizer.release();
+            mVisualizer = null;
+        }
+    };
+    private ObjectAnimator mVisualizerColorAnimator;
+    private ValueAnimator[] mValueAnimators = new ValueAnimator[32];
+    private float[] mFFTPoints = new float[128];
+    private boolean mVisible = false;
+    private boolean mPlaying = false;
+    private boolean mPowerSaveMode = false;
+    private int mColor;
+    private Visualizer.OnDataCaptureListener mVisualizerListener =
+            new Visualizer.OnDataCaptureListener() {
+                byte rfk, ifk;
+                int dbValue;
+                float magnitude;
+
+                @Override
+                public void onWaveFormDataCapture(Visualizer visualizer, byte[] bytes, int samplingRate) {
+                }
+
+                @Override
+                public void onFftDataCapture(Visualizer visualizer, byte[] fft, int samplingRate) {
+                    for (int i = 0; i < 32; i++) {
+                        mValueAnimators[i].cancel();
+
+                        rfk = fft[i * 2 + 2];
+                        ifk = fft[i * 2 + 3];
+                        magnitude = rfk * rfk + ifk * ifk;
+                        dbValue = magnitude > 0 ? (int) (10 * Math.log10(magnitude)) : 0;
+
+                        mValueAnimators[i].setFloatValues(mFFTPoints[i * 4 + 1],
+                                mFFTPoints[3] - (dbValue * 16f));
+                        mValueAnimators[i].start();
+                    }
+                }
+            };
+    private final Runnable mLinkVisualizer = new Runnable() {
+        @Override
+        public void run() {
+            try {
+                mVisualizer = new Visualizer(0);
+            } catch (Exception e) {
+                return;
+            }
+
+            mVisualizer.setEnabled(false);
+            mVisualizer.setCaptureSize(66);
+            mVisualizer.setDataCaptureListener(mVisualizerListener, Visualizer.getMaxCaptureRate(),
+                    false, true);
+            mVisualizer.setEnabled(true);
+        }
+    };
+
+    public VisualizerView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+    }
+
+    public VisualizerView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public VisualizerView(Context context) {
+        this(context, null, 0);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        final int size = Math.min(getMeasuredWidth(), getMeasuredHeight());
+        setMeasuredDimension(size, size);
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+
+        float barUnit = w / 32f;
+        float barWidth = barUnit * 8f / 9f;
+        barUnit = barWidth + (barUnit - barWidth) * 32f / 31f;
+        mPaint.setStrokeWidth(barWidth);
+
+        for (int i = 0; i < 32; i++) {
+            mFFTPoints[i * 4] = mFFTPoints[i * 4 + 2] = i * barUnit + (barWidth / 2);
+            mFFTPoints[i * 4 + 3] = h;
+        }
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        if (mVisualizer != null) {
+            canvas.drawLines(mFFTPoints, mPaint);
+        }
+    }
+
+    public void initialize(Context context) {
+        mColor = context.getResources().getColor(R.color.visualizer_fill_color);
+
+        mPaint = new Paint();
+        mPaint.setAntiAlias(true);
+        mPaint.setColor(mColor);
+
+        for (int i = 0; i < 32; i++) {
+            final int j = i * 4 + 1;
+            mValueAnimators[i] = new ValueAnimator();
+            mValueAnimators[i].setDuration(128);
+            mValueAnimators[i].addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                @Override
+                public void onAnimationUpdate(ValueAnimator animation) {
+                    mFFTPoints[j] = (float) animation.getAnimatedValue();
+                }
+            });
+        }
+
+        mValueAnimators[31].addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator animation) {
+                postInvalidate();
+            }
+        });
+    }
+
+    public void setVisible(boolean visible) {
+        if (mVisible != visible) {
+            mVisible = visible;
+            checkStateChanged();
+        }
+    }
+
+    public void setPlaying(boolean playing) {
+        if (mPlaying != playing) {
+            mPlaying = playing;
+            checkStateChanged();
+        }
+    }
+
+    public void setPowerSaveMode(boolean powerSaveMode) {
+        if (mPowerSaveMode != powerSaveMode) {
+            mPowerSaveMode = powerSaveMode;
+            checkStateChanged();
+        }
+    }
+
+    public void setColor(int color) {
+        color = Color.argb(191, Color.red(color), Color.green(color), Color.blue(color));
+
+        if (mColor != color) {
+            mColor = color;
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                if (mVisualizer != null) {
+                    if (mVisualizerColorAnimator != null) {
+                        mVisualizerColorAnimator.cancel();
+                    }
+
+                    mVisualizerColorAnimator = ObjectAnimator.ofArgb(mPaint, "color",
+                            mPaint.getColor(), mColor);
+                    mVisualizerColorAnimator.setStartDelay(600);
+                    mVisualizerColorAnimator.setDuration(1200);
+                    mVisualizerColorAnimator.start();
+                } else {
+                    mPaint.setColor(mColor);
+                }
+            } else {
+                mPaint.setColor(mColor);
+            }
+        }
+    }
+
+    private void checkStateChanged() {
+        if (mVisible && mPlaying && !mPowerSaveMode) {
+            if (mVisualizer == null) {
+                AsyncTask.execute(mLinkVisualizer);
+                animate().alpha(1f).setDuration(300);
+            }
+        } else {
+            if (mVisualizer != null) {
+                animate().alpha(0f).setDuration(0);
+                AsyncTask.execute(mUnlinkVisualizer);
+            }
+        }
+    }
+}
diff --git a/twelve/src/main/java/com/google/android/exoplayer2/TwelvePlayer.java b/twelve/src/main/java/com/google/android/exoplayer2/TwelvePlayer.java
new file mode 100755
index 0000000000..48e535db8e
--- /dev/null
+++ b/twelve/src/main/java/com/google/android/exoplayer2/TwelvePlayer.java
@@ -0,0 +1,1020 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.graphics.SurfaceTexture;
+import android.media.MediaCodec;
+import android.media.PlaybackParams;
+import android.os.Handler;
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import android.view.Surface;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.TextureView;
+import com.google.android.exoplayer2.audio.AudioCapabilities;
+import com.google.android.exoplayer2.audio.AudioProcessor;
+import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
+import com.google.android.exoplayer2.decoder.DecoderCounters;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer2.mediacodec.MediaCodecSelector;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataRenderer;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.TextRenderer;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
+import com.google.android.exoplayer2.video.VideoRendererEventListener;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * An {@link ExoPlayer} implementation that uses default {@link Renderer} components. Instances can
+ * be obtained from {@link ExoPlayerFactory}.
+ */
+@TargetApi(16)
+public class TwelvePlayer implements ExoPlayer {
+
+    /**
+     * A listener for video rendering information from a {@link SimpleExoPlayer}.
+     */
+    public interface VideoListener {
+
+        /**
+         * Called each time there's a change in the size of the video being rendered.
+         *
+         * @param width The video width in pixels.
+         * @param height The video height in pixels.
+         * @param unappliedRotationDegrees For videos that require a rotation, this is the clockwise
+         *     rotation in degrees that the application should apply for the video for it to be rendered
+         *     in the correct orientation. This value will always be zero on API levels 21 and above,
+         *     since the renderer will apply all necessary rotations internally. On earlier API levels
+         *     this is not possible. Applications that use {@link android.view.TextureView} can apply
+         *     the rotation by calling {@link android.view.TextureView#setTransform}. Applications that
+         *     do not expect to encounter rotated videos can safely ignore this parameter.
+         * @param pixelWidthHeightRatio The width to height ratio of each pixel. For the normal case
+         *     of square pixels this will be equal to 1.0. Different values are indicative of anamorphic
+         *     content.
+         */
+        void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
+                                float pixelWidthHeightRatio);
+
+        /**
+         * Called when a frame is rendered for the first time since setting the surface, and when a
+         * frame is rendered for the first time since a video track was selected.
+         */
+        void onRenderedFirstFrame();
+
+    }
+
+    /**
+     * Modes for using extension renderers.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({EXTENSION_RENDERER_MODE_OFF, EXTENSION_RENDERER_MODE_ON, EXTENSION_RENDERER_MODE_PREFER})
+    public @interface ExtensionRendererMode {}
+    /**
+     * Do not allow use of extension renderers.
+     */
+    public static final int EXTENSION_RENDERER_MODE_OFF = 0;
+    /**
+     * Allow use of extension renderers. Extension renderers are indexed after core renderers of the
+     * same type. A {@link TrackSelector} that prefers the first suitable renderer will therefore
+     * prefer to use a core renderer to an extension renderer in the case that both are able to play
+     * a given track.
+     */
+    public static final int EXTENSION_RENDERER_MODE_ON = 1;
+    /**
+     * Allow use of extension renderers. Extension renderers are indexed before core renderers of the
+     * same type. A {@link TrackSelector} that prefers the first suitable renderer will therefore
+     * prefer to use an extension renderer to a core renderer in the case that both are able to play
+     * a given track.
+     */
+    public static final int EXTENSION_RENDERER_MODE_PREFER = 2;
+
+    private static final String TAG = "SimpleExoPlayer";
+    protected static final int MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY = 50;
+
+    private final ExoPlayer player;
+    private final Renderer[] renderers;
+    private final ComponentListener componentListener;
+    private final Handler mainHandler;
+    private final int videoRendererCount;
+    private final int audioRendererCount;
+
+    private Format videoFormat;
+    private Format audioFormat;
+
+    private Surface surface;
+    private boolean ownsSurface;
+    @C.VideoScalingMode
+    private int videoScalingMode;
+    private SurfaceHolder surfaceHolder;
+    private TextureView textureView;
+    private TextRenderer.Output textOutput;
+    private MetadataRenderer.Output metadataOutput;
+    private VideoListener videoListener;
+    private AudioRendererEventListener audioDebugListener;
+    private VideoRendererEventListener videoDebugListener;
+    private DecoderCounters videoDecoderCounters;
+    private DecoderCounters audioDecoderCounters;
+    private int audioSessionId;
+    @C.StreamType
+    private int audioStreamType;
+    private float audioVolume;
+
+    protected TwelvePlayer(Context context, TrackSelector trackSelector, LoadControl loadControl,
+                              DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+                              @ExtensionRendererMode int extensionRendererMode, long allowedVideoJoiningTimeMs) {
+        mainHandler = new Handler();
+        componentListener = new ComponentListener();
+
+        // Build the renderers.
+        ArrayList<Renderer> renderersList = new ArrayList<>();
+        buildRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
+                allowedVideoJoiningTimeMs, renderersList);
+        renderers = renderersList.toArray(new Renderer[renderersList.size()]);
+
+        // Obtain counts of video and audio renderers.
+        int videoRendererCount = 0;
+        int audioRendererCount = 0;
+        for (Renderer renderer : renderers) {
+            switch (renderer.getTrackType()) {
+                case C.TRACK_TYPE_VIDEO:
+                    videoRendererCount++;
+                    break;
+                case C.TRACK_TYPE_AUDIO:
+                    audioRendererCount++;
+                    break;
+            }
+        }
+        this.videoRendererCount = videoRendererCount;
+        this.audioRendererCount = audioRendererCount;
+
+        // Set initial values.
+        audioVolume = 1;
+        audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+        audioStreamType = C.STREAM_TYPE_DEFAULT;
+        videoScalingMode = C.VIDEO_SCALING_MODE_DEFAULT;
+
+        // Build the player and associated objects.
+        player = new ExoPlayerImpl(renderers, trackSelector, loadControl);
+    }
+
+    /**
+     * Sets the video scaling mode.
+     * <p>
+     * Note that the scaling mode only applies if a {@link MediaCodec}-based video {@link Renderer} is
+     * enabled and if the output surface is owned by a {@link android.view.SurfaceView}.
+     *
+     * @param videoScalingMode The video scaling mode.
+     */
+    public void setVideoScalingMode(@C.VideoScalingMode int videoScalingMode) {
+        this.videoScalingMode = videoScalingMode;
+        ExoPlayerMessage[] messages = new ExoPlayerMessage[videoRendererCount];
+        int count = 0;
+        for (Renderer renderer : renderers) {
+            if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
+                messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_SCALING_MODE,
+                        videoScalingMode);
+            }
+        }
+        player.sendMessages(messages);
+    }
+
+    /**
+     * Returns the video scaling mode.
+     */
+    public @C.VideoScalingMode int getVideoScalingMode() {
+        return videoScalingMode;
+    }
+
+    /**
+     * Clears any {@link Surface}, {@link SurfaceHolder}, {@link SurfaceView} or {@link TextureView}
+     * currently set on the player.
+     */
+    public void clearVideoSurface() {
+        setVideoSurface(null);
+    }
+
+    /**
+     * Sets the {@link Surface} onto which video will be rendered. The caller is responsible for
+     * tracking the lifecycle of the surface, and must clear the surface by calling
+     * {@code setVideoSurface(null)} if the surface is destroyed.
+     * <p>
+     * If the surface is held by a {@link SurfaceView}, {@link TextureView} or {@link SurfaceHolder}
+     * then it's recommended to use {@link #setVideoSurfaceView(SurfaceView)},
+     * {@link #setVideoTextureView(TextureView)} or {@link #setVideoSurfaceHolder(SurfaceHolder)}
+     * rather than this method, since passing the holder allows the player to track the lifecycle of
+     * the surface automatically.
+     *
+     * @param surface The {@link Surface}.
+     */
+    public void setVideoSurface(Surface surface) {
+        removeSurfaceCallbacks();
+        setVideoSurfaceInternal(surface, false);
+    }
+
+    /**
+     * Sets the {@link SurfaceHolder} that holds the {@link Surface} onto which video will be
+     * rendered. The player will track the lifecycle of the surface automatically.
+     *
+     * @param surfaceHolder The surface holder.
+     */
+    public void setVideoSurfaceHolder(SurfaceHolder surfaceHolder) {
+        removeSurfaceCallbacks();
+        this.surfaceHolder = surfaceHolder;
+        if (surfaceHolder == null) {
+            setVideoSurfaceInternal(null, false);
+        } else {
+            setVideoSurfaceInternal(surfaceHolder.getSurface(), false);
+            surfaceHolder.addCallback(componentListener);
+        }
+    }
+
+    /**
+     * Sets the {@link SurfaceView} onto which video will be rendered. The player will track the
+     * lifecycle of the surface automatically.
+     *
+     * @param surfaceView The surface view.
+     */
+    public void setVideoSurfaceView(SurfaceView surfaceView) {
+        setVideoSurfaceHolder(surfaceView.getHolder());
+    }
+
+    /**
+     * Sets the {@link TextureView} onto which video will be rendered. The player will track the
+     * lifecycle of the surface automatically.
+     *
+     * @param textureView The texture view.
+     */
+    public void setVideoTextureView(TextureView textureView) {
+        removeSurfaceCallbacks();
+        this.textureView = textureView;
+        if (textureView == null) {
+            setVideoSurfaceInternal(null, true);
+        } else {
+            if (textureView.getSurfaceTextureListener() != null) {
+                Log.w(TAG, "Replacing existing SurfaceTextureListener.");
+            }
+            SurfaceTexture surfaceTexture = textureView.getSurfaceTexture();
+            setVideoSurfaceInternal(surfaceTexture == null ? null : new Surface(surfaceTexture), true);
+            textureView.setSurfaceTextureListener(componentListener);
+        }
+    }
+
+    /**
+     * Sets the stream type for audio playback (see {@link C.StreamType} and
+     * {@link android.media.AudioTrack#AudioTrack(int, int, int, int, int, int)}). If the stream type
+     * is not set, audio renderers use {@link C#STREAM_TYPE_DEFAULT}.
+     * <p>
+     * Note that when the stream type changes, the AudioTrack must be reinitialized, which can
+     * introduce a brief gap in audio output. Note also that tracks in the same audio session must
+     * share the same routing, so a new audio session id will be generated.
+     *
+     * @param audioStreamType The stream type for audio playback.
+     */
+    public void setAudioStreamType(@C.StreamType int audioStreamType) {
+        this.audioStreamType = audioStreamType;
+        ExoPlayerMessage[] messages = new ExoPlayerMessage[audioRendererCount];
+        int count = 0;
+        for (Renderer renderer : renderers) {
+            if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
+                messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_STREAM_TYPE, audioStreamType);
+            }
+        }
+        player.sendMessages(messages);
+    }
+
+    /**
+     * Returns the stream type for audio playback.
+     */
+    public @C.StreamType int getAudioStreamType() {
+        return audioStreamType;
+    }
+
+    /**
+     * Sets the audio volume, with 0 being silence and 1 being unity gain.
+     *
+     * @param audioVolume The audio volume.
+     */
+    public void setVolume(float audioVolume) {
+        this.audioVolume = audioVolume;
+        ExoPlayerMessage[] messages = new ExoPlayerMessage[audioRendererCount];
+        int count = 0;
+        for (Renderer renderer : renderers) {
+            if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
+                messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_VOLUME, audioVolume);
+            }
+        }
+        player.sendMessages(messages);
+    }
+
+    /**
+     * Returns the audio volume, with 0 being silence and 1 being unity gain.
+     */
+    public float getVolume() {
+        return audioVolume;
+    }
+
+    /**
+     * Sets the {@link PlaybackParams} governing audio playback.
+     *
+     * @deprecated Use {@link #setPlaybackParameters(PlaybackParameters)}.
+     * @param params The {@link PlaybackParams}, or null to clear any previously set parameters.
+     */
+    @Deprecated
+    @TargetApi(23)
+    public void setPlaybackParams(@Nullable PlaybackParams params) {
+        PlaybackParameters playbackParameters;
+        if (params != null) {
+            params.allowDefaults();
+            playbackParameters = new PlaybackParameters(params.getSpeed(), params.getPitch());
+        } else {
+            playbackParameters = null;
+        }
+        setPlaybackParameters(playbackParameters);
+    }
+
+    /**
+     * Returns the video format currently being played, or null if no video is being played.
+     */
+    public Format getVideoFormat() {
+        return videoFormat;
+    }
+
+    /**
+     * Returns the audio format currently being played, or null if no audio is being played.
+     */
+    public Format getAudioFormat() {
+        return audioFormat;
+    }
+
+    /**
+     * Returns the audio session identifier, or {@link C#AUDIO_SESSION_ID_UNSET} if not set.
+     */
+    public int getAudioSessionId() {
+        return audioSessionId;
+    }
+
+    /**
+     * Returns {@link DecoderCounters} for video, or null if no video is being played.
+     */
+    public DecoderCounters getVideoDecoderCounters() {
+        return videoDecoderCounters;
+    }
+
+    /**
+     * Returns {@link DecoderCounters} for audio, or null if no audio is being played.
+     */
+    public DecoderCounters getAudioDecoderCounters() {
+        return audioDecoderCounters;
+    }
+
+    /**
+     * Sets a listener to receive video events.
+     *
+     * @param listener The listener.
+     */
+    public void setVideoListener(VideoListener listener) {
+        videoListener = listener;
+    }
+
+    /**
+     * Sets a listener to receive debug events from the video renderer.
+     *
+     * @param listener The listener.
+     */
+    public void setVideoDebugListener(VideoRendererEventListener listener) {
+        videoDebugListener = listener;
+    }
+
+    /**
+     * Sets a listener to receive debug events from the audio renderer.
+     *
+     * @param listener The listener.
+     */
+    public void setAudioDebugListener(AudioRendererEventListener listener) {
+        audioDebugListener = listener;
+    }
+
+    /**
+     * Sets an output to receive text events.
+     *
+     * @param output The output.
+     */
+    public void setTextOutput(TextRenderer.Output output) {
+        textOutput = output;
+    }
+
+    /**
+     * Sets a listener to receive metadata events.
+     *
+     * @param output The output.
+     */
+    public void setMetadataOutput(MetadataRenderer.Output output) {
+        metadataOutput = output;
+    }
+
+    // ExoPlayer implementation
+
+    @Override
+    public void addListener(EventListener listener) {
+        player.addListener(listener);
+    }
+
+    @Override
+    public void removeListener(EventListener listener) {
+        player.removeListener(listener);
+    }
+
+    @Override
+    public int getPlaybackState() {
+        return player.getPlaybackState();
+    }
+
+    @Override
+    public void prepare(MediaSource mediaSource) {
+        player.prepare(mediaSource);
+    }
+
+    @Override
+    public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+        player.prepare(mediaSource, resetPosition, resetState);
+    }
+
+    @Override
+    public void setPlayWhenReady(boolean playWhenReady) {
+        player.setPlayWhenReady(playWhenReady);
+    }
+
+    @Override
+    public boolean getPlayWhenReady() {
+        return player.getPlayWhenReady();
+    }
+
+    @Override
+    public boolean isLoading() {
+        return player.isLoading();
+    }
+
+    @Override
+    public void seekToDefaultPosition() {
+        player.seekToDefaultPosition();
+    }
+
+    @Override
+    public void seekToDefaultPosition(int windowIndex) {
+        player.seekToDefaultPosition(windowIndex);
+    }
+
+    @Override
+    public void seekTo(long positionMs) {
+        player.seekTo(positionMs);
+    }
+
+    @Override
+    public void seekTo(int windowIndex, long positionMs) {
+        player.seekTo(windowIndex, positionMs);
+    }
+
+    @Override
+    public void setPlaybackParameters(PlaybackParameters playbackParameters) {
+        player.setPlaybackParameters(playbackParameters);
+    }
+
+    @Override
+    public PlaybackParameters getPlaybackParameters() {
+        return player.getPlaybackParameters();
+    }
+
+    @Override
+    public void stop() {
+        player.stop();
+    }
+
+    @Override
+    public void release() {
+        player.release();
+        removeSurfaceCallbacks();
+        if (surface != null) {
+            if (ownsSurface) {
+                surface.release();
+            }
+            surface = null;
+        }
+    }
+
+    @Override
+    public void sendMessages(ExoPlayerMessage... messages) {
+        player.sendMessages(messages);
+    }
+
+    @Override
+    public void blockingSendMessages(ExoPlayerMessage... messages) {
+        player.blockingSendMessages(messages);
+    }
+
+    @Override
+    public int getRendererCount() {
+        return player.getRendererCount();
+    }
+
+    @Override
+    public int getRendererType(int index) {
+        return player.getRendererType(index);
+    }
+
+    @Override
+    public TrackGroupArray getCurrentTrackGroups() {
+        return player.getCurrentTrackGroups();
+    }
+
+    @Override
+    public TrackSelectionArray getCurrentTrackSelections() {
+        return player.getCurrentTrackSelections();
+    }
+
+    @Override
+    public Timeline getCurrentTimeline() {
+        return player.getCurrentTimeline();
+    }
+
+    @Override
+    public Object getCurrentManifest() {
+        return player.getCurrentManifest();
+    }
+
+    @Override
+    public int getCurrentPeriodIndex() {
+        return player.getCurrentPeriodIndex();
+    }
+
+    @Override
+    public int getCurrentWindowIndex() {
+        return player.getCurrentWindowIndex();
+    }
+
+    @Override
+    public long getDuration() {
+        return player.getDuration();
+    }
+
+    @Override
+    public long getCurrentPosition() {
+        return player.getCurrentPosition();
+    }
+
+    @Override
+    public long getBufferedPosition() {
+        return player.getBufferedPosition();
+    }
+
+    @Override
+    public int getBufferedPercentage() {
+        return player.getBufferedPercentage();
+    }
+
+    @Override
+    public boolean isCurrentWindowDynamic() {
+        return player.isCurrentWindowDynamic();
+    }
+
+    @Override
+    public boolean isCurrentWindowSeekable() {
+        return player.isCurrentWindowSeekable();
+    }
+
+    // Renderer building.
+
+    private void buildRenderers(Context context, Handler mainHandler,
+                                DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+                                @ExtensionRendererMode int extensionRendererMode, long allowedVideoJoiningTimeMs,
+                                ArrayList<Renderer> out) {
+        buildVideoRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
+                componentListener, allowedVideoJoiningTimeMs, out);
+        buildAudioRenderers(context, mainHandler, drmSessionManager, extensionRendererMode,
+                componentListener, buildAudioProcessors(), out);
+        buildTextRenderers(context, mainHandler, extensionRendererMode, componentListener, out);
+        buildMetadataRenderers(context, mainHandler, extensionRendererMode, componentListener, out);
+        buildMiscellaneousRenderers(context, mainHandler, extensionRendererMode, out);
+    }
+
+    /**
+     * Builds video renderers for use by the player.
+     *
+     * @param context The {@link Context} associated with the player.
+     * @param mainHandler A handler associated with the main thread's looper.
+     * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
+     *     not be used for DRM protected playbacks.
+     * @param extensionRendererMode The extension renderer mode.
+     * @param eventListener An event listener.
+     * @param allowedVideoJoiningTimeMs The maximum duration in milliseconds for which video renderers
+     *     can attempt to seamlessly join an ongoing playback.
+     * @param out An array to which the built renderers should be appended.
+     */
+    protected void buildVideoRenderers(Context context, Handler mainHandler,
+                                       DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+                                       @ExtensionRendererMode int extensionRendererMode, VideoRendererEventListener eventListener,
+                                       long allowedVideoJoiningTimeMs, ArrayList<Renderer> out) {
+        out.add(new MediaCodecVideoRenderer(context, MediaCodecSelector.DEFAULT,
+                allowedVideoJoiningTimeMs, drmSessionManager, false, mainHandler, eventListener,
+                MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY));
+
+        if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
+            return;
+        }
+        int extensionRendererIndex = out.size();
+        if (extensionRendererMode == EXTENSION_RENDERER_MODE_PREFER) {
+            extensionRendererIndex--;
+        }
+
+        try {
+            Class<?> clazz =
+                    Class.forName("com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer");
+            Constructor<?> constructor = clazz.getConstructor(boolean.class, long.class, Handler.class,
+                    VideoRendererEventListener.class, int.class);
+            Renderer renderer = (Renderer) constructor.newInstance(true, allowedVideoJoiningTimeMs,
+                    mainHandler, componentListener, MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
+            out.add(extensionRendererIndex++, renderer);
+            Log.i(TAG, "Loaded LibvpxVideoRenderer.");
+        } catch (ClassNotFoundException e) {
+            // Expected if the app was built without the extension.
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Builds audio renderers for use by the player.
+     *
+     * @param context The {@link Context} associated with the player.
+     * @param mainHandler A handler associated with the main thread's looper.
+     * @param drmSessionManager An optional {@link DrmSessionManager}. May be null if the player will
+     *     not be used for DRM protected playbacks.
+     * @param extensionRendererMode The extension renderer mode.
+     * @param eventListener An event listener.
+     * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio buffers
+     *     before output. May be empty.
+     * @param out An array to which the built renderers should be appended.
+     */
+    protected void buildAudioRenderers(Context context, Handler mainHandler,
+                                       DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+                                       @ExtensionRendererMode int extensionRendererMode, AudioRendererEventListener eventListener,
+                                       AudioProcessor[] audioProcessors, ArrayList<Renderer> out) {
+        out.add(new MediaCodecAudioRenderer(MediaCodecSelector.DEFAULT, drmSessionManager, true,
+                mainHandler, eventListener, AudioCapabilities.getCapabilities(context), audioProcessors));
+
+        if (extensionRendererMode == EXTENSION_RENDERER_MODE_OFF) {
+            return;
+        }
+        int extensionRendererIndex = out.size();
+        if (extensionRendererMode == EXTENSION_RENDERER_MODE_PREFER) {
+            extensionRendererIndex--;
+        }
+
+        try {
+            Class<?> clazz =
+                    Class.forName("com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer");
+            Constructor<?> constructor = clazz.getConstructor(Handler.class,
+                    AudioRendererEventListener.class, AudioProcessor[].class);
+            Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener,
+                    audioProcessors);
+            out.add(extensionRendererIndex++, renderer);
+            Log.i(TAG, "Loaded LibopusAudioRenderer.");
+        } catch (ClassNotFoundException e) {
+            // Expected if the app was built without the extension.
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+
+        try {
+            Class<?> clazz =
+                    Class.forName("com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer");
+            Constructor<?> constructor = clazz.getConstructor(Handler.class,
+                    AudioRendererEventListener.class, AudioProcessor[].class);
+            Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener,
+                    audioProcessors);
+            out.add(extensionRendererIndex++, renderer);
+            Log.i(TAG, "Loaded LibflacAudioRenderer.");
+        } catch (ClassNotFoundException e) {
+            // Expected if the app was built without the extension.
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+
+        try {
+            Class<?> clazz =
+                    Class.forName("com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer");
+            Constructor<?> constructor = clazz.getConstructor(Handler.class,
+                    AudioRendererEventListener.class, AudioProcessor[].class);
+            Renderer renderer = (Renderer) constructor.newInstance(mainHandler, componentListener,
+                    audioProcessors);
+            out.add(extensionRendererIndex++, renderer);
+            Log.i(TAG, "Loaded FfmpegAudioRenderer.");
+        } catch (ClassNotFoundException e) {
+            // Expected if the app was built without the extension.
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Builds text renderers for use by the player.
+     *
+     * @param context The {@link Context} associated with the player.
+     * @param mainHandler A handler associated with the main thread's looper.
+     * @param extensionRendererMode The extension renderer mode.
+     * @param output An output for the renderers.
+     * @param out An array to which the built renderers should be appended.
+     */
+    protected void buildTextRenderers(Context context, Handler mainHandler,
+                                      @ExtensionRendererMode int extensionRendererMode, TextRenderer.Output output,
+                                      ArrayList<Renderer> out) {
+        out.add(new TextRenderer(output, mainHandler.getLooper()));
+    }
+
+    /**
+     * Builds metadata renderers for use by the player.
+     *
+     * @param context The {@link Context} associated with the player.
+     * @param mainHandler A handler associated with the main thread's looper.
+     * @param extensionRendererMode The extension renderer mode.
+     * @param output An output for the renderers.
+     * @param out An array to which the built renderers should be appended.
+     */
+    protected void buildMetadataRenderers(Context context, Handler mainHandler,
+                                          @ExtensionRendererMode int extensionRendererMode, MetadataRenderer.Output output,
+                                          ArrayList<Renderer> out) {
+        out.add(new MetadataRenderer(output, mainHandler.getLooper()));
+    }
+
+    /**
+     * Builds any miscellaneous renderers used by the player.
+     *
+     * @param context The {@link Context} associated with the player.
+     * @param mainHandler A handler associated with the main thread's looper.
+     * @param extensionRendererMode The extension renderer mode.
+     * @param out An array to which the built renderers should be appended.
+     */
+    protected void buildMiscellaneousRenderers(Context context, Handler mainHandler,
+                                               @ExtensionRendererMode int extensionRendererMode, ArrayList<Renderer> out) {
+        // Do nothing.
+    }
+
+    /**
+     * Builds an array of {@link AudioProcessor}s that will process PCM audio before output.
+     */
+    protected AudioProcessor[] buildAudioProcessors() {
+        return new AudioProcessor[0];
+    }
+
+    // Internal methods.
+
+    private void removeSurfaceCallbacks() {
+        if (textureView != null) {
+            if (textureView.getSurfaceTextureListener() != componentListener) {
+                Log.w(TAG, "SurfaceTextureListener already unset or replaced.");
+            } else {
+                textureView.setSurfaceTextureListener(null);
+            }
+            textureView = null;
+        }
+        if (surfaceHolder != null) {
+            surfaceHolder.removeCallback(componentListener);
+            surfaceHolder = null;
+        }
+    }
+
+    private void setVideoSurfaceInternal(Surface surface, boolean ownsSurface) {
+        // Note: We don't turn this method into a no-op if the surface is being replaced with itself
+        // so as to ensure onRenderedFirstFrame callbacks are still called in this case.
+        ExoPlayerMessage[] messages = new ExoPlayerMessage[videoRendererCount];
+        int count = 0;
+        for (Renderer renderer : renderers) {
+            if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
+                messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_SURFACE, surface);
+            }
+        }
+        if (this.surface != null && this.surface != surface) {
+            // If we created this surface, we are responsible for releasing it.
+            if (this.ownsSurface) {
+                this.surface.release();
+            }
+            // We're replacing a surface. Block to ensure that it's not accessed after the method returns.
+            player.blockingSendMessages(messages);
+        } else {
+            player.sendMessages(messages);
+        }
+        this.surface = surface;
+        this.ownsSurface = ownsSurface;
+    }
+
+    private final class ComponentListener implements VideoRendererEventListener,
+            AudioRendererEventListener, TextRenderer.Output, MetadataRenderer.Output,
+            SurfaceHolder.Callback, TextureView.SurfaceTextureListener {
+
+        // VideoRendererEventListener implementation
+
+        @Override
+        public void onVideoEnabled(DecoderCounters counters) {
+            videoDecoderCounters = counters;
+            if (videoDebugListener != null) {
+                videoDebugListener.onVideoEnabled(counters);
+            }
+        }
+
+        @Override
+        public void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
+                                              long initializationDurationMs) {
+            if (videoDebugListener != null) {
+                videoDebugListener.onVideoDecoderInitialized(decoderName, initializedTimestampMs,
+                        initializationDurationMs);
+            }
+        }
+
+        @Override
+        public void onVideoInputFormatChanged(Format format) {
+            videoFormat = format;
+            if (videoDebugListener != null) {
+                videoDebugListener.onVideoInputFormatChanged(format);
+            }
+        }
+
+        @Override
+        public void onDroppedFrames(int count, long elapsed) {
+            if (videoDebugListener != null) {
+                videoDebugListener.onDroppedFrames(count, elapsed);
+            }
+        }
+
+        @Override
+        public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
+                                       float pixelWidthHeightRatio) {
+            if (videoListener != null) {
+                videoListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
+                        pixelWidthHeightRatio);
+            }
+            if (videoDebugListener != null) {
+                videoDebugListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
+                        pixelWidthHeightRatio);
+            }
+        }
+
+        @Override
+        public void onRenderedFirstFrame(Surface surface) {
+            if (videoListener != null && TwelvePlayer.this.surface == surface) {
+                videoListener.onRenderedFirstFrame();
+            }
+            if (videoDebugListener != null) {
+                videoDebugListener.onRenderedFirstFrame(surface);
+            }
+        }
+
+        @Override
+        public void onVideoDisabled(DecoderCounters counters) {
+            if (videoDebugListener != null) {
+                videoDebugListener.onVideoDisabled(counters);
+            }
+            videoFormat = null;
+            videoDecoderCounters = null;
+        }
+
+        // AudioRendererEventListener implementation
+
+        @Override
+        public void onAudioEnabled(DecoderCounters counters) {
+            audioDecoderCounters = counters;
+            if (audioDebugListener != null) {
+                audioDebugListener.onAudioEnabled(counters);
+            }
+        }
+
+        @Override
+        public void onAudioSessionId(int sessionId) {
+            audioSessionId = sessionId;
+            if (audioDebugListener != null) {
+                audioDebugListener.onAudioSessionId(sessionId);
+            }
+        }
+
+        @Override
+        public void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
+                                              long initializationDurationMs) {
+            if (audioDebugListener != null) {
+                audioDebugListener.onAudioDecoderInitialized(decoderName, initializedTimestampMs,
+                        initializationDurationMs);
+            }
+        }
+
+        @Override
+        public void onAudioInputFormatChanged(Format format) {
+            audioFormat = format;
+            if (audioDebugListener != null) {
+                audioDebugListener.onAudioInputFormatChanged(format);
+            }
+        }
+
+        @Override
+        public void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,
+                                         long elapsedSinceLastFeedMs) {
+            if (audioDebugListener != null) {
+                audioDebugListener.onAudioTrackUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
+            }
+        }
+
+        @Override
+        public void onAudioDisabled(DecoderCounters counters) {
+            if (audioDebugListener != null) {
+                audioDebugListener.onAudioDisabled(counters);
+            }
+            audioFormat = null;
+            audioDecoderCounters = null;
+            audioSessionId = C.AUDIO_SESSION_ID_UNSET;
+        }
+
+        // TextRenderer.Output implementation
+
+        @Override
+        public void onCues(List<Cue> cues) {
+            if (textOutput != null) {
+                textOutput.onCues(cues);
+            }
+        }
+
+        // MetadataRenderer.Output implementation
+
+        @Override
+        public void onMetadata(Metadata metadata) {
+            if (metadataOutput != null) {
+                metadataOutput.onMetadata(metadata);
+            }
+        }
+
+        // SurfaceHolder.Callback implementation
+
+        @Override
+        public void surfaceCreated(SurfaceHolder holder) {
+            setVideoSurfaceInternal(holder.getSurface(), false);
+        }
+
+        @Override
+        public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
+            // Do nothing.
+        }
+
+        @Override
+        public void surfaceDestroyed(SurfaceHolder holder) {
+            setVideoSurfaceInternal(null, false);
+        }
+
+        // TextureView.SurfaceTextureListener implementation
+
+        @Override
+        public void onSurfaceTextureAvailable(SurfaceTexture surfaceTexture, int width, int height) {
+            setVideoSurfaceInternal(new Surface(surfaceTexture), true);
+        }
+
+        @Override
+        public void onSurfaceTextureSizeChanged(SurfaceTexture surfaceTexture, int width, int height) {
+            // Do nothing.
+        }
+
+        @Override
+        public boolean onSurfaceTextureDestroyed(SurfaceTexture surfaceTexture) {
+            setVideoSurfaceInternal(null, true);
+            return true;
+        }
+
+        @Override
+        public void onSurfaceTextureUpdated(SurfaceTexture surfaceTexture) {
+            // Do nothing.
+        }
+
+    }
+
+}
diff --git a/twelve/src/main/res/anim/fade_out.xml b/twelve/src/main/res/anim/fade_out.xml
new file mode 100755
index 0000000000..0365e0b446
--- /dev/null
+++ b/twelve/src/main/res/anim/fade_out.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+/* //device/apps/common/res/anim/fade_out.xml
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shareInterpolator="false"
+    android:zAdjustment="top">
+    <alpha
+        android:duration="300"
+        android:fillAfter="true"
+        android:fillBefore="true"
+        android:fillEnabled="true"
+        android:fromAlpha="1.0"
+        android:interpolator="@android:interpolator/decelerate_cubic"
+        android:toAlpha="0.0" />
+    <scale
+        android:duration="300"
+        android:fillAfter="true"
+        android:fillBefore="true"
+        android:fillEnabled="true"
+        android:fromXScale="1.0"
+        android:fromYScale="1.0"
+        android:interpolator="@android:interpolator/decelerate_cubic"
+        android:pivotX="50%p"
+        android:pivotY="50%p"
+        android:toXScale=".8"
+        android:toYScale=".8" />
+</set>
\ No newline at end of file
diff --git a/twelve/src/main/res/color/tab_text_color.xml b/twelve/src/main/res/color/tab_text_color.xml
new file mode 100755
index 0000000000..35653622d7
--- /dev/null
+++ b/twelve/src/main/res/color/tab_text_color.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ Copyright (C) 2014 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License
+  -->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:color="@color/header_action_bar_text_color_active" android:state_selected="true" />
+    <item android:color="@color/header_action_bar_text_color" />
+</selector>
diff --git a/twelve/src/main/res/drawable-hdpi/default_artwork.png b/twelve/src/main/res/drawable-hdpi/default_artwork.png
new file mode 100755
index 0000000000..ce6cd651e2
Binary files /dev/null and b/twelve/src/main/res/drawable-hdpi/default_artwork.png differ
diff --git a/twelve/src/main/res/drawable-hdpi/default_artwork_blur.png b/twelve/src/main/res/drawable-hdpi/default_artwork_blur.png
new file mode 100755
index 0000000000..172705fe2a
Binary files /dev/null and b/twelve/src/main/res/drawable-hdpi/default_artwork_blur.png differ
diff --git a/twelve/src/main/res/drawable-hdpi/ic_album.png b/twelve/src/main/res/drawable-hdpi/ic_album.png
new file mode 100755
index 0000000000..c059733086
Binary files /dev/null and b/twelve/src/main/res/drawable-hdpi/ic_album.png differ
diff --git a/twelve/src/main/res/drawable-hdpi/ic_album_lg.png b/twelve/src/main/res/drawable-hdpi/ic_album_lg.png
new file mode 100755
index 0000000000..3d34a6f210
Binary files /dev/null and b/twelve/src/main/res/drawable-hdpi/ic_album_lg.png differ
diff --git a/twelve/src/main/res/drawable-hdpi/ic_artist.png b/twelve/src/main/res/drawable-hdpi/ic_artist.png
new file mode 100755
index 0000000000..4a84573d46
Binary files /dev/null and b/twelve/src/main/res/drawable-hdpi/ic_artist.png differ
diff --git a/twelve/src/main/res/drawable-hdpi/ic_artist_lg.png b/twelve/src/main/res/drawable-hdpi/ic_artist_lg.png
new file mode 100755
index 0000000000..39311060ce
Binary files /dev/null and b/twelve/src/main/res/drawable-hdpi/ic_artist_lg.png differ
diff --git a/twelve/src/main/res/drawable-hdpi/ic_notification.png b/twelve/src/main/res/drawable-hdpi/ic_notification.png
new file mode 100755
index 0000000000..5610f64938
Binary files /dev/null and b/twelve/src/main/res/drawable-hdpi/ic_notification.png differ
diff --git a/twelve/src/main/res/drawable-hdpi/ic_playlist.png b/twelve/src/main/res/drawable-hdpi/ic_playlist.png
new file mode 100755
index 0000000000..d5798de2d4
Binary files /dev/null and b/twelve/src/main/res/drawable-hdpi/ic_playlist.png differ
diff --git a/twelve/src/main/res/drawable-hdpi/ic_playlist_lg.png b/twelve/src/main/res/drawable-hdpi/ic_playlist_lg.png
new file mode 100755
index 0000000000..3a4be49795
Binary files /dev/null and b/twelve/src/main/res/drawable-hdpi/ic_playlist_lg.png differ
diff --git a/twelve/src/main/res/drawable-mdpi/default_artwork.png b/twelve/src/main/res/drawable-mdpi/default_artwork.png
new file mode 100755
index 0000000000..8958ba5ddc
Binary files /dev/null and b/twelve/src/main/res/drawable-mdpi/default_artwork.png differ
diff --git a/twelve/src/main/res/drawable-mdpi/default_artwork_blur.png b/twelve/src/main/res/drawable-mdpi/default_artwork_blur.png
new file mode 100755
index 0000000000..a447877347
Binary files /dev/null and b/twelve/src/main/res/drawable-mdpi/default_artwork_blur.png differ
diff --git a/twelve/src/main/res/drawable-mdpi/ic_album.png b/twelve/src/main/res/drawable-mdpi/ic_album.png
new file mode 100755
index 0000000000..7ebc0e0fb5
Binary files /dev/null and b/twelve/src/main/res/drawable-mdpi/ic_album.png differ
diff --git a/twelve/src/main/res/drawable-mdpi/ic_album_lg.png b/twelve/src/main/res/drawable-mdpi/ic_album_lg.png
new file mode 100755
index 0000000000..a5c40a3c94
Binary files /dev/null and b/twelve/src/main/res/drawable-mdpi/ic_album_lg.png differ
diff --git a/twelve/src/main/res/drawable-mdpi/ic_artist.png b/twelve/src/main/res/drawable-mdpi/ic_artist.png
new file mode 100755
index 0000000000..d1bf6cbe5c
Binary files /dev/null and b/twelve/src/main/res/drawable-mdpi/ic_artist.png differ
diff --git a/twelve/src/main/res/drawable-mdpi/ic_artist_lg.png b/twelve/src/main/res/drawable-mdpi/ic_artist_lg.png
new file mode 100755
index 0000000000..3b8f6cf7d1
Binary files /dev/null and b/twelve/src/main/res/drawable-mdpi/ic_artist_lg.png differ
diff --git a/twelve/src/main/res/drawable-mdpi/ic_notification.png b/twelve/src/main/res/drawable-mdpi/ic_notification.png
new file mode 100755
index 0000000000..9511ea6dc6
Binary files /dev/null and b/twelve/src/main/res/drawable-mdpi/ic_notification.png differ
diff --git a/twelve/src/main/res/drawable-mdpi/ic_playlist.png b/twelve/src/main/res/drawable-mdpi/ic_playlist.png
new file mode 100755
index 0000000000..16c2c83b25
Binary files /dev/null and b/twelve/src/main/res/drawable-mdpi/ic_playlist.png differ
diff --git a/twelve/src/main/res/drawable-mdpi/ic_playlist_lg.png b/twelve/src/main/res/drawable-mdpi/ic_playlist_lg.png
new file mode 100755
index 0000000000..aea793b0a9
Binary files /dev/null and b/twelve/src/main/res/drawable-mdpi/ic_playlist_lg.png differ
diff --git a/twelve/src/main/res/drawable-v21/selectable_background.xml b/twelve/src/main/res/drawable-v21/selectable_background.xml
new file mode 100755
index 0000000000..844355052d
--- /dev/null
+++ b/twelve/src/main/res/drawable-v21/selectable_background.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="@color/white" />
diff --git a/twelve/src/main/res/drawable-v21/selectable_background_light.xml b/twelve/src/main/res/drawable-v21/selectable_background_light.xml
new file mode 100755
index 0000000000..66d8339331
--- /dev/null
+++ b/twelve/src/main/res/drawable-v21/selectable_background_light.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2014 The CyanogenMod Project
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="@color/primary" />
diff --git a/twelve/src/main/res/drawable-v21/view_pager_tab_background.xml b/twelve/src/main/res/drawable-v21/view_pager_tab_background.xml
new file mode 100755
index 0000000000..045395d8cc
--- /dev/null
+++ b/twelve/src/main/res/drawable-v21/view_pager_tab_background.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+    ~ Copyright (C) 2014 The Android Open Source Project
+    ~
+    ~ Licensed under the Apache License, Version 2.0 (the "License");
+    ~ you may not use this file except in compliance with the License.
+    ~ You may obtain a copy of the License at
+    ~
+    ~      http://www.apache.org/licenses/LICENSE-2.0
+    ~
+    ~ Unless required by applicable law or agreed to in writing, software
+    ~ distributed under the License is distributed on an "AS IS" BASIS,
+    ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    ~ See the License for the specific language governing permissions and
+    ~ limitations under the License
+-->
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="@color/tab_ripple_color">
+    <item android:id="@android:id/mask">
+        <color android:color="@android:color/white" />
+    </item>
+</ripple>
diff --git a/twelve/src/main/res/drawable-xhdpi/default_artwork.png b/twelve/src/main/res/drawable-xhdpi/default_artwork.png
new file mode 100755
index 0000000000..d68d94f17d
Binary files /dev/null and b/twelve/src/main/res/drawable-xhdpi/default_artwork.png differ
diff --git a/twelve/src/main/res/drawable-xhdpi/default_artwork_blur.png b/twelve/src/main/res/drawable-xhdpi/default_artwork_blur.png
new file mode 100755
index 0000000000..b03c39ca25
Binary files /dev/null and b/twelve/src/main/res/drawable-xhdpi/default_artwork_blur.png differ
diff --git a/twelve/src/main/res/drawable-xhdpi/ic_album.png b/twelve/src/main/res/drawable-xhdpi/ic_album.png
new file mode 100755
index 0000000000..d7025cf3d6
Binary files /dev/null and b/twelve/src/main/res/drawable-xhdpi/ic_album.png differ
diff --git a/twelve/src/main/res/drawable-xhdpi/ic_album_lg.png b/twelve/src/main/res/drawable-xhdpi/ic_album_lg.png
new file mode 100755
index 0000000000..1b50d84fea
Binary files /dev/null and b/twelve/src/main/res/drawable-xhdpi/ic_album_lg.png differ
diff --git a/twelve/src/main/res/drawable-xhdpi/ic_artist.png b/twelve/src/main/res/drawable-xhdpi/ic_artist.png
new file mode 100755
index 0000000000..7232871b0d
Binary files /dev/null and b/twelve/src/main/res/drawable-xhdpi/ic_artist.png differ
diff --git a/twelve/src/main/res/drawable-xhdpi/ic_artist_lg.png b/twelve/src/main/res/drawable-xhdpi/ic_artist_lg.png
new file mode 100755
index 0000000000..4429a35190
Binary files /dev/null and b/twelve/src/main/res/drawable-xhdpi/ic_artist_lg.png differ
diff --git a/twelve/src/main/res/drawable-xhdpi/ic_notification.png b/twelve/src/main/res/drawable-xhdpi/ic_notification.png
new file mode 100755
index 0000000000..564c5d0de7
Binary files /dev/null and b/twelve/src/main/res/drawable-xhdpi/ic_notification.png differ
diff --git a/twelve/src/main/res/drawable-xhdpi/ic_playlist.png b/twelve/src/main/res/drawable-xhdpi/ic_playlist.png
new file mode 100755
index 0000000000..e72ce31206
Binary files /dev/null and b/twelve/src/main/res/drawable-xhdpi/ic_playlist.png differ
diff --git a/twelve/src/main/res/drawable-xhdpi/ic_playlist_lg.png b/twelve/src/main/res/drawable-xhdpi/ic_playlist_lg.png
new file mode 100755
index 0000000000..4da86c1ada
Binary files /dev/null and b/twelve/src/main/res/drawable-xhdpi/ic_playlist_lg.png differ
diff --git a/twelve/src/main/res/drawable-xxhdpi/default_artwork.png b/twelve/src/main/res/drawable-xxhdpi/default_artwork.png
new file mode 100755
index 0000000000..72b03812a6
Binary files /dev/null and b/twelve/src/main/res/drawable-xxhdpi/default_artwork.png differ
diff --git a/twelve/src/main/res/drawable-xxhdpi/default_artwork_blur.png b/twelve/src/main/res/drawable-xxhdpi/default_artwork_blur.png
new file mode 100755
index 0000000000..e269398891
Binary files /dev/null and b/twelve/src/main/res/drawable-xxhdpi/default_artwork_blur.png differ
diff --git a/twelve/src/main/res/drawable-xxhdpi/ic_album.png b/twelve/src/main/res/drawable-xxhdpi/ic_album.png
new file mode 100755
index 0000000000..84c5678abe
Binary files /dev/null and b/twelve/src/main/res/drawable-xxhdpi/ic_album.png differ
diff --git a/twelve/src/main/res/drawable-xxhdpi/ic_album_lg.png b/twelve/src/main/res/drawable-xxhdpi/ic_album_lg.png
new file mode 100755
index 0000000000..1b09e9c308
Binary files /dev/null and b/twelve/src/main/res/drawable-xxhdpi/ic_album_lg.png differ
diff --git a/twelve/src/main/res/drawable-xxhdpi/ic_artist.png b/twelve/src/main/res/drawable-xxhdpi/ic_artist.png
new file mode 100755
index 0000000000..fa94babe98
Binary files /dev/null and b/twelve/src/main/res/drawable-xxhdpi/ic_artist.png differ
diff --git a/twelve/src/main/res/drawable-xxhdpi/ic_artist_lg.png b/twelve/src/main/res/drawable-xxhdpi/ic_artist_lg.png
new file mode 100755
index 0000000000..f232ded16b
Binary files /dev/null and b/twelve/src/main/res/drawable-xxhdpi/ic_artist_lg.png differ
diff --git a/twelve/src/main/res/drawable-xxhdpi/ic_notification.png b/twelve/src/main/res/drawable-xxhdpi/ic_notification.png
new file mode 100755
index 0000000000..1203bc671b
Binary files /dev/null and b/twelve/src/main/res/drawable-xxhdpi/ic_notification.png differ
diff --git a/twelve/src/main/res/drawable-xxhdpi/ic_playlist.png b/twelve/src/main/res/drawable-xxhdpi/ic_playlist.png
new file mode 100755
index 0000000000..ce94de0333
Binary files /dev/null and b/twelve/src/main/res/drawable-xxhdpi/ic_playlist.png differ
diff --git a/twelve/src/main/res/drawable-xxhdpi/ic_playlist_lg.png b/twelve/src/main/res/drawable-xxhdpi/ic_playlist_lg.png
new file mode 100755
index 0000000000..8c83309252
Binary files /dev/null and b/twelve/src/main/res/drawable-xxhdpi/ic_playlist_lg.png differ
diff --git a/twelve/src/main/res/drawable/above_shadow.xml b/twelve/src/main/res/drawable/above_shadow.xml
new file mode 100755
index 0000000000..be58bea83b
--- /dev/null
+++ b/twelve/src/main/res/drawable/above_shadow.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+    <gradient
+        android:angle="90"
+        android:endColor="@android:color/transparent"
+        android:startColor="#20000000"></gradient>
+</shape>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/below_shadow.xml b/twelve/src/main/res/drawable/below_shadow.xml
new file mode 100755
index 0000000000..f07df01656
--- /dev/null
+++ b/twelve/src/main/res/drawable/below_shadow.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+    <gradient
+        android:angle="270"
+        android:endColor="@android:color/transparent"
+        android:startColor="#20000000"></gradient>
+</shape>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/bottom_shadow.xml b/twelve/src/main/res/drawable/bottom_shadow.xml
new file mode 100755
index 0000000000..de82e91cba
--- /dev/null
+++ b/twelve/src/main/res/drawable/bottom_shadow.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+
+    <gradient
+        android:angle="90.0"
+        android:endColor="@color/transparent"
+        android:startColor="@color/black" />
+
+</shape>
diff --git a/twelve/src/main/res/drawable/btn_add_to_playlist.xml b/twelve/src/main/res/drawable/btn_add_to_playlist.xml
new file mode 100755
index 0000000000..22f27b162d
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_add_to_playlist.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M14 10H2v2h12v-2zm0-4H2v2h12V6zm4 8v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM2
+16h8v-2H2v2z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_header_collapse.xml b/twelve/src/main/res/drawable/btn_header_collapse.xml
new file mode 100755
index 0000000000..a499140c15
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_header_collapse.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="8dp"
+    android:height="8dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/black"
+        android:pathData="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41
+5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z" />
+    <path android:pathData="M0 0h24v24h-24z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_notification_collapse.xml b/twelve/src/main/res/drawable/btn_notification_collapse.xml
new file mode 100755
index 0000000000..89c0f19df6
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_notification_collapse.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M19 13H5v-2h14v2z" />
+    <path android:pathData="M0 0h24v24H0z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_playback_browse.xml b/twelve/src/main/res/drawable/btn_playback_browse.xml
new file mode 100755
index 0000000000..9abaeec9a0
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_playback_browse.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="@color/black"
+        android:pathData="M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1 .9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2
+5h-3v5.5c0 1.38-1.12 2.5-2.5 2.5S10 13.88 10 12.5s1.12-2.5 2.5-2.5c.57 0 1.08
+.19 1.5 .51 V5h4v2zM4 6H2v14c0 1.1 .9 2 2 2h14v-2H4V6z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_playback_icon.xml b/twelve/src/main/res/drawable/btn_playback_icon.xml
new file mode 100755
index 0000000000..225575a6f1
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_playback_icon.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24h-24z" />
+    <path
+        android:fillColor="@color/black"
+        android:pathData="M12 3v9.28c-.47-.17-.97-.28-1.5-.28-2.49 0-4.5 2.01-4.5 4.5s2.01 4.5 4.5
+4.5c2.31 0 4.2-1.75 4.45-4h.05v-11h4v-3h-7z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_playback_next.xml b/twelve/src/main/res/drawable/btn_playback_next.xml
new file mode 100755
index 0000000000..e5182bde84
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_playback_next.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_playback_pause.xml b/twelve/src/main/res/drawable/btn_playback_pause.xml
new file mode 100755
index 0000000000..4589c34470
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_playback_pause.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_playback_play.xml b/twelve/src/main/res/drawable/btn_playback_play.xml
new file mode 100755
index 0000000000..154fb1755d
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_playback_play.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M8 5v14l11-7z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_playback_previous.xml b/twelve/src/main/res/drawable/btn_playback_previous.xml
new file mode 100755
index 0000000000..20d19e1de0
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_playback_previous.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_playback_repeat_all.xml b/twelve/src/main/res/drawable/btn_playback_repeat_all.xml
new file mode 100755
index 0000000000..4036e26ed7
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_playback_repeat_all.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_playback_repeat_one.xml b/twelve/src/main/res/drawable/btn_playback_repeat_one.xml
new file mode 100755
index 0000000000..401540dc87
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_playback_repeat_one.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2
+1v1h1.5v4H13z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_playback_shuffle_all.xml b/twelve/src/main/res/drawable/btn_playback_shuffle_all.xml
new file mode 100755
index 0000000000..885601080e
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_playback_shuffle_all.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20
+17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04
+2.04-3.13-3.13z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/btn_queue_icon.xml b/twelve/src/main/res/drawable/btn_queue_icon.xml
new file mode 100755
index 0000000000..aebe171644
--- /dev/null
+++ b/twelve/src/main/res/drawable/btn_queue_icon.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/black"
+        android:pathData="M15 6H3v2h12V6zm0 4H3v2h12v-2zM3 16h8v-2H3v2zM17
+6v8.18c-.31-.11-.65-.18-1-.18-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3V8h3V6h-5z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/circular_drawable.xml b/twelve/src/main/res/drawable/circular_drawable.xml
new file mode 100755
index 0000000000..2f2360f488
--- /dev/null
+++ b/twelve/src/main/res/drawable/circular_drawable.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:innerRadiusRatio="@dimen/circular_progress_bar_inner_radius_ratio"
+    android:shape="ring"
+    android:thicknessRatio="@dimen/circular_progress_bar_thickness_ratio"
+    android:useLevel="true">
+    <solid android:color="@color/circular_progress_bar" />
+</shape>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/circular_drawable_background.xml b/twelve/src/main/res/drawable/circular_drawable_background.xml
new file mode 100755
index 0000000000..fc55740b0b
--- /dev/null
+++ b/twelve/src/main/res/drawable/circular_drawable_background.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:innerRadiusRatio="@dimen/circular_progress_bar_inner_radius_ratio"
+    android:shape="ring"
+    android:thicknessRatio="@dimen/circular_progress_bar_thickness_ratio"
+    android:useLevel="true">
+    <solid android:color="@color/circular_progress_bar_background" />
+</shape>
diff --git a/twelve/src/main/res/drawable/dnd_list_divider.xml b/twelve/src/main/res/drawable/dnd_list_divider.xml
new file mode 100755
index 0000000000..537c32db5c
--- /dev/null
+++ b/twelve/src/main/res/drawable/dnd_list_divider.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<inset xmlns:android="http://schemas.android.com/apk/res/android"
+    android:insetLeft="@dimen/drag_and_drop_width"
+    android:insetRight="@dimen/list_preferred_item_padding">
+
+    <shape>
+        <solid android:color="@color/list_item_divider_color" />
+        <corners android:radius="1.0dip" />
+    </shape>
+
+</inset>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/dnd_list_divider_light.xml b/twelve/src/main/res/drawable/dnd_list_divider_light.xml
new file mode 100755
index 0000000000..33ac6b3d6a
--- /dev/null
+++ b/twelve/src/main/res/drawable/dnd_list_divider_light.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<inset xmlns:android="http://schemas.android.com/apk/res/android"
+    android:insetLeft="@dimen/drag_and_drop_width"
+    android:insetRight="@dimen/list_preferred_item_padding">
+
+    <shape>
+        <solid android:color="@color/list_item_divider_color_light" />
+        <corners android:radius="1.0dip" />
+    </shape>
+
+</inset>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/drag_indicator.xml b/twelve/src/main/res/drawable/drag_indicator.xml
new file mode 100755
index 0000000000..8a05ee7370
--- /dev/null
+++ b/twelve/src/main/res/drawable/drag_indicator.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M20,9H4v2h16V9zM4,15h16v-2H4v2z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/fab_accent.xml b/twelve/src/main/res/drawable/fab_accent.xml
new file mode 100755
index 0000000000..4724dbb63c
--- /dev/null
+++ b/twelve/src/main/res/drawable/fab_accent.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2015 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="oval">
+    <solid android:color="@color/accent" />
+</shape>
diff --git a/twelve/src/main/res/drawable/floating_action_button.xml b/twelve/src/main/res/drawable/floating_action_button.xml
new file mode 100755
index 0000000000..c9b5639a49
--- /dev/null
+++ b/twelve/src/main/res/drawable/floating_action_button.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2015 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="@color/grey">
+    <item android:id="@android:id/mask">
+        <shape android:shape="oval">
+            <solid
+                android:background="?android:attr/selectableItemBackground"
+                android:color="@color/accent" />
+        </shape>
+    </item>
+</ripple>
diff --git a/twelve/src/main/res/drawable/gray_circle.xml b/twelve/src/main/res/drawable/gray_circle.xml
new file mode 100755
index 0000000000..b6f1edc698
--- /dev/null
+++ b/twelve/src/main/res/drawable/gray_circle.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="oval">
+    <solid android:color="@color/grey" />
+</shape>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/gripper.xml b/twelve/src/main/res/drawable/gripper.xml
new file mode 100755
index 0000000000..2ff667fae5
--- /dev/null
+++ b/twelve/src/main/res/drawable/gripper.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+    <path
+        android:fillColor="@color/black"
+        android:pathData="M20,9H4v2h16V9zM4,15h16v-2H4v2z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/gripper_light.xml b/twelve/src/main/res/drawable/gripper_light.xml
new file mode 100755
index 0000000000..8a05ee7370
--- /dev/null
+++ b/twelve/src/main/res/drawable/gripper_light.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24.0"
+    android:viewportWidth="24.0">
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M20,9H4v2h16V9zM4,15h16v-2H4v2z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/history_icon.xml b/twelve/src/main/res/drawable/history_icon.xml
new file mode 100755
index 0000000000..76c2036bbd
--- /dev/null
+++ b/twelve/src/main/res/drawable/history_icon.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillAlpha=".9"
+        android:fillColor="@color/black"
+        android:pathData="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89 .07 .14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7
+7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13
+21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54 .72 -1.21-3.5-2.08V8H12z"
+        android:strokeAlpha=".9" />
+</vector>
diff --git a/twelve/src/main/res/drawable/ic_action_search.xml b/twelve/src/main/res/drawable/ic_action_search.xml
new file mode 100755
index 0000000000..faaed1c4d7
--- /dev/null
+++ b/twelve/src/main/res/drawable/ic_action_search.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91
+3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27 .28 v.79l5 4.99L20.49
+19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5
+14z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/inset_list_divider.xml b/twelve/src/main/res/drawable/inset_list_divider.xml
new file mode 100755
index 0000000000..bb665d3ff0
--- /dev/null
+++ b/twelve/src/main/res/drawable/inset_list_divider.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<inset xmlns:android="http://schemas.android.com/apk/res/android"
+    android:insetLeft="@dimen/list_preferred_item_padding"
+    android:insetRight="@dimen/list_preferred_item_padding">
+
+    <shape>
+        <solid android:color="@color/list_item_divider_color" />
+        <corners android:radius="1.0dip" />
+    </shape>
+
+</inset>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/inset_list_divider_no_padding.xml b/twelve/src/main/res/drawable/inset_list_divider_no_padding.xml
new file mode 100755
index 0000000000..7c3f793aa0
--- /dev/null
+++ b/twelve/src/main/res/drawable/inset_list_divider_no_padding.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<inset xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <shape>
+        <solid android:color="@color/list_item_divider_color" />
+        <corners android:radius="1.0dip" />
+    </shape>
+
+</inset>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/menu_button.xml b/twelve/src/main/res/drawable/menu_button.xml
new file mode 100755
index 0000000000..f98f44e52e
--- /dev/null
+++ b/twelve/src/main/res/drawable/menu_button.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24h-24z" />
+    <path
+        android:fillColor="@color/black"
+        android:pathData="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2
+2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/menu_button_light.xml b/twelve/src/main/res/drawable/menu_button_light.xml
new file mode 100755
index 0000000000..5adf469af1
--- /dev/null
+++ b/twelve/src/main/res/drawable/menu_button_light.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24h-24z" />
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2
+2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/no_results.xml b/twelve/src/main/res/drawable/no_results.xml
new file mode 100755
index 0000000000..f5f2498924
--- /dev/null
+++ b/twelve/src/main/res/drawable/no_results.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="96dp"
+    android:height="96dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="@color/black"
+        android:pathData="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 14.5c-2.49
+0-4.5-2.01-4.5-4.5S9.51 7.5 12 7.5s4.5 2.01 4.5 4.5-2.01 4.5-4.5 4.5zm0-5.5c-.55
+0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/now_playing_icon.xml b/twelve/src/main/res/drawable/now_playing_icon.xml
new file mode 100755
index 0000000000..c1fdbfef9a
--- /dev/null
+++ b/twelve/src/main/res/drawable/now_playing_icon.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillColor="@color/accent"
+        android:pathData="M14.5,21c-1.9,0-3.5-1.6-3.5-3.5v-11C11,5.7,10.3,5,9.5,5S8,5.7,8,6.5V10c0,1.7-1.3,3-3,3H3v-2
+h2c0.6,0,1-0.4,1-1V6.5C6,4.6,7.6,3,9.5,3S13,4.6,13,6.5v11c0,0.8,0.7,1.5,1.5,1.5s1.5-0.7,1.5-1.5V14c0-1.7,1.3-3,3-3h2v2h-2
+c-0.6,0-1,0.4-1,1v3.5C18,19.4,16.4,21,14.5,21Z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/now_playing_progress.xml b/twelve/src/main/res/drawable/now_playing_progress.xml
new file mode 100755
index 0000000000..f09b2678f5
--- /dev/null
+++ b/twelve/src/main/res/drawable/now_playing_progress.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:innerRadiusRatio="2.601"
+    android:shape="ring"
+    android:thicknessRatio="8.666"
+    android:useLevel="true">
+    <solid android:color="@color/circular_progress_bar" />
+</shape>
diff --git a/twelve/src/main/res/drawable/now_playing_progress_background.xml b/twelve/src/main/res/drawable/now_playing_progress_background.xml
new file mode 100755
index 0000000000..878bc35fcc
--- /dev/null
+++ b/twelve/src/main/res/drawable/now_playing_progress_background.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:innerRadiusRatio="2.601"
+    android:shape="ring"
+    android:thicknessRatio="8.666"
+    android:useLevel="true">
+    <solid android:color="@color/circular_progress_bar_background" />
+</shape>
diff --git a/twelve/src/main/res/drawable/playlist_icon.xml b/twelve/src/main/res/drawable/playlist_icon.xml
new file mode 100755
index 0000000000..ae7a61f370
--- /dev/null
+++ b/twelve/src/main/res/drawable/playlist_icon.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="@color/primary"
+        android:pathData="M15 6H3v2h12V6zm0 4H3v2h12v-2zM3 16h8v-2H3v2zM17
+6v8.18c-.31-.11-.65-.18-1-.18-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3V8h3V6h-5z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/recent_icon.xml b/twelve/src/main/res/drawable/recent_icon.xml
new file mode 100755
index 0000000000..d26feb0cdb
--- /dev/null
+++ b/twelve/src/main/res/drawable/recent_icon.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path
+        android:fillAlpha=".9"
+        android:fillColor="@color/primary"
+        android:pathData="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89 .07 .14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7
+7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13
+21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54 .72 -1.21-3.5-2.08V8H12z"
+        android:strokeAlpha=".9" />
+</vector>
diff --git a/twelve/src/main/res/drawable/recently_added.xml b/twelve/src/main/res/drawable/recently_added.xml
new file mode 100755
index 0000000000..08cdd198ca
--- /dev/null
+++ b/twelve/src/main/res/drawable/recently_added.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="@color/primary"
+        android:pathData="M23 12l-2.44-2.78 .34 -3.68-3.61-.82-1.89-3.18L12 3 8.6 1.54 6.71 4.72l-3.61 .81
+.34 3.68L1 12l2.44 2.78-.34 3.69 3.61 .82 1.89 3.18L12 21l3.4 1.46 1.89-3.18
+3.61-.82-.34-3.68L23 12zm-10 5h-2v-2h2v2zm0-4h-2V7h2v6z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/right_shadow.xml b/twelve/src/main/res/drawable/right_shadow.xml
new file mode 100755
index 0000000000..c01ce9637c
--- /dev/null
+++ b/twelve/src/main/res/drawable/right_shadow.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+ 
+       http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+
+    <gradient
+        android:angle="180"
+        android:endColor="@color/transparent"
+        android:startColor="@color/black" />
+
+</shape>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/selectable_background.xml b/twelve/src/main/res/drawable/selectable_background.xml
new file mode 100755
index 0000000000..0a25e956a9
--- /dev/null
+++ b/twelve/src/main/res/drawable/selectable_background.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2014 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@color/my_color_highlight_press" android:state_pressed="true" />
+    <item android:drawable="@android:color/transparent" />
+</selector>
diff --git a/twelve/src/main/res/drawable/selectable_background_light.xml b/twelve/src/main/res/drawable/selectable_background_light.xml
new file mode 100755
index 0000000000..314fc59c57
--- /dev/null
+++ b/twelve/src/main/res/drawable/selectable_background_light.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2014 The CyanogenMod Project
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@color/my_color_highlight_press" android:state_pressed="true" />
+    <item android:drawable="@android:color/transparent" />
+</selector>
\ No newline at end of file
diff --git a/twelve/src/main/res/drawable/stopwatch_icon_small_grey.xml b/twelve/src/main/res/drawable/stopwatch_icon_small_grey.xml
new file mode 100755
index 0000000000..85e7702204
--- /dev/null
+++ b/twelve/src/main/res/drawable/stopwatch_icon_small_grey.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="18dp"
+    android:height="18dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="@color/grey"
+        android:pathData="M11 17c0 .55 .45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1zm0-14v4h2V5.08c3.39 .49 6
+3.39 6 6.92 0 3.87-3.13 7-7 7s-7-3.13-7-7c0-1.68 .59 -3.22 1.58-4.42L12
+13l1.41-1.41-6.8-6.8v.02C4.42 6.45 3 9.05 3 12c0 4.97 4.02 9 9 9 4.97 0 9-4.03
+9-9s-4.03-9-9-9h-1zm7 9c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1zM6 12c0
+.55 .45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/stopwatch_icon_white.xml b/twelve/src/main/res/drawable/stopwatch_icon_white.xml
new file mode 100755
index 0000000000..e3400b0acd
--- /dev/null
+++ b/twelve/src/main/res/drawable/stopwatch_icon_white.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="@color/white"
+        android:pathData="M11 17c0 .55 .45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1zm0-14v4h2V5.08c3.39 .49 6
+3.39 6 6.92 0 3.87-3.13 7-7 7s-7-3.13-7-7c0-1.68 .59 -3.22 1.58-4.42L12
+13l1.41-1.41-6.8-6.8v.02C4.42 6.45 3 9.05 3 12c0 4.97 4.02 9 9 9 4.97 0 9-4.03
+9-9s-4.03-9-9-9h-1zm7 9c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1zM6 12c0
+.55 .45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/top_tracks_icon.xml b/twelve/src/main/res/drawable/top_tracks_icon.xml
new file mode 100755
index 0000000000..87e913a5c8
--- /dev/null
+++ b/twelve/src/main/res/drawable/top_tracks_icon.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportHeight="24"
+    android:viewportWidth="24">
+
+    <path android:pathData="M0 0h24v24h-24z" />
+    <path
+        android:fillColor="@color/black"
+        android:pathData="M12 21.35l-1.45-1.32c-5.15-4.67-8.55-7.75-8.55-11.53 0-3.08 2.42-5.5 5.5-5.5
+1.74 0 3.41 .81 4.5 2.09 1.09-1.28 2.76-2.09 4.5-2.09 3.08 0 5.5 2.42 5.5 5.5 0
+3.78-3.4 6.86-8.55 11.54l-1.45 1.31z" />
+</vector>
diff --git a/twelve/src/main/res/drawable/view_pager_tab_background.xml b/twelve/src/main/res/drawable/view_pager_tab_background.xml
new file mode 100755
index 0000000000..db9b13bcbb
--- /dev/null
+++ b/twelve/src/main/res/drawable/view_pager_tab_background.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+    ~ Copyright (C) 2014 The Android Open Source Project
+    ~
+    ~ Licensed under the Apache License, Version 2.0 (the "License");
+    ~ you may not use this file except in compliance with the License.
+    ~ You may obtain a copy of the License at
+    ~
+    ~      http://www.apache.org/licenses/LICENSE-2.0
+    ~
+    ~ Unless required by applicable law or agreed to in writing, software
+    ~ distributed under the License is distributed on an "AS IS" BASIS,
+    ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    ~ See the License for the specific language governing permissions and
+    ~ limitations under the License
+-->
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:drawable="@color/my_color_highlight_press" android:state_pressed="true" />
+    <item android:drawable="@android:color/transparent" />
+</selector>
diff --git a/twelve/src/main/res/layout-land/activity_player_fragment.xml b/twelve/src/main/res/layout-land/activity_player_fragment.xml
new file mode 100755
index 0000000000..1cdcbbd5bb
--- /dev/null
+++ b/twelve/src/main/res/layout-land/activity_player_fragment.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+    <include
+        android:id="@+id/audio_player_header"
+        layout="@layout/audio_player_header_bar" />
+
+    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="horizontal">
+
+        <include layout="@layout/main_album_flow" />
+
+        <include layout="@layout/main_playback_controls" />
+    </LinearLayout>
+</LinearLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/activity_album_detail.xml b/twelve/src/main/res/layout/activity_album_detail.xml
new file mode 100755
index 0000000000..f2a346cfd5
--- /dev/null
+++ b/twelve/src/main/res/layout/activity_album_detail.xml
@@ -0,0 +1,98 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/activity_album_detail_background_color">
+
+    <RelativeLayout
+        android:id="@+id/header"
+        android:layout_width="match_parent"
+        android:layout_height="108dp"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentTop="true"
+        android:background="@color/page_header_background"
+        android:elevation="2dp">
+
+        <ImageView
+            android:id="@+id/album_art"
+            android:layout_width="108dp"
+            android:layout_height="108dp"
+            android:layout_alignParentLeft="true"
+            android:layout_alignParentTop="true"
+            android:layout_marginRight="@dimen/standard_padding"
+            android:scaleType="centerCrop" />
+
+        <RelativeLayout
+            android:id="@+id/header_info"
+            android:layout_width="wrap_content"
+            android:layout_height="fill_parent"
+            android:layout_toRightOf="@id/album_art"
+            android:gravity="center_vertical">
+
+            <TextView
+                android:id="@+id/title"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_alignParentTop="true"
+                android:singleLine="true"
+                android:textColor="@color/album_detail_title_text_color"
+                android:textSize="@dimen/text_size_large"
+                android:textStyle="bold" />
+
+            <TextView
+                android:id="@+id/song_count_and_year"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/title"
+                android:singleLine="true"
+                android:textColor="@color/album_detail_song_count_and_year_text_color"
+                android:textSize="@dimen/text_size_micro" />
+
+            <TextView
+                android:id="@+id/genre"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/song_count_and_year"
+                android:layout_marginRight="@dimen/standard_padding"
+                android:layout_marginTop="4dp"
+                android:singleLine="true"
+                android:textColor="@color/album_detail_genre_text_color"
+                android:textSize="@dimen/text_size_micro"
+                android:visibility="gone" />
+
+            <ImageView
+                android:id="@+id/duration_icon"
+                android:layout_width="10dp"
+                android:layout_height="12dp"
+                android:layout_alignBottom="@+id/duration"
+                android:layout_alignTop="@+id/duration"
+                android:layout_below="@id/song_count_and_year"
+                android:layout_marginRight="4dp"
+                android:layout_toRightOf="@id/genre"
+                android:gravity="center"
+                android:src="@drawable/stopwatch_icon_small_grey" />
+
+            <TextView
+                android:id="@+id/duration"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/song_count_and_year"
+                android:layout_marginTop="4dp"
+                android:layout_toRightOf="@id/duration_icon"
+                android:singleLine="true"
+                android:textColor="@color/album_detail_duration_text_color"
+                android:textSize="@dimen/text_size_micro" />
+        </RelativeLayout>
+
+    </RelativeLayout>
+
+    <include layout="@layout/loading_empty_container" />
+
+    <ListView
+        android:id="@+id/songs"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_alignParentLeft="true"
+        android:layout_below="@id/header"
+        android:divider="@null"
+        android:dividerHeight="0dp" />
+</RelativeLayout>
diff --git a/twelve/src/main/res/layout/activity_artist_detail.xml b/twelve/src/main/res/layout/activity_artist_detail.xml
new file mode 100755
index 0000000000..77bb13b5f5
--- /dev/null
+++ b/twelve/src/main/res/layout/activity_artist_detail.xml
@@ -0,0 +1,16 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/activity_artist_detail_background_color">
+
+    <include layout="@layout/loading_empty_container" />
+
+    <ListView
+        android:id="@+id/songs"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentTop="true"
+        android:divider="@null"
+        android:dividerHeight="0dp" />
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/activity_audio_preview.xml b/twelve/src/main/res/layout/activity_audio_preview.xml
new file mode 100755
index 0000000000..378dd6bf57
--- /dev/null
+++ b/twelve/src/main/res/layout/activity_audio_preview.xml
@@ -0,0 +1,103 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2015 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/grp_transparent_wrapper"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@android:color/transparent"
+    android:padding="0dp">
+
+    <LinearLayout
+        android:id="@+id/grp_container_view"
+        android:layout_width="match_parent"
+        android:layout_height="@dimen/preview_layout_height"
+        android:layout_centerInParent="true"
+        android:layout_margin="@dimen/preview_layout_margin"
+        android:background="?android:colorBackground"
+        android:gravity="center_vertical"
+        android:orientation="vertical"
+        android:padding="@dimen/preview_layout_padding"
+        android:weightSum="1.0">
+
+        <FrameLayout
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight=".5">
+
+            <SeekBar
+                android:id="@+id/sb_progress"
+                android:layout_width="match_parent"
+                android:layout_height="@dimen/preview_layout_seekbar_height"
+                android:enabled="false"
+                android:maxHeight="@dimen/preview_layout_seekbar_height"
+                android:minHeight="@dimen/preview_layout_seekbar_height"
+                android:visibility="invisible" />
+
+            <ProgressBar
+                android:id="@+id/pb_loader"
+                style="@android:style/Widget.DeviceDefault.ProgressBar.Horizontal"
+                android:layout_width="match_parent"
+                android:layout_height="@dimen/preview_layout_seekbar_height"
+                android:indeterminate="true"
+                android:maxHeight="@dimen/preview_layout_seekbar_height"
+                android:minHeight="@dimen/preview_layout_seekbar_height"
+                android:visibility="invisible" />
+
+        </FrameLayout>
+
+        <RelativeLayout
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight=".5">
+
+            <ImageButton
+                android:id="@+id/ib_playpause"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_alignParentRight="true"
+                android:layout_alignParentTop="true"
+                android:background="@android:color/transparent"
+                android:enabled="false"
+                android:src="@drawable/btn_playback_play" />
+
+            <TextView
+                android:id="@+id/tv_title"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_alignParentLeft="true"
+                android:layout_alignParentTop="true"
+                android:layout_toLeftOf="@id/ib_playpause"
+                android:ellipsize="end"
+                android:gravity="top"
+                android:textSize="@dimen/preview_title_textSize"
+                android:textStyle="bold" />
+
+            <TextView
+                android:id="@+id/tv_artist"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_alignParentLeft="true"
+                android:layout_below="@id/tv_title"
+                android:layout_toLeftOf="@id/ib_playpause"
+                android:ellipsize="end"
+                android:textSize="@dimen/preview_artist_textSize"
+                android:textStyle="italic" />
+
+        </RelativeLayout>
+
+    </LinearLayout>
+
+</RelativeLayout>
diff --git a/twelve/src/main/res/layout/activity_base.xml b/twelve/src/main/res/layout/activity_base.xml
new file mode 100755
index 0000000000..3097743f26
--- /dev/null
+++ b/twelve/src/main/res/layout/activity_base.xml
@@ -0,0 +1,120 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+ 
+       http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<com.dolzzo.twelve.slidinguppanel.SlidingUpPanelLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/tools"
+    xmlns:sothree="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/sliding_layout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:gravity="bottom"
+    sothree:dragView="@+id/firstPanelDragArea"
+    sothree:dragViewClickable="false"
+    sothree:panelHeight="@dimen/bottom_action_bar_height"
+    sothree:shadowHeight="@dimen/sliding_panel_shadow_height"
+    sothree:slidePanelOffset="@dimen/bottom_action_bar_height">
+
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <android.support.v7.widget.Toolbar
+            android:id="@+id/toolbar"
+            android:layout_width="match_parent"
+            android:layout_height="?android:attr/actionBarSize"
+            android:theme="@style/ToolBarTheme"
+            app:elevation="@dimen/action_bar_elevation"
+            app:popupTheme="@style/ToolBarPopupTheme" />
+
+        <FrameLayout
+            android:id="@+id/activity_base_content"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent" />
+
+    </FrameLayout>
+
+    <com.dolzzo.twelve.slidinguppanel.SlidingUpPanelLayout
+        android:id="@+id/sliding_layout2"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:background="@color/activity_base_background_color"
+        android:gravity="bottom"
+        sothree:directOffset="true"
+        sothree:dragView="@+id/secondPanelDragArea"
+        sothree:fadeColor="@color/transparent"
+        sothree:panelHeight="@dimen/sliding_panel_indicator_height"
+        sothree:shadowHeight="@dimen/sliding_panel_shadow_height">
+
+        <include
+            layout="@layout/blur_scrim_image"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent" />
+
+        <RelativeLayout
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:orientation="vertical">
+
+            <LinearLayout
+                android:id="@+id/firstPanelDragArea"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical">
+
+                <include layout="@layout/bottom_action_bar" />
+
+                <fragment
+                    android:id="@+id/audioPlayerFragment"
+                    class="com.dolzzo.twelve.ui.fragments.AudioPlayerFragment"
+                    android:layout_width="match_parent"
+                    android:layout_height="0dip"
+                    android:layout_weight="1" />
+            </LinearLayout>
+        </RelativeLayout>
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:orientation="vertical">
+
+            <LinearLayout
+                android:id="@+id/secondPanelDragArea"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical">
+
+                <ImageView
+                    android:id="@+id/secondPanelDragIndicator"
+                    android:layout_width="wrap_content"
+                    android:layout_height="@dimen/sliding_panel_indicator_height"
+                    android:layout_gravity="center_horizontal"
+                    android:scaleType="centerInside"
+                    android:src="@drawable/drag_indicator" />
+
+                <include
+                    android:id="@+id/secondHeaderBar"
+                    layout="@layout/header_bar" />
+            </LinearLayout>
+
+            <fragment
+                android:id="@+id/queueFragment"
+                class="com.dolzzo.twelve.ui.fragments.QueueFragment"
+                android:layout_width="match_parent"
+                android:layout_height="0dip"
+                android:layout_weight="1" />
+        </LinearLayout>
+    </com.dolzzo.twelve.slidinguppanel.SlidingUpPanelLayout>
+</com.dolzzo.twelve.slidinguppanel.SlidingUpPanelLayout>
diff --git a/twelve/src/main/res/layout/activity_player_fragment.xml b/twelve/src/main/res/layout/activity_player_fragment.xml
new file mode 100755
index 0000000000..5a45713261
--- /dev/null
+++ b/twelve/src/main/res/layout/activity_player_fragment.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+    <include
+        android:id="@+id/audio_player_header"
+        layout="@layout/audio_player_header_bar" />
+
+    <include layout="@layout/main_album_flow" />
+
+    <include layout="@layout/main_playback_controls" />
+</LinearLayout>
diff --git a/twelve/src/main/res/layout/activity_search.xml b/twelve/src/main/res/layout/activity_search.xml
new file mode 100755
index 0000000000..d04d3fd316
--- /dev/null
+++ b/twelve/src/main/res/layout/activity_search.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+
+    <android.support.v7.widget.Toolbar
+        android:id="@+id/toolbar"
+        android:layout_width="match_parent"
+        android:layout_height="?android:attr/actionBarSize"
+        android:background="@color/primary"
+        android:theme="@style/ToolBarTheme"
+        app:elevation="@dimen/action_bar_elevation"
+        app:popupTheme="@style/ToolBarPopupTheme" />
+
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <ListView
+            android:id="@+id/list_search_history"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:cacheColorHint="@color/transparent"
+            android:divider="@null"
+            android:dividerHeight="0dp"
+            android:drawSelectorOnTop="false"
+            android:fastScrollEnabled="true" />
+
+        <include layout="@layout/list_base" />
+    </FrameLayout>
+</LinearLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/album_art_fragment.xml b/twelve/src/main/res/layout/album_art_fragment.xml
new file mode 100755
index 0000000000..bfb87ab71d
--- /dev/null
+++ b/twelve/src/main/res/layout/album_art_fragment.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <com.dolzzo.twelve.widgets.SquareImageView
+        android:id="@+id/audio_player_album_art"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:src="@drawable/default_artwork" />
+</FrameLayout>
diff --git a/twelve/src/main/res/layout/album_detail_song.xml b/twelve/src/main/res/layout/album_detail_song.xml
new file mode 100755
index 0000000000..53b6e134df
--- /dev/null
+++ b/twelve/src/main/res/layout/album_detail_song.xml
@@ -0,0 +1,59 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="70dp">
+
+    <LinearLayout
+        android:id="@+id/right_container"
+        android:layout_width="wrap_content"
+        android:layout_height="fill_parent"
+        android:layout_alignParentRight="true"
+        android:layout_centerVertical="true"
+        android:layout_marginRight="@dimen/list_item_general_margin"
+        android:gravity="center_vertical"
+        android:orientation="horizontal">
+
+        <ImageView
+            android:id="@+id/now_playing"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:src="@drawable/now_playing_icon"
+            android:visibility="gone" />
+
+        <com.dolzzo.twelve.widgets.PopupMenuButton
+            android:id="@+id/overflow"
+            android:layout_width="@dimen/overflow_width"
+            android:layout_height="@dimen/overflow_height"
+            android:gravity="center"
+            android:src="@drawable/menu_button" />
+    </LinearLayout>
+
+    <RelativeLayout
+        android:id="@+id/song_info"
+        android:layout_width="wrap_content"
+        android:layout_height="fill_parent"
+        android:layout_marginLeft="@dimen/list_item_general_margin"
+        android:layout_toLeftOf="@id/right_container"
+        android:gravity="center_vertical">
+
+        <TextView
+            android:id="@+id/title"
+            style="@style/ListItemMainText.Single"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content" />
+
+        <TextView
+            android:id="@+id/duration"
+            style="@style/ListItemSecondaryText.Single"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_below="@id/title" />
+
+    </RelativeLayout>
+
+    <ImageView
+        android:id="@+id/divider"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:src="@drawable/inset_list_divider" />
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/app_msg.xml b/twelve/src/main/res/layout/app_msg.xml
new file mode 100755
index 0000000000..d651b6c399
--- /dev/null
+++ b/twelve/src/main/res/layout/app_msg.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:gravity="center"
+    android:minHeight="48dp"
+    android:orientation="vertical">
+
+    <TextView
+        android:id="@android:id/message"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        android:padding="8dp"
+        android:textColor="@color/app_msg_text_color"
+        android:textIsSelectable="false"
+        android:textSize="14sp"
+        android:textStyle="bold" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/app_widget_large.xml b/twelve/src/main/res/layout/app_widget_large.xml
new file mode 100755
index 0000000000..d747a86d39
--- /dev/null
+++ b/twelve/src/main/res/layout/app_widget_large.xml
@@ -0,0 +1,105 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<GridLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/app_widget_large_min_height"
+    android:background="@color/widget_background_color"
+    android:columnCount="2"
+    android:rowCount="2"
+    tools:ignore="ContentDescription">
+
+    <ImageView
+        android:id="@+id/app_widget_large_image"
+        android:layout_width="@dimen/notification_expanded_height"
+        android:layout_height="@dimen/notification_expanded_height"
+        android:layout_marginBottom="@dimen/app_widget_bottom_margin"
+        android:layout_rowSpan="2"
+        android:scaleType="fitXY" />
+
+    <LinearLayout
+        android:id="@+id/app_widget_large_info_container"
+        android:layout_width="0dp"
+        android:layout_gravity="fill"
+        android:gravity="center_vertical"
+        android:orientation="vertical"
+        android:paddingLeft="@dimen/notification_info_container_padding_left">
+
+        <TextView
+            android:id="@+id/app_widget_large_line_one"
+            style="@style/NotificationText"
+            android:textColor="@color/widget_text"
+            android:textSize="@dimen/text_size_medium"
+            android:textStyle="bold" />
+
+        <TextView
+            android:id="@+id/app_widget_large_line_two"
+            style="@style/NotificationText"
+            android:textColor="@color/widget_text"
+            android:textSize="@dimen/text_size_small" />
+
+        <TextView
+            android:id="@+id/app_widget_large_line_three"
+            style="@style/NotificationText"
+            android:textColor="@color/widget_text"
+            android:textSize="@dimen/text_size_small" />
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/app_widget_large_buttons"
+        android:layout_width="0dp"
+        android:layout_gravity="fill_horizontal"
+        android:layout_marginBottom="@dimen/app_widget_bottom_margin"
+        android:dividerPadding="@dimen/notification_expanded_buttons_divider_padding"
+        android:gravity="center_vertical"
+        android:orientation="horizontal"
+        android:showDividers="middle">
+
+        <ImageButton
+            android:id="@+id/app_widget_large_previous"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/notification_expanded_button_height"
+            android:layout_weight="1"
+            android:background="?android:selectableItemBackground"
+            android:contentDescription="@string/accessibility_prev"
+            android:padding="@dimen/notification_expanded_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_previous" />
+
+        <ImageButton
+            android:id="@+id/app_widget_large_play"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/notification_expanded_button_height"
+            android:layout_weight="1"
+            android:background="?android:selectableItemBackground"
+            android:padding="@dimen/notification_expanded_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_pause" />
+
+        <ImageButton
+            android:id="@+id/app_widget_large_next"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/notification_expanded_button_height"
+            android:layout_weight="1"
+            android:background="?android:selectableItemBackground"
+            android:contentDescription="@string/accessibility_next"
+            android:padding="@dimen/notification_expanded_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_next" />
+    </LinearLayout>
+
+</GridLayout>
diff --git a/twelve/src/main/res/layout/app_widget_large_alternate.xml b/twelve/src/main/res/layout/app_widget_large_alternate.xml
new file mode 100755
index 0000000000..d71cde40d3
--- /dev/null
+++ b/twelve/src/main/res/layout/app_widget_large_alternate.xml
@@ -0,0 +1,126 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<GridLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/app_widget_large_min_height"
+    android:background="@color/widget_background_color"
+    android:columnCount="2"
+    android:rowCount="2"
+    tools:ignore="ContentDescription">
+
+    <ImageView
+        android:id="@+id/app_widget_large_alternate_image"
+        android:layout_width="@dimen/app_widget_large_alternate_artwork_size"
+        android:layout_height="@dimen/app_widget_large_alternate_artwork_size"
+        android:scaleType="fitXY" />
+
+    <LinearLayout
+        android:id="@+id/app_widget_large_alternate_info_container"
+        android:layout_width="0dp"
+        android:layout_gravity="center_vertical|fill_horizontal"
+        android:orientation="vertical"
+        android:paddingLeft="@dimen/notification_info_container_padding_left">
+
+        <TextView
+            android:id="@+id/app_widget_large_alternate_line_one"
+            style="@style/NotificationText"
+            android:textColor="@color/widget_text"
+            android:textSize="@dimen/text_size_medium"
+            android:textStyle="bold" />
+
+        <TextView
+            android:id="@+id/app_widget_large_alternate_line_two"
+            style="@style/NotificationText"
+            android:textColor="@color/widget_text"
+            android:textSize="@dimen/text_size_small" />
+
+        <TextView
+            android:id="@+id/app_widget_large_alternate_line_three"
+            style="@style/NotificationText"
+            android:textColor="@color/widget_text"
+            android:textSize="@dimen/text_size_small" />
+
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/app_widget_large_alternate_buttons"
+        android:layout_width="0dp"
+        android:layout_columnSpan="2"
+        android:layout_gravity="fill_horizontal"
+        android:layout_marginBottom="@dimen/app_widget_bottom_margin"
+        android:dividerPadding="@dimen/notification_expanded_buttons_divider_padding"
+        android:gravity="center_vertical"
+        android:orientation="horizontal"
+        android:showDividers="middle">
+
+        <ImageButton
+            android:id="@+id/app_widget_large_alternate_shuffle"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/notification_expanded_button_height"
+            android:layout_weight="1"
+            android:background="?android:selectableItemBackground"
+            android:contentDescription="@string/accessibility_shuffle"
+            android:padding="@dimen/notification_expanded_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_shuffle_all" />
+
+        <ImageButton
+            android:id="@+id/app_widget_large_alternate_previous"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/notification_expanded_button_height"
+            android:layout_weight="1"
+            android:background="?android:selectableItemBackground"
+            android:contentDescription="@string/accessibility_prev"
+            android:padding="@dimen/notification_expanded_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_previous" />
+
+        <ImageButton
+            android:id="@+id/app_widget_large_alternate_play"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/notification_expanded_button_height"
+            android:layout_weight="1"
+            android:background="?android:selectableItemBackground"
+            android:padding="@dimen/notification_expanded_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_pause" />
+
+        <ImageButton
+            android:id="@+id/app_widget_large_alternate_next"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/notification_expanded_button_height"
+            android:layout_weight="1"
+            android:background="?android:selectableItemBackground"
+            android:contentDescription="@string/accessibility_next"
+            android:padding="@dimen/notification_expanded_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_next" />
+
+        <ImageButton
+            android:id="@+id/app_widget_large_alternate_repeat"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/notification_expanded_button_height"
+            android:layout_weight="1"
+            android:background="?android:selectableItemBackground"
+            android:contentDescription="@string/accessibility_repeat"
+            android:padding="@dimen/notification_expanded_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_repeat_all" />
+    </LinearLayout>
+
+</GridLayout>
diff --git a/twelve/src/main/res/layout/app_widget_small.xml b/twelve/src/main/res/layout/app_widget_small.xml
new file mode 100755
index 0000000000..9662977cd8
--- /dev/null
+++ b/twelve/src/main/res/layout/app_widget_small.xml
@@ -0,0 +1,122 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<GridLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/widget_background_color"
+    android:columnCount="2"
+    android:gravity="top"
+    android:padding="@dimen/app_widget_padding"
+    android:rowCount="2"
+    tools:ignore="NestedWeights">
+
+    <ImageView
+        android:id="@+id/app_widget_small_image"
+        android:layout_width="@dimen/app_widget_small_artwork_size"
+        android:layout_height="@dimen/app_widget_small_artwork_size"
+        android:contentDescription="@null"
+        android:scaleType="centerInside" />
+
+    <LinearLayout
+        android:layout_gravity="fill_horizontal"
+        android:focusable="true"
+        android:gravity="center_horizontal"
+        android:orientation="horizontal">
+
+        <ImageButton
+            android:id="@+id/app_widget_small_previous"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/app_widget_small_button_height"
+            android:layout_weight="1"
+            android:background="@null"
+            android:contentDescription="@string/accessibility_prev"
+            android:focusable="true"
+            android:padding="@dimen/app_widget_small_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_previous" />
+
+        <ImageButton
+            android:id="@+id/app_widget_small_play"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/app_widget_small_button_height"
+            android:layout_weight="1"
+            android:background="@null"
+            android:contentDescription="@string/accessibility_play"
+            android:focusable="true"
+            android:padding="@dimen/app_widget_small_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_play" />
+
+        <ImageButton
+            android:id="@+id/app_widget_small_next"
+            android:layout_width="0dp"
+            android:layout_height="@dimen/app_widget_small_button_height"
+            android:layout_weight="1"
+            android:background="@null"
+            android:contentDescription="@string/accessibility_next"
+            android:focusable="true"
+            android:padding="@dimen/app_widget_small_button_padding"
+            android:scaleType="fitCenter"
+            android:src="@drawable/btn_playback_next" />
+
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/app_widget_small_info_container"
+        android:layout_columnSpan="2"
+        android:layout_gravity="fill"
+        android:layout_marginBottom="@dimen/app_widget_bottom_margin"
+        android:focusable="true"
+        android:gravity="center_vertical"
+        android:orientation="horizontal"
+        android:paddingLeft="@dimen/app_widget_small_info_container_padding_left"
+        android:paddingRight="@dimen/app_widget_small_info_container_padding_right">
+
+        <TextView
+            android:id="@+id/app_widget_small_line_one"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:ellipsize="none"
+            android:singleLine="true"
+            android:textColor="@color/widget_text"
+            android:textSize="@dimen/text_size_small"
+            android:textStyle="bold" />
+
+        <TextView
+            android:id="@+id/app_widget_small_text_separator"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:ellipsize="none"
+            android:paddingLeft="5dp"
+            android:paddingRight="5dp"
+            android:singleLine="true"
+            android:text="@string/app_widget_text_separator"
+            android:textColor="@color/widget_text"
+            android:textSize="@dimen/text_size_small" />
+
+        <TextView
+            android:id="@+id/app_widget_small_line_two"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:ellipsize="marquee"
+            android:singleLine="true"
+            android:textColor="@color/widget_text"
+            android:textSize="@dimen/text_size_small" />
+    </LinearLayout>
+
+</GridLayout>
diff --git a/twelve/src/main/res/layout/artist_detail_album.xml b/twelve/src/main/res/layout/artist_detail_album.xml
new file mode 100755
index 0000000000..c68612081a
--- /dev/null
+++ b/twelve/src/main/res/layout/artist_detail_album.xml
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2015 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<android.support.v7.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:card_view="http://schemas.android.com/apk/res-auto"
+    android:layout_width="156dp"
+    android:layout_height="222dp"
+    android:layout_marginRight="8dp"
+    android:elevation="3dp"
+    android:foreground="@drawable/selectable_background"
+    android:paddingBottom="8dp"
+    card_view:cardBackgroundColor="@color/cards_bg_color"
+    card_view:cardCornerRadius="2dp"
+    card_view:cardElevation="4dp">
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <ImageView
+            android:id="@+id/album_art"
+            android:layout_width="156dp"
+            android:layout_height="156dp"
+            android:layout_alignParentLeft="true"
+            android:layout_alignParentTop="true"
+            android:scaleType="centerCrop" />
+
+        <com.dolzzo.twelve.widgets.PopupMenuButton
+            android:id="@+id/overflow"
+            android:layout_width="@dimen/overflow_width"
+            android:layout_height="match_parent"
+            android:layout_alignParentRight="true"
+            android:layout_below="@id/album_art"
+            android:layout_marginBottom="1dp"
+            android:gravity="center_vertical"
+            android:src="@drawable/menu_button_light" />
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:layout_alignParentLeft="true"
+            android:layout_below="@id/album_art"
+            android:layout_marginLeft="8dp"
+            android:layout_toLeftOf="@id/overflow"
+            android:gravity="center_vertical"
+            android:orientation="vertical">
+
+            <TextView
+                android:id="@+id/title"
+                style="@style/ListItemMainText.Single"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:textColor="@color/artist_detail_album_title_text_color"
+                android:textSize="@dimen/text_size_micro" />
+
+            <TextView
+                android:id="@+id/year"
+                style="@style/ListItemSecondaryText.Single"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:textColor="@color/artist_detail_album_year_text_color"
+                android:textSize="@dimen/text_size_extra_micro" />
+
+        </LinearLayout>
+
+    </RelativeLayout>
+
+</android.support.v7.widget.CardView>
diff --git a/twelve/src/main/res/layout/artist_detail_header.xml b/twelve/src/main/res/layout/artist_detail_header.xml
new file mode 100755
index 0000000000..0bb4bbe742
--- /dev/null
+++ b/twelve/src/main/res/layout/artist_detail_header.xml
@@ -0,0 +1,43 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/artist_detail_header_background_color">
+
+    <ImageView
+        android:id="@+id/hero"
+        android:layout_width="match_parent"
+        android:layout_height="222dp"
+        android:gravity="center" />
+
+    <TextView
+        android:id="@+id/albums_label"
+        android:layout_width="wrap_content"
+        android:layout_height="40dp"
+        android:layout_below="@id/hero"
+        android:layout_marginLeft="@dimen/list_item_general_margin"
+        android:gravity="center_vertical"
+        android:text="@string/header_albums"
+        android:textAllCaps="true"
+        android:textColor="@color/artist_detail_header_albums_label_text_color"
+        android:textSize="@dimen/text_size_medium" />
+
+    <android.support.v7.widget.RecyclerView
+        android:id="@+id/albums"
+        android:layout_width="match_parent"
+        android:layout_height="230dp"
+        android:layout_below="@id/albums_label"
+        android:scrollbars="none" />
+
+    <TextView
+        android:id="@+id/songs_label"
+        android:layout_width="wrap_content"
+        android:layout_height="30dp"
+        android:layout_below="@id/albums"
+        android:layout_marginLeft="@dimen/list_item_general_margin"
+        android:gravity="bottom"
+        android:text="@string/header_all_songs"
+        android:textAllCaps="true"
+        android:textColor="@color/artist_detail_header_songs_label_text_color"
+        android:textSize="@dimen/text_size_medium" />
+
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/artist_detail_song.xml b/twelve/src/main/res/layout/artist_detail_song.xml
new file mode 100755
index 0000000000..c3d284030b
--- /dev/null
+++ b/twelve/src/main/res/layout/artist_detail_song.xml
@@ -0,0 +1,66 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="70dp">
+
+    <ImageView
+        android:id="@+id/album_art"
+        android:layout_width="50dp"
+        android:layout_height="50dp"
+        android:layout_alignParentLeft="true"
+        android:layout_alignParentTop="true"
+        android:layout_marginBottom="@dimen/list_preferred_item_padding"
+        android:layout_marginLeft="@dimen/list_item_general_margin"
+        android:layout_marginRight="@dimen/list_preferred_item_padding"
+        android:layout_marginTop="@dimen/list_preferred_item_padding" />
+
+    <LinearLayout
+        android:id="@+id/right_container"
+        android:layout_width="wrap_content"
+        android:layout_height="fill_parent"
+        android:layout_alignParentRight="true"
+        android:layout_centerVertical="true"
+        android:layout_marginRight="@dimen/list_item_general_margin"
+        android:gravity="center_vertical"
+        android:orientation="horizontal">
+
+        <ImageView
+            android:id="@+id/now_playing"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:src="@drawable/now_playing_icon"
+            android:visibility="gone" />
+
+        <com.dolzzo.twelve.widgets.PopupMenuButton
+            android:id="@+id/overflow"
+            android:layout_width="@dimen/overflow_width"
+            android:layout_height="@dimen/overflow_height"
+            android:src="@drawable/menu_button" />
+    </LinearLayout>
+
+    <TextView
+        android:id="@+id/title"
+        style="@style/ListItemMainText.Single"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentTop="true"
+        android:layout_marginTop="16dp"
+        android:layout_toLeftOf="@id/right_container"
+        android:layout_toRightOf="@id/album_art" />
+
+    <TextView
+        android:id="@+id/album"
+        style="@style/ListItemSecondaryText.Single"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_below="@id/title"
+        android:layout_marginTop="-2dp"
+        android:layout_toLeftOf="@id/right_container"
+        android:layout_toRightOf="@id/album_art" />
+
+    <ImageView
+        android:id="@+id/divider"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:src="@drawable/inset_list_divider" />
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/audio_player_header_bar.xml b/twelve/src/main/res/layout/audio_player_header_bar.xml
new file mode 100755
index 0000000000..c76a2c7b55
--- /dev/null
+++ b/twelve/src/main/res/layout/audio_player_header_bar.xml
@@ -0,0 +1,95 @@
+<!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="@dimen/header_bar_height"
+    android:background="@android:color/transparent"
+    android:elevation="@dimen/action_bar_elevation"
+    android:orientation="horizontal"
+    android:paddingLeft="@dimen/header_bar_padding_left">
+
+    <LinearLayout
+        android:id="@+id/header_bar_button_container"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentRight="true"
+        android:layout_centerVertical="true"
+        android:orientation="horizontal">
+
+        <ImageView
+            android:id="@+id/header_bar_add_button"
+            android:layout_width="@dimen/header_bar_custom_button_width"
+            android:layout_height="@dimen/header_bar_button_height"
+            android:layout_gravity="center_vertical"
+            android:layout_weight="0"
+            android:background="@drawable/selectable_background"
+            android:scaleType="centerInside"
+            android:src="@drawable/btn_add_to_playlist" />
+
+        <ImageView
+            android:id="@+id/header_bar_search_button"
+            android:layout_width="@dimen/header_bar_custom_button_width"
+            android:layout_height="@dimen/header_bar_button_height"
+            android:layout_gravity="center_vertical"
+            android:layout_weight="0"
+            android:background="@drawable/selectable_background"
+            android:scaleType="centerInside"
+            android:src="@drawable/ic_action_search" />
+
+        <ImageView
+            android:id="@+id/header_bar_menu_button"
+            android:layout_width="@dimen/header_bar_menu_button_width"
+            android:layout_height="@dimen/header_bar_button_height"
+            android:layout_gravity="center_vertical"
+            android:layout_weight="0"
+            android:background="@drawable/selectable_background"
+            android:scaleType="centerInside"
+            android:src="@drawable/menu_button_light" />
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/header_bar_text_container"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentLeft="true"
+        android:layout_centerVertical="true"
+        android:layout_toLeftOf="@id/header_bar_button_container"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/header_bar_song_title"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:ellipsize="end"
+            android:maxLines="1"
+            android:textAllCaps="true"
+            android:textColor="@color/header_action_bar_text_color"
+            android:textSize="@dimen/text_size_medium"
+            android:textStyle="bold" />
+
+        <TextView
+            android:id="@+id/header_bar_artist_title"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:ellipsize="end"
+            android:maxLines="1"
+            android:paddingBottom="2dp"
+            android:textAllCaps="true"
+            android:textColor="@color/header_action_bar_text_color"
+            android:textSize="@dimen/text_size_micro" />
+    </LinearLayout>
+</RelativeLayout>
diff --git a/twelve/src/main/res/layout/blur_scrim_image.xml b/twelve/src/main/res/layout/blur_scrim_image.xml
new file mode 100755
index 0000000000..eeccf7d3b0
--- /dev/null
+++ b/twelve/src/main/res/layout/blur_scrim_image.xml
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<com.dolzzo.twelve.widgets.BlurScrimImage xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/blurScrimImage"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <ImageView
+        android:id="@+id/blurImage"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:scaleType="centerCrop"
+        android:src="@drawable/default_artwork_blur" />
+
+    <LinearLayout
+        android:id="@+id/blurScrim"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="vertical" />
+</com.dolzzo.twelve.widgets.BlurScrimImage>
diff --git a/twelve/src/main/res/layout/bottom_action_bar.xml b/twelve/src/main/res/layout/bottom_action_bar.xml
new file mode 100755
index 0000000000..8467c50884
--- /dev/null
+++ b/twelve/src/main/res/layout/bottom_action_bar.xml
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/bottom_action_bar"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/bottom_action_bar_height"
+    android:layout_gravity="bottom"
+    android:background="@android:color/transparent"
+    android:clickable="true"
+    android:elevation="@dimen/action_bar_elevation"
+    android:orientation="horizontal"
+    tools:ignore="ContentDescription">
+
+    <com.dolzzo.twelve.widgets.SquareImageView
+        android:id="@+id/bottom_action_bar_album_art"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="left|center"
+        android:src="@drawable/default_artwork" />
+
+    <RelativeLayout
+        android:id="@+id/bottom_action_bar_info_container"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_vertical"
+        android:layout_weight="1"
+        android:paddingLeft="@dimen/bottom_action_bar_info_padding_left">
+
+        <TextView
+            android:id="@+id/bottom_action_bar_line_one"
+            style="@style/BottomActionBarLineOne" />
+
+        <TextView
+            android:id="@+id/bottom_action_bar_line_two"
+            style="@style/BottomActionBarLineTwo"
+            android:layout_below="@+id/bottom_action_bar_line_one" />
+    </RelativeLayout>
+
+    <FrameLayout
+        android:id="@+id/play_pause_container"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_vertical"
+        android:paddingLeft="@dimen/bab_progress_padding_left"
+        android:paddingRight="@dimen/bab_progress_padding_right">
+
+        <include
+            layout="@layout/play_pause_progress_button"
+            android:layout_width="@dimen/bab_progress_size"
+            android:layout_height="@dimen/bab_progress_size"
+            android:contentDescription="@string/accessibility_play" />
+    </FrameLayout>
+</LinearLayout>
diff --git a/twelve/src/main/res/layout/colorstrip.xml b/twelve/src/main/res/layout/colorstrip.xml
new file mode 100755
index 0000000000..432b3b74b3
--- /dev/null
+++ b/twelve/src/main/res/layout/colorstrip.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<View xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/colorstrip"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/colorstrip_height"
+    android:background="@color/accent" />
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/edit_queue_list_item.xml b/twelve/src/main/res/layout/edit_queue_list_item.xml
new file mode 100755
index 0000000000..67e34203cd
--- /dev/null
+++ b/twelve/src/main/res/layout/edit_queue_list_item.xml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/edit_track_list_parent"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/item_normal_height">
+
+    <ImageView
+        android:id="@+id/edit_track_list_item_handle"
+        android:layout_width="@dimen/drag_and_drop_width"
+        android:layout_height="@dimen/drag_and_drop_height"
+        android:layout_centerVertical="true"
+        android:scaleType="fitXY"
+        android:src="@drawable/gripper_light" />
+
+    <FrameLayout
+        android:id="@+id/edit_track_list_container"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_toRightOf="@+id/edit_track_list_item_handle"
+        android:gravity="center_vertical">
+
+        <include layout="@layout/list_item_queue" />
+    </FrameLayout>
+
+    <ImageView
+        android:id="@+id/divider"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:src="@drawable/dnd_list_divider_light" />
+</RelativeLayout>
diff --git a/twelve/src/main/res/layout/edit_track_list_item.xml b/twelve/src/main/res/layout/edit_track_list_item.xml
new file mode 100755
index 0000000000..ed42a4ce3e
--- /dev/null
+++ b/twelve/src/main/res/layout/edit_track_list_item.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/edit_track_list_parent"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/item_normal_height">
+
+    <ImageView
+        android:id="@+id/edit_track_list_item_handle"
+        android:layout_width="@dimen/drag_and_drop_width"
+        android:layout_height="@dimen/drag_and_drop_height"
+        android:layout_centerVertical="true"
+        android:scaleType="fitXY"
+        android:src="@drawable/gripper" />
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="@dimen/item_normal_height"
+        android:layout_toRightOf="@+id/edit_track_list_item_handle"
+        android:gravity="center_vertical"
+        android:minHeight="@dimen/item_normal_height"
+        android:paddingBottom="@dimen/list_item_padding_bottom"
+        android:paddingRight="@dimen/list_item_general_margin"
+        android:paddingTop="@dimen/list_item_padding_top">
+
+        <include layout="@layout/list_item_common" />
+    </RelativeLayout>
+
+    <ImageView
+        android:id="@+id/divider"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:src="@drawable/dnd_list_divider" />
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/faux_playlist_header.xml b/twelve/src/main/res/layout/faux_playlist_header.xml
new file mode 100755
index 0000000000..136827966a
--- /dev/null
+++ b/twelve/src/main/res/layout/faux_playlist_header.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+ 
+       http://www.apache.org/licenses/LICENSE-2.0
+ 
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content">
+
+    <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+        android:layout_width="match_parent"
+        android:layout_height="@dimen/faux_playlist_detail_header_height"
+        android:visibility="invisible"></RelativeLayout>
+</FrameLayout>
diff --git a/twelve/src/main/res/layout/fragment_music_browser_phone.xml b/twelve/src/main/res/layout/fragment_music_browser_phone.xml
new file mode 100755
index 0000000000..541a869f74
--- /dev/null
+++ b/twelve/src/main/res/layout/fragment_music_browser_phone.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <RelativeLayout
+        android:id="@+id/fragment_home_phone_container"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <com.dolzzo.twelve.widgets.ViewPagerTabs
+            android:id="@+id/fragment_home_phone_pager_titles"
+            style="@style/HeaderTabTextStyle"
+            android:layout_width="match_parent"
+            android:layout_height="@dimen/tpi_height"
+            android:elevation="@dimen/action_bar_elevation" />
+
+        <android.support.v4.view.ViewPager
+            android:id="@+id/fragment_home_phone_pager"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:layout_below="@+id/fragment_home_phone_pager_titles" />
+    </RelativeLayout>
+
+</FrameLayout>
diff --git a/twelve/src/main/res/layout/grid_base.xml b/twelve/src/main/res/layout/grid_base.xml
new file mode 100755
index 0000000000..e96b08a05a
--- /dev/null
+++ b/twelve/src/main/res/layout/grid_base.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/grid_base_container"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <include layout="@layout/loading_empty_container" />
+
+    <GridView
+        android:id="@+id/grid_base"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:cacheColorHint="@color/transparent"
+        android:clipToPadding="false"
+        android:drawSelectorOnTop="true"
+        android:fadingEdge="vertical"
+        android:fastScrollEnabled="true"
+        android:horizontalSpacing="@dimen/grid_item_horizontal_spacing"
+        android:paddingBottom="4dp"
+        android:paddingLeft="@dimen/list_item_general_margin"
+        android:paddingRight="@dimen/list_item_general_margin"
+        android:paddingTop="4dp"
+        android:scrollbarStyle="outsideOverlay"
+        android:scrollbars="vertical"
+        android:verticalSpacing="@dimen/grid_item_vertical_spacing" />
+</FrameLayout>
diff --git a/twelve/src/main/res/layout/grid_header.xml b/twelve/src/main/res/layout/grid_header.xml
new file mode 100755
index 0000000000..16a256aaaf
--- /dev/null
+++ b/twelve/src/main/res/layout/grid_header.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="8dp">
+    <!-- height should be list_item_general_margin - grid_item_vertical_spacing -->
+</FrameLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/grid_items_normal.xml b/twelve/src/main/res/layout/grid_items_normal.xml
new file mode 100755
index 0000000000..8d8339625e
--- /dev/null
+++ b/twelve/src/main/res/layout/grid_items_normal.xml
@@ -0,0 +1,73 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<android.support.v7.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:card_view="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    card_view:cardBackgroundColor="@color/cards_bg_color"
+    card_view:cardCornerRadius="2dp"
+    card_view:cardElevation="4dp">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+
+        <include layout="@layout/square_image_view" />
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="@dimen/grid_bottom_height"
+            android:orientation="horizontal"
+            android:paddingLeft="@dimen/grid_item_padding_left">
+
+            <LinearLayout
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_vertical"
+                android:layout_weight="1"
+                android:orientation="vertical">
+
+                <TextView
+                    android:id="@+id/line_one"
+                    style="@style/ListItemMainText.Grid.Single"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:paddingBottom="1dp"
+                    android:textColor="@color/grid_items_normal_line_one" />
+
+                <TextView
+                    android:id="@+id/line_two"
+                    style="@style/ListItemSecondaryText.Grid.Single"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:textColor="@color/grid_items_normal_line_two" />
+
+            </LinearLayout>
+
+            <com.dolzzo.twelve.widgets.PopupMenuButton
+                android:id="@+id/popup_menu_button"
+                android:layout_width="wrap_content"
+                android:layout_height="match_parent"
+                android:paddingRight="@dimen/grid_item_padding_right"
+                android:src="@drawable/menu_button_light" />
+
+        </LinearLayout>
+
+    </LinearLayout>
+
+</android.support.v7.widget.CardView>
diff --git a/twelve/src/main/res/layout/header_bar.xml b/twelve/src/main/res/layout/header_bar.xml
new file mode 100755
index 0000000000..f24ad679d9
--- /dev/null
+++ b/twelve/src/main/res/layout/header_bar.xml
@@ -0,0 +1,70 @@
+<!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<com.dolzzo.twelve.ui.HeaderBar xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="@dimen/header_bar_height"
+    android:background="@color/header_action_bar_color"
+    android:elevation="@dimen/action_bar_elevation"
+    android:enabled="false"
+    android:gravity="center_vertical"
+    android:orientation="horizontal"
+    android:paddingStart="@dimen/drag_and_drop_width"
+    android:theme="@style/ToolBarTheme">
+
+    <ImageView
+        android:id="@+id/header_bar_up"
+        android:layout_width="@dimen/header_bar_up_width"
+        android:layout_height="@dimen/header_bar_button_height"
+        android:layout_gravity="center_vertical"
+        android:layout_weight="0"
+        android:background="@drawable/selectable_background"
+        android:scaleType="centerCrop"
+        android:src="@drawable/btn_header_collapse" />
+
+    <TextView
+        android:id="@+id/header_bar_title"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:ellipsize="end"
+        android:singleLine="true"
+        android:textAllCaps="true"
+        android:textColor="@color/header_action_bar_text_color"
+        android:textSize="@dimen/text_size_medium"
+        android:textStyle="bold" />
+
+    <ImageView
+        android:id="@+id/header_bar_search_button"
+        android:layout_width="@dimen/header_bar_custom_button_width"
+        android:layout_height="@dimen/header_bar_button_height"
+        android:layout_gravity="center_vertical"
+        android:layout_weight="0"
+        android:background="@drawable/selectable_background"
+        android:scaleType="centerInside"
+        android:src="@drawable/ic_action_search" />
+
+    <ImageView
+        android:id="@+id/header_bar_menu_button"
+        android:layout_width="@dimen/header_bar_menu_button_width"
+        android:layout_height="@dimen/header_bar_button_height"
+        android:layout_gravity="center_vertical"
+        android:layout_weight="0"
+        android:background="@drawable/selectable_background"
+        android:scaleType="centerInside"
+        android:src="@drawable/menu_button_light" />
+
+</com.dolzzo.twelve.ui.HeaderBar>
diff --git a/twelve/src/main/res/layout/list_base.xml b/twelve/src/main/res/layout/list_base.xml
new file mode 100755
index 0000000000..f94e3de794
--- /dev/null
+++ b/twelve/src/main/res/layout/list_base.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/list_base_container"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <include layout="@layout/loading_empty_container" />
+
+    <com.dolzzo.twelve.dragdrop.DragSortListView
+        android:id="@+id/list_base"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:cacheColorHint="@color/transparent"
+        android:divider="@null"
+        android:dividerHeight="0dp"
+        android:drawSelectorOnTop="false"
+        android:fadingEdge="vertical"
+        android:fastScrollEnabled="true" />
+</FrameLayout>
diff --git a/twelve/src/main/res/layout/list_base_padding.xml b/twelve/src/main/res/layout/list_base_padding.xml
new file mode 100755
index 0000000000..db1c094280
--- /dev/null
+++ b/twelve/src/main/res/layout/list_base_padding.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/list_base_container"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/list_base_container_background_color">
+
+    <include layout="@layout/loading_empty_container" />
+
+    <com.dolzzo.twelve.dragdrop.DragSortListView
+        android:id="@+id/list_base"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:cacheColorHint="@color/transparent"
+        android:clipToPadding="false"
+        android:divider="@null"
+        android:dividerHeight="0dp"
+        android:drawSelectorOnTop="false"
+        android:fadingEdge="vertical"
+        android:fastScrollEnabled="true"
+        android:paddingTop="@dimen/header_bar_height" />
+</FrameLayout>
diff --git a/twelve/src/main/res/layout/list_header.xml b/twelve/src/main/res/layout/list_header.xml
new file mode 100755
index 0000000000..ab7fd3dfb4
--- /dev/null
+++ b/twelve/src/main/res/layout/list_header.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/title"
+    android:layout_width="match_parent"
+    android:layout_height="30dp"
+    android:layout_alignParentBottom="true"
+    android:background="@null"
+    android:gravity="center_vertical"
+    android:paddingLeft="@dimen/list_item_general_margin"
+    android:paddingRight="@dimen/list_item_general_margin"
+    android:textAllCaps="true"
+    android:textColor="@color/list_item_header_text_color"
+    android:textSize="@dimen/list_item_header_size" />
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/list_item_common.xml b/twelve/src/main/res/layout/list_item_common.xml
new file mode 100755
index 0000000000..dfeed14dec
--- /dev/null
+++ b/twelve/src/main/res/layout/list_item_common.xml
@@ -0,0 +1,63 @@
+<merge xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <ImageView
+        android:id="@+id/image"
+        android:layout_width="@dimen/list_item_image_width"
+        android:layout_height="@dimen/list_item_image_height"
+        android:layout_centerVertical="true"
+        android:scaleType="centerCrop" />
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="@dimen/list_item_image_height"
+        android:layout_toLeftOf="@+id/line_one_right"
+        android:layout_toRightOf="@+id/image"
+        android:gravity="center_vertical"
+        android:minHeight="@dimen/item_normal_height"
+        android:paddingLeft="@dimen/list_preferred_item_padding">
+
+        <TextView
+            android:id="@+id/line_one"
+            style="@style/ListItemMainText.Single"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content" />
+
+        <TextView
+            android:id="@+id/line_two"
+            style="@style/ListItemSecondaryText.Single"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_below="@+id/line_one" />
+    </RelativeLayout>
+
+    <TextView
+        android:id="@+id/line_one_right"
+        style="@style/ListItemSecondaryText.Single"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerVertical="true"
+        android:layout_toLeftOf="@+id/right_container" />
+
+    <LinearLayout
+        android:id="@id/right_container"
+        android:layout_width="wrap_content"
+        android:layout_height="fill_parent"
+        android:layout_alignParentRight="true"
+        android:layout_centerVertical="true"
+        android:gravity="center_vertical"
+        android:orientation="horizontal">
+
+        <ImageView
+            android:id="@+id/now_playing"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:src="@drawable/now_playing_icon"
+            android:visibility="gone" />
+
+        <com.dolzzo.twelve.widgets.PopupMenuButton
+            android:id="@+id/popup_menu_button"
+            android:layout_width="@dimen/overflow_width"
+            android:layout_height="@dimen/overflow_height"
+            android:src="@drawable/menu_button" />
+    </LinearLayout>
+</merge>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/list_item_normal.xml b/twelve/src/main/res/layout/list_item_normal.xml
new file mode 100755
index 0000000000..d1420980c1
--- /dev/null
+++ b/twelve/src/main/res/layout/list_item_normal.xml
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/item_normal_height"
+    android:minHeight="@dimen/item_normal_height"
+    tools:ignore="ContentDescription">
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:gravity="center_vertical"
+        android:paddingBottom="@dimen/list_item_padding_bottom"
+        android:paddingLeft="@dimen/list_item_general_margin"
+        android:paddingRight="@dimen/list_item_general_margin"
+        android:paddingTop="@dimen/list_item_padding_top">
+
+        <include layout="@layout/list_item_common" />
+    </RelativeLayout>
+
+    <ImageView
+        android:id="@+id/divider"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:src="@drawable/inset_list_divider" />
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/list_item_queue.xml b/twelve/src/main/res/layout/list_item_queue.xml
new file mode 100755
index 0000000000..b3a41b957f
--- /dev/null
+++ b/twelve/src/main/res/layout/list_item_queue.xml
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/item_normal_height"
+    android:background="@android:color/transparent"
+    android:gravity="center_vertical"
+    android:minHeight="@dimen/item_normal_height"
+    android:paddingBottom="@dimen/list_item_padding_bottom"
+    android:paddingTop="@dimen/list_item_padding_top">
+
+    <ImageView
+        android:id="@+id/image"
+        android:layout_width="@dimen/list_item_image_width"
+        android:layout_height="@dimen/list_item_image_height"
+        android:layout_centerVertical="true"
+        android:scaleType="centerCrop" />
+
+    <!-- center the text views vertically -->
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:layout_toLeftOf="@+id/play_pause_container"
+        android:layout_toRightOf="@id/image"
+        android:gravity="center_vertical"
+        android:orientation="vertical"
+        android:paddingLeft="@dimen/list_item_queue_text_padding_left">
+
+        <TextView
+            android:id="@+id/line_one"
+            style="@style/ListItemMainText.Light.Single"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content" />
+
+        <TextView
+            android:id="@+id/line_two"
+            style="@style/ListItemSecondaryText.Light.Single"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content" />
+    </LinearLayout>
+
+    <FrameLayout
+        android:id="@id/play_pause_container"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerVertical="true"
+        android:layout_toLeftOf="@+id/popup_menu_button"
+        android:paddingLeft="@dimen/list_item_progress_padding_left"
+        android:paddingRight="@dimen/list_item_progress_padding_right">
+
+        <include
+            layout="@layout/play_pause_progress_button"
+            android:layout_width="@dimen/list_item_progress_width"
+            android:layout_height="@dimen/list_item_progress_height"
+            android:layout_centerVertical="true" />
+    </FrameLayout>
+
+    <com.dolzzo.twelve.widgets.PopupMenuButton
+        android:id="@id/popup_menu_button"
+        android:layout_width="@dimen/overflow_width"
+        android:layout_height="@dimen/overflow_height"
+        android:layout_alignParentRight="true"
+        android:layout_centerVertical="true"
+        android:src="@drawable/menu_button_light" />
+</RelativeLayout>
diff --git a/twelve/src/main/res/layout/list_item_search_history.xml b/twelve/src/main/res/layout/list_item_search_history.xml
new file mode 100755
index 0000000000..d9ebab93aa
--- /dev/null
+++ b/twelve/src/main/res/layout/list_item_search_history.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/item_short_height"
+    android:minHeight="@dimen/item_short_height"
+    tools:ignore="ContentDescription">
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:gravity="center_vertical"
+        android:paddingBottom="@dimen/list_item_padding_bottom"
+        android:paddingLeft="@dimen/list_preferred_item_padding"
+        android:paddingRight="@dimen/list_preferred_item_padding"
+        android:paddingTop="@dimen/list_item_padding_top">
+
+        <com.dolzzo.twelve.widgets.SquareImageView
+            android:id="@+id/image"
+            android:layout_width="@dimen/list_item_image_width"
+            android:layout_height="@dimen/list_item_image_height"
+            android:layout_centerVertical="true"
+            android:scaleType="centerCrop"
+            android:src="@drawable/history_icon" />
+
+        <TextView
+            android:id="@+id/line_one"
+            style="@style/ListItemMainText.Single"
+            android:layout_width="match_parent"
+            android:layout_height="fill_parent"
+            android:layout_centerVertical="true"
+            android:layout_toRightOf="@id/image"
+            android:gravity="center_vertical" />
+    </RelativeLayout>
+
+    <ImageView
+        android:id="@+id/divider"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:src="@drawable/inset_list_divider" />
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/list_item_simple.xml b/twelve/src/main/res/layout/list_item_simple.xml
new file mode 100755
index 0000000000..199d416ee7
--- /dev/null
+++ b/twelve/src/main/res/layout/list_item_simple.xml
@@ -0,0 +1,78 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/item_normal_height"
+    android:minHeight="@dimen/item_normal_height"
+    tools:ignore="ContentDescription">
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:gravity="center_vertical"
+        android:paddingBottom="@dimen/list_item_padding_bottom"
+        android:paddingLeft="@dimen/list_preferred_item_padding"
+        android:paddingRight="@dimen/list_preferred_item_padding"
+        android:paddingTop="@dimen/list_item_padding_top">
+
+        <!-- center the text views vertically -->
+        <LinearLayout
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:layout_alignParentLeft="true"
+            android:layout_toLeftOf="@+id/line_one_right"
+            android:gravity="center_vertical"
+            android:orientation="vertical">
+
+            <TextView
+                android:id="@+id/line_one"
+                style="@style/ListItemMainText.Single"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content" />
+
+            <TextView
+                android:id="@+id/line_two"
+                style="@style/ListItemSecondaryText.Single"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content" />
+        </LinearLayout>
+
+        <TextView
+            android:id="@+id/line_one_right"
+            style="@style/ListItemSecondaryText.Single"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerVertical="true"
+            android:layout_toLeftOf="@+id/popup_menu_button" />
+
+        <com.dolzzo.twelve.widgets.PopupMenuButton
+            android:id="@id/popup_menu_button"
+            android:layout_width="@dimen/overflow_width"
+            android:layout_height="@dimen/overflow_height"
+            android:layout_alignParentRight="true"
+            android:layout_centerVertical="true"
+            android:src="@drawable/menu_button" />
+    </RelativeLayout>
+
+    <ImageView
+        android:id="@+id/divider"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:src="@drawable/inset_list_divider" />
+</RelativeLayout>
diff --git a/twelve/src/main/res/layout/list_item_smart_playlist.xml b/twelve/src/main/res/layout/list_item_smart_playlist.xml
new file mode 100755
index 0000000000..b2261bcbb2
--- /dev/null
+++ b/twelve/src/main/res/layout/list_item_smart_playlist.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/item_normal_height"
+    android:elevation="2dp"
+    android:minHeight="@dimen/item_normal_height"
+    tools:ignore="ContentDescription">
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:gravity="center_vertical"
+        android:paddingBottom="@dimen/list_item_padding_bottom"
+        android:paddingLeft="@dimen/list_item_general_margin"
+        android:paddingRight="@dimen/list_item_general_margin"
+        android:paddingTop="@dimen/list_item_padding_top">
+
+        <include layout="@layout/list_item_common" />
+    </RelativeLayout>
+
+    <ImageView
+        android:id="@+id/divider"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:src="@drawable/inset_list_divider_no_padding" />
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/list_item_top_tracks.xml b/twelve/src/main/res/layout/list_item_top_tracks.xml
new file mode 100755
index 0000000000..fcbbf1e145
--- /dev/null
+++ b/twelve/src/main/res/layout/list_item_top_tracks.xml
@@ -0,0 +1,111 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/item_normal_height"
+    android:minHeight="@dimen/item_normal_height"
+    tools:ignore="ContentDescription">
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:gravity="center_vertical"
+        android:paddingBottom="@dimen/list_item_padding_bottom"
+        android:paddingLeft="@dimen/list_item_general_margin"
+        android:paddingRight="@dimen/list_item_general_margin"
+        android:paddingTop="@dimen/list_item_padding_top">
+
+        <FrameLayout
+            android:id="@+id/position_contanier"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_alignParentLeft="true"
+            android:layout_centerVertical="true">
+
+            <ImageView
+                android:layout_width="@dimen/list_item_top_track_image_size"
+                android:layout_height="@dimen/list_item_top_track_image_size"
+                android:layout_gravity="center"
+                android:scaleType="centerCrop"
+                android:src="@drawable/gray_circle" />
+
+            <TextView
+                android:id="@+id/position_number"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center"
+                android:textColor="@color/position_number_color"
+                android:textSize="@dimen/text_size_small"
+                android:textStyle="bold" />
+        </FrameLayout>
+
+
+        <RelativeLayout
+            android:layout_width="match_parent"
+            android:layout_height="@dimen/list_item_image_height"
+            android:layout_toLeftOf="@+id/right_container"
+            android:layout_toRightOf="@+id/position_contanier"
+            android:gravity="center_vertical"
+            android:minHeight="@dimen/item_normal_height"
+            android:paddingLeft="@dimen/list_preferred_item_padding">
+
+            <TextView
+                android:id="@+id/line_one"
+                style="@style/ListItemMainText.Single"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content" />
+
+            <TextView
+                android:id="@+id/line_two"
+                style="@style/ListItemSecondaryText.Single"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_below="@+id/line_one" />
+        </RelativeLayout>
+
+        <LinearLayout
+            android:id="@id/right_container"
+            android:layout_width="wrap_content"
+            android:layout_height="fill_parent"
+            android:layout_alignParentRight="true"
+            android:layout_centerVertical="true"
+            android:gravity="center_vertical"
+            android:orientation="horizontal">
+
+            <ImageView
+                android:id="@+id/now_playing"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:src="@drawable/now_playing_icon"
+                android:visibility="gone" />
+
+            <com.dolzzo.twelve.widgets.PopupMenuButton
+                android:id="@+id/popup_menu_button"
+                android:layout_width="@dimen/overflow_width"
+                android:layout_height="@dimen/overflow_height"
+                android:src="@drawable/menu_button" />
+        </LinearLayout>
+    </RelativeLayout>
+
+    <ImageView
+        android:id="@+id/divider"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true"
+        android:src="@drawable/inset_list_divider" />
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/list_menu_item_layout.xml b/twelve/src/main/res/layout/list_menu_item_layout.xml
new file mode 100755
index 0000000000..e8124c68ab
--- /dev/null
+++ b/twelve/src/main/res/layout/list_menu_item_layout.xml
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2007 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+  
+          http://www.apache.org/licenses/LICENSE-2.0
+  
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<android.support.v7.view.menu.ListMenuItemView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="?android:attr/listPreferredItemHeightSmall">
+
+    <!-- Icon will be inserted here. -->
+
+    <!-- The title and summary have some gap between them, and this 'group' should be centered vertically. -->
+    <RelativeLayout
+        android:layout_width="0dip"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_vertical"
+        android:layout_marginEnd="?android:attr/listPreferredItemPaddingEnd"
+        android:layout_marginStart="?android:attr/listPreferredItemPaddingStart"
+        android:layout_weight="1"
+        android:duplicateParentState="true">
+
+        <TextView
+            android:id="@+id/title"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_alignParentStart="true"
+            android:layout_alignParentTop="true"
+            android:duplicateParentState="true"
+            android:ellipsize="marquee"
+            android:fadingEdge="horizontal"
+            android:singleLine="true"
+            android:textAlignment="viewStart"
+            android:textAppearance="?android:attr/textAppearanceListItemSmall" />
+
+        <TextView
+            android:id="@+id/shortcut"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_alignParentStart="true"
+            android:layout_below="@id/title"
+            android:duplicateParentState="true"
+            android:singleLine="true"
+            android:textAlignment="viewStart"
+            android:textAppearance="?android:attr/textAppearanceSmall" />
+
+    </RelativeLayout>
+
+    <!-- Checkbox, and/or radio button will be inserted here. -->
+
+</android.support.v7.view.menu.ListMenuItemView>
diff --git a/twelve/src/main/res/layout/list_search_footer.xml b/twelve/src/main/res/layout/list_search_footer.xml
new file mode 100755
index 0000000000..bd3317ec79
--- /dev/null
+++ b/twelve/src/main/res/layout/list_search_footer.xml
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:background="@null"
+    android:orientation="vertical">
+
+    <ImageView
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:src="@drawable/inset_list_divider_no_padding" />
+
+    <TextView
+        android:id="@+id/title"
+        android:layout_width="match_parent"
+        android:layout_height="50dp"
+        android:background="@null"
+        android:gravity="center"
+        android:textAllCaps="true"
+        android:textColor="@color/list_item_search_footer_text_color"
+        android:textSize="@dimen/list_item_footer_size"
+        android:textStyle="bold" />
+
+    <ImageView
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:src="@drawable/inset_list_divider_no_padding" />
+</LinearLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/list_search_header.xml b/twelve/src/main/res/layout/list_search_header.xml
new file mode 100755
index 0000000000..02578b648b
--- /dev/null
+++ b/twelve/src/main/res/layout/list_search_header.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="46dp"
+    android:background="@null">
+
+    <TextView
+        android:id="@+id/title"
+        android:layout_width="match_parent"
+        android:layout_height="20dp"
+        android:layout_alignParentBottom="true"
+        android:background="@null"
+        android:gravity="center_vertical"
+        android:paddingLeft="@dimen/list_item_general_margin"
+        android:paddingRight="@dimen/list_item_general_margin"
+        android:textAllCaps="true"
+        android:textColor="@color/list_item_header_text_color"
+        android:textSize="@dimen/list_item_header_size" />
+</RelativeLayout>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/loading_empty_container.xml b/twelve/src/main/res/layout/loading_empty_container.xml
new file mode 100755
index 0000000000..4e6356f1bc
--- /dev/null
+++ b/twelve/src/main/res/layout/loading_empty_container.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<com.dolzzo.twelve.widgets.LoadingEmptyContainer xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/loading_empty_container"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:layout_centerInParent="true"
+    android:layout_gravity="center"
+    android:gravity="center">
+
+    <ProgressBar
+        android:id="@+id/progressbar"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center" />
+
+    <include layout="@layout/no_results_message" />
+</com.dolzzo.twelve.widgets.LoadingEmptyContainer>
diff --git a/twelve/src/main/res/layout/main_album_flow.xml b/twelve/src/main/res/layout/main_album_flow.xml
new file mode 100755
index 0000000000..c71415f5d1
--- /dev/null
+++ b/twelve/src/main/res/layout/main_album_flow.xml
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<com.dolzzo.twelve.widgets.SquareFrame xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <com.dolzzo.twelve.widgets.SquareViewPager
+        android:id="@+id/audio_player_album_art_viewpager"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent" />
+
+    <include layout="@layout/loading_empty_container" />
+
+    <com.dolzzo.twelve.widgets.VisualizerView
+        android:id="@+id/visualizerView"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_gravity="bottom"
+        android:gravity="bottom"
+        android:visibility="visible" />
+
+    <TextView
+        android:id="@+id/audio_player_lyrics"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center"
+        android:alpha="0.0"
+        android:background="@color/lyrics_background_color"
+        android:gravity="center"
+        android:minHeight="66dp"
+        android:paddingBottom="6dp"
+        android:paddingLeft="15dp"
+        android:paddingRight="15dp"
+        android:paddingTop="6dp"
+        android:textColor="@color/audio_player_lyrics_text_color"
+        android:textSize="@dimen/text_size_small" />
+</com.dolzzo.twelve.widgets.SquareFrame>
\ No newline at end of file
diff --git a/twelve/src/main/res/layout/main_playback_controls.xml b/twelve/src/main/res/layout/main_playback_controls.xml
new file mode 100755
index 0000000000..5aff453c82
--- /dev/null
+++ b/twelve/src/main/res/layout/main_playback_controls.xml
@@ -0,0 +1,143 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<android.support.v7.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:card_view="http://schemas.android.com/apk/res-auto"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    card_view:cardBackgroundColor="@color/semitransparent_black"
+    card_view:cardCornerRadius="@dimen/audio_player_controls_card_corner_radius"
+    card_view:cardElevation="@dimen/audio_player_controls_card_elevation"
+    card_view:cardUseCompatPadding="true"
+    card_view:contentPadding="@dimen/audio_player_controls_card_content_padding">
+
+    <RelativeLayout
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent">
+
+        <include
+            android:id="@+id/playPauseProgressButton"
+            layout="@layout/play_pause_progress_button"
+            android:layout_width="@dimen/audio_player_controls_main_button_width"
+            android:layout_height="@dimen/audio_player_controls_main_button_height"
+            android:layout_centerInParent="true"
+            android:background="@drawable/fab_accent"
+            android:contentDescription="@string/accessibility_play"
+            android:gravity="center_horizontal" />
+
+        <!-- This is the left side of the progress bar - it has the previous
+        and shuffle button and the current time text -->
+        <RelativeLayout
+            android:layout_width="wrap_content"
+            android:layout_height="fill_parent"
+            android:layout_toLeftOf="@id/playPauseProgressButton">
+
+            <TextView
+                android:id="@+id/audio_player_current_time"
+                android:layout_width="52dp"
+                android:layout_height="@dimen/audio_player_controls_end_button_height"
+                android:layout_alignParentRight="true"
+                android:layout_centerVertical="true"
+                android:gravity="left|center_vertical"
+                android:paddingLeft="@dimen/audio_player_time_text_padding"
+                android:textColor="@color/audio_player_current_time_color"
+                android:textSize="@dimen/audio_player_time_text_size"
+                android:textStyle="bold" />
+
+            <com.dolzzo.twelve.widgets.RepeatingImageButton
+                android:id="@+id/action_button_previous"
+                android:layout_width="@dimen/audio_player_controls_end_button_width"
+                android:layout_height="@dimen/audio_player_controls_end_button_height"
+                android:layout_centerVertical="true"
+                android:layout_toLeftOf="@id/audio_player_current_time"
+                android:scaleType="fitCenter"
+                android:src="@drawable/btn_playback_previous" />
+
+            <!-- divider -->
+            <View
+                android:id="@+id/action_button_left_bottom_divider"
+                android:layout_width="@dimen/audio_player_divider_length"
+                android:layout_height="@dimen/audio_player_divider_height"
+                android:layout_alignParentRight="true"
+                android:layout_below="@id/audio_player_current_time"
+                android:layout_marginRight="@dimen/audio_player_divider_horizontal_offset"
+                android:background="@color/now_playing_divider" />
+
+            <com.dolzzo.twelve.widgets.ShuffleButton
+                android:id="@+id/action_button_shuffle"
+                android:layout_width="@dimen/audio_player_controls_end_button_width"
+                android:layout_height="@dimen/audio_player_controls_end_button_height"
+                android:layout_alignLeft="@id/action_button_previous"
+                android:layout_below="@id/action_button_left_bottom_divider"
+                android:layout_marginLeft="@dimen/audio_player_controls_end_button_half_width"
+                android:contentDescription="@string/accessibility_shuffle"
+                android:scaleType="fitCenter"
+                android:src="@drawable/btn_playback_shuffle_all" />
+        </RelativeLayout>
+
+        <!-- This is the right side of the progress bar - it has the next
+        and repeat button and the total time text -->
+        <RelativeLayout
+            android:layout_width="wrap_content"
+            android:layout_height="fill_parent"
+            android:layout_toRightOf="@id/playPauseProgressButton">
+
+            <TextView
+                android:id="@+id/audio_player_total_time"
+                android:layout_width="52dp"
+                android:layout_height="@dimen/audio_player_controls_end_button_height"
+                android:layout_alignParentLeft="true"
+                android:layout_centerVertical="true"
+                android:gravity="right|center_vertical"
+                android:paddingRight="@dimen/audio_player_time_text_padding"
+                android:textColor="@color/audio_player_total_time_color"
+                android:textSize="@dimen/audio_player_time_text_size"
+                android:textStyle="bold" />
+
+            <com.dolzzo.twelve.widgets.RepeatingImageButton
+                android:id="@+id/action_button_next"
+                android:layout_width="@dimen/audio_player_controls_end_button_width"
+                android:layout_height="@dimen/audio_player_controls_end_button_height"
+                android:layout_centerVertical="true"
+                android:layout_toRightOf="@id/audio_player_total_time"
+                android:scaleType="fitCenter"
+                android:src="@drawable/btn_playback_next" />
+
+            <!-- divider -->
+            <View
+                android:id="@+id/action_button_right_bottom_divider"
+                android:layout_width="@dimen/audio_player_divider_length"
+                android:layout_height="@dimen/audio_player_divider_height"
+                android:layout_alignParentLeft="true"
+                android:layout_below="@id/audio_player_total_time"
+                android:layout_marginLeft="@dimen/audio_player_divider_horizontal_offset" />
+
+            <com.dolzzo.twelve.widgets.RepeatButton
+                android:id="@+id/action_button_repeat"
+                android:layout_width="@dimen/audio_player_controls_end_button_width"
+                android:layout_height="@dimen/audio_player_controls_end_button_height"
+                android:layout_alignRight="@id/action_button_next"
+                android:layout_below="@id/audio_player_total_time"
+                android:layout_marginRight="@dimen/audio_player_controls_end_button_half_width"
+                android:contentDescription="@string/accessibility_repeat"
+                android:focusable="true"
+                android:scaleType="fitCenter"
+                android:src="@drawable/btn_playback_repeat_all" />
+
+        </RelativeLayout>
+
+    </RelativeLayout>
+</android.support.v7.widget.CardView>
diff --git a/twelve/src/main/res/layout/no_results_message.xml b/twelve/src/main/res/layout/no_results_message.xml
new file mode 100755
index 0000000000..096007a32e
--- /dev/null
+++ b/twelve/src/main/res/layout/no_results_message.xml
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<com.dolzzo.twelve.widgets.NoResultsContainer xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/no_results_container"
+    android:layout_width="@dimen/no_results_width"
+    android:layout_height="wrap_content"
+    android:layout_centerInParent="true"
+    android:layout_gravity="center"
+    android:gravity="center_horizontal"
+    android:orientation="vertical"
+    android:visibility="gone">
+
+    <ImageView
+        android:layout_width="@dimen/white_note_width"
+        android:layout_height="@dimen/white_note_height"
+        android:layout_gravity="center_horizontal"
+        android:paddingBottom="@dimen/white_note_padding_bottom"
+        android:scaleType="centerInside"
+        android:src="@drawable/no_results" />
+
+    <LinearLayout
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:gravity="center_horizontal"
+        android:orientation="vertical"
+        android:paddingBottom="@dimen/no_results_text_padding_bottom">
+
+        <TextView
+            android:id="@+id/no_results_main_text"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:gravity="center_horizontal"
+            android:maxLines="2"
+            android:text="@string/empty_generic_main"
+            android:textAllCaps="true"
+            android:textColor="@color/no_results"
+            android:textSize="@dimen/no_results_text_main"
+            android:textStyle="bold" />
+
+        <TextView
+            android:id="@+id/no_results_main_highlight_text"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:ellipsize="end"
+            android:gravity="center_horizontal"
+            android:maxLines="2"
+            android:textColor="@color/no_results"
+            android:textSize="@dimen/no_results_text_main"
+            android:textStyle="bold|italic"
+            android:visibility="gone" />
+    </LinearLayout>
+
+    <TextView
+        android:id="@+id/no_results_secondary_text"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:gravity="center_horizontal"
+        android:text="@string/empty_generic_secondary"
+        android:textColor="@color/no_results"
+        android:textSize="@dimen/no_results_text_secondary" />
+</com.dolzzo.twelve.widgets.NoResultsContainer>
diff --git a/twelve/src/main/res/layout/play_pause_progress_button.xml b/twelve/src/main/res/layout/play_pause_progress_button.xml
new file mode 100755
index 0000000000..d74f1af885
--- /dev/null
+++ b/twelve/src/main/res/layout/play_pause_progress_button.xml
@@ -0,0 +1,55 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<com.dolzzo.twelve.widgets.PlayPauseProgressButton xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/playPauseProgressButton"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:visibility="gone">
+
+    <!-- TODO: Figure out why scaleType: centerInside isn't properly scaling up -->
+    <com.dolzzo.twelve.widgets.PlayPauseButton
+        android:id="@+id/action_button_play"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:layout_gravity="center"
+        android:background="@color/accent"
+        android:contentDescription="@string/accessibility_play"
+        android:focusable="true"
+        android:scaleType="centerCrop"
+        android:src="@drawable/btn_playback_play" />
+
+    <ProgressBar
+        android:id="@+id/progressBarBackground"
+        style="?android:attr/progressBarStyleHorizontal"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:clickable="false"
+        android:indeterminate="false"
+        android:max="1000"
+        android:progress="1000"
+        android:progressDrawable="@drawable/circular_drawable_background" />
+
+    <ProgressBar
+        android:id="@+id/circularProgressBar"
+        style="?android:attr/progressBarStyleHorizontal"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:clickable="false"
+        android:indeterminate="false"
+        android:max="1000"
+        android:progressDrawable="@drawable/circular_drawable" />
+
+</com.dolzzo.twelve.widgets.PlayPauseProgressButton>
diff --git a/twelve/src/main/res/layout/playlist_detail.xml b/twelve/src/main/res/layout/playlist_detail.xml
new file mode 100755
index 0000000000..64d8fc9f95
--- /dev/null
+++ b/twelve/src/main/res/layout/playlist_detail.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <include layout="@layout/list_base_padding" />
+
+    <include
+        android:id="@+id/playlist_header"
+        layout="@layout/playlist_detail_header" />
+
+</RelativeLayout>
diff --git a/twelve/src/main/res/layout/playlist_detail_header.xml b/twelve/src/main/res/layout/playlist_detail_header.xml
new file mode 100755
index 0000000000..bc61320142
--- /dev/null
+++ b/twelve/src/main/res/layout/playlist_detail_header.xml
@@ -0,0 +1,70 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="@dimen/playlist_detail_header_height">
+
+    <com.dolzzo.twelve.widgets.LayoutSuppressingImageView
+        android:id="@+id/image"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:layout_alignParentTop="true"
+        android:layout_centerHorizontal="true"
+        android:contentDescription="@null"
+        android:scaleType="centerCrop" />
+
+    <FrameLayout
+        android:layout_width="fill_parent"
+        android:layout_height="@dimen/playlist_detail_header_bottom_height"
+        android:layout_alignParentBottom="true"
+        android:background="@color/header_shadow_color">
+
+        <LinearLayout
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:gravity="center_vertical"
+            android:orientation="horizontal">
+
+            <ImageView
+                android:layout_width="20dp"
+                android:layout_height="20dp"
+                android:scaleType="centerInside"
+                android:src="@drawable/playlist_icon" />
+
+            <TextView
+                android:id="@+id/number_of_songs_text"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:paddingRight="16dp"
+                android:textColor="@color/number_of_songs_text_color"
+                android:textSize="@dimen/text_size_micro" />
+
+            <ImageView
+                android:layout_width="20dp"
+                android:layout_height="20dp"
+                android:scaleType="centerInside"
+                android:src="@drawable/stopwatch_icon_white" />
+
+            <TextView
+                android:id="@+id/duration_text"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textColor="@color/duration_text_color"
+                android:textSize="@dimen/text_size_micro" />
+        </LinearLayout>
+    </FrameLayout>
+</RelativeLayout>
diff --git a/twelve/src/main/res/layout/square_image_view.xml b/twelve/src/main/res/layout/square_image_view.xml
new file mode 100755
index 0000000000..2888998e17
--- /dev/null
+++ b/twelve/src/main/res/layout/square_image_view.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<com.dolzzo.twelve.widgets.SquareView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/square_view"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <com.dolzzo.twelve.widgets.SquareImageView
+        android:id="@+id/image"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:scaleType="centerCrop" />
+
+</com.dolzzo.twelve.widgets.SquareView>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/activity_base.xml b/twelve/src/main/res/menu/activity_base.xml
new file mode 100755
index 0000000000..8797387f56
--- /dev/null
+++ b/twelve/src/main/res/menu/activity_base.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_settings"
+        android:orderInCategory="1000"
+        android:title="@string/menu_settings"
+        app:showAsAction="never" />
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/album_sort_by.xml b/twelve/src/main/res/menu/album_sort_by.xml
new file mode 100755
index 0000000000..6fe0614337
--- /dev/null
+++ b/twelve/src/main/res/menu/album_sort_by.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_sort_by"
+        android:orderInCategory="200"
+        android:title="@string/menu_sort_by"
+        app:showAsAction="never">
+        <menu>
+            <item
+                android:id="@+id/menu_sort_by_az"
+                android:title="@string/sort_order_entry_az" />
+            <item
+                android:id="@+id/menu_sort_by_za"
+                android:title="@string/sort_order_entry_za" />
+            <item
+                android:id="@+id/menu_sort_by_year"
+                android:title="@string/sort_order_entry_year" />
+            <item
+                android:id="@+id/menu_sort_by_artist"
+                android:title="@string/sort_order_entry_artist" />
+            <item
+                android:id="@+id/menu_sort_by_number_of_songs"
+                android:title="@string/sort_order_entry_number_of_songs" />
+        </menu>
+    </item>
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/artist_album_sort_by.xml b/twelve/src/main/res/menu/artist_album_sort_by.xml
new file mode 100755
index 0000000000..32643ad5d1
--- /dev/null
+++ b/twelve/src/main/res/menu/artist_album_sort_by.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_sort_by"
+        android:title="@string/menu_sort_by"
+        app:showAsAction="never">
+        <menu>
+            <item
+                android:id="@+id/menu_sort_by_az"
+                android:title="@string/sort_order_entry_az" />
+            <item
+                android:id="@+id/menu_sort_by_za"
+                android:title="@string/sort_order_entry_za" />
+            <item
+                android:id="@+id/menu_sort_by_year"
+                android:title="@string/sort_order_entry_year" />
+            <item
+                android:id="@+id/menu_sort_by_number_of_songs"
+                android:title="@string/sort_order_entry_number_of_songs" />
+        </menu>
+    </item>
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/artist_song_sort_by.xml b/twelve/src/main/res/menu/artist_song_sort_by.xml
new file mode 100755
index 0000000000..d9f1688b8a
--- /dev/null
+++ b/twelve/src/main/res/menu/artist_song_sort_by.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_sort_by"
+        android:title="@string/menu_sort_by"
+        app:showAsAction="never">
+        <menu>
+            <item
+                android:id="@+id/menu_sort_by_az"
+                android:title="@string/sort_order_entry_az" />
+            <item
+                android:id="@+id/menu_sort_by_za"
+                android:title="@string/sort_order_entry_za" />
+            <item
+                android:id="@+id/menu_sort_by_year"
+                android:title="@string/sort_order_entry_year" />
+            <item
+                android:id="@+id/menu_sort_by_album"
+                android:title="@string/sort_order_entry_album" />
+            <item
+                android:id="@+id/menu_sort_by_duration"
+                android:title="@string/sort_order_entry_duration" />
+            <item
+                android:id="@+id/menu_sort_by_date_added"
+                android:title="@string/sort_order_entry_date_added" />
+            <item
+                android:id="@+id/menu_sort_by_filename"
+                android:title="@string/sort_order_entry_filename" />
+        </menu>
+    </item>
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/artist_sort_by.xml b/twelve/src/main/res/menu/artist_sort_by.xml
new file mode 100755
index 0000000000..dc7fdb6285
--- /dev/null
+++ b/twelve/src/main/res/menu/artist_sort_by.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_sort_by"
+        android:orderInCategory="200"
+        android:title="@string/menu_sort_by"
+        app:showAsAction="never">
+        <menu>
+            <item
+                android:id="@+id/menu_sort_by_az"
+                android:title="@string/sort_order_entry_az" />
+            <item
+                android:id="@+id/menu_sort_by_za"
+                android:title="@string/sort_order_entry_za" />
+            <item
+                android:id="@+id/menu_sort_by_number_of_songs"
+                android:title="@string/sort_order_entry_number_of_songs" />
+            <item
+                android:id="@+id/menu_sort_by_number_of_albums"
+                android:title="@string/sort_order_entry_number_of_albums" />
+        </menu>
+    </item>
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/audio_player.xml b/twelve/src/main/res/menu/audio_player.xml
new file mode 100755
index 0000000000..19b55c2df6
--- /dev/null
+++ b/twelve/src/main/res/menu/audio_player.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_audio_player_equalizer"
+        android:orderInCategory="41"
+        android:title="@string/menu_equalizer"
+        app:showAsAction="never" />
+    <item
+        android:id="@+id/menu_audio_player_ringtone"
+        android:orderInCategory="42"
+        android:title="@string/context_menu_use_as_ringtone"
+        app:showAsAction="never" />
+    <item
+        android:id="@+id/menu_audio_player_more_by_artist"
+        android:orderInCategory="43"
+        android:title="@string/context_menu_more_by_artist"
+        app:showAsAction="never" />
+    <item
+        android:id="@+id/menu_audio_player_delete"
+        android:orderInCategory="44"
+        android:title="@string/context_menu_delete"
+        app:showAsAction="never" />
+
+</menu>
diff --git a/twelve/src/main/res/menu/clear_list.xml b/twelve/src/main/res/menu/clear_list.xml
new file mode 100755
index 0000000000..0b70b6e919
--- /dev/null
+++ b/twelve/src/main/res/menu/clear_list.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/clear_list"
+        android:orderInCategory="150"
+        android:title="@string/menu_clear_list"
+        app:showAsAction="never" />
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/new_playlist.xml b/twelve/src/main/res/menu/new_playlist.xml
new file mode 100755
index 0000000000..6eb0ec04d4
--- /dev/null
+++ b/twelve/src/main/res/menu/new_playlist.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_new_playlist"
+        android:orderInCategory="130"
+        android:title="@string/new_playlist"
+        app:showAsAction="never" />
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/queue.xml b/twelve/src/main/res/menu/queue.xml
new file mode 100755
index 0000000000..48442e418e
--- /dev/null
+++ b/twelve/src/main/res/menu/queue.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_save_queue"
+        android:orderInCategory="50"
+        android:title="@string/menu_save_queue"
+        app:showAsAction="never" />
+    <item
+        android:id="@+id/menu_clear_queue"
+        android:orderInCategory="51"
+        android:title="@string/menu_clear_queue"
+        app:showAsAction="never" />
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/search.xml b/twelve/src/main/res/menu/search.xml
new file mode 100755
index 0000000000..a86b09cbab
--- /dev/null
+++ b/twelve/src/main/res/menu/search.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_search"
+        android:actionViewClass="android.widget.SearchView"
+        android:orderInCategory="1"
+        android:title="@string/menu_search"
+        app:actionViewClass="android.support.v7.widget.SearchView"
+        app:showAsAction="ifRoom|collapseActionView" />
+
+</menu>
diff --git a/twelve/src/main/res/menu/search_btn.xml b/twelve/src/main/res/menu/search_btn.xml
new file mode 100755
index 0000000000..268b83a1b2
--- /dev/null
+++ b/twelve/src/main/res/menu/search_btn.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+    <item
+        android:id="@+id/menu_search"
+        android:icon="@drawable/ic_action_search"
+        android:orderInCategory="1"
+        android:title="@string/menu_search"
+        app:showAsAction="ifRoom" />
+</menu>
diff --git a/twelve/src/main/res/menu/shuffle_all.xml b/twelve/src/main/res/menu/shuffle_all.xml
new file mode 100755
index 0000000000..6aa6a5fd09
--- /dev/null
+++ b/twelve/src/main/res/menu/shuffle_all.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_shuffle_all"
+        android:orderInCategory="30"
+        android:title="@string/menu_shuffle_all"
+        app:showAsAction="never" />
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/shuffle_item.xml b/twelve/src/main/res/menu/shuffle_item.xml
new file mode 100755
index 0000000000..0cafcbfcc8
--- /dev/null
+++ b/twelve/src/main/res/menu/shuffle_item.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_shuffle_item"
+        android:orderInCategory="30"
+        android:title="@string/menu_shuffle_item"
+        app:showAsAction="never" />
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/menu/song_sort_by.xml b/twelve/src/main/res/menu/song_sort_by.xml
new file mode 100755
index 0000000000..27924b6dec
--- /dev/null
+++ b/twelve/src/main/res/menu/song_sort_by.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto">
+
+    <item
+        android:id="@+id/menu_sort_by"
+        android:orderInCategory="200"
+        android:title="@string/menu_sort_by"
+        app:showAsAction="never">
+        <menu>
+            <item
+                android:id="@+id/menu_sort_by_az"
+                android:title="@string/sort_order_entry_az" />
+            <item
+                android:id="@+id/menu_sort_by_za"
+                android:title="@string/sort_order_entry_za" />
+            <item
+                android:id="@+id/menu_sort_by_year"
+                android:title="@string/sort_order_entry_year" />
+            <item
+                android:id="@+id/menu_sort_by_artist"
+                android:title="@string/sort_order_entry_artist" />
+            <item
+                android:id="@+id/menu_sort_by_album"
+                android:title="@string/sort_order_entry_album" />
+            <item
+                android:id="@+id/menu_sort_by_duration"
+                android:title="@string/sort_order_entry_duration" />
+            <item
+                android:id="@+id/menu_sort_by_filename"
+                android:title="@string/sort_order_entry_filename" />
+        </menu>
+    </item>
+
+</menu>
\ No newline at end of file
diff --git a/twelve/src/main/res/mipmap-hdpi/ic_launcher_eleven.png b/twelve/src/main/res/mipmap-hdpi/ic_launcher_eleven.png
new file mode 100755
index 0000000000..407d91ed96
Binary files /dev/null and b/twelve/src/main/res/mipmap-hdpi/ic_launcher_eleven.png differ
diff --git a/twelve/src/main/res/mipmap-mdpi/ic_launcher_eleven.png b/twelve/src/main/res/mipmap-mdpi/ic_launcher_eleven.png
new file mode 100755
index 0000000000..0413c8587a
Binary files /dev/null and b/twelve/src/main/res/mipmap-mdpi/ic_launcher_eleven.png differ
diff --git a/twelve/src/main/res/mipmap-xhdpi/ic_launcher_eleven.png b/twelve/src/main/res/mipmap-xhdpi/ic_launcher_eleven.png
new file mode 100755
index 0000000000..e7f2784589
Binary files /dev/null and b/twelve/src/main/res/mipmap-xhdpi/ic_launcher_eleven.png differ
diff --git a/twelve/src/main/res/mipmap-xxhdpi/ic_launcher_eleven.png b/twelve/src/main/res/mipmap-xxhdpi/ic_launcher_eleven.png
new file mode 100755
index 0000000000..77fcd9b87b
Binary files /dev/null and b/twelve/src/main/res/mipmap-xxhdpi/ic_launcher_eleven.png differ
diff --git a/twelve/src/main/res/mipmap-xxxhdpi/ic_launcher_eleven.png b/twelve/src/main/res/mipmap-xxxhdpi/ic_launcher_eleven.png
new file mode 100755
index 0000000000..2e41d3efba
Binary files /dev/null and b/twelve/src/main/res/mipmap-xxxhdpi/ic_launcher_eleven.png differ
diff --git a/twelve/src/main/res/transition/explode.xml b/twelve/src/main/res/transition/explode.xml
new file mode 100755
index 0000000000..2e40891444
--- /dev/null
+++ b/twelve/src/main/res/transition/explode.xml
@@ -0,0 +1,2 @@
+<explode xmlns:android="http://schemas.android.com/apk/res/android"
+    android:duration="300" />
diff --git a/twelve/src/main/res/values-ko/plurals.xml b/twelve/src/main/res/values-ko/plurals.xml
new file mode 100755
index 0000000000..5976f6620a
--- /dev/null
+++ b/twelve/src/main/res/values-ko/plurals.xml
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--Generated by crowdin.com-->
+<!--
+     Copyright (C) 2012-2013 Andrew Neal
+     Copyright (C) 2012-2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+  <!-- Used to indicate the number of artists -->
+  <plurals name="Nartists">
+    <item quantity="other"><xliff:g id="count">%d</xliff:g>명의 아티스트</item>
+  </plurals>
+  <!-- Used to indicate the number of albums for an artist -->
+  <plurals name="Nalbums">
+    <item quantity="other"><xliff:g id="count">%d</xliff:g>개의 앨범</item>
+  </plurals>
+  <!-- Used to indicate the number of songs for an album -->
+  <plurals name="Nsongs">
+    <item quantity="other"><xliff:g id="count">%d</xliff:g>곡의 음악</item>
+  </plurals>
+  <!-- Used to indicate the number of genres -->
+  <plurals name="Ngenres">
+    <item quantity="other"><xliff:g id="count">%d</xliff:g>개의 장르</item>
+  </plurals>
+  <!-- Used to show a shortened version of hours-->
+  <plurals name="Nhours">
+    <item quantity="other"><xliff:g id="hours">%d</xliff:g>시간</item>
+  </plurals>
+  <!-- Used to show a shortened version of minutes -->
+  <plurals name="Nminutes">
+    <item quantity="other"><xliff:g id="minutes">%d</xliff:g>분</item>
+  </plurals>
+  <!-- Toasts after adding song(s) to playlists -->
+  <plurals name="NNNtrackstoplaylist">
+    <item quantity="other"><xliff:g id="number" example="27">%d</xliff:g>곡의 음악이 재생목록에 추가되었습니다.</item>
+  </plurals>
+  <!-- Toasts after removing song(s) from playlists -->
+  <plurals name="NNNtracksfromplaylist">
+    <item quantity="other"><xliff:g id="number" example="27">%d</xliff:g>곡의 음악이 재생목록에서 제거되었습니다.</item>
+  </plurals>
+  <!-- Toasts after adding song(s) to queue -->
+  <plurals name="NNNtrackstoqueue">
+    <item quantity="other"><xliff:g id="number" example="27">%d</xliff:g>곡의 음악이 대기열에 추가되었습니다.</item>
+  </plurals>
+  <!-- Toasts after adding song(s) to the favorites list -->
+  <plurals name="NNNtrackstofavorites">
+    <item quantity="other"><xliff:g id="number" example="27">%d</xliff:g>곡의 음악이 즐겨찾기에 추가되었습니다.</item>
+  </plurals>
+  <!-- Toast confirming that song(s) was/were deleted. -->
+  <plurals name="NNNtracksdeleted">
+    <item quantity="other"><xliff:g id="songs_to_delete">%d</xliff:g>곡의 음악이 삭제되었습니다.</item>
+  </plurals>
+</resources>
diff --git a/twelve/src/main/res/values-ko/strings.xml b/twelve/src/main/res/values-ko/strings.xml
new file mode 100755
index 0000000000..fa13bcfa35
--- /dev/null
+++ b/twelve/src/main/res/values-ko/strings.xml
@@ -0,0 +1,189 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--Generated by crowdin.com-->
+<!--
+     Copyright (C) 2012-2013 Andrew Neal
+     Copyright (C) 2012-2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+  <string name="app_name">음악</string>
+  <!-- Page titles -->
+  <string name="page_recent">최근</string>
+  <string name="page_artists">아티스트</string>
+  <string name="page_albums">앨범</string>
+  <string name="page_songs">음악</string>
+  <string name="page_playlists">재생목록</string>
+  <string name="page_genres">장르</string>
+  <string name="page_now_playing">재생 중</string>
+  <string name="page_play_queue">재생 대기열</string>
+  <!-- Section Headers -->
+  <string name="header_albums">앨범</string>
+  <string name="header_top_songs">자주 듣는 곡들</string>
+  <string name="header_all_songs">모든 노래</string>
+  <!-- Option menu items -->
+  <string name="menu_settings">설정</string>
+  <string name="menu_search">검색</string>
+  <string name="menu_shuffle_item">셔플</string>
+  <string name="menu_shuffle_all">모두 셔플</string>
+  <string name="menu_shuffle_playlist">재생목록 셔플</string>
+  <string name="menu_shuffle_album">앨범 셔플</string>
+  <string name="menu_shuffle_artist">아티스트 셔플</string>
+  <string name="menu_shuffle_top_tracks">자주 듣는 곡들 셔플</string>
+  <string name="menu_shuffle_recent">최근 재생 셔플</string>
+  <string name="menu_shuffle_last_added">최근 추가 셔플</string>
+  <string name="menu_play_all">모두 재생</string>
+  <string name="menu_sort_by">정렬</string>
+  <string name="menu_clear_list">목록 비우기</string>
+  <string name="menu_clear_recents">최근 목록 비우기</string>
+  <string name="menu_clear_queue">대기열 비우기</string>
+  <string name="menu_save_queue">큐를 재생 목록으로 저장</string>
+  <string name="menu_equalizer">이퀄라이저</string>
+  <!-- Playlist items -->
+  <string name="add_to_playlist">재생목록에 추가</string>
+  <string name="add_to_queue">대기열에 추가</string>
+  <string name="remove_from_recent">최근 재생 목록에서 제거</string>
+  <string name="remove_from_queue">대기열에서 제거</string>
+  <!-- Sort orders -->
+  <string name="sort_order_entry_az">오름차순</string>
+  <string name="sort_order_entry_za">내림차순</string>
+  <string name="sort_order_entry_artist">아티스트</string>
+  <string name="sort_order_entry_album">앨범</string>
+  <string name="sort_order_entry_year">연도</string>
+  <string name="sort_order_entry_duration">길이</string>
+  <string name="sort_order_entry_date_added">추가된 날짜</string>
+  <string name="sort_order_entry_track_list">트랙 목록</string>
+  <string name="sort_order_entry_number_of_songs">음악 수</string>
+  <string name="sort_order_entry_number_of_albums">앨범 수</string>
+  <string name="sort_order_entry_filename">파일명</string>
+  <!-- Default playlist names -->
+  <string name="playlist_last_added">최근에 추가된 곡</string>
+  <string name="playlist_recently_played">최근에 재생된 곡</string>
+  <string name="playlist_top_tracks">자주 듣는 노래</string>
+  <!-- AlertDialog items -->
+  <string name="new_playlist">새 재생목록</string>
+  <string name="save">저장</string>
+  <string name="cancel">취소</string>
+  <string name="overwrite">덮어쓰기</string>
+  <string name="clear">지우기</string>
+  <string name="new_playlist_name_template">재생목록 <xliff:g id="number">%d</xliff:g></string>
+  <string name="create_playlist_prompt">재생목록 이름</string>
+  <string name="delete_dialog_title"><xliff:g id="item" example="album">%s</xliff:g>을(를) 삭제할까요?</string>
+  <string name="clear_top_tracks_title">자주 듣는 곡들 목록을 비우시겠습니까?</string>
+  <string name="clear_recent_title">최근 재생 목록을 비우시겠습니까?</string>
+  <string name="clear_last_added">최근 추가 목록을 비우시겠습니까?</string>
+  <string name="cannot_be_undone">이 작업은 되돌릴 수 없습니다</string>
+  <string name="delete_warning">임시 저장된 이미지들이 영구적으로 제거됩니다</string>
+  <string name="new_photo">갤러리에서 사진 선택</string>
+  <string name="google_search">Google 검색</string>
+  <string name="use_default">기본 사진 사용</string>
+  <string name="old_photo">이전 사진 사용</string>
+  <!-- Context menu items -->
+  <string name="context_menu_play_selection">재생</string>
+  <string name="context_menu_play_next">다음 곡 재생</string>
+  <string name="context_menu_play_album">앨범 재생</string>
+  <string name="context_menu_more_by_artist">이 아티스트의 다른 곡들</string>
+  <string name="context_menu_rename_playlist">이름 바꾸기</string>
+  <string name="context_menu_delete">삭제</string>
+  <string name="context_menu_fetch_album_art">앨범 아트 받아오기</string>
+  <string name="context_menu_fetch_artist_image">아티스트 이미지 받아오기</string>
+  <string name="context_menu_remove_from_recent">최근 목록에서 제거</string>
+  <string name="context_menu_use_as_ringtone">벨소리로 지정</string>
+  <string name="context_menu_remove_from_playlist">재생목록에서 제거</string>
+  <string name="context_menu_change_image">이미지 변경</string>
+  <!-- Content descriptions -->
+  <string name="accessibility_play">재생</string>
+  <string name="accessibility_pause">일시정지</string>
+  <string name="accessibility_next">다음</string>
+  <string name="accessibility_prev">이전</string>
+  <string name="accessibility_shuffle">셔플</string>
+  <string name="accessibility_shuffle_all">모두 셔플</string>
+  <string name="accessibility_repeat">반복</string>
+  <string name="accessibility_repeat_all">모두 반복</string>
+  <string name="accessibility_repeat_one">한 곡 반복</string>
+  <string name="accessibility_queue">대기열 열기</string>
+  <string name="accessibility_browse">음악 탐색</string>
+  <!-- Toast messages -->
+  <string name="set_as_ringtone">\'<xliff:g id="name" example="Alarm Bell">%s</xliff:g>\'이(가) 벨소리로 지정되었습니다</string>
+  <string name="playlist_renamed">재생목록의 이름이 변경되었습니다</string>
+  <!-- Settings -->
+  <string name="settings_ui_category">인터페이스</string>
+  <string name="settings_storage_category">저장소</string>
+  <string name="settings_data_category">데이터</string>
+  <string name="settings_delete_cache_title">캐시 제거</string>
+  <string name="settings_delete_cache_summary">임시 저장된 모든 이미지 제거</string>
+  <string name="settings_download_only_on_wifi_title">Wi-Fi를 통해서만 다운로드</string>
+  <string name="settings_download_only_on_wifi_summary">데이터 과금을 막기 위해 모바일 네트워크를 통해 다운로드하지 않음</string>
+  <string name="settings_download_missing_artwork_title">앨범 아트가 없으면 다운로드</string>
+  <string name="settings_download_artist_images_title">아티스트 이미지가 없으면 다운로드</string>
+  <string name="settings_general_category">일반</string>
+  <string name="settings_show_music_visualization_title">음악 시각화 표시</string>
+  <string name="settings_show_lyrics_title">노래 가사 표시</string>
+  <string name="settings_show_lyrics_summary">SRT 파일이 있는 곡만</string>
+  <string name="settings_shake_to_play">흔들어 재생</string>
+  <string name="settings_shake_to_play_summary">기기를 흔들어 다음 곡을 재생</string>
+  <string name="settings_lockscreen_album_art">잠금화면 앨범 아트</string>
+  <string name="settings_lockscreen_album_art_summary">잠금화면 배경을 앨범 아트로 바꿈</string>
+  <!-- App widget -->
+  <string name="app_widget_small">음악: 4 \u00d7 1</string>
+  <string name="app_widget_large">음악: 4 \u00d7 2</string>
+  <string name="app_widget_large_alt">음악: 4 \u00d7 2 (다른 배치)</string>
+  <string name="app_widget_recent">음악: 최근에 들은 곡</string>
+  <!-- Empty list / error messages -->
+  <string name="no_effects_for_you">이퀄라이저를 열 수 없습니다.</string>
+  <string name="empty_music">컴퓨터에서 기기로 음악을 복사하려면 USB 케이블을 사용하십시오.</string>
+  <string name="empty_search">검색 결과 없음</string>
+  <string name="empty_search_check">스펠링이 정확한 지 확인해보거나, 다른 키워드를 사용해보십시오.</string>
+  <string name="empty_favorite">즐겨찾기에 추가한 음악들이 여기에 표시됩니다.</string>
+  <string name="empty_recent_main">최근에 재생된 곡 없음</string>
+  <string name="empty_recent">최근에 들은 음악들이 여기에 표시됩니다.</string>
+  <string name="empty_playlist_main">재생목록에 음악 없음</string>
+  <string name="empty_playlist_secondary">재생목록에 음악를 추가하려면 음악, 앨범, 또는 아티스트의 옵션 메뉴를 탭하여 연 뒤 \"재생목록에 추가\"를 선택하십시오.</string>
+  <string name="empty_top_tracks_main">자주 듣는 곡 없음</string>
+  <string name="empty_top_tracks_secondary">자주 듣는 음악들이 여기에 표시됩니다.</string>
+  <string name="empty_last_added_main">최근에 추가된 곡 없음</string>
+  <string name="empty_last_added">지난 한 달 동안 추가된 음악들이 여기에 표시됩니다.</string>
+  <string name="empty_generic_main">음악 없음</string>
+  <string name="empty_generic_secondary">컴퓨터에서 기기로 음악을 복사하려면 USB 케이블을 사용하십시오.</string>
+  <string name="empty_queue_main">대기열에 노래 없음</string>
+  <string name="empty_queue_secondary">노래를 재생 대기열에 추가하려면 노래, 앨범, 또는 아티스트의 옵션 메뉴를 탭하여 연 뒤 \"대기열에 추가\"를 선택하십시오.</string>
+  <string name="error_playing_track">%1$s 트랙을 재생할 수 없음</string>
+  <!-- Section Headers -->
+  <string name="header_unknown_year">알 수 없는 연도</string>
+  <string name="header_less_than_30s">30초 미만</string>
+  <string name="header_30_to_60_seconds">30-60초</string>
+  <string name="header_1_to_2_minutes">1-2분</string>
+  <string name="header_2_to_3_minutes">2-3분</string>
+  <string name="header_3_to_4_minutes">3-4분</string>
+  <string name="header_4_to_5_minutes">4-5분</string>
+  <string name="header_5_to_10_minutes">5-10분</string>
+  <string name="header_10_to_30_minutes">10-30분</string>
+  <string name="header_30_to_60_minutes">30-60분</string>
+  <string name="header_greater_than_60_minutes">60분 초과</string>
+  <string name="header_1_song">1곡의 음악</string>
+  <string name="header_2_to_4_songs">2-4곡의 음악</string>
+  <string name="header_5_to_9_songs">5-9곡의 음악</string>
+  <string name="header_10_plus_songs">10곡 이상의 음악</string>
+  <string name="header_5_plus_albums">5개 이상의 앨범</string>
+  <string name="header_other">"기타"</string>
+  <string name="footer_search_artists">모든 아티스트 보기</string>
+  <string name="footer_search_albums">모든 앨범 보기</string>
+  <string name="footer_search_songs">모든 음악 보기</string>
+  <string name="footer_search_playlists">모든 재생목록 보기</string>
+  <string name="searchHint">음악 검색</string>
+  <string name="search_title_artists">모든 \"%s\" 아티스트</string>
+  <string name="search_title_albums">모든 \"%s\" 앨범</string>
+  <string name="search_title_songs">모든 \"%s\" 음악</string>
+  <string name="search_title_playlists">모든 \"%s\" 재생목록</string>
+  <string name="duration_format"><xliff:g id="hours">%1$s</xliff:g> <xliff:g id="minutes">%2$s</xliff:g></string>
+</resources>
diff --git a/twelve/src/main/res/values-sw600dp/dimens.xml b/twelve/src/main/res/values-sw600dp/dimens.xml
new file mode 100755
index 0000000000..e5c03f9f1a
--- /dev/null
+++ b/twelve/src/main/res/values-sw600dp/dimens.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<resources>
+
+    <!-- List item detailed height -->
+    <dimen name="list_item_detailed_height">164.0dip</dimen>
+
+</resources>
\ No newline at end of file
diff --git a/twelve/src/main/res/values-v21/styles.xml b/twelve/src/main/res/values-v21/styles.xml
new file mode 100755
index 0000000000..6f89133ee0
--- /dev/null
+++ b/twelve/src/main/res/values-v21/styles.xml
@@ -0,0 +1,12 @@
+<resources>
+
+    <style name="AppTheme.NoActionBar">
+        <item name="windowActionBar">false</item>
+        <item name="windowNoTitle">true</item>
+        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
+        <item name="android:statusBarColor">@color/primary_dark</item>
+        <item name="android:windowContentTransitions">true</item>
+        <item name="android:windowAllowEnterTransitionOverlap">false</item>
+        <item name="android:windowAllowReturnTransitionOverlap">false</item>
+    </style>
+</resources>
diff --git a/twelve/src/main/res/values/appmsg_colors.xml b/twelve/src/main/res/values/appmsg_colors.xml
new file mode 100755
index 0000000000..aefef970e7
--- /dev/null
+++ b/twelve/src/main/res/values/appmsg_colors.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2012 Andrew Neal
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+<resources>
+
+    <color name="alert">@color/red</color>
+    <color name="confirm">@color/orange</color>
+    <color name="info">@color/green</color>
+
+</resources>
diff --git a/twelve/src/main/res/values/arrays.xml b/twelve/src/main/res/values/arrays.xml
new file mode 100755
index 0000000000..4109fba939
--- /dev/null
+++ b/twelve/src/main/res/values/arrays.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2012-2013 Andrew Neal
+     Copyright (C) 2012-2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+
+    <!-- Main TitlePageIndicator titles -->
+    <string-array name="page_titles" translatable="false">
+        <item>@string/page_artists</item>
+        <item>@string/page_albums</item>
+        <item>@string/page_songs</item>
+        <item>@string/page_playlists</item>
+    </string-array>
+
+</resources>
diff --git a/twelve/src/main/res/values/attrs.xml b/twelve/src/main/res/values/attrs.xml
new file mode 100755
index 0000000000..3881847d59
--- /dev/null
+++ b/twelve/src/main/res/values/attrs.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2012 Andrew Neal
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+<resources>
+    <declare-styleable name="SlidingUpPanelLayout">
+        <attr name="panelHeight" format="dimension" />
+        <attr name="slidePanelOffset" format="dimension" />
+        <attr name="shadowHeight" format="dimension" />
+        <attr name="paralaxOffset" format="dimension" />
+        <attr name="directOffset" format="boolean" />
+        <attr name="fadeColor" format="color" />
+        <attr name="flingVelocity" format="integer" />
+        <attr name="dragView" format="reference" />
+        <attr name="dragViewClickable" format="boolean" />
+        <attr name="overlay" format="boolean" />
+        <attr name="anchorPoint" format="float" />
+        <attr name="initialState" format="enum">
+            <enum name="expanded" value="0" />
+            <enum name="collapsed" value="1" />
+            <enum name="anchored" value="2" />
+            <enum name="hidden" value="3" />
+        </attr>
+    </declare-styleable>
+</resources>
diff --git a/twelve/src/main/res/values/cm_colors.xml b/twelve/src/main/res/values/cm_colors.xml
new file mode 100755
index 0000000000..c64f4d0c33
--- /dev/null
+++ b/twelve/src/main/res/values/cm_colors.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2015 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+    <!-- Background colors for LetterTileDrawables definitions. -->
+    <color name="letter_tile_purple_color">@color/purple</color>
+    <color name="letter_tile_blue_color">@color/blue</color>
+    <color name="letter_tile_indigo_color">@color/indigo</color>
+    <color name="letter_tile_teal_color">@color/teal</color>
+    <color name="letter_tile_light_green_color">@color/green</color>
+    <color name="letter_tile_red_color">@color/red</color>
+    <color name="letter_tile_grey_color">@color/grey</color>
+    <color name="letter_tile_deep_orange_color">@color/orange</color>
+    <color name="letter_tile_brown_color">@color/brown</color>
+    <color name="letter_tile_purple_color_dark">@color/purple_dark</color>
+    <color name="letter_tile_blue_color_dark">@color/blue_dark</color>
+    <color name="letter_tile_indigo_color_dark">@color/indigo_dark</color>
+    <color name="letter_tile_teal_color_dark">@color/teal_dark</color>
+    <color name="letter_tile_light_green_color_dark">@color/green_dark</color>
+    <color name="letter_tile_red_color_dark">@color/red_dark</color>
+    <color name="letter_tile_grey_color_dark">@color/grey_dark</color>
+    <color name="letter_tile_deep_orange_color_dark">@color/orange_dark</color>
+    <color name="letter_tile_brown_color_dark">@color/brown_dark</color>
+</resources>
diff --git a/twelve/src/main/res/values/colors.xml b/twelve/src/main/res/values/colors.xml
new file mode 100755
index 0000000000..83ccbad00b
--- /dev/null
+++ b/twelve/src/main/res/values/colors.xml
@@ -0,0 +1,174 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2012 Andrew Neal
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+    <!-- Material -->
+    <color name="primary">#333333</color>
+    <color name="primary_dark">#282828</color>
+    <color name="primary_light">#444444</color>
+    <color name="accent">#009688</color>
+
+    <!-- Main colors -->
+    <color name="black">#333333</color>
+    <color name="semitransparent_black">#a0333333</color>
+    <color name="white">#fafafa</color>
+    <color name="grey">#9e9e9e</color>
+    <color name="grey_dark">#616161</color>
+    <color name="purple">#9C27B0</color>
+    <color name="indigo">#673AB7</color>
+    <color name="green">#4CAF50</color>
+    <color name="red">#F44336</color>
+    <color name="orange">#FF5722</color>
+    <color name="brown">#795548</color>
+    <color name="teal">#009688</color>
+    <color name="blue">#3F51B5</color>
+    <color name="purple_dark">#7B1FA2</color>
+    <color name="indigo_dark">#512DA8</color>
+    <color name="green_dark">#388E3C</color>
+    <color name="red_dark">#D32F2F</color>
+    <color name="orange_dark">#F57C00</color>
+    <color name="brown_dark">#5D4037</color>
+    <color name="teal_dark">#00796B</color>
+    <color name="blue_dark">#303F9F</color>
+
+    <!-- Standard Text Color -->
+    <color name="default_text_color">@color/black</color>
+    <color name="default_text_color_light">@color/white</color>
+
+    <!-- Cards -->
+    <color name="cards_bg_color">#273139</color>
+    <color name="cardOne">@color/white</color>
+    <color name="cardTwo">#e0e0e0</color>
+
+    <!-- Transparent colors -->
+    <color name="transparent">#00000000</color>
+    <color name="transparent_black">#99212121</color>
+    <color name="transparent_white">#99fafafa</color>
+    <color name="transparent_blue">#993F51B5</color>
+
+    <color name="background_color">@color/white</color>
+
+    <!-- Color for the action bar -->
+    <color name="header_action_bar_color">@color/primary</color>
+    <color name="header_action_bar_text_color">#f5f5f5</color>
+    <color name="header_action_bar_text_color_active">#ffffff</color>
+    <color name="bottom_action_bar_text_color">@color/default_text_color_light</color>
+
+    <!-- Background color used on some page headers -->
+    <color name="page_header_background">@color/white</color>
+
+    <!-- Color for background for shadow on playlist page -->
+    <color name="header_shadow_color">#ea212121</color>
+
+    <!-- Color for the pop up menu -->
+    <color name="menu_divider_color">@color/transparent</color>
+    <color name="menu_text_color">@color/black</color>
+
+    <!-- List view related colors -->
+    <color name="list_item_background">#4cfafafa</color>
+    <color name="list_item_header_text_color">@color/black</color>
+    <color name="list_item_search_footer_text_color">@color/accent</color>
+    <color name="list_item_text_color">@color/default_text_color</color>
+    <color name="list_item_text_color_light">@color/default_text_color_light</color>
+    <color name="list_item_divider_color">#4c212121</color>
+    <color name="list_item_divider_color_light">#34fafafa</color>
+    <color name="grid_list_item_text_color">#b3212121</color>
+
+    <!-- Top title page colors -->
+    <color name="tab_ripple_color">@color/white</color>
+    <color name="tab_accent_color">@color/white</color>
+    <color name="tab_selected_underline_color">@color/white</color>
+
+    <!-- Search Colors -->
+    <color name="search_hint_color">@color/white</color>
+
+    <!-- Color for the text on the audio player -->
+    <color name="audio_player_text_color">@color/default_text_color_light</color>
+
+    <!-- Color for the Progress bar -->
+    <color name="circular_progress_bar_background">#40ffffff</color>
+    <color name="circular_progress_bar">@color/white</color>
+
+    <!-- search no results text color -->
+    <color name="no_results">@color/black</color>
+    <color name="no_results_light">@color/white</color>
+
+    <color name="now_playing_divider">@color/transparent</color>
+
+    <!-- App widget colors -->
+    <color name="widget_text">@color/white</color>
+
+    <!-- Background Lyrics Color -->
+    <color name="lyrics_background_color">#b2212121</color>
+
+    <!-- Letter tile colors -->
+    <color name="letter_tile_default_color">@color/grey</color>
+    <color name="letter_tile_font_color">@color/white</color>
+    <array name="letter_tile_colors">
+        <item>@color/letter_tile_purple_color</item>
+        <item>@color/letter_tile_blue_color</item>
+        <item>@color/letter_tile_indigo_color</item>
+        <item>@color/letter_tile_teal_color</item>
+        <item>@color/letter_tile_light_green_color</item>
+        <item>@color/letter_tile_red_color</item>
+        <item>@color/letter_tile_grey_color</item>
+        <item>@color/letter_tile_deep_orange_color</item>
+        <item>@color/letter_tile_brown_color</item>
+    </array>
+
+    <array name="letter_tile_vibrant_dark_colors">
+        <item>@color/letter_tile_purple_color_dark</item>
+        <item>@color/letter_tile_blue_color_dark</item>
+        <item>@color/letter_tile_indigo_color_dark</item>
+        <item>@color/letter_tile_teal_color_dark</item>
+        <item>@color/letter_tile_light_green_color_dark</item>
+        <item>@color/letter_tile_red_color_dark</item>
+        <item>@color/letter_tile_grey_color_dark</item>
+        <item>@color/letter_tile_deep_orange_color_dark</item>
+        <item>@color/letter_tile_brown_color_dark</item>
+    </array>
+
+    <!-- Color for the visualizer bars -->
+    <color name="visualizer_fill_color">#bffafafa</color>
+
+    <!-- Separated and exposed values for themes -->
+    <color name="widget_background_color">@color/black</color>
+    <color name="list_base_container_background_color">@color/white</color>
+    <color name="activity_album_detail_background_color">@color/background_color</color>
+    <color name="activity_artist_detail_background_color">@color/background_color</color>
+    <color name="activity_base_background_color">@color/background_color</color>
+    <color name="artist_detail_header_background_color">@color/background_color</color>
+    <color name="album_detail_title_text_color">@color/default_text_color</color>
+    <color name="album_detail_song_count_and_year_text_color">@color/default_text_color</color>
+    <color name="album_detail_genre_text_color">@color/default_text_color</color>
+    <color name="album_detail_duration_text_color">@color/default_text_color</color>
+    <color name="app_msg_text_color">?android:textColorPrimaryInverse</color>
+    <color name="artist_detail_album_title_text_color">@color/cardOne</color>
+    <color name="artist_detail_album_year_text_color">@color/cardTwo</color>
+    <color name="artist_detail_header_albums_label_text_color">@color/list_item_header_text_color
+    </color>
+    <color name="artist_detail_header_songs_label_text_color">@color/list_item_header_text_color
+    </color>
+    <color name="grid_items_normal_line_one">@color/cardOne</color>
+    <color name="grid_items_normal_line_two">@color/cardTwo</color>
+    <color name="position_number_color">@color/white</color>
+    <color name="audio_player_lyrics_text_color">@color/white</color>
+    <color name="audio_player_current_time_color">@color/white</color>
+    <color name="audio_player_total_time_color">@color/white</color>
+    <color name="number_of_songs_text_color">@color/white</color>
+    <color name="duration_text_color">@color/white</color>
+
+    <color name="my_color_highlight_press">@color/circular_progress_bar_background</color>
+</resources>
diff --git a/twelve/src/main/res/values/config.xml b/twelve/src/main/res/values/config.xml
new file mode 100755
index 0000000000..bc8e1d2748
--- /dev/null
+++ b/twelve/src/main/res/values/config.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2012 Andrew Neal
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+<resources>
+
+    <!-- Configures hardware acceleration -->
+    <bool name="config_hardwareAccelerated">true</bool>
+
+    <!-- Configures a larger heap size -->
+    <bool name="config_largeHeap">true</bool>
+
+</resources>
diff --git a/twelve/src/main/res/values/dimens.xml b/twelve/src/main/res/values/dimens.xml
new file mode 100755
index 0000000000..bd511190ba
--- /dev/null
+++ b/twelve/src/main/res/values/dimens.xml
@@ -0,0 +1,221 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2012 Andrew Neal
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+<resources>
+
+    <!-- Text sizes -->
+    <dimen name="text_size_extra_micro">12sp</dimen>
+    <dimen name="text_size_micro">13sp</dimen>
+    <dimen name="text_size_small">14sp</dimen>
+    <dimen name="text_size_medium">16sp</dimen>
+    <dimen name="text_size_large">22sp</dimen>
+    <dimen name="text_size_x_large">24sp</dimen>
+    <dimen name="text_size_dayum">34sp</dimen>
+
+    <!-- Frequently used spacing between elements in many layouts -->
+    <dimen name="standard_padding">16.0dp</dimen>
+
+    <!-- overflow menu used on page headers and in list items -->
+    <dimen name="overflow_height">56dp</dimen>
+    <dimen name="overflow_width">48dp</dimen>
+
+    <!-- List and grid view padding -->
+    <dimen name="list_preferred_item_padding">14.0dip</dimen>
+    <dimen name="list_menu_item_padding_right">4.0dip</dimen>
+    <dimen name="list_item_general_margin">16.0dip</dimen>
+    <dimen name="list_item_menu_button_width">24.0dip</dimen>
+    <dimen name="list_item_menu_button_height">30.0dip</dimen>
+    <dimen name="list_item_padding_top">12.0dip</dimen>
+    <dimen name="list_item_padding_bottom">12.0dip</dimen>
+    <dimen name="list_item_header_size">16.0sp</dimen>
+    <dimen name="list_item_footer_size">18.0sp</dimen>
+    <dimen name="list_item_main_text_size">@dimen/text_size_small</dimen>
+    <dimen name="list_item_secondary_text_size">@dimen/text_size_micro</dimen>
+    <dimen name="list_item_queue_text_padding_left">15.0dip</dimen>
+
+    <!-- List view fast scroll padding left -->
+    <dimen name="fast_scroll_padding_left">8dp</dimen>
+    <!-- List view fast scroll padding right -->
+    <dimen name="fast_scroll_padding_right">8dp</dimen>
+    <!-- grid view vertical and horizontal spacing -->
+    <dimen name="grid_item_horizontal_spacing">2dp</dimen>
+    <dimen name="grid_item_vertical_spacing">2dp</dimen>
+    <!-- List item detailed height -->
+    <dimen name="list_item_detailed_height">128dp</dimen>
+    <!-- Top margin of "line_two" -->
+    <dimen name="list_item_line_two_margin_top">8dp</dimen>
+    <!-- Left padding in the grid text -->
+    <dimen name="grid_item_padding_left">16dp</dimen>
+    <dimen name="grid_item_padding_right">16dp</dimen>
+    <!-- Left padding in the grid text -->
+    <dimen name="grid_bottom_height">44dip</dimen>
+    <!-- Grid and list item normal height -->
+    <dimen name="item_normal_height">70.0dip</dimen>
+    <dimen name="item_short_height">60.0dip</dimen>
+    <dimen name="list_item_image_height">50.0dip</dimen>
+    <dimen name="list_item_image_width">50.0dip</dimen>
+    <dimen name="list_item_top_track_image_size">26.0dip</dimen>
+
+    <dimen name="action_bar_elevation">4dp</dimen>
+
+    <!-- Bottom Action Bar -->
+    <dimen name="bottom_action_bar_height">50.0dip</dimen>
+    <dimen name="bottom_action_bar_item_width">56.0dip</dimen>
+    <dimen name="bottom_action_bar_item_padding_left">12.0dip</dimen>
+    <dimen name="bottom_action_bar_item_padding_right">12.0dip</dimen>
+    <dimen name="bottom_action_bar_album_art_width">30.0dip</dimen>
+    <dimen name="bottom_action_bar_album_art_height">30.0dip</dimen>
+    <dimen name="bottom_action_bar_info_padding_left">5.0dip</dimen>
+    <dimen name="bab_progress_size">35.0dip</dimen>
+    <dimen name="bab_progress_padding_left">16.0dip</dimen>
+    <dimen name="bab_progress_padding_right">22.0dip</dimen>
+
+    <!-- Notification template -->
+    <dimen name="notification_big_icon_height">64.0dip</dimen>
+    <dimen name="notification_big_icon_width">64.0dip</dimen>
+    <dimen name="notification_info_container_padding_left">8.0dip</dimen>
+    <dimen name="notification_info_container_padding_bottom">4.0dip</dimen>
+    <dimen name="notification_action_padding">8.0dip</dimen>
+    <dimen name="notification_action_height">48.0dip</dimen>
+    <dimen name="notification_action_width">48.0dip</dimen>
+
+    <!-- Notification template expanded -->
+    <dimen name="notification_expanded_height">128.0dip</dimen>
+    <dimen name="notification_expanded_buttons_divider_padding">12.0dip</dimen>
+    <dimen name="notification_expanded_button_height">48.0dip</dimen>
+    <dimen name="notification_expanded_button_padding">10.0dip</dimen>
+    <dimen name="notification_expanded_content_padding_top">8.0dip</dimen>
+    <dimen name="notification_expanded_collapse_padding">8.0dip</dimen>
+
+    <!-- Height of the shadow asset under the photo -->
+    <dimen name="profile_photo_shadow_height">10.0dip</dimen>
+    <!-- Height of the text label in the carousel -->
+    <dimen name="profile_carousel_label_height">45.0dip</dimen>
+    <dimen name="profile_indicator_height">5.0dip</dimen>
+    <dimen name="profile_label_padding">16.0dip</dimen>
+    <!-- playlist detail header -->
+    <dimen name="playlist_detail_header_height">240.0dip</dimen>
+    <dimen name="faux_playlist_detail_header_height">190.0dip</dimen>
+    <dimen name="playlist_detail_header_bottom_height">40.0dip</dimen>
+
+    <!-- Audio player Buttons (play/pause/shuffle/repeat/next/previous)-->
+    <dimen name="audio_player_controls_end_button_width">50.0dip</dimen>
+    <dimen name="audio_player_controls_end_button_height">50.0dip</dimen>
+    <dimen name="audio_player_controls_end_button_half_width">25.0dip</dimen>
+    <dimen name="audio_player_controls_end_button_padding">8.0dip</dimen>
+    <dimen name="audio_player_controls_main_button_width">100.0dip</dimen>
+    <dimen name="audio_player_controls_main_button_height">100.0dip</dimen>
+    <dimen name="audio_player_controls_top_button_width">26.0dip</dimen>
+    <dimen name="audio_player_controls_top_button_height">30.0dip</dimen>
+    <dimen name="audio_player_controls_side_width">83.0dip</dimen>
+    <dimen name="audio_player_control_padding_top">26.0dip</dimen>
+
+    <!-- Audio player track text settings-->
+    <dimen name="audio_player_track_name_padding_side">36.0dip</dimen>
+    <dimen name="audio_player_header_padding_bottom">15.0dip</dimen>
+    <dimen name="audio_player_track_text_size">14sp</dimen>
+
+    <!-- Audio player time text settings-->
+    <dimen name="audio_player_time_text_padding">3.0dip</dimen>
+    <dimen name="audio_player_time_text_size">@dimen/text_size_micro</dimen>
+
+    <dimen name="audio_player_divider_length">86.0dip</dimen>
+    <dimen name="audio_player_divider_height">1.0dip</dimen>
+    <dimen name="audio_player_divider_horizontal_offset">8.0dip</dimen>
+
+    <!-- App Widgets -->
+    <dimen name="app_widget_large_min_width">250.0dip</dimen>
+    <dimen name="app_widget_large_min_height">128.0dip</dimen>
+    <dimen name="app_widget_scrollable_min_height">180.0dip</dimen>
+    <dimen name="app_widget_scrollable_min_resize_height">110.0dip</dimen>
+    <dimen name="app_widget_large_alternate_artwork_size">80.0dip</dimen>
+    <dimen name="app_widget_small_min_width">250.0dip</dimen>
+    <dimen name="app_widget_small_min_height">40.0dip</dimen>
+    <dimen name="app_widget_small_info_container_padding_left">8.0dip</dimen>
+    <dimen name="app_widget_small_info_container_padding_right">8.0dip</dimen>
+    <dimen name="app_widget_small_artwork_size">48.0dip</dimen>
+    <dimen name="app_widget_small_button_padding">8.0dip</dimen>
+    <dimen name="app_widget_small_button_height">48.0dip</dimen>
+    <dimen name="app_widget_tiny_height">70.0dip</dimen>
+    <dimen name="app_widget_tiny_width">70.0dip</dimen>
+    <dimen name="app_widget_padding">0.0dip</dimen>
+    <dimen name="app_widget_bottom_margin">4.0dip</dimen>
+
+    <!-- Shadow height -->
+    <dimen name="shadow_height">5.0dip</dimen>
+
+    <!-- Colorstrip -->
+    <dimen name="colorstrip_height">2.0dip</dimen>
+
+    <!-- Drag and drop -->
+    <dimen name="drag_and_drop_width">20.0dip</dimen>
+    <dimen name="drag_and_drop_height">50.0dip</dimen>
+
+    <!-- Color scheme dialog -->
+    <dimen name="color_scheme_dialog_row_padding">8.0dip</dimen>
+
+    <!-- Sliding Panel -->
+    <dimen name="sliding_panel_indicator_height">20.0dip</dimen>
+    <dimen name="sliding_panel_shadow_height">0.0dip</dimen>
+
+    <!-- Header Bar -->
+    <dimen name="header_bar_height">56.0dip</dimen>
+    <dimen name="header_bar_up_width">30.0dip</dimen>
+    <dimen name="header_bar_menu_button_width">38.0dip</dimen>
+    <dimen name="header_bar_custom_button_width">48.0dip</dimen>
+    <dimen name="header_bar_button_height">48.0dip</dimen>
+    <dimen name="header_bar_button_padding_small">5.0dip</dimen>
+    <dimen name="header_bar_button_padding_large">10.0dip</dimen>
+    <dimen name="header_bar_padding_left">16.0dp</dimen>
+    <dimen name="header_bar_button_container_padding">8.0dp</dimen>
+
+    <!-- Title Page Indicator Settings -->
+    <dimen name="tpi_height">48dp</dimen>
+    <dimen name="tab_text_size">14sp</dimen>
+    <dimen name="tab_selected_underline_height">2dp</dimen>
+
+    <dimen name="list_item_progress_width">45.0dip</dimen>
+    <dimen name="list_item_progress_height">45.0dip</dimen>
+    <dimen name="list_item_progress_padding_left">10.0dip</dimen>
+    <dimen name="list_item_progress_padding_right">17.0dip</dimen>
+
+    <!-- Search Page Settings -->
+    <dimen name="white_note_width">60.0dip</dimen>
+    <dimen name="white_note_height">70.0dip</dimen>
+    <dimen name="white_note_padding_bottom">24.0dip</dimen>
+    <dimen name="no_results_width">260.0dip</dimen>
+    <dimen name="no_results_text_padding_bottom">16.0dip</dimen>
+    <dimen name="no_results_text_main">20.0sp</dimen>
+    <dimen name="no_results_text_secondary">14.0sp</dimen>
+
+    <!-- General consensus is to leave dividers at 1px instead of having different
+    partial scaled up values for different resolutions -->
+    <dimen name="divider_height">1px</dimen>
+
+    <item name="letter_to_tile_ratio" type="dimen">53%</item>
+
+    <!-- Audio preview -->
+    <dimen name="preview_layout_height">125dp</dimen>
+    <dimen name="preview_layout_seekbar_height">30dp</dimen>
+    <dimen name="preview_layout_padding">20dp</dimen>
+    <dimen name="preview_layout_margin">20dp</dimen>
+    <dimen name="preview_title_textSize">12sp</dimen>
+    <dimen name="preview_artist_textSize">10sp</dimen>
+
+    <!-- Audio Player Controls Card -->
+    <dimen name="audio_player_controls_card_corner_radius">2dp</dimen>
+    <dimen name="audio_player_controls_card_content_padding">8dp</dimen>
+    <dimen name="audio_player_controls_card_elevation">4dp</dimen>
+</resources>
diff --git a/twelve/src/main/res/values/donottranslate.xml b/twelve/src/main/res/values/donottranslate.xml
new file mode 100755
index 0000000000..77fbddb3f8
--- /dev/null
+++ b/twelve/src/main/res/values/donottranslate.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2012 Andrew Neal
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!-- Do not translate. Duration format for duration < 1 hour -->
+    <string name="durationformatshort" translatable="false"><xliff:g id="format">%2$d:%3$02d</xliff:g></string>
+    <!-- Do not translate. Duration format for duration >= 1 hour -->
+    <string name="durationformatlong" translatable="false"><xliff:g id="format">%1$d:%2$02d:%3$02d</xliff:g></string>
+    <!-- Do not translate. This provides a separator for two strings -->
+    <string name="combine_two_strings" translatable="false">%1$s | %2$s</string>
+    <string name="letter_tile_letter_font_family" translatable="false">roboto</string>
+</resources>
diff --git a/twelve/src/main/res/values/fractions.xml b/twelve/src/main/res/values/fractions.xml
new file mode 100755
index 0000000000..22e90f4561
--- /dev/null
+++ b/twelve/src/main/res/values/fractions.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2012 Andrew Neal
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+ -->
+<resources>
+
+    <item name="tab_width_screen_percentage" type="fraction">75.0%</item>
+    <item name="tab_height_screen_percentage" type="fraction">42.0%</item>
+
+</resources>
diff --git a/twelve/src/main/res/values/plurals.xml b/twelve/src/main/res/values/plurals.xml
new file mode 100755
index 0000000000..933229ea1a
--- /dev/null
+++ b/twelve/src/main/res/values/plurals.xml
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2012-2013 Andrew Neal
+     Copyright (C) 2012-2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <!-- Used to indicate the number of artists -->
+    <plurals name="Nartists">
+        <item quantity="one"><xliff:g id="count">%d</xliff:g> artist</item>
+        <item quantity="other"><xliff:g id="count">%d</xliff:g> artists</item>
+    </plurals>
+
+    <!-- Used to indicate the number of albums for an artist -->
+    <plurals name="Nalbums">
+        <item quantity="one"><xliff:g id="count">%d</xliff:g> album</item>
+        <item quantity="other"><xliff:g id="count">%d</xliff:g> albums</item>
+    </plurals>
+
+    <!-- Used to indicate the number of songs for an album -->
+    <plurals name="Nsongs">
+        <item quantity="zero"><xliff:g id="count">%d</xliff:g> songs</item>
+        <item quantity="one"><xliff:g id="count">%d</xliff:g> song</item>
+        <item quantity="other"><xliff:g id="count">%d</xliff:g> songs</item>
+    </plurals>
+
+    <!-- Used to indicate the number of genres -->
+    <plurals name="Ngenres">
+        <item quantity="one"><xliff:g id="count">%d</xliff:g> genre</item>
+        <item quantity="other"><xliff:g id="count">%d</xliff:g> genres</item>
+    </plurals>
+
+    <!-- Used to show a shortened version of hours-->
+    <plurals name="Nhours">
+        <item quantity="other"><xliff:g id="hours">%d</xliff:g>h</item>
+    </plurals>
+
+    <!-- Used to show a shortened version of minutes -->
+    <plurals name="Nminutes">
+        <item quantity="other"><xliff:g id="minutes">%d</xliff:g>m</item>
+    </plurals>
+
+    <!-- Toasts after adding song(s) to playlists -->
+    <plurals name="NNNtrackstoplaylist">
+        <item quantity="one"><xliff:g example="1" id="number">%d</xliff:g> song added to playlist.</item>
+        <item quantity="other"><xliff:g example="27" id="number">%d</xliff:g> songs added to playlist.</item>
+    </plurals>
+
+    <!-- Toasts after removing song(s) from playlists -->
+    <plurals name="NNNtracksfromplaylist">
+        <item quantity="one"><xliff:g example="1" id="number">%d</xliff:g> song removed from playlist.</item>
+        <item quantity="other"><xliff:g example="27" id="number">%d</xliff:g> songs removed from playlist.</item>
+    </plurals>
+
+    <!-- Toasts after adding song(s) to queue -->
+    <plurals name="NNNtrackstoqueue">
+        <item quantity="one"><xliff:g example="1" id="number">%d</xliff:g> song added to the queue.</item>
+        <item quantity="other"><xliff:g example="27" id="number">%d</xliff:g> songs added to the queue.</item>
+    </plurals>
+
+    <!-- Toasts after adding song(s) to the favorites list -->
+    <plurals name="NNNtrackstofavorites">
+        <item quantity="one"><xliff:g example="1" id="number">%d</xliff:g> song added to favorites.</item>
+        <item quantity="other"><xliff:g example="27" id="number">%d</xliff:g> songs added to favorites.</item>
+    </plurals>
+
+    <!-- Toast confirming that song(s) was/were deleted. -->
+    <plurals name="NNNtracksdeleted">
+        <item quantity="one"><xliff:g example="1" id="songs_to_delete">%d</xliff:g> song was deleted.</item>
+        <item quantity="other"><xliff:g id="songs_to_delete">%d</xliff:g> songs were deleted.</item>
+    </plurals>
+</resources>
diff --git a/twelve/src/main/res/values/strings.xml b/twelve/src/main/res/values/strings.xml
new file mode 100755
index 0000000000..ed35171e09
--- /dev/null
+++ b/twelve/src/main/res/values/strings.xml
@@ -0,0 +1,209 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+     Copyright (C) 2012-2013 Andrew Neal
+     Copyright (C) 2012-2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <string name="app_name">Music</string>
+
+    <!-- Page titles -->
+    <string name="page_recent">Recent</string>
+    <string name="page_artists">Artists</string>
+    <string name="page_albums">Albums</string>
+    <string name="page_songs">Songs</string>
+    <string name="page_playlists">Playlists</string>
+    <string name="page_genres">Genres</string>
+    <string name="page_now_playing">Now Playing</string>
+    <string name="page_play_queue">Play Queue</string>
+
+    <!-- Section Headers -->
+    <string name="header_albums">Albums</string>
+    <string name="header_top_songs">Top Songs</string>
+    <string name="header_all_songs">All Songs</string>
+
+    <!-- Option menu items -->
+    <string name="menu_settings">Settings</string>
+    <string name="menu_search">Search</string>
+    <string name="menu_shuffle_item">Shuffle</string>
+    <string name="menu_shuffle_all">Shuffle all</string>
+    <string name="menu_shuffle_playlist">Shuffle playlist</string>
+    <string name="menu_shuffle_album">Shuffle album</string>
+    <string name="menu_shuffle_artist">Shuffle artist</string>
+    <string name="menu_shuffle_top_tracks">Shuffle top tracks</string>
+    <string name="menu_shuffle_recent">Shuffle recently played</string>
+    <string name="menu_shuffle_last_added">Shuffle last added</string>
+    <string name="menu_play_all">Play all</string>
+    <string name="menu_sort_by">Sort by</string>
+    <string name="menu_clear_list">Clear list</string>
+    <string name="menu_clear_recents">Clear recent</string>
+    <string name="menu_clear_queue">Clear queue</string>
+    <string name="menu_save_queue">Save queue to playlist</string>
+    <string name="menu_equalizer">Equalizer</string>
+
+    <!-- Playlist items -->
+    <string name="add_to_playlist">Add to playlist</string>
+    <string name="add_to_queue">Add to queue</string>
+    <string name="remove_from_recent">Remove from recent</string>
+    <string name="remove_from_queue">Remove from queue</string>
+
+    <!-- Sort orders -->
+    <string name="sort_order_entry_az">A-Z</string>
+    <string name="sort_order_entry_za">Z-A</string>
+    <string name="sort_order_entry_artist">Artist</string>
+    <string name="sort_order_entry_album">Album</string>
+    <string name="sort_order_entry_year">Year</string>
+    <string name="sort_order_entry_duration">Duration</string>
+    <string name="sort_order_entry_date_added">Date added</string>
+    <string name="sort_order_entry_track_list">Track list</string>
+    <string name="sort_order_entry_number_of_songs">Number of songs</string>
+    <string name="sort_order_entry_number_of_albums">Number of albums</string>
+    <string name="sort_order_entry_filename">Filename</string>
+
+    <!-- Default playlist names -->
+    <string name="playlist_last_added">Last added</string>
+    <string name="playlist_recently_played">Recently played</string>
+    <string name="playlist_top_tracks">My top tracks</string>
+
+    <!-- AlertDialog items -->
+    <string name="new_playlist">New playlist</string>
+    <string name="save">Save</string>
+    <string name="cancel">Cancel</string>
+    <string name="overwrite">Overwrite</string>
+    <string name="clear">Clear</string>
+    <string name="new_playlist_name_template">Playlist <xliff:g id="number">%d</xliff:g></string>
+    <string name="create_playlist_prompt">Playlist name</string>
+    <string name="delete_dialog_title">Delete <xliff:g example="album" id="item">%s</xliff:g>?</string>
+    <string name="clear_top_tracks_title">Clear top tracks?</string>
+    <string name="clear_recent_title">Clear recently played?</string>
+    <string name="clear_last_added">Clear last added?</string>
+    <string name="cannot_be_undone">This cannot be undone</string>
+    <string name="delete_warning">This will permanently delete the cached image entries</string>
+    <string name="new_photo">Choose photo from Gallery</string>
+    <string name="google_search">Google search</string>
+    <string name="use_default">Use default photo</string>
+    <string name="old_photo">Use old photo</string>
+
+    <!-- Context menu items -->
+    <string name="context_menu_play_selection">Play</string>
+    <string name="context_menu_play_next">Play next</string>
+    <string name="context_menu_play_album">Play album</string>
+    <string name="context_menu_more_by_artist">More by artist</string>
+    <string name="context_menu_rename_playlist">Rename</string>
+    <string name="context_menu_delete">Delete</string>
+    <string name="context_menu_fetch_album_art">Fetch album art</string>
+    <string name="context_menu_fetch_artist_image">Fetch artist image</string>
+    <string name="context_menu_remove_from_recent">Remove from recent</string>
+    <string name="context_menu_use_as_ringtone">Use as ringtone</string>
+    <string name="context_menu_remove_from_playlist">Remove from playlist</string>
+    <string name="context_menu_change_image">Change image</string>
+
+    <!-- Content descriptions -->
+    <string name="accessibility_play">Play</string>
+    <string name="accessibility_pause">Pause</string>
+    <string name="accessibility_next">Next</string>
+    <string name="accessibility_prev">Previous</string>
+    <string name="accessibility_shuffle">Shuffle</string>
+    <string name="accessibility_shuffle_all">Shuffle all</string>
+    <string name="accessibility_repeat">Repeat</string>
+    <string name="accessibility_repeat_all">Repeat all</string>
+    <string name="accessibility_repeat_one">Repeat one</string>
+    <string name="accessibility_queue">Open queue</string>
+    <string name="accessibility_browse">Browse music</string>
+
+    <!-- Toast messages -->
+    <string name="set_as_ringtone">\'<xliff:g example="Alarm Bell" id="name">%s</xliff:g>\' set as ringtone</string>
+    <string name="playlist_renamed">Playlist renamed</string>
+
+    <!-- Settings -->
+    <string name="settings_ui_category">Interface</string>
+    <string name="settings_storage_category">Storage</string>
+    <string name="settings_data_category">Data</string>
+    <string name="settings_delete_cache_title">Delete cache</string>
+    <string name="settings_delete_cache_summary">Remove all cached images</string>
+    <string name="settings_download_only_on_wifi_title">Download via Wi-Fi only</string>
+    <string name="settings_download_only_on_wifi_summary">To reduce carrier charges, don\'t download over mobile networks</string>
+    <string name="settings_download_missing_artwork_title">Download missing album art</string>
+    <string name="settings_download_artist_images_title">Download missing artist images</string>
+    <string name="settings_general_category">General</string>
+    <string name="settings_show_music_visualization_title">Show music visualization</string>
+    <string name="settings_show_lyrics_title">Show song lyrics</string>
+    <string name="settings_show_lyrics_summary">For songs that have an srt file</string>
+    <string name="settings_shake_to_play">Shake to Play</string>
+    <string name="settings_shake_to_play_summary">Shake your device to play next song</string>
+    <string name="settings_lockscreen_album_art">Lockscreen album art</string>
+    <string name="settings_lockscreen_album_art_summary">Replace lockscreen background with album art</string>
+
+    <!-- App widget -->
+    <string name="app_widget_small">Music: 4 \u00d7 1</string>
+    <string name="app_widget_large">Music: 4 \u00d7 2</string>
+    <string name="app_widget_large_alt">Music: 4 \u00d7 2 (alternate)</string>
+    <string name="app_widget_recent">Music: recently listened</string>
+    <string name="app_widget_text_separator" translatable="false">-</string>
+
+    <!-- Empty list / error messages -->
+    <string name="no_effects_for_you">The equalizer could not be opened.</string>
+    <string name="empty_music">To copy music from your computer to your device, use a USB cable.</string>
+    <string name="empty_search">No search results found</string>
+    <string name="empty_search_check">Please check that you have the correct spelling or try a different keyword.</string>
+    <string name="empty_favorite">Songs you mark as favorites will be shown here.</string>
+    <string name="empty_recent_main">No recent songs</string>
+    <string name="empty_recent">Songs you have listened to recently will show up here.</string>
+    <string name="empty_playlist_main">No songs in playlist</string>
+    <string name="empty_playlist_secondary">To add songs to this playlist, tap the options menu on a song, album or artist and select \"Add to playlist\".</string>
+    <string name="empty_top_tracks_main">No top tracks</string>
+    <string name="empty_top_tracks_secondary">The songs you listen to most will be added to this list.</string>
+    <string name="empty_last_added_main">No songs added recently</string>
+    <string name="empty_last_added">Songs you have added over the last month will be shown here.</string>
+    <string name="empty_generic_main">No music found</string>
+    <string name="empty_generic_secondary">To copy music from your computer to your device, use a USB cable.</string>
+    <string name="empty_queue_main">No songs in play queue</string>
+    <string name="empty_queue_secondary">To add songs to your Play Queue, tap the options menu on a song, album, or artist and select \"Add to queue\".</string>
+    <string name="error_playing_track">Unable to play track %1$s</string>
+
+    <!-- Section Headers -->
+    <string name="header_unknown_year">Unknown year</string>
+    <string name="header_less_than_30s">Less than 30 seconds</string>
+    <string name="header_30_to_60_seconds">30 - 60 seconds</string>
+    <string name="header_1_to_2_minutes">1 - 2 minutes</string>
+    <string name="header_2_to_3_minutes">2 - 3 minutes</string>
+    <string name="header_3_to_4_minutes">3 - 4 minutes</string>
+    <string name="header_4_to_5_minutes">4 - 5 minutes</string>
+    <string name="header_5_to_10_minutes">5 - 10 minutes</string>
+    <string name="header_10_to_30_minutes">10 - 30 minutes</string>
+    <string name="header_30_to_60_minutes">30 - 60 minutes</string>
+    <string name="header_greater_than_60_minutes">More than 60 minutes</string>
+
+    <string name="header_1_song">1 song</string>
+    <string name="header_2_to_4_songs">2 - 4 songs</string>
+    <string name="header_5_to_9_songs">5 - 9 songs</string>
+    <string name="header_10_plus_songs">10+ songs</string>
+
+    <string name="header_5_plus_albums">5+ albums</string>
+
+    <string name="header_other">"Other"</string>
+
+    <string name="footer_search_artists">Show all artists</string>
+    <string name="footer_search_albums">Show all albums</string>
+    <string name="footer_search_songs">Show all songs</string>
+    <string name="footer_search_playlists">Show all playlists</string>
+
+    <string name="searchHint">Search music</string>
+    <string name="search_title_artists">All \"%s\" artists</string>
+    <string name="search_title_albums">All \"%s\" albums</string>
+    <string name="search_title_songs">All \"%s\" songs</string>
+    <string name="search_title_playlists">All \"%s\" playlists</string>
+
+    <string name="duration_format"><xliff:g id="hours">%1$s</xliff:g> <xliff:g id="minutes">%2$s</xliff:g></string>
+</resources>
diff --git a/twelve/src/main/res/values/styles.xml b/twelve/src/main/res/values/styles.xml
new file mode 100755
index 0000000000..179badefa4
--- /dev/null
+++ b/twelve/src/main/res/values/styles.xml
@@ -0,0 +1,196 @@
+<?xml version="1.0" encoding="utf-8"?><!-- Copyright (C) 2012 Andrew Neal
+     Copyright (C) 2014 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
+    <!-- Main Material -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
+        <item name="android:windowContentOverlay">@null</item>
+        <item name="android:popupMenuStyle">@style/PopupMenu</item>
+        <item name="android:dropDownListViewStyle">@style/DropDownListView</item>
+        <item name="android:textAppearanceSmallPopupMenu">@style/SmallPopupMenu</item>
+        <item name="android:textAppearanceLargePopupMenu">@style/LargePopupMenu</item>
+        <item name="android:listViewStyle">@style/ListView</item>
+        <item name="android:actionBarStyle">@style/ActionBar</item>
+        <item name="android:actionBarWidgetTheme">@style/ActionBarWidgetTheme</item>
+        <item name="colorPrimary">@color/primary</item>
+        <item name="colorPrimaryDark">@color/primary_dark</item>
+        <item name="colorAccent">@color/accent</item>
+        <item name="android:windowNoTitle">true</item>
+        <item name="android:windowActionBar">false</item>
+    </style>
+
+    <style name="ActionBarWidgetTheme">
+        <!-- This is the color of the search text hint in the action bar -->
+        <item name="android:textColorHint">@color/search_hint_color</item>
+        <item name="android:popupMenuStyle">@style/PopupMenu</item>
+        <item name="android:dropDownListViewStyle">@style/DropDownListView</item>
+        <item name="android:textAppearanceSmallPopupMenu">@style/SmallPopupMenu</item>
+        <item name="android:textAppearanceLargePopupMenu">@style/LargePopupMenu</item>
+        <!-- Empty icon -->
+        <item name="android:icon">@android:color/transparent</item>
+    </style>
+
+    <!-- Make the action bar not take up space -->
+    <style name="AppTheme.NoActionBar">
+        <item name="android:windowNoTitle">true</item>
+        <item name="android:windowActionBar">false</item>
+    </style>
+
+    <!-- Set the default list view divider color and size -->
+    <style name="ListView" parent="Widget.AppCompat.ListView">
+        <item name="android:divider">@color/list_item_divider_color</item>
+        <item name="android:dividerHeight">@dimen/divider_height</item>
+    </style>
+
+    <style name="PopupMenu" parent="Widget.AppCompat.PopupMenu" />
+
+    <style name="DropDownListView" parent="Widget.AppCompat.ListView.DropDown" />
+
+    <!-- Sets up the pop up menu text color and size -->
+    <style name="SmallPopupMenu" parent="TextAppearance.AppCompat.Widget.PopupMenu.Small">
+        <item name="android:textColor">@color/menu_text_color</item>
+        <item name="android:textSize">@dimen/text_size_medium</item>
+    </style>
+
+    <!-- Sets up the pop up menu text color and size -->
+    <style name="LargePopupMenu" parent="TextAppearance.AppCompat.Widget.PopupMenu.Large">
+        <item name="android:textColor">@color/menu_text_color</item>
+        <item name="android:textSize">@dimen/text_size_medium</item>
+    </style>
+
+    <!-- Sets the action bar title text style -->
+    <style name="ActionBar" parent="Widget.AppCompat.ActionBar">
+        <item name="android:background">@color/header_action_bar_color</item>
+    </style>
+
+    <!-- Sets the action bar menu icon -->
+    <style name="ActionOverFlowButton" parent="Widget.AppCompat.ActionButton.Overflow">
+        <item name="android:src">@drawable/menu_button_light</item>
+        <item name="android:minWidth">0dip</item>
+        <item name="android:paddingLeft">8dip</item>
+        <item name="android:paddingRight">8dip</item>
+    </style>
+
+    <!-- The list item main text style/color -->
+    <style name="ListItemMainText">
+        <item name="android:textColor">@color/list_item_text_color</item>
+        <item name="android:textSize">@dimen/list_item_main_text_size</item>
+        <item name="android:textStyle">bold</item>
+        <item name="android:ellipsize">end</item>
+    </style>
+
+    <style name="ListItemMainText.Single" parent="ListItemMainText">
+        <item name="android:singleLine">true</item>
+    </style>
+
+    <style name="ListItemMainText.Grid.Single" parent="ListItemMainText.Single">
+        <item name="android:textSize">@dimen/text_size_micro</item>
+        <item name="android:textColor">@color/grid_list_item_text_color</item>
+    </style>
+
+    <!-- The list item secondary text style/color -->
+    <style name="ListItemSecondaryText">
+        <item name="android:textColor">@color/list_item_text_color</item>
+        <item name="android:textSize">@dimen/list_item_secondary_text_size</item>
+        <item name="android:textStyle">normal</item>
+        <item name="android:ellipsize">end</item>
+    </style>
+
+    <style name="ListItemSecondaryText.Single" parent="ListItemSecondaryText">
+        <item name="android:singleLine">true</item>
+    </style>
+
+    <style name="ListItemSecondaryText.Grid.Single" parent="ListItemSecondaryText.Single">
+        <item name="android:textSize">@dimen/text_size_extra_micro</item>
+        <item name="android:textColor">@color/grid_list_item_text_color</item>
+    </style>
+
+    <style name="ListItemMainText.Light.Single" parent="ListItemMainText.Single">
+        <item name="android:textColor">@color/list_item_text_color_light</item>
+    </style>
+
+    <style name="ListItemSecondaryText.Light.Single" parent="ListItemSecondaryText.Single">
+        <item name="android:textColor">@color/list_item_text_color_light</item>
+    </style>
+
+    <!-- Shortcut Activity theme -->
+    <style name="Theme.Transparent" parent="Theme.AppCompat.NoActionBar">
+        <item name="android:windowIsTranslucent">true</item>
+        <item name="android:windowBackground">@color/transparent</item>
+        <item name="android:windowContentOverlay">@null</item>
+        <item name="android:windowNoTitle">true</item>
+        <item name="android:windowIsFloating">true</item>
+        <item name="android:backgroundDimEnabled">false</item>
+    </style>
+
+    <style name="Theme.AudioPreview" parent="Theme.AppCompat.NoActionBar">
+        <item name="android:windowIsTranslucent">true</item>
+        <item name="android:windowBackground">@color/transparent</item>
+        <item name="android:windowNoTitle">true</item>
+        <item name="android:windowContentOverlay">@null</item>
+        <item name="android:backgroundDimEnabled">true</item>
+    </style>
+
+    <!-- Notification bar event text -->
+    <style name="NotificationText">
+        <item name="android:layout_width">match_parent</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:ellipsize">end</item>
+        <item name="android:fadingEdge">horizontal</item>
+        <item name="android:singleLine">true</item>
+        <item name="android:textColor">#212121</item>
+    </style>
+
+    <!-- Bottom Action Bar TextViews -->
+    <style name="BottomActionBarText">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:ellipsize">end</item>
+        <item name="android:paddingLeft">5dp</item>
+        <item name="android:paddingRight">16dp</item>
+        <item name="android:gravity">top|left|center</item>
+        <item name="android:singleLine">true</item>
+        <item name="android:textColor">@color/bottom_action_bar_text_color</item>
+    </style>
+
+    <style name="BottomActionBarLineOne" parent="@style/BottomActionBarText">
+        <item name="android:textStyle">bold</item>
+        <item name="android:textSize">@dimen/text_size_small</item>
+    </style>
+
+    <style name="BottomActionBarLineTwo" parent="@style/BottomActionBarText">
+        <item name="android:textSize">@dimen/text_size_extra_micro</item>
+    </style>
+
+    <!-- Bottom Action Bar Image Buttons -->
+    <style name="BottomActionBarItem">
+        <item name="android:layout_weight">1</item>
+        <item name="android:layout_width">0dp</item>
+        <item name="android:layout_height">match_parent</item>
+        <item name="android:gravity">center|right</item>
+        <item name="android:paddingLeft">@dimen/bottom_action_bar_item_padding_left</item>
+        <item name="android:paddingRight">@dimen/bottom_action_bar_item_padding_right</item>
+        <item name="android:scaleType">centerInside</item>
+    </style>
+
+    <style name="HeaderTabTextStyle" parent="Widget.AppCompat.ActionBar.TabText">
+        <item name="android:textColor">@color/tab_text_color</item>
+        <item name="android:textSize">@dimen/tab_text_size</item>
+    </style>
+
+    <style name="ToolBarTheme" parent="ThemeOverlay.AppCompat.Dark.ActionBar" />
+
+    <style name="ToolBarPopupTheme" parent="Theme.AppCompat.Light" />
+</resources>
diff --git a/twelve/src/main/res/values/values.xml b/twelve/src/main/res/values/values.xml
new file mode 100755
index 0000000000..5b0ad3a10a
--- /dev/null
+++ b/twelve/src/main/res/values/values.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <!-- Circular Progress Bar Sizes -->
+    <item name="circular_progress_bar_inner_radius_ratio" format="float" type="dimen">3</item>
+    <item name="circular_progress_bar_thickness_ratio" format="float" type="dimen">10</item>
+</resources>
\ No newline at end of file
diff --git a/twelve/src/main/res/xml/app_widget_large.xml b/twelve/src/main/res/xml/app_widget_large.xml
new file mode 100755
index 0000000000..c1ac662411
--- /dev/null
+++ b/twelve/src/main/res/xml/app_widget_large.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
+    android:initialLayout="@layout/app_widget_large"
+    android:minHeight="@dimen/app_widget_large_min_height"
+    android:minWidth="@dimen/app_widget_large_min_width"
+    android:updatePeriodMillis="0"
+    android:widgetCategory="home_screen" />
diff --git a/twelve/src/main/res/xml/app_widget_large_alternate.xml b/twelve/src/main/res/xml/app_widget_large_alternate.xml
new file mode 100755
index 0000000000..a1eb706cc7
--- /dev/null
+++ b/twelve/src/main/res/xml/app_widget_large_alternate.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
+    android:initialLayout="@layout/app_widget_large_alternate"
+    android:minHeight="@dimen/app_widget_large_min_height"
+    android:minWidth="@dimen/app_widget_large_min_width"
+    android:updatePeriodMillis="0"
+    android:widgetCategory="home_screen" />
diff --git a/twelve/src/main/res/xml/app_widget_small.xml b/twelve/src/main/res/xml/app_widget_small.xml
new file mode 100755
index 0000000000..4d6a38f60a
--- /dev/null
+++ b/twelve/src/main/res/xml/app_widget_small.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
+    android:initialLayout="@layout/app_widget_small"
+    android:minHeight="@dimen/app_widget_small_min_height"
+    android:minWidth="@dimen/app_widget_small_min_width"
+    android:updatePeriodMillis="0"
+    android:widgetCategory="home_screen" />
\ No newline at end of file
diff --git a/twelve/src/main/res/xml/searchable.xml b/twelve/src/main/res/xml/searchable.xml
new file mode 100755
index 0000000000..2d819e1a2c
--- /dev/null
+++ b/twelve/src/main/res/xml/searchable.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<searchable xmlns:android="http://schemas.android.com/apk/res/android"
+    android:imeOptions="actionSearch"
+    android:label="@string/menu_search"
+    android:searchSuggestIntentAction="android.intent.action.SEARCH"
+    android:searchSuggestSelection=" ? "
+    android:searchSuggestThreshold="2"
+    android:voiceSearchMode="showVoiceSearchButton|launchRecognizer">
+
+</searchable>
\ No newline at end of file
diff --git a/twelve/src/main/res/xml/settings.xml b/twelve/src/main/res/xml/settings.xml
new file mode 100755
index 0000000000..0b0228984a
--- /dev/null
+++ b/twelve/src/main/res/xml/settings.xml
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  Copyright (C) 2012 Andrew Neal
+  Copyright (C) 2014 The CyanogenMod Project
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <!-- Data catetory -->
+    <!--<PreferenceCategory android:title="@string/settings_data_category" >-->
+
+    <!--&lt;!&ndash; Only on Wi-Fi &ndash;&gt;-->
+    <!--<CheckBoxPreference-->
+    <!--android:defaultValue="true"-->
+    <!--android:key="only_on_wifi"-->
+    <!--android:summary="@string/settings_download_only_on_wifi_summary"-->
+    <!--android:title="@string/settings_download_only_on_wifi_title" />-->
+    <!--&lt;!&ndash; Missing artwork &ndash;&gt;-->
+    <!--<CheckBoxPreference-->
+    <!--android:defaultValue="true"-->
+    <!--android:key="download_missing_artwork"-->
+    <!--android:title="@string/settings_download_missing_artwork_title" />-->
+    <!--&lt;!&ndash; Missing artist images &ndash;&gt;-->
+    <!--<CheckBoxPreference-->
+    <!--android:defaultValue="true"-->
+    <!--android:key="download_missing_artist_images"-->
+    <!--android:title="@string/settings_download_artist_images_title" />-->
+    <!--</PreferenceCategory>-->
+    <PreferenceCategory android:title="@string/settings_general_category">
+
+        <!-- Music visualizer -->
+        <SwitchPreference
+            android:defaultValue="true"
+            android:key="music_visualization"
+            android:title="@string/settings_show_music_visualization_title" />
+
+        <!-- Show Lyrics -->
+        <SwitchPreference
+            android:defaultValue="true"
+            android:key="show_lyrics"
+            android:summary="@string/settings_show_lyrics_summary"
+            android:title="@string/settings_show_lyrics_title" />
+
+        <!-- Shake to switch songs -->
+        <SwitchPreference
+            android:defaultValue="false"
+            android:key="shake_to_play"
+            android:summary="@string/settings_shake_to_play_summary"
+            android:title="@string/settings_shake_to_play" />
+
+        <!-- Show album art on lockscreen -->
+        <SwitchPreference
+            android:defaultValue="true"
+            android:key="lockscreen_album_art"
+            android:summary="@string/settings_lockscreen_album_art_summary"
+            android:title="@string/settings_lockscreen_album_art" />
+    </PreferenceCategory>
+    <!-- Storage catetory -->
+    <PreferenceCategory android:title="@string/settings_storage_category">
+
+        <!-- Delete cache -->
+        <Preference
+            android:key="delete_cache"
+            android:summary="@string/settings_delete_cache_summary"
+            android:title="@string/settings_delete_cache_title" />
+    </PreferenceCategory>
+</PreferenceScreen>
diff --git a/twelve/src/test/java/com/dolzzo/twelve/ExampleUnitTest.java b/twelve/src/test/java/com/dolzzo/twelve/ExampleUnitTest.java
new file mode 100755
index 0000000000..be5a89e95d
--- /dev/null
+++ b/twelve/src/test/java/com/dolzzo/twelve/ExampleUnitTest.java
@@ -0,0 +1,17 @@
+package com.dolzzo.twelve;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
