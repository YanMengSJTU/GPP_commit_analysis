diff --git a/demo_misc/vp9_opus_sw/build.gradle b/demo_misc/vp9_opus_sw/build.gradle
index 5b6eac3ab3..d466aa26a7 100644
--- a/demo_misc/vp9_opus_sw/build.gradle
+++ b/demo_misc/vp9_opus_sw/build.gradle
@@ -26,6 +26,10 @@ android {
             minifyEnabled false
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
         }
+        debug {
+            jniDebuggable = true
+            debuggable = true
+        }
     }
 
     lintOptions {
@@ -37,4 +41,5 @@ dependencies {
     compile project(':library')
     compile project(':extension-opus')
     compile project(':extension-vp9')
+    compile project(':extension-flac')
 }
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
index f37f3f92c3..ddd3ddc73e 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
+++ b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/PlayerActivity.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer.ExoPlaybackException;
 import com.google.android.exoplayer.ExoPlayer;
 import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.ext.flac.LibflacAudioTrackRenderer;
 import com.google.android.exoplayer.ext.opus.LibopusAudioTrackRenderer;
 import com.google.android.exoplayer.ext.vp9.LibvpxVideoTrackRenderer;
 import com.google.android.exoplayer.ext.vp9.VpxDecoderException;
@@ -129,7 +130,7 @@ public void onPause() {
   }
 
   private void startBasicPlayback() {
-    player = ExoPlayer.Factory.newInstance(2);
+    player = ExoPlayer.Factory.newInstance(3);
     player.addListener(this);
     mediaController.setMediaPlayer(new PlayerControl(player));
     mediaController.setEnabled(true);
@@ -150,8 +151,10 @@ private void startBasicPlayback() {
           surfaceView.getHolder().getSurface());
       vpxVideoSurfaceView.setVisibility(View.GONE);
     }
-    TrackRenderer audioRenderer = new LibopusAudioTrackRenderer(sampleSource);
-    player.prepare(videoRenderer, audioRenderer);
+    TrackRenderer opusAudioTrackRenderer = new LibopusAudioTrackRenderer(sampleSource);
+    TrackRenderer flacAudioTrackRenderer = new LibflacAudioTrackRenderer(sampleSource);
+
+    player.prepare(videoRenderer, opusAudioTrackRenderer, flacAudioTrackRenderer);
     player.setPlayWhenReady(true);
   }
 
diff --git a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java
index adf0ba1e31..722f485acc 100644
--- a/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java
+++ b/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/SampleChooserActivity.java
@@ -44,6 +44,7 @@ public void onCreate(Bundle savedInstanceState) {
     ListView sampleList = (ListView) findViewById(R.id.sample_list);
     final SampleAdapter sampleAdapter = new SampleAdapter(this);
 
+
     sampleAdapter.add(new Header("DASH - VP9 Only"));
     sampleAdapter.add(new Sample("Google Glass",
         "http://demos.webmproject.org/dash/201410/vp9_glass/manifest_vp9.mpd",
diff --git a/extensions/flac/README.md b/extensions/flac/README.md
new file mode 100644
index 0000000000..0a911412a6
--- /dev/null
+++ b/extensions/flac/README.md
@@ -0,0 +1,86 @@
+# ExoPlayer Flac Extension
+
+## Description
+
+The Flac Extension is a [TrackRenderer][] implementation that helps you bundle
+libFLAC (the Flac decoding library) into your app and use it along with
+ExoPlayer to play Flac audio on Android devices.
+
+[TrackRenderer]: https://google.github.io/ExoPlayer/doc/reference/com/google/android/exoplayer/TrackRenderer.html
+
+## Build Instructions (Android Studio and Eclipse)
+
+Building the Flac Extension involves building libFLAC and JNI bindings using the
+Android NDK and linking it into your app. The following steps will tell you how
+to do that using Android Studio or Eclipse.
+
+*   Checkout ExoPlayer along with Extensions
+
+```
+git clone https://github.com/google/ExoPlayer.git
+```
+
+*   Set the following environment variables:
+
+```
+cd "<path to exoplayer checkout>"
+EXOPLAYER_ROOT="$(pwd)"
+FLAC_EXT_PATH="${EXOPLAYER_ROOT}/extensions/flac/src/main"
+```
+
+*   Download the [Android NDK][] and set its location in an environment
+    variable:
+
+```
+NDK_PATH="<path to Android NDK>"
+```
+
+*   Download and extract flac-1.3.1 as "${FLAC_EXT_PATH}/jni/flac" folder `curl
+    http://downloads.xiph.org/releases/flac/flac-1.3.1.tar.xz | tar xJ && \ mv
+    flac-1.3.1 flac`
+
+### Android Studio
+
+For Android Studio, we build the native libraries from the command line and then
+Gradle will pick it up when building your app using Android Studio.
+
+*   Build the JNI native libraries
+
+```
+cd "${FLAC_EXT_PATH}"/jni && \
+${NDK_PATH}/ndk-build APP_ABI=all -j4
+```
+
+*   In your project, you can add a dependency to the Flac Extension by using a
+    rule like this:
+
+```
+// in settings.gradle
+include ':..:ExoPlayer:library'
+include ':..:ExoPlayer:extension-flac'
+
+// in build.gradle
+dependencies {
+    compile project(':..:ExoPlayer:library')
+    compile project(':..:ExoPlayer:extension-flac')
+}
+```
+
+*   Now, when you build your app, the Flac extension will be built and the
+    native libraries will be packaged along with the APK.
+
+### Eclipse
+
+To be completed...
+
+## Building for various Architectures
+
+### Android Studio
+
+The manual invocation of `ndk-build` will build the library for all
+architectures and the correct one will be picked up from the APK based on the
+device its running on.
+
+### Eclipse
+
+To be completed...
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
new file mode 100644
index 0000000000..e170263d74
--- /dev/null
+++ b/extensions/flac/build.gradle
@@ -0,0 +1,45 @@
+// Copyright (C) 2016 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion 23
+    buildToolsVersion "23.0.1"
+
+    defaultConfig {
+        minSdkVersion 9
+        targetSdkVersion 23
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        abortOnError false
+    }
+
+    sourceSets.main {
+        jniLibs.srcDir 'src/main/libs'
+        jni.srcDirs = [] // Disable the automatic ndk-build call by Android Studio.
+    }
+}
+
+dependencies {
+    compile project(':library')
+}
+
diff --git a/extensions/flac/src/main/AndroidManifest.xml b/extensions/flac/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..1a075c0948
--- /dev/null
+++ b/extensions/flac/src/main/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer.ext.flac">
+
+    <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="23"/>
+
+</manifest>
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
new file mode 100644
index 0000000000..1afa7bcbed
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.SampleHolder;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.Decoder;
+import com.google.android.exoplayer.util.extensions.DecoderWrapper;
+import com.google.android.exoplayer.util.extensions.InputBuffer;
+
+import java.nio.ByteBuffer;
+import java.util.List;
+
+/**
+ * JNI wrapper for the libflac Flac decoder.
+ */
+/* package */ final class FlacDecoder implements Decoder<InputBuffer, FlacOutputBuffer,
+    FlacDecoderException> {
+
+  /**
+   * Whether the underlying libflac library is available.
+   */
+  public static final boolean IS_AVAILABLE;
+  static {
+    boolean isAvailable;
+    try {
+      System.loadLibrary("flacJNI");
+      isAvailable = true;
+    } catch (UnsatisfiedLinkError exception) {
+      isAvailable = false;
+    }
+    IS_AVAILABLE = isAvailable;
+  }
+
+  public final int maxFrameSize;
+
+  private final int maxOutputBufferSize;
+
+  private final long nativeDecoderContext;
+
+  private FlacDecoderException exception;
+
+  public FlacDecoder(List<byte[]> initializationData) throws FlacDecoderException {
+    if (initializationData.size() != 1) {
+      throw new FlacDecoderException("Wrong number of initialization data");
+    }
+
+    nativeDecoderContext = flacInit();
+    if (nativeDecoderContext == 0) {
+      throw new FlacDecoderException("Failed to initialize decoder");
+    }
+
+    byte[] data = initializationData.get(0);
+    boolean decoded = flacDecodeMetadata(nativeDecoderContext, data);
+    if (!decoded) {
+      throw new FlacDecoderException("Metadata decoding failed");
+    }
+
+    maxFrameSize = flacGetMaxFrameSize(nativeDecoderContext);
+    maxOutputBufferSize = flacGetMaxOutputBufferSize(nativeDecoderContext);
+  }
+
+  @Override
+  public InputBuffer createInputBuffer(int initialSize) {
+    return new InputBuffer(initialSize);
+  }
+
+  @Override
+  public FlacOutputBuffer createOutputBuffer(
+      DecoderWrapper<InputBuffer, FlacOutputBuffer, FlacDecoderException> owner) {
+    return new FlacOutputBuffer(owner);
+  }
+
+  @Override
+  public boolean decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer) {
+    outputBuffer.reset();
+    if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
+      outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
+      return true;
+    }
+    if (inputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
+      outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
+    }
+    SampleHolder sampleHolder = inputBuffer.sampleHolder;
+    outputBuffer.timestampUs = sampleHolder.timeUs;
+    sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
+    outputBuffer.init(maxOutputBufferSize);
+    int result = flacDecode(nativeDecoderContext, sampleHolder.data, sampleHolder.size,
+        outputBuffer.data, outputBuffer.data.capacity());
+    if (result < 0) {
+      exception = new FlacDecoderException("Frame decoding failed");
+      return false;
+    }
+    outputBuffer.data.position(0);
+    outputBuffer.data.limit(result);
+    return true;
+  }
+
+  @Override
+  public void maybeThrowException() throws FlacDecoderException {
+    if (exception != null) {
+      throw exception;
+    }
+  }
+
+  @Override
+  public void release() {
+    flacClose(nativeDecoderContext);
+  }
+
+  private native long flacInit();
+
+  private native boolean flacDecodeMetadata(long context, byte[] input);
+
+  private native int flacDecode(long context, ByteBuffer inputBuffer, int inputSize,
+      ByteBuffer outputBuffer, int outputSize);
+
+  private native void flacClose(long context);
+
+  private native int flacGetMaxOutputBufferSize(long context);
+
+  private native int flacGetMaxFrameSize(long context);
+}
+
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoderException.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoderException.java
new file mode 100644
index 0000000000..8aeb564bea
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoderException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+/**
+ * Thrown when an Flac decoder error occurs.
+ */
+public final class FlacDecoderException extends Exception {
+
+  /* package */ FlacDecoderException(String message) {
+    super(message);
+  }
+
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java
new file mode 100644
index 0000000000..3e3c2a2e5d
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacOutputBuffer.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.util.extensions.DecoderWrapper;
+import com.google.android.exoplayer.util.extensions.OutputBuffer;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Buffer for {@link FlacDecoder} output.
+ */
+public final class FlacOutputBuffer extends OutputBuffer {
+
+  private final DecoderWrapper<?, FlacOutputBuffer, ?> owner;
+
+  public ByteBuffer data;
+
+  /* package */ FlacOutputBuffer(DecoderWrapper<?, FlacOutputBuffer, ?> owner) {
+    this.owner = owner;
+  }
+
+  /* package */ void init(int size) {
+    if (data == null || data.capacity() < size) {
+      data = ByteBuffer.allocateDirect(size);
+    }
+    data.position(0);
+    data.limit(size);
+  }
+
+  @Override
+  public void reset() {
+    super.reset();
+    if (data != null) {
+      data.clear();
+    }
+  }
+
+  @Override
+  public void release() {
+    owner.releaseOutputBuffer(this);
+  }
+
+}
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
new file mode 100644
index 0000000000..1ef63335b2
--- /dev/null
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
@@ -0,0 +1,404 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.ext.flac;
+
+import com.google.android.exoplayer.CodecCounters;
+import com.google.android.exoplayer.ExoPlaybackException;
+import com.google.android.exoplayer.ExoPlayer;
+import com.google.android.exoplayer.MediaClock;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.MediaFormatHolder;
+import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.SampleSourceTrackRenderer;
+import com.google.android.exoplayer.TrackRenderer;
+import com.google.android.exoplayer.audio.AudioTrack;
+import com.google.android.exoplayer.util.MimeTypes;
+import com.google.android.exoplayer.util.extensions.Buffer;
+import com.google.android.exoplayer.util.extensions.DecoderWrapper;
+import com.google.android.exoplayer.util.extensions.InputBuffer;
+
+import android.os.Handler;
+
+import java.util.List;
+
+/**
+ * Decodes and renders audio using the native Flac decoder.
+ */
+public final class LibflacAudioTrackRenderer extends SampleSourceTrackRenderer
+    implements MediaClock {
+
+  /**
+   * Interface definition for a callback to be notified of {@link LibflacAudioTrackRenderer} events.
+   */
+  public interface EventListener {
+
+    /**
+     * Invoked when the {@link AudioTrack} fails to initialize.
+     *
+     * @param e The corresponding exception.
+     */
+    void onAudioTrackInitializationError(AudioTrack.InitializationException e);
+
+    /**
+     * Invoked when an {@link AudioTrack} write fails.
+     *
+     * @param e The corresponding exception.
+     */
+    void onAudioTrackWriteError(AudioTrack.WriteException e);
+
+    /**
+     * Invoked when decoding fails.
+     *
+     * @param e The corresponding exception.
+     */
+    void onDecoderError(FlacDecoderException e);
+
+  }
+
+  /**
+   * The type of a message that can be passed to an instance of this class via
+   * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
+   * should be a {@link Float} with 0 being silence and 1 being unity gain.
+   */
+  public static final int MSG_SET_VOLUME = 1;
+
+  private static final int NUM_BUFFERS = 16;
+
+  public final CodecCounters codecCounters = new CodecCounters();
+
+  private final Handler eventHandler;
+  private final EventListener eventListener;
+  private final MediaFormatHolder formatHolder;
+
+  private MediaFormat format;
+  private DecoderWrapper<InputBuffer, FlacOutputBuffer, FlacDecoderException> decoderWrapper;
+  private InputBuffer inputBuffer;
+  private FlacOutputBuffer outputBuffer;
+
+  private long currentPositionUs;
+  private boolean allowPositionDiscontinuity;
+  private boolean inputStreamEnded;
+  private boolean outputStreamEnded;
+  private boolean sourceIsReady;
+  private boolean notifyDiscontinuityToDecoder;
+
+  private final AudioTrack audioTrack;
+  private int audioSessionId;
+
+  /**
+   * @param source The upstream source from which the renderer obtains samples.
+   */
+  public LibflacAudioTrackRenderer(SampleSource source) {
+    this(source, null, null);
+  }
+
+  /**
+   * @param source The upstream source from which the renderer obtains samples.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public LibflacAudioTrackRenderer(SampleSource source, Handler eventHandler,
+      EventListener eventListener) {
+    super(source);
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
+    this.audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    this.audioTrack = new AudioTrack();
+    formatHolder = new MediaFormatHolder();
+  }
+
+  /**
+   * Returns whether the underlying libflac library is available.
+   */
+  public static boolean isLibflacAvailable() {
+    return FlacDecoder.IS_AVAILABLE;
+  }
+
+  @Override
+  protected MediaClock getMediaClock() {
+    return this;
+  }
+
+  @Override
+  protected boolean handlesTrack(MediaFormat mediaFormat) {
+    return MimeTypes.AUDIO_FLAC.equalsIgnoreCase(mediaFormat.mimeType);
+  }
+
+  @Override
+  protected void doSomeWork(long positionUs, long elapsedRealtimeUs, boolean sourceIsReady)
+      throws ExoPlaybackException {
+    if (outputStreamEnded) {
+      return;
+    }
+    this.sourceIsReady = sourceIsReady;
+
+    // Try and read a format if we don't have one already.
+    if (format == null && !readFormat(positionUs)) {
+      // We can't make progress without one.
+      return;
+    }
+
+    // If we don't have a decoder yet, we need to instantiate one.
+    if (decoderWrapper == null) {
+      // For flac, the format can contain only one entry in initializationData which is the flac
+      // file header.
+      List<byte[]> initializationData = format.initializationData;
+      if (initializationData.size() < 1) {
+        throw new ExoPlaybackException("Missing initialization data");
+      }
+      FlacDecoder decoder;
+      try {
+        decoder = new FlacDecoder(initializationData);
+      } catch (FlacDecoderException e) {
+        notifyDecoderError(e);
+        throw new ExoPlaybackException(e);
+      }
+      decoderWrapper = new DecoderWrapper<>(decoder, new InputBuffer[NUM_BUFFERS],
+          new FlacOutputBuffer[NUM_BUFFERS], decoder.maxFrameSize);
+      decoderWrapper.start();
+      codecCounters.codecInitCount++;
+    }
+
+    // Rendering loop.
+    try {
+      renderBuffer();
+      while (feedInputBuffer(positionUs)) {}
+    } catch (AudioTrack.InitializationException e) {
+      notifyAudioTrackInitializationError(e);
+      throw new ExoPlaybackException(e);
+    } catch (AudioTrack.WriteException e) {
+      notifyAudioTrackWriteError(e);
+      throw new ExoPlaybackException(e);
+    } catch (FlacDecoderException e) {
+      notifyDecoderError(e);
+      throw new ExoPlaybackException(e);
+    }
+    codecCounters.ensureUpdated();
+  }
+
+  private void renderBuffer() throws FlacDecoderException, AudioTrack.InitializationException,
+      AudioTrack.WriteException {
+    if (outputStreamEnded) {
+      return;
+    }
+
+    if (outputBuffer == null) {
+      outputBuffer = decoderWrapper.dequeueOutputBuffer();
+      if (outputBuffer == null) {
+        return;
+      }
+    }
+
+    if (outputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
+      outputStreamEnded = true;
+      audioTrack.handleEndOfStream();
+      outputBuffer.release();
+      outputBuffer = null;
+      return;
+    }
+
+    if (!audioTrack.isInitialized()) {
+      if (audioSessionId != AudioTrack.SESSION_ID_NOT_SET) {
+        audioTrack.initialize(audioSessionId);
+      } else {
+        audioSessionId = audioTrack.initialize();
+      }
+      if (getState() == TrackRenderer.STATE_STARTED) {
+        audioTrack.play();
+      }
+    }
+
+    int handleBufferResult;
+    handleBufferResult = audioTrack.handleBuffer(outputBuffer.data, outputBuffer.data.position(),
+        outputBuffer.data.remaining(), outputBuffer.timestampUs);
+
+    // If we are out of sync, allow currentPositionUs to jump backwards.
+    if ((handleBufferResult & AudioTrack.RESULT_POSITION_DISCONTINUITY) != 0) {
+      allowPositionDiscontinuity = true;
+    }
+
+    // Release the buffer if it was consumed.
+    if ((handleBufferResult & AudioTrack.RESULT_BUFFER_CONSUMED) != 0) {
+      codecCounters.renderedOutputBufferCount++;
+      outputBuffer.release();
+      outputBuffer = null;
+    }
+  }
+
+  private boolean feedInputBuffer(long positionUs) throws FlacDecoderException {
+    if (inputStreamEnded) {
+      return false;
+    }
+
+    if (inputBuffer == null) {
+      inputBuffer = decoderWrapper.dequeueInputBuffer();
+      if (inputBuffer == null) {
+        return false;
+      }
+    }
+
+    int result = readSource(positionUs, formatHolder, inputBuffer.sampleHolder);
+    if (result == SampleSource.NOTHING_READ) {
+      return false;
+    }
+    if (result == SampleSource.FORMAT_READ) {
+      format = formatHolder.format;
+      return true;
+    }
+    if (result == SampleSource.END_OF_STREAM) {
+      inputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
+      decoderWrapper.queueInputBuffer(inputBuffer);
+      inputBuffer = null;
+      inputStreamEnded = true;
+      return false;
+    }
+    if (notifyDiscontinuityToDecoder) {
+      notifyDiscontinuityToDecoder = false;
+      inputBuffer.setFlag(Buffer.FLAG_RESET);
+    }
+
+    decoderWrapper.queueInputBuffer(inputBuffer);
+    inputBuffer = null;
+    return true;
+  }
+
+  private void flushDecoder() {
+    inputBuffer = null;
+    if (outputBuffer != null) {
+      outputBuffer.release();
+      outputBuffer = null;
+    }
+    decoderWrapper.flush();
+    notifyDiscontinuityToDecoder = true;
+  }
+
+  @Override
+  protected boolean isEnded() {
+    return outputStreamEnded && !audioTrack.hasPendingData();
+  }
+
+  @Override
+  protected boolean isReady() {
+    return audioTrack.hasPendingData()
+        || (format != null && (sourceIsReady || outputBuffer != null));
+  }
+
+  @Override
+  public long getPositionUs() {
+    long newCurrentPositionUs = audioTrack.getCurrentPositionUs(isEnded());
+    if (newCurrentPositionUs != AudioTrack.CURRENT_POSITION_NOT_SET) {
+      currentPositionUs = allowPositionDiscontinuity ? newCurrentPositionUs
+          : Math.max(currentPositionUs, newCurrentPositionUs);
+      allowPositionDiscontinuity = false;
+    }
+    return currentPositionUs;
+  }
+
+  @Override
+  protected void onDiscontinuity(long positionUs) {
+    audioTrack.reset();
+    currentPositionUs = positionUs;
+    allowPositionDiscontinuity = true;
+    inputStreamEnded = false;
+    outputStreamEnded = false;
+    sourceIsReady = false;
+    if (decoderWrapper != null) {
+      flushDecoder();
+    }
+  }
+
+  @Override
+  protected void onStarted() {
+    audioTrack.play();
+  }
+
+  @Override
+  protected void onStopped() {
+    audioTrack.pause();
+  }
+
+  @Override
+  protected void onDisabled() throws ExoPlaybackException {
+    inputBuffer = null;
+    outputBuffer = null;
+    format = null;
+    audioSessionId = AudioTrack.SESSION_ID_NOT_SET;
+    try {
+      if (decoderWrapper != null) {
+        decoderWrapper.release();
+        decoderWrapper = null;
+        codecCounters.codecReleaseCount++;
+      }
+      audioTrack.release();
+    } finally {
+      super.onDisabled();
+    }
+  }
+
+  private boolean readFormat(long positionUs) {
+    int result = readSource(positionUs, formatHolder, null);
+    if (result == SampleSource.FORMAT_READ) {
+      format = formatHolder.format;
+      audioTrack.configure(format.getFrameworkMediaFormatV16(), false);
+      return true;
+    }
+    return false;
+  }
+
+  @Override
+  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+    if (messageType == MSG_SET_VOLUME) {
+      audioTrack.setVolume((Float) message);
+    } else {
+      super.handleMessage(messageType, message);
+    }
+  }
+
+  private void notifyAudioTrackInitializationError(final AudioTrack.InitializationException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onAudioTrackInitializationError(e);
+        }
+      });
+    }
+  }
+
+  private void notifyAudioTrackWriteError(final AudioTrack.WriteException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onAudioTrackWriteError(e);
+        }
+      });
+    }
+  }
+
+  private void notifyDecoderError(final FlacDecoderException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          eventListener.onDecoderError(e);
+        }
+      });
+    }
+  }
+
+}
diff --git a/extensions/flac/src/main/jni/Android.mk b/extensions/flac/src/main/jni/Android.mk
new file mode 100644
index 0000000000..e009333633
--- /dev/null
+++ b/extensions/flac/src/main/jni/Android.mk
@@ -0,0 +1,38 @@
+#
+# Copyright (C) 2016 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+WORKING_DIR := $(call my-dir)
+
+# build libflacJNI.so
+include $(CLEAR_VARS)
+include $(WORKING_DIR)/flac_sources.mk
+
+LOCAL_PATH := $(WORKING_DIR)
+LOCAL_MODULE := libflacJNI
+LOCAL_ARM_MODE := arm
+LOCAL_CPP_EXTENSION := .cc
+
+LOCAL_C_INCLUDES := \
+    $(LOCAL_PATH)/flac/include \
+    $(LOCAL_PATH)/flac/src/libFLAC/include
+LOCAL_SRC_FILES := $(FLAC_SOURCES)
+
+LOCAL_CFLAGS += '-DVERSION="1.3.1"' -DFLAC__NO_MD5 -DFLAC__INTEGER_ONLY_LIBRARY -DFLAC__NO_ASM
+LOCAL_CFLAGS += -D_REENTRANT -DPIC -DU_COMMON_IMPLEMENTATION -fPIC
+LOCAL_CFLAGS += -O3 -funroll-loops -finline-functions
+
+LOCAL_LDLIBS := -llog -lz -lm
+include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/flac/src/main/jni/Application.mk b/extensions/flac/src/main/jni/Application.mk
new file mode 100644
index 0000000000..59bf5f8f87
--- /dev/null
+++ b/extensions/flac/src/main/jni/Application.mk
@@ -0,0 +1,20 @@
+#
+# Copyright (C) 2016 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+APP_OPTIM := release
+APP_STL := gnustl_static
+APP_CPPFLAGS := -frtti
+APP_PLATFORM := android-9
diff --git a/extensions/flac/src/main/jni/data_source.cc b/extensions/flac/src/main/jni/data_source.cc
new file mode 100644
index 0000000000..9701df0789
--- /dev/null
+++ b/extensions/flac/src/main/jni/data_source.cc
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "include/data_source.h"
+#include <android/log.h>
+#include <string.h>
+
+#define LOG_TAG "DataSource"
+#define ALOGE(...) \
+  ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
+
+void DataSource::setBuffer(const void *data, const size_t size) {
+  this->data = data;
+  this->size = size;
+}
+
+ssize_t DataSource::readAt(off64_t /*offset*/, void *const data, size_t size) {
+  if (size > this->size) {
+    size = this->size;
+  }
+  memcpy(data, this->data, size);
+  this->data = reinterpret_cast<const char *>(this->data) + size;
+  this->size -= size;
+  return size;
+}
diff --git a/extensions/flac/src/main/jni/flac_jni.cc b/extensions/flac/src/main/jni/flac_jni.cc
new file mode 100644
index 0000000000..be21d9f057
--- /dev/null
+++ b/extensions/flac/src/main/jni/flac_jni.cc
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include <android/log.h>
+
+#include <cstdlib>
+
+#include "include/flac_parser.h"
+
+#define LOG_TAG "libflac_native"
+#define ALOGE(...) \
+  ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
+#define ALOGV(...) \
+  ((void)__android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))
+
+#define FUNC(RETURN_TYPE, NAME, ...)                                 \
+  extern "C" {                                                       \
+  JNIEXPORT RETURN_TYPE                                              \
+      Java_com_google_android_exoplayer_ext_flac_FlacDecoder_##NAME( \
+          JNIEnv *env, jobject thiz, ##__VA_ARGS__);                 \
+  }                                                                  \
+  JNIEXPORT RETURN_TYPE                                              \
+      Java_com_google_android_exoplayer_ext_flac_FlacDecoder_##NAME( \
+          JNIEnv *env, jobject thiz, ##__VA_ARGS__)
+
+FUNC(jlong, flacInit) {
+  FLACParser *parser = new FLACParser();
+  ALOGV("flacInit parser %p", parser);
+  return reinterpret_cast<intptr_t>(parser);
+}
+
+FUNC(jboolean, flacDecodeMetadata, jlong jContext, jbyteArray jInput) {
+  FLACParser *parser = reinterpret_cast<FLACParser *>(jContext);
+  jbyte *data = env->GetByteArrayElements(jInput, NULL);
+  jint inputSize = env->GetArrayLength(jInput);
+  ALOGV("flacDecodeMetadata byte array: %p size: %d", data, inputSize);
+  jboolean result = parser->init(data, inputSize);
+  env->ReleaseByteArrayElements(jInput, data, JNI_ABORT);
+  return result;
+}
+
+FUNC(jint, flacDecode, jlong jContext, jobject jInputBuffer, jint inputSize,
+     jobject jOutputBuffer, jint outputSize) {
+  FLACParser *parser = reinterpret_cast<FLACParser *>(jContext);
+  const uint8_t *inputBuffer = reinterpret_cast<const uint8_t *>(
+      env->GetDirectBufferAddress(jInputBuffer));
+  int16_t *outputBuffer =
+      reinterpret_cast<int16_t *>(env->GetDirectBufferAddress(jOutputBuffer));
+  return parser->readBuffer(inputBuffer, inputSize, outputBuffer, outputSize);
+}
+
+FUNC(void, flacClose, jlong jContext) {
+  delete reinterpret_cast<FLACParser *>(jContext);
+}
+
+FUNC(jint, flacGetMaxOutputBufferSize, jlong jContext) {
+  FLACParser *parser = reinterpret_cast<FLACParser *>(jContext);
+  return parser->getMaxOutputBufferSize();
+}
+
+FUNC(jint, flacGetMaxFrameSize, jlong jContext) {
+  FLACParser *parser = reinterpret_cast<FLACParser *>(jContext);
+  return parser->getMaxFrameSize();
+}
diff --git a/extensions/flac/src/main/jni/flac_parser.cc b/extensions/flac/src/main/jni/flac_parser.cc
new file mode 100644
index 0000000000..19bc53c7e3
--- /dev/null
+++ b/extensions/flac/src/main/jni/flac_parser.cc
@@ -0,0 +1,438 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "include/flac_parser.h"
+
+#include <jni.h>
+
+#include <android/log.h>
+
+#include <cassert>
+#include <cstdlib>
+
+#define LOG_TAG "FLACParser"
+#define ALOGE(...) \
+  ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
+#define ALOGV(...) \
+  ((void)__android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))
+
+#define LOG_ALWAYS_FATAL(...) \
+  (__android_log_assert(NULL, LOG_TAG, ##__VA_ARGS__))
+
+#define LITERAL_TO_STRING_INTERNAL(x) #x
+#define LITERAL_TO_STRING(x) LITERAL_TO_STRING_INTERNAL(x)
+
+#define TRESPASS()          \
+  LOG_ALWAYS_FATAL(__FILE__ \
+                   ":" LITERAL_TO_STRING(__LINE__) " Should not be here.");
+#define CHECK(x) \
+  if (!(x)) ALOGE("Check failed: %s ", #x)
+
+// The FLAC parser calls our C++ static callbacks using C calling conventions,
+// inside FLAC__stream_decoder_process_until_end_of_metadata
+// and FLAC__stream_decoder_process_single.
+// We immediately then call our corresponding C++ instance methods
+// with the same parameter list, but discard redundant information.
+
+FLAC__StreamDecoderReadStatus FLACParser::read_callback(
+    const FLAC__StreamDecoder * /* decoder */, FLAC__byte buffer[],
+    size_t *bytes, void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->readCallback(buffer, bytes);
+}
+
+FLAC__StreamDecoderSeekStatus FLACParser::seek_callback(
+    const FLAC__StreamDecoder * /* decoder */,
+    FLAC__uint64 absolute_byte_offset, void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->seekCallback(absolute_byte_offset);
+}
+
+FLAC__StreamDecoderTellStatus FLACParser::tell_callback(
+    const FLAC__StreamDecoder * /* decoder */,
+    FLAC__uint64 *absolute_byte_offset, void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->tellCallback(absolute_byte_offset);
+}
+
+FLAC__StreamDecoderLengthStatus FLACParser::length_callback(
+    const FLAC__StreamDecoder * /* decoder */, FLAC__uint64 *stream_length,
+    void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->lengthCallback(stream_length);
+}
+
+FLAC__bool FLACParser::eof_callback(const FLAC__StreamDecoder * /* decoder */,
+                                    void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)->eofCallback();
+}
+
+FLAC__StreamDecoderWriteStatus FLACParser::write_callback(
+    const FLAC__StreamDecoder * /* decoder */, const FLAC__Frame *frame,
+    const FLAC__int32 *const buffer[], void *client_data) {
+  return reinterpret_cast<FLACParser *>(client_data)
+      ->writeCallback(frame, buffer);
+}
+
+void FLACParser::metadata_callback(const FLAC__StreamDecoder * /* decoder */,
+                                   const FLAC__StreamMetadata *metadata,
+                                   void *client_data) {
+  reinterpret_cast<FLACParser *>(client_data)->metadataCallback(metadata);
+}
+
+void FLACParser::error_callback(const FLAC__StreamDecoder * /* decoder */,
+                                FLAC__StreamDecoderErrorStatus status,
+                                void *client_data) {
+  reinterpret_cast<FLACParser *>(client_data)->errorCallback(status);
+}
+
+// These are the corresponding callbacks with C++ calling conventions
+
+FLAC__StreamDecoderReadStatus FLACParser::readCallback(FLAC__byte buffer[],
+                                                       size_t *bytes) {
+  size_t requested = *bytes;
+  ssize_t actual = mDataSource->readAt(mCurrentPos, buffer, requested);
+  if (0 > actual) {
+    *bytes = 0;
+    return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
+  } else if (0 == actual) {
+    *bytes = 0;
+    mEOF = true;
+    return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
+  } else {
+    assert(actual <= requested);
+    *bytes = actual;
+    mCurrentPos += actual;
+    return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
+  }
+}
+
+FLAC__StreamDecoderSeekStatus FLACParser::seekCallback(
+    FLAC__uint64 absolute_byte_offset) {
+  mCurrentPos = absolute_byte_offset;
+  mEOF = false;
+  return FLAC__STREAM_DECODER_SEEK_STATUS_OK;
+}
+
+FLAC__StreamDecoderTellStatus FLACParser::tellCallback(
+    FLAC__uint64 *absolute_byte_offset) {
+  *absolute_byte_offset = mCurrentPos;
+  return FLAC__STREAM_DECODER_TELL_STATUS_OK;
+}
+
+FLAC__StreamDecoderLengthStatus FLACParser::lengthCallback(
+    FLAC__uint64 *stream_length) {
+  return FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;
+}
+
+FLAC__bool FLACParser::eofCallback() { return mEOF; }
+
+FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(
+    const FLAC__Frame *frame, const FLAC__int32 *const buffer[]) {
+  if (mWriteRequested) {
+    mWriteRequested = false;
+    // FLAC parser doesn't free or realloc buffer until next frame or finish
+    mWriteHeader = frame->header;
+    mWriteBuffer = buffer;
+    mWriteCompleted = true;
+    return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
+  } else {
+    ALOGE("FLACParser::writeCallback unexpected");
+    return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
+  }
+}
+
+void FLACParser::metadataCallback(const FLAC__StreamMetadata *metadata) {
+  switch (metadata->type) {
+    case FLAC__METADATA_TYPE_STREAMINFO:
+      if (!mStreamInfoValid) {
+        mStreamInfo = metadata->data.stream_info;
+        mStreamInfoValid = true;
+      } else {
+        ALOGE("FLACParser::metadataCallback unexpected STREAMINFO");
+      }
+      break;
+    case FLAC__METADATA_TYPE_VORBIS_COMMENT:
+      // do nothing
+      break;
+    case FLAC__METADATA_TYPE_PICTURE:
+      // do nothing
+      break;
+    default:
+      ALOGE("FLACParser::metadataCallback unexpected type %u", metadata->type);
+      break;
+  }
+}
+
+void FLACParser::errorCallback(FLAC__StreamDecoderErrorStatus status) {
+  ALOGE("FLACParser::errorCallback status=%d", status);
+  mErrorStatus = status;
+}
+
+// Copy samples from FLAC native 32-bit non-interleaved to 16-bit interleaved.
+// These are candidates for optimization if needed.
+
+static void copyMono8(int16_t *dst, const int *const *src, unsigned nSamples,
+                      unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i] << 8;
+  }
+}
+
+static void copyStereo8(int16_t *dst, const int *const *src, unsigned nSamples,
+                        unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i] << 8;
+    *dst++ = src[1][i] << 8;
+  }
+}
+
+static void copyMultiCh8(int16_t *dst, const int *const *src, unsigned nSamples,
+                         unsigned nChannels) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    for (unsigned c = 0; c < nChannels; ++c) {
+      *dst++ = src[c][i] << 8;
+    }
+  }
+}
+
+static void copyMono16(int16_t *dst, const int *const *src, unsigned nSamples,
+                       unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i];
+  }
+}
+
+static void copyStereo16(int16_t *dst, const int *const *src, unsigned nSamples,
+                         unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i];
+    *dst++ = src[1][i];
+  }
+}
+
+static void copyMultiCh16(int16_t *dst, const int *const *src,
+                          unsigned nSamples, unsigned nChannels) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    for (unsigned c = 0; c < nChannels; ++c) {
+      *dst++ = src[c][i];
+    }
+  }
+}
+
+// 24-bit versions should do dithering or noise-shaping, here or in AudioFlinger
+
+static void copyMono24(int16_t *dst, const int *const *src, unsigned nSamples,
+                       unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i] >> 8;
+  }
+}
+
+static void copyStereo24(int16_t *dst, const int *const *src, unsigned nSamples,
+                         unsigned /* nChannels */) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    *dst++ = src[0][i] >> 8;
+    *dst++ = src[1][i] >> 8;
+  }
+}
+
+static void copyMultiCh24(int16_t *dst, const int *const *src,
+                          unsigned nSamples, unsigned nChannels) {
+  for (unsigned i = 0; i < nSamples; ++i) {
+    for (unsigned c = 0; c < nChannels; ++c) {
+      *dst++ = src[c][i] >> 8;
+    }
+  }
+}
+
+static void copyTrespass(int16_t * /* dst */, const int *const * /* src */,
+                         unsigned /* nSamples */, unsigned /* nChannels */) {
+  TRESPASS();
+}
+
+// FLACParser
+
+FLACParser::FLACParser()
+    : mDataSource(new DataSource),
+      mCopy(copyTrespass),
+      mDecoder(NULL),
+      mCurrentPos(0LL),
+      mEOF(false),
+      mStreamInfoValid(false),
+      mWriteRequested(false),
+      mWriteCompleted(false),
+      mWriteBuffer(NULL),
+      mErrorStatus((FLAC__StreamDecoderErrorStatus)-1) {
+  ALOGV("FLACParser::FLACParser");
+  memset(&mStreamInfo, 0, sizeof(mStreamInfo));
+  memset(&mWriteHeader, 0, sizeof(mWriteHeader));
+}
+
+FLACParser::~FLACParser() {
+  ALOGV("FLACParser::~FLACParser");
+  if (mDecoder != NULL) {
+    FLAC__stream_decoder_delete(mDecoder);
+    mDecoder = NULL;
+  }
+  delete mDataSource;
+}
+
+bool FLACParser::init(const void *buffer, size_t size) {
+  mDataSource->setBuffer(buffer, size);
+
+  // setup libFLAC parser
+  mDecoder = FLAC__stream_decoder_new();
+  if (mDecoder == NULL) {
+    // The new should succeed, since probably all it does is a malloc
+    // that always succeeds in Android.  But to avoid dependence on the
+    // libFLAC internals, we check and log here.
+    ALOGE("new failed");
+    return false;
+  }
+  FLAC__stream_decoder_set_md5_checking(mDecoder, false);
+  FLAC__stream_decoder_set_metadata_ignore_all(mDecoder);
+  FLAC__stream_decoder_set_metadata_respond(mDecoder,
+                                            FLAC__METADATA_TYPE_STREAMINFO);
+  FLAC__stream_decoder_set_metadata_respond(mDecoder,
+                                            FLAC__METADATA_TYPE_PICTURE);
+  FLAC__stream_decoder_set_metadata_respond(mDecoder,
+                                            FLAC__METADATA_TYPE_VORBIS_COMMENT);
+  FLAC__StreamDecoderInitStatus initStatus;
+  initStatus = FLAC__stream_decoder_init_stream(
+      mDecoder, read_callback, seek_callback, tell_callback, length_callback,
+      eof_callback, write_callback, metadata_callback, error_callback,
+      reinterpret_cast<void *>(this));
+  if (initStatus != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
+    // A failure here probably indicates a programming error and so is
+    // unlikely to happen. But we check and log here similarly to above.
+    ALOGE("init_stream failed %d", initStatus);
+    return false;
+  }
+  // parse all metadata
+  if (!FLAC__stream_decoder_process_until_end_of_metadata(mDecoder)) {
+    ALOGE("end_of_metadata failed");
+    return false;
+  }
+  if (mStreamInfoValid) {
+    // check channel count
+    if (getChannels() == 0 || getChannels() > 8) {
+      ALOGE("unsupported channel count %u", getChannels());
+      return false;
+    }
+    // check bit depth
+    switch (getBitsPerSample()) {
+      case 8:
+      case 16:
+      case 24:
+        break;
+      default:
+        ALOGE("unsupported bits per sample %u", getBitsPerSample());
+        return false;
+    }
+    // check sample rate
+    switch (getSampleRate()) {
+      case 8000:
+      case 11025:
+      case 12000:
+      case 16000:
+      case 22050:
+      case 24000:
+      case 32000:
+      case 44100:
+      case 48000:
+      case 88200:
+      case 96000:
+        break;
+      default:
+        ALOGE("unsupported sample rate %u", getSampleRate());
+        return false;
+    }
+    // configure the appropriate copy function, defaulting to trespass
+    static const struct {
+      unsigned mChannels;
+      unsigned mBitsPerSample;
+      void (*mCopy)(int16_t *dst, const int *const *src, unsigned nSamples,
+                    unsigned nChannels);
+    } table[] = {
+        {1, 8, copyMono8},   {2, 8, copyStereo8},   {8, 8, copyMultiCh8},
+        {1, 16, copyMono16}, {2, 16, copyStereo16}, {8, 16, copyMultiCh16},
+        {1, 24, copyMono24}, {2, 24, copyStereo24}, {8, 24, copyMultiCh24},
+    };
+    for (unsigned i = 0; i < sizeof(table) / sizeof(table[0]); ++i) {
+      if (table[i].mChannels >= getChannels() &&
+          table[i].mBitsPerSample == getBitsPerSample()) {
+        mCopy = table[i].mCopy;
+        break;
+      }
+    }
+  } else {
+    ALOGE("missing STREAMINFO");
+    return false;
+  }
+  return true;
+}
+
+size_t FLACParser::readBuffer(const void *buffer, size_t size, int16_t *output,
+                              size_t output_size) {
+  mWriteRequested = true;
+  mWriteCompleted = false;
+  mDataSource->setBuffer(buffer, size);
+
+  if (!FLAC__stream_decoder_process_single(mDecoder)) {
+    ALOGE("FLACParser::readBuffer process_single failed");
+    return -1;
+  }
+  if (!mWriteCompleted) {
+    ALOGE("FLACParser::readBuffer write did not complete");
+    return -1;
+  }
+
+  // verify that block header keeps the promises made by STREAMINFO
+  unsigned blocksize = mWriteHeader.blocksize;
+  if (blocksize == 0 || blocksize > getMaxBlockSize()) {
+    ALOGE("FLACParser::readBuffer write invalid blocksize %u", blocksize);
+    return -1;
+  }
+  if (mWriteHeader.sample_rate != getSampleRate() ||
+      mWriteHeader.channels != getChannels() ||
+      mWriteHeader.bits_per_sample != getBitsPerSample()) {
+    ALOGE(
+        "FLACParser::readBuffer write changed parameters mid-stream: %d/%d/%d "
+        "-> %d/%d/%d",
+        getSampleRate(), getChannels(), getBitsPerSample(),
+        mWriteHeader.sample_rate, mWriteHeader.channels,
+        mWriteHeader.bits_per_sample);
+    return -1;
+  }
+
+  size_t bufferSize = blocksize * getChannels() * sizeof(int16_t);
+  if (bufferSize > output_size) {
+    ALOGE(
+        "FLACParser::readBuffer not enough space in output buffer "
+        "%zu < %zu",
+        output_size, bufferSize);
+    return -1;
+  }
+
+  // copy PCM from FLAC write buffer to our media buffer, with interleaving.
+  (*mCopy)(output, mWriteBuffer, blocksize, getChannels());
+
+  // fill in buffer metadata
+  CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
+
+  return bufferSize;
+}
diff --git a/extensions/flac/src/main/jni/flac_sources.mk b/extensions/flac/src/main/jni/flac_sources.mk
new file mode 100644
index 0000000000..a42c152129
--- /dev/null
+++ b/extensions/flac/src/main/jni/flac_sources.mk
@@ -0,0 +1,46 @@
+#
+# Copyright (C) 2016 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+FLAC_SOURCES = \
+  data_source.cc                                 \
+  flac_jni.cc                                    \
+  flac_parser.cc                                 \
+  flac/src/libFLAC/bitmath.c                     \
+  flac/src/libFLAC/bitreader.c                   \
+  flac/src/libFLAC/bitwriter.c                   \
+  flac/src/libFLAC/cpu.c                         \
+  flac/src/libFLAC/crc.c                         \
+  flac/src/libFLAC/fixed.c                       \
+  flac/src/libFLAC/fixed_intrin_sse2.c           \
+  flac/src/libFLAC/fixed_intrin_ssse3.c          \
+  flac/src/libFLAC/float.c                       \
+  flac/src/libFLAC/format.c                      \
+  flac/src/libFLAC/lpc.c                         \
+  flac/src/libFLAC/lpc_intrin_avx2.c             \
+  flac/src/libFLAC/lpc_intrin_sse2.c             \
+  flac/src/libFLAC/lpc_intrin_sse41.c            \
+  flac/src/libFLAC/lpc_intrin_sse.c              \
+  flac/src/libFLAC/md5.c                         \
+  flac/src/libFLAC/memory.c                      \
+  flac/src/libFLAC/metadata_iterators.c          \
+  flac/src/libFLAC/metadata_object.c             \
+  flac/src/libFLAC/stream_decoder.c              \
+  flac/src/libFLAC/stream_encoder.c              \
+  flac/src/libFLAC/stream_encoder_framing.c      \
+  flac/src/libFLAC/stream_encoder_intrin_avx2.c  \
+  flac/src/libFLAC/stream_encoder_intrin_sse2.c  \
+  flac/src/libFLAC/stream_encoder_intrin_ssse3.c \
+  flac/src/libFLAC/window.c
diff --git a/extensions/flac/src/main/jni/include/data_source.h b/extensions/flac/src/main/jni/include/data_source.h
new file mode 100644
index 0000000000..930f35577e
--- /dev/null
+++ b/extensions/flac/src/main/jni/include/data_source.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INCLUDE_DATA_SOURCE_H_
+#define INCLUDE_DATA_SOURCE_H_
+
+#include <sys/types.h>
+
+class DataSource {
+ public:
+  void setBuffer(const void *data, const size_t size);
+
+  // Returns the number of bytes read, or -1 on failure. It's not an error if
+  // this returns zero; it just means the given offset is equal to, or
+  // beyond, the end of the source.
+  ssize_t readAt(off64_t /*offset*/, void *const data, size_t size);
+
+ private:
+  const void *data;
+  size_t size;
+};
+
+#endif  // INCLUDE_DATA_SOURCE_H_
diff --git a/extensions/flac/src/main/jni/include/flac_parser.h b/extensions/flac/src/main/jni/include/flac_parser.h
new file mode 100644
index 0000000000..19905c1ed7
--- /dev/null
+++ b/extensions/flac/src/main/jni/include/flac_parser.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLAC_PARSER_H_
+#define FLAC_PARSER_H_
+
+#include <stdint.h>
+
+// libFLAC parser
+#include "FLAC/stream_decoder.h"
+
+#include "include/data_source.h"
+
+typedef int status_t;
+
+class FLACParser {
+ public:
+  FLACParser();
+  ~FLACParser();
+
+  bool init(const void *buffer, size_t size);
+
+  // stream properties
+  unsigned getMaxBlockSize() const { return mStreamInfo.max_blocksize; }
+  unsigned getSampleRate() const { return mStreamInfo.sample_rate; }
+  unsigned getChannels() const { return mStreamInfo.channels; }
+  unsigned getBitsPerSample() const { return mStreamInfo.bits_per_sample; }
+  FLAC__uint64 getTotalSamples() const { return mStreamInfo.total_samples; }
+  unsigned getMaxOutputBufferSize() const {
+    return getMaxBlockSize() * getChannels() * sizeof(int16_t);
+  }
+  unsigned getMaxFrameSize() const { return mStreamInfo.max_framesize; }
+
+  size_t readBuffer(const void *buffer, size_t size, int16_t *output,
+                    size_t output_size);
+
+ private:
+  DataSource *mDataSource;
+
+  void (*mCopy)(int16_t *dst, const int *const *src, unsigned nSamples,
+                unsigned nChannels);
+
+  // handle to underlying libFLAC parser
+  FLAC__StreamDecoder *mDecoder;
+
+  // current position within the data source
+  off64_t mCurrentPos;
+  bool mEOF;
+
+  // cached when the STREAMINFO metadata is parsed by libFLAC
+  FLAC__StreamMetadata_StreamInfo mStreamInfo;
+  bool mStreamInfoValid;
+
+  // cached when a decoded PCM block is "written" by libFLAC parser
+  bool mWriteRequested;
+  bool mWriteCompleted;
+  FLAC__FrameHeader mWriteHeader;
+  const FLAC__int32 *const *mWriteBuffer;
+
+  // most recent error reported by libFLAC parser
+  FLAC__StreamDecoderErrorStatus mErrorStatus;
+
+  // no copy constructor or assignment
+  FLACParser(const FLACParser &);
+  FLACParser &operator=(const FLACParser &);
+
+  // FLAC parser callbacks as C++ instance methods
+  FLAC__StreamDecoderReadStatus readCallback(FLAC__byte buffer[],
+                                             size_t *bytes);
+  FLAC__StreamDecoderSeekStatus seekCallback(FLAC__uint64 absolute_byte_offset);
+  FLAC__StreamDecoderTellStatus tellCallback(
+      FLAC__uint64 *absolute_byte_offset);
+  FLAC__StreamDecoderLengthStatus lengthCallback(FLAC__uint64 *stream_length);
+  FLAC__bool eofCallback();
+  FLAC__StreamDecoderWriteStatus writeCallback(
+      const FLAC__Frame *frame, const FLAC__int32 *const buffer[]);
+  void metadataCallback(const FLAC__StreamMetadata *metadata);
+  void errorCallback(FLAC__StreamDecoderErrorStatus status);
+
+  // FLAC parser callbacks as C-callable functions
+  static FLAC__StreamDecoderReadStatus read_callback(
+      const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes,
+      void *client_data);
+  static FLAC__StreamDecoderSeekStatus seek_callback(
+      const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset,
+      void *client_data);
+  static FLAC__StreamDecoderTellStatus tell_callback(
+      const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset,
+      void *client_data);
+  static FLAC__StreamDecoderLengthStatus length_callback(
+      const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length,
+      void *client_data);
+  static FLAC__bool eof_callback(const FLAC__StreamDecoder *decoder,
+                                 void *client_data);
+  static FLAC__StreamDecoderWriteStatus write_callback(
+      const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame,
+      const FLAC__int32 *const buffer[], void *client_data);
+  static void metadata_callback(const FLAC__StreamDecoder *decoder,
+                                const FLAC__StreamMetadata *metadata,
+                                void *client_data);
+  static void error_callback(const FLAC__StreamDecoder *decoder,
+                             FLAC__StreamDecoderErrorStatus status,
+                             void *client_data);
+};
+
+#endif  // FLAC_PARSER_H_
diff --git a/extensions/flac/src/main/proguard.cfg b/extensions/flac/src/main/proguard.cfg
new file mode 100644
index 0000000000..190e32d539
--- /dev/null
+++ b/extensions/flac/src/main/proguard.cfg
@@ -0,0 +1,6 @@
+# Proguard rules specific to the Flac extension.
+
+# This prevents the names of native methods from being obfuscated.
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
diff --git a/extensions/flac/src/main/project.properties b/extensions/flac/src/main/project.properties
new file mode 100644
index 0000000000..b92a03b7ab
--- /dev/null
+++ b/extensions/flac/src/main/project.properties
@@ -0,0 +1,16 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+# Project target.
+target=android-23
+android.library=true
+android.library.reference.1=../../../../library/src/main
diff --git a/gradle.properties b/gradle.properties
index 34fb4618f0..e4a0986904 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,18 +1,16 @@
-# Project-wide Gradle settings.
-
-# IDE (e.g. Android Studio) users:
-# Settings specified in this file will override any Gradle settings
-# configured through the IDE.
-
+## Project-wide Gradle settings.
+#
 # For more details on how to configure your build environment visit
 # http://www.gradle.org/docs/current/userguide/build_environment.html
-
+#
 # Specifies the JVM arguments used for the daemon process.
 # The setting is particularly useful for tweaking memory settings.
 # Default value: -Xmx10248m -XX:MaxPermSize=256m
 # org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
-
+#
 # When configured, Gradle will run in incubating parallel mode.
 # This option should only be used with decoupled projects. More details, visit
 # http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
 # org.gradle.parallel=true
+#Thu Feb 04 15:49:07 GMT 2016
+android.useDeprecatedNdk=true
diff --git a/settings.gradle b/settings.gradle
index 8d0d2823bf..b38ed0e15a 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -18,8 +18,10 @@ include ':playbacktests'
 include ':extension-opus'
 include ':extension-vp9'
 include ':extension-okhttp'
+include ':extension-flac'
 
 project(':demo-misc-vp9-opus-sw').projectDir = new File(settingsDir, 'demo_misc/vp9_opus_sw')
 project(':extension-opus').projectDir = new File(settingsDir, 'extensions/opus')
 project(':extension-vp9').projectDir = new File(settingsDir, 'extensions/vp9')
 project(':extension-okhttp').projectDir = new File(settingsDir, 'extensions/okhttp')
+project(':extension-flac').projectDir = new File(settingsDir, 'extensions/flac')
