diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
index 48df138304..4f6e3b7bee 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
@@ -71,9 +71,10 @@ public RollingSampleBuffer(Allocator allocator) {
    */
   public void clear() {
     infoQueue.clear();
-    while (!dataQueue.isEmpty()) {
-      allocator.release(dataQueue.remove());
-    }
+
+    allocator.release(dataQueue.toArray(new Allocation[dataQueue.size()]));
+    dataQueue.clear();
+
     totalBytesDropped = 0;
     totalBytesWritten = 0;
     lastAllocation = null;
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java b/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java
index db575441b6..dbfae85e44 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/Allocator.java
@@ -37,6 +37,13 @@
    */
   void release(Allocation allocation);
 
+  /**
+   * Return an array of {@link Allocation}s.
+   *
+   * @param allocations The array of {@link Allocation}s being returned.
+   */
+  void release(Allocation[] allocations);
+
   /**
    * Hints to the {@link Allocator} that it should make a best effort to release any memory that it
    * has allocated, beyond the specified target number of bytes.
diff --git a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
index 2327e909f1..a989c0ff2b 100644
--- a/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
+++ b/library/src/main/java/com/google/android/exoplayer/upstream/DefaultAllocator.java
@@ -95,6 +95,25 @@ public synchronized void release(Allocation allocation) {
     notifyAll();
   }
 
+  @Override
+  public synchronized void release(Allocation[] allocations) {
+    if (availableCount + allocations.length >= availableAllocations.length) {
+      availableAllocations = Arrays.copyOf(
+          availableAllocations, Math.max(
+              availableAllocations.length * 2,
+              availableCount + allocations.length));
+    }
+    for (Allocation allocation : allocations) {
+      // Weak sanity check that the allocation probably originated from this pool.
+      Assertions.checkArgument(allocation.data == initialAllocationBlock
+          || allocation.data.length == individualAllocationSize);
+      availableAllocations[availableCount++] = allocation;
+    }
+    allocatedCount -= allocations.length;
+    // Wake up threads waiting for the allocated size to drop.
+    notifyAll();
+  }
+
   @Override
   public synchronized void trim(int targetSize) {
     int targetAllocationCount = Util.ceilDivide(targetSize, individualAllocationSize);
