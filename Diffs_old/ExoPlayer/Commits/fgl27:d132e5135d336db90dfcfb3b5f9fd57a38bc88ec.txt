diff --git a/.gitignore b/.gitignore
index 2ec73a6fd8..790a44c22f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -57,6 +57,9 @@ extensions/vp9/src/main/jni/libvpx
 extensions/vp9/src/main/jni/libvpx_android_configs
 extensions/vp9/src/main/jni/libyuv
 
+# AV1 extension
+extensions/av1/src/main/jni/libgav1
+
 # Opus extension
 extensions/opus/src/main/jni/libopus
 
diff --git a/.hgignore b/.hgignore
index 5889f43b8d..7819a90ac5 100644
--- a/.hgignore
+++ b/.hgignore
@@ -62,6 +62,9 @@ extensions/vp9/src/main/jni/libvpx
 extensions/vp9/src/main/jni/libvpx_android_configs
 extensions/vp9/src/main/jni/libyuv
 
+# AV1 extension
+extensions/av1/src/main/jni/libgav1
+
 # Opus extension
 extensions/opus/src/main/jni/libopus
 
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 77edbd468f..d1a5f13eb3 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -2,6 +2,9 @@
 
 ### dev-v2 (not yet released) ###
 
+* AV1 extension: Uses libgav1 to decode AV1 videos. Android 10 includes an AV1
+  decoder, but the older versions of Android require this extension for playback
+  of AV1 streams ([#3353](https://github.com/google/ExoPlayer/issues/3353)).
 * UI
   * Setting `app:played_color` on `PlayerView` and `PlayerControlView` no longer
     adjusts the colors of the scrubber handle , buffered and unplayed parts of
@@ -29,6 +32,8 @@
     ([#1787](https://github.com/google/ExoPlayer/issues/1787)).
   * Support `Label` elements
     ([#6297](https://github.com/google/ExoPlayer/issues/6297)).
+  * Support legacy audio channel configuration
+    ([#6523](https://github.com/google/ExoPlayer/issues/6523)).
 * Add `allowedCapturePolicy` field to `AudioAttributes` wrapper to allow to
   opt-out of audio recording.
 * Add `DataSpec.httpRequestHeaders` to set HTTP request headers when connecting
@@ -95,6 +100,8 @@
     and move it to the core library.
   * Move `LibvpxVideoRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER` to
     `C.MSG_SET_OUTPUT_BUFFER_RENDERER`.
+  * Use `VideoDecoderRenderer` as an implementation of
+    `VideoDecoderOutputBufferRenderer`, instead of `VideoDecoderSurfaceView`.
 * Add `Timeline.Window.isLive` to indicate that a window is a live stream
   ([#2668](https://github.com/google/ExoPlayer/issues/2668) and
   [#5973](https://github.com/google/ExoPlayer/issues/5973)).
@@ -103,6 +110,10 @@
 * Fail more explicitly when local-file Uris contain invalid parts (e.g.
   fragment) ([#6470](https://github.com/google/ExoPlayer/issues/6470)).
 * Add `MediaPeriod.isLoading` to improve `Player.isLoading` state.
+* Add support for ID3-in-EMSG in HLS streams
+  ([spec](https://aomediacodec.github.io/av1-id3/)).
+* Make show and hide player controls accessible for TalkBack in `PlayerView`.
+* Pass the codec output `MediaFormat` to `VideoFrameMetadataListener`.
 
 ### 2.10.5 (2019-09-20) ###
 
diff --git a/core_settings.gradle b/core_settings.gradle
index 3f6d58f777..0f9746af96 100644
--- a/core_settings.gradle
+++ b/core_settings.gradle
@@ -24,6 +24,7 @@ include modulePrefix + 'library-hls'
 include modulePrefix + 'library-smoothstreaming'
 include modulePrefix + 'library-ui'
 include modulePrefix + 'testutils'
+include modulePrefix + 'extension-av1'
 include modulePrefix + 'extension-ffmpeg'
 include modulePrefix + 'extension-flac'
 include modulePrefix + 'extension-gvr'
@@ -46,6 +47,7 @@ project(modulePrefix + 'library-hls').projectDir = new File(rootDir, 'library/hl
 project(modulePrefix + 'library-smoothstreaming').projectDir = new File(rootDir, 'library/smoothstreaming')
 project(modulePrefix + 'library-ui').projectDir = new File(rootDir, 'library/ui')
 project(modulePrefix + 'testutils').projectDir = new File(rootDir, 'testutils')
+project(modulePrefix + 'extension-av1').projectDir = new File(rootDir, 'extensions/av1')
 project(modulePrefix + 'extension-ffmpeg').projectDir = new File(rootDir, 'extensions/ffmpeg')
 project(modulePrefix + 'extension-flac').projectDir = new File(rootDir, 'extensions/flac')
 project(modulePrefix + 'extension-gvr').projectDir = new File(rootDir, 'extensions/gvr')
diff --git a/demos/gvr/src/main/AndroidManifest.xml b/demos/gvr/src/main/AndroidManifest.xml
index 8545787064..d582433471 100644
--- a/demos/gvr/src/main/AndroidManifest.xml
+++ b/demos/gvr/src/main/AndroidManifest.xml
@@ -64,7 +64,7 @@
         android:theme="@style/VrActivityTheme">
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
-        <category android:name="com.google.intent.category.CARDBOARD"/> <!-- copybara:strip(development-only) -->
+        <category android:name="com.google.intent.category.CARDBOARD"/>
         <category android:name="com.google.intent.category.DAYDREAM"/>
       </intent-filter>
     </activity>
diff --git a/demos/main/build.gradle b/demos/main/build.gradle
index 06c734986c..a4b4a46663 100644
--- a/demos/main/build.gradle
+++ b/demos/main/build.gradle
@@ -69,6 +69,7 @@ dependencies {
     implementation project(modulePrefix + 'library-hls')
     implementation project(modulePrefix + 'library-smoothstreaming')
     implementation project(modulePrefix + 'library-ui')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-av1')
     withExtensionsImplementation project(path: modulePrefix + 'extension-ffmpeg')
     withExtensionsImplementation project(path: modulePrefix + 'extension-flac')
     withExtensionsImplementation project(path: modulePrefix + 'extension-ima')
diff --git a/demos/main/src/main/assets/media.exolist.json b/demos/main/src/main/assets/media.exolist.json
index bcb3ef4ad1..712c250846 100644
--- a/demos/main/src/main/assets/media.exolist.json
+++ b/demos/main/src/main/assets/media.exolist.json
@@ -376,44 +376,48 @@
         "uri": "https://html5demos.com/assets/dizzy.mp4"
       },
       {
-        "name": "Apple AAC 10s",
+        "name": "Apple 10s (AAC)",
         "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear0/fileSequence0.aac"
       },
       {
-        "name": "Apple TS 10s",
+        "name": "Apple 10s (TS)",
         "uri": "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/gear1/fileSequence0.ts"
       },
       {
-        "name": "Android screens (Matroska)",
+        "name": "Android screens (MKV)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv"
       },
       {
-        "name": "Screens 360P (WebM,VP9,No Audio)",
+        "name": "Screens 360p video (WebM,VP9)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/video-vp9-360.webm"
       },
       {
-        "name": "Screens 480p (FMP4,H264,No Audio)",
+        "name": "Screens 480p video (FMP4,H264)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/video-avc-baseline-480.mp4"
       },
       {
-        "name": "Screens 1080p (FMP4,H264, No Audio)",
+        "name": "Screens 1080p video (FMP4,H264)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/video-137.mp4"
       },
       {
-        "name": "Screens (FMP4,AAC Audio)",
+        "name": "Screens audio (FMP4)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/gen-3/screens/dash-vod-single-segment/audio-141.mp4"
       },
       {
-        "name": "Google Play (MP3 Audio)",
+        "name": "Google Play (MP3)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-0/play.mp3"
       },
       {
-        "name": "Google Play (Ogg/Vorbis Audio)",
+        "name": "Google Play (Ogg/Vorbis)",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/ogg/play.ogg"
       },
       {
-        "name": "Big Buck Bunny (FLV Video)",
+        "name": "Big Buck Bunny video (FLV)",
         "uri": "https://vod.leasewebcdn.com/bbb.flv?ri=1024&rs=150&start=0"
+      },
+      {
+        "name": "Big Buck Bunny 480p video (MP4,AV1)",
+        "uri": "https://storage.googleapis.com/downloads.webmproject.org/av1/exoplayer/bbb-av1-480p.mp4"
       }
     ]
   },
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
index 6985d42b36..d83d7076c5 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
@@ -28,7 +28,7 @@
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
-import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
+import com.google.android.exoplayer2.upstream.FileDataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
@@ -165,7 +165,7 @@ protected static CacheDataSourceFactory buildReadOnlyCacheDataSource(
     return new CacheDataSourceFactory(
         cache,
         upstreamFactory,
-        new FileDataSourceFactory(),
+        new FileDataSource.Factory(),
         /* cacheWriteDataSinkFactory= */ null,
         CacheDataSource.FLAG_IGNORE_CACHE_ON_ERROR,
         /* eventListener= */ null);
diff --git a/extensions/av1/README.md b/extensions/av1/README.md
new file mode 100644
index 0000000000..8197a7ab2b
--- /dev/null
+++ b/extensions/av1/README.md
@@ -0,0 +1,118 @@
+# ExoPlayer AV1 extension #
+
+The AV1 extension provides `Libgav1VideoRenderer`, which uses libgav1 native
+library to decode AV1 videos.
+
+## License note ##
+
+Please note that whilst the code in this repository is licensed under
+[Apache 2.0][], using this extension also requires building and including one or
+more external libraries as described below. These are licensed separately.
+
+[Apache 2.0]: https://github.com/google/ExoPlayer/blob/release-v2/LICENSE
+
+## Build instructions ##
+
+To use this extension you need to clone the ExoPlayer repository and depend on
+its modules locally. Instructions for doing this can be found in ExoPlayer's
+[top level README][].
+
+In addition, it's necessary to fetch cpu_features library and libgav1 with its
+dependencies as follows:
+
+* Set the following environment variables:
+
+```
+cd "<path to exoplayer checkout>"
+EXOPLAYER_ROOT="$(pwd)"
+AV1_EXT_PATH="${EXOPLAYER_ROOT}/extensions/av1/src/main"
+```
+
+* Fetch cpu_features library:
+
+```
+cd "${AV1_EXT_PATH}/jni" && \
+git clone https://github.com/google/cpu_features
+```
+
+* Fetch libgav1:
+
+```
+cd "${AV1_EXT_PATH}/jni" && \
+git clone https://chromium.googlesource.com/codecs/libgav1 libgav1
+```
+
+* Fetch Abseil:
+
+```
+cd "${AV1_EXT_PATH}/jni/libgav1" && \
+git clone https://github.com/abseil/abseil-cpp.git third_party/abseil-cpp
+```
+
+* [Install CMake][].
+
+Having followed these steps, gradle will build the extension automatically when
+run on the command line or via Android Studio, using [CMake][] and [Ninja][]
+to configure and build libgav1 and the extension's [JNI wrapper library][].
+
+[top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
+[Install CMake]: https://developer.android.com/studio/projects/install-ndk
+[CMake]: https://cmake.org/
+[Ninja]: https://ninja-build.org
+[JNI wrapper library]: https://github.com/google/ExoPlayer/blob/dev-v2/extensions/av1/src/main/jni/gav1_jni.cc
+
+## Using the extension ##
+
+Once you've followed the instructions above to check out, build and depend on
+the extension, the next step is to tell ExoPlayer to use `Libgav1VideoRenderer`.
+How you do this depends on which player API you're using:
+
+* If you're passing a `DefaultRenderersFactory` to `SimpleExoPlayer.Builder`,
+  you can enable using the extension by setting the `extensionRendererMode`
+  parameter of the `DefaultRenderersFactory` constructor to
+  `EXTENSION_RENDERER_MODE_ON`. This will use `Libgav1VideoRenderer` for
+  playback if `MediaCodecVideoRenderer` doesn't support decoding the input AV1
+  stream. Pass `EXTENSION_RENDERER_MODE_PREFER` to give `Libgav1VideoRenderer`
+  priority over `MediaCodecVideoRenderer`.
+* If you've subclassed `DefaultRenderersFactory`, add a `Libvgav1VideoRenderer`
+  to the output list in `buildVideoRenderers`. ExoPlayer will use the first
+  `Renderer` in the list that supports the input media format.
+* If you've implemented your own `RenderersFactory`, return a
+  `Libgav1VideoRenderer` instance from `createRenderers`. ExoPlayer will use the
+  first `Renderer` in the returned array that supports the input media format.
+* If you're using `ExoPlayer.Builder`, pass a `Libgav1VideoRenderer` in the
+  array of `Renderer`s. ExoPlayer will use the first `Renderer` in the list that
+  supports the input media format.
+
+Note: These instructions assume you're using `DefaultTrackSelector`. If you have
+a custom track selector the choice of `Renderer` is up to your implementation.
+You need to make sure you are passing a `Libgav1VideoRenderer` to the player and
+then you need to implement your own logic to use the renderer for a given track.
+
+## Rendering options ##
+
+There are two possibilities for rendering the output `Libgav1VideoRenderer`
+gets from the libgav1 decoder:
+
+* GL rendering using GL shader for color space conversion
+  * If you are using `SimpleExoPlayer` with `PlayerView`, enable this option by
+    setting `surface_type` of `PlayerView` to be `video_decoder_surface_view`.
+  * Otherwise, enable this option by sending `Libgav1VideoRenderer` a message
+    of type `C.MSG_SET_OUTPUT_BUFFER_RENDERER` with an instance of
+    `VideoDecoderOutputBufferRenderer` as its object.
+
+* Native rendering using `ANativeWindow`
+  * If you are using `SimpleExoPlayer` with `PlayerView`, this option is enabled
+    by default.
+  * Otherwise, enable this option by sending `Libgav1VideoRenderer` a message of
+    type `C.MSG_SET_SURFACE` with an instance of `SurfaceView` as its object.
+
+Note: Although the default option uses `ANativeWindow`, based on our testing the
+GL rendering mode has better performance, so should be preferred
+
+## Links ##
+
+* [Javadoc][]: Classes matching `com.google.android.exoplayer2.ext.av1.*`
+  belong to this module.
+
+[Javadoc]: https://exoplayer.dev/doc/reference/index.html
diff --git a/extensions/av1/build.gradle b/extensions/av1/build.gradle
new file mode 100644
index 0000000000..0b539d551b
--- /dev/null
+++ b/extensions/av1/build.gradle
@@ -0,0 +1,73 @@
+// Copyright (C) 2019 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
+    defaultConfig {
+        minSdkVersion project.ext.minSdkVersion
+        targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
+
+        externalNativeBuild {
+            cmake {
+                // Debug CMake build type causes video frames to drop,
+                // so native library should always use Release build type.
+                arguments "-DCMAKE_BUILD_TYPE=Release"
+                targets "gav1JNI"
+            }
+        }
+    }
+
+    // This option resolves the problem of finding libgav1JNI.so
+    // on multiple paths. The first one found is picked.
+    packagingOptions {
+        pickFirst 'lib/arm64-v8a/libgav1JNI.so'
+        pickFirst 'lib/armeabi-v7a/libgav1JNI.so'
+        pickFirst 'lib/x86/libgav1JNI.so'
+        pickFirst 'lib/x86_64/libgav1JNI.so'
+    }
+
+    sourceSets.main {
+        // As native JNI library build is invoked from gradle, this is
+        // not needed. However, it exposes the built library and keeps
+        // consistency with the other extensions.
+        jniLibs.srcDir 'src/main/libs'
+    }
+}
+
+// Configure the native build only if libgav1 is present, to avoid gradle sync
+// failures if libgav1 hasn't been checked out according to the README and CMake
+// isn't installed.
+if (project.file('src/main/jni/libgav1').exists()) {
+    android.externalNativeBuild.cmake.path = 'src/main/jni/CMakeLists.txt'
+    android.externalNativeBuild.cmake.version = '3.7.1+'
+}
+
+dependencies {
+    implementation project(modulePrefix + 'library-core')
+    implementation 'androidx.annotation:annotation:' + androidxAnnotationVersion
+}
+
+ext {
+    javadocTitle = 'AV1 extension'
+}
+apply from: '../../javadoc_library.gradle'
diff --git a/extensions/av1/proguard-rules.txt b/extensions/av1/proguard-rules.txt
new file mode 100644
index 0000000000..9d73f7e2b5
--- /dev/null
+++ b/extensions/av1/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Proguard rules specific to the AV1 extension.
+
+# This prevents the names of native methods from being obfuscated.
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
+
diff --git a/extensions/av1/src/main/AndroidManifest.xml b/extensions/av1/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..af85bacdf6
--- /dev/null
+++ b/extensions/av1/src/main/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.ext.av1"/>
diff --git a/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Gav1Decoder.java b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Gav1Decoder.java
new file mode 100644
index 0000000000..8e886b144c
--- /dev/null
+++ b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Gav1Decoder.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.av1;
+
+import android.view.Surface;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.decoder.SimpleDecoder;
+import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoDecoderInputBuffer;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBuffer;
+import java.nio.ByteBuffer;
+
+/** Gav1 decoder. */
+/* package */ final class Gav1Decoder
+    extends SimpleDecoder<VideoDecoderInputBuffer, VideoDecoderOutputBuffer, Gav1DecoderException> {
+
+  // LINT.IfChange
+  private static final int GAV1_ERROR = 0;
+  private static final int GAV1_OK = 1;
+  private static final int GAV1_DECODE_ONLY = 2;
+  // LINT.ThenChange(../../../../../../../jni/gav1_jni.cc)
+
+  private final long gav1DecoderContext;
+
+  @C.VideoOutputMode private volatile int outputMode;
+
+  /**
+   * Creates a Gav1Decoder.
+   *
+   * @param numInputBuffers Number of input buffers.
+   * @param numOutputBuffers Number of output buffers.
+   * @param initialInputBufferSize The initial size of each input buffer, in bytes.
+   * @param threads Number of threads libgav1 will use to decode.
+   * @throws Gav1DecoderException Thrown if an exception occurs when initializing the decoder.
+   */
+  public Gav1Decoder(
+      int numInputBuffers, int numOutputBuffers, int initialInputBufferSize, int threads)
+      throws Gav1DecoderException {
+    super(
+        new VideoDecoderInputBuffer[numInputBuffers],
+        new VideoDecoderOutputBuffer[numOutputBuffers]);
+    if (!Gav1Library.isAvailable()) {
+      throw new Gav1DecoderException("Failed to load decoder native library.");
+    }
+    gav1DecoderContext = gav1Init(threads);
+    if (gav1DecoderContext == GAV1_ERROR || gav1CheckError(gav1DecoderContext) == GAV1_ERROR) {
+      throw new Gav1DecoderException(
+          "Failed to initialize decoder. Error: " + gav1GetErrorMessage(gav1DecoderContext));
+    }
+    setInitialInputBufferSize(initialInputBufferSize);
+  }
+
+  @Override
+  public String getName() {
+    return "libgav1";
+  }
+
+  /**
+   * Sets the output mode for frames rendered by the decoder.
+   *
+   * @param outputMode The output mode.
+   */
+  public void setOutputMode(@C.VideoOutputMode int outputMode) {
+    this.outputMode = outputMode;
+  }
+
+  @Override
+  protected VideoDecoderInputBuffer createInputBuffer() {
+    return new VideoDecoderInputBuffer();
+  }
+
+  @Override
+  protected VideoDecoderOutputBuffer createOutputBuffer() {
+    return new VideoDecoderOutputBuffer(this::releaseOutputBuffer);
+  }
+
+  @Nullable
+  @Override
+  protected Gav1DecoderException decode(
+      VideoDecoderInputBuffer inputBuffer, VideoDecoderOutputBuffer outputBuffer, boolean reset) {
+    ByteBuffer inputData = Util.castNonNull(inputBuffer.data);
+    int inputSize = inputData.limit();
+    if (gav1Decode(gav1DecoderContext, inputData, inputSize) == GAV1_ERROR) {
+      return new Gav1DecoderException(
+          "gav1Decode error: " + gav1GetErrorMessage(gav1DecoderContext));
+    }
+
+    boolean decodeOnly = inputBuffer.isDecodeOnly();
+    if (!decodeOnly) {
+      @Nullable
+      ByteBuffer supplementalData =
+          inputBuffer.hasSupplementalData() ? inputBuffer.supplementalData : null;
+      outputBuffer.init(inputBuffer.timeUs, outputMode, supplementalData);
+    }
+    // We need to dequeue the decoded frame from the decoder even when the input data is
+    // decode-only.
+    int getFrameResult = gav1GetFrame(gav1DecoderContext, outputBuffer, decodeOnly);
+    if (getFrameResult == GAV1_ERROR) {
+      return new Gav1DecoderException(
+          "gav1GetFrame error: " + gav1GetErrorMessage(gav1DecoderContext));
+    }
+    if (getFrameResult == GAV1_DECODE_ONLY) {
+      outputBuffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
+    }
+    if (!decodeOnly) {
+      outputBuffer.colorInfo = inputBuffer.colorInfo;
+    }
+
+    return null;
+  }
+
+  @Override
+  protected Gav1DecoderException createUnexpectedDecodeException(Throwable error) {
+    return new Gav1DecoderException("Unexpected decode error", error);
+  }
+
+  @Override
+  public void release() {
+    super.release();
+    gav1Close(gav1DecoderContext);
+  }
+
+  @Override
+  protected void releaseOutputBuffer(VideoDecoderOutputBuffer buffer) {
+    // Decode only frames do not acquire a reference on the internal decoder buffer and thus do not
+    // require a call to gav1ReleaseFrame.
+    if (buffer.mode == C.VIDEO_OUTPUT_MODE_SURFACE_YUV && !buffer.isDecodeOnly()) {
+      gav1ReleaseFrame(gav1DecoderContext, buffer);
+    }
+    super.releaseOutputBuffer(buffer);
+  }
+
+  /**
+   * Renders output buffer to the given surface. Must only be called when in {@link
+   * C#VIDEO_OUTPUT_MODE_SURFACE_YUV} mode.
+   *
+   * @param outputBuffer Output buffer.
+   * @param surface Output surface.
+   * @throws Gav1DecoderException Thrown if called with invalid output mode or frame rendering
+   *     fails.
+   */
+  public void renderToSurface(VideoDecoderOutputBuffer outputBuffer, Surface surface)
+      throws Gav1DecoderException {
+    if (outputBuffer.mode != C.VIDEO_OUTPUT_MODE_SURFACE_YUV) {
+      throw new Gav1DecoderException("Invalid output mode.");
+    }
+    if (gav1RenderFrame(gav1DecoderContext, surface, outputBuffer) == GAV1_ERROR) {
+      throw new Gav1DecoderException(
+          "Buffer render error: " + gav1GetErrorMessage(gav1DecoderContext));
+    }
+  }
+
+  /**
+   * Initializes a libgav1 decoder.
+   *
+   * @param threads Number of threads to be used by a libgav1 decoder.
+   * @return The address of the decoder context or {@link #GAV1_ERROR} if there was an error.
+   */
+  private native long gav1Init(int threads);
+
+  /**
+   * Deallocates the decoder context.
+   *
+   * @param context Decoder context.
+   */
+  private native void gav1Close(long context);
+
+  /**
+   * Decodes the encoded data passed.
+   *
+   * @param context Decoder context.
+   * @param encodedData Encoded data.
+   * @param length Length of the data buffer.
+   * @return {@link #GAV1_OK} if successful, {@link #GAV1_ERROR} if an error occurred.
+   */
+  private native int gav1Decode(long context, ByteBuffer encodedData, int length);
+
+  /**
+   * Gets the decoded frame.
+   *
+   * @param context Decoder context.
+   * @param outputBuffer Output buffer for the decoded frame.
+   * @return {@link #GAV1_OK} if successful, {@link #GAV1_DECODE_ONLY} if successful but the frame
+   *     is decode-only, {@link #GAV1_ERROR} if an error occurred.
+   */
+  private native int gav1GetFrame(
+      long context, VideoDecoderOutputBuffer outputBuffer, boolean decodeOnly);
+
+  /**
+   * Renders the frame to the surface. Used with {@link C#VIDEO_OUTPUT_MODE_SURFACE_YUV} only.
+   *
+   * @param context Decoder context.
+   * @param surface Output surface.
+   * @param outputBuffer Output buffer with the decoded frame.
+   * @return {@link #GAV1_OK} if successful, {@link #GAV1_ERROR} if an error occured.
+   */
+  private native int gav1RenderFrame(
+      long context, Surface surface, VideoDecoderOutputBuffer outputBuffer);
+
+  /**
+   * Releases the frame. Used with {@link C#VIDEO_OUTPUT_MODE_SURFACE_YUV} only.
+   *
+   * @param context Decoder context.
+   * @param outputBuffer Output buffer.
+   */
+  private native void gav1ReleaseFrame(long context, VideoDecoderOutputBuffer outputBuffer);
+
+  /**
+   * Returns a human-readable string describing the last error encountered in the given context.
+   *
+   * @param context Decoder context.
+   * @return A string describing the last encountered error.
+   */
+  private native String gav1GetErrorMessage(long context);
+
+  /**
+   * Returns whether an error occured.
+   *
+   * @param context Decoder context.
+   * @return {@link #GAV1_OK} if there was no error, {@link #GAV1_ERROR} if an error occured.
+   */
+  private native int gav1CheckError(long context);
+}
diff --git a/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Gav1DecoderException.java b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Gav1DecoderException.java
new file mode 100644
index 0000000000..9d8692c581
--- /dev/null
+++ b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Gav1DecoderException.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.av1;
+
+import com.google.android.exoplayer2.video.VideoDecoderException;
+
+/** Thrown when a libgav1 decoder error occurs. */
+public final class Gav1DecoderException extends VideoDecoderException {
+
+  /* package */ Gav1DecoderException(String message) {
+    super(message);
+  }
+
+  /* package */ Gav1DecoderException(String message, Throwable cause) {
+    super(message, cause);
+  }
+}
diff --git a/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Gav1Library.java b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Gav1Library.java
new file mode 100644
index 0000000000..7907fa4623
--- /dev/null
+++ b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Gav1Library.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.av1;
+
+import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.util.LibraryLoader;
+
+/** Configures and queries the underlying native library. */
+public final class Gav1Library {
+
+  static {
+    ExoPlayerLibraryInfo.registerModule("goog.exo.gav1");
+  }
+
+  private static final LibraryLoader LOADER = new LibraryLoader("gav1JNI");
+
+  private Gav1Library() {}
+
+  /** Returns whether the underlying library is available, loading it if necessary. */
+  public static boolean isAvailable() {
+    return LOADER.isAvailable();
+  }
+}
diff --git a/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Libgav1VideoRenderer.java b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Libgav1VideoRenderer.java
new file mode 100644
index 0000000000..1ae972477d
--- /dev/null
+++ b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/Libgav1VideoRenderer.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.av1;
+
+import static java.lang.Runtime.getRuntime;
+
+import android.os.Handler;
+import android.view.Surface;
+import androidx.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.PlayerMessage.Target;
+import com.google.android.exoplayer2.decoder.SimpleDecoder;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.ExoMediaCrypto;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.TraceUtil;
+import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.SimpleDecoderVideoRenderer;
+import com.google.android.exoplayer2.video.VideoDecoderException;
+import com.google.android.exoplayer2.video.VideoDecoderInputBuffer;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBuffer;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBufferRenderer;
+import com.google.android.exoplayer2.video.VideoRendererEventListener;
+
+/**
+ * Decodes and renders video using libgav1 decoder.
+ *
+ * <p>This renderer accepts the following messages sent via {@link ExoPlayer#createMessage(Target)}
+ * on the playback thread:
+ *
+ * <ul>
+ *   <li>Message with type {@link C#MSG_SET_SURFACE} to set the output surface. The message payload
+ *       should be the target {@link Surface}, or null.
+ *   <li>Message with type {@link C#MSG_SET_OUTPUT_BUFFER_RENDERER} to set the output buffer
+ *       renderer. The message payload should be the target {@link
+ *       VideoDecoderOutputBufferRenderer}, or null.
+ * </ul>
+ */
+public class Libgav1VideoRenderer extends SimpleDecoderVideoRenderer {
+
+  private static final int DEFAULT_NUM_OF_INPUT_BUFFERS = 4;
+  private static final int DEFAULT_NUM_OF_OUTPUT_BUFFERS = 4;
+  /* Default size based on 720p resolution video compressed by a factor of two. */
+  private static final int DEFAULT_INPUT_BUFFER_SIZE =
+      Util.ceilDivide(1280, 64) * Util.ceilDivide(720, 64) * (64 * 64 * 3 / 2) / 2;
+
+  /** The number of input buffers. */
+  private final int numInputBuffers;
+  /**
+   * The number of output buffers. The renderer may limit the minimum possible value due to
+   * requiring multiple output buffers to be dequeued at a time for it to make progress.
+   */
+  private final int numOutputBuffers;
+
+  private final int threads;
+
+  @Nullable private Gav1Decoder decoder;
+
+  /**
+   * Creates a Libgav1VideoRenderer.
+   *
+   * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
+   *     can attempt to seamlessly join an ongoing playback.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
+   *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
+   */
+  public Libgav1VideoRenderer(
+      long allowedJoiningTimeMs,
+      @Nullable Handler eventHandler,
+      @Nullable VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify) {
+    this(
+        allowedJoiningTimeMs,
+        eventHandler,
+        eventListener,
+        maxDroppedFramesToNotify,
+        /* threads= */ getRuntime().availableProcessors(),
+        DEFAULT_NUM_OF_INPUT_BUFFERS,
+        DEFAULT_NUM_OF_OUTPUT_BUFFERS);
+  }
+
+  /**
+   * Creates a Libgav1VideoRenderer.
+   *
+   * @param allowedJoiningTimeMs The maximum duration in milliseconds for which this video renderer
+   *     can attempt to seamlessly join an ongoing playback.
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param maxDroppedFramesToNotify The maximum number of frames that can be dropped between
+   *     invocations of {@link VideoRendererEventListener#onDroppedFrames(int, long)}.
+   * @param threads Number of threads libgav1 will use to decode.
+   * @param numInputBuffers Number of input buffers.
+   * @param numOutputBuffers Number of output buffers.
+   */
+  public Libgav1VideoRenderer(
+      long allowedJoiningTimeMs,
+      @Nullable Handler eventHandler,
+      @Nullable VideoRendererEventListener eventListener,
+      int maxDroppedFramesToNotify,
+      int threads,
+      int numInputBuffers,
+      int numOutputBuffers) {
+    super(
+        allowedJoiningTimeMs,
+        eventHandler,
+        eventListener,
+        maxDroppedFramesToNotify,
+        /* drmSessionManager= */ null,
+        /* playClearSamplesWithoutKeys= */ false);
+    this.threads = threads;
+    this.numInputBuffers = numInputBuffers;
+    this.numOutputBuffers = numOutputBuffers;
+  }
+
+  @Override
+  protected int supportsFormatInternal(
+      @Nullable DrmSessionManager<ExoMediaCrypto> drmSessionManager, Format format) {
+    if (!MimeTypes.VIDEO_AV1.equalsIgnoreCase(format.sampleMimeType)
+        || !Gav1Library.isAvailable()) {
+      return FORMAT_UNSUPPORTED_TYPE;
+    }
+    if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
+      return FORMAT_UNSUPPORTED_DRM;
+    }
+    return FORMAT_HANDLED | ADAPTIVE_SEAMLESS;
+  }
+
+  @Override
+  protected SimpleDecoder<
+          VideoDecoderInputBuffer,
+          ? extends VideoDecoderOutputBuffer,
+          ? extends VideoDecoderException>
+      createDecoder(Format format, @Nullable ExoMediaCrypto mediaCrypto)
+          throws VideoDecoderException {
+    TraceUtil.beginSection("createGav1Decoder");
+    int initialInputBufferSize =
+        format.maxInputSize != Format.NO_VALUE ? format.maxInputSize : DEFAULT_INPUT_BUFFER_SIZE;
+    Gav1Decoder decoder =
+        new Gav1Decoder(numInputBuffers, numOutputBuffers, initialInputBufferSize, threads);
+    this.decoder = decoder;
+    TraceUtil.endSection();
+    return decoder;
+  }
+
+  @Override
+  protected void renderOutputBufferToSurface(VideoDecoderOutputBuffer outputBuffer, Surface surface)
+      throws Gav1DecoderException {
+    if (decoder == null) {
+      throw new Gav1DecoderException(
+          "Failed to render output buffer to surface: decoder is not initialized.");
+    }
+    decoder.renderToSurface(outputBuffer, surface);
+    outputBuffer.release();
+  }
+
+  @Override
+  protected void setDecoderOutputMode(@C.VideoOutputMode int outputMode) {
+    if (decoder != null) {
+      decoder.setOutputMode(outputMode);
+    }
+  }
+
+  // PlayerMessage.Target implementation.
+
+  @Override
+  public void handleMessage(int messageType, @Nullable Object message) throws ExoPlaybackException {
+    if (messageType == C.MSG_SET_SURFACE) {
+      setOutputSurface((Surface) message);
+    } else if (messageType == C.MSG_SET_OUTPUT_BUFFER_RENDERER) {
+      setOutputBufferRenderer((VideoDecoderOutputBufferRenderer) message);
+    } else {
+      super.handleMessage(messageType, message);
+    }
+  }
+}
diff --git a/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/package-info.java b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/package-info.java
new file mode 100644
index 0000000000..2e289b27fa
--- /dev/null
+++ b/extensions/av1/src/main/java/com/google/android/exoplayer2/ext/av1/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@NonNullApi
+package com.google.android.exoplayer2.ext.av1;
+
+import com.google.android.exoplayer2.util.NonNullApi;
diff --git a/extensions/av1/src/main/jni/CMakeLists.txt b/extensions/av1/src/main/jni/CMakeLists.txt
new file mode 100644
index 0000000000..abd8764e0f
--- /dev/null
+++ b/extensions/av1/src/main/jni/CMakeLists.txt
@@ -0,0 +1,56 @@
+# libgav1JNI requires modern CMake.
+cmake_minimum_required(VERSION 3.7.1 FATAL_ERROR)
+
+# libgav1JNI requires C++11.
+set(CMAKE_CXX_STANDARD 11)
+
+project(libgav1JNI C CXX)
+
+# Devices using armeabi-v7a are not required to support
+# Neon which is why Neon is disabled by default for
+# armeabi-v7a build. This flag enables it.
+if(${ANDROID_ABI} MATCHES "armeabi-v7a")
+    add_compile_options("-mfpu=neon")
+    add_compile_options("-fPIC")
+endif()
+
+set(libgav1_jni_root "${CMAKE_CURRENT_SOURCE_DIR}")
+set(libgav1_jni_build "${CMAKE_BINARY_DIR}")
+set(libgav1_jni_output_directory
+    ${libgav1_jni_root}/../libs/${ANDROID_ABI}/)
+
+set(libgav1_root "${libgav1_jni_root}/libgav1")
+set(libgav1_build "${libgav1_jni_build}/libgav1")
+
+set(cpu_features_root "${libgav1_jni_root}/cpu_features")
+set(cpu_features_build "${libgav1_jni_build}/cpu_features")
+
+# Build cpu_features library.
+add_subdirectory("${cpu_features_root}"
+                 "${cpu_features_build}"
+                 EXCLUDE_FROM_ALL)
+
+# Build libgav1.
+add_subdirectory("${libgav1_root}"
+                 "${libgav1_build}"
+                 EXCLUDE_FROM_ALL)
+
+# Build libgav1JNI.
+add_library(gav1JNI
+            SHARED
+            gav1_jni.cc)
+
+# Locate NDK log library.
+find_library(android_log_lib log)
+
+# Link libgav1JNI against used libraries.
+target_link_libraries(gav1JNI
+                      PRIVATE android
+                      PRIVATE cpu_features
+                      PRIVATE libgav1_static
+                      PRIVATE ${android_log_lib})
+
+# Specify output directory for libgav1JNI.
+set_target_properties(gav1JNI PROPERTIES
+                      LIBRARY_OUTPUT_DIRECTORY
+                      ${libgav1_jni_output_directory})
diff --git a/extensions/av1/src/main/jni/gav1_jni.cc b/extensions/av1/src/main/jni/gav1_jni.cc
new file mode 100644
index 0000000000..9ac3ea5cd2
--- /dev/null
+++ b/extensions/av1/src/main/jni/gav1_jni.cc
@@ -0,0 +1,754 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <android/log.h>
+#include <android/native_window.h>
+#include <android/native_window_jni.h>
+
+#include "cpu_features_macros.h"  // NOLINT
+#ifdef CPU_FEATURES_ARCH_ARM
+#include "cpuinfo_arm.h"  // NOLINT
+#endif                    // CPU_FEATURES_ARCH_ARM
+#ifdef CPU_FEATURES_COMPILED_ANY_ARM_NEON
+#include <arm_neon.h>
+#endif  // CPU_FEATURES_COMPILED_ANY_ARM_NEON
+#include <jni.h>
+
+#include <cstring>
+#include <mutex>  // NOLINT
+#include <new>
+
+#include "gav1/decoder.h"
+
+#define LOG_TAG "gav1_jni"
+#define LOGE(...) \
+  ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))
+
+#define DECODER_FUNC(RETURN_TYPE, NAME, ...)                         \
+  extern "C" {                                                       \
+  JNIEXPORT RETURN_TYPE                                              \
+      Java_com_google_android_exoplayer2_ext_av1_Gav1Decoder_##NAME( \
+          JNIEnv* env, jobject thiz, ##__VA_ARGS__);                 \
+  }                                                                  \
+  JNIEXPORT RETURN_TYPE                                              \
+      Java_com_google_android_exoplayer2_ext_av1_Gav1Decoder_##NAME( \
+          JNIEnv* env, jobject thiz, ##__VA_ARGS__)
+
+jint JNI_OnLoad(JavaVM* vm, void* reserved) {
+  JNIEnv* env;
+  if (vm->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK) {
+    return -1;
+  }
+  return JNI_VERSION_1_6;
+}
+
+namespace {
+
+// YUV plane indices.
+const int kPlaneY = 0;
+const int kPlaneU = 1;
+const int kPlaneV = 2;
+const int kMaxPlanes = 3;
+
+// Android YUV format. See:
+// https://developer.android.com/reference/android/graphics/ImageFormat.html#YV12.
+const int kImageFormatYV12 = 0x32315659;
+
+// LINT.IfChange
+// Output modes.
+const int kOutputModeYuv = 0;
+const int kOutputModeSurfaceYuv = 1;
+// LINT.ThenChange(../../../../../library/core/src/main/java/com/google/android/exoplayer2/C.java)
+
+// LINT.IfChange
+const int kColorSpaceUnknown = 0;
+// LINT.ThenChange(../../../../../library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java)
+
+// LINT.IfChange
+// Return codes for jni methods.
+const int kStatusError = 0;
+const int kStatusOk = 1;
+const int kStatusDecodeOnly = 2;
+// LINT.ThenChange(../java/com/google/android/exoplayer2/ext/av1/Gav1Decoder.java)
+
+// Status codes specific to the JNI wrapper code.
+enum JniStatusCode {
+  kJniStatusOk = 0,
+  kJniStatusOutOfMemory = -1,
+  kJniStatusBufferAlreadyReleased = -2,
+  kJniStatusInvalidNumOfPlanes = -3,
+  kJniStatusBitDepth12NotSupportedWithYuv = -4,
+  kJniStatusHighBitDepthNotSupportedWithSurfaceYuv = -5,
+  kJniStatusANativeWindowError = -6,
+  kJniStatusBufferResizeError = -7,
+  kJniStatusNeonNotSupported = -8
+};
+
+const char* GetJniErrorMessage(JniStatusCode error_code) {
+  switch (error_code) {
+    case kJniStatusOutOfMemory:
+      return "Out of memory.";
+    case kJniStatusBufferAlreadyReleased:
+      return "JNI buffer already released.";
+    case kJniStatusBitDepth12NotSupportedWithYuv:
+      return "Bit depth 12 is not supported with YUV.";
+    case kJniStatusHighBitDepthNotSupportedWithSurfaceYuv:
+      return "High bit depth (10 or 12 bits per pixel) output format is not "
+             "supported with YUV surface.";
+    case kJniStatusInvalidNumOfPlanes:
+      return "Libgav1 decoded buffer has invalid number of planes.";
+    case kJniStatusANativeWindowError:
+      return "ANativeWindow error.";
+    case kJniStatusBufferResizeError:
+      return "Buffer resize failed.";
+    case kJniStatusNeonNotSupported:
+      return "Neon is not supported.";
+    default:
+      return "Unrecognized error code.";
+  }
+}
+
+// Manages Libgav1FrameBuffer and reference information.
+class JniFrameBuffer {
+ public:
+  explicit JniFrameBuffer(int id) : id_(id), reference_count_(0) {
+    gav1_frame_buffer_.private_data = &id_;
+  }
+  ~JniFrameBuffer() {
+    for (int plane_index = kPlaneY; plane_index < kMaxPlanes; plane_index++) {
+      delete[] gav1_frame_buffer_.data[plane_index];
+    }
+  }
+
+  void SetFrameData(const libgav1::DecoderBuffer& decoder_buffer) {
+    for (int plane_index = kPlaneY; plane_index < decoder_buffer.NumPlanes();
+         plane_index++) {
+      stride_[plane_index] = decoder_buffer.stride[plane_index];
+      plane_[plane_index] = decoder_buffer.plane[plane_index];
+      displayed_width_[plane_index] =
+          decoder_buffer.displayed_width[plane_index];
+      displayed_height_[plane_index] =
+          decoder_buffer.displayed_height[plane_index];
+    }
+  }
+
+  int Stride(int plane_index) const { return stride_[plane_index]; }
+  uint8_t* Plane(int plane_index) const { return plane_[plane_index]; }
+  int DisplayedWidth(int plane_index) const {
+    return displayed_width_[plane_index];
+  }
+  int DisplayedHeight(int plane_index) const {
+    return displayed_height_[plane_index];
+  }
+
+  // Methods maintaining reference count are not thread-safe. They must be
+  // called with a lock held.
+  void AddReference() { ++reference_count_; }
+  void RemoveReference() { reference_count_--; }
+  bool InUse() const { return reference_count_ != 0; }
+
+  const Libgav1FrameBuffer& GetGav1FrameBuffer() const {
+    return gav1_frame_buffer_;
+  }
+
+  // Attempts to reallocate data planes if the existing ones don't have enough
+  // capacity. Returns true if the allocation was successful or wasn't needed,
+  // false if the allocation failed.
+  bool MaybeReallocateGav1DataPlanes(int y_plane_min_size,
+                                     int uv_plane_min_size) {
+    for (int plane_index = kPlaneY; plane_index < kMaxPlanes; plane_index++) {
+      const int min_size =
+          (plane_index == kPlaneY) ? y_plane_min_size : uv_plane_min_size;
+      if (gav1_frame_buffer_.size[plane_index] >= min_size) continue;
+      delete[] gav1_frame_buffer_.data[plane_index];
+      gav1_frame_buffer_.data[plane_index] =
+          new (std::nothrow) uint8_t[min_size];
+      if (!gav1_frame_buffer_.data[plane_index]) {
+        gav1_frame_buffer_.size[plane_index] = 0;
+        return false;
+      }
+      gav1_frame_buffer_.size[plane_index] = min_size;
+    }
+    return true;
+  }
+
+ private:
+  int stride_[kMaxPlanes];
+  uint8_t* plane_[kMaxPlanes];
+  int displayed_width_[kMaxPlanes];
+  int displayed_height_[kMaxPlanes];
+  int id_;
+  int reference_count_;
+  Libgav1FrameBuffer gav1_frame_buffer_ = {};
+};
+
+// Manages frame buffers used by libgav1 decoder and ExoPlayer.
+// Handles synchronization between libgav1 and ExoPlayer threads.
+class JniBufferManager {
+ public:
+  ~JniBufferManager() {
+    // This lock does not do anything since libgav1 has released all the frame
+    // buffers. It exists to merely be consistent with all other usage of
+    // |all_buffers_| and |all_buffer_count_|.
+    std::lock_guard<std::mutex> lock(mutex_);
+    while (all_buffer_count_--) {
+      delete all_buffers_[all_buffer_count_];
+    }
+  }
+
+  JniStatusCode GetBuffer(size_t y_plane_min_size, size_t uv_plane_min_size,
+                          Libgav1FrameBuffer* frame_buffer) {
+    std::lock_guard<std::mutex> lock(mutex_);
+
+    JniFrameBuffer* output_buffer;
+    if (free_buffer_count_) {
+      output_buffer = free_buffers_[--free_buffer_count_];
+    } else if (all_buffer_count_ < kMaxFrames) {
+      output_buffer = new (std::nothrow) JniFrameBuffer(all_buffer_count_);
+      if (output_buffer == nullptr) return kJniStatusOutOfMemory;
+      all_buffers_[all_buffer_count_++] = output_buffer;
+    } else {
+      // Maximum number of buffers is being used.
+      return kJniStatusOutOfMemory;
+    }
+    if (!output_buffer->MaybeReallocateGav1DataPlanes(y_plane_min_size,
+                                                      uv_plane_min_size)) {
+      return kJniStatusOutOfMemory;
+    }
+
+    output_buffer->AddReference();
+    *frame_buffer = output_buffer->GetGav1FrameBuffer();
+
+    return kJniStatusOk;
+  }
+
+  JniFrameBuffer* GetBuffer(int id) const { return all_buffers_[id]; }
+
+  void AddBufferReference(int id) {
+    std::lock_guard<std::mutex> lock(mutex_);
+    all_buffers_[id]->AddReference();
+  }
+
+  JniStatusCode ReleaseBuffer(int id) {
+    std::lock_guard<std::mutex> lock(mutex_);
+    JniFrameBuffer* buffer = all_buffers_[id];
+    if (!buffer->InUse()) {
+      return kJniStatusBufferAlreadyReleased;
+    }
+    buffer->RemoveReference();
+    if (!buffer->InUse()) {
+      free_buffers_[free_buffer_count_++] = buffer;
+    }
+    return kJniStatusOk;
+  }
+
+ private:
+  static const int kMaxFrames = 32;
+
+  JniFrameBuffer* all_buffers_[kMaxFrames];
+  int all_buffer_count_ = 0;
+
+  JniFrameBuffer* free_buffers_[kMaxFrames];
+  int free_buffer_count_ = 0;
+
+  std::mutex mutex_;
+};
+
+struct JniContext {
+  ~JniContext() {
+    if (native_window) {
+      ANativeWindow_release(native_window);
+    }
+  }
+
+  bool MaybeAcquireNativeWindow(JNIEnv* env, jobject new_surface) {
+    if (surface == new_surface) {
+      return true;
+    }
+    if (native_window) {
+      ANativeWindow_release(native_window);
+    }
+    native_window_width = 0;
+    native_window_height = 0;
+    native_window = ANativeWindow_fromSurface(env, new_surface);
+    if (native_window == nullptr) {
+      jni_status_code = kJniStatusANativeWindowError;
+      surface = nullptr;
+      return false;
+    }
+    surface = new_surface;
+    return true;
+  }
+
+  jfieldID decoder_private_field;
+  jfieldID output_mode_field;
+  jfieldID data_field;
+  jmethodID init_for_private_frame_method;
+  jmethodID init_for_yuv_frame_method;
+
+  JniBufferManager buffer_manager;
+  // The libgav1 decoder instance has to be deleted before |buffer_manager| is
+  // destructed. This will make sure that libgav1 releases all the frame
+  // buffers that it might be holding references to. So this has to be declared
+  // after |buffer_manager| since the destruction happens in reverse order of
+  // declaration.
+  libgav1::Decoder decoder;
+
+  ANativeWindow* native_window = nullptr;
+  jobject surface = nullptr;
+  int native_window_width = 0;
+  int native_window_height = 0;
+
+  Libgav1StatusCode libgav1_status_code = kLibgav1StatusOk;
+  JniStatusCode jni_status_code = kJniStatusOk;
+};
+
+int Libgav1GetFrameBuffer(void* private_data, size_t y_plane_min_size,
+                          size_t uv_plane_min_size,
+                          Libgav1FrameBuffer* frame_buffer) {
+  JniContext* const context = reinterpret_cast<JniContext*>(private_data);
+  context->jni_status_code = context->buffer_manager.GetBuffer(
+      y_plane_min_size, uv_plane_min_size, frame_buffer);
+  if (context->jni_status_code != kJniStatusOk) {
+    LOGE("%s", GetJniErrorMessage(context->jni_status_code));
+    return -1;
+  }
+  return 0;
+}
+
+int Libgav1ReleaseFrameBuffer(void* private_data,
+                              Libgav1FrameBuffer* frame_buffer) {
+  JniContext* const context = reinterpret_cast<JniContext*>(private_data);
+  const int buffer_id = *reinterpret_cast<int*>(frame_buffer->private_data);
+  context->jni_status_code = context->buffer_manager.ReleaseBuffer(buffer_id);
+  if (context->jni_status_code != kJniStatusOk) {
+    LOGE("%s", GetJniErrorMessage(context->jni_status_code));
+    return -1;
+  }
+  return 0;
+}
+
+constexpr int AlignTo16(int value) { return (value + 15) & (~15); }
+
+void CopyPlane(const uint8_t* source, int source_stride, uint8_t* destination,
+               int destination_stride, int width, int height) {
+  while (height--) {
+    std::memcpy(destination, source, width);
+    source += source_stride;
+    destination += destination_stride;
+  }
+}
+
+void CopyFrameToDataBuffer(const libgav1::DecoderBuffer* decoder_buffer,
+                           jbyte* data) {
+  for (int plane_index = kPlaneY; plane_index < decoder_buffer->NumPlanes();
+       plane_index++) {
+    const uint64_t length = decoder_buffer->stride[plane_index] *
+                            decoder_buffer->displayed_height[plane_index];
+    memcpy(data, decoder_buffer->plane[plane_index], length);
+    data += length;
+  }
+}
+
+void Convert10BitFrameTo8BitDataBuffer(
+    const libgav1::DecoderBuffer* decoder_buffer, jbyte* data) {
+  for (int plane_index = kPlaneY; plane_index < decoder_buffer->NumPlanes();
+       plane_index++) {
+    int sample = 0;
+    const uint8_t* source = decoder_buffer->plane[plane_index];
+    for (int i = 0; i < decoder_buffer->displayed_height[plane_index]; i++) {
+      const uint16_t* source_16 = reinterpret_cast<const uint16_t*>(source);
+      for (int j = 0; j < decoder_buffer->displayed_width[plane_index]; j++) {
+        // Lightweight dither. Carryover the remainder of each 10->8 bit
+        // conversion to the next pixel.
+        sample += source_16[j];
+        data[j] = sample >> 2;
+        sample &= 3;  // Remainder.
+      }
+      source += decoder_buffer->stride[plane_index];
+      data += decoder_buffer->stride[plane_index];
+    }
+  }
+}
+
+#ifdef CPU_FEATURES_COMPILED_ANY_ARM_NEON
+void Convert10BitFrameTo8BitDataBufferNeon(
+    const libgav1::DecoderBuffer* decoder_buffer, jbyte* data) {
+  uint32x2_t lcg_value = vdup_n_u32(random());
+  lcg_value = vset_lane_u32(random(), lcg_value, 1);
+  // LCG values recommended in "Numerical Recipes".
+  const uint32x2_t LCG_MULT = vdup_n_u32(1664525);
+  const uint32x2_t LCG_INCR = vdup_n_u32(1013904223);
+
+  for (int plane_index = kPlaneY; plane_index < kMaxPlanes; plane_index++) {
+    const uint8_t* source = decoder_buffer->plane[plane_index];
+
+    for (int i = 0; i < decoder_buffer->displayed_height[plane_index]; i++) {
+      const uint16_t* source_16 = reinterpret_cast<const uint16_t*>(source);
+      uint8_t* destination = reinterpret_cast<uint8_t*>(data);
+
+      // Each read consumes 4 2-byte samples, but to reduce branches and
+      // random steps we unroll to 4 rounds, so each loop consumes 16
+      // samples.
+      const int j_max = decoder_buffer->displayed_width[plane_index] & ~15;
+      int j;
+      for (j = 0; j < j_max; j += 16) {
+        // Run a round of the RNG.
+        lcg_value = vmla_u32(LCG_INCR, lcg_value, LCG_MULT);
+
+        // Round 1.
+        // The lower two bits of this LCG parameterization are garbage,
+        // leaving streaks on the image. We access the upper bits of each
+        // 16-bit lane by shifting. (We use this both as an 8- and 16-bit
+        // vector, so the choice of which one to keep it as is arbitrary.)
+        uint8x8_t randvec =
+            vreinterpret_u8_u16(vshr_n_u16(vreinterpret_u16_u32(lcg_value), 8));
+
+        // We retrieve the values and shift them so that the bits we'll
+        // shift out (after biasing) are in the upper 8 bits of each 16-bit
+        // lane.
+        uint16x4_t values = vshl_n_u16(vld1_u16(source_16), 6);
+        // We add the bias bits in the lower 8 to the shifted values to get
+        // the final values in the upper 8 bits.
+        uint16x4_t added_1 = vqadd_u16(values, vreinterpret_u16_u8(randvec));
+        source_16 += 4;
+
+        // Round 2.
+        // Shifting the randvec bits left by 2 bits, as an 8-bit vector,
+        // should leave us with enough bias to get the needed rounding
+        // operation.
+        randvec = vshl_n_u8(randvec, 2);
+
+        // Retrieve and sum the next 4 pixels.
+        values = vshl_n_u16(vld1_u16(source_16), 6);
+        uint16x4_t added_2 = vqadd_u16(values, vreinterpret_u16_u8(randvec));
+        source_16 += 4;
+
+        // Reinterpret the two added vectors as 8x8, zip them together, and
+        // discard the lower portions.
+        uint8x8_t zipped =
+            vuzp_u8(vreinterpret_u8_u16(added_1), vreinterpret_u8_u16(added_2))
+                .val[1];
+        vst1_u8(destination, zipped);
+        destination += 8;
+
+        // Run it again with the next two rounds using the remaining
+        // entropy in randvec.
+
+        // Round 3.
+        randvec = vshl_n_u8(randvec, 2);
+        values = vshl_n_u16(vld1_u16(source_16), 6);
+        added_1 = vqadd_u16(values, vreinterpret_u16_u8(randvec));
+        source_16 += 4;
+
+        // Round 4.
+        randvec = vshl_n_u8(randvec, 2);
+        values = vshl_n_u16(vld1_u16(source_16), 6);
+        added_2 = vqadd_u16(values, vreinterpret_u16_u8(randvec));
+        source_16 += 4;
+
+        zipped =
+            vuzp_u8(vreinterpret_u8_u16(added_1), vreinterpret_u8_u16(added_2))
+                .val[1];
+        vst1_u8(destination, zipped);
+        destination += 8;
+      }
+
+      uint32_t randval = 0;
+      // For the remaining pixels in each row - usually none, as most
+      // standard sizes are divisible by 32 - convert them "by hand".
+      for (; j < decoder_buffer->displayed_width[plane_index]; j++) {
+        if (!randval) randval = random();
+        destination[j] = (source_16[j] + (randval & 3)) >> 2;
+        randval >>= 2;
+      }
+
+      source += decoder_buffer->stride[plane_index];
+      data += decoder_buffer->stride[plane_index];
+    }
+  }
+}
+#endif  // CPU_FEATURES_COMPILED_ANY_ARM_NEON
+
+}  // namespace
+
+DECODER_FUNC(jlong, gav1Init, jint threads) {
+  JniContext* context = new (std::nothrow) JniContext();
+  if (context == nullptr) {
+    return kStatusError;
+  }
+
+#ifdef CPU_FEATURES_ARCH_ARM
+  // Libgav1 requires NEON with arm ABIs.
+#ifdef CPU_FEATURES_COMPILED_ANY_ARM_NEON
+  const cpu_features::ArmFeatures arm_features =
+      cpu_features::GetArmInfo().features;
+  if (!arm_features.neon) {
+    context->jni_status_code = kJniStatusNeonNotSupported;
+    return reinterpret_cast<jlong>(context);
+  }
+#else
+  context->jni_status_code = kJniStatusNeonNotSupported;
+  return reinterpret_cast<jlong>(context);
+#endif  // CPU_FEATURES_COMPILED_ANY_ARM_NEON
+#endif  // CPU_FEATURES_ARCH_ARM
+
+  libgav1::DecoderSettings settings;
+  settings.threads = threads;
+  settings.get = Libgav1GetFrameBuffer;
+  settings.release = Libgav1ReleaseFrameBuffer;
+  settings.callback_private_data = context;
+
+  context->libgav1_status_code = context->decoder.Init(&settings);
+  if (context->libgav1_status_code != kLibgav1StatusOk) {
+    return reinterpret_cast<jlong>(context);
+  }
+
+  // Populate JNI References.
+  const jclass outputBufferClass = env->FindClass(
+      "com/google/android/exoplayer2/video/VideoDecoderOutputBuffer");
+  context->decoder_private_field =
+      env->GetFieldID(outputBufferClass, "decoderPrivate", "I");
+  context->output_mode_field = env->GetFieldID(outputBufferClass, "mode", "I");
+  context->data_field =
+      env->GetFieldID(outputBufferClass, "data", "Ljava/nio/ByteBuffer;");
+  context->init_for_private_frame_method =
+      env->GetMethodID(outputBufferClass, "initForPrivateFrame", "(II)V");
+  context->init_for_yuv_frame_method =
+      env->GetMethodID(outputBufferClass, "initForYuvFrame", "(IIIII)Z");
+
+  return reinterpret_cast<jlong>(context);
+}
+
+DECODER_FUNC(void, gav1Close, jlong jContext) {
+  JniContext* const context = reinterpret_cast<JniContext*>(jContext);
+  delete context;
+}
+
+DECODER_FUNC(jint, gav1Decode, jlong jContext, jobject encodedData,
+             jint length) {
+  JniContext* const context = reinterpret_cast<JniContext*>(jContext);
+  const uint8_t* const buffer = reinterpret_cast<const uint8_t*>(
+      env->GetDirectBufferAddress(encodedData));
+  context->libgav1_status_code =
+      context->decoder.EnqueueFrame(buffer, length, /*user_private_data=*/0);
+  if (context->libgav1_status_code != kLibgav1StatusOk) {
+    return kStatusError;
+  }
+  return kStatusOk;
+}
+
+DECODER_FUNC(jint, gav1GetFrame, jlong jContext, jobject jOutputBuffer,
+             jboolean decodeOnly) {
+  JniContext* const context = reinterpret_cast<JniContext*>(jContext);
+  const libgav1::DecoderBuffer* decoder_buffer;
+  context->libgav1_status_code = context->decoder.DequeueFrame(&decoder_buffer);
+  if (context->libgav1_status_code != kLibgav1StatusOk) {
+    return kStatusError;
+  }
+
+  if (decodeOnly || decoder_buffer == nullptr) {
+    // This is not an error. The input data was decode-only or no displayable
+    // frames are available.
+    return kStatusDecodeOnly;
+  }
+
+  const int output_mode =
+      env->GetIntField(jOutputBuffer, context->output_mode_field);
+  if (output_mode == kOutputModeYuv) {
+    // Resize the buffer if required. Default color conversion will be used as
+    // libgav1::DecoderBuffer doesn't expose color space info.
+    const jboolean init_result = env->CallBooleanMethod(
+        jOutputBuffer, context->init_for_yuv_frame_method,
+        decoder_buffer->displayed_width[kPlaneY],
+        decoder_buffer->displayed_height[kPlaneY],
+        decoder_buffer->stride[kPlaneY], decoder_buffer->stride[kPlaneU],
+        kColorSpaceUnknown);
+    if (env->ExceptionCheck()) {
+      // Exception is thrown in Java when returning from the native call.
+      return kStatusError;
+    }
+    if (!init_result) {
+      context->jni_status_code = kJniStatusBufferResizeError;
+      return kStatusError;
+    }
+
+    const jobject data_object =
+        env->GetObjectField(jOutputBuffer, context->data_field);
+    jbyte* const data =
+        reinterpret_cast<jbyte*>(env->GetDirectBufferAddress(data_object));
+
+    switch (decoder_buffer->bitdepth) {
+      case 8:
+        CopyFrameToDataBuffer(decoder_buffer, data);
+        break;
+      case 10:
+#ifdef CPU_FEATURES_COMPILED_ANY_ARM_NEON
+        Convert10BitFrameTo8BitDataBufferNeon(decoder_buffer, data);
+#else
+        Convert10BitFrameTo8BitDataBuffer(decoder_buffer, data);
+#endif  // CPU_FEATURES_COMPILED_ANY_ARM_NEON
+        break;
+      default:
+        context->jni_status_code = kJniStatusBitDepth12NotSupportedWithYuv;
+        return kStatusError;
+    }
+  } else if (output_mode == kOutputModeSurfaceYuv) {
+    if (decoder_buffer->bitdepth != 8) {
+      context->jni_status_code =
+          kJniStatusHighBitDepthNotSupportedWithSurfaceYuv;
+      return kStatusError;
+    }
+
+    if (decoder_buffer->NumPlanes() > kMaxPlanes) {
+      context->jni_status_code = kJniStatusInvalidNumOfPlanes;
+      return kStatusError;
+    }
+
+    const int buffer_id =
+        *reinterpret_cast<int*>(decoder_buffer->buffer_private_data);
+    context->buffer_manager.AddBufferReference(buffer_id);
+    JniFrameBuffer* const jni_buffer =
+        context->buffer_manager.GetBuffer(buffer_id);
+    jni_buffer->SetFrameData(*decoder_buffer);
+    env->CallVoidMethod(jOutputBuffer, context->init_for_private_frame_method,
+                        decoder_buffer->displayed_width[kPlaneY],
+                        decoder_buffer->displayed_height[kPlaneY]);
+    if (env->ExceptionCheck()) {
+      // Exception is thrown in Java when returning from the native call.
+      return kStatusError;
+    }
+    env->SetIntField(jOutputBuffer, context->decoder_private_field, buffer_id);
+  }
+
+  return kStatusOk;
+}
+
+DECODER_FUNC(jint, gav1RenderFrame, jlong jContext, jobject jSurface,
+             jobject jOutputBuffer) {
+  JniContext* const context = reinterpret_cast<JniContext*>(jContext);
+  const int buffer_id =
+      env->GetIntField(jOutputBuffer, context->decoder_private_field);
+  JniFrameBuffer* const jni_buffer =
+      context->buffer_manager.GetBuffer(buffer_id);
+
+  if (!context->MaybeAcquireNativeWindow(env, jSurface)) {
+    return kStatusError;
+  }
+
+  if (context->native_window_width != jni_buffer->DisplayedWidth(kPlaneY) ||
+      context->native_window_height != jni_buffer->DisplayedHeight(kPlaneY)) {
+    if (ANativeWindow_setBuffersGeometry(
+            context->native_window, jni_buffer->DisplayedWidth(kPlaneY),
+            jni_buffer->DisplayedHeight(kPlaneY), kImageFormatYV12)) {
+      context->jni_status_code = kJniStatusANativeWindowError;
+      return kStatusError;
+    }
+    context->native_window_width = jni_buffer->DisplayedWidth(kPlaneY);
+    context->native_window_height = jni_buffer->DisplayedHeight(kPlaneY);
+  }
+
+  ANativeWindow_Buffer native_window_buffer;
+  if (ANativeWindow_lock(context->native_window, &native_window_buffer,
+                         /*inOutDirtyBounds=*/nullptr) ||
+      native_window_buffer.bits == nullptr) {
+    context->jni_status_code = kJniStatusANativeWindowError;
+    return kStatusError;
+  }
+
+  // Y plane
+  CopyPlane(jni_buffer->Plane(kPlaneY), jni_buffer->Stride(kPlaneY),
+            reinterpret_cast<uint8_t*>(native_window_buffer.bits),
+            native_window_buffer.stride, jni_buffer->DisplayedWidth(kPlaneY),
+            jni_buffer->DisplayedHeight(kPlaneY));
+
+  const int y_plane_size =
+      native_window_buffer.stride * native_window_buffer.height;
+  const int32_t native_window_buffer_uv_height =
+      (native_window_buffer.height + 1) / 2;
+  const int native_window_buffer_uv_stride =
+      AlignTo16(native_window_buffer.stride / 2);
+
+  // TODO(b/140606738): Handle monochrome videos.
+
+  // V plane
+  // Since the format for ANativeWindow is YV12, V plane is being processed
+  // before U plane.
+  const int v_plane_height = std::min(native_window_buffer_uv_height,
+                                      jni_buffer->DisplayedHeight(kPlaneV));
+  CopyPlane(
+      jni_buffer->Plane(kPlaneV), jni_buffer->Stride(kPlaneV),
+      reinterpret_cast<uint8_t*>(native_window_buffer.bits) + y_plane_size,
+      native_window_buffer_uv_stride, jni_buffer->DisplayedWidth(kPlaneV),
+      v_plane_height);
+
+  const int v_plane_size = v_plane_height * native_window_buffer_uv_stride;
+
+  // U plane
+  CopyPlane(jni_buffer->Plane(kPlaneU), jni_buffer->Stride(kPlaneU),
+            reinterpret_cast<uint8_t*>(native_window_buffer.bits) +
+                y_plane_size + v_plane_size,
+            native_window_buffer_uv_stride, jni_buffer->DisplayedWidth(kPlaneU),
+            std::min(native_window_buffer_uv_height,
+                     jni_buffer->DisplayedHeight(kPlaneU)));
+
+  if (ANativeWindow_unlockAndPost(context->native_window)) {
+    context->jni_status_code = kJniStatusANativeWindowError;
+    return kStatusError;
+  }
+
+  return kStatusOk;
+}
+
+DECODER_FUNC(void, gav1ReleaseFrame, jlong jContext, jobject jOutputBuffer) {
+  JniContext* const context = reinterpret_cast<JniContext*>(jContext);
+  const int buffer_id =
+      env->GetIntField(jOutputBuffer, context->decoder_private_field);
+  env->SetIntField(jOutputBuffer, context->decoder_private_field, -1);
+  context->jni_status_code = context->buffer_manager.ReleaseBuffer(buffer_id);
+  if (context->jni_status_code != kJniStatusOk) {
+    LOGE("%s", GetJniErrorMessage(context->jni_status_code));
+  }
+}
+
+DECODER_FUNC(jstring, gav1GetErrorMessage, jlong jContext) {
+  if (jContext == 0) {
+    return env->NewStringUTF("Failed to initialize JNI context.");
+  }
+
+  JniContext* const context = reinterpret_cast<JniContext*>(jContext);
+  if (context->libgav1_status_code != kLibgav1StatusOk) {
+    return env->NewStringUTF(
+        libgav1::GetErrorString(context->libgav1_status_code));
+  }
+  if (context->jni_status_code != kJniStatusOk) {
+    return env->NewStringUTF(GetJniErrorMessage(context->jni_status_code));
+  }
+
+  return env->NewStringUTF("None.");
+}
+
+DECODER_FUNC(jint, gav1CheckError, jlong jContext) {
+  JniContext* const context = reinterpret_cast<JniContext*>(jContext);
+  if (context->libgav1_status_code != kLibgav1StatusOk ||
+      context->jni_status_code != kJniStatusOk) {
+    return kStatusError;
+  }
+  return kStatusOk;
+}
+
+// TODO(b/139902005): Add functions for getting libgav1 version and build
+// configuration once libgav1 ABI provides this information.
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
index 147f769a98..d5bc72fbaf 100644
--- a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -134,7 +134,7 @@ public CastPlayer(CastContext castContext) {
     currentTrackSelection = EMPTY_TRACK_SELECTION_ARRAY;
     pendingSeekWindowIndex = C.INDEX_UNSET;
     pendingSeekPositionMs = C.TIME_UNSET;
-    maybeUpdateInternalState();
+    updateInternalStateAndNotifyIfChanged();
   }
 
   // Media Queue manipulation methods.
@@ -346,19 +346,20 @@ public void setPlayWhenReady(boolean playWhenReady) {
     if (remoteMediaClient == null) {
       return;
     }
-    // We send the message to the receiver app and update the local state, which will cause the
-    // operation to be perceived as synchronous by the user.
+    // We update the local state and send the message to the receiver app, which will cause the
+    // operation to be perceived as synchronous by the user. When the operation reports a result,
+    // the local state will be updated to reflect the state reported by the Cast SDK.
+    setPlayerStateAndNotifyIfChanged(playWhenReady, playbackState);
+    flushNotifications();
     PendingResult<MediaChannelResult> pendingResult =
         playWhenReady ? remoteMediaClient.play() : remoteMediaClient.pause();
     pendingResult.setResultCallback(
         mediaChannelResult -> {
           if (remoteMediaClient != null) {
-            maybeUpdatePlayerStateAndNotify();
+            updatePlayerStateAndNotifyIfChanged();
             flushNotifications();
           }
         });
-    maybeSetPlayerStateAndNotify(playWhenReady, playbackState);
-    flushNotifications();
   }
 
   @Override
@@ -439,9 +440,23 @@ public int getRendererType(int index) {
 
   @Override
   public void setRepeatMode(@RepeatMode int repeatMode) {
-    if (remoteMediaClient != null) {
-      remoteMediaClient.queueSetRepeatMode(getCastRepeatMode(repeatMode), null);
+    if (remoteMediaClient == null) {
+      return;
     }
+    // We update the local state and send the message to the receiver app, which will cause the
+    // operation to be perceived as synchronous by the user. When the operation reports a result,
+    // the local state will be updated to reflect the state reported by the Cast SDK.
+    setRepeatModeAndNotifyIfChanged(repeatMode);
+    flushNotifications();
+    remoteMediaClient
+        .queueSetRepeatMode(getCastRepeatMode(repeatMode), /* jsonObject= */ null)
+        .setResultCallback(
+            mediaChannelResult -> {
+              if (remoteMediaClient != null) {
+                updateRepeatModeAndNotifyIfChanged();
+                flushNotifications();
+              }
+            });
   }
 
   @Override
@@ -547,26 +562,20 @@ public long getContentBufferedPosition() {
 
   // Internal methods.
 
-  private void maybeUpdateInternalState() {
+  private void updateInternalStateAndNotifyIfChanged() {
     if (remoteMediaClient == null) {
       // There is no session. We leave the state of the player as it is now.
       return;
     }
-
     boolean wasPlaying = playbackState == Player.STATE_READY && playWhenReady;
-    maybeUpdatePlayerStateAndNotify();
+    updatePlayerStateAndNotifyIfChanged();
     boolean isPlaying = playbackState == Player.STATE_READY && playWhenReady;
     if (wasPlaying != isPlaying) {
       notificationsBatch.add(
           new ListenerNotificationTask(listener -> listener.onIsPlayingChanged(isPlaying)));
     }
-    @RepeatMode int repeatMode = fetchRepeatMode(remoteMediaClient);
-    if (this.repeatMode != repeatMode) {
-      this.repeatMode = repeatMode;
-      notificationsBatch.add(
-          new ListenerNotificationTask(listener -> listener.onRepeatModeChanged(this.repeatMode)));
-    }
-    maybeUpdateTimelineAndNotify();
+    updateRepeatModeAndNotifyIfChanged();
+    updateTimelineAndNotifyIfChanged();
 
     int currentWindowIndex = C.INDEX_UNSET;
     MediaQueueItem currentItem = remoteMediaClient.getCurrentItem();
@@ -584,7 +593,7 @@ private void maybeUpdateInternalState() {
               listener ->
                   listener.onPositionDiscontinuity(DISCONTINUITY_REASON_PERIOD_TRANSITION)));
     }
-    if (updateTracksAndSelections()) {
+    if (updateTracksAndSelectionsAndNotifyIfChanged()) {
       notificationsBatch.add(
           new ListenerNotificationTask(
               listener -> listener.onTracksChanged(currentTrackGroups, currentTrackSelection)));
@@ -593,12 +602,17 @@ private void maybeUpdateInternalState() {
   }
 
   @RequiresNonNull("remoteMediaClient")
-  private void maybeUpdatePlayerStateAndNotify() {
-    maybeSetPlayerStateAndNotify(
+  private void updatePlayerStateAndNotifyIfChanged() {
+    setPlayerStateAndNotifyIfChanged(
         !remoteMediaClient.isPaused(), fetchPlaybackState(remoteMediaClient));
   }
 
-  private void maybeUpdateTimelineAndNotify() {
+  @RequiresNonNull("remoteMediaClient")
+  private void updateRepeatModeAndNotifyIfChanged() {
+    setRepeatModeAndNotifyIfChanged(fetchRepeatMode(remoteMediaClient));
+  }
+
+  private void updateTimelineAndNotifyIfChanged() {
     if (updateTimeline()) {
       @Player.TimelineChangeReason
       int reason =
@@ -625,10 +639,8 @@ private boolean updateTimeline() {
     return !oldTimeline.equals(currentTimeline);
   }
 
-  /**
-   * Updates the internal tracks and selection and returns whether they have changed.
-   */
-  private boolean updateTracksAndSelections() {
+  /** Updates the internal tracks and selection and returns whether they have changed. */
+  private boolean updateTracksAndSelectionsAndNotifyIfChanged() {
     if (remoteMediaClient == null) {
       // There is no session. We leave the state of the player as it is now.
       return false;
@@ -674,7 +686,15 @@ private boolean updateTracksAndSelections() {
     return false;
   }
 
-  private void maybeSetPlayerStateAndNotify(
+  private void setRepeatModeAndNotifyIfChanged(@Player.RepeatMode int repeatMode) {
+    if (this.repeatMode != repeatMode) {
+      this.repeatMode = repeatMode;
+      notificationsBatch.add(
+          new ListenerNotificationTask(listener -> listener.onRepeatModeChanged(repeatMode)));
+    }
+  }
+
+  private void setPlayerStateAndNotifyIfChanged(
       boolean playWhenReady, @Player.State int playbackState) {
     if (this.playWhenReady != playWhenReady || this.playbackState != playbackState) {
       this.playWhenReady = playWhenReady;
@@ -701,7 +721,7 @@ private void setRemoteMediaClient(@Nullable RemoteMediaClient remoteMediaClient)
       }
       remoteMediaClient.addListener(statusListener);
       remoteMediaClient.addProgressListener(statusListener, PROGRESS_REPORT_PERIOD_MS);
-      maybeUpdateInternalState();
+      updateInternalStateAndNotifyIfChanged();
     } else {
       if (sessionAvailabilityListener != null) {
         sessionAvailabilityListener.onCastSessionUnavailable();
@@ -820,7 +840,7 @@ public void onProgressUpdated(long progressMs, long unusedDurationMs) {
 
     @Override
     public void onStatusUpdated() {
-      maybeUpdateInternalState();
+      updateInternalStateAndNotifyIfChanged();
     }
 
     @Override
@@ -828,7 +848,7 @@ public void onMetadataUpdated() {}
 
     @Override
     public void onQueueStatusUpdated() {
-      maybeUpdateTimelineAndNotify();
+      updateTimelineAndNotifyIfChanged();
     }
 
     @Override
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index b7ea254a6c..a2e8736f82 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -107,11 +107,26 @@ a custom track selector the choice of `Renderer` is up to your implementation,
 so you need to make sure you are passing an `LibvpxVideoRenderer` to the
 player, then implement your own logic to use the renderer for a given track.
 
-`LibvpxVideoRenderer` can optionally output to a `VideoDecoderSurfaceView` when
-not being used via `SimpleExoPlayer`, in which case color space conversion will
-be performed using a GL shader. To enable this mode, send the renderer a message
-of type `C.MSG_SET_OUTPUT_BUFFER_RENDERER` with the `VideoDecoderSurfaceView` as
-its object, instead of sending `MSG_SET_SURFACE` with a `Surface`.
+## Rendering options ##
+
+There are two possibilities for rendering the output `LibvpxVideoRenderer`
+gets from the libvpx decoder:
+
+* GL rendering using GL shader for color space conversion
+  * If you are using `SimpleExoPlayer` with `PlayerView`, enable this option by
+    setting `surface_type` of `PlayerView` to be `video_decoder_surface_view`.
+  * Otherwise, enable this option by sending `LibvpxVideoRenderer` a message of
+    type `C.MSG_SET_OUTPUT_BUFFER_RENDERER` with an instance of
+    `VideoDecoderOutputBufferRenderer` as its object.
+
+* Native rendering using `ANativeWindow`
+  * If you are using `SimpleExoPlayer` with `PlayerView`, this option is enabled
+    by default.
+  * Otherwise, enable this option by sending `LibvpxVideoRenderer` a message of
+    type `C.MSG_SET_SURFACE` with an instance of `SurfaceView` as its object.
+
+Note: Although the default option uses `ANativeWindow`, based on our testing the
+GL rendering mode has better performance, so should be preferred.
 
 ## Links ##
 
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index 3dd039118c..85ceabc909 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -124,7 +124,7 @@ public void run() {
       player
           .createMessage(videoRenderer)
           .setType(C.MSG_SET_OUTPUT_BUFFER_RENDERER)
-          .setPayload(new VideoDecoderSurfaceView(context))
+          .setPayload(new VideoDecoderSurfaceView(context).getOutputBufferRenderer())
           .send();
       player.prepare(mediaSource);
       player.setPlayWhenReady(true);
diff --git a/extensions/vp9/src/main/METADATA b/extensions/vp9/src/main/METADATA
deleted file mode 100644
index 7510fdadc0..0000000000
--- a/extensions/vp9/src/main/METADATA
+++ /dev/null
@@ -1,9 +0,0 @@
-# Format: google3/devtools/metadata/metadata.proto (go/google3metadata)
-
-tricorder: {
-  options: {
-    builder: {
-      config: "android"
-    }
-  }
-}
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index ec4f3f7903..31195a3070 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -238,7 +238,7 @@ protected void renderOutputBuffer(
       throws VideoDecoderException {
     if (frameMetadataListener != null) {
       frameMetadataListener.onVideoFrameAboutToBeRendered(
-          presentationTimeUs, System.nanoTime(), outputFormat);
+          presentationTimeUs, System.nanoTime(), outputFormat, /* mediaFormat= */ null);
     }
     super.renderOutputBuffer(outputBuffer, presentationTimeUs, outputFormat);
   }
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 6d00e1ce97..7fefd1c665 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Thu Apr 25 13:15:25 BST 2019
+#Mon Oct 07 17:24:00 BST 2019
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index b235715f46..a86d927acb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -521,6 +521,7 @@ private C() {}
   /** Indicates that a buffer should be decoded but not rendered. */
   public static final int BUFFER_FLAG_DECODE_ONLY = 1 << 31; // 0x80000000
 
+  // LINT.IfChange
   /**
    * Video decoder output modes. Possible modes are {@link #VIDEO_OUTPUT_MODE_NONE}, {@link
    * #VIDEO_OUTPUT_MODE_YUV} and {@link #VIDEO_OUTPUT_MODE_SURFACE_YUV}.
@@ -535,6 +536,10 @@ private C() {}
   public static final int VIDEO_OUTPUT_MODE_YUV = 0;
   /** Video decoder output mode that renders 4:2:0 YUV planes directly to a surface. */
   public static final int VIDEO_OUTPUT_MODE_SURFACE_YUV = 1;
+  // LINT.ThenChange(
+  //     ../../../../../../../../../extensions/av1/src/main/jni/gav1_jni.cc,
+  //     ../../../../../../../../../extensions/vp9/src/main/jni/vpx_jni.cc
+  // )
 
   /**
    * Video scaling modes for {@link MediaCodec}-based {@link Renderer}s. One of {@link
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index a97b1e0d5a..f53d72f598 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -365,6 +365,33 @@ protected void buildVideoRenderers(
       // The extension is present, but instantiation failed.
       throw new RuntimeException("Error instantiating VP9 extension", e);
     }
+
+    try {
+      // Full class names used for constructor args so the LINT rule triggers if any of them move.
+      // LINT.IfChange
+      Class<?> clazz = Class.forName("com.google.android.exoplayer2.ext.av1.Libgav1VideoRenderer");
+      Constructor<?> constructor =
+          clazz.getConstructor(
+              long.class,
+              android.os.Handler.class,
+              com.google.android.exoplayer2.video.VideoRendererEventListener.class,
+              int.class);
+      // LINT.ThenChange(../../../../../../../proguard-rules.txt)
+      Renderer renderer =
+          (Renderer)
+              constructor.newInstance(
+                  allowedVideoJoiningTimeMs,
+                  eventHandler,
+                  eventListener,
+                  MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
+      out.add(extensionRendererIndex++, renderer);
+      Log.i(TAG, "Loaded Libgav1VideoRenderer.");
+    } catch (ClassNotFoundException e) {
+      // Expected if the app was built without the extension.
+    } catch (Exception e) {
+      // The extension is present, but instantiation failed.
+      throw new RuntimeException("Error instantiating AV1 extension", e);
+    }
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Player.java b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
index 5f00916892..1c0dd4ca0a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -31,6 +31,7 @@
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBufferRenderer;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
@@ -280,6 +281,13 @@
      * @param textureView The texture view to clear.
      */
     void clearVideoTextureView(TextureView textureView);
+
+    /**
+     * Sets the output buffer renderer.
+     *
+     * @param outputBufferRenderer The output buffer renderer.
+     */
+    void setOutputBufferRenderer(VideoDecoderOutputBufferRenderer outputBufferRenderer);
   }
 
   /** The text component of a {@link Player}. */
@@ -721,7 +729,7 @@ public void onTimelineChanged(Timeline timeline, @Nullable Object manifest) {
   /**
    * Sets the {@link RepeatMode} to be used for playback.
    *
-   * @param repeatMode A repeat mode.
+   * @param repeatMode The repeat mode.
    */
   void setRepeatMode(@RepeatMode int repeatMode);
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index d7861da797..ab99994267 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -55,6 +55,7 @@
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.PriorityTaskManager;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoDecoderOutputBufferRenderer;
 import com.google.android.exoplayer2.video.VideoFrameMetadataListener;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
 import com.google.android.exoplayer2.video.spherical.CameraMotionListener;
@@ -584,8 +585,8 @@ public void setVideoTextureView(TextureView textureView) {
         Log.w(TAG, "Replacing existing SurfaceTextureListener.");
       }
       textureView.setSurfaceTextureListener(componentListener);
-      SurfaceTexture surfaceTexture = textureView.isAvailable() ? textureView.getSurfaceTexture()
-          : null;
+      SurfaceTexture surfaceTexture =
+          textureView.isAvailable() ? textureView.getSurfaceTexture() : null;
       if (surfaceTexture == null) {
         setVideoSurfaceInternal(/* surface= */ null, /* ownsSurface= */ true);
         maybeNotifySurfaceSizeChanged(/* width= */ 0, /* height= */ 0);
@@ -604,6 +605,23 @@ public void clearVideoTextureView(TextureView textureView) {
     }
   }
 
+  @Override
+  public void setOutputBufferRenderer(VideoDecoderOutputBufferRenderer outputBufferRenderer) {
+    verifyApplicationThread();
+    removeSurfaceCallbacks();
+    List<PlayerMessage> messages = new ArrayList<>();
+    for (Renderer renderer : renderers) {
+      if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
+        messages.add(
+            player
+                .createMessage(renderer)
+                .setType(C.MSG_SET_OUTPUT_BUFFER_RENDERER)
+                .setPayload(outputBufferRenderer)
+                .send());
+      }
+    }
+  }
+
   @Override
   public void addAudioListener(AudioListener listener) {
     audioListeners.add(listener);
@@ -695,12 +713,12 @@ public float getVolume() {
 
   /**
    * Sets the stream type for audio playback, used by the underlying audio track.
-   * <p>
-   * Setting the stream type during playback may introduce a short gap in audio output as the audio
-   * track is recreated. A new audio session id will also be generated.
-   * <p>
-   * Calling this method overwrites any attributes set previously by calling
-   * {@link #setAudioAttributes(AudioAttributes)}.
+   *
+   * <p>Setting the stream type during playback may introduce a short gap in audio output as the
+   * audio track is recreated. A new audio session id will also be generated.
+   *
+   * <p>Calling this method overwrites any attributes set previously by calling {@link
+   * #setAudioAttributes(AudioAttributes)}.
    *
    * @deprecated Use {@link #setAudioAttributes(AudioAttributes)}.
    * @param streamType The stream type for audio playback.
@@ -1432,13 +1450,13 @@ private void sendVolumeToRenderers() {
 
   private void updatePlayWhenReady(
       boolean playWhenReady, @AudioFocusManager.PlayerCommand int playerCommand) {
+    playWhenReady = playWhenReady && playerCommand != AudioFocusManager.PLAYER_COMMAND_DO_NOT_PLAY;
+    @PlaybackSuppressionReason
     int playbackSuppressionReason =
-        playerCommand == AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY
-            ? Player.PLAYBACK_SUPPRESSION_REASON_NONE
-            : Player.PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS;
-    player.setPlayWhenReady(
-        playWhenReady && playerCommand != AudioFocusManager.PLAYER_COMMAND_DO_NOT_PLAY,
-        playbackSuppressionReason);
+        playWhenReady && playerCommand != AudioFocusManager.PLAYER_COMMAND_PLAY_WHEN_READY
+            ? Player.PLAYBACK_SUPPRESSION_REASON_AUDIO_FOCUS_LOSS
+            : Player.PLAYBACK_SUPPRESSION_REASON_NONE;
+    player.setPlayWhenReady(playWhenReady, playbackSuppressionReason);
   }
 
   private void verifyApplicationThread() {
@@ -1473,11 +1491,11 @@ public void onVideoEnabled(DecoderCounters counters) {
     }
 
     @Override
-    public void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
-        long initializationDurationMs) {
+    public void onVideoDecoderInitialized(
+        String decoderName, long initializedTimestampMs, long initializationDurationMs) {
       for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
-        videoDebugListener.onVideoDecoderInitialized(decoderName, initializedTimestampMs,
-            initializationDurationMs);
+        videoDebugListener.onVideoDecoderInitialized(
+            decoderName, initializedTimestampMs, initializationDurationMs);
       }
     }
 
@@ -1497,8 +1515,8 @@ public void onDroppedFrames(int count, long elapsed) {
     }
 
     @Override
-    public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-        float pixelWidthHeightRatio) {
+    public void onVideoSizeChanged(
+        int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
       for (com.google.android.exoplayer2.video.VideoListener videoListener : videoListeners) {
         // Prevent duplicate notification if a listener is both a VideoRendererEventListener and
         // a VideoListener, as they have the same method signature.
@@ -1508,8 +1526,8 @@ public void onVideoSizeChanged(int width, int height, int unappliedRotationDegre
         }
       }
       for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
-        videoDebugListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
-            pixelWidthHeightRatio);
+        videoDebugListener.onVideoSizeChanged(
+            width, height, unappliedRotationDegrees, pixelWidthHeightRatio);
       }
     }
 
@@ -1563,11 +1581,11 @@ public void onAudioSessionId(int sessionId) {
     }
 
     @Override
-    public void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
-        long initializationDurationMs) {
+    public void onAudioDecoderInitialized(
+        String decoderName, long initializedTimestampMs, long initializationDurationMs) {
       for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
-        audioDebugListener.onAudioDecoderInitialized(decoderName, initializedTimestampMs,
-            initializationDurationMs);
+        audioDebugListener.onAudioDecoderInitialized(
+            decoderName, initializedTimestampMs, initializationDurationMs);
       }
     }
 
@@ -1580,8 +1598,8 @@ public void onAudioInputFormatChanged(Format format) {
     }
 
     @Override
-    public void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs,
-        long elapsedSinceLastFeedMs) {
+    public void onAudioSinkUnderrun(
+        int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs) {
       for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
         audioDebugListener.onAudioSinkUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
index 65dcd187a9..cd090c2c5e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/DownloaderConstructorHelper.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DummyDataSource;
+import com.google.android.exoplayer2.upstream.FileDataSource;
 import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
 import com.google.android.exoplayer2.upstream.PriorityDataSourceFactory;
 import com.google.android.exoplayer2.upstream.cache.Cache;
@@ -108,7 +109,7 @@ public DownloaderConstructorHelper(
     DataSource.Factory readDataSourceFactory =
         cacheReadDataSourceFactory != null
             ? cacheReadDataSourceFactory
-            : new FileDataSourceFactory();
+            : new FileDataSource.Factory();
     if (cacheWriteDataSinkFactory == null) {
       cacheWriteDataSinkFactory =
           new CacheDataSinkFactory(cache, CacheDataSink.DEFAULT_FRAGMENT_SIZE);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
index 17f4047bc0..a73258272c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/ProgressiveDownloader.java
@@ -29,6 +29,12 @@
 
 /**
  * A downloader for progressive media streams.
+ *
+ * <p>The downloader attempts to download the entire media bytes referenced by a {@link Uri} into a
+ * cache as defined by {@link DownloaderConstructorHelper}. Callers can use the constructor to
+ * specify a custom cache key for the downloaded bytes.
+ *
+ * <p>The downloader will avoid downloading already-downloaded media bytes.
  */
 public final class ProgressiveDownloader implements Downloader {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
index 38b4a1da03..2661469efd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSource.java
@@ -30,9 +30,7 @@
 /** A {@link DataSource} for reading local files. */
 public final class FileDataSource extends BaseDataSource {
 
-  /**
-   * Thrown when IOException is encountered during local file read operation.
-   */
+  /** Thrown when a {@link FileDataSource} encounters an error reading a file. */
   public static class FileDataSourceException extends IOException {
 
     public FileDataSourceException(IOException cause) {
@@ -44,6 +42,32 @@ public FileDataSourceException(String message, IOException cause) {
     }
   }
 
+  /** {@link DataSource.Factory} for {@link FileDataSource} instances. */
+  public static final class Factory implements DataSource.Factory {
+
+    @Nullable private TransferListener listener;
+
+    /**
+     * Sets a {@link TransferListener} for {@link FileDataSource} instances created by this factory.
+     *
+     * @param listener The {@link TransferListener}.
+     * @return This factory.
+     */
+    public Factory setListener(@Nullable TransferListener listener) {
+      this.listener = listener;
+      return this;
+    }
+
+    @Override
+    public FileDataSource createDataSource() {
+      FileDataSource dataSource = new FileDataSource();
+      if (listener != null) {
+        dataSource.addTransferListener(listener);
+      }
+      return dataSource;
+    }
+  }
+
   @Nullable private RandomAccessFile file;
   @Nullable private Uri uri;
   private long bytesRemaining;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
index e0630c7989..004a68fdaf 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/FileDataSourceFactory.java
@@ -17,28 +17,22 @@
 
 import androidx.annotation.Nullable;
 
-/**
- * A {@link DataSource.Factory} that produces {@link FileDataSource}.
- */
+/** @deprecated Use {@link FileDataSource.Factory}. */
+@Deprecated
 public final class FileDataSourceFactory implements DataSource.Factory {
 
-  @Nullable private final TransferListener listener;
+  private final FileDataSource.Factory wrappedFactory;
 
   public FileDataSourceFactory() {
-    this(null);
+    this(/* listener= */ null);
   }
 
   public FileDataSourceFactory(@Nullable TransferListener listener) {
-    this.listener = listener;
+    wrappedFactory = new FileDataSource.Factory().setListener(listener);
   }
 
   @Override
   public FileDataSource createDataSource() {
-    FileDataSource dataSource = new FileDataSource();
-    if (listener != null) {
-      dataSource.addTransferListener(listener);
-    }
-    return dataSource;
+    return wrappedFactory.createDataSource();
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
index 2f0f6caa2c..21758bdceb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java
@@ -18,7 +18,7 @@
 import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.upstream.DataSink;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.FileDataSourceFactory;
+import com.google.android.exoplayer2.upstream.FileDataSource;
 
 /** A {@link DataSource.Factory} that produces {@link CacheDataSource}. */
 public final class CacheDataSourceFactory implements DataSource.Factory {
@@ -49,7 +49,7 @@ public CacheDataSourceFactory(
     this(
         cache,
         upstreamFactory,
-        new FileDataSourceFactory(),
+        new FileDataSource.Factory(),
         new CacheDataSinkFactory(cache, CacheDataSink.DEFAULT_FRAGMENT_SIZE),
         flags,
         /* eventListener= */ null);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index c66ce82614..c8f13cb6de 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -142,6 +142,7 @@ public VideoDecoderException(
 
   private int pendingRotationDegrees;
   private float pendingPixelWidthHeightRatio;
+  @Nullable private MediaFormat currentMediaFormat;
   private int currentWidth;
   private int currentHeight;
   private int currentUnappliedRotationDegrees;
@@ -502,6 +503,7 @@ protected void onDisabled() {
     lastInputTimeUs = C.TIME_UNSET;
     outputStreamOffsetUs = C.TIME_UNSET;
     pendingOutputStreamOffsetCount = 0;
+    currentMediaFormat = null;
     clearReportedVideoSize();
     clearRenderedFirstFrame();
     frameReleaseTimeHelper.disable();
@@ -720,6 +722,7 @@ protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
 
   @Override
   protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat) {
+    currentMediaFormat = outputFormat;
     boolean hasCrop = outputFormat.containsKey(KEY_CROP_RIGHT)
         && outputFormat.containsKey(KEY_CROP_LEFT) && outputFormat.containsKey(KEY_CROP_BOTTOM)
         && outputFormat.containsKey(KEY_CROP_TOP);
@@ -810,7 +813,7 @@ protected boolean processOutputBuffer(
                 || (isStarted && shouldForceRenderOutputBuffer(earlyUs, elapsedSinceLastRenderUs)));
     if (forceRenderOutputBuffer) {
       long releaseTimeNs = System.nanoTime();
-      notifyFrameMetadataListener(presentationTimeUs, releaseTimeNs, format);
+      notifyFrameMetadataListener(presentationTimeUs, releaseTimeNs, format, currentMediaFormat);
       if (Util.SDK_INT >= 21) {
         renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, releaseTimeNs);
       } else {
@@ -854,7 +857,8 @@ protected boolean processOutputBuffer(
     if (Util.SDK_INT >= 21) {
       // Let the underlying framework time the release.
       if (earlyUs < 50000) {
-        notifyFrameMetadataListener(presentationTimeUs, adjustedReleaseTimeNs, format);
+        notifyFrameMetadataListener(
+            presentationTimeUs, adjustedReleaseTimeNs, format, currentMediaFormat);
         renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, adjustedReleaseTimeNs);
         return true;
       }
@@ -872,7 +876,8 @@ protected boolean processOutputBuffer(
             return false;
           }
         }
-        notifyFrameMetadataListener(presentationTimeUs, adjustedReleaseTimeNs, format);
+        notifyFrameMetadataListener(
+            presentationTimeUs, adjustedReleaseTimeNs, format, currentMediaFormat);
         renderOutputBuffer(codec, bufferIndex, presentationTimeUs);
         return true;
       }
@@ -905,10 +910,10 @@ private void processOutputFormat(MediaCodec codec, int width, int height) {
   }
 
   private void notifyFrameMetadataListener(
-      long presentationTimeUs, long releaseTimeNs, Format format) {
+      long presentationTimeUs, long releaseTimeNs, Format format, MediaFormat mediaFormat) {
     if (frameMetadataListener != null) {
       frameMetadataListener.onVideoFrameAboutToBeRendered(
-          presentationTimeUs, releaseTimeNs, format);
+          presentationTimeUs, releaseTimeNs, format, mediaFormat);
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
index 1289818c02..b179745c36 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderOutputBuffer.java
@@ -34,10 +34,15 @@
     void releaseOutputBuffer(VideoDecoderOutputBuffer outputBuffer);
   }
 
+  // LINT.IfChange
   public static final int COLORSPACE_UNKNOWN = 0;
   public static final int COLORSPACE_BT601 = 1;
   public static final int COLORSPACE_BT709 = 2;
   public static final int COLORSPACE_BT2020 = 3;
+  // LINT.ThenChange(
+  //     ../../../../../../../../../../extensions/av1/src/main/jni/gav1_jni.cc,
+  //     ../../../../../../../../../../extensions/vp9/src/main/jni/vpx_jni.cc
+  // )
 
   /** Decoder private data. */
   public int decoderPrivate;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java
index c85dff0c26..183b1c063c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderRenderer.java
@@ -28,7 +28,8 @@
  * GLSurfaceView.Renderer implementation that can render YUV Frames returned by a video decoder
  * after decoding. It does the YUV to RGB color conversion in the Fragment Shader.
  */
-/* package */ class VideoDecoderRenderer implements GLSurfaceView.Renderer {
+/* package */ class VideoDecoderRenderer
+    implements GLSurfaceView.Renderer, VideoDecoderOutputBufferRenderer {
 
   private static final float[] kColorConversion601 = {
     1.164f, 1.164f, 1.164f,
@@ -82,6 +83,7 @@
 
   private static final FloatBuffer TEXTURE_VERTICES =
       GlUtil.createBuffer(new float[] {-1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f});
+  private final GLSurfaceView surfaceView;
   private final int[] yuvTextures = new int[3];
   private final AtomicReference<VideoDecoderOutputBuffer> pendingOutputBufferReference;
 
@@ -98,7 +100,8 @@
 
   private VideoDecoderOutputBuffer renderedOutputBuffer; // Accessed only from the GL thread.
 
-  public VideoDecoderRenderer() {
+  public VideoDecoderRenderer(GLSurfaceView surfaceView) {
+    this.surfaceView = surfaceView;
     pendingOutputBufferReference = new AtomicReference<>();
     textureCoords = new FloatBuffer[3];
     texLocations = new int[3];
@@ -109,21 +112,6 @@ public VideoDecoderRenderer() {
     }
   }
 
-  /**
-   * Set a frame to be rendered. This should be followed by a call to
-   * VideoDecoderSurfaceView.requestRender() to actually render the frame.
-   *
-   * @param outputBuffer OutputBuffer containing the YUV Frame to be rendered
-   */
-  public void setFrame(VideoDecoderOutputBuffer outputBuffer) {
-    VideoDecoderOutputBuffer oldPendingOutputBuffer =
-        pendingOutputBufferReference.getAndSet(outputBuffer);
-    if (oldPendingOutputBuffer != null) {
-      // The old pending output buffer will never be used for rendering, so release it now.
-      oldPendingOutputBuffer.release();
-    }
-  }
-
   @Override
   public void onSurfaceCreated(GL10 unused, EGLConfig config) {
     program = GlUtil.compileProgram(VERTEX_SHADER, FRAGMENT_SHADER);
@@ -223,6 +211,17 @@ public void onDrawFrame(GL10 unused) {
     GlUtil.checkGlError();
   }
 
+  @Override
+  public void setOutputBuffer(VideoDecoderOutputBuffer outputBuffer) {
+    VideoDecoderOutputBuffer oldPendingOutputBuffer =
+        pendingOutputBufferReference.getAndSet(outputBuffer);
+    if (oldPendingOutputBuffer != null) {
+      // The old pending output buffer will never be used for rendering, so release it now.
+      oldPendingOutputBuffer.release();
+    }
+    surfaceView.requestRender();
+  }
+
   private void setupTextures() {
     GLES20.glGenTextures(3, yuvTextures, 0);
     for (int i = 0; i < 3; i++) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderSurfaceView.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderSurfaceView.java
index f2a4c2d002..0436c919a0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderSurfaceView.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoDecoderSurfaceView.java
@@ -21,28 +21,40 @@
 import androidx.annotation.Nullable;
 
 /** A GLSurfaceView extension that scales itself to the given aspect ratio. */
-public class VideoDecoderSurfaceView extends GLSurfaceView
-    implements VideoDecoderOutputBufferRenderer {
+public class VideoDecoderSurfaceView extends GLSurfaceView {
 
   private final VideoDecoderRenderer renderer;
 
+  /**
+   * Creates VideoDecoderSurfaceView.
+   *
+   * @param context A {@link Context}.
+   */
   public VideoDecoderSurfaceView(Context context) {
     this(context, /* attrs= */ null);
   }
 
+  /**
+   * Creates VideoDecoderSurfaceView.
+   *
+   * @param context A {@link Context}.
+   * @param attrs Custom attributes.
+   */
   public VideoDecoderSurfaceView(Context context, @Nullable AttributeSet attrs) {
     super(context, attrs);
-    renderer = new VideoDecoderRenderer();
+    renderer = new VideoDecoderRenderer(this);
     setPreserveEGLContextOnPause(true);
     setEGLContextClientVersion(2);
     setRenderer(renderer);
     setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);
   }
 
-  @Override
-  public void setOutputBuffer(VideoDecoderOutputBuffer outputBuffer) {
-    renderer.setFrame(outputBuffer);
-    requestRender();
+  /**
+   * Returns the output buffer renderer used.
+   *
+   * @return {@link VideoDecoderOutputBuffer}.
+   */
+  public VideoDecoderOutputBufferRenderer getOutputBufferRenderer() {
+    return renderer;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java
index b467d0f421..746903a101 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoFrameMetadataListener.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.video;
 
+import android.media.MediaFormat;
+import androidx.annotation.Nullable;
 import com.google.android.exoplayer2.Format;
 
 /** A listener for metadata corresponding to video frame being rendered. */
@@ -26,6 +28,13 @@
    * @param releaseTimeNs The wallclock time at which the frame should be displayed, in nanoseconds.
    *     If the platform API version of the device is less than 21, then this is the best effort.
    * @param format The format associated with the frame.
+   * @param mediaFormat The framework media format associated with the frame, or {@code null} if not
+   *     known or not applicable (e.g., because the frame was not output by a {@link
+   *     android.media.MediaCodec MediaCodec}).
    */
-  void onVideoFrameAboutToBeRendered(long presentationTimeUs, long releaseTimeNs, Format format);
+  void onVideoFrameAboutToBeRendered(
+      long presentationTimeUs,
+      long releaseTimeNs,
+      Format format,
+      @Nullable MediaFormat mediaFormat);
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
index 37c026db74..d7f5624ae1 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -17,9 +17,11 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
+import static org.robolectric.Shadows.shadowOf;
 
 import android.content.Context;
 import android.graphics.SurfaceTexture;
+import android.media.AudioManager;
 import android.net.Uri;
 import android.view.Surface;
 import androidx.annotation.Nullable;
@@ -29,6 +31,7 @@
 import com.google.android.exoplayer2.Player.EventListener;
 import com.google.android.exoplayer2.Timeline.Window;
 import com.google.android.exoplayer2.analytics.AnalyticsListener;
+import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.source.ClippingMediaSource;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
@@ -55,7 +58,6 @@
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.TransferListener;
-import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Clock;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -64,6 +66,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
@@ -71,6 +74,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.LooperMode;
+import org.robolectric.shadows.ShadowAudioManager;
 
 /** Unit test for {@link ExoPlayer}. */
 @RunWith(AndroidJUnit4.class)
@@ -2767,6 +2771,67 @@ public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
         .inOrder();
   }
 
+  @Test
+  public void simplePlaybackHasNoPlaybackSuppression() throws Exception {
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("simplePlaybackHasNoPlaybackSuppression")
+            .play()
+            .waitForPlaybackState(Player.STATE_READY)
+            .pause()
+            .play()
+            .build();
+    AtomicBoolean seenPlaybackSuppression = new AtomicBoolean();
+    EventListener listener =
+        new EventListener() {
+          @Override
+          public void onPlaybackSuppressionReasonChanged(
+              @Player.PlaybackSuppressionReason int playbackSuppressionReason) {
+            seenPlaybackSuppression.set(true);
+          }
+        };
+    new ExoPlayerTestRunner.Builder()
+        .setActionSchedule(actionSchedule)
+        .setEventListener(listener)
+        .build(context)
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    assertThat(seenPlaybackSuppression.get()).isFalse();
+  }
+
+  @Test
+  public void audioFocusDenied() throws Exception {
+    ShadowAudioManager shadowAudioManager = shadowOf(context.getSystemService(AudioManager.class));
+    shadowAudioManager.setNextFocusRequestResponse(AudioManager.AUDIOFOCUS_REQUEST_FAILED);
+
+    PlayerStateGrabber playerStateGrabber = new PlayerStateGrabber();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("audioFocusDenied")
+            .setAudioAttributes(AudioAttributes.DEFAULT, /* handleAudioFocus= */ true)
+            .play()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(playerStateGrabber)
+            .build();
+    AtomicBoolean seenPlaybackSuppression = new AtomicBoolean();
+    EventListener listener =
+        new EventListener() {
+          @Override
+          public void onPlaybackSuppressionReasonChanged(
+              @Player.PlaybackSuppressionReason int playbackSuppressionReason) {
+            seenPlaybackSuppression.set(true);
+          }
+        };
+    new ExoPlayerTestRunner.Builder()
+        .setActionSchedule(actionSchedule)
+        .setEventListener(listener)
+        .build(context)
+        .start()
+        .blockUntilActionScheduleFinished(TIMEOUT_MS);
+
+    assertThat(playerStateGrabber.playWhenReady).isFalse();
+    assertThat(seenPlaybackSuppression.get()).isFalse();
+  }
+
   // Internal methods.
 
   private static ActionSchedule.Builder addSurfaceSwitch(ActionSchedule.Builder builder) {
@@ -2812,38 +2877,17 @@ public void handleMessage(SimpleExoPlayer player, int messageType, @Nullable Obj
     }
   }
 
-  /**
-   * Provides a wrapper for a {@link Runnable} which does collect playback states and window counts.
-   * Can be used with {@link ActionSchedule.Builder#executeRunnable(Runnable)} to verify that a
-   * playback state did not change and hence no observable callback is called.
-   *
-   * <p>This is specifically useful in cases when the test may end before a given state arrives or
-   * when an action of the action schedule might execute before a callback is called.
-   */
-  public static class PlaybackStateCollector extends PlayerRunnable {
-
-    private final int[] playbackStates;
-    private final int[] timelineWindowCount;
-    private final int index;
-
-    /**
-     * Creates the collector.
-     *
-     * @param index The index to populate.
-     * @param playbackStates An array of playback states to populate.
-     * @param timelineWindowCount An array of window counts to populate.
-     */
-    public PlaybackStateCollector(int index, int[] playbackStates, int[] timelineWindowCount) {
-      Assertions.checkArgument(playbackStates.length > index && timelineWindowCount.length > index);
-      this.playbackStates = playbackStates;
-      this.timelineWindowCount = timelineWindowCount;
-      this.index = index;
-    }
+  private static final class PlayerStateGrabber extends PlayerRunnable {
+
+    public boolean playWhenReady;
+    @Player.State public int playbackState;
+    @Nullable public Timeline timeline;
 
     @Override
     public void run(SimpleExoPlayer player) {
-      playbackStates[index] = player.getPlaybackState();
-      timelineWindowCount[index] = player.getCurrentTimeline().getWindowCount();
+      playWhenReady = player.getPlayWhenReady();
+      playbackState = player.getPlaybackState();
+      timeline = player.getCurrentTimeline();
     }
   }
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index d225f65cea..643b1203dc 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -1169,10 +1169,13 @@ protected String parseBaseUrl(XmlPullParser xpp, String parentBaseUrl)
   protected int parseAudioChannelConfiguration(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
     String schemeIdUri = parseString(xpp, "schemeIdUri", null);
-    int audioChannels = "urn:mpeg:dash:23003:3:audio_channel_configuration:2011".equals(schemeIdUri)
-        ? parseInt(xpp, "value", Format.NO_VALUE)
-        : ("tag:dolby.com,2014:dash:audio_channel_configuration:2011".equals(schemeIdUri)
-        ? parseDolbyChannelConfiguration(xpp) : Format.NO_VALUE);
+    int audioChannels =
+        "urn:mpeg:dash:23003:3:audio_channel_configuration:2011".equals(schemeIdUri)
+            ? parseInt(xpp, "value", Format.NO_VALUE)
+            : ("tag:dolby.com,2014:dash:audio_channel_configuration:2011".equals(schemeIdUri)
+                    || "urn:dolby:dash:audio_channel_configuration:2011".equals(schemeIdUri)
+                ? parseDolbyChannelConfiguration(xpp)
+                : Format.NO_VALUE);
     do {
       xpp.next();
     } while (!XmlPullParserUtil.isEndTag(xpp, "AudioChannelConfiguration"));
@@ -1551,7 +1554,8 @@ protected static String parseString(XmlPullParser xpp, String name, String defau
   /**
    * Parses the number of channels from the value attribute of an AudioElementConfiguration with
    * schemeIdUri "tag:dolby.com,2014:dash:audio_channel_configuration:2011", as defined by table E.5
-   * in ETSI TS 102 366.
+   * in ETSI TS 102 366, or the legacy schemeIdUri
+   * "urn:dolby:dash:audio_channel_configuration:2011".
    *
    * @param xpp The parser from which to read.
    * @return The parsed number of channels, or {@link Format#NO_VALUE} if the channel count could
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
index d5b9ca478e..2495c8439f 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
@@ -29,6 +29,7 @@
 import com.google.android.exoplayer2.extractor.ts.AdtsExtractor;
 import com.google.android.exoplayer2.extractor.ts.DefaultTsPayloadReaderFactory;
 import com.google.android.exoplayer2.extractor.ts.TsExtractor;
+import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.EOFException;
@@ -158,7 +159,7 @@ public Result createExtractor(
 
     if (!(extractorByFileExtension instanceof FragmentedMp4Extractor)) {
       FragmentedMp4Extractor fragmentedMp4Extractor =
-          createFragmentedMp4Extractor(timestampAdjuster, drmInitData, muxedCaptionFormats);
+          createFragmentedMp4Extractor(timestampAdjuster, format, drmInitData, muxedCaptionFormats);
       if (sniffQuietly(fragmentedMp4Extractor, extractorInput)) {
         return buildResult(fragmentedMp4Extractor);
       }
@@ -208,7 +209,8 @@ private Extractor createExtractorByFileExtension(
         || lastPathSegment.startsWith(M4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 4)
         || lastPathSegment.startsWith(MP4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)
         || lastPathSegment.startsWith(CMF_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)) {
-      return createFragmentedMp4Extractor(timestampAdjuster, drmInitData, muxedCaptionFormats);
+      return createFragmentedMp4Extractor(
+          timestampAdjuster, format, drmInitData, muxedCaptionFormats);
     } else {
       // For any other file extension, we assume TS format.
       return createTsExtractor(
@@ -267,10 +269,21 @@ private static TsExtractor createTsExtractor(
 
   private static FragmentedMp4Extractor createFragmentedMp4Extractor(
       TimestampAdjuster timestampAdjuster,
+      Format format,
       DrmInitData drmInitData,
       @Nullable List<Format> muxedCaptionFormats) {
+    boolean isVariant = false;
+    for (int i = 0; i < format.metadata.length(); i++) {
+      Metadata.Entry entry = format.metadata.get(i);
+      if (entry instanceof HlsTrackMetadataEntry) {
+        isVariant = !((HlsTrackMetadataEntry) entry).variantInfos.isEmpty();
+        break;
+      }
+    }
+    // Only enable the EMSG TrackOutput if this is the 'variant' track (i.e. the main one) to avoid
+    // creating a separate EMSG track for every audio track in a video stream.
     return new FragmentedMp4Extractor(
-        /* flags= */ 0,
+        /* flags= */ isVariant ? FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK : 0,
         timestampAdjuster,
         /* sideloadedTrack= */ null,
         drmInitData,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index b0b4c04b48..8b57cb7aa6 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -75,6 +75,7 @@
   private final TimestampAdjusterProvider timestampAdjusterProvider;
   private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
   private final boolean allowChunklessPreparation;
+  private final @HlsMetadataType int metadataType;
   private final boolean useSessionKeys;
 
   @Nullable private Callback callback;
@@ -117,6 +118,7 @@ public HlsMediaPeriod(
       Allocator allocator,
       CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
       boolean allowChunklessPreparation,
+      @HlsMetadataType int metadataType,
       boolean useSessionKeys) {
     this.extractorFactory = extractorFactory;
     this.playlistTracker = playlistTracker;
@@ -128,6 +130,7 @@ public HlsMediaPeriod(
     this.allocator = allocator;
     this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
     this.allowChunklessPreparation = allowChunklessPreparation;
+    this.metadataType = metadataType;
     this.useSessionKeys = useSessionKeys;
     compositeSequenceableLoader =
         compositeSequenceableLoaderFactory.createCompositeSequenceableLoader();
@@ -755,7 +758,8 @@ private HlsSampleStreamWrapper buildSampleStreamWrapper(
         muxedAudioFormat,
         drmSessionManager,
         loadErrorHandlingPolicy,
-        eventDispatcher);
+        eventDispatcher,
+        metadataType);
   }
 
   private static Map<String, DrmInitData> deriveOverridingDrmInitData(
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index aa30e9ba37..d889729835 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -71,6 +71,7 @@
     private LoadErrorHandlingPolicy loadErrorHandlingPolicy;
     private boolean allowChunklessPreparation;
     private long LowLatency;
+    @HlsMetadataType private int metadataType;
     private boolean useSessionKeys;
     private boolean isCreateCalled;
     @Nullable private Object tag;
@@ -100,6 +101,7 @@ public Factory(HlsDataSourceFactory hlsDataSourceFactory) {
       drmSessionManager = DrmSessionManager.getDummyDrmSessionManager();
       loadErrorHandlingPolicy = new DefaultLoadErrorHandlingPolicy();
       compositeSequenceableLoaderFactory = new DefaultCompositeSequenceableLoaderFactory();
+      metadataType = HlsMetadataType.ID3;
     }
 
     /**
@@ -249,6 +251,31 @@ public Factory setLowLatency(long LowLatency) {
       return this;
     }
 
+    /**
+     * Sets the type of metadata to extract from the HLS source (defaults to {@link
+     * HlsMetadataType#ID3}).
+     *
+     * <p>HLS supports in-band ID3 in both TS and fMP4 streams, but in the fMP4 case the data is
+     * wrapped in an EMSG box [<a href="https://aomediacodec.github.io/av1-id3/">spec</a>].
+     *
+     * <p>If this is set to {@link HlsMetadataType#ID3} then raw ID3 metadata of will be extracted
+     * from TS sources. From fMP4 streams EMSGs containing metadata of this type (in the variant
+     * stream only) will be unwrapped to expose the inner data. All other in-band metadata will be
+     * dropped.
+     *
+     * <p>If this is set to {@link HlsMetadataType#EMSG} then all EMSG data from the fMP4 variant
+     * stream will be extracted. No metadata will be extracted from TS streams, since they don't
+     * support EMSG.
+     *
+     * @param metadataType The type of metadata to extract.
+     * @return This factory, for convenience.
+     */
+    public Factory setMetadataType(@HlsMetadataType int metadataType) {
+      Assertions.checkState(!isCreateCalled);
+      this.metadataType = metadataType;
+      return this;
+    }
+
     /**
      * Sets whether to use #EXT-X-SESSION-KEY tags provided in the master playlist. If enabled, it's
      * assumed that any single session key declared in the master playlist can be used to obtain all
@@ -302,6 +329,7 @@ public HlsMediaSource createMediaSource(Uri playlistUri) {
               hlsDataSourceFactory, loadErrorHandlingPolicy, playlistParserFactory),
           allowChunklessPreparation,
           LowLatency,
+          metadataType,
           useSessionKeys,
           tag);
     }
@@ -328,6 +356,7 @@ public Factory setStreamKeys(List<StreamKey> streamKeys) {
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final boolean allowChunklessPreparation;
   private final long LowLatency;
+  private final @HlsMetadataType int metadataType;
   private final boolean useSessionKeys;
   private final HlsPlaylistTracker playlistTracker;
   @Nullable private final Object tag;
@@ -344,6 +373,7 @@ private HlsMediaSource(
       HlsPlaylistTracker playlistTracker,
       boolean allowChunklessPreparation,
       long LowLatency,
+      @HlsMetadataType int metadataType,
       boolean useSessionKeys,
       @Nullable Object tag) {
     this.manifestUri = manifestUri;
@@ -355,6 +385,7 @@ private HlsMediaSource(
     this.playlistTracker = playlistTracker;
     this.allowChunklessPreparation = allowChunklessPreparation;
     this.LowLatency = LowLatency;
+    this.metadataType = metadataType;
     this.useSessionKeys = useSessionKeys;
     this.tag = tag;
   }
@@ -392,6 +423,7 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator, long star
         allocator,
         compositeSequenceableLoaderFactory,
         allowChunklessPreparation,
+        metadataType,
         useSessionKeys);
   }
 
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMetadataType.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMetadataType.java
new file mode 100644
index 0000000000..e445466e67
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMetadataType.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+import androidx.annotation.IntDef;
+import java.lang.annotation.Retention;
+
+/**
+ * The types of metadata that can be extracted from HLS streams.
+ *
+ * <p>See {@link HlsMediaSource.Factory#setMetadataType(int)}.
+ */
+@Retention(SOURCE)
+@IntDef({HlsMetadataType.ID3, HlsMetadataType.EMSG})
+public @interface HlsMetadataType {
+  int ID3 = 1;
+  int EMSG = 3;
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index 58c275664b..749ce74d96 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -28,10 +28,13 @@
 import com.google.android.exoplayer2.drm.DrmSession;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.extractor.DummyTrackOutput;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
+import com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder;
 import com.google.android.exoplayer2.metadata.id3.PrivFrame;
 import com.google.android.exoplayer2.source.DecryptableSampleQueueReader;
 import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
@@ -51,7 +54,9 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Log;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
+import java.io.EOFException;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -60,6 +65,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 
 /**
  * Loads {@link HlsMediaChunk}s obtained from a {@link HlsChunkSource}, and provides
@@ -96,7 +102,8 @@
 
   private static final Set<Integer> MAPPABLE_TYPES =
       Collections.unmodifiableSet(
-          new HashSet<>(Arrays.asList(C.TRACK_TYPE_AUDIO, C.TRACK_TYPE_VIDEO)));
+          new HashSet<>(
+              Arrays.asList(C.TRACK_TYPE_AUDIO, C.TRACK_TYPE_VIDEO, C.TRACK_TYPE_METADATA)));
 
   private final int trackType;
   private final Callback callback;
@@ -107,11 +114,10 @@
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
   private final Loader loader;
   private final EventDispatcher eventDispatcher;
+  private final @HlsMetadataType int metadataType;
   private final HlsChunkSource.HlsChunkHolder nextChunkHolder;
   private final ArrayList<HlsMediaChunk> mediaChunks;
   private final List<HlsMediaChunk> readOnlyMediaChunks;
-  private final Runnable maybeFinishPrepareRunnable;
-  private final Runnable onTracksEndedRunnable;
   private final Handler handler;
   private final ArrayList<HlsSampleStream> hlsSampleStreams;
   private final Map<String, DrmInitData> overridingDrmInitData;
@@ -121,6 +127,7 @@
   private int[] sampleQueueTrackIds;
   private Set<Integer> sampleQueueMappingDoneByType;
   private SparseIntArray sampleQueueIndicesByType;
+  private TrackOutput emsgUnwrappingTrackOutput;
   private int primarySampleQueueType;
   private int primarySampleQueueIndex;
   private boolean sampleQueuesBuilt;
@@ -130,7 +137,7 @@
   private Format downstreamTrackFormat;
   private boolean released;
 
-  // Tracks are complicated in HLS. See documentation of buildTracks for details.
+  // Tracks are complicated in HLS. See documentation of buildTracksFromSampleStreams for details.
   // Indexed by track (as exposed by this source).
   private TrackGroupArray trackGroups;
   private Set<TrackGroup> optionalTrackGroups;
@@ -178,7 +185,8 @@ public HlsSampleStreamWrapper(
       Format muxedAudioFormat,
       DrmSessionManager<?> drmSessionManager,
       LoadErrorHandlingPolicy loadErrorHandlingPolicy,
-      EventDispatcher eventDispatcher) {
+      EventDispatcher eventDispatcher,
+      @HlsMetadataType int metadataType) {
     this.trackType = trackType;
     this.callback = callback;
     this.chunkSource = chunkSource;
@@ -188,6 +196,7 @@ public HlsSampleStreamWrapper(
     this.drmSessionManager = drmSessionManager;
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     this.eventDispatcher = eventDispatcher;
+    this.metadataType = metadataType;
     loader = new Loader("Loader:HlsSampleStreamWrapper");
     nextChunkHolder = new HlsChunkSource.HlsChunkHolder();
     sampleQueueTrackIds = new int[0];
@@ -200,8 +209,6 @@ public HlsSampleStreamWrapper(
     mediaChunks = new ArrayList<>();
     readOnlyMediaChunks = Collections.unmodifiableList(mediaChunks);
     hlsSampleStreams = new ArrayList<>();
-    maybeFinishPrepareRunnable = this::maybeFinishPrepare;
-    onTracksEndedRunnable = this::onTracksEnded;
     handler = new Handler();
     lastSeekPositionUs = positionUs;
     pendingResetPositionUs = positionUs;
@@ -819,46 +826,34 @@ public void init(int chunkUid, boolean shouldSpliceIn, boolean reusingExtractor)
 
   @Override
   public TrackOutput track(int id, int type) {
+    @Nullable TrackOutput trackOutput = null;
     if (MAPPABLE_TYPES.contains(type)) {
       // Track types in MAPPABLE_TYPES are handled manually to ignore IDs.
-      @Nullable TrackOutput mappedTrackOutput = getMappedTrackOutput(id, type);
-      if (mappedTrackOutput != null) {
-        return mappedTrackOutput;
-      }
-    } else /* sparse track */ {
+      trackOutput = getMappedTrackOutput(id, type);
+    } else /* non-mappable type track */ {
       for (int i = 0; i < sampleQueues.length; i++) {
         if (sampleQueueTrackIds[i] == id) {
-          return sampleQueues[i];
+          trackOutput = sampleQueues[i];
+          break;
         }
       }
     }
-    if (tracksEnded) {
-      return createDummyTrackOutput(id, type);
+
+    if (trackOutput == null) {
+      if (tracksEnded) {
+        return createDummyTrackOutput(id, type);
+      } else {
+        // The relevant SampleQueue hasn't been constructed yet - so construct it.
+        trackOutput = createSampleQueue(id, type);
+      }
     }
 
-    int trackCount = sampleQueues.length;
-    SampleQueue trackOutput = new FormatAdjustingSampleQueue(allocator, overridingDrmInitData);
-    trackOutput.setSampleOffsetUs(sampleOffsetUs);
-    trackOutput.sourceId(chunkUid);
-    trackOutput.setUpstreamFormatChangeListener(this);
-    sampleQueueTrackIds = Arrays.copyOf(sampleQueueTrackIds, trackCount + 1);
-    sampleQueueTrackIds[trackCount] = id;
-    sampleQueues = Arrays.copyOf(sampleQueues, trackCount + 1);
-    sampleQueues[trackCount] = trackOutput;
-    sampleQueueReaders = Arrays.copyOf(sampleQueueReaders, trackCount + 1);
-    sampleQueueReaders[trackCount] =
-        new DecryptableSampleQueueReader(sampleQueues[trackCount], drmSessionManager);
-    sampleQueueIsAudioVideoFlags = Arrays.copyOf(sampleQueueIsAudioVideoFlags, trackCount + 1);
-    sampleQueueIsAudioVideoFlags[trackCount] = type == C.TRACK_TYPE_AUDIO
-        || type == C.TRACK_TYPE_VIDEO;
-    haveAudioVideoSampleQueues |= sampleQueueIsAudioVideoFlags[trackCount];
-    sampleQueueMappingDoneByType.add(type);
-    sampleQueueIndicesByType.append(type, trackCount);
-    if (getTrackTypeScore(type) > getTrackTypeScore(primarySampleQueueType)) {
-      primarySampleQueueIndex = trackCount;
-      primarySampleQueueType = type;
+    if (type == C.TRACK_TYPE_METADATA) {
+      if (emsgUnwrappingTrackOutput == null) {
+        emsgUnwrappingTrackOutput = new EmsgUnwrappingTrackOutput(trackOutput, metadataType);
+      }
+      return emsgUnwrappingTrackOutput;
     }
-    sampleQueuesEnabledStates = Arrays.copyOf(sampleQueuesEnabledStates, trackCount + 1);
     return trackOutput;
   }
 
@@ -893,10 +888,38 @@ private TrackOutput getMappedTrackOutput(int id, int type) {
         : createDummyTrackOutput(id, type);
   }
 
+  private SampleQueue createSampleQueue(int id, int type) {
+    int trackCount = sampleQueues.length;
+
+    SampleQueue trackOutput = new FormatAdjustingSampleQueue(allocator, overridingDrmInitData);
+    trackOutput.setSampleOffsetUs(sampleOffsetUs);
+    trackOutput.sourceId(chunkUid);
+    trackOutput.setUpstreamFormatChangeListener(this);
+    sampleQueueTrackIds = Arrays.copyOf(sampleQueueTrackIds, trackCount + 1);
+    sampleQueueTrackIds[trackCount] = id;
+    sampleQueues = Arrays.copyOf(sampleQueues, trackCount + 1);
+    sampleQueues[trackCount] = trackOutput;
+    sampleQueueReaders = Arrays.copyOf(sampleQueueReaders, trackCount + 1);
+    sampleQueueReaders[trackCount] =
+        new DecryptableSampleQueueReader(sampleQueues[trackCount], drmSessionManager);
+    sampleQueueIsAudioVideoFlags = Arrays.copyOf(sampleQueueIsAudioVideoFlags, trackCount + 1);
+    sampleQueueIsAudioVideoFlags[trackCount] =
+        type == C.TRACK_TYPE_AUDIO || type == C.TRACK_TYPE_VIDEO;
+    haveAudioVideoSampleQueues |= sampleQueueIsAudioVideoFlags[trackCount];
+    sampleQueueMappingDoneByType.add(type);
+    sampleQueueIndicesByType.append(type, trackCount);
+    if (getTrackTypeScore(type) > getTrackTypeScore(primarySampleQueueType)) {
+      primarySampleQueueIndex = trackCount;
+      primarySampleQueueType = type;
+    }
+    sampleQueuesEnabledStates = Arrays.copyOf(sampleQueuesEnabledStates, trackCount + 1);
+    return trackOutput;
+  }
+
   @Override
   public void endTracks() {
     tracksEnded = true;
-    handler.post(onTracksEndedRunnable);
+    handler.post(this::onTracksEnded);
   }
 
   @Override
@@ -908,7 +931,7 @@ public void seekMap(SeekMap seekMap) {
 
   @Override
   public void onUpstreamFormatChanged(Format format) {
-    handler.post(maybeFinishPrepareRunnable);
+    handler.post(this::maybeFinishPrepare);
   }
 
   // Called by the loading thread.
@@ -1285,4 +1308,141 @@ private Metadata getAdjustedMetadata(@Nullable Metadata metadata) {
       return new Metadata(newMetadataEntries);
     }
   }
+
+  private static class EmsgUnwrappingTrackOutput implements TrackOutput {
+
+    private static final String TAG = "EmsgUnwrappingTrackOutput";
+
+    // TODO(ibaker): Create a Formats util class with common constants like this.
+    private static final Format ID3_FORMAT =
+        Format.createSampleFormat(
+            /* id= */ null, MimeTypes.APPLICATION_ID3, Format.OFFSET_SAMPLE_RELATIVE);
+    private static final Format EMSG_FORMAT =
+        Format.createSampleFormat(
+            /* id= */ null, MimeTypes.APPLICATION_EMSG, Format.OFFSET_SAMPLE_RELATIVE);
+
+    private final EventMessageDecoder emsgDecoder;
+    private final TrackOutput delegate;
+    private final Format delegateFormat;
+    @MonotonicNonNull private Format format;
+
+    private byte[] buffer;
+    private int bufferPosition;
+
+    public EmsgUnwrappingTrackOutput(TrackOutput delegate, @HlsMetadataType int metadataType) {
+      this.emsgDecoder = new EventMessageDecoder();
+      this.delegate = delegate;
+      switch (metadataType) {
+        case HlsMetadataType.ID3:
+          delegateFormat = ID3_FORMAT;
+          break;
+        case HlsMetadataType.EMSG:
+          delegateFormat = EMSG_FORMAT;
+          break;
+        default:
+          throw new IllegalArgumentException("Unknown metadataType: " + metadataType);
+      }
+
+      this.buffer = new byte[0];
+      this.bufferPosition = 0;
+    }
+
+    @Override
+    public void format(Format format) {
+      this.format = format;
+      delegate.format(delegateFormat);
+    }
+
+    @Override
+    public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+        throws IOException, InterruptedException {
+      ensureBufferCapacity(bufferPosition + length);
+      int numBytesRead = input.read(buffer, bufferPosition, length);
+      if (numBytesRead == C.RESULT_END_OF_INPUT) {
+        if (allowEndOfInput) {
+          return C.RESULT_END_OF_INPUT;
+        } else {
+          throw new EOFException();
+        }
+      }
+      bufferPosition += numBytesRead;
+      return numBytesRead;
+    }
+
+    @Override
+    public void sampleData(ParsableByteArray buffer, int length) {
+      ensureBufferCapacity(bufferPosition + length);
+      buffer.readBytes(this.buffer, bufferPosition, length);
+      bufferPosition += length;
+    }
+
+    @Override
+    public void sampleMetadata(
+        long timeUs,
+        @C.BufferFlags int flags,
+        int size,
+        int offset,
+        @Nullable CryptoData cryptoData) {
+      Assertions.checkState(format != null);
+      ParsableByteArray sample = getSampleAndTrimBuffer(size, offset);
+      ParsableByteArray sampleForDelegate;
+      if (Util.areEqual(format.sampleMimeType, delegateFormat.sampleMimeType)) {
+        // Incoming format matches delegate track's format, so pass straight through.
+        sampleForDelegate = sample;
+      } else if (MimeTypes.APPLICATION_EMSG.equals(format.sampleMimeType)) {
+        // Incoming sample is EMSG, and delegate track is not expecting EMSG, so try unwrapping.
+        EventMessage emsg = emsgDecoder.decode(sample);
+        if (!emsgContainsExpectedWrappedFormat(emsg)) {
+          Log.w(
+              TAG,
+              String.format(
+                  "Ignoring EMSG. Expected it to contain wrapped %s but actual wrapped format: %s",
+                  delegateFormat.sampleMimeType, emsg.getWrappedMetadataFormat()));
+          return;
+        }
+        sampleForDelegate =
+            new ParsableByteArray(Assertions.checkNotNull(emsg.getWrappedMetadataBytes()));
+      } else {
+        Log.w(TAG, "Ignoring sample for unsupported format: " + format.sampleMimeType);
+        return;
+      }
+
+      int sampleSize = sampleForDelegate.bytesLeft();
+
+      delegate.sampleData(sampleForDelegate, sampleSize);
+      delegate.sampleMetadata(timeUs, flags, sampleSize, offset, cryptoData);
+    }
+
+    private boolean emsgContainsExpectedWrappedFormat(EventMessage emsg) {
+      @Nullable Format wrappedMetadataFormat = emsg.getWrappedMetadataFormat();
+      return wrappedMetadataFormat != null
+          && Util.areEqual(delegateFormat.sampleMimeType, wrappedMetadataFormat.sampleMimeType);
+    }
+
+    private void ensureBufferCapacity(int requiredLength) {
+      if (buffer.length < requiredLength) {
+        buffer = Arrays.copyOf(buffer, requiredLength + requiredLength / 2);
+      }
+    }
+
+    /**
+     * Removes a complete sample from the {@link #buffer} field & reshuffles the tail data skipped
+     * by {@code offset} to the head of the array.
+     *
+     * @param size see {@code size} param of {@link #sampleMetadata}.
+     * @param offset see {@code offset} param of {@link #sampleMetadata}.
+     * @return A {@link ParsableByteArray} containing the sample removed from {@link #buffer}.
+     */
+    private ParsableByteArray getSampleAndTrimBuffer(int size, int offset) {
+      int sampleEnd = bufferPosition - offset;
+      int sampleStart = sampleEnd - size;
+
+      byte[] sampleBytes = Arrays.copyOfRange(buffer, sampleStart, sampleEnd);
+      ParsableByteArray sample = new ParsableByteArray(sampleBytes);
+
+      System.arraycopy(buffer, sampleEnd, buffer, 0, offset);
+      bufferPosition = offset;
+      return sample;
+    }
+  }
 }
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java
index 847e46591d..73ef11bda9 100644
--- a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriodTest.java
@@ -92,6 +92,7 @@ public void getSteamKeys_isCompatibleWithHlsMasterPlaylistFilter() {
               mock(Allocator.class),
               mock(CompositeSequenceableLoaderFactory.class),
               /* allowChunklessPreparation =*/ true,
+              HlsMetadataType.ID3,
               /* useSessionKeys= */ false);
         };
 
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
index 3b6711766e..b8642e2e42 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
@@ -43,6 +43,7 @@
 import java.util.Arrays;
 import java.util.Formatter;
 import java.util.Locale;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * A view for controlling {@link Player} instances.
@@ -231,6 +232,7 @@
   private static final int MAX_UPDATE_INTERVAL_MS = 1000;
 
   private final ComponentListener componentListener;
+  private final CopyOnWriteArrayList<VisibilityListener> visibilityListeners;
   private final View previousButton;
   private final View nextButton;
   private final View playButton;
@@ -265,7 +267,6 @@
 
   @Nullable private Player player;
   private com.google.android.exoplayer2.ControlDispatcher controlDispatcher;
-  @Nullable private VisibilityListener visibilityListener;
   @Nullable private ProgressUpdateListener progressUpdateListener;
   @Nullable private PlaybackPreparer playbackPreparer;
 
@@ -335,6 +336,7 @@ public PlayerControlView(
         a.recycle();
       }
     }
+    visibilityListeners = new CopyOnWriteArrayList<>();
     period = new Timeline.Period();
     window = new Timeline.Window();
     formatBuilder = new StringBuilder();
@@ -510,13 +512,21 @@ public void setExtraAdGroupMarkers(
   }
 
   /**
-   * Sets the {@link VisibilityListener}.
+   * Adds a {@link VisibilityListener}.
    *
-   * @param listener The listener to be notified about visibility changes, or null to remove the
-   *     current listener.
+   * @param listener The listener to be notified about visibility changes.
    */
-  public void setVisibilityListener(@Nullable VisibilityListener listener) {
-    this.visibilityListener = listener;
+  public void addVisibilityListener(VisibilityListener listener) {
+    visibilityListeners.add(listener);
+  }
+
+  /**
+   * Removes a {@link VisibilityListener}.
+   *
+   * @param listener The listener to be removed.
+   */
+  public void removeVisibilityListener(VisibilityListener listener) {
+    visibilityListeners.remove(listener);
   }
 
   /**
@@ -697,7 +707,7 @@ public void setTimeBarMinUpdateInterval(int minUpdateIntervalMs) {
   public void show() {
     if (!isVisible()) {
       setVisibility(VISIBLE);
-      if (visibilityListener != null) {
+      for (VisibilityListener visibilityListener : visibilityListeners) {
         visibilityListener.onVisibilityChange(getVisibility());
       }
       updateAll();
@@ -711,7 +721,7 @@ public void show() {
   public void hide() {
     if (isVisible()) {
       setVisibility(GONE);
-      if (visibilityListener != null) {
+      for (VisibilityListener visibilityListener : visibilityListeners) {
         visibilityListener.onVisibilityChange(getVisibility());
       }
       removeCallbacks(updateProgressAction);
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
index 67701cbb93..3c6f6e1d9a 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -64,6 +64,7 @@
 import com.google.android.exoplayer2.util.ErrorMessageProvider;
 import com.google.android.exoplayer2.util.RepeatModeUtil;
 import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoDecoderSurfaceView;
 import com.google.android.exoplayer2.video.VideoListener;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -276,6 +277,7 @@
   private static final int SURFACE_TYPE_SURFACE_VIEW = 1;
   private static final int SURFACE_TYPE_TEXTURE_VIEW = 2;
   private static final int SURFACE_TYPE_MONO360_VIEW = 3;
+  private static final int SURFACE_TYPE_VIDEO_GL_SURFACE_VIEW = 4;
   // LINT.ThenChange(../../../../../../res/values/attrs.xml)
 
   @Nullable private final AspectRatioFrameLayout contentFrame;
@@ -292,6 +294,7 @@
 
   private Player player;
   private boolean useController;
+  @Nullable private PlayerControlView.VisibilityListener controllerVisibilityListener;
   private boolean useArtwork;
   @Nullable private Drawable defaultArtwork;
   private @ShowBuffering int showBuffering;
@@ -411,6 +414,9 @@ public PlayerView(Context context, @Nullable AttributeSet attrs, int defStyleAtt
           sphericalSurfaceView.setSingleTapListener(componentListener);
           surfaceView = sphericalSurfaceView;
           break;
+        case SURFACE_TYPE_VIDEO_GL_SURFACE_VIEW:
+          surfaceView = new VideoDecoderSurfaceView(context);
+          break;
         default:
           surfaceView = new SurfaceView(context);
           break;
@@ -478,6 +484,10 @@ public PlayerView(Context context, @Nullable AttributeSet attrs, int defStyleAtt
     this.controllerHideDuringAds = controllerHideDuringAds;
     this.useController = useController && controller != null;
     hideController();
+    updateContentDescription();
+    if (controller != null) {
+      controller.addVisibilityListener(/* listener= */ componentListener);
+    }
   }
 
   /**
@@ -539,6 +549,8 @@ public void setPlayer(@Nullable Player player) {
           oldVideoComponent.clearVideoTextureView((TextureView) surfaceView);
         } else if (surfaceView instanceof SphericalSurfaceView) {
           ((SphericalSurfaceView) surfaceView).setVideoComponent(null);
+        } else if (surfaceView instanceof VideoDecoderSurfaceView) {
+          oldVideoComponent.setOutputBufferRenderer(null);
         } else if (surfaceView instanceof SurfaceView) {
           oldVideoComponent.clearVideoSurfaceView((SurfaceView) surfaceView);
         }
@@ -565,6 +577,9 @@ public void setPlayer(@Nullable Player player) {
           newVideoComponent.setVideoTextureView((TextureView) surfaceView);
         } else if (surfaceView instanceof SphericalSurfaceView) {
           ((SphericalSurfaceView) surfaceView).setVideoComponent(newVideoComponent);
+        } else if (surfaceView instanceof VideoDecoderSurfaceView) {
+          newVideoComponent.setOutputBufferRenderer(
+              ((VideoDecoderSurfaceView) surfaceView).getOutputBufferRenderer());
         } else if (surfaceView instanceof SurfaceView) {
           newVideoComponent.setVideoSurfaceView((SurfaceView) surfaceView);
         }
@@ -677,8 +692,9 @@ public void setUseController(boolean useController) {
       controller.setPlayer(player);
     } else if (controller != null) {
       controller.hide();
-      controller.setPlayer(null);
+      controller.setPlayer(/* player= */ null);
     }
+    updateContentDescription();
   }
 
   /**
@@ -736,8 +752,8 @@ public void setShowBuffering(boolean showBuffering) {
    * buffering spinner is not displayed by default.
    *
    * @param showBuffering The mode that defines when the buffering spinner is displayed. One of
-   *     {@link #SHOW_BUFFERING_NEVER}, {@link #SHOW_BUFFERING_WHEN_PLAYING} and
-   *     {@link #SHOW_BUFFERING_ALWAYS}.
+   *     {@link #SHOW_BUFFERING_NEVER}, {@link #SHOW_BUFFERING_WHEN_PLAYING} and {@link
+   *     #SHOW_BUFFERING_ALWAYS}.
    */
   public void setShowBuffering(@ShowBuffering int showBuffering) {
     if (this.showBuffering != showBuffering) {
@@ -870,6 +886,7 @@ public boolean getControllerHideOnTouch() {
   public void setControllerHideOnTouch(boolean controllerHideOnTouch) {
     Assertions.checkState(controller != null);
     this.controllerHideOnTouch = controllerHideOnTouch;
+    updateContentDescription();
   }
 
   /**
@@ -911,7 +928,16 @@ public void setControllerHideDuringAds(boolean controllerHideDuringAds) {
   public void setControllerVisibilityListener(
       @Nullable PlayerControlView.VisibilityListener listener) {
     Assertions.checkState(controller != null);
-    controller.setVisibilityListener(listener);
+    if (this.controllerVisibilityListener == listener) {
+      return;
+    }
+    if (this.controllerVisibilityListener != null) {
+      controller.removeVisibilityListener(this.controllerVisibilityListener);
+    }
+    this.controllerVisibilityListener = listener;
+    if (listener != null) {
+      controller.addVisibilityListener(listener);
+    }
   }
 
   /**
@@ -1349,6 +1375,20 @@ private void updateErrorMessage() {
     }
   }
 
+  private void updateContentDescription() {
+    if (controller == null || !useController) {
+      setContentDescription(/* contentDescription= */ null);
+    } else if (controller.getVisibility() == View.VISIBLE) {
+      setContentDescription(
+          /* contentDescription= */ controllerHideOnTouch
+              ? getResources().getString(R.string.exo_controls_hide)
+              : null);
+    } else {
+      setContentDescription(
+          /* contentDescription= */ getResources().getString(R.string.exo_controls_show));
+    }
+  }
+
   @TargetApi(23)
   private static void configureEditModeLogoV23(Resources resources, ImageView logo) {
     logo.setImageDrawable(resources.getDrawable(R.drawable.exo_edit_mode_logo, null));
@@ -1408,7 +1448,8 @@ private boolean isDpadKey(int keyCode) {
           TextOutput,
           VideoListener,
           OnLayoutChangeListener,
-          SingleTapListener {
+          SingleTapListener,
+          PlayerControlView.VisibilityListener {
 
     // TextOutput implementation
 
@@ -1503,5 +1544,12 @@ public void onLayoutChange(
     public boolean onSingleTapUp(MotionEvent e) {
       return toggleControllerVisibility();
     }
+
+    // PlayerControlView.VisibilityListener implementation
+
+    @Override
+    public void onVisibilityChange(int visibility) {
+      updateContentDescription();
+    }
   }
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java
index b70fd277a9..4343800500 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/spherical/SceneRenderer.java
@@ -18,6 +18,7 @@
 import static com.google.android.exoplayer2.util.GlUtil.checkGlError;
 
 import android.graphics.SurfaceTexture;
+import android.media.MediaFormat;
 import android.opengl.GLES20;
 import android.opengl.Matrix;
 import androidx.annotation.Nullable;
@@ -142,7 +143,10 @@ public void shutdown() {
 
   @Override
   public void onVideoFrameAboutToBeRendered(
-      long presentationTimeUs, long releaseTimeNs, Format format) {
+      long presentationTimeUs,
+      long releaseTimeNs,
+      Format format,
+      @Nullable MediaFormat mediaFormat) {
     sampleTimestampQueue.add(releaseTimeNs, presentationTimeUs);
     setProjection(format.projectionData, format.stereoMode, releaseTimeNs);
   }
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index 706fba0e0b..b342d5d888 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -30,6 +30,7 @@
     <enum name="surface_view" value="1"/>
     <enum name="texture_view" value="2"/>
     <enum name="spherical_view" value="3"/>
+    <enum name="video_decoder_surface_view" value="4"/>
   </attr>
 
   <!-- Must be kept in sync with RepeatModeUtil -->
diff --git a/library/ui/src/main/res/values/strings.xml b/library/ui/src/main/res/values/strings.xml
index f0282b4991..74c5e1f3f6 100644
--- a/library/ui/src/main/res/values/strings.xml
+++ b/library/ui/src/main/res/values/strings.xml
@@ -14,6 +14,10 @@
      limitations under the License.
 -->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+  <!-- Description for a media player view to indicate that tapping on the view shows the playback controls. [CHAR LIMIT=50] -->
+  <string name="exo_controls_show">Show player controls</string>
+  <!-- Description for a media player view to indicate that tapping on the view hides the playback controls [CHAR LIMIT=50] -->
+  <string name="exo_controls_hide">Hide player controls</string>
   <!-- Description for a media control button that causes the previous track to be played. [CHAR LIMIT=30] -->
   <string name="exo_controls_previous_description">Previous track</string>
   <!-- Description for a media control button that causes the next track to be played. [CHAR LIMIT=30] -->
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
index 52f6121bae..7936f9b51c 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
@@ -29,6 +29,7 @@
 import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.testutil.ActionSchedule.ActionNode;
 import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerRunnable;
@@ -290,6 +291,31 @@ protected void doActionImpl(
     }
   }
 
+  /** Calls {@link SimpleExoPlayer#setAudioAttributes(AudioAttributes, boolean)}. */
+  public static final class SetAudioAttributes extends Action {
+
+    private final AudioAttributes audioAttributes;
+    private final boolean handleAudioFocus;
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param audioAttributes The attributes to use for audio playback.
+     * @param handleAudioFocus True if the player should handle audio focus, false otherwise.
+     */
+    public SetAudioAttributes(
+        String tag, AudioAttributes audioAttributes, boolean handleAudioFocus) {
+      super(tag, "SetAudioAttributes");
+      this.audioAttributes = audioAttributes;
+      this.handleAudioFocus = handleAudioFocus;
+    }
+
+    @Override
+    protected void doActionImpl(
+        SimpleExoPlayer player, DefaultTrackSelector trackSelector, Surface surface) {
+      player.setAudioAttributes(audioAttributes, handleAudioFocus);
+    }
+  }
+
   /** Calls {@link ExoPlayer#prepare(MediaSource)}. */
   public static final class PrepareSource extends Action {
 
@@ -297,12 +323,19 @@ protected void doActionImpl(
     private final boolean resetPosition;
     private final boolean resetState;
 
-    /** @param tag A tag to use for logging. */
+    /**
+     * @param tag A tag to use for logging.
+     * @param mediaSource The {@link MediaSource} to prepare the player with.
+     */
     public PrepareSource(String tag, MediaSource mediaSource) {
       this(tag, mediaSource, true, true);
     }
 
-    /** @param tag A tag to use for logging. */
+    /**
+     * @param tag A tag to use for logging.
+     * @param mediaSource The {@link MediaSource} to prepare the player with.
+     * @param resetPosition Whether the player's position should be reset.
+     */
     public PrepareSource(
         String tag, MediaSource mediaSource, boolean resetPosition, boolean resetState) {
       super(tag, "PrepareSource");
@@ -323,7 +356,10 @@ protected void doActionImpl(
 
     private final @Player.RepeatMode int repeatMode;
 
-    /** @param tag A tag to use for logging. */
+    /**
+     * @param tag A tag to use for logging.
+     * @param repeatMode The repeat mode.
+     */
     public SetRepeatMode(String tag, @Player.RepeatMode int repeatMode) {
       super(tag, "SetRepeatMode:" + repeatMode);
       this.repeatMode = repeatMode;
@@ -341,7 +377,10 @@ protected void doActionImpl(
 
     private final boolean shuffleModeEnabled;
 
-    /** @param tag A tag to use for logging. */
+    /**
+     * @param tag A tag to use for logging.
+     * @param shuffleModeEnabled Whether shuffling is enabled.
+     */
     public SetShuffleModeEnabled(String tag, boolean shuffleModeEnabled) {
       super(tag, "SetShuffleModeEnabled:" + shuffleModeEnabled);
       this.shuffleModeEnabled = shuffleModeEnabled;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
index 9cc8790757..cf363f6266 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
@@ -27,6 +27,7 @@
 import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.audio.AudioAttributes;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.testutil.Action.ClearVideoSurface;
 import com.google.android.exoplayer2.testutil.Action.ExecuteRunnable;
@@ -35,6 +36,7 @@
 import com.google.android.exoplayer2.testutil.Action.Seek;
 import com.google.android.exoplayer2.testutil.Action.SendBroadcast;
 import com.google.android.exoplayer2.testutil.Action.SendMessages;
+import com.google.android.exoplayer2.testutil.Action.SetAudioAttributes;
 import com.google.android.exoplayer2.testutil.Action.SetPlayWhenReady;
 import com.google.android.exoplayer2.testutil.Action.SetPlaybackParameters;
 import com.google.android.exoplayer2.testutil.Action.SetRendererDisabled;
@@ -133,7 +135,7 @@ public Builder delay(long delayMs) {
     }
 
     /**
-     * Schedules an action to be executed.
+     * Schedules an action.
      *
      * @param action The action to schedule.
      * @return The builder, for convenience.
@@ -143,7 +145,7 @@ public Builder apply(Action action) {
     }
 
     /**
-     * Schedules an action to be executed repeatedly.
+     * Schedules an action repeatedly.
      *
      * @param action The action to schedule.
      * @param intervalMs The interval between each repetition in milliseconds.
@@ -154,7 +156,7 @@ public Builder repeat(Action action, long intervalMs) {
     }
 
     /**
-     * Schedules a seek action to be executed.
+     * Schedules a seek action.
      *
      * @param positionMs The seek position.
      * @return The builder, for convenience.
@@ -164,7 +166,7 @@ public Builder seek(long positionMs) {
     }
 
     /**
-     * Schedules a seek action to be executed.
+     * Schedules a seek action.
      *
      * @param windowIndex The window to seek to.
      * @param positionMs The seek position.
@@ -175,7 +177,7 @@ public Builder seek(int windowIndex, long positionMs) {
     }
 
     /**
-     * Schedules a seek action to be executed and waits until playback resumes after the seek.
+     * Schedules a seek action and waits until playback resumes after the seek.
      *
      * @param positionMs The seek position.
      * @return The builder, for convenience.
@@ -196,7 +198,7 @@ public Builder waitForSeekProcessed() {
     }
 
     /**
-     * Schedules a playback parameters setting action to be executed.
+     * Schedules a playback parameters setting action.
      *
      * @param playbackParameters The playback parameters to set.
      * @return The builder, for convenience.
@@ -207,7 +209,7 @@ public Builder setPlaybackParameters(PlaybackParameters playbackParameters) {
     }
 
     /**
-     * Schedules a stop action to be executed.
+     * Schedules a stop action.
      *
      * @return The builder, for convenience.
      */
@@ -216,7 +218,7 @@ public Builder stop() {
     }
 
     /**
-     * Schedules a stop action to be executed.
+     * Schedules a stop action.
      *
      * @param reset Whether the player should be reset.
      * @return The builder, for convenience.
@@ -226,7 +228,7 @@ public Builder stop(boolean reset) {
     }
 
     /**
-     * Schedules a play action to be executed.
+     * Schedules a play action.
      *
      * @return The builder, for convenience.
      */
@@ -235,8 +237,8 @@ public Builder play() {
     }
 
     /**
-     * Schedules a play action to be executed, waits until the player reaches the specified
-     * position, and pauses the player again.
+     * Schedules a play action, waits until the player reaches the specified position, and pauses
+     * the player again.
      *
      * @param windowIndex The window index at which the player should be paused again.
      * @param positionMs The position in that window at which the player should be paused again.
@@ -247,8 +249,8 @@ public Builder playUntilPosition(int windowIndex, long positionMs) {
     }
 
     /**
-     * Schedules a play action to be executed, waits until the player reaches the start of the
-     * specified window, and pauses the player again.
+     * Schedules a play action, waits until the player reaches the start of the specified window,
+     * and pauses the player again.
      *
      * @param windowIndex The window index at which the player should be paused again.
      * @return The builder, for convenience.
@@ -258,7 +260,7 @@ public Builder playUntilStartOfWindow(int windowIndex) {
     }
 
     /**
-     * Schedules a pause action to be executed.
+     * Schedules a pause action.
      *
      * @return The builder, for convenience.
      */
@@ -267,7 +269,7 @@ public Builder pause() {
     }
 
     /**
-     * Schedules a renderer enable action to be executed.
+     * Schedules a renderer enable action.
      *
      * @return The builder, for convenience.
      */
@@ -276,7 +278,7 @@ public Builder enableRenderer(int index) {
     }
 
     /**
-     * Schedules a renderer disable action to be executed.
+     * Schedules a renderer disable action.
      *
      * @return The builder, for convenience.
      */
@@ -285,7 +287,7 @@ public Builder disableRenderer(int index) {
     }
 
     /**
-     * Schedules a clear video surface action to be executed.
+     * Schedules a clear video surface action.
      *
      * @return The builder, for convenience.
      */
@@ -294,7 +296,7 @@ public Builder clearVideoSurface() {
     }
 
     /**
-     * Schedules a set video surface action to be executed.
+     * Schedules a set video surface action.
      *
      * @return The builder, for convenience.
      */
@@ -303,7 +305,16 @@ public Builder setVideoSurface() {
     }
 
     /**
-     * Schedules a new source preparation action to be executed.
+     * Schedules application of audio attributes.
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder setAudioAttributes(AudioAttributes audioAttributes, boolean handleAudioFocus) {
+      return apply(new SetAudioAttributes(tag, audioAttributes, handleAudioFocus));
+    }
+
+    /**
+     * Schedules a new source preparation action.
      *
      * @return The builder, for convenience.
      */
@@ -312,7 +323,7 @@ public Builder prepareSource(MediaSource mediaSource) {
     }
 
     /**
-     * Schedules a new source preparation action to be executed.
+     * Schedules a new source preparation action.
      *
      * @see com.google.android.exoplayer2.ExoPlayer#prepare(MediaSource, boolean, boolean)
      * @return The builder, for convenience.
@@ -323,7 +334,7 @@ public Builder prepareSource(
     }
 
     /**
-     * Schedules a repeat mode setting action to be executed.
+     * Schedules a repeat mode setting action.
      *
      * @return The builder, for convenience.
      */
@@ -332,7 +343,7 @@ public Builder setRepeatMode(@Player.RepeatMode int repeatMode) {
     }
 
     /**
-     * Schedules a shuffle setting action to be executed.
+     * Schedules a shuffle setting action.
      *
      * @return The builder, for convenience.
      */
@@ -438,7 +449,7 @@ public Builder waitForIsLoading(boolean targetIsLoading) {
     }
 
     /**
-     * Schedules a {@link Runnable} to be executed.
+     * Schedules a {@link Runnable}.
      *
      * @return The builder, for convenience.
      */
@@ -560,8 +571,8 @@ public void setNext(ActionNode next) {
     }
 
     /**
-     * Schedules {@link #action} to be executed after {@link #delayMs}. The {@link #next} node will
-     * be scheduled immediately after {@link #action} is executed.
+     * Schedules {@link #action} after {@link #delayMs}. The {@link #next} node will be scheduled
+     * immediately after {@link #action} is executed.
      *
      * @param player The player to which actions should be applied.
      * @param trackSelector The track selector to which actions should be applied.
