diff --git a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
index c313a289f9..dfb56a2bcc 100644
--- a/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/chunk/VideoFormatSelectorUtil.java
@@ -58,7 +58,7 @@
       boolean filterHdFormats) throws DecoderQueryException {
     Point viewportSize = getViewportSize(context);
     return selectVideoFormats(formatWrappers, allowedContainerMimeTypes, filterHdFormats, true,
-        viewportSize.x, viewportSize.y);
+        false, viewportSize.x, viewportSize.y);
   }
 
   /**
@@ -80,6 +80,7 @@
    * @param filterHdFormats True to filter HD formats. False otherwise.
    * @param orientationMayChange True if the video's orientation may change with respect to the
    *     viewport during playback.
+   * @param secureDecoder True if secure decoder is required.
    * @param viewportWidth The width in pixels of the viewport within which the video will be
    *     displayed. If the viewport size may change, this should be set to the maximum possible
    *     width. -1 if selection should not be constrained by a viewport.
@@ -91,7 +92,7 @@
    */
   public static int[] selectVideoFormats(List<? extends FormatWrapper> formatWrappers,
       String[] allowedContainerMimeTypes, boolean filterHdFormats, boolean orientationMayChange,
-      int viewportWidth, int viewportHeight) throws DecoderQueryException {
+      boolean secureDecoder, int viewportWidth, int viewportHeight) throws DecoderQueryException {
     int maxVideoPixelsToRetain = Integer.MAX_VALUE;
     ArrayList<Integer> selectedIndexList = new ArrayList<>();
 
@@ -99,7 +100,7 @@
     int formatWrapperCount = formatWrappers.size();
     for (int i = 0; i < formatWrapperCount; i++) {
       Format format = formatWrappers.get(i).getFormat();
-      if (isFormatPlayable(format, allowedContainerMimeTypes, filterHdFormats)) {
+      if (isFormatPlayable(format, allowedContainerMimeTypes, filterHdFormats, secureDecoder)) {
         // Select the format for now. It may still be filtered in the second pass below.
         selectedIndexList.add(i);
         // Keep track of the number of pixels of the selected format whose resolution is the
@@ -139,7 +140,7 @@
    * whether HD formats should be filtered and a maximum decodable frame size in pixels.
    */
   private static boolean isFormatPlayable(Format format, String[] allowedContainerMimeTypes,
-      boolean filterHdFormats) throws DecoderQueryException {
+      boolean filterHdFormats, boolean secureDecoder) throws DecoderQueryException {
     if (allowedContainerMimeTypes != null
         && !Util.contains(allowedContainerMimeTypes, format.mimeType)) {
       // Filtering format based on its container mime type.
@@ -157,10 +158,10 @@ private static boolean isFormatPlayable(Format format, String[] allowedContainer
           videoMediaMimeType = MimeTypes.VIDEO_H264;
         }
         if (format.frameRate > 0) {
-          return MediaCodecUtil.isSizeAndRateSupportedV21(videoMediaMimeType, false, format.width,
-              format.height, format.frameRate);
+          return MediaCodecUtil.isSizeAndRateSupportedV21(videoMediaMimeType, secureDecoder,
+              format.width, format.height, format.frameRate);
         } else {
-          return MediaCodecUtil.isSizeSupportedV21(videoMediaMimeType, false, format.width,
+          return MediaCodecUtil.isSizeSupportedV21(videoMediaMimeType, secureDecoder, format.width,
               format.height);
         }
       }
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
index f855a0ee2b..d6020d42df 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/gts/DashTest.java
@@ -34,6 +34,9 @@
 import com.google.android.exoplayer.dash.mpd.MediaPresentationDescriptionParser;
 import com.google.android.exoplayer.dash.mpd.Period;
 import com.google.android.exoplayer.dash.mpd.Representation;
+import com.google.android.exoplayer.drm.FrameworkMediaCrypto;
+import com.google.android.exoplayer.drm.StreamingDrmSessionManager;
+import com.google.android.exoplayer.drm.UnsupportedDrmException;
 import com.google.android.exoplayer.playbacktests.util.ActionSchedule;
 import com.google.android.exoplayer.playbacktests.util.CodecCountersUtil;
 import com.google.android.exoplayer.playbacktests.util.DebugMediaCodecVideoTrackRenderer;
@@ -42,6 +45,7 @@
 import com.google.android.exoplayer.playbacktests.util.LogcatLogger;
 import com.google.android.exoplayer.playbacktests.util.MetricsLogger;
 import com.google.android.exoplayer.playbacktests.util.TestUtil;
+import com.google.android.exoplayer.playbacktests.util.WidevineMediaDrmCallback;
 import com.google.android.exoplayer.upstream.DataSource;
 import com.google.android.exoplayer.upstream.DefaultAllocator;
 import com.google.android.exoplayer.upstream.DefaultUriDataSource;
@@ -51,6 +55,8 @@
 
 import android.annotation.TargetApi;
 import android.media.MediaCodec;
+import android.media.MediaDrm;
+import android.media.UnsupportedSchemeException;
 import android.os.Handler;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Log;
@@ -61,6 +67,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.UUID;
 
 /**
  * Tests DASH playbacks using {@link ExoPlayer}.
@@ -79,12 +86,20 @@
 
   private static final String MANIFEST_URL_PREFIX = "https://storage.googleapis.com/exoplayer-test-"
       + "media-1/gen-3/screens/dash-vod-single-segment/";
+  // Clear content manifests.
   private static final String H264_MANIFEST = "manifest-h264.mpd";
   private static final String H265_MANIFEST = "manifest-h265.mpd";
   private static final String VP9_MANIFEST = "manifest-vp9.mpd";
   private static final String H264_23_MANIFEST = "manifest-h264-23.mpd";
   private static final String H264_24_MANIFEST = "manifest-h264-24.mpd";
   private static final String H264_29_MANIFEST = "manifest-h264-29.mpd";
+  // Widevine encrypted content manifests.
+  private static final String WIDEVINE_H264_MANIFEST = "manifest-h264-enc.mpd";
+  private static final String WIDEVINE_H265_MANIFEST = "manifest-h265-enc.mpd";
+  private static final String WIDEVINE_VP9_MANIFEST = "manifest-vp9-enc.mpd";
+  private static final String WIDEVINE_H264_23_MANIFEST = "manifest-h264-23-enc.mpd";
+  private static final String WIDEVINE_H264_24_MANIFEST = "manifest-h264-24-enc.mpd";
+  private static final String WIDEVINE_H264_29_MANIFEST = "manifest-h264-29-enc.mpd";
 
   private static final String AAC_AUDIO_REPRESENTATION_ID = "141";
   private static final String H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "avc-baseline-240";
@@ -135,6 +150,63 @@
           VP9_180P_VIDEO_REPRESENTATION_ID,
           VP9_360P_VIDEO_REPRESENTATION_ID};
 
+  // Widevine encrypted content representation ids.
+  private static final String WIDEVINE_AAC_AUDIO_REPRESENTATION_ID = "0";
+  private static final String WIDEVINE_H264_BASELINE_240P_VIDEO_REPRESENTATION_ID = "1";
+  private static final String WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID = "2";
+  private static final String WIDEVINE_H264_MAIN_240P_VIDEO_REPRESENTATION_ID = "3";
+  private static final String WIDEVINE_H264_MAIN_480P_VIDEO_REPRESENTATION_ID = "4";
+  // The highest quality H264 format mandated by the Android CDD.
+  private static final String WIDEVINE_H264_CDD_FIXED = Util.SDK_INT < 23
+      ? WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID
+      : WIDEVINE_H264_MAIN_480P_VIDEO_REPRESENTATION_ID;
+  // Multiple H264 formats mandated by the Android CDD. Note: The CDD actually mandated main profile
+  // support from API level 23, but we opt to test only from 24 due to known issues on API level 23
+  // when switching between baseline and main profiles on certain devices.
+  private static final String[] WIDEVINE_H264_CDD_ADAPTIVE = Util.SDK_INT < 24
+      ? new String[] {
+      WIDEVINE_H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
+      WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID}
+      : new String[] {
+      WIDEVINE_H264_BASELINE_240P_VIDEO_REPRESENTATION_ID,
+      WIDEVINE_H264_BASELINE_480P_VIDEO_REPRESENTATION_ID,
+      WIDEVINE_H264_MAIN_240P_VIDEO_REPRESENTATION_ID,
+      WIDEVINE_H264_MAIN_480P_VIDEO_REPRESENTATION_ID};
+
+  private static final String WIDEVINE_H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID = "2";
+  private static final String WIDEVINE_H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID = "2";
+  private static final String WIDEVINE_H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID = "2";
+
+  private static final String WIDEVINE_H265_BASELINE_288P_VIDEO_REPRESENTATION_ID = "1";
+  private static final String WIDEVINE_H265_BASELINE_360P_VIDEO_REPRESENTATION_ID = "2";
+  // The highest quality H265 format mandated by the Android CDD.
+  private static final String WIDEVINE_H265_CDD_FIXED =
+      WIDEVINE_H265_BASELINE_360P_VIDEO_REPRESENTATION_ID;
+  // Multiple H265 formats mandated by the Android CDD.
+  private static final String[] WIDEVINE_H265_CDD_ADAPTIVE =
+      new String[] {
+          WIDEVINE_H265_BASELINE_288P_VIDEO_REPRESENTATION_ID,
+          WIDEVINE_H265_BASELINE_360P_VIDEO_REPRESENTATION_ID};
+
+  private static final String WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID = "0";
+  private static final String WIDEVINE_VP9_180P_VIDEO_REPRESENTATION_ID = "1";
+  private static final String WIDEVINE_VP9_360P_VIDEO_REPRESENTATION_ID = "2";
+  // The highest quality VP9 format mandated by the Android CDD.
+  private static final String WIDEVINE_VP9_CDD_FIXED = VP9_360P_VIDEO_REPRESENTATION_ID;
+  // Multiple VP9 formats mandated by the Android CDD.
+  private static final String[] WIDEVINE_VP9_CDD_ADAPTIVE =
+      new String[] {
+          WIDEVINE_VP9_180P_VIDEO_REPRESENTATION_ID,
+          WIDEVINE_VP9_360P_VIDEO_REPRESENTATION_ID};
+
+  private static final String WIDEVINE_PROVIDER = "widevine_test";
+  private static final String WIDEVINE_SW_CRYPTO_CONTENT_ID = "exoplayer_test_1";
+  private static final String WIDEVINE_HW_ALL_CONTENT_ID = "exoplayer_test_2";
+  private static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
+  private static final String WIDEVINE_SECURITY_LEVEL_1 = "L1";
+  private static final String WIDEVINE_SECURITY_LEVEL_3 = "L3";
+  private static final String SECURITY_LEVEL_PROPERTY = "securityLevel";
+
   // Whether adaptive tests should enable video formats beyond those mandated by the Android CDD
   // if the device advertises support for them.
   private static final boolean ALLOW_ADDITIONAL_VIDEO_FORMATS = Util.SDK_INT >= 24;
@@ -190,7 +262,7 @@ public void testH264Fixed() throws IOException {
     }
     String streamName = "test_h264_fixed";
     testDashPlayback(getActivity(), streamName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-        H264_CDD_FIXED);
+        MimeTypes.VIDEO_H264, false, H264_CDD_FIXED);
   }
 
   public void testH264Adaptive() throws IOException {
@@ -199,8 +271,8 @@ public void testH264Adaptive() throws IOException {
       return;
     }
     String streamName = "test_h264_adaptive";
-    testDashPlayback(getActivity(), streamName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), streamName, H264_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
+        MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
   }
 
   public void testH264AdaptiveWithSeeking() throws IOException {
@@ -210,7 +282,8 @@ public void testH264AdaptiveWithSeeking() throws IOException {
     }
     String streamName = "test_h264_adaptive_with_seeking";
     testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, H264_MANIFEST,
-        AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+        AAC_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        H264_CDD_ADAPTIVE);
   }
 
   public void testH264AdaptiveWithRendererDisabling() throws IOException {
@@ -220,7 +293,8 @@ public void testH264AdaptiveWithRendererDisabling() throws IOException {
     }
     String streamName = "test_h264_adaptive_with_renderer_disabling";
     testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false, H264_MANIFEST,
-        AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, H264_CDD_ADAPTIVE);
+        AAC_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_H264, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        H264_CDD_ADAPTIVE);
   }
 
   // H265 CDD.
@@ -232,7 +306,7 @@ public void testH265Fixed() throws IOException {
     }
     String streamName = "test_h265_fixed";
     testDashPlayback(getActivity(), streamName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
-        H265_CDD_FIXED);
+        MimeTypes.VIDEO_H265, false, H265_CDD_FIXED);
   }
 
   public void testH265Adaptive() throws IOException {
@@ -241,8 +315,8 @@ public void testH265Adaptive() throws IOException {
       return;
     }
     String streamName = "test_h265_adaptive";
-    testDashPlayback(getActivity(), streamName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), streamName, H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false,
+        MimeTypes.VIDEO_H265, ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
   }
 
   public void testH265AdaptiveWithSeeking() throws IOException {
@@ -252,7 +326,8 @@ public void testH265AdaptiveWithSeeking() throws IOException {
     }
     String streamName = "test_h265_adaptive_with_seeking";
     testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, H265_MANIFEST,
-        AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
+        AAC_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_H265, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        H265_CDD_ADAPTIVE);
   }
 
   public void testH265AdaptiveWithRendererDisabling() throws IOException {
@@ -262,8 +337,8 @@ public void testH265AdaptiveWithRendererDisabling() throws IOException {
     }
     String streamName = "test_h265_adaptive_with_renderer_disabling";
     testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
-        H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        H265_CDD_ADAPTIVE);
+        H265_MANIFEST, AAC_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_H265,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, H265_CDD_ADAPTIVE);
     }
 
   // VP9 (CDD).
@@ -275,7 +350,7 @@ public void testVp9Fixed360p() throws IOException {
     }
     String streamName = "test_vp9_fixed_360p";
     testDashPlayback(getActivity(), streamName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false,
-        VP9_CDD_FIXED);
+        MimeTypes.VIDEO_VP9, false, VP9_CDD_FIXED);
   }
 
   public void testVp9Adaptive() throws IOException {
@@ -284,8 +359,8 @@ public void testVp9Adaptive() throws IOException {
       return;
     }
     String streamName = "test_vp9_adaptive";
-    testDashPlayback(getActivity(), streamName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID,
-        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
+    testDashPlayback(getActivity(), streamName, VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false,
+        MimeTypes.VIDEO_VP9, ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
   }
 
   public void testVp9AdaptiveWithSeeking() throws IOException {
@@ -295,7 +370,8 @@ public void testVp9AdaptiveWithSeeking() throws IOException {
     }
     String streamName = "test_vp9_adaptive_with_seeking";
     testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, VP9_MANIFEST,
-        VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
+        VORBIS_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_VP9, ALLOW_ADDITIONAL_VIDEO_FORMATS,
+        VP9_CDD_ADAPTIVE);
   }
 
   public void testVp9AdaptiveWithRendererDisabling() throws IOException {
@@ -305,8 +381,8 @@ public void testVp9AdaptiveWithRendererDisabling() throws IOException {
     }
     String streamName = "test_vp9_adaptive_with_renderer_disabling";
     testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
-        VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, ALLOW_ADDITIONAL_VIDEO_FORMATS,
-        VP9_CDD_ADAPTIVE);
+        VP9_MANIFEST, VORBIS_AUDIO_REPRESENTATION_ID, false, MimeTypes.VIDEO_VP9,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, VP9_CDD_ADAPTIVE);
   }
 
   // H264: Other frame-rates for output buffer count assertions.
@@ -319,7 +395,7 @@ public void test23FpsH264Fixed() throws IOException {
     }
     String streamName = "test_23fps_h264_fixed";
     testDashPlayback(getActivity(), streamName, H264_23_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        false, H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID);
+        false, MimeTypes.VIDEO_H264, false, H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID);
   }
 
   // 24 fps.
@@ -330,7 +406,7 @@ public void test24FpsH264Fixed() throws IOException {
     }
     String streamName = "test_24fps_h264_fixed";
     testDashPlayback(getActivity(), streamName, H264_24_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        false, H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID);
+        false, MimeTypes.VIDEO_H264, false, H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID);
   }
 
   // 29.97 fps.
@@ -341,28 +417,206 @@ public void test29FpsH264Fixed() throws IOException {
     }
     String streamName = "test_29fps_h264_fixed";
     testDashPlayback(getActivity(), streamName, H264_29_MANIFEST, AAC_AUDIO_REPRESENTATION_ID,
-        false, H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
+        false, MimeTypes.VIDEO_H264, false, H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
+  }
+
+  // Widevine encrypted media tests.
+  // H264 CDD.
+
+  public void testWidevineH264Fixed() throws IOException {
+    if (Util.SDK_INT < 18) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_fixed";
+    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_MANIFEST,
+        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264, false,
+        WIDEVINE_H264_CDD_FIXED);
+  }
+
+  public void testWidevineH264Adaptive() throws IOException {
+    if (Util.SDK_INT < 18 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_adaptive";
+    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_MANIFEST,
+        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H264_CDD_ADAPTIVE);
+  }
+
+  public void testWidevineH264AdaptiveWithSeeking() throws IOException {
+    if (Util.SDK_INT < 18 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_adaptive_with_seeking";
+    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, WIDEVINE_H264_MANIFEST,
+        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H264_CDD_ADAPTIVE);
+  }
+
+  public void testWidevineH264AdaptiveWithRendererDisabling() throws IOException {
+    if (Util.SDK_INT < 18 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H264)) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h264_adaptive_with_renderer_disabling";
+    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
+        WIDEVINE_H264_MANIFEST, WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H264_CDD_ADAPTIVE);
+  }
+
+  // H265 CDD.
+
+  public void testWidevineH265Fixed() throws IOException {
+    if (Util.SDK_INT < 23) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h265_fixed";
+    testDashPlayback(getActivity(), streamName, WIDEVINE_H265_MANIFEST,
+        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H265, false,
+        WIDEVINE_H265_CDD_FIXED);
+  }
+
+  public void testWidevineH265Adaptive() throws IOException {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h265_adaptive";
+    testDashPlayback(getActivity(), streamName, WIDEVINE_H265_MANIFEST,
+        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H265,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H265_CDD_ADAPTIVE);
+  }
+
+  public void testWidevineH265AdaptiveWithSeeking() throws IOException {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h265_adaptive_with_seeking";
+    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, WIDEVINE_H265_MANIFEST,
+        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H265,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H265_CDD_ADAPTIVE);
+  }
+
+  public void testWidevineH265AdaptiveWithRendererDisabling() throws IOException {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_H265)) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_h265_adaptive_with_renderer_disabling";
+    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
+        WIDEVINE_H265_MANIFEST, WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H265,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_H265_CDD_ADAPTIVE);
+  }
+
+  // VP9 (CDD).
+
+  public void testWidevineVp9Fixed360p() throws IOException {
+    if (Util.SDK_INT < 23) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_vp9_fixed_360p";
+    testDashPlayback(getActivity(), streamName, WIDEVINE_VP9_MANIFEST,
+        WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_VP9, false,
+        WIDEVINE_VP9_CDD_FIXED);
+  }
+
+  public void testWidevineVp9Adaptive() throws IOException {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_vp9_adaptive";
+    testDashPlayback(getActivity(), streamName, WIDEVINE_VP9_MANIFEST,
+        WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_VP9,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_VP9_CDD_ADAPTIVE);
+  }
+
+  public void testWidevineVp9AdaptiveWithSeeking() throws IOException {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_vp9_adaptive_with_seeking";
+    testDashPlayback(getActivity(), streamName, SEEKING_SCHEDULE, false, WIDEVINE_VP9_MANIFEST,
+        WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_VP9,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_VP9_CDD_ADAPTIVE);
+  }
+
+  public void testWidevineVp9AdaptiveWithRendererDisabling() throws IOException {
+    if (Util.SDK_INT < 24 || shouldSkipAdaptiveTest(MimeTypes.VIDEO_VP9)) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_vp9_adaptive_with_renderer_disabling";
+    testDashPlayback(getActivity(), streamName, RENDERER_DISABLING_SCHEDULE, false,
+        WIDEVINE_VP9_MANIFEST, WIDEVINE_VORBIS_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_VP9,
+        ALLOW_ADDITIONAL_VIDEO_FORMATS, WIDEVINE_VP9_CDD_ADAPTIVE);
+  }
+
+  // H264: Other frame-rates for output buffer count assertions.
+
+  // 23.976 fps.
+  public void testWidevine23FpsH264Fixed() throws IOException {
+    if (Util.SDK_INT < 23) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_23fps_h264_fixed";
+    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_23_MANIFEST,
+        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264, false,
+        WIDEVINE_H264_BASELINE_480P_23FPS_VIDEO_REPRESENTATION_ID);
+  }
+
+  // 24 fps.
+  public void testWidevine24FpsH264Fixed() throws IOException {
+    if (Util.SDK_INT < 23) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_24fps_h264_fixed";
+    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_24_MANIFEST,
+        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264, false,
+        WIDEVINE_H264_BASELINE_480P_24FPS_VIDEO_REPRESENTATION_ID);
+  }
+
+  // 29.97 fps.
+  public void testWidevine29FpsH264Fixed() throws IOException {
+    if (Util.SDK_INT < 23) {
+      // Pass.
+      return;
+    }
+    String streamName = "test_widevine_29fps_h264_fixed";
+    testDashPlayback(getActivity(), streamName, WIDEVINE_H264_29_MANIFEST,
+        WIDEVINE_AAC_AUDIO_REPRESENTATION_ID, true, MimeTypes.VIDEO_H264, false,
+        WIDEVINE_H264_BASELINE_480P_29FPS_VIDEO_REPRESENTATION_ID);
   }
 
   // Internal.
 
   private void testDashPlayback(HostActivity activity, String streamName, String manifestFileName,
-      String audioFormat, boolean canIncludeAdditionalVideoFormats, String... videoFormats)
-      throws IOException {
+      String audioFormat, boolean isWidevineEncrypted, String videoMimeType,
+      boolean canIncludeAdditionalVideoFormats, String... videoFormats) throws IOException {
     testDashPlayback(activity, streamName, null, true, manifestFileName, audioFormat,
-        canIncludeAdditionalVideoFormats, videoFormats);
+        isWidevineEncrypted, videoMimeType, canIncludeAdditionalVideoFormats, videoFormats);
   }
 
   private void testDashPlayback(HostActivity activity, String streamName,
       ActionSchedule actionSchedule, boolean fullPlaybackNoSeeking, String manifestFileName,
-      String audioFormat, boolean canIncludeAdditionalVideoFormats, String... videoFormats)
-      throws IOException {
+      String audioFormat, boolean isWidevineEncrypted, String videoMimeType,
+      boolean canIncludeAdditionalVideoFormats, String... videoFormats) throws IOException {
     MediaPresentationDescription mpd = TestUtil.loadManifest(activity, TAG,
         MANIFEST_URL_PREFIX + manifestFileName, new MediaPresentationDescriptionParser());
     MetricsLogger metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG,
         REPORT_NAME, streamName);
     DashHostedTest test = new DashHostedTest(streamName, mpd, metricsLogger, fullPlaybackNoSeeking,
-        audioFormat, canIncludeAdditionalVideoFormats, false, actionSchedule, videoFormats);
+        audioFormat, canIncludeAdditionalVideoFormats, isWidevineEncrypted, false, actionSchedule,
+        videoMimeType, videoFormats);
     activity.runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
     // Retry test exactly once if adaptive test fails due to excessive dropped buffers when playing
     // non-CDD required formats (b/28220076).
@@ -370,12 +624,12 @@ private void testDashPlayback(HostActivity activity, String streamName,
       metricsLogger = MetricsLogger.Factory.createDefault(getInstrumentation(), TAG, REPORT_NAME,
           streamName + "_cdd_limited_retry");
       test = new DashHostedTest(streamName, mpd, metricsLogger, fullPlaybackNoSeeking, audioFormat,
-          false, true, actionSchedule, videoFormats);
+          false, isWidevineEncrypted, true, actionSchedule, videoMimeType, videoFormats);
       activity.runTest(test, mpd.duration + MAX_ADDITIONAL_TIME_MS);
     }
   }
 
-  private boolean shouldSkipAdaptiveTest(String mimeType) throws IOException {
+  private static boolean shouldSkipAdaptiveTest(String mimeType) throws IOException {
     if (!MediaCodecUtil.getDecoderInfo(mimeType, false).adaptive) {
       assertTrue(Util.SDK_INT < 21);
       return true;
@@ -400,16 +654,19 @@ private boolean shouldSkipAdaptiveTest(String mimeType) throws IOException {
     private static final int AUDIO_EVENT_ID = 1;
 
     private final String streamName;
+    private final String videoMimeType;
     private final MediaPresentationDescription mpd;
     private final MetricsLogger metricsLogger;
     private final boolean fullPlaybackNoSeeking;
     private final boolean canIncludeAdditionalVideoFormats;
+    private final boolean isWidevineEncrypted;
     private final String[] audioFormats;
     private final String[] videoFormats;
 
     private CodecCounters videoCounters;
     private CodecCounters audioCounters;
     private boolean needsCddLimitedRetry;
+    private boolean needsSecureVideoDecoder;
     private TrackSelector videoTrackSelector;
 
     /**
@@ -421,13 +678,17 @@ private boolean shouldSkipAdaptiveTest(String mimeType) throws IOException {
      * @param audioFormat The audio format.
      * @param canIncludeAdditionalVideoFormats Whether to use video formats in addition to
      *     those listed in the videoFormats argument, if the device is capable of playing them.
+     * @param isWidevineEncrypted Whether the video is Widevine encrypted.
      * @param isCddLimitedRetry Whether this is a CDD limited retry following a previous failure.
+     * @param actionSchedule The action schedule for the test.
+     * @param videoMimeType The video mime type.
      * @param videoFormats The video formats.
      */
     public DashHostedTest(String streamName, MediaPresentationDescription mpd,
         MetricsLogger metricsLogger, boolean fullPlaybackNoSeeking, String audioFormat,
-        boolean canIncludeAdditionalVideoFormats, boolean isCddLimitedRetry,
-        ActionSchedule actionSchedule, String... videoFormats) {
+        boolean canIncludeAdditionalVideoFormats, boolean isWidevineEncrypted,
+        boolean isCddLimitedRetry, ActionSchedule actionSchedule, String videoMimeType,
+        String... videoFormats) {
       super(RENDERER_COUNT);
       Assertions.checkArgument(!(isCddLimitedRetry && canIncludeAdditionalVideoFormats));
       this.streamName = streamName;
@@ -436,6 +697,8 @@ public DashHostedTest(String streamName, MediaPresentationDescription mpd,
       this.fullPlaybackNoSeeking = fullPlaybackNoSeeking;
       this.audioFormats = new String[] {audioFormat};
       this.canIncludeAdditionalVideoFormats = canIncludeAdditionalVideoFormats;
+      this.isWidevineEncrypted = isWidevineEncrypted;
+      this.videoMimeType = videoMimeType;
       this.videoFormats = videoFormats;
       if (actionSchedule != null) {
         setSchedule(actionSchedule);
@@ -449,10 +712,30 @@ public DashHostedTest(String streamName, MediaPresentationDescription mpd,
       LoadControl loadControl = new DefaultLoadControl(new DefaultAllocator(BUFFER_SEGMENT_SIZE));
       String userAgent = TestUtil.getUserAgent(host);
 
+      StreamingDrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
+      if (isWidevineEncrypted) {
+        try {
+          // Force L3 if secure decoder is not available.
+          boolean useL3Widevine = MediaCodecUtil.getDecoderInfo(videoMimeType, true) == null;
+          String widevineContentId = getWidevineContentId(useL3Widevine);
+          WidevineMediaDrmCallback drmCallback =
+              new WidevineMediaDrmCallback(widevineContentId, WIDEVINE_PROVIDER);
+          drmSessionManager = StreamingDrmSessionManager.newWidevineInstance(
+              player.getPlaybackLooper(), drmCallback, null, handler, null);
+          String securityProperty = drmSessionManager.getPropertyString(SECURITY_LEVEL_PROPERTY);
+          if (useL3Widevine && !WIDEVINE_SECURITY_LEVEL_3.equals(securityProperty)) {
+            drmSessionManager.setPropertyString(SECURITY_LEVEL_PROPERTY, WIDEVINE_SECURITY_LEVEL_3);
+          }
+          needsSecureVideoDecoder = !useL3Widevine;
+        } catch (IOException | UnsupportedDrmException e) {
+          throw new IllegalStateException(e);
+        }
+      }
+
       // Build the video renderer.
       DataSource videoDataSource = new DefaultUriDataSource(host, null, userAgent);
       videoTrackSelector = new TrackSelector(AdaptationSet.TYPE_VIDEO,
-          canIncludeAdditionalVideoFormats, videoFormats);
+          canIncludeAdditionalVideoFormats, needsSecureVideoDecoder, videoFormats);
       ChunkSource videoChunkSource = new DashChunkSource(mpd, videoTrackSelector, videoDataSource,
           new FormatEvaluator.RandomEvaluator(0));
       ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,
@@ -460,13 +743,13 @@ public DashHostedTest(String streamName, MediaPresentationDescription mpd,
           MIN_LOADABLE_RETRY_COUNT);
       DebugMediaCodecVideoTrackRenderer videoRenderer = new DebugMediaCodecVideoTrackRenderer(host,
           videoSampleSource, MediaCodecSelector.DEFAULT, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT,
-          0, handler, logger, 50);
+          0, drmSessionManager, true, handler, logger, 50);
       videoCounters = videoRenderer.codecCounters;
       player.sendMessage(videoRenderer, DebugMediaCodecVideoTrackRenderer.MSG_SET_SURFACE, surface);
 
       // Build the audio renderer.
       DataSource audioDataSource = new DefaultUriDataSource(host, null, userAgent);
-      TrackSelector audioTrackSelector = new TrackSelector(AdaptationSet.TYPE_AUDIO, false,
+      TrackSelector audioTrackSelector = new TrackSelector(AdaptationSet.TYPE_AUDIO, false, false,
           audioFormats);
       ChunkSource audioChunkSource = new DashChunkSource(mpd, audioTrackSelector, audioDataSource,
           null);
@@ -474,7 +757,7 @@ public DashHostedTest(String streamName, MediaPresentationDescription mpd,
           AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, handler, logger, AUDIO_EVENT_ID,
           MIN_LOADABLE_RETRY_COUNT);
       MediaCodecAudioTrackRenderer audioRenderer = new MediaCodecAudioTrackRenderer(
-          audioSampleSource, MediaCodecSelector.DEFAULT, handler, logger);
+          audioSampleSource, MediaCodecSelector.DEFAULT, drmSessionManager, true, handler, logger);
       audioCounters = audioRenderer.codecCounters;
 
       TrackRenderer[] renderers = new TrackRenderer[RENDERER_COUNT];
@@ -555,20 +838,37 @@ protected void logMetrics() {
       metricsLogger.close();
     }
 
+    @TargetApi(18)
+    private static String getWidevineContentId(boolean widevineForceL3) {
+      if (widevineForceL3) {
+        return WIDEVINE_SW_CRYPTO_CONTENT_ID;
+      }
+      try {
+        MediaDrm mediaDrm = new MediaDrm(WIDEVINE_UUID);
+        String securityLevel = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
+        return WIDEVINE_SECURITY_LEVEL_1.equals(securityLevel) ? WIDEVINE_HW_ALL_CONTENT_ID
+            : WIDEVINE_SW_CRYPTO_CONTENT_ID;
+      } catch (UnsupportedSchemeException e) {
+        throw new IllegalStateException(e);
+      }
+    }
+
     private static final class TrackSelector implements DashTrackSelector {
 
       private final int adaptationSetType;
       private final String[] representationIds;
       private final boolean canIncludeAdditionalVideoRepresentations;
+      private final boolean needsSecureDecoder;
 
       public boolean includedAdditionalVideoRepresentations;
 
       private TrackSelector(int adaptationSetType, boolean canIncludeAdditionalVideoRepresentations,
-          String[] representationIds) {
+          boolean needsSecureDecoder, String[] representationIds) {
         Assertions.checkState(!canIncludeAdditionalVideoRepresentations
             || adaptationSetType == AdaptationSet.TYPE_VIDEO);
         this.adaptationSetType = adaptationSetType;
         this.canIncludeAdditionalVideoRepresentations = canIncludeAdditionalVideoRepresentations;
+        this.needsSecureDecoder = needsSecureDecoder;
         this.representationIds = representationIds;
       }
 
@@ -579,7 +879,7 @@ public void selectTracks(MediaPresentationDescription manifest, int periodIndex,
         int adaptationSetIndex = period.getAdaptationSetIndex(adaptationSetType);
         AdaptationSet adaptationSet = period.adaptationSets.get(adaptationSetIndex);
         int[] representationIndices = getRepresentationIndices(adaptationSet, representationIds,
-            canIncludeAdditionalVideoRepresentations);
+            canIncludeAdditionalVideoRepresentations, needsSecureDecoder);
         if (representationIndices.length > representationIds.length) {
           includedAdditionalVideoRepresentations = true;
         }
@@ -592,8 +892,8 @@ public void selectTracks(MediaPresentationDescription manifest, int periodIndex,
       }
 
       private static int[] getRepresentationIndices(AdaptationSet adaptationSet,
-          String[] representationIds, boolean canIncludeAdditionalVideoRepresentations)
-          throws IOException {
+          String[] representationIds, boolean canIncludeAdditionalVideoRepresentations,
+          boolean needsSecureDecoder) throws IOException {
         List<Representation> availableRepresentations = adaptationSet.representations;
         List<Integer> selectedRepresentationIndices = new ArrayList<>();
 
@@ -615,7 +915,7 @@ public void selectTracks(MediaPresentationDescription manifest, int periodIndex,
         // Select additional video representations, if supported by the device.
         if (canIncludeAdditionalVideoRepresentations) {
            int[] supportedVideoRepresentationIndices = VideoFormatSelectorUtil.selectVideoFormats(
-               availableRepresentations, null, false, true, -1, -1);
+               availableRepresentations, null, false, true, needsSecureDecoder, -1, -1);
            for (int i = 0; i < supportedVideoRepresentationIndices.length; i++) {
              int representationIndex = supportedVideoRepresentationIndices[i];
              if (!selectedRepresentationIndices.contains(representationIndex)) {
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
index c930c74fd3..936ca54672 100644
--- a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/DebugMediaCodecVideoTrackRenderer.java
@@ -19,6 +19,8 @@
 import com.google.android.exoplayer.MediaCodecSelector;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.SampleSource;
+import com.google.android.exoplayer.drm.DrmSessionManager;
+import com.google.android.exoplayer.drm.FrameworkMediaCrypto;
 
 import android.annotation.TargetApi;
 import android.content.Context;
@@ -43,9 +45,12 @@
 
   public DebugMediaCodecVideoTrackRenderer(Context context, SampleSource source,
       MediaCodecSelector mediaCodecSelector, int videoScalingMode, long allowedJoiningTimeMs,
-      Handler eventHandler, EventListener eventListener, int maxDroppedFrameCountToNotify) {
-    super(context, source, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs, null, false,
-        eventHandler, eventListener, maxDroppedFrameCountToNotify);
+      DrmSessionManager<FrameworkMediaCrypto> drmSessionManager,
+      boolean playClearSamplesWithoutKeys, Handler eventHandler, EventListener eventListener,
+      int maxDroppedFrameCountToNotify) {
+    super(context, source, mediaCodecSelector, videoScalingMode, allowedJoiningTimeMs,
+        drmSessionManager, playClearSamplesWithoutKeys, eventHandler, eventListener,
+        maxDroppedFrameCountToNotify);
     startIndex = 0;
     queueSize = 0;
   }
diff --git a/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/WidevineMediaDrmCallback.java b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/WidevineMediaDrmCallback.java
new file mode 100644
index 0000000000..e98cd9a8c8
--- /dev/null
+++ b/playbacktests/src/main/java/com/google/android/exoplayer/playbacktests/util/WidevineMediaDrmCallback.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.playbacktests.util;
+
+import com.google.android.exoplayer.drm.ExoMediaDrm.KeyRequest;
+import com.google.android.exoplayer.drm.ExoMediaDrm.ProvisionRequest;
+import com.google.android.exoplayer.drm.MediaDrmCallback;
+import com.google.android.exoplayer.util.Util;
+
+import android.annotation.TargetApi;
+import android.text.TextUtils;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.UUID;
+
+/**
+ * A {@link MediaDrmCallback} for Widevine test content.
+ */
+@TargetApi(18)
+public final class WidevineMediaDrmCallback implements MediaDrmCallback {
+
+  private static final String WIDEVINE_GTS_DEFAULT_BASE_URI =
+      "https://proxy.uat.widevine.com/proxy";
+
+  private final String defaultUri;
+
+  public WidevineMediaDrmCallback(String contentId, String provider) {
+    String params = "?video_id=" + contentId + "&provider=" + provider;
+    defaultUri = WIDEVINE_GTS_DEFAULT_BASE_URI + params;
+  }
+
+  @Override
+  public byte[] executeProvisionRequest(UUID uuid, ProvisionRequest request) throws IOException {
+    String url = request.getDefaultUrl() + "&signedRequest=" + new String(request.getData(),
+        Charset.defaultCharset());
+    return Util.executePost(url, null, null);
+  }
+
+  @Override
+  public byte[] executeKeyRequest(UUID uuid, KeyRequest request) throws IOException {
+    String url = request.getDefaultUrl();
+    if (TextUtils.isEmpty(url)) {
+      url = defaultUri;
+    }
+    return Util.executePost(url, request.getData(), null);
+  }
+
+}
