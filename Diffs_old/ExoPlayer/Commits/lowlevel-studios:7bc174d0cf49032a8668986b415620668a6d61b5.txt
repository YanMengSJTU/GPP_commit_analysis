diff --git a/ISSUE_TEMPLATE b/ISSUE_TEMPLATE
index 1b912312d1..807888a447 100644
--- a/ISSUE_TEMPLATE
+++ b/ISSUE_TEMPLATE
@@ -1,5 +1,3 @@
-*** ISSUES THAT IGNORE THIS TEMPLATE WILL BE CLOSED WITHOUT INVESTIGATION ***
-
 Before filing an issue:
 -----------------------
 - Search existing issues, including issues that are closed.
@@ -26,7 +24,7 @@ Describe how the issue can be reproduced, ideally using the ExoPlayer demo app.
 ### Link to test content
 Provide a link to media that reproduces the issue. If you don't wish to post it
 publicly, please submit the issue, then email the link to
-dev.exoplayer@gmail.com including the issue number in the subject line.
+dev.exoplayer@gmail.com using a subject in the format "Issue #1234".
 
 ### Version of ExoPlayer being used
 Specify the absolute version number. Avoid using terms such as "latest".
@@ -40,5 +38,4 @@ devices and Android versions.
 Capture a full bug report using "adb bugreport". Output from "adb logcat" or a
 log snippet is NOT sufficient. Please attach the captured bug report as a file.
 If you don't wish to post it publicly, please submit the issue, then email the
-bug report to dev.exoplayer@gmail.com including the issue number in the subject
-line.
+bug report to dev.exoplayer@gmail.com using a subject in the format "Issue #1234".
diff --git a/README.md b/README.md
index ecfe3eb96f..8755ac588d 100644
--- a/README.md
+++ b/README.md
@@ -42,7 +42,7 @@ Next add a gradle compile dependency to the `build.gradle` file of your app
 module. The following will add a dependency to the full library:
 
 ```gradle
-compile 'com.google.android.exoplayer:exoplayer:2.X.X'
+implementation 'com.google.android.exoplayer:exoplayer:2.X.X'
 ```
 
 where `2.X.X` is your preferred version. Alternatively, you can depend on only
@@ -51,9 +51,9 @@ dependencies on the Core, DASH and UI library modules, as might be required for
 an app that plays DASH content:
 
 ```gradle
-compile 'com.google.android.exoplayer:exoplayer-core:2.X.X'
-compile 'com.google.android.exoplayer:exoplayer-dash:2.X.X'
-compile 'com.google.android.exoplayer:exoplayer-ui:2.X.X'
+implementation 'com.google.android.exoplayer:exoplayer-core:2.X.X'
+implementation 'com.google.android.exoplayer:exoplayer-dash:2.X.X'
+implementation 'com.google.android.exoplayer:exoplayer-ui:2.X.X'
 ```
 
 The available library modules are listed below. Adding a dependency to the full
@@ -68,7 +68,7 @@ individually.
 
 In addition to library modules, ExoPlayer has multiple extension modules that
 depend on external libraries to provide additional functionality. Some
-extensions are available from JCenter, whereas others must be built manaully.
+extensions are available from JCenter, whereas others must be built manually.
 Browse the [extensions directory][] and their individual READMEs for details.
 
 More information on the library and extension modules that are available from
@@ -105,9 +105,9 @@ You should now see the ExoPlayer modules appear as part of your project. You can
 depend on them as you would on any other local module, for example:
 
 ```gradle
-compile project(':exoplayer-library-core')
-compile project(':exoplayer-library-dash')
-compile project(':exoplayer-library-ui')
+implementation project(':exoplayer-library-core')
+implementation project(':exoplayer-library-dash')
+implementation project(':exoplayer-library-ui')
 ```
 
 ## Developing ExoPlayer ##
diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 579c2a92ac..3148cf0779 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -1,5 +1,208 @@
 # Release notes #
 
+### 2.7.2 ###
+
+* Gradle: Upgrade Gradle version from 4.1 to 4.4 so it can work with Android
+  Studio 3.1 ([#3708](https://github.com/google/ExoPlayer/issues/3708)).
+* Match codecs starting with "mp4a" to different Audio MimeTypes
+  ([#3779](https://github.com/google/ExoPlayer/issues/3779)).
+* Fix ANR issue on Redmi 4X and Redmi Note 4
+  ([#4006](https://github.com/google/ExoPlayer/issues/4006)).
+* Fix handling of zero padded strings when parsing Matroska streams
+  ([#4010](https://github.com/google/ExoPlayer/issues/4010)).
+* Fix "Decoder input buffer too small" error when playing some FLAC streams.
+* MediaSession extension: Omit fast forward and rewind actions when media is not
+  seekable ([#4001](https://github.com/google/ExoPlayer/issues/4001)).
+
+### 2.7.1 ###
+
+* Gradle: Replaced 'compile' (deprecated) with 'implementation' and
+  'api'. This may lead to build breakage for applications upgrading from
+  previous version that rely on indirect dependencies of certain modules. In
+  such cases, application developers need to add the missing dependency to
+  their gradle file. You can read more about the new dependency configurations
+  [here](https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#new_configurations).
+* HlsMediaSource: Make HLS periods start at zero instead of the epoch.
+  Applications that rely on HLS timelines having a period starting at
+  the epoch will need to update their handling of HLS timelines. The program
+  date time is still available via the informational
+  `Timeline.Window.windowStartTimeMs` field
+  ([#3865](https://github.com/google/ExoPlayer/issues/3865),
+  [#3888](https://github.com/google/ExoPlayer/issues/3888)).
+* Enable seeking in MP4 streams where duration is set incorrectly in the track
+  header ([#3926](https://github.com/google/ExoPlayer/issues/3926)).
+* Video: Force rendering a frame periodically in `MediaCodecVideoRenderer` and
+  `LibvpxVideoRenderer`, even if it is late.
+
+### 2.7.0 ###
+
+* Player interface:
+  * Add optional parameter to `stop` to reset the player when stopping.
+  * Add a reason to `EventListener.onTimelineChanged` to distinguish between
+    initial preparation, reset and dynamic updates.
+  * Add `Player.DISCONTINUITY_REASON_AD_INSERTION` to the possible reasons
+    reported in `Eventlistener.onPositionDiscontinuity` to distinguish
+    transitions to and from ads within one period from transitions between
+    periods.
+  * Replaced `ExoPlayer.sendMessages` with `ExoPlayer.createMessage` to allow
+    more customization of the message. Now supports setting a message delivery
+    playback position and/or a delivery handler
+    ([#2189](https://github.com/google/ExoPlayer/issues/2189)).
+  * Add `Player.VideoComponent`, `Player.TextComponent` and
+    `Player.MetadataComponent` interfaces that define optional video, text and
+    metadata output functionality. New `getVideoComponent`, `getTextComponent`
+    and `getMetadataComponent` methods provide access to this functionality.
+* Add `ExoPlayer.setSeekParameters` for controlling how seek operations are
+  performed. The `SeekParameters` class contains defaults for exact seeking and
+  seeking to the closest sync points before, either side or after specified seek
+  positions. `SeekParameters` are not currently supported when playing HLS
+  streams.
+* DefaultTrackSelector:
+  * Replace `DefaultTrackSelector.Parameters` copy methods with a builder.
+  * Support disabling of individual text track selection flags.
+* Buffering:
+  * Allow a back-buffer of media to be retained behind the current playback
+    position, for fast backward seeking. The back-buffer can be configured by
+    custom `LoadControl` implementations.
+  * Add ability for `SequenceableLoader` to re-evaluate its buffer and discard
+    buffered media so that it can be re-buffered in a different quality.
+  * Allow more flexible loading strategy when playing media containing multiple
+    sub-streams, by allowing injection of custom `CompositeSequenceableLoader`
+    factories through `DashMediaSource.Factory`, `HlsMediaSource.Factory`,
+    `SsMediaSource.Factory`, and `MergingMediaSource`.
+  * Play out existing buffer before retrying for progressive live streams
+    ([#1606](https://github.com/google/ExoPlayer/issues/1606)).
+* UI components:
+  * Generalized player and control views to allow them to bind with any
+    `Player`, and renamed them to `PlayerView` and `PlayerControlView`
+    respectively.
+  * Made `PlayerView` automatically apply video rotation when configured to use
+    `TextureView` ([#91](https://github.com/google/ExoPlayer/issues/91)).
+  * Made `PlayerView` play button behave correctly when the player is ended
+    ([#3689](https://github.com/google/ExoPlayer/issues/3689)), and call a
+    `PlaybackPreparer` when the player is idle.
+* DRM: Optimistically attempt playback of DRM protected content that does not
+  declare scheme specific init data in the manifest. If playback of clear
+  samples without keys is allowed, delay DRM session error propagation until
+  keys are actually needed
+  ([#3630](https://github.com/google/ExoPlayer/issues/3630)).
+* DASH:
+  * Support in-band Emsg events targeting the player with scheme id
+    "urn:mpeg:dash:event:2012" and scheme values "1", "2" and "3".
+  * Support EventStream elements in DASH manifests.
+* HLS:
+    * Add opt-in support for chunkless preparation in HLS. This allows an
+      HLS source to finish preparation without downloading any chunks, which can
+      significantly reduce initial buffering time
+      ([#3149](https://github.com/google/ExoPlayer/issues/3149)). More details
+      can be found
+      [here](https://medium.com/google-exoplayer/faster-hls-preparation-f6611aa15ea6).
+    * Fail if unable to sync with the Transport Stream, rather than entering
+      stuck in an indefinite buffering state.
+    * Fix mime type propagation
+      ([#3653](https://github.com/google/ExoPlayer/issues/3653)).
+    * Fix ID3 context reuse across segment format changes
+      ([#3622](https://github.com/google/ExoPlayer/issues/3622)).
+    * Use long for media sequence numbers
+      ([#3747](https://github.com/google/ExoPlayer/issues/3747))
+    * Add initial support for the EXT-X-GAP tag.
+* Audio:
+  * Support TrueHD passthrough for rechunked samples in Matroska files
+    ([#2147](https://github.com/google/ExoPlayer/issues/2147)).
+  * Support resampling 24-bit and 32-bit integer to 32-bit float for high
+    resolution output in `DefaultAudioSink`
+    ([#3635](https://github.com/google/ExoPlayer/pull/3635)).
+* Captions:
+  * Basic support for PGS subtitles
+    ([#3008](https://github.com/google/ExoPlayer/issues/3008)).
+  * Fix handling of CEA-608 captions where multiple buffers have the same
+    presentation timestamp
+    ([#3782](https://github.com/google/ExoPlayer/issues/3782)).
+* Caching:
+  * Fix cache corruption issue
+    ([#3762](https://github.com/google/ExoPlayer/issues/3762)).
+  * Implement periodic check in `CacheDataSource` to see whether it's possible
+    to switch to reading/writing the cache having initially bypassed it.
+* IMA extension:
+    * Fix the player getting stuck when an ad group fails to load
+      ([#3584](https://github.com/google/ExoPlayer/issues/3584)).
+    * Work around loadAd not being called beore the LOADED AdEvent arrives
+      ([#3552](https://github.com/google/ExoPlayer/issues/3552)).
+    * Handle asset mismatch errors
+      ([#3801](https://github.com/google/ExoPlayer/issues/3801)).
+    * Add support for playing non-Extractor content MediaSources in
+      the IMA demo app
+      ([#3676](https://github.com/google/ExoPlayer/issues/3676)).
+    * Fix handling of ad tags where ad groups are out of order
+      ([#3716](https://github.com/google/ExoPlayer/issues/3716)).
+    * Fix handling of ad tags with only preroll/postroll ad groups
+      ([#3715](https://github.com/google/ExoPlayer/issues/3715)).
+    * Propagate ad media preparation errors to IMA so that the ads can be
+      skipped.
+    * Handle exceptions in IMA callbacks so that can be logged less verbosely.
+* New Cast extension. Simplifies toggling between local and Cast playbacks.
+* `EventLogger` moved from the demo app into the core library.
+* Fix ANR issue on the Huawei P8 Lite, Huawei Y6II, Moto C+, Meizu M5C,
+  Lenovo K4 Note and Sony Xperia E5.
+  ([#3724](https://github.com/google/ExoPlayer/issues/3724),
+  [#3835](https://github.com/google/ExoPlayer/issues/3835)).
+* Fix potential NPE when removing media sources from a
+  DynamicConcatenatingMediaSource
+  ([#3796](https://github.com/google/ExoPlayer/issues/3796)).
+* Check `sys.display-size` on Philips ATVs
+  ([#3807](https://github.com/google/ExoPlayer/issues/3807)).
+* Release `Extractor`s on the loading thread to avoid potentially leaking
+  resources when the playback thread has quit by the time the loading task has
+  completed.
+* ID3: Better handle malformed ID3 data
+  ([#3792](https://github.com/google/ExoPlayer/issues/3792).
+* Support 14-bit mode and little endianness in DTS PES packets
+  ([#3340](https://github.com/google/ExoPlayer/issues/3340)).
+
+### 2.6.1 ###
+
+* Add factories to `ExtractorMediaSource`, `HlsMediaSource`, `SsMediaSource`,
+  `DashMediaSource` and `SingleSampleMediaSource`.
+* Use the same listener `MediaSourceEventListener` for all MediaSource
+  implementations.
+* IMA extension:
+  * Support non-ExtractorMediaSource ads
+    ([#3302](https://github.com/google/ExoPlayer/issues/3302)).
+  * Skip ads before the ad preceding the player's initial seek position
+    ([#3527](https://github.com/google/ExoPlayer/issues/3527)).
+  * Fix ad loading when there is no preroll.
+  * Add an option to turn off hiding controls during ad playback
+    ([#3532](https://github.com/google/ExoPlayer/issues/3532)).
+  * Support specifying an ads response instead of an ad tag
+    ([#3548](https://github.com/google/ExoPlayer/issues/3548)).
+  * Support overriding the ad load timeout
+    ([#3556](https://github.com/google/ExoPlayer/issues/3556)).
+* DASH: Support time zone designators in ISO8601 UTCTiming elements
+  ([#3524](https://github.com/google/ExoPlayer/issues/3524)).
+* Audio:
+  * Support 32-bit PCM float output from `DefaultAudioSink`, and add an option
+    to use this with `FfmpegAudioRenderer`.
+  * Add support for extracting 32-bit WAVE files
+    ([#3379](https://github.com/google/ExoPlayer/issues/3379)).
+  * Support extraction and decoding of Dolby Atmos
+    ([#2465](https://github.com/google/ExoPlayer/issues/2465)).
+  * Fix handling of playback parameter changes while paused when followed by a
+    seek.
+* SimpleExoPlayer: Allow multiple audio and video debug listeners.
+* DefaultTrackSelector: Support undefined language text track selection when the
+  preferred language is not available
+  ([#2980](https://github.com/google/ExoPlayer/issues/2980)).
+* Add options to `DefaultLoadControl` to set maximum buffer size in bytes and
+  to choose whether size or time constraints are prioritized.
+* Use surfaceless context for secure `DummySurface`, if available
+  ([#3558](https://github.com/google/ExoPlayer/issues/3558)).
+* FLV: Fix playback of live streams that do not contain an audio track
+  ([#3188](https://github.com/google/ExoPlayer/issues/3188)).
+* CEA-608: Fix handling of row count changes in roll-up mode
+  ([#3513](https://github.com/google/ExoPlayer/issues/3513)).
+* Prevent period transitions when seeking to the end of a period when paused
+  ([#2439](https://github.com/google/ExoPlayer/issues/2439)).
+
 ### 2.6.0 ###
 
 * Removed "r" prefix from versions. This release is "2.6.0", not "r2.6.0".
@@ -142,7 +345,7 @@
   easy and seamless way of incorporating display ads into ExoPlayer playbacks.
   You can read more about the IMA extension
   [here](https://medium.com/google-exoplayer/playing-ads-with-exoplayer-and-ima-868dfd767ea).
-* MediaSession extension: Provides an easy to to connect ExoPlayer with
+* MediaSession extension: Provides an easy way to connect ExoPlayer with
   MediaSessionCompat in the Android Support Library.
 * RTMP extension: An extension for playing streams over RTMP.
 * Build: Made it easier for application developers to depend on a local checkout
diff --git a/build.gradle b/build.gradle
index cbdd5c1bf3..10fd1215a0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -17,8 +17,8 @@ buildscript {
         google()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.0'
-        classpath 'com.novoda:bintray-release:0.5.0'
+        classpath 'com.android.tools.build:gradle:3.1.0'
+        classpath 'com.novoda:bintray-release:0.8.1'
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:4.4.18'
     }
     // Workaround for the following test coverage issue. Remove when fixed:
diff --git a/constants.gradle b/constants.gradle
index 2a7754d65c..61b2e44b27 100644
--- a/constants.gradle
+++ b/constants.gradle
@@ -12,23 +12,25 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 project.ext {
+    // ExoPlayer version and version code.
+    releaseVersion = '2.7.2'
+    releaseVersionCode = 2702
     // Important: ExoPlayer specifies a minSdkVersion of 14 because various
     // components provided by the library may be of use on older devices.
     // However, please note that the core media playback functionality provided
     // by the library requires API level 16 or greater.
     minSdkVersion = 14
-    compileSdkVersion = 26
-    targetSdkVersion = 26
-    buildToolsVersion = '26.0.2'
+    targetSdkVersion = 27
+    compileSdkVersion = 27
+    buildToolsVersion = '27.0.3'
     testSupportLibraryVersion = '0.5'
     supportLibraryVersion = '27.0.0'
     playServicesLibraryVersion = '11.4.2'
     dexmakerVersion = '1.2'
     mockitoVersion = '1.9.5'
     junitVersion = '4.12'
-    truthVersion = '0.35'
-    robolectricVersion = '3.4.2'
-    releaseVersion = '2.6.0'
+    truthVersion = '0.39'
+    robolectricVersion = '3.7.1'
     modulePrefix = ':'
     if (gradle.ext.has('exoplayerModulePrefix')) {
         modulePrefix += gradle.ext.exoplayerModulePrefix
diff --git a/core_settings.gradle b/core_settings.gradle
index 7a8320b1a1..c4914e3040 100644
--- a/core_settings.gradle
+++ b/core_settings.gradle
@@ -24,10 +24,12 @@ include modulePrefix + 'library-hls'
 include modulePrefix + 'library-smoothstreaming'
 include modulePrefix + 'library-ui'
 include modulePrefix + 'testutils'
+include modulePrefix + 'testutils-robolectric'
 include modulePrefix + 'extension-ffmpeg'
 include modulePrefix + 'extension-flac'
 include modulePrefix + 'extension-gvr'
 include modulePrefix + 'extension-ima'
+include modulePrefix + 'extension-cast'
 include modulePrefix + 'extension-mediasession'
 include modulePrefix + 'extension-okhttp'
 include modulePrefix + 'extension-opus'
@@ -42,10 +44,12 @@ project(modulePrefix + 'library-hls').projectDir = new File(rootDir, 'library/hl
 project(modulePrefix + 'library-smoothstreaming').projectDir = new File(rootDir, 'library/smoothstreaming')
 project(modulePrefix + 'library-ui').projectDir = new File(rootDir, 'library/ui')
 project(modulePrefix + 'testutils').projectDir = new File(rootDir, 'testutils')
+project(modulePrefix + 'testutils-robolectric').projectDir = new File(rootDir, 'testutils_robolectric')
 project(modulePrefix + 'extension-ffmpeg').projectDir = new File(rootDir, 'extensions/ffmpeg')
 project(modulePrefix + 'extension-flac').projectDir = new File(rootDir, 'extensions/flac')
 project(modulePrefix + 'extension-gvr').projectDir = new File(rootDir, 'extensions/gvr')
 project(modulePrefix + 'extension-ima').projectDir = new File(rootDir, 'extensions/ima')
+project(modulePrefix + 'extension-cast').projectDir = new File(rootDir, 'extensions/cast')
 project(modulePrefix + 'extension-mediasession').projectDir = new File(rootDir, 'extensions/mediasession')
 project(modulePrefix + 'extension-okhttp').projectDir = new File(rootDir, 'extensions/okhttp')
 project(modulePrefix + 'extension-opus').projectDir = new File(rootDir, 'extensions/opus')
diff --git a/demos/cast/README.md b/demos/cast/README.md
new file mode 100644
index 0000000000..2c68a5277a
--- /dev/null
+++ b/demos/cast/README.md
@@ -0,0 +1,4 @@
+# Cast demo application #
+
+This folder contains a demo application that showcases ExoPlayer integration
+with Google Cast.
diff --git a/demos/cast/build.gradle b/demos/cast/build.gradle
new file mode 100644
index 0000000000..c928d0e46e
--- /dev/null
+++ b/demos/cast/build.gradle
@@ -0,0 +1,56 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        versionName project.ext.releaseVersion
+        versionCode project.ext.releaseVersionCode
+        minSdkVersion 16
+        targetSdkVersion project.ext.targetSdkVersion
+    }
+
+    buildTypes {
+        release {
+            shrinkResources true
+            minifyEnabled true
+            proguardFiles getDefaultProguardFile('proguard-android.txt')
+        }
+        debug {
+            jniDebuggable = true
+        }
+    }
+
+    lintOptions {
+        // The demo app does not have translations.
+        disable 'MissingTranslation'
+    }
+
+}
+
+dependencies {
+    implementation project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-dash')
+    implementation project(modulePrefix + 'library-hls')
+    implementation project(modulePrefix + 'library-smoothstreaming')
+    implementation project(modulePrefix + 'library-ui')
+    implementation project(modulePrefix + 'extension-cast')
+    implementation 'com.android.support:support-v4:' + supportLibraryVersion
+    implementation 'com.android.support:appcompat-v7:' + supportLibraryVersion
+    implementation 'com.android.support:recyclerview-v7:' + supportLibraryVersion
+}
diff --git a/demos/cast/src/main/AndroidManifest.xml b/demos/cast/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..ae16776333
--- /dev/null
+++ b/demos/cast/src/main/AndroidManifest.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.exoplayer2.castdemo">
+
+  <uses-permission android:name="android.permission.INTERNET"/>
+  <uses-sdk/>
+
+  <application android:label="@string/application_name" android:icon="@mipmap/ic_launcher"
+      android:largeHeap="true" android:allowBackup="false">
+
+    <meta-data android:name="com.google.android.gms.cast.framework.OPTIONS_PROVIDER_CLASS_NAME"
+        android:value="com.google.android.exoplayer2.ext.cast.DefaultCastOptionsProvider" />
+
+    <activity android:name="com.google.android.exoplayer2.castdemo.MainActivity"
+        android:configChanges="keyboard|keyboardHidden|orientation|screenSize|screenLayout|smallestScreenSize|uiMode"
+        android:launchMode="singleTop" android:label="@string/application_name"
+        android:theme="@style/Theme.AppCompat">
+      <intent-filter>
+        <action android:name="android.intent.action.MAIN"/>
+        <category android:name="android.intent.category.LAUNCHER"/>
+      </intent-filter>
+    </activity>
+
+  </application>
+
+</manifest>
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
new file mode 100644
index 0000000000..26ab5eb0dd
--- /dev/null
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/DemoUtil.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.castdemo;
+
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.gms.cast.MediaInfo;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Utility methods and constants for the Cast demo application.
+ */
+/* package */ final class DemoUtil {
+
+  public static final String MIME_TYPE_DASH = MimeTypes.APPLICATION_MPD;
+  public static final String MIME_TYPE_HLS = MimeTypes.APPLICATION_M3U8;
+  public static final String MIME_TYPE_SS = MimeTypes.APPLICATION_SS;
+  public static final String MIME_TYPE_VIDEO_MP4 = MimeTypes.VIDEO_MP4;
+
+  /**
+   * The list of samples available in the cast demo app.
+   */
+  public static final List<Sample> SAMPLES;
+
+  /**
+   * Represents a media sample.
+   */
+  public static final class Sample {
+
+    /**
+     * The uri from which the media sample is obtained.
+     */
+    public final String uri;
+    /**
+     * A descriptive name for the sample.
+     */
+    public final String name;
+    /**
+     * The mime type of the media sample, as required by {@link MediaInfo#setContentType}.
+     */
+    public final String mimeType;
+
+    /**
+     * @param uri See {@link #uri}.
+     * @param name See {@link #name}.
+     * @param mimeType See {@link #mimeType}.
+     */
+    public Sample(String uri, String name, String mimeType) {
+      this.uri = uri;
+      this.name = name;
+      this.mimeType = mimeType;
+    }
+
+    @Override
+    public String toString() {
+      return name;
+    }
+
+  }
+
+  static {
+    // App samples.
+    ArrayList<Sample> samples = new ArrayList<>();
+    samples.add(new Sample("https://storage.googleapis.com/wvmedia/clear/h264/tears/tears.mpd",
+        "DASH (clear,MP4,H264)", MIME_TYPE_DASH));
+    samples.add(new Sample("https://commondatastorage.googleapis.com/gtv-videos-bucket/CastVideos/"
+        + "hls/TearsOfSteel.m3u8", "Tears of Steel (HLS)", MIME_TYPE_HLS));
+    samples.add(new Sample("https://html5demos.com/assets/dizzy.mp4", "Dizzy (MP4)",
+        MIME_TYPE_VIDEO_MP4));
+
+
+    SAMPLES = Collections.unmodifiableList(samples);
+
+  }
+
+  private DemoUtil() {}
+
+}
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
new file mode 100644
index 0000000000..3e48ab2ab4
--- /dev/null
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/MainActivity.java
@@ -0,0 +1,261 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.castdemo;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.v4.graphics.ColorUtils;
+import android.support.v7.app.AlertDialog;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.ViewHolder;
+import android.support.v7.widget.helper.ItemTouchHelper;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+import android.widget.TextView;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.castdemo.DemoUtil.Sample;
+import com.google.android.exoplayer2.ext.cast.CastPlayer;
+import com.google.android.exoplayer2.ui.PlayerControlView;
+import com.google.android.exoplayer2.ui.PlayerView;
+import com.google.android.gms.cast.framework.CastButtonFactory;
+import com.google.android.gms.cast.framework.CastContext;
+
+/**
+ * An activity that plays video using {@link SimpleExoPlayer} and {@link CastPlayer}.
+ */
+public class MainActivity extends AppCompatActivity implements OnClickListener,
+    PlayerManager.QueuePositionListener {
+
+  private PlayerView localPlayerView;
+  private PlayerControlView castControlView;
+  private PlayerManager playerManager;
+  private RecyclerView mediaQueueList;
+  private MediaQueueListAdapter mediaQueueListAdapter;
+  private CastContext castContext;
+
+  // Activity lifecycle methods.
+
+  @Override
+  public void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+    // Getting the cast context later than onStart can cause device discovery not to take place.
+    castContext = CastContext.getSharedInstance(this);
+
+    setContentView(R.layout.main_activity);
+
+    localPlayerView = findViewById(R.id.local_player_view);
+    localPlayerView.requestFocus();
+
+    castControlView = findViewById(R.id.cast_control_view);
+
+    mediaQueueList = findViewById(R.id.sample_list);
+    ItemTouchHelper helper = new ItemTouchHelper(new RecyclerViewCallback());
+    helper.attachToRecyclerView(mediaQueueList);
+    mediaQueueList.setLayoutManager(new LinearLayoutManager(this));
+    mediaQueueList.setHasFixedSize(true);
+    mediaQueueListAdapter = new MediaQueueListAdapter();
+
+    findViewById(R.id.add_sample_button).setOnClickListener(this);
+  }
+
+  @Override
+  public boolean onCreateOptionsMenu(Menu menu) {
+    super.onCreateOptionsMenu(menu);
+    getMenuInflater().inflate(R.menu.menu, menu);
+    CastButtonFactory.setUpMediaRouteButton(this, menu, R.id.media_route_menu_item);
+    return true;
+  }
+
+  @Override
+  public void onResume() {
+    super.onResume();
+    playerManager =
+        PlayerManager.createPlayerManager(
+            /* queuePositionListener= */ this,
+            localPlayerView,
+            castControlView,
+            /* context= */ this,
+            castContext);
+    mediaQueueList.setAdapter(mediaQueueListAdapter);
+  }
+
+  @Override
+  public void onPause() {
+    super.onPause();
+    mediaQueueListAdapter.notifyItemRangeRemoved(0, mediaQueueListAdapter.getItemCount());
+    mediaQueueList.setAdapter(null);
+    playerManager.release();
+  }
+
+  // Activity input.
+
+  @Override
+  public boolean dispatchKeyEvent(KeyEvent event) {
+    // If the event was not handled then see if the player view can handle it.
+    return super.dispatchKeyEvent(event) || playerManager.dispatchKeyEvent(event);
+  }
+
+  @Override
+  public void onClick(View view) {
+    new AlertDialog.Builder(this).setTitle(R.string.sample_list_dialog_title)
+        .setView(buildSampleListView()).setPositiveButton(android.R.string.ok, null).create()
+        .show();
+  }
+
+  // PlayerManager.QueuePositionListener implementation.
+
+  @Override
+  public void onQueuePositionChanged(int previousIndex, int newIndex) {
+    if (previousIndex != C.INDEX_UNSET) {
+      mediaQueueListAdapter.notifyItemChanged(previousIndex);
+    }
+    if (newIndex != C.INDEX_UNSET) {
+      mediaQueueListAdapter.notifyItemChanged(newIndex);
+    }
+  }
+
+  // Internal methods.
+
+  private View buildSampleListView() {
+    View dialogList = getLayoutInflater().inflate(R.layout.sample_list, null);
+    ListView sampleList = dialogList.findViewById(R.id.sample_list);
+    sampleList.setAdapter(new SampleListAdapter(this));
+    sampleList.setOnItemClickListener(
+        new OnItemClickListener() {
+
+          @Override
+          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+            playerManager.addItem(DemoUtil.SAMPLES.get(position));
+            mediaQueueListAdapter.notifyItemInserted(playerManager.getMediaQueueSize() - 1);
+          }
+        });
+    return dialogList;
+  }
+
+  // Internal classes.
+
+  private class QueueItemViewHolder extends RecyclerView.ViewHolder implements OnClickListener {
+
+    public final TextView textView;
+
+    public QueueItemViewHolder(TextView textView) {
+      super(textView);
+      this.textView = textView;
+      textView.setOnClickListener(this);
+    }
+
+    @Override
+    public void onClick(View v) {
+      playerManager.selectQueueItem(getAdapterPosition());
+    }
+
+  }
+
+  private class MediaQueueListAdapter extends RecyclerView.Adapter<QueueItemViewHolder> {
+
+    @Override
+    public QueueItemViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+      TextView v = (TextView) LayoutInflater.from(parent.getContext())
+          .inflate(android.R.layout.simple_list_item_1, parent, false);
+      return new QueueItemViewHolder(v);
+    }
+
+    @Override
+    public void onBindViewHolder(QueueItemViewHolder holder, int position) {
+      TextView view = holder.textView;
+      view.setText(playerManager.getItem(position).name);
+      // TODO: Solve coloring using the theme's ColorStateList.
+      view.setTextColor(ColorUtils.setAlphaComponent(view.getCurrentTextColor(),
+           position == playerManager.getCurrentItemIndex() ? 255 : 100));
+    }
+
+    @Override
+    public int getItemCount() {
+      return playerManager.getMediaQueueSize();
+    }
+
+  }
+
+  private class RecyclerViewCallback extends ItemTouchHelper.SimpleCallback {
+
+    private int draggingFromPosition;
+    private int draggingToPosition;
+
+    public RecyclerViewCallback() {
+      super(ItemTouchHelper.UP | ItemTouchHelper.DOWN, ItemTouchHelper.START | ItemTouchHelper.END);
+      draggingFromPosition = C.INDEX_UNSET;
+      draggingToPosition = C.INDEX_UNSET;
+    }
+
+    @Override
+    public boolean onMove(RecyclerView list, RecyclerView.ViewHolder origin,
+        RecyclerView.ViewHolder target) {
+      int fromPosition = origin.getAdapterPosition();
+      int toPosition = target.getAdapterPosition();
+      if (draggingFromPosition == C.INDEX_UNSET) {
+        // A drag has started, but changes to the media queue will be reflected in clearView().
+        draggingFromPosition = fromPosition;
+      }
+      draggingToPosition = toPosition;
+      mediaQueueListAdapter.notifyItemMoved(fromPosition, toPosition);
+      return true;
+    }
+
+    @Override
+    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {
+      int position = viewHolder.getAdapterPosition();
+      if (playerManager.removeItem(position)) {
+        mediaQueueListAdapter.notifyItemRemoved(position);
+      }
+    }
+
+    @Override
+    public void clearView(RecyclerView recyclerView, ViewHolder viewHolder) {
+      super.clearView(recyclerView, viewHolder);
+      if (draggingFromPosition != C.INDEX_UNSET) {
+        // A drag has ended. We reflect the media queue change in the player.
+        if (!playerManager.moveItem(draggingFromPosition, draggingToPosition)) {
+          // The move failed. The entire sequence of onMove calls since the drag started needs to be
+          // invalidated.
+          mediaQueueListAdapter.notifyDataSetChanged();
+        }
+      }
+      draggingFromPosition = C.INDEX_UNSET;
+      draggingToPosition = C.INDEX_UNSET;
+    }
+
+  }
+
+  private static final class SampleListAdapter extends ArrayAdapter<Sample> {
+
+    public SampleListAdapter(Context context) {
+      super(context, android.R.layout.simple_list_item_1, DemoUtil.SAMPLES);
+    }
+
+  }
+
+}
diff --git a/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
new file mode 100644
index 0000000000..a14978a46a
--- /dev/null
+++ b/demos/cast/src/main/java/com/google/android/exoplayer2/castdemo/PlayerManager.java
@@ -0,0 +1,430 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.castdemo;
+
+import android.content.Context;
+import android.net.Uri;
+import android.view.KeyEvent;
+import android.view.View;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.DefaultRenderersFactory;
+import com.google.android.exoplayer2.ExoPlayerFactory;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Player.DefaultEventListener;
+import com.google.android.exoplayer2.Player.DiscontinuityReason;
+import com.google.android.exoplayer2.Player.TimelineChangeReason;
+import com.google.android.exoplayer2.RenderersFactory;
+import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Timeline.Period;
+import com.google.android.exoplayer2.castdemo.DemoUtil.Sample;
+import com.google.android.exoplayer2.ext.cast.CastPlayer;
+import com.google.android.exoplayer2.source.DynamicConcatenatingMediaSource;
+import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.dash.DashMediaSource;
+import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
+import com.google.android.exoplayer2.source.hls.HlsMediaSource;
+import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
+import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.ui.PlayerControlView;
+import com.google.android.exoplayer2.ui.PlayerView;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
+import com.google.android.gms.cast.MediaInfo;
+import com.google.android.gms.cast.MediaMetadata;
+import com.google.android.gms.cast.MediaQueueItem;
+import com.google.android.gms.cast.framework.CastContext;
+import java.util.ArrayList;
+
+/**
+ * Manages players and an internal media queue for the ExoPlayer/Cast demo app.
+ */
+/* package */ final class PlayerManager extends DefaultEventListener
+    implements CastPlayer.SessionAvailabilityListener {
+
+  /**
+   * Listener for changes in the media queue playback position.
+   */
+  public interface QueuePositionListener {
+
+    /**
+     * Called when the currently played item of the media queue changes.
+     */
+    void onQueuePositionChanged(int previousIndex, int newIndex);
+
+  }
+
+  private static final String USER_AGENT = "ExoCastDemoPlayer";
+  private static final DefaultBandwidthMeter BANDWIDTH_METER = new DefaultBandwidthMeter();
+  private static final DefaultHttpDataSourceFactory DATA_SOURCE_FACTORY =
+      new DefaultHttpDataSourceFactory(USER_AGENT, BANDWIDTH_METER);
+
+  private final PlayerView localPlayerView;
+  private final PlayerControlView castControlView;
+  private final SimpleExoPlayer exoPlayer;
+  private final CastPlayer castPlayer;
+  private final ArrayList<DemoUtil.Sample> mediaQueue;
+  private final QueuePositionListener queuePositionListener;
+
+  private DynamicConcatenatingMediaSource dynamicConcatenatingMediaSource;
+  private boolean castMediaQueueCreationPending;
+  private int currentItemIndex;
+  private Player currentPlayer;
+
+  /**
+   * @param queuePositionListener A {@link QueuePositionListener} for queue position changes.
+   * @param localPlayerView The {@link PlayerView} for local playback.
+   * @param castControlView The {@link PlayerControlView} to control remote playback.
+   * @param context A {@link Context}.
+   * @param castContext The {@link CastContext}.
+   */
+  public static PlayerManager createPlayerManager(
+      QueuePositionListener queuePositionListener,
+      PlayerView localPlayerView,
+      PlayerControlView castControlView,
+      Context context,
+      CastContext castContext) {
+    PlayerManager playerManager =
+        new PlayerManager(
+            queuePositionListener, localPlayerView, castControlView, context, castContext);
+    playerManager.init();
+    return playerManager;
+  }
+
+  private PlayerManager(
+      QueuePositionListener queuePositionListener,
+      PlayerView localPlayerView,
+      PlayerControlView castControlView,
+      Context context,
+      CastContext castContext) {
+    this.queuePositionListener = queuePositionListener;
+    this.localPlayerView = localPlayerView;
+    this.castControlView = castControlView;
+    mediaQueue = new ArrayList<>();
+    currentItemIndex = C.INDEX_UNSET;
+
+    DefaultTrackSelector trackSelector = new DefaultTrackSelector(BANDWIDTH_METER);
+    RenderersFactory renderersFactory = new DefaultRenderersFactory(context, null);
+    exoPlayer = ExoPlayerFactory.newSimpleInstance(renderersFactory, trackSelector);
+    exoPlayer.addListener(this);
+    localPlayerView.setPlayer(exoPlayer);
+
+    castPlayer = new CastPlayer(castContext);
+    castPlayer.addListener(this);
+    castPlayer.setSessionAvailabilityListener(this);
+    castControlView.setPlayer(castPlayer);
+  }
+
+  // Queue manipulation methods.
+
+  /**
+   * Plays a specified queue item in the current player.
+   *
+   * @param itemIndex The index of the item to play.
+   */
+  public void selectQueueItem(int itemIndex) {
+    setCurrentItem(itemIndex, C.TIME_UNSET, true);
+  }
+
+  /**
+   * Returns the index of the currently played item.
+   */
+  public int getCurrentItemIndex() {
+    return currentItemIndex;
+  }
+
+  /**
+   * Appends {@code sample} to the media queue.
+   *
+   * @param sample The {@link Sample} to append.
+   */
+  public void addItem(Sample sample) {
+    mediaQueue.add(sample);
+    if (currentPlayer == exoPlayer) {
+      dynamicConcatenatingMediaSource.addMediaSource(buildMediaSource(sample));
+    } else {
+      castPlayer.addItems(buildMediaQueueItem(sample));
+    }
+  }
+
+  /**
+   * Returns the size of the media queue.
+   */
+  public int getMediaQueueSize() {
+    return mediaQueue.size();
+  }
+
+  /**
+   * Returns the item at the given index in the media queue.
+   *
+   * @param position The index of the item.
+   * @return The item at the given index in the media queue.
+   */
+  public Sample getItem(int position) {
+    return mediaQueue.get(position);
+  }
+
+  /**
+   * Removes the item at the given index from the media queue.
+   *
+   * @param itemIndex The index of the item to remove.
+   * @return Whether the removal was successful.
+   */
+  public boolean removeItem(int itemIndex) {
+    if (currentPlayer == exoPlayer) {
+      dynamicConcatenatingMediaSource.removeMediaSource(itemIndex);
+    } else {
+      if (castPlayer.getPlaybackState() != Player.STATE_IDLE) {
+        Timeline castTimeline = castPlayer.getCurrentTimeline();
+        if (castTimeline.getPeriodCount() <= itemIndex) {
+          return false;
+        }
+        castPlayer.removeItem((int) castTimeline.getPeriod(itemIndex, new Period()).id);
+      }
+    }
+    mediaQueue.remove(itemIndex);
+    if (itemIndex == currentItemIndex && itemIndex == mediaQueue.size()) {
+      maybeSetCurrentItemAndNotify(C.INDEX_UNSET);
+    } else if (itemIndex < currentItemIndex) {
+      maybeSetCurrentItemAndNotify(currentItemIndex - 1);
+    }
+    return true;
+  }
+
+  /**
+   * Moves an item within the queue.
+   *
+   * @param fromIndex The index of the item to move.
+   * @param toIndex The target index of the item in the queue.
+   * @return Whether the item move was successful.
+   */
+  public boolean moveItem(int fromIndex, int toIndex) {
+    // Player update.
+    if (currentPlayer == exoPlayer) {
+      dynamicConcatenatingMediaSource.moveMediaSource(fromIndex, toIndex);
+    } else if (castPlayer.getPlaybackState() != Player.STATE_IDLE) {
+      Timeline castTimeline = castPlayer.getCurrentTimeline();
+      int periodCount = castTimeline.getPeriodCount();
+      if (periodCount <= fromIndex || periodCount <= toIndex) {
+        return false;
+      }
+      int elementId = (int) castTimeline.getPeriod(fromIndex, new Period()).id;
+      castPlayer.moveItem(elementId, toIndex);
+    }
+
+    mediaQueue.add(toIndex, mediaQueue.remove(fromIndex));
+
+    // Index update.
+    if (fromIndex == currentItemIndex) {
+      maybeSetCurrentItemAndNotify(toIndex);
+    } else if (fromIndex < currentItemIndex && toIndex >= currentItemIndex) {
+      maybeSetCurrentItemAndNotify(currentItemIndex - 1);
+    } else if (fromIndex > currentItemIndex && toIndex <= currentItemIndex) {
+      maybeSetCurrentItemAndNotify(currentItemIndex + 1);
+    }
+
+    return true;
+  }
+
+  // Miscellaneous methods.
+
+  /**
+   * Dispatches a given {@link KeyEvent} to the corresponding view of the current player.
+   *
+   * @param event The {@link KeyEvent}.
+   * @return Whether the event was handled by the target view.
+   */
+  public boolean dispatchKeyEvent(KeyEvent event) {
+    if (currentPlayer == exoPlayer) {
+      return localPlayerView.dispatchKeyEvent(event);
+    } else /* currentPlayer == castPlayer */ {
+      return castControlView.dispatchKeyEvent(event);
+    }
+  }
+
+  /**
+   * Releases the manager and the players that it holds.
+   */
+  public void release() {
+    currentItemIndex = C.INDEX_UNSET;
+    mediaQueue.clear();
+    castPlayer.setSessionAvailabilityListener(null);
+    castPlayer.release();
+    localPlayerView.setPlayer(null);
+    exoPlayer.release();
+  }
+
+  // Player.EventListener implementation.
+
+  @Override
+  public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+    updateCurrentItemIndex();
+  }
+
+  @Override
+  public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+    updateCurrentItemIndex();
+  }
+
+  @Override
+  public void onTimelineChanged(
+      Timeline timeline, Object manifest, @TimelineChangeReason int reason) {
+    updateCurrentItemIndex();
+    if (timeline.isEmpty()) {
+      castMediaQueueCreationPending = true;
+    }
+  }
+
+  // CastPlayer.SessionAvailabilityListener implementation.
+
+  @Override
+  public void onCastSessionAvailable() {
+    setCurrentPlayer(castPlayer);
+  }
+
+  @Override
+  public void onCastSessionUnavailable() {
+    setCurrentPlayer(exoPlayer);
+  }
+
+  // Internal methods.
+
+  private void init() {
+    setCurrentPlayer(castPlayer.isCastSessionAvailable() ? castPlayer : exoPlayer);
+  }
+
+  private void updateCurrentItemIndex() {
+    int playbackState = currentPlayer.getPlaybackState();
+    maybeSetCurrentItemAndNotify(
+        playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED
+        ? currentPlayer.getCurrentWindowIndex() : C.INDEX_UNSET);
+  }
+
+  private void setCurrentPlayer(Player currentPlayer) {
+    if (this.currentPlayer == currentPlayer) {
+      return;
+    }
+
+    // View management.
+    if (currentPlayer == exoPlayer) {
+      localPlayerView.setVisibility(View.VISIBLE);
+      castControlView.hide();
+    } else /* currentPlayer == castPlayer */ {
+      localPlayerView.setVisibility(View.GONE);
+      castControlView.show();
+    }
+
+    // Player state management.
+    long playbackPositionMs = C.TIME_UNSET;
+    int windowIndex = C.INDEX_UNSET;
+    boolean playWhenReady = false;
+    if (this.currentPlayer != null) {
+      int playbackState = this.currentPlayer.getPlaybackState();
+      if (playbackState != Player.STATE_ENDED) {
+        playbackPositionMs = this.currentPlayer.getCurrentPosition();
+        playWhenReady = this.currentPlayer.getPlayWhenReady();
+        windowIndex = this.currentPlayer.getCurrentWindowIndex();
+        if (windowIndex != currentItemIndex) {
+          playbackPositionMs = C.TIME_UNSET;
+          windowIndex = currentItemIndex;
+        }
+      }
+      this.currentPlayer.stop(true);
+    } else {
+      // This is the initial setup. No need to save any state.
+    }
+
+    this.currentPlayer = currentPlayer;
+
+    // Media queue management.
+    castMediaQueueCreationPending = currentPlayer == castPlayer;
+    if (currentPlayer == exoPlayer) {
+      dynamicConcatenatingMediaSource = new DynamicConcatenatingMediaSource();
+      for (int i = 0; i < mediaQueue.size(); i++) {
+        dynamicConcatenatingMediaSource.addMediaSource(buildMediaSource(mediaQueue.get(i)));
+      }
+      exoPlayer.prepare(dynamicConcatenatingMediaSource);
+    }
+
+    // Playback transition.
+    if (windowIndex != C.INDEX_UNSET) {
+      setCurrentItem(windowIndex, playbackPositionMs, playWhenReady);
+    }
+  }
+
+  /**
+   * Starts playback of the item at the given position.
+   *
+   * @param itemIndex The index of the item to play.
+   * @param positionMs The position at which playback should start.
+   * @param playWhenReady Whether the player should proceed when ready to do so.
+   */
+  private void setCurrentItem(int itemIndex, long positionMs, boolean playWhenReady) {
+    maybeSetCurrentItemAndNotify(itemIndex);
+    if (castMediaQueueCreationPending) {
+      MediaQueueItem[] items = new MediaQueueItem[mediaQueue.size()];
+      for (int i = 0; i < items.length; i++) {
+        items[i] = buildMediaQueueItem(mediaQueue.get(i));
+      }
+      castMediaQueueCreationPending = false;
+      castPlayer.loadItems(items, itemIndex, positionMs, Player.REPEAT_MODE_OFF);
+    } else {
+      currentPlayer.seekTo(itemIndex, positionMs);
+      currentPlayer.setPlayWhenReady(playWhenReady);
+    }
+  }
+
+  private void maybeSetCurrentItemAndNotify(int currentItemIndex) {
+    if (this.currentItemIndex != currentItemIndex) {
+      int oldIndex = this.currentItemIndex;
+      this.currentItemIndex = currentItemIndex;
+      queuePositionListener.onQueuePositionChanged(oldIndex, currentItemIndex);
+    }
+  }
+
+  private static MediaSource buildMediaSource(DemoUtil.Sample sample) {
+    Uri uri = Uri.parse(sample.uri);
+    switch (sample.mimeType) {
+      case DemoUtil.MIME_TYPE_SS:
+        return new SsMediaSource.Factory(
+                new DefaultSsChunkSource.Factory(DATA_SOURCE_FACTORY), DATA_SOURCE_FACTORY)
+            .createMediaSource(uri);
+      case DemoUtil.MIME_TYPE_DASH:
+        return new DashMediaSource.Factory(
+                new DefaultDashChunkSource.Factory(DATA_SOURCE_FACTORY), DATA_SOURCE_FACTORY)
+            .createMediaSource(uri);
+      case DemoUtil.MIME_TYPE_HLS:
+        return new HlsMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
+      case DemoUtil.MIME_TYPE_VIDEO_MP4:
+        return new ExtractorMediaSource.Factory(DATA_SOURCE_FACTORY).createMediaSource(uri);
+      default: {
+        throw new IllegalStateException("Unsupported type: " + sample.mimeType);
+      }
+    }
+  }
+
+  private static MediaQueueItem buildMediaQueueItem(DemoUtil.Sample sample) {
+    MediaMetadata movieMetadata = new MediaMetadata(MediaMetadata.MEDIA_TYPE_MOVIE);
+    movieMetadata.putString(MediaMetadata.KEY_TITLE, sample.name);
+    MediaInfo mediaInfo = new MediaInfo.Builder(sample.uri)
+        .setStreamType(MediaInfo.STREAM_TYPE_BUFFERED).setContentType(sample.mimeType)
+        .setMetadata(movieMetadata).build();
+    return new MediaQueueItem.Builder(mediaInfo).build();
+  }
+
+}
diff --git a/demos/cast/src/main/res/drawable/ic_add_circle_white_24dp.xml b/demos/cast/src/main/res/drawable/ic_add_circle_white_24dp.xml
new file mode 100644
index 0000000000..5f3c8961ef
--- /dev/null
+++ b/demos/cast/src/main/res/drawable/ic_add_circle_white_24dp.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector android:alpha="0.8" android:height="24dp" android:viewportHeight="24.0"
+    android:viewportWidth="24.0" android:width="24dp"
+    xmlns:android="http://schemas.android.com/apk/res/android">
+  <path android:fillColor="#FFFFFF" android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM17,13h-4v4h-2v-4L7,13v-2h4L11,7h2v4h4v2z"/>
+</vector>
diff --git a/demos/cast/src/main/res/layout/main_activity.xml b/demos/cast/src/main/res/layout/main_activity.xml
new file mode 100644
index 0000000000..01e48cdea7
--- /dev/null
+++ b/demos/cast/src/main/res/layout/main_activity.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:keepScreenOn="true">
+  <com.google.android.exoplayer2.ui.PlayerView android:id="@+id/local_player_view"
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="12"
+      app:repeat_toggle_modes="all|one"/>
+  <RelativeLayout android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="12">
+    <android.support.v7.widget.RecyclerView android:id="@+id/sample_list"
+        android:choiceMode="singleChoice"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:scrollbars="vertical"
+        android:fadeScrollbars="false"/>
+    <ImageButton android:id="@+id/add_sample_button"
+        android:background="@drawable/ic_add_circle_white_24dp"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_alignParentEnd="true"
+        android:layout_alignParentRight="true"
+        android:layout_alignParentBottom="true"
+        android:padding="30dp"/>
+  </RelativeLayout>
+  <com.google.android.exoplayer2.ui.PlayerControlView android:id="@+id/cast_control_view"
+      android:layout_width="match_parent"
+      android:layout_height="0dp"
+      android:layout_weight="2"
+      android:visibility="gone"
+      app:repeat_toggle_modes="all|one"
+      app:show_timeout="-1"/>
+</LinearLayout>
diff --git a/demos/cast/src/main/res/layout/sample_list.xml b/demos/cast/src/main/res/layout/sample_list.xml
new file mode 100644
index 0000000000..910db9e058
--- /dev/null
+++ b/demos/cast/src/main/res/layout/sample_list.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="match_parent">
+
+  <ListView android:id="@+id/sample_list"
+      android:layout_width="match_parent"
+      android:layout_height="250dp"
+      android:fadeScrollbars="false"/>
+
+</LinearLayout>
diff --git a/demos/cast/src/main/res/menu/menu.xml b/demos/cast/src/main/res/menu/menu.xml
new file mode 100644
index 0000000000..075ad34ec4
--- /dev/null
+++ b/demos/cast/src/main/res/menu/menu.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+      xmlns:app="http://schemas.android.com/apk/res-auto">
+
+  <item
+      android:id="@+id/media_route_menu_item"
+      android:title="@string/media_route_menu_title"
+      app:actionProviderClass="android.support.v7.app.MediaRouteActionProvider"
+      app:showAsAction="always" />
+
+</menu>
diff --git a/demos/cast/src/main/res/mipmap-hdpi/ic_launcher.png b/demos/cast/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000000..52e8dc93d9
Binary files /dev/null and b/demos/cast/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/demos/cast/src/main/res/mipmap-mdpi/ic_launcher.png b/demos/cast/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000000..b55576eff3
Binary files /dev/null and b/demos/cast/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/demos/cast/src/main/res/mipmap-xhdpi/ic_launcher.png b/demos/cast/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000000..ca84d6a60e
Binary files /dev/null and b/demos/cast/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/demos/cast/src/main/res/mipmap-xxhdpi/ic_launcher.png b/demos/cast/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..27ab9b1054
Binary files /dev/null and b/demos/cast/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/demos/cast/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/demos/cast/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000000..d1eb9b78cf
Binary files /dev/null and b/demos/cast/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/demos/cast/src/main/res/values/strings.xml b/demos/cast/src/main/res/values/strings.xml
new file mode 100644
index 0000000000..3505c40400
--- /dev/null
+++ b/demos/cast/src/main/res/values/strings.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources>
+
+  <string name="application_name">Exo Cast Demo</string>
+
+  <string name="media_route_menu_title">Cast</string>
+
+  <string name="sample_list_dialog_title">Add samples</string>
+
+</resources>
diff --git a/demos/ima/build.gradle b/demos/ima/build.gradle
index c32228de28..35c2daf88e 100644
--- a/demos/ima/build.gradle
+++ b/demos/ima/build.gradle
@@ -19,6 +19,8 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
+        versionName project.ext.releaseVersion
+        versionCode project.ext.releaseVersionCode
         minSdkVersion 16
         targetSdkVersion project.ext.targetSdkVersion
     }
@@ -41,7 +43,11 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile project(modulePrefix + 'library-ui')
-    compile project(modulePrefix + 'extension-ima')
+    implementation project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-ui')
+    implementation project(modulePrefix + 'library-dash')
+    implementation project(modulePrefix + 'library-hls')
+    implementation project(modulePrefix + 'library-smoothstreaming')
+    implementation project(modulePrefix + 'extension-ima')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
 }
diff --git a/demos/ima/src/main/AndroidManifest.xml b/demos/ima/src/main/AndroidManifest.xml
index 5252d2feeb..50ad0c1b54 100644
--- a/demos/ima/src/main/AndroidManifest.xml
+++ b/demos/ima/src/main/AndroidManifest.xml
@@ -14,12 +14,10 @@
      limitations under the License.
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.google.android.exoplayer2.imademo"
-    android:versionCode="2600"
-    android:versionName="2.6.0">
+    package="com.google.android.exoplayer2.imademo">
 
   <uses-permission android:name="android.permission.INTERNET"/>
-  <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="26"/>
+  <uses-sdk/>
 
   <application android:label="@string/application_name" android:icon="@mipmap/ic_launcher"
       android:largeHeap="true" android:allowBackup="false">
diff --git a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/MainActivity.java b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/MainActivity.java
index fb9cd05cd4..9988108f32 100644
--- a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/MainActivity.java
+++ b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/MainActivity.java
@@ -18,7 +18,7 @@
 import android.app.Activity;
 import android.os.Bundle;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ui.SimpleExoPlayerView;
+import com.google.android.exoplayer2.ui.PlayerView;
 
 /**
  * Main Activity for the IMA plugin demo. {@link ExoPlayer} objects are created by
@@ -26,7 +26,7 @@
  */
 public final class MainActivity extends Activity {
 
-  private SimpleExoPlayerView playerView;
+  private PlayerView playerView;
   private PlayerManager player;
 
   @Override
diff --git a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
index e11c840d12..e51c5e89b7 100644
--- a/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
+++ b/demos/ima/src/main/java/com/google/android/exoplayer2/imademo/PlayerManager.java
@@ -17,32 +17,40 @@
 
 import android.content.Context;
 import android.net.Uri;
+import android.os.Handler;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.C.ContentType;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.ext.ima.ImaAdsLoader;
-import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
-import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSourceEventListener;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
+import com.google.android.exoplayer2.source.dash.DashMediaSource;
+import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
+import com.google.android.exoplayer2.source.hls.HlsMediaSource;
+import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
+import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
 import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
-import com.google.android.exoplayer2.ui.SimpleExoPlayerView;
+import com.google.android.exoplayer2.ui.PlayerView;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import com.google.android.exoplayer2.util.Util;
 
-/**
- * Manages the {@link ExoPlayer}, the IMA plugin and all video playback.
- */
-/* package */ final class PlayerManager {
+/** Manages the {@link ExoPlayer}, the IMA plugin and all video playback. */
+/* package */ final class PlayerManager implements AdsMediaSource.MediaSourceFactory {
 
   private final ImaAdsLoader adsLoader;
+  private final DataSource.Factory manifestDataSourceFactory;
+  private final DataSource.Factory mediaDataSourceFactory;
 
   private SimpleExoPlayer player;
   private long contentPosition;
@@ -50,9 +58,17 @@
   public PlayerManager(Context context) {
     String adTag = context.getString(R.string.ad_tag_url);
     adsLoader = new ImaAdsLoader(context, Uri.parse(adTag));
+    manifestDataSourceFactory =
+        new DefaultDataSourceFactory(
+            context, Util.getUserAgent(context, context.getString(R.string.application_name)));
+    mediaDataSourceFactory =
+        new DefaultDataSourceFactory(
+            context,
+            Util.getUserAgent(context, context.getString(R.string.application_name)),
+            new DefaultBandwidthMeter());
   }
 
-  public void init(Context context, SimpleExoPlayerView simpleExoPlayerView) {
+  public void init(Context context, PlayerView playerView) {
     // Create a default track selector.
     BandwidthMeter bandwidthMeter = new DefaultBandwidthMeter();
     TrackSelection.Factory videoTrackSelectionFactory =
@@ -63,23 +79,22 @@ public void init(Context context, SimpleExoPlayerView simpleExoPlayerView) {
     player = ExoPlayerFactory.newSimpleInstance(context, trackSelector);
 
     // Bind the player to the view.
-    simpleExoPlayerView.setPlayer(player);
-
-    // Produces DataSource instances through which media data is loaded.
-    DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(context,
-        Util.getUserAgent(context, context.getString(R.string.application_name)));
-
-    // Produces Extractor instances for parsing the content media (i.e. not the ad).
-    ExtractorsFactory extractorsFactory = new DefaultExtractorsFactory();
+    playerView.setPlayer(player);
 
     // This is the MediaSource representing the content media (i.e. not the ad).
     String contentUrl = context.getString(R.string.content_url);
-    MediaSource contentMediaSource = new ExtractorMediaSource(
-        Uri.parse(contentUrl), dataSourceFactory, extractorsFactory, null, null);
+    MediaSource contentMediaSource =
+        buildMediaSource(Uri.parse(contentUrl), /* handler= */ null, /* listener= */ null);
 
     // Compose the content media source into a new AdsMediaSource with both ads and content.
-    MediaSource mediaSourceWithAds = new AdsMediaSource(contentMediaSource, dataSourceFactory,
-        adsLoader, simpleExoPlayerView.getOverlayFrameLayout());
+    MediaSource mediaSourceWithAds =
+        new AdsMediaSource(
+            contentMediaSource,
+            /* adMediaSourceFactory= */ this,
+            adsLoader,
+            playerView.getOverlayFrameLayout(),
+            /* eventHandler= */ null,
+            /* eventListener= */ null);
 
     // Prepare the player with the source.
     player.seekTo(contentPosition);
@@ -103,4 +118,44 @@ public void release() {
     adsLoader.release();
   }
 
+  // AdsMediaSource.MediaSourceFactory implementation.
+
+  @Override
+  public MediaSource createMediaSource(
+      Uri uri, @Nullable Handler handler, @Nullable MediaSourceEventListener listener) {
+    return buildMediaSource(uri, handler, listener);
+  }
+
+  @Override
+  public int[] getSupportedTypes() {
+    // IMA does not support Smooth Streaming ads.
+    return new int[] {C.TYPE_DASH, C.TYPE_HLS, C.TYPE_OTHER};
+  }
+
+  // Internal methods.
+
+  private MediaSource buildMediaSource(
+      Uri uri, @Nullable Handler handler, @Nullable MediaSourceEventListener listener) {
+    @ContentType int type = Util.inferContentType(uri);
+    switch (type) {
+      case C.TYPE_DASH:
+        return new DashMediaSource.Factory(
+                new DefaultDashChunkSource.Factory(mediaDataSourceFactory),
+                manifestDataSourceFactory)
+            .createMediaSource(uri, handler, listener);
+      case C.TYPE_SS:
+        return new SsMediaSource.Factory(
+                new DefaultSsChunkSource.Factory(mediaDataSourceFactory), manifestDataSourceFactory)
+            .createMediaSource(uri, handler, listener);
+      case C.TYPE_HLS:
+        return new HlsMediaSource.Factory(mediaDataSourceFactory)
+            .createMediaSource(uri, handler, listener);
+      case C.TYPE_OTHER:
+        return new ExtractorMediaSource.Factory(mediaDataSourceFactory)
+            .createMediaSource(uri, handler, listener);
+      default:
+        throw new IllegalStateException("Unsupported type: " + type);
+    }
+  }
+
 }
diff --git a/demos/ima/src/main/res/layout/main_activity.xml b/demos/ima/src/main/res/layout/main_activity.xml
index ad5da62f47..f7ea5c9b88 100644
--- a/demos/ima/src/main/res/layout/main_activity.xml
+++ b/demos/ima/src/main/res/layout/main_activity.xml
@@ -13,7 +13,7 @@
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
-<com.google.android.exoplayer2.ui.SimpleExoPlayerView
+<com.google.android.exoplayer2.ui.PlayerView
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/player_view"
     android:layout_width="match_parent"
diff --git a/demos/main/build.gradle b/demos/main/build.gradle
index adad8f0e58..ce0992eb7a 100644
--- a/demos/main/build.gradle
+++ b/demos/main/build.gradle
@@ -19,6 +19,8 @@ android {
     buildToolsVersion project.ext.buildToolsVersion
 
     defaultConfig {
+        versionName project.ext.releaseVersion
+        versionCode project.ext.releaseVersionCode
         minSdkVersion 16
         targetSdkVersion project.ext.targetSdkVersion
     }
@@ -27,7 +29,10 @@ android {
         release {
             shrinkResources true
             minifyEnabled true
-            proguardFiles getDefaultProguardFile('proguard-android.txt')
+            proguardFiles = [
+                "proguard-rules.txt",
+                getDefaultProguardFile('proguard-android.txt')
+            ]
         }
         debug {
             jniDebuggable = true
@@ -52,15 +57,16 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile project(modulePrefix + 'library-dash')
-    compile project(modulePrefix + 'library-hls')
-    compile project(modulePrefix + 'library-smoothstreaming')
-    compile project(modulePrefix + 'library-ui')
-    withExtensionsCompile project(path: modulePrefix + 'extension-ffmpeg')
-    withExtensionsCompile project(path: modulePrefix + 'extension-flac')
-    withExtensionsCompile project(path: modulePrefix + 'extension-ima')
-    withExtensionsCompile project(path: modulePrefix + 'extension-opus')
-    withExtensionsCompile project(path: modulePrefix + 'extension-vp9')
-    withExtensionsCompile project(path: modulePrefix + 'extension-rtmp')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-dash')
+    implementation project(modulePrefix + 'library-hls')
+    implementation project(modulePrefix + 'library-smoothstreaming')
+    implementation project(modulePrefix + 'library-ui')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-ffmpeg')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-flac')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-ima')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-opus')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-vp9')
+    withExtensionsImplementation project(path: modulePrefix + 'extension-rtmp')
 }
diff --git a/demos/main/proguard-rules.txt b/demos/main/proguard-rules.txt
new file mode 100644
index 0000000000..cd201892ab
--- /dev/null
+++ b/demos/main/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Proguard rules specific to the main demo app.
+
+# Constructor accessed via reflection in PlayerActivity
+-dontnote com.google.android.exoplayer2.ext.ima.ImaAdsLoader
+-keepclassmembers class com.google.android.exoplayer2.ext.ima.ImaAdsLoader {
+  <init>(android.content.Context, android.net.Uri);
+}
diff --git a/demos/main/src/main/AndroidManifest.xml b/demos/main/src/main/AndroidManifest.xml
index d041e24d80..cde95300ab 100644
--- a/demos/main/src/main/AndroidManifest.xml
+++ b/demos/main/src/main/AndroidManifest.xml
@@ -15,15 +15,13 @@
 -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.google.android.exoplayer2.demo"
-    android:versionCode="2600"
-    android:versionName="2.6.0">
+    package="com.google.android.exoplayer2.demo">
 
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
   <uses-feature android:name="android.software.leanback" android:required="false"/>
   <uses-feature android:name="android.hardware.touchscreen" android:required="false"/>
-  <uses-sdk android:minSdkVersion="16" android:targetSdkVersion="26"/>
+  <uses-sdk/>
 
   <application
       android:label="@string/application_name"
diff --git a/demos/main/src/main/assets/media.exolist.json b/demos/main/src/main/assets/media.exolist.json
index 38a0c577ae..7052e7c436 100644
--- a/demos/main/src/main/assets/media.exolist.json
+++ b/demos/main/src/main/assets/media.exolist.json
@@ -540,7 +540,7 @@
       {
         "name": "VMAP pre-, mid- and post-rolls, single ads",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
-        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/single_ad_samples&ciu_szs=300x250&impl=s&gdfp_req=1&env=vp&output=vast&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ct%3Dlinear&correlator="
+        "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpremidpost&cmsid=496&vid=short_onecue&correlator="
       },
       {
         "name": "VMAP pre-roll single ad, mid-roll standard pod with 3 ads, post-roll single ad",
@@ -566,6 +566,16 @@
         "name": "VMAP pre-roll single ad, mid-roll standard pods with 5 ads every 10 seconds for 1:40, post-roll single ad",
         "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
         "ad_tag_uri": "https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/124319096/external/ad_rule_samples&ciu_szs=300x250&ad_rule=1&impl=s&gdfp_req=1&env=vp&output=vmap&unviewed_position_start=1&cust_params=deployment%3Ddevsite%26sample_ar%3Dpremidpostlongpod&cmsid=496&vid=short_tencue&correlator="
+      },
+      {
+        "name": "VMAP empty midroll",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "http://vastsynthesizer.appspot.com/empty-midroll"
+      },
+      {
+        "name": "VMAP full, empty, full midrolls",
+        "uri": "https://storage.googleapis.com/exoplayer-test-media-1/mkv/android-screens-lavf-56.36.100-aac-avc-main-1280x720.mkv",
+        "ad_tag_uri": "http://vastsynthesizer.appspot.com/empty-midroll-2"
       }
     ]
   }
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
index b5db4c018d..5d019e4c53 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoApplication.java
@@ -17,10 +17,10 @@
 
 import android.app.Application;
 import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 import com.google.android.exoplayer2.upstream.DefaultHttpDataSourceFactory;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.upstream.TransferListener;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -36,13 +36,15 @@ public void onCreate() {
     userAgent = Util.getUserAgent(this, "ExoPlayerDemo");
   }
 
-  public DataSource.Factory buildDataSourceFactory(DefaultBandwidthMeter bandwidthMeter) {
-    return new DefaultDataSourceFactory(this, bandwidthMeter,
-        buildHttpDataSourceFactory(bandwidthMeter));
+  /** Returns a {@link DataSource.Factory}. */
+  public DataSource.Factory buildDataSourceFactory(TransferListener<? super DataSource> listener) {
+    return new DefaultDataSourceFactory(this, listener, buildHttpDataSourceFactory(listener));
   }
 
-  public HttpDataSource.Factory buildHttpDataSourceFactory(DefaultBandwidthMeter bandwidthMeter) {
-    return new DefaultHttpDataSourceFactory(userAgent, bandwidthMeter);
+  /** Returns a {@link HttpDataSource.Factory}. */
+  public HttpDataSource.Factory buildHttpDataSourceFactory(
+      TransferListener<? super DataSource> listener) {
+    return new DefaultHttpDataSourceFactory(userAgent, listener);
   }
 
   public boolean useExtensionRenderers() {
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoUtil.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoUtil.java
index f9e9c34158..2692bc4531 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoUtil.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/DemoUtil.java
@@ -23,7 +23,7 @@
 /**
  * Utility methods for demo application.
  */
-/*package*/ final class DemoUtil {
+/* package */ final class DemoUtil {
 
   /**
    * Builds a track name for display.
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
index 08c5bddb09..e91feaa291 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java
@@ -16,13 +16,13 @@
 package com.google.android.exoplayer2.demo;
 
 import android.app.Activity;
-import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.Handler;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.view.KeyEvent;
 import android.view.View;
@@ -38,6 +38,7 @@
 import com.google.android.exoplayer2.DefaultRenderersFactory;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayerFactory;
+import com.google.android.exoplayer2.PlaybackPreparer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
@@ -46,13 +47,13 @@
 import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
 import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
 import com.google.android.exoplayer2.drm.UnsupportedDrmException;
-import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer.DecoderInitializationException;
 import com.google.android.exoplayer2.mediacodec.MediaCodecUtil.DecoderQueryException;
 import com.google.android.exoplayer2.source.BehindLiveWindowException;
 import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSourceEventListener;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.ads.AdsLoader;
 import com.google.android.exoplayer2.source.ads.AdsMediaSource;
@@ -67,24 +68,24 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.ui.DebugTextViewHelper;
-import com.google.android.exoplayer2.ui.PlaybackControlView;
-import com.google.android.exoplayer2.ui.SimpleExoPlayerView;
+import com.google.android.exoplayer2.ui.PlayerControlView;
+import com.google.android.exoplayer2.ui.PlayerView;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.util.EventLogger;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.reflect.Constructor;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.CookiePolicy;
 import java.util.UUID;
 
-/**
- * An activity that plays media using {@link SimpleExoPlayer}.
- */
-public class PlayerActivity extends Activity implements OnClickListener,
-    PlaybackControlView.VisibilityListener {
+/** An activity that plays media using {@link SimpleExoPlayer}. */
+public class PlayerActivity extends Activity
+    implements OnClickListener, PlaybackPreparer, PlayerControlView.VisibilityListener {
 
-  public static final String DRM_SCHEME_UUID_EXTRA = "drm_scheme_uuid";
+  public static final String DRM_SCHEME_EXTRA = "drm_scheme";
   public static final String DRM_LICENSE_URL = "drm_license_url";
   public static final String DRM_KEY_REQUEST_PROPERTIES = "drm_key_request_properties";
   public static final String DRM_MULTI_SESSION = "drm_multi_session";
@@ -99,6 +100,9 @@
   public static final String EXTENSION_LIST_EXTRA = "extension_list";
   public static final String AD_TAG_URI_EXTRA = "ad_tag_uri";
 
+  // For backwards compatibility.
+  private static final String DRM_SCHEME_UUID_EXTRA = "drm_scheme_uuid";
+
   private static final DefaultBandwidthMeter BANDWIDTH_METER = new DefaultBandwidthMeter();
   private static final CookieManager DEFAULT_COOKIE_MANAGER;
   static {
@@ -108,10 +112,9 @@
 
   private Handler mainHandler;
   private EventLogger eventLogger;
-  private SimpleExoPlayerView simpleExoPlayerView;
+  private PlayerView playerView;
   private LinearLayout debugRootView;
   private TextView debugTextView;
-  private Button retryButton;
 
   private DataSource.Factory mediaDataSourceFactory;
   private SimpleExoPlayer player;
@@ -149,12 +152,10 @@ public void onCreate(Bundle savedInstanceState) {
     rootView.setOnClickListener(this);
     debugRootView = findViewById(R.id.controls_root);
     debugTextView = findViewById(R.id.debug_text_view);
-    retryButton = findViewById(R.id.retry_button);
-    retryButton.setOnClickListener(this);
 
-    simpleExoPlayerView = findViewById(R.id.player_view);
-    simpleExoPlayerView.setControllerVisibilityListener(this);
-    simpleExoPlayerView.requestFocus();
+    playerView = findViewById(R.id.player_view);
+    playerView.setControllerVisibilityListener(this);
+    playerView.requestFocus();
   }
 
   @Override
@@ -219,24 +220,29 @@ public void onRequestPermissionsResult(int requestCode, @NonNull String[] permis
   @Override
   public boolean dispatchKeyEvent(KeyEvent event) {
     // See whether the player view wants to handle media or DPAD keys events.
-    return simpleExoPlayerView.dispatchKeyEvent(event) || super.dispatchKeyEvent(event);
+    return playerView.dispatchKeyEvent(event) || super.dispatchKeyEvent(event);
   }
 
   // OnClickListener methods
 
   @Override
   public void onClick(View view) {
-    if (view == retryButton) {
-      initializePlayer();
-    } else if (view.getParent() == debugRootView) {
+    if (view.getParent() == debugRootView) {
       MappedTrackInfo mappedTrackInfo = trackSelector.getCurrentMappedTrackInfo();
       if (mappedTrackInfo != null) {
-        trackSelectionHelper.showSelectionDialog(this, ((Button) view).getText(),
-            trackSelector.getCurrentMappedTrackInfo(), (int) view.getTag());
+        trackSelectionHelper.showSelectionDialog(
+            this, ((Button) view).getText(), mappedTrackInfo, (int) view.getTag());
       }
     }
   }
 
+  // PlaybackControlView.PlaybackPreparer implementation
+
+  @Override
+  public void preparePlayback() {
+    initializePlayer();
+  }
+
   // PlaybackControlView.VisibilityListener implementation
 
   @Override
@@ -257,10 +263,8 @@ private void initializePlayer() {
       lastSeenTrackGroupArray = null;
       eventLogger = new EventLogger(trackSelector);
 
-      UUID drmSchemeUuid = intent.hasExtra(DRM_SCHEME_UUID_EXTRA)
-          ? UUID.fromString(intent.getStringExtra(DRM_SCHEME_UUID_EXTRA)) : null;
       DrmSessionManager<FrameworkMediaCrypto> drmSessionManager = null;
-      if (drmSchemeUuid != null) {
+      if (intent.hasExtra(DRM_SCHEME_EXTRA) || intent.hasExtra(DRM_SCHEME_UUID_EXTRA)) {
         String drmLicenseUrl = intent.getStringExtra(DRM_LICENSE_URL);
         String[] keyRequestPropertiesArray = intent.getStringArrayExtra(DRM_KEY_REQUEST_PROPERTIES);
         boolean multiSession = intent.getBooleanExtra(DRM_MULTI_SESSION, false);
@@ -269,8 +273,16 @@ private void initializePlayer() {
           errorStringId = R.string.error_drm_not_supported;
         } else {
           try {
-            drmSessionManager = buildDrmSessionManagerV18(drmSchemeUuid, drmLicenseUrl,
-                keyRequestPropertiesArray, multiSession);
+            String drmSchemeExtra = intent.hasExtra(DRM_SCHEME_EXTRA) ? DRM_SCHEME_EXTRA
+                : DRM_SCHEME_UUID_EXTRA;
+            UUID drmSchemeUuid = Util.getDrmUuid(intent.getStringExtra(drmSchemeExtra));
+            if (drmSchemeUuid == null) {
+              errorStringId = R.string.error_drm_unsupported_scheme;
+            } else {
+              drmSessionManager =
+                  buildDrmSessionManagerV18(
+                      drmSchemeUuid, drmLicenseUrl, keyRequestPropertiesArray, multiSession);
+            }
           } catch (UnsupportedDrmException e) {
             errorStringId = e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
                 ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown;
@@ -295,11 +307,12 @@ private void initializePlayer() {
       player.addListener(new PlayerEventListener());
       player.addListener(eventLogger);
       player.addMetadataOutput(eventLogger);
-      player.setAudioDebugListener(eventLogger);
-      player.setVideoDebugListener(eventLogger);
-
-      simpleExoPlayerView.setPlayer(player);
+      player.addAudioDebugListener(eventLogger);
+      player.addVideoDebugListener(eventLogger);
       player.setPlayWhenReady(shouldAutoPlay);
+
+      playerView.setPlayer(player);
+      playerView.setPlaybackPreparer(this);
       debugViewHelper = new DebugTextViewHelper(player, debugTextView);
       debugViewHelper.start();
     }
@@ -329,7 +342,7 @@ private void initializePlayer() {
     }
     MediaSource[] mediaSources = new MediaSource[uris.length];
     for (int i = 0; i < uris.length; i++) {
-      mediaSources[i] = buildMediaSource(uris[i], extensions[i]);
+      mediaSources[i] = buildMediaSource(uris[i], extensions[i], mainHandler, eventLogger);
     }
     MediaSource mediaSource = mediaSources.length == 1 ? mediaSources[0]
         : new ConcatenatingMediaSource(mediaSources);
@@ -340,9 +353,10 @@ private void initializePlayer() {
         releaseAdsLoader();
         loadedAdTagUri = adTagUri;
       }
-      try {
-        mediaSource = createAdsMediaSource(mediaSource, Uri.parse(adTagUriString));
-      } catch (Exception e) {
+      MediaSource adsMediaSource = createAdsMediaSource(mediaSource, Uri.parse(adTagUriString));
+      if (adsMediaSource != null) {
+        mediaSource = adsMediaSource;
+      } else {
         showToast(R.string.ima_not_loaded);
       }
     } else {
@@ -357,21 +371,30 @@ private void initializePlayer() {
     updateButtonVisibilities();
   }
 
-  private MediaSource buildMediaSource(Uri uri, String overrideExtension) {
+  private MediaSource buildMediaSource(
+      Uri uri,
+      String overrideExtension,
+      @Nullable Handler handler,
+      @Nullable MediaSourceEventListener listener) {
     @ContentType int type = TextUtils.isEmpty(overrideExtension) ? Util.inferContentType(uri)
         : Util.inferContentType("." + overrideExtension);
     switch (type) {
-      case C.TYPE_SS:
-        return new SsMediaSource(uri, buildDataSourceFactory(false),
-            new DefaultSsChunkSource.Factory(mediaDataSourceFactory), mainHandler, eventLogger);
       case C.TYPE_DASH:
-        return new DashMediaSource(uri, buildDataSourceFactory(false),
-            new DefaultDashChunkSource.Factory(mediaDataSourceFactory), mainHandler, eventLogger);
+        return new DashMediaSource.Factory(
+                new DefaultDashChunkSource.Factory(mediaDataSourceFactory),
+                buildDataSourceFactory(false))
+            .createMediaSource(uri, handler, listener);
+      case C.TYPE_SS:
+        return new SsMediaSource.Factory(
+                new DefaultSsChunkSource.Factory(mediaDataSourceFactory),
+                buildDataSourceFactory(false))
+            .createMediaSource(uri, handler, listener);
       case C.TYPE_HLS:
-        return new HlsMediaSource(uri, mediaDataSourceFactory, mainHandler, eventLogger);
+        return new HlsMediaSource.Factory(mediaDataSourceFactory)
+            .createMediaSource(uri, handler, listener);
       case C.TYPE_OTHER:
-        return new ExtractorMediaSource(uri, mediaDataSourceFactory, new DefaultExtractorsFactory(),
-            mainHandler, eventLogger);
+        return new ExtractorMediaSource.Factory(mediaDataSourceFactory)
+            .createMediaSource(uri, handler, listener);
       default: {
         throw new IllegalStateException("Unsupported type: " + type);
       }
@@ -441,24 +464,47 @@ private void clearResumePosition() {
         .buildHttpDataSourceFactory(useBandwidthMeter ? BANDWIDTH_METER : null);
   }
 
-  /**
-   * Returns an ads media source, reusing the ads loader if one exists.
-   *
-   * @throws Exception Thrown if it was not possible to create an ads media source, for example, due
-   *     to a missing dependency.
-   */
-  private MediaSource createAdsMediaSource(MediaSource mediaSource, Uri adTagUri) throws Exception {
+  /** Returns an ads media source, reusing the ads loader if one exists. */
+  private @Nullable MediaSource createAdsMediaSource(MediaSource mediaSource, Uri adTagUri) {
     // Load the extension source using reflection so the demo app doesn't have to depend on it.
     // The ads loader is reused for multiple playbacks, so that ad playback can resume.
-    Class<?> loaderClass = Class.forName("com.google.android.exoplayer2.ext.ima.ImaAdsLoader");
-    if (adsLoader == null) {
-      adsLoader = (AdsLoader) loaderClass.getConstructor(Context.class, Uri.class)
-          .newInstance(this, adTagUri);
-      adUiViewGroup = new FrameLayout(this);
-      // The demo app has a non-null overlay frame layout.
-      simpleExoPlayerView.getOverlayFrameLayout().addView(adUiViewGroup);
+    try {
+      Class<?> loaderClass = Class.forName("com.google.android.exoplayer2.ext.ima.ImaAdsLoader");
+      if (adsLoader == null) {
+        // Full class names used so the LINT.IfChange rule triggers should any of the classes move.
+        // LINT.IfChange
+        Constructor<? extends AdsLoader> loaderConstructor =
+            loaderClass
+                .asSubclass(AdsLoader.class)
+                .getConstructor(android.content.Context.class, android.net.Uri.class);
+        // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
+        adsLoader = loaderConstructor.newInstance(this, adTagUri);
+        adUiViewGroup = new FrameLayout(this);
+        // The demo app has a non-null overlay frame layout.
+        playerView.getOverlayFrameLayout().addView(adUiViewGroup);
+      }
+      AdsMediaSource.MediaSourceFactory adMediaSourceFactory =
+          new AdsMediaSource.MediaSourceFactory() {
+            @Override
+            public MediaSource createMediaSource(
+                Uri uri, @Nullable Handler handler, @Nullable MediaSourceEventListener listener) {
+              return PlayerActivity.this.buildMediaSource(
+                  uri, /* overrideExtension= */ null, handler, listener);
+            }
+
+            @Override
+            public int[] getSupportedTypes() {
+              return new int[] {C.TYPE_DASH, C.TYPE_SS, C.TYPE_HLS, C.TYPE_OTHER};
+            }
+          };
+      return new AdsMediaSource(
+          mediaSource, adMediaSourceFactory, adsLoader, adUiViewGroup, mainHandler, eventLogger);
+    } catch (ClassNotFoundException e) {
+      // IMA extension not loaded.
+      return null;
+    } catch (Exception e) {
+      throw new RuntimeException(e);
     }
-    return new AdsMediaSource(mediaSource, mediaDataSourceFactory, adsLoader, adUiViewGroup);
   }
 
   private void releaseAdsLoader() {
@@ -466,7 +512,7 @@ private void releaseAdsLoader() {
       adsLoader.release();
       adsLoader = null;
       loadedAdTagUri = null;
-      simpleExoPlayerView.getOverlayFrameLayout().removeAllViews();
+      playerView.getOverlayFrameLayout().removeAllViews();
     }
   }
 
@@ -474,10 +520,6 @@ private void releaseAdsLoader() {
 
   private void updateButtonVisibilities() {
     debugRootView.removeAllViews();
-
-    retryButton.setVisibility(inErrorState ? View.VISIBLE : View.GONE);
-    debugRootView.addView(retryButton);
-
     if (player == null) {
       return;
     }
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
index 1f84b1f29c..3895ad8e84 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
+++ b/demos/main/src/main/java/com/google/android/exoplayer2/demo/SampleChooserActivity.java
@@ -32,7 +32,6 @@
 import android.widget.ExpandableListView.OnChildClickListener;
 import android.widget.TextView;
 import android.widget.Toast;
-import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSourceInputStream;
@@ -202,7 +201,9 @@ private Sample readEntry(JsonReader reader, boolean insidePlaylist) throws IOExc
             break;
           case "drm_scheme":
             Assertions.checkState(!insidePlaylist, "Invalid attribute on nested item: drm_scheme");
-            drmUuid = getDrmUuid(reader.nextString());
+            String drmScheme = reader.nextString();
+            drmUuid = Util.getDrmUuid(drmScheme);
+            Assertions.checkState(drmUuid != null, "Invalid drm_scheme: " + drmScheme);
             break;
           case "drm_license_url":
             Assertions.checkState(!insidePlaylist,
@@ -270,23 +271,6 @@ private SampleGroup getGroup(String groupName, List<SampleGroup> groups) {
       return group;
     }
 
-    private UUID getDrmUuid(String typeString) throws ParserException {
-      switch (Util.toLowerInvariant(typeString)) {
-        case "widevine":
-          return C.WIDEVINE_UUID;
-        case "playready":
-          return C.PLAYREADY_UUID;
-        case "clearkey":
-          return C.CLEARKEY_UUID;
-        default:
-          try {
-            return UUID.fromString(typeString);
-          } catch (RuntimeException e) {
-            throw new ParserException("Unsupported drm type: " + typeString);
-          }
-      }
-    }
-
   }
 
   private static final class SampleAdapter extends BaseExpandableListAdapter {
@@ -393,7 +377,7 @@ public DrmInfo(UUID drmSchemeUuid, String drmLicenseUrl,
 
     public void updateIntent(Intent intent) {
       Assertions.checkNotNull(intent);
-      intent.putExtra(PlayerActivity.DRM_SCHEME_UUID_EXTRA, drmSchemeUuid.toString());
+      intent.putExtra(PlayerActivity.DRM_SCHEME_EXTRA, drmSchemeUuid.toString());
       intent.putExtra(PlayerActivity.DRM_LICENSE_URL, drmLicenseUrl);
       intent.putExtra(PlayerActivity.DRM_KEY_REQUEST_PROPERTIES, drmKeyRequestProperties);
       intent.putExtra(PlayerActivity.DRM_MULTI_SESSION, drmMultiSession);
diff --git a/demos/main/src/main/proguard-rules.txt b/demos/main/src/main/proguard-rules.txt
new file mode 100644
index 0000000000..cd201892ab
--- /dev/null
+++ b/demos/main/src/main/proguard-rules.txt
@@ -0,0 +1,7 @@
+# Proguard rules specific to the main demo app.
+
+# Constructor accessed via reflection in PlayerActivity
+-dontnote com.google.android.exoplayer2.ext.ima.ImaAdsLoader
+-keepclassmembers class com.google.android.exoplayer2.ext.ima.ImaAdsLoader {
+  <init>(android.content.Context, android.net.Uri);
+}
diff --git a/demos/main/src/main/res/layout/player_activity.xml b/demos/main/src/main/res/layout/player_activity.xml
index 3f8cdaa7d6..6b84033273 100644
--- a/demos/main/src/main/res/layout/player_activity.xml
+++ b/demos/main/src/main/res/layout/player_activity.xml
@@ -20,7 +20,7 @@
     android:layout_height="match_parent"
     android:keepScreenOn="true">
 
-  <com.google.android.exoplayer2.ui.SimpleExoPlayerView android:id="@+id/player_view"
+  <com.google.android.exoplayer2.ui.PlayerView android:id="@+id/player_view"
       android:layout_width="match_parent"
       android:layout_height="match_parent"/>
 
@@ -42,15 +42,7 @@
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
         android:orientation="horizontal"
-        android:visibility="gone">
-
-      <Button android:id="@+id/retry_button"
-          android:layout_width="wrap_content"
-          android:layout_height="wrap_content"
-          android:text="@string/retry"
-          android:visibility="gone"/>
-
-    </LinearLayout>
+        android:visibility="gone"/>
 
   </LinearLayout>
 
diff --git a/demos/main/src/main/res/values/strings.xml b/demos/main/src/main/res/values/strings.xml
index b38ccf6e88..43b17052fb 100644
--- a/demos/main/src/main/res/values/strings.xml
+++ b/demos/main/src/main/res/values/strings.xml
@@ -23,8 +23,6 @@
 
   <string name="text">Text</string>
 
-  <string name="retry">Retry</string>
-
   <string name="selection_disabled">Disabled</string>
 
   <string name="selection_default">Default</string>
diff --git a/extensions/cast/README.md b/extensions/cast/README.md
new file mode 100644
index 0000000000..cc72c5f9bc
--- /dev/null
+++ b/extensions/cast/README.md
@@ -0,0 +1,30 @@
+# ExoPlayer Cast extension #
+
+## Description ##
+
+The cast extension is a [Player][] implementation that controls playback on a
+Cast receiver app.
+
+[Player]: https://google.github.io/ExoPlayer/doc/reference/index.html?com/google/android/exoplayer2/Player.html
+
+## Getting the extension ##
+
+The easiest way to use the extension is to add it as a gradle dependency:
+
+```gradle
+implementation 'com.google.android.exoplayer:extension-cast:2.X.X'
+```
+
+where `2.X.X` is the version, which must match the version of the ExoPlayer
+library being used.
+
+Alternatively, you can clone the ExoPlayer repository and depend on the module
+locally. Instructions for doing this can be found in ExoPlayer's
+[top level README][].
+
+[top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
+
+## Using the extension ##
+
+Create a `CastPlayer` and use it to integrate Cast into your app using
+ExoPlayer's common `Player` interface.
diff --git a/extensions/cast/build.gradle b/extensions/cast/build.gradle
new file mode 100644
index 0000000000..253a1922a8
--- /dev/null
+++ b/extensions/cast/build.gradle
@@ -0,0 +1,58 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../../constants.gradle'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion 14
+        targetSdkVersion project.ext.targetSdkVersion
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    }
+}
+
+dependencies {
+    // These dependencies are necessary to force the supportLibraryVersion of
+    // com.android.support:support-v4, com.android.support:appcompat-v7 and
+    // com.android.support:mediarouter-v7 to be used. Else older versions are
+    // used, for example:
+    // com.google.android.gms:play-services-cast-framework:11.4.2
+    // |-- com.google.android.gms:play-services-basement:11.4.2
+    //   |-- com.android.support:support-v4:25.2.0
+    api 'com.android.support:support-v4:' + supportLibraryVersion
+    api 'com.android.support:appcompat-v7:' + supportLibraryVersion
+    api 'com.android.support:mediarouter-v7:' + supportLibraryVersion
+    api 'com.google.android.gms:play-services-cast-framework:' + playServicesLibraryVersion
+    implementation project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-ui')
+    testImplementation project(modulePrefix + 'testutils')
+    testImplementation 'junit:junit:' + junitVersion
+    testImplementation 'org.mockito:mockito-core:' + mockitoVersion
+    testImplementation 'org.robolectric:robolectric:' + robolectricVersion
+    testImplementation project(modulePrefix + 'testutils-robolectric')
+}
+
+ext {
+    javadocTitle = 'Cast extension'
+}
+apply from: '../../javadoc_library.gradle'
+
+ext {
+    releaseArtifact = 'extension-cast'
+    releaseDescription = 'Cast extension for ExoPlayer.'
+}
+apply from: '../../publish.gradle'
diff --git a/extensions/cast/src/main/AndroidManifest.xml b/extensions/cast/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..c12fc1289f
--- /dev/null
+++ b/extensions/cast/src/main/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<manifest package="com.google.android.exoplayer2.ext.cast"/>
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
new file mode 100644
index 0000000000..50c883c3f6
--- /dev/null
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastPlayer.java
@@ -0,0 +1,882 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.FixedTrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
+import com.google.android.gms.cast.CastStatusCodes;
+import com.google.android.gms.cast.MediaInfo;
+import com.google.android.gms.cast.MediaQueueItem;
+import com.google.android.gms.cast.MediaStatus;
+import com.google.android.gms.cast.MediaTrack;
+import com.google.android.gms.cast.framework.CastContext;
+import com.google.android.gms.cast.framework.CastSession;
+import com.google.android.gms.cast.framework.SessionManager;
+import com.google.android.gms.cast.framework.SessionManagerListener;
+import com.google.android.gms.cast.framework.media.RemoteMediaClient;
+import com.google.android.gms.cast.framework.media.RemoteMediaClient.MediaChannelResult;
+import com.google.android.gms.common.api.PendingResult;
+import com.google.android.gms.common.api.ResultCallback;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+/**
+ * {@link Player} implementation that communicates with a Cast receiver app.
+ *
+ * <p>The behavior of this class depends on the underlying Cast session, which is obtained from the
+ * Cast context passed to {@link #CastPlayer}. To keep track of the session,
+ * {@link #isCastSessionAvailable()} can be queried and {@link SessionAvailabilityListener} can be
+ * implemented and attached to the player.</p>
+ *
+ * <p> If no session is available, the player state will remain unchanged and calls to methods that
+ * alter it will be ignored. Querying the player state is possible even when no session is
+ * available, in which case, the last observed receiver app state is reported.</p>
+ *
+ * <p>Methods should be called on the application's main thread.</p>
+ */
+public final class CastPlayer implements Player {
+
+  /**
+   * Listener of changes in the cast session availability.
+   */
+  public interface SessionAvailabilityListener {
+
+    /**
+     * Called when a cast session becomes available to the player.
+     */
+    void onCastSessionAvailable();
+
+    /**
+     * Called when the cast session becomes unavailable.
+     */
+    void onCastSessionUnavailable();
+
+  }
+
+  private static final String TAG = "CastPlayer";
+
+  private static final int RENDERER_COUNT = 3;
+  private static final int RENDERER_INDEX_VIDEO = 0;
+  private static final int RENDERER_INDEX_AUDIO = 1;
+  private static final int RENDERER_INDEX_TEXT = 2;
+  private static final long PROGRESS_REPORT_PERIOD_MS = 1000;
+  private static final TrackSelectionArray EMPTY_TRACK_SELECTION_ARRAY =
+      new TrackSelectionArray(null, null, null);
+  private static final long[] EMPTY_TRACK_ID_ARRAY = new long[0];
+
+  private final CastContext castContext;
+  // TODO: Allow custom implementations of CastTimelineTracker.
+  private final CastTimelineTracker timelineTracker;
+  private final Timeline.Window window;
+  private final Timeline.Period period;
+
+  private RemoteMediaClient remoteMediaClient;
+
+  // Result callbacks.
+  private final StatusListener statusListener;
+  private final SeekResultCallback seekResultCallback;
+
+  // Listeners.
+  private final CopyOnWriteArraySet<EventListener> listeners;
+  private SessionAvailabilityListener sessionAvailabilityListener;
+
+  // Internal state.
+  private CastTimeline currentTimeline;
+  private TrackGroupArray currentTrackGroups;
+  private TrackSelectionArray currentTrackSelection;
+  private int playbackState;
+  private int repeatMode;
+  private int currentWindowIndex;
+  private boolean playWhenReady;
+  private long lastReportedPositionMs;
+  private int pendingSeekCount;
+  private int pendingSeekWindowIndex;
+  private long pendingSeekPositionMs;
+  private boolean waitingForInitialTimeline;
+
+  /**
+   * @param castContext The context from which the cast session is obtained.
+   */
+  public CastPlayer(CastContext castContext) {
+    this.castContext = castContext;
+    timelineTracker = new CastTimelineTracker();
+    window = new Timeline.Window();
+    period = new Timeline.Period();
+    statusListener = new StatusListener();
+    seekResultCallback = new SeekResultCallback();
+    listeners = new CopyOnWriteArraySet<>();
+
+    SessionManager sessionManager = castContext.getSessionManager();
+    sessionManager.addSessionManagerListener(statusListener, CastSession.class);
+    CastSession session = sessionManager.getCurrentCastSession();
+    remoteMediaClient = session != null ? session.getRemoteMediaClient() : null;
+
+    playbackState = STATE_IDLE;
+    repeatMode = REPEAT_MODE_OFF;
+    currentTimeline = CastTimeline.EMPTY_CAST_TIMELINE;
+    currentTrackGroups = TrackGroupArray.EMPTY;
+    currentTrackSelection = EMPTY_TRACK_SELECTION_ARRAY;
+    pendingSeekWindowIndex = C.INDEX_UNSET;
+    pendingSeekPositionMs = C.TIME_UNSET;
+    updateInternalState();
+  }
+
+  // Media Queue manipulation methods.
+
+  /**
+   * Loads a single item media queue. If no session is available, does nothing.
+   *
+   * @param item The item to load.
+   * @param positionMs The position at which the playback should start in milliseconds relative to
+   *     the start of the item at {@code startIndex}. If {@link C#TIME_UNSET} is passed, playback
+   *     starts at position 0.
+   * @return The Cast {@code PendingResult}, or null if no session is available.
+   */
+  public PendingResult<MediaChannelResult> loadItem(MediaQueueItem item, long positionMs) {
+    return loadItems(new MediaQueueItem[] {item}, 0, positionMs, REPEAT_MODE_OFF);
+  }
+
+  /**
+   * Loads a media queue. If no session is available, does nothing.
+   *
+   * @param items The items to load.
+   * @param startIndex The index of the item at which playback should start.
+   * @param positionMs The position at which the playback should start in milliseconds relative to
+   *     the start of the item at {@code startIndex}. If {@link C#TIME_UNSET} is passed, playback
+   *     starts at position 0.
+   * @param repeatMode The repeat mode for the created media queue.
+   * @return The Cast {@code PendingResult}, or null if no session is available.
+   */
+  public PendingResult<MediaChannelResult> loadItems(MediaQueueItem[] items, int startIndex,
+      long positionMs, @RepeatMode int repeatMode) {
+    if (remoteMediaClient != null) {
+      positionMs = positionMs != C.TIME_UNSET ? positionMs : 0;
+      waitingForInitialTimeline = true;
+      return remoteMediaClient.queueLoad(items, startIndex, getCastRepeatMode(repeatMode),
+          positionMs, null);
+    }
+    return null;
+  }
+
+  /**
+   * Appends a sequence of items to the media queue. If no media queue exists, does nothing.
+   *
+   * @param items The items to append.
+   * @return The Cast {@code PendingResult}, or null if no media queue exists.
+   */
+  public PendingResult<MediaChannelResult> addItems(MediaQueueItem... items) {
+    return addItems(MediaQueueItem.INVALID_ITEM_ID, items);
+  }
+
+  /**
+   * Inserts a sequence of items into the media queue. If no media queue or period with id {@code
+   * periodId} exist, does nothing.
+   *
+   * @param periodId The id of the period ({@link #getCurrentTimeline}) that corresponds to the item
+   *     that will follow immediately after the inserted items.
+   * @param items The items to insert.
+   * @return The Cast {@code PendingResult}, or null if no media queue or no period with id {@code
+   *     periodId} exist.
+   */
+  public PendingResult<MediaChannelResult> addItems(int periodId, MediaQueueItem... items) {
+    if (getMediaStatus() != null && (periodId == MediaQueueItem.INVALID_ITEM_ID
+        || currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET)) {
+      return remoteMediaClient.queueInsertItems(items, periodId, null);
+    }
+    return null;
+  }
+
+  /**
+   * Removes an item from the media queue. If no media queue or period with id {@code periodId}
+   * exist, does nothing.
+   *
+   * @param periodId The id of the period ({@link #getCurrentTimeline}) that corresponds to the item
+   *     to remove.
+   * @return The Cast {@code PendingResult}, or null if no media queue or no period with id {@code
+   *     periodId} exist.
+   */
+  public PendingResult<MediaChannelResult> removeItem(int periodId) {
+    if (getMediaStatus() != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET) {
+      return remoteMediaClient.queueRemoveItem(periodId, null);
+    }
+    return null;
+  }
+
+  /**
+   * Moves an existing item within the media queue. If no media queue or period with id {@code
+   * periodId} exist, does nothing.
+   *
+   * @param periodId The id of the period ({@link #getCurrentTimeline}) that corresponds to the item
+   *     to move.
+   * @param newIndex The target index of the item in the media queue. Must be in the range 0 &lt;=
+   *     index &lt; {@link Timeline#getPeriodCount()}, as provided by {@link #getCurrentTimeline()}.
+   * @return The Cast {@code PendingResult}, or null if no media queue or no period with id {@code
+   *     periodId} exist.
+   */
+  public PendingResult<MediaChannelResult> moveItem(int periodId, int newIndex) {
+    Assertions.checkArgument(newIndex >= 0 && newIndex < currentTimeline.getPeriodCount());
+    if (getMediaStatus() != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET) {
+      return remoteMediaClient.queueMoveItemToNewIndex(periodId, newIndex, null);
+    }
+    return null;
+  }
+
+  /**
+   * Returns the item that corresponds to the period with the given id, or null if no media queue or
+   * period with id {@code periodId} exist.
+   *
+   * @param periodId The id of the period ({@link #getCurrentTimeline}) that corresponds to the item
+   *     to get.
+   * @return The item that corresponds to the period with the given id, or null if no media queue or
+   *     period with id {@code periodId} exist.
+   */
+  public MediaQueueItem getItem(int periodId) {
+    MediaStatus mediaStatus = getMediaStatus();
+    return mediaStatus != null && currentTimeline.getIndexOfPeriod(periodId) != C.INDEX_UNSET
+        ? mediaStatus.getItemById(periodId) : null;
+  }
+
+  // CastSession methods.
+
+  /**
+   * Returns whether a cast session is available.
+   */
+  public boolean isCastSessionAvailable() {
+    return remoteMediaClient != null;
+  }
+
+  /**
+   * Sets a listener for updates on the cast session availability.
+   *
+   * @param listener The {@link SessionAvailabilityListener}.
+   */
+  public void setSessionAvailabilityListener(SessionAvailabilityListener listener) {
+    sessionAvailabilityListener = listener;
+  }
+
+  // Player implementation.
+
+  @Override
+  public VideoComponent getVideoComponent() {
+    return null;
+  }
+
+  @Override
+  public TextComponent getTextComponent() {
+    return null;
+  }
+
+  @Override
+  public void addListener(EventListener listener) {
+    listeners.add(listener);
+  }
+
+  @Override
+  public void removeListener(EventListener listener) {
+    listeners.remove(listener);
+  }
+
+  @Override
+  public int getPlaybackState() {
+    return playbackState;
+  }
+
+  @Override
+  public void setPlayWhenReady(boolean playWhenReady) {
+    if (remoteMediaClient == null) {
+      return;
+    }
+    if (playWhenReady) {
+      remoteMediaClient.play();
+    } else {
+      remoteMediaClient.pause();
+    }
+  }
+
+  @Override
+  public boolean getPlayWhenReady() {
+    return playWhenReady;
+  }
+
+  @Override
+  public void seekToDefaultPosition() {
+    seekTo(0);
+  }
+
+  @Override
+  public void seekToDefaultPosition(int windowIndex) {
+    seekTo(windowIndex, 0);
+  }
+
+  @Override
+  public void seekTo(long positionMs) {
+    seekTo(getCurrentWindowIndex(), positionMs);
+  }
+
+  @Override
+  public void seekTo(int windowIndex, long positionMs) {
+    MediaStatus mediaStatus = getMediaStatus();
+    // We assume the default position is 0. There is no support for seeking to the default position
+    // in RemoteMediaClient.
+    positionMs = positionMs != C.TIME_UNSET ? positionMs : 0;
+    if (mediaStatus != null) {
+      if (getCurrentWindowIndex() != windowIndex) {
+        remoteMediaClient.queueJumpToItem((int) currentTimeline.getPeriod(windowIndex, period).uid,
+            positionMs, null).setResultCallback(seekResultCallback);
+      } else {
+        remoteMediaClient.seek(positionMs).setResultCallback(seekResultCallback);
+      }
+      pendingSeekCount++;
+      pendingSeekWindowIndex = windowIndex;
+      pendingSeekPositionMs = positionMs;
+      for (EventListener listener : listeners) {
+        listener.onPositionDiscontinuity(Player.DISCONTINUITY_REASON_SEEK);
+      }
+    } else if (pendingSeekCount == 0) {
+      for (EventListener listener : listeners) {
+        listener.onSeekProcessed();
+      }
+    }
+  }
+
+  @Override
+  public void setPlaybackParameters(@Nullable PlaybackParameters playbackParameters) {
+    // Unsupported by the RemoteMediaClient API. Do nothing.
+  }
+
+  @Override
+  public PlaybackParameters getPlaybackParameters() {
+    return PlaybackParameters.DEFAULT;
+  }
+
+  @Override
+  public void stop() {
+    stop(/* reset= */ false);
+  }
+
+  @Override
+  public void stop(boolean reset) {
+    playbackState = STATE_IDLE;
+    if (remoteMediaClient != null) {
+      // TODO(b/69792021): Support or emulate stop without position reset.
+      remoteMediaClient.stop();
+    }
+  }
+
+  @Override
+  public void release() {
+    SessionManager sessionManager = castContext.getSessionManager();
+    sessionManager.removeSessionManagerListener(statusListener, CastSession.class);
+    sessionManager.endCurrentSession(false);
+  }
+
+  @Override
+  public int getRendererCount() {
+    // We assume there are three renderers: video, audio, and text.
+    return RENDERER_COUNT;
+  }
+
+  @Override
+  public int getRendererType(int index) {
+    switch (index) {
+      case RENDERER_INDEX_VIDEO:
+        return C.TRACK_TYPE_VIDEO;
+      case RENDERER_INDEX_AUDIO:
+        return C.TRACK_TYPE_AUDIO;
+      case RENDERER_INDEX_TEXT:
+        return C.TRACK_TYPE_TEXT;
+      default:
+        throw new IndexOutOfBoundsException();
+    }
+  }
+
+  @Override
+  public void setRepeatMode(@RepeatMode int repeatMode) {
+    if (remoteMediaClient != null) {
+      remoteMediaClient.queueSetRepeatMode(getCastRepeatMode(repeatMode), null);
+    }
+  }
+
+  @Override
+  @RepeatMode public int getRepeatMode() {
+    return repeatMode;
+  }
+
+  @Override
+  public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
+    // TODO: Support shuffle mode.
+  }
+
+  @Override
+  public boolean getShuffleModeEnabled() {
+    // TODO: Support shuffle mode.
+    return false;
+  }
+
+  @Override
+  public TrackSelectionArray getCurrentTrackSelections() {
+    return currentTrackSelection;
+  }
+
+  @Override
+  public TrackGroupArray getCurrentTrackGroups() {
+    return currentTrackGroups;
+  }
+
+  @Override
+  public Timeline getCurrentTimeline() {
+    return currentTimeline;
+  }
+
+  @Override
+  @Nullable public Object getCurrentManifest() {
+    return null;
+  }
+
+  @Override
+  public int getCurrentPeriodIndex() {
+    return getCurrentWindowIndex();
+  }
+
+  @Override
+  public int getCurrentWindowIndex() {
+    return pendingSeekWindowIndex != C.INDEX_UNSET ? pendingSeekWindowIndex : currentWindowIndex;
+  }
+
+  @Override
+  public int getNextWindowIndex() {
+    return currentTimeline.isEmpty() ? C.INDEX_UNSET
+        : currentTimeline.getNextWindowIndex(getCurrentWindowIndex(), repeatMode, false);
+  }
+
+  @Override
+  public int getPreviousWindowIndex() {
+    return currentTimeline.isEmpty() ? C.INDEX_UNSET
+        : currentTimeline.getPreviousWindowIndex(getCurrentWindowIndex(), repeatMode, false);
+  }
+
+  // TODO: Fill the cast timeline information with ProgressListener's duration updates.
+  // See [Internal: b/65152553].
+  @Override
+  public long getDuration() {
+    return currentTimeline.isEmpty() ? C.TIME_UNSET
+        : currentTimeline.getWindow(getCurrentWindowIndex(), window).getDurationMs();
+  }
+
+  @Override
+  public long getCurrentPosition() {
+    return pendingSeekPositionMs != C.TIME_UNSET
+        ? pendingSeekPositionMs
+        : remoteMediaClient != null
+            ? remoteMediaClient.getApproximateStreamPosition()
+            : lastReportedPositionMs;
+  }
+
+  @Override
+  public long getBufferedPosition() {
+    return getCurrentPosition();
+  }
+
+  @Override
+  public int getBufferedPercentage() {
+    long position = getBufferedPosition();
+    long duration = getDuration();
+    return position == C.TIME_UNSET || duration == C.TIME_UNSET
+        ? 0
+        : duration == 0 ? 100 : Util.constrainValue((int) ((position * 100) / duration), 0, 100);
+  }
+
+  @Override
+  public boolean isCurrentWindowDynamic() {
+    return !currentTimeline.isEmpty()
+        && currentTimeline.getWindow(getCurrentWindowIndex(), window).isDynamic;
+  }
+
+  @Override
+  public boolean isCurrentWindowSeekable() {
+    return !currentTimeline.isEmpty()
+        && currentTimeline.getWindow(getCurrentWindowIndex(), window).isSeekable;
+  }
+
+  @Override
+  public boolean isPlayingAd() {
+    return false;
+  }
+
+  @Override
+  public int getCurrentAdGroupIndex() {
+    return C.INDEX_UNSET;
+  }
+
+  @Override
+  public int getCurrentAdIndexInAdGroup() {
+    return C.INDEX_UNSET;
+  }
+
+  @Override
+  public boolean isLoading() {
+    return false;
+  }
+
+  @Override
+  public long getContentPosition() {
+    return getCurrentPosition();
+  }
+
+  // Internal methods.
+
+  public void updateInternalState() {
+    if (remoteMediaClient == null) {
+      // There is no session. We leave the state of the player as it is now.
+      return;
+    }
+
+    int playbackState = fetchPlaybackState(remoteMediaClient);
+    boolean playWhenReady = !remoteMediaClient.isPaused();
+    if (this.playbackState != playbackState
+        || this.playWhenReady != playWhenReady) {
+      this.playbackState = playbackState;
+      this.playWhenReady = playWhenReady;
+      for (EventListener listener : listeners) {
+        listener.onPlayerStateChanged(this.playWhenReady, this.playbackState);
+      }
+    }
+    @RepeatMode int repeatMode = fetchRepeatMode(remoteMediaClient);
+    if (this.repeatMode != repeatMode) {
+      this.repeatMode = repeatMode;
+      for (EventListener listener : listeners) {
+        listener.onRepeatModeChanged(repeatMode);
+      }
+    }
+    int currentWindowIndex = fetchCurrentWindowIndex(getMediaStatus());
+    if (this.currentWindowIndex != currentWindowIndex && pendingSeekCount == 0) {
+      this.currentWindowIndex = currentWindowIndex;
+      for (EventListener listener : listeners) {
+        listener.onPositionDiscontinuity(DISCONTINUITY_REASON_PERIOD_TRANSITION);
+      }
+    }
+    if (updateTracksAndSelections()) {
+      for (EventListener listener : listeners) {
+        listener.onTracksChanged(currentTrackGroups, currentTrackSelection);
+      }
+    }
+    maybeUpdateTimelineAndNotify();
+  }
+
+  private void maybeUpdateTimelineAndNotify() {
+    if (updateTimeline()) {
+      @Player.TimelineChangeReason int reason = waitingForInitialTimeline
+          ? Player.TIMELINE_CHANGE_REASON_PREPARED : Player.TIMELINE_CHANGE_REASON_DYNAMIC;
+      waitingForInitialTimeline = false;
+      for (EventListener listener : listeners) {
+        listener.onTimelineChanged(currentTimeline, null, reason);
+      }
+    }
+  }
+
+  /**
+   * Updates the current timeline and returns whether it has changed.
+   */
+  private boolean updateTimeline() {
+    CastTimeline oldTimeline = currentTimeline;
+    MediaStatus status = getMediaStatus();
+    currentTimeline =
+        status != null ? timelineTracker.getCastTimeline(status) : CastTimeline.EMPTY_CAST_TIMELINE;
+    return !oldTimeline.equals(currentTimeline);
+  }
+
+  /**
+   * Updates the internal tracks and selection and returns whether they have changed.
+   */
+  private boolean updateTracksAndSelections() {
+    if (remoteMediaClient == null) {
+      // There is no session. We leave the state of the player as it is now.
+      return false;
+    }
+
+    MediaStatus mediaStatus = getMediaStatus();
+    MediaInfo mediaInfo = mediaStatus != null ? mediaStatus.getMediaInfo() : null;
+    List<MediaTrack> castMediaTracks = mediaInfo != null ? mediaInfo.getMediaTracks() : null;
+    if (castMediaTracks == null || castMediaTracks.isEmpty()) {
+      boolean hasChanged = !currentTrackGroups.isEmpty();
+      currentTrackGroups = TrackGroupArray.EMPTY;
+      currentTrackSelection = EMPTY_TRACK_SELECTION_ARRAY;
+      return hasChanged;
+    }
+    long[] activeTrackIds = mediaStatus.getActiveTrackIds();
+    if (activeTrackIds == null) {
+      activeTrackIds = EMPTY_TRACK_ID_ARRAY;
+    }
+
+    TrackGroup[] trackGroups = new TrackGroup[castMediaTracks.size()];
+    TrackSelection[] trackSelections = new TrackSelection[RENDERER_COUNT];
+    for (int i = 0; i < castMediaTracks.size(); i++) {
+      MediaTrack mediaTrack = castMediaTracks.get(i);
+      trackGroups[i] = new TrackGroup(CastUtils.mediaTrackToFormat(mediaTrack));
+
+      long id = mediaTrack.getId();
+      int trackType = MimeTypes.getTrackType(mediaTrack.getContentType());
+      int rendererIndex = getRendererIndexForTrackType(trackType);
+      if (isTrackActive(id, activeTrackIds) && rendererIndex != C.INDEX_UNSET
+          && trackSelections[rendererIndex] == null) {
+        trackSelections[rendererIndex] = new FixedTrackSelection(trackGroups[i], 0);
+      }
+    }
+    TrackGroupArray newTrackGroups = new TrackGroupArray(trackGroups);
+    TrackSelectionArray newTrackSelections = new TrackSelectionArray(trackSelections);
+
+    if (!newTrackGroups.equals(currentTrackGroups)
+        || !newTrackSelections.equals(currentTrackSelection)) {
+      currentTrackSelection = new TrackSelectionArray(trackSelections);
+      currentTrackGroups = new TrackGroupArray(trackGroups);
+      return true;
+    }
+    return false;
+  }
+
+  private void setRemoteMediaClient(@Nullable RemoteMediaClient remoteMediaClient) {
+    if (this.remoteMediaClient == remoteMediaClient) {
+      // Do nothing.
+      return;
+    }
+    if (this.remoteMediaClient != null) {
+      this.remoteMediaClient.removeListener(statusListener);
+      this.remoteMediaClient.removeProgressListener(statusListener);
+    }
+    this.remoteMediaClient = remoteMediaClient;
+    if (remoteMediaClient != null) {
+      if (sessionAvailabilityListener != null) {
+        sessionAvailabilityListener.onCastSessionAvailable();
+      }
+      remoteMediaClient.addListener(statusListener);
+      remoteMediaClient.addProgressListener(statusListener, PROGRESS_REPORT_PERIOD_MS);
+      updateInternalState();
+    } else {
+      if (sessionAvailabilityListener != null) {
+        sessionAvailabilityListener.onCastSessionUnavailable();
+      }
+    }
+  }
+
+  private @Nullable MediaStatus getMediaStatus() {
+    return remoteMediaClient != null ? remoteMediaClient.getMediaStatus() : null;
+  }
+
+  /**
+   * Retrieves the playback state from {@code remoteMediaClient} and maps it into a {@link Player}
+   * state
+   */
+  private static int fetchPlaybackState(RemoteMediaClient remoteMediaClient) {
+    int receiverAppStatus = remoteMediaClient.getPlayerState();
+    switch (receiverAppStatus) {
+      case MediaStatus.PLAYER_STATE_BUFFERING:
+        return STATE_BUFFERING;
+      case MediaStatus.PLAYER_STATE_PLAYING:
+      case MediaStatus.PLAYER_STATE_PAUSED:
+        return STATE_READY;
+      case MediaStatus.PLAYER_STATE_IDLE:
+      case MediaStatus.PLAYER_STATE_UNKNOWN:
+      default:
+        return STATE_IDLE;
+    }
+  }
+
+  /**
+   * Retrieves the repeat mode from {@code remoteMediaClient} and maps it into a
+   * {@link Player.RepeatMode}.
+   */
+  @RepeatMode
+  private static int fetchRepeatMode(RemoteMediaClient remoteMediaClient) {
+    MediaStatus mediaStatus = remoteMediaClient.getMediaStatus();
+    if (mediaStatus == null) {
+      // No media session active, yet.
+      return REPEAT_MODE_OFF;
+    }
+    int castRepeatMode = mediaStatus.getQueueRepeatMode();
+    switch (castRepeatMode) {
+      case MediaStatus.REPEAT_MODE_REPEAT_SINGLE:
+        return REPEAT_MODE_ONE;
+      case MediaStatus.REPEAT_MODE_REPEAT_ALL:
+      case MediaStatus.REPEAT_MODE_REPEAT_ALL_AND_SHUFFLE:
+        return REPEAT_MODE_ALL;
+      case MediaStatus.REPEAT_MODE_REPEAT_OFF:
+        return REPEAT_MODE_OFF;
+      default:
+        throw new IllegalStateException();
+    }
+  }
+
+  /**
+   * Retrieves the current item index from {@code mediaStatus} and maps it into a window index. If
+   * there is no media session, returns 0.
+   */
+  private static int fetchCurrentWindowIndex(@Nullable MediaStatus mediaStatus) {
+    Integer currentItemId = mediaStatus != null
+        ? mediaStatus.getIndexById(mediaStatus.getCurrentItemId()) : null;
+    return currentItemId != null ? currentItemId : 0;
+  }
+
+  private static boolean isTrackActive(long id, long[] activeTrackIds) {
+    for (long activeTrackId : activeTrackIds) {
+      if (activeTrackId == id) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private static int getRendererIndexForTrackType(int trackType) {
+    return trackType == C.TRACK_TYPE_VIDEO
+        ? RENDERER_INDEX_VIDEO
+        : trackType == C.TRACK_TYPE_AUDIO
+            ? RENDERER_INDEX_AUDIO
+            : trackType == C.TRACK_TYPE_TEXT ? RENDERER_INDEX_TEXT : C.INDEX_UNSET;
+  }
+
+  private static int getCastRepeatMode(@RepeatMode int repeatMode) {
+    switch (repeatMode) {
+      case REPEAT_MODE_ONE:
+        return MediaStatus.REPEAT_MODE_REPEAT_SINGLE;
+      case REPEAT_MODE_ALL:
+        return MediaStatus.REPEAT_MODE_REPEAT_ALL;
+      case REPEAT_MODE_OFF:
+        return MediaStatus.REPEAT_MODE_REPEAT_OFF;
+      default:
+        throw new IllegalArgumentException();
+    }
+  }
+
+  private final class StatusListener implements RemoteMediaClient.Listener,
+      SessionManagerListener<CastSession>, RemoteMediaClient.ProgressListener {
+
+    // RemoteMediaClient.ProgressListener implementation.
+
+    @Override
+    public void onProgressUpdated(long progressMs, long unusedDurationMs) {
+      lastReportedPositionMs = progressMs;
+    }
+
+    // RemoteMediaClient.Listener implementation.
+
+    @Override
+    public void onStatusUpdated() {
+      updateInternalState();
+    }
+
+    @Override
+    public void onMetadataUpdated() {}
+
+    @Override
+    public void onQueueStatusUpdated() {
+      maybeUpdateTimelineAndNotify();
+    }
+
+    @Override
+    public void onPreloadStatusUpdated() {}
+
+    @Override
+    public void onSendingRemoteMediaRequest() {}
+
+    @Override
+    public void onAdBreakStatusUpdated() {}
+
+
+    // SessionManagerListener implementation.
+
+    @Override
+    public void onSessionStarted(CastSession castSession, String s) {
+      setRemoteMediaClient(castSession.getRemoteMediaClient());
+    }
+
+    @Override
+    public void onSessionResumed(CastSession castSession, boolean b) {
+      setRemoteMediaClient(castSession.getRemoteMediaClient());
+    }
+
+    @Override
+    public void onSessionEnded(CastSession castSession, int i) {
+      setRemoteMediaClient(null);
+    }
+
+    @Override
+    public void onSessionSuspended(CastSession castSession, int i) {
+      setRemoteMediaClient(null);
+    }
+
+    @Override
+    public void onSessionResumeFailed(CastSession castSession, int statusCode) {
+      Log.e(TAG, "Session resume failed. Error code " + statusCode + ": "
+          + CastUtils.getLogString(statusCode));
+    }
+
+    @Override
+    public void onSessionStarting(CastSession castSession) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onSessionStartFailed(CastSession castSession, int statusCode) {
+      Log.e(TAG, "Session start failed. Error code " + statusCode + ": "
+          + CastUtils.getLogString(statusCode));
+    }
+
+    @Override
+    public void onSessionEnding(CastSession castSession) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onSessionResuming(CastSession castSession, String s) {
+      // Do nothing.
+    }
+
+  }
+
+  // Result callbacks hooks.
+
+  private final class SeekResultCallback implements ResultCallback<MediaChannelResult> {
+
+    @Override
+    public void onResult(@NonNull MediaChannelResult result) {
+      int statusCode = result.getStatus().getStatusCode();
+      if (statusCode != CastStatusCodes.SUCCESS && statusCode != CastStatusCodes.REPLACED) {
+        Log.e(TAG, "Seek failed. Error code " + statusCode + ": "
+            + CastUtils.getLogString(statusCode));
+      }
+      if (--pendingSeekCount == 0) {
+        pendingSeekWindowIndex = C.INDEX_UNSET;
+        pendingSeekPositionMs = C.TIME_UNSET;
+        for (EventListener listener : listeners) {
+          listener.onSeekProcessed();
+        }
+      }
+    }
+  }
+
+}
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
new file mode 100644
index 0000000000..a0be844439
--- /dev/null
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimeline.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+import android.util.SparseIntArray;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.gms.cast.MediaInfo;
+import com.google.android.gms.cast.MediaQueueItem;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A {@link Timeline} for Cast media queues.
+ */
+/* package */ final class CastTimeline extends Timeline {
+
+  public static final CastTimeline EMPTY_CAST_TIMELINE =
+      new CastTimeline(
+          Collections.<MediaQueueItem>emptyList(), Collections.<String, Long>emptyMap());
+
+  private final SparseIntArray idsToIndex;
+  private final int[] ids;
+  private final long[] durationsUs;
+  private final long[] defaultPositionsUs;
+
+  /**
+   * @param items A list of cast media queue items to represent.
+   * @param contentIdToDurationUsMap A map of content id to duration in microseconds.
+   */
+  public CastTimeline(List<MediaQueueItem> items, Map<String, Long> contentIdToDurationUsMap) {
+    int itemCount = items.size();
+    int index = 0;
+    idsToIndex = new SparseIntArray(itemCount);
+    ids = new int[itemCount];
+    durationsUs = new long[itemCount];
+    defaultPositionsUs = new long[itemCount];
+    for (MediaQueueItem item : items) {
+      int itemId = item.getItemId();
+      ids[index] = itemId;
+      idsToIndex.put(itemId, index);
+      MediaInfo mediaInfo = item.getMedia();
+      String contentId = mediaInfo.getContentId();
+      durationsUs[index] =
+          contentIdToDurationUsMap.containsKey(contentId)
+              ? contentIdToDurationUsMap.get(contentId)
+              : CastUtils.getStreamDurationUs(mediaInfo);
+      defaultPositionsUs[index] = (long) (item.getStartTime() * C.MICROS_PER_SECOND);
+      index++;
+    }
+  }
+
+  // Timeline implementation.
+
+  @Override
+  public int getWindowCount() {
+    return ids.length;
+  }
+
+  @Override
+  public Window getWindow(int windowIndex, Window window, boolean setIds,
+      long defaultPositionProjectionUs) {
+    long durationUs = durationsUs[windowIndex];
+    boolean isDynamic = durationUs == C.TIME_UNSET;
+    return window.set(ids[windowIndex], C.TIME_UNSET, C.TIME_UNSET, !isDynamic, isDynamic,
+        defaultPositionsUs[windowIndex], durationUs, windowIndex, windowIndex, 0);
+  }
+
+  @Override
+  public int getPeriodCount() {
+    return ids.length;
+  }
+
+  @Override
+  public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+    int id = ids[periodIndex];
+    return period.set(id, id, periodIndex, durationsUs[periodIndex], 0);
+  }
+
+  @Override
+  public int getIndexOfPeriod(Object uid) {
+    return uid instanceof Integer ? idsToIndex.get((int) uid, C.INDEX_UNSET) : C.INDEX_UNSET;
+  }
+
+  // equals and hashCode implementations.
+
+  @Override
+  public boolean equals(Object other) {
+    if (this == other) {
+      return true;
+    } else if (!(other instanceof CastTimeline)) {
+      return false;
+    }
+    CastTimeline that = (CastTimeline) other;
+    return Arrays.equals(ids, that.ids)
+        && Arrays.equals(durationsUs, that.durationsUs)
+        && Arrays.equals(defaultPositionsUs, that.defaultPositionsUs);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = Arrays.hashCode(ids);
+    result = 31 * result + Arrays.hashCode(durationsUs);
+    result = 31 * result + Arrays.hashCode(defaultPositionsUs);
+    return result;
+  }
+
+}
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimelineTracker.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimelineTracker.java
new file mode 100644
index 0000000000..412bfb476d
--- /dev/null
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastTimelineTracker.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+import com.google.android.gms.cast.MediaInfo;
+import com.google.android.gms.cast.MediaQueueItem;
+import com.google.android.gms.cast.MediaStatus;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+
+/**
+ * Creates {@link CastTimeline}s from cast receiver app media status.
+ *
+ * <p>This class keeps track of the duration reported by the current item to fill any missing
+ * durations in the media queue items [See internal: b/65152553].
+ */
+/* package */ final class CastTimelineTracker {
+
+  private final HashMap<String, Long> contentIdToDurationUsMap;
+  private final HashSet<String> scratchContentIdSet;
+
+  public CastTimelineTracker() {
+    contentIdToDurationUsMap = new HashMap<>();
+    scratchContentIdSet = new HashSet<>();
+  }
+
+  /**
+   * Returns a {@link CastTimeline} that represent the given {@code status}.
+   *
+   * @param status The Cast media status.
+   * @return A {@link CastTimeline} that represent the given {@code status}.
+   */
+  public CastTimeline getCastTimeline(MediaStatus status) {
+    MediaInfo mediaInfo = status.getMediaInfo();
+    List<MediaQueueItem> items = status.getQueueItems();
+    removeUnusedDurationEntries(items);
+
+    if (mediaInfo != null) {
+      String contentId = mediaInfo.getContentId();
+      long durationUs = CastUtils.getStreamDurationUs(mediaInfo);
+      contentIdToDurationUsMap.put(contentId, durationUs);
+    }
+    return new CastTimeline(items, contentIdToDurationUsMap);
+  }
+
+  private void removeUnusedDurationEntries(List<MediaQueueItem> items) {
+    scratchContentIdSet.clear();
+    for (MediaQueueItem item : items) {
+      scratchContentIdSet.add(item.getMedia().getContentId());
+    }
+    contentIdToDurationUsMap.keySet().retainAll(scratchContentIdSet);
+  }
+}
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java
new file mode 100644
index 0000000000..f17c39bdbf
--- /dev/null
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/CastUtils.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.gms.cast.CastStatusCodes;
+import com.google.android.gms.cast.MediaInfo;
+import com.google.android.gms.cast.MediaTrack;
+
+/**
+ * Utility methods for ExoPlayer/Cast integration.
+ */
+/* package */ final class CastUtils {
+
+  /**
+   * Returns the duration in microseconds advertised by a media info, or {@link C#TIME_UNSET} if
+   * unknown or not applicable.
+   *
+   * @param mediaInfo The media info to get the duration from.
+   * @return The duration in microseconds.
+   */
+  public static long getStreamDurationUs(MediaInfo mediaInfo) {
+    long durationMs =
+        mediaInfo != null ? mediaInfo.getStreamDuration() : MediaInfo.UNKNOWN_DURATION;
+    return durationMs != MediaInfo.UNKNOWN_DURATION ? C.msToUs(durationMs) : C.TIME_UNSET;
+  }
+
+  /**
+   * Returns a descriptive log string for the given {@code statusCode}, or "Unknown." if not one of
+   * {@link CastStatusCodes}.
+   *
+   * @param statusCode A Cast API status code.
+   * @return A descriptive log string for the given {@code statusCode}, or "Unknown." if not one of
+   *     {@link CastStatusCodes}.
+   */
+  public static String getLogString(int statusCode) {
+    switch (statusCode) {
+      case CastStatusCodes.APPLICATION_NOT_FOUND:
+        return "A requested application could not be found.";
+      case CastStatusCodes.APPLICATION_NOT_RUNNING:
+        return "A requested application is not currently running.";
+      case CastStatusCodes.AUTHENTICATION_FAILED:
+        return "Authentication failure.";
+      case CastStatusCodes.CANCELED:
+        return "An in-progress request has been canceled, most likely because another action has "
+            + "preempted it.";
+      case CastStatusCodes.ERROR_SERVICE_CREATION_FAILED:
+        return "The Cast Remote Display service could not be created.";
+      case CastStatusCodes.ERROR_SERVICE_DISCONNECTED:
+        return "The Cast Remote Display service was disconnected.";
+      case CastStatusCodes.FAILED:
+        return "The in-progress request failed.";
+      case CastStatusCodes.INTERNAL_ERROR:
+        return "An internal error has occurred.";
+      case CastStatusCodes.INTERRUPTED:
+        return "A blocking call was interrupted while waiting and did not run to completion.";
+      case CastStatusCodes.INVALID_REQUEST:
+        return "An invalid request was made.";
+      case CastStatusCodes.MESSAGE_SEND_BUFFER_TOO_FULL:
+        return "A message could not be sent because there is not enough room in the send buffer at "
+            + "this time.";
+      case CastStatusCodes.MESSAGE_TOO_LARGE:
+        return "A message could not be sent because it is too large.";
+      case CastStatusCodes.NETWORK_ERROR:
+        return "Network I/O error.";
+      case CastStatusCodes.NOT_ALLOWED:
+        return "The request was disallowed and could not be completed.";
+      case CastStatusCodes.REPLACED:
+        return "The request's progress is no longer being tracked because another request of the "
+            + "same type has been made before the first request completed.";
+      case CastStatusCodes.SUCCESS:
+        return "Success.";
+      case CastStatusCodes.TIMEOUT:
+        return "An operation has timed out.";
+      case CastStatusCodes.UNKNOWN_ERROR:
+        return "An unknown, unexpected error has occurred.";
+      default:
+        return "Unknown: " + statusCode;
+    }
+  }
+
+  /**
+   * Creates a {@link Format} instance containing all information contained in the given
+   * {@link MediaTrack} object.
+   *
+   * @param mediaTrack The {@link MediaTrack}.
+   * @return The equivalent {@link Format}.
+   */
+  public static Format mediaTrackToFormat(MediaTrack mediaTrack) {
+    return Format.createContainerFormat(mediaTrack.getContentId(), mediaTrack.getContentType(),
+        null, null, Format.NO_VALUE, 0, mediaTrack.getLanguage());
+  }
+
+  private CastUtils() {}
+
+}
diff --git a/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/DefaultCastOptionsProvider.java b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/DefaultCastOptionsProvider.java
new file mode 100644
index 0000000000..06f0bec971
--- /dev/null
+++ b/extensions/cast/src/main/java/com/google/android/exoplayer2/ext/cast/DefaultCastOptionsProvider.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+import android.content.Context;
+import com.google.android.gms.cast.CastMediaControlIntent;
+import com.google.android.gms.cast.framework.CastOptions;
+import com.google.android.gms.cast.framework.OptionsProvider;
+import com.google.android.gms.cast.framework.SessionProvider;
+import java.util.List;
+
+/**
+ * A convenience {@link OptionsProvider} to target the default cast receiver app.
+ */
+public final class DefaultCastOptionsProvider implements OptionsProvider {
+
+  @Override
+  public CastOptions getCastOptions(Context context) {
+    return new CastOptions.Builder()
+        .setReceiverApplicationId(CastMediaControlIntent.DEFAULT_MEDIA_RECEIVER_APPLICATION_ID)
+        .setStopReceiverApplicationWhenEndingSession(true).build();
+  }
+
+  @Override
+  public List<SessionProvider> getAdditionalSessionProviders(Context context) {
+    return null;
+  }
+
+}
diff --git a/extensions/cast/src/test/AndroidManifest.xml b/extensions/cast/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..057efdc245
--- /dev/null
+++ b/extensions/cast/src/test/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.android.exoplayer2.ext.cast.test">
+
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
+
+</manifest>
diff --git a/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/CastTimelineTrackerTest.java b/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/CastTimelineTrackerTest.java
new file mode 100644
index 0000000000..4c60e7c0b3
--- /dev/null
+++ b/extensions/cast/src/test/java/com/google/android/exoplayer2/ext/cast/CastTimelineTrackerTest.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ext.cast;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.testutil.TimelineAsserts;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.gms.cast.MediaInfo;
+import com.google.android.gms.cast.MediaQueueItem;
+import com.google.android.gms.cast.MediaStatus;
+import java.util.ArrayList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.robolectric.RobolectricTestRunner;
+
+/** Tests for {@link CastTimelineTracker}. */
+@RunWith(RobolectricTestRunner.class)
+public class CastTimelineTrackerTest {
+
+  private static final long DURATION_1_MS = 1000;
+  private static final long DURATION_2_MS = 2000;
+  private static final long DURATION_3_MS = 3000;
+  private static final long DURATION_4_MS = 4000;
+  private static final long DURATION_5_MS = 5000;
+
+  /** Tests that duration of the current media info is correctly propagated to the timeline. */
+  @Test
+  public void testGetCastTimeline() {
+    MediaInfo mediaInfo;
+    MediaStatus status =
+        mockMediaStatus(
+            new int[] {1, 2, 3},
+            new String[] {"contentId1", "contentId2", "contentId3"},
+            new long[] {DURATION_1_MS, MediaInfo.UNKNOWN_DURATION, MediaInfo.UNKNOWN_DURATION});
+
+    CastTimelineTracker tracker = new CastTimelineTracker();
+    mediaInfo = getMediaInfo("contentId1", DURATION_1_MS);
+    Mockito.when(status.getMediaInfo()).thenReturn(mediaInfo);
+    TimelineAsserts.assertPeriodDurations(
+        tracker.getCastTimeline(status), C.msToUs(DURATION_1_MS), C.TIME_UNSET, C.TIME_UNSET);
+
+    mediaInfo = getMediaInfo("contentId3", DURATION_3_MS);
+    Mockito.when(status.getMediaInfo()).thenReturn(mediaInfo);
+    TimelineAsserts.assertPeriodDurations(
+        tracker.getCastTimeline(status),
+        C.msToUs(DURATION_1_MS),
+        C.TIME_UNSET,
+        C.msToUs(DURATION_3_MS));
+
+    mediaInfo = getMediaInfo("contentId2", DURATION_2_MS);
+    Mockito.when(status.getMediaInfo()).thenReturn(mediaInfo);
+    TimelineAsserts.assertPeriodDurations(
+        tracker.getCastTimeline(status),
+        C.msToUs(DURATION_1_MS),
+        C.msToUs(DURATION_2_MS),
+        C.msToUs(DURATION_3_MS));
+
+    MediaStatus newStatus =
+        mockMediaStatus(
+            new int[] {4, 1, 5, 3},
+            new String[] {"contentId4", "contentId1", "contentId5", "contentId3"},
+            new long[] {
+              MediaInfo.UNKNOWN_DURATION,
+              MediaInfo.UNKNOWN_DURATION,
+              DURATION_5_MS,
+              MediaInfo.UNKNOWN_DURATION
+            });
+    mediaInfo = getMediaInfo("contentId5", DURATION_5_MS);
+    Mockito.when(newStatus.getMediaInfo()).thenReturn(mediaInfo);
+    TimelineAsserts.assertPeriodDurations(
+        tracker.getCastTimeline(newStatus),
+        C.TIME_UNSET,
+        C.msToUs(DURATION_1_MS),
+        C.msToUs(DURATION_5_MS),
+        C.msToUs(DURATION_3_MS));
+
+    mediaInfo = getMediaInfo("contentId3", DURATION_3_MS);
+    Mockito.when(newStatus.getMediaInfo()).thenReturn(mediaInfo);
+    TimelineAsserts.assertPeriodDurations(
+        tracker.getCastTimeline(newStatus),
+        C.TIME_UNSET,
+        C.msToUs(DURATION_1_MS),
+        C.msToUs(DURATION_5_MS),
+        C.msToUs(DURATION_3_MS));
+
+    mediaInfo = getMediaInfo("contentId4", DURATION_4_MS);
+    Mockito.when(newStatus.getMediaInfo()).thenReturn(mediaInfo);
+    TimelineAsserts.assertPeriodDurations(
+        tracker.getCastTimeline(newStatus),
+        C.msToUs(DURATION_4_MS),
+        C.msToUs(DURATION_1_MS),
+        C.msToUs(DURATION_5_MS),
+        C.msToUs(DURATION_3_MS));
+  }
+
+  private static MediaStatus mockMediaStatus(
+      int[] itemIds, String[] contentIds, long[] durationsMs) {
+    ArrayList<MediaQueueItem> items = new ArrayList<>();
+    for (int i = 0; i < contentIds.length; i++) {
+      MediaInfo mediaInfo = getMediaInfo(contentIds[i], durationsMs[i]);
+      MediaQueueItem item = Mockito.mock(MediaQueueItem.class);
+      Mockito.when(item.getMedia()).thenReturn(mediaInfo);
+      Mockito.when(item.getItemId()).thenReturn(itemIds[i]);
+      items.add(item);
+    }
+    MediaStatus status = Mockito.mock(MediaStatus.class);
+    Mockito.when(status.getQueueItems()).thenReturn(items);
+    return status;
+  }
+
+  private static MediaInfo getMediaInfo(String contentId, long durationMs) {
+    return new MediaInfo.Builder(contentId)
+        .setStreamDuration(durationMs)
+        .setContentType(MimeTypes.APPLICATION_MP4)
+        .setStreamType(MediaInfo.STREAM_TYPE_NONE)
+        .build();
+  }
+}
diff --git a/extensions/cast/src/test/resources/robolectric.properties b/extensions/cast/src/test/resources/robolectric.properties
new file mode 100644
index 0000000000..2f3210368e
--- /dev/null
+++ b/extensions/cast/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+manifest=src/test/AndroidManifest.xml
diff --git a/extensions/cronet/README.md b/extensions/cronet/README.md
index 66da774978..ea84b602db 100644
--- a/extensions/cronet/README.md
+++ b/extensions/cronet/README.md
@@ -19,10 +19,20 @@ and enable the extension:
 1. Copy the three jar files into the `libs` directory of this extension
 1. Copy the content of the downloaded `libs` directory into the `jniLibs`
    directory of this extension
-
-* In your `settings.gradle` file, add
-  `gradle.ext.exoplayerIncludeCronetExtension = true` before the line that
-  applies `core_settings.gradle`.
+1. In your `settings.gradle` file, add
+   `gradle.ext.exoplayerIncludeCronetExtension = true` before the line that
+   applies `core_settings.gradle`.
+1. In all `build.gradle` files where this extension is linked as a dependency,
+   add
+   ```
+   android {
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+   }
+   ```
+   to enable Java 8 features required by the Cronet library.
 
 [top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
 [here]: https://console.cloud.google.com/storage/browser/chromium-cronet/android
diff --git a/extensions/cronet/build.gradle b/extensions/cronet/build.gradle
index 197dec80a5..1cfb4f5513 100644
--- a/extensions/cronet/build.gradle
+++ b/extensions/cronet/build.gradle
@@ -35,15 +35,13 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile files('libs/cronet_api.jar')
-    compile files('libs/cronet_impl_common_java.jar')
-    compile files('libs/cronet_impl_native_java.jar')
-    androidTestCompile project(modulePrefix + 'library')
-    androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
-    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
-    androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
-    androidTestCompile 'com.android.support.test:runner:' + testSupportLibraryVersion
+    api files('libs/cronet_api.jar')
+    implementation files('libs/cronet_impl_common_java.jar')
+    implementation files('libs/cronet_impl_native_java.jar')
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    testImplementation project(modulePrefix + 'library')
+    testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
 ext {
diff --git a/extensions/cronet/src/main/AndroidManifest.xml b/extensions/cronet/src/main/AndroidManifest.xml
index c81d95f104..5ba54999f4 100644
--- a/extensions/cronet/src/main/AndroidManifest.xml
+++ b/extensions/cronet/src/main/AndroidManifest.xml
@@ -14,7 +14,7 @@
 -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.google.android.exoplayer.ext.cronet">
+    package="com.google.android.exoplayer2.ext.cronet">
 
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
 
diff --git a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
index 536155a70f..29bc874cd8 100644
--- a/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
+++ b/extensions/cronet/src/main/java/com/google/android/exoplayer2/ext/cronet/CronetDataSource.java
@@ -369,6 +369,7 @@ public int read(byte[] buffer, int offset, int readLength) throws HttpDataSource
         throw new HttpDataSourceException(exception, currentDataSpec,
             HttpDataSourceException.TYPE_READ);
       } else if (finished) {
+        bytesRemaining = 0;
         return C.RESULT_END_OF_INPUT;
       } else {
         // The operation didn't time out, fail or finish, and therefore data must have been read.
diff --git a/extensions/cronet/src/androidTest/AndroidManifest.xml b/extensions/cronet/src/test/AndroidManifest.xml
similarity index 67%
rename from extensions/cronet/src/androidTest/AndroidManifest.xml
rename to extensions/cronet/src/test/AndroidManifest.xml
index 7f14a28e83..52be9aa157 100644
--- a/extensions/cronet/src/androidTest/AndroidManifest.xml
+++ b/extensions/cronet/src/test/AndroidManifest.xml
@@ -16,18 +16,8 @@
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:tools="http://schemas.android.com/tools"
-    package="com.google.android.exoplayer.ext.cronet">
+    package="com.google.android.exoplayer2.ext.cronet">
 
   <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
-  <application android:debuggable="true"
-      android:allowBackup="false"
-      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
-    <uses-library android:name="android.test.runner" />
-  </application>
-
-  <instrumentation
-      android:name="android.test.InstrumentationTestRunner"
-      android:targetPackage="com.google.android.exoplayer.ext.cronet"/>
-
 </manifest>
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
similarity index 76%
rename from extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
rename to extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
index a65bb0951b..291e73fcc1 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
+++ b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/ByteArrayUploadDataProviderTest.java
@@ -15,14 +15,10 @@
  */
 package com.google.android.exoplayer2.ext.cronet;
 
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
-import static org.mockito.MockitoAnnotations.initMocks;
 
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
@@ -31,11 +27,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link ByteArrayUploadDataProvider}.
- */
-@RunWith(AndroidJUnit4.class)
+/** Tests for {@link ByteArrayUploadDataProvider}. */
+@RunWith(RobolectricTestRunner.class)
 public final class ByteArrayUploadDataProviderTest {
 
   private static final byte[] TEST_DATA = new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
@@ -46,22 +42,20 @@
 
   @Before
   public void setUp() {
-    System.setProperty("dexmaker.dexcache",
-        InstrumentationRegistry.getTargetContext().getCacheDir().getPath());
-    initMocks(this);
+    MockitoAnnotations.initMocks(this);
     byteBuffer = ByteBuffer.allocate(TEST_DATA.length);
     byteArrayUploadDataProvider = new ByteArrayUploadDataProvider(TEST_DATA);
   }
 
   @Test
   public void testGetLength() {
-    assertEquals(TEST_DATA.length, byteArrayUploadDataProvider.getLength());
+    assertThat(byteArrayUploadDataProvider.getLength()).isEqualTo(TEST_DATA.length);
   }
 
   @Test
   public void testReadFullBuffer() throws IOException {
     byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
-    assertArrayEquals(TEST_DATA, byteBuffer.array());
+    assertThat(byteBuffer.array()).isEqualTo(TEST_DATA);
   }
 
   @Test
@@ -71,12 +65,12 @@ public void testReadPartialBuffer() throws IOException {
     byteBuffer = ByteBuffer.allocate(TEST_DATA.length / 2);
     // Read half of the data.
     byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
-    assertArrayEquals(firstHalf, byteBuffer.array());
+    assertThat(byteBuffer.array()).isEqualTo(firstHalf);
 
     // Read the second half of the data.
     byteBuffer.rewind();
     byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
-    assertArrayEquals(secondHalf, byteBuffer.array());
+    assertThat(byteBuffer.array()).isEqualTo(secondHalf);
     verify(mockUploadDataSink, times(2)).onReadSucceeded(false);
   }
 
@@ -84,14 +78,13 @@ public void testReadPartialBuffer() throws IOException {
   public void testRewind() throws IOException {
     // Read all the data.
     byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
-    assertArrayEquals(TEST_DATA, byteBuffer.array());
+    assertThat(byteBuffer.array()).isEqualTo(TEST_DATA);
 
     // Rewind and make sure it can be read again.
     byteBuffer.clear();
     byteArrayUploadDataProvider.rewind(mockUploadDataSink);
     byteArrayUploadDataProvider.read(mockUploadDataSink, byteBuffer);
-    assertArrayEquals(TEST_DATA, byteBuffer.array());
+    assertThat(byteBuffer.array()).isEqualTo(TEST_DATA);
     verify(mockUploadDataSink).onRewindSucceeded();
   }
-
 }
diff --git a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
similarity index 63%
rename from extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
rename to extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
index 4c6a42849f..4e990cd027 100644
--- a/extensions/cronet/src/androidTest/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
+++ b/extensions/cronet/src/test/java/com/google/android/exoplayer2/ext/cronet/CronetDataSourceTest.java
@@ -15,10 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.cronet;
 
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyString;
@@ -31,12 +28,10 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import static org.mockito.MockitoAnnotations.initMocks;
 
 import android.net.Uri;
 import android.os.ConditionVariable;
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
+import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
@@ -53,6 +48,7 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.chromium.net.CronetEngine;
@@ -64,13 +60,14 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.shadows.ShadowSystemClock;
 
-/**
- * Tests for {@link CronetDataSource}.
- */
-@RunWith(AndroidJUnit4.class)
+/** Tests for {@link CronetDataSource}. */
+@RunWith(RobolectricTestRunner.class)
 public final class CronetDataSourceTest {
 
   private static final int TEST_CONNECT_TIMEOUT_MS = 100;
@@ -88,18 +85,11 @@
   private UrlResponseInfo testUrlResponseInfo;
 
   @Mock private UrlRequest.Builder mockUrlRequestBuilder;
-  @Mock
-  private UrlRequest mockUrlRequest;
-  @Mock
-  private Predicate<String> mockContentTypePredicate;
-  @Mock
-  private TransferListener<CronetDataSource> mockTransferListener;
-  @Mock
-  private Clock mockClock;
-  @Mock
-  private Executor mockExecutor;
-  @Mock
-  private NetworkException mockNetworkException;
+  @Mock private UrlRequest mockUrlRequest;
+  @Mock private Predicate<String> mockContentTypePredicate;
+  @Mock private TransferListener<CronetDataSource> mockTransferListener;
+  @Mock private Executor mockExecutor;
+  @Mock private NetworkException mockNetworkException;
   @Mock private CronetEngine mockCronetEngine;
 
   private CronetDataSource dataSourceUnderTest;
@@ -107,32 +97,31 @@
 
   @Before
   public void setUp() throws Exception {
-    System.setProperty("dexmaker.dexcache",
-        InstrumentationRegistry.getTargetContext().getCacheDir().getPath());
-    initMocks(this);
-    dataSourceUnderTest = spy(
-        new CronetDataSource(
-            mockCronetEngine,
-            mockExecutor,
-            mockContentTypePredicate,
-            mockTransferListener,
-            TEST_CONNECT_TIMEOUT_MS,
-            TEST_READ_TIMEOUT_MS,
-            true, // resetTimeoutOnRedirects
-            mockClock,
-            null,
-            false));
+    MockitoAnnotations.initMocks(this);
+    dataSourceUnderTest =
+        spy(
+            new CronetDataSource(
+                mockCronetEngine,
+                mockExecutor,
+                mockContentTypePredicate,
+                mockTransferListener,
+                TEST_CONNECT_TIMEOUT_MS,
+                TEST_READ_TIMEOUT_MS,
+                true, // resetTimeoutOnRedirects
+                Clock.DEFAULT,
+                null,
+                false));
     when(mockContentTypePredicate.evaluate(anyString())).thenReturn(true);
     when(mockCronetEngine.newUrlRequestBuilder(
-        anyString(), any(UrlRequest.Callback.class), any(Executor.class)))
+            anyString(), any(UrlRequest.Callback.class), any(Executor.class)))
         .thenReturn(mockUrlRequestBuilder);
     when(mockUrlRequestBuilder.allowDirectExecutor()).thenReturn(mockUrlRequestBuilder);
     when(mockUrlRequestBuilder.build()).thenReturn(mockUrlRequest);
     mockStatusResponse();
 
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 0, C.LENGTH_UNSET, null);
-    testPostDataSpec = new DataSpec(
-        Uri.parse(TEST_URL), TEST_POST_BODY, 0, 0, C.LENGTH_UNSET, null, 0);
+    testPostDataSpec =
+        new DataSpec(Uri.parse(TEST_URL), TEST_POST_BODY, 0, 0, C.LENGTH_UNSET, null, 0);
     testResponseHeader = new HashMap<>();
     testResponseHeader.put("Content-Type", TEST_CONTENT_TYPE);
     // This value can be anything since the DataSpec is unset.
@@ -178,20 +167,19 @@ public void testCallbackFromPreviousRequest() throws HttpDataSourceException {
     // Prepare a mock UrlRequest to be used in the second open() call.
     final UrlRequest mockUrlRequest2 = mock(UrlRequest.class);
     when(mockUrlRequestBuilder.build()).thenReturn(mockUrlRequest2);
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        // Invoke the callback for the previous request.
-        dataSourceUnderTest.onFailed(
-            mockUrlRequest,
-            testUrlResponseInfo,
-            mockNetworkException);
-        dataSourceUnderTest.onResponseStarted(
-            mockUrlRequest2,
-            testUrlResponseInfo);
-        return null;
-      }
-    }).when(mockUrlRequest2).start();
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                // Invoke the callback for the previous request.
+                dataSourceUnderTest.onFailed(
+                    mockUrlRequest, testUrlResponseInfo, mockNetworkException);
+                dataSourceUnderTest.onResponseStarted(mockUrlRequest2, testUrlResponseInfo);
+                return null;
+              }
+            })
+        .when(mockUrlRequest2)
+        .start();
     dataSourceUnderTest.open(testDataSpec);
   }
 
@@ -224,7 +212,7 @@ public void testRequestHeadersSet() throws HttpDataSourceException {
   @Test
   public void testRequestOpen() throws HttpDataSourceException {
     mockResponseStartSuccess();
-    assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testDataSpec));
+    assertThat(dataSourceUnderTest.open(testDataSpec)).isEqualTo(TEST_CONTENT_LENGTH);
     verify(mockTransferListener).onTransferStart(dataSourceUnderTest, testDataSpec);
   }
 
@@ -236,7 +224,7 @@ public void testRequestOpenGzippedCompressedReturnsDataSpecLength()
     testResponseHeader.put("Content-Length", Long.toString(50L));
     mockResponseStartSuccess();
 
-    assertEquals(5000 /* contentLength */, dataSourceUnderTest.open(testDataSpec));
+    assertThat(dataSourceUnderTest.open(testDataSpec)).isEqualTo(5000 /* contentLength */);
     verify(mockTransferListener).onTransferStart(dataSourceUnderTest, testDataSpec);
   }
 
@@ -249,7 +237,7 @@ public void testRequestOpenFail() {
       fail("HttpDataSource.HttpDataSourceException expected");
     } catch (HttpDataSourceException e) {
       // Check for connection not automatically closed.
-      assertFalse(e.getCause() instanceof UnknownHostException);
+      assertThat(e.getCause() instanceof UnknownHostException).isFalse();
       verify(mockUrlRequest, never()).cancel();
       verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
     }
@@ -258,15 +246,15 @@ public void testRequestOpenFail() {
   @Test
   public void testRequestOpenFailDueToDnsFailure() {
     mockResponseStartFailure();
-    when(mockNetworkException.getErrorCode()).thenReturn(
-        NetworkException.ERROR_HOSTNAME_NOT_RESOLVED);
+    when(mockNetworkException.getErrorCode())
+        .thenReturn(NetworkException.ERROR_HOSTNAME_NOT_RESOLVED);
 
     try {
       dataSourceUnderTest.open(testDataSpec);
       fail("HttpDataSource.HttpDataSourceException expected");
     } catch (HttpDataSourceException e) {
       // Check for connection not automatically closed.
-      assertTrue(e.getCause() instanceof UnknownHostException);
+      assertThat(e.getCause() instanceof UnknownHostException).isTrue();
       verify(mockUrlRequest, never()).cancel();
       verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
     }
@@ -281,7 +269,7 @@ public void testRequestOpenValidatesStatusCode() {
       dataSourceUnderTest.open(testDataSpec);
       fail("HttpDataSource.HttpDataSourceException expected");
     } catch (HttpDataSourceException e) {
-      assertTrue(e instanceof HttpDataSource.InvalidResponseCodeException);
+      assertThat(e instanceof HttpDataSource.InvalidResponseCodeException).isTrue();
       // Check for connection not automatically closed.
       verify(mockUrlRequest, never()).cancel();
       verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
@@ -297,7 +285,7 @@ public void testRequestOpenValidatesContentTypePredicate() {
       dataSourceUnderTest.open(testDataSpec);
       fail("HttpDataSource.HttpDataSourceException expected");
     } catch (HttpDataSourceException e) {
-      assertTrue(e instanceof HttpDataSource.InvalidContentTypeException);
+      assertThat(e instanceof HttpDataSource.InvalidContentTypeException).isTrue();
       // Check for connection not automatically closed.
       verify(mockUrlRequest, never()).cancel();
       verify(mockContentTypePredicate).evaluate(TEST_CONTENT_TYPE);
@@ -309,7 +297,7 @@ public void testPostRequestOpen() throws HttpDataSourceException {
     mockResponseStartSuccess();
 
     dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
-    assertEquals(TEST_CONTENT_LENGTH, dataSourceUnderTest.open(testPostDataSpec));
+    assertThat(dataSourceUnderTest.open(testPostDataSpec)).isEqualTo(TEST_CONTENT_LENGTH);
     verify(mockTransferListener).onTransferStart(dataSourceUnderTest, testPostDataSpec);
   }
 
@@ -348,13 +336,13 @@ public void testRequestReadTwice() throws HttpDataSourceException {
 
     byte[] returnedBuffer = new byte[8];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
-    assertEquals(8, bytesRead);
+    assertThat(returnedBuffer).isEqualTo(buildTestDataArray(0, 8));
+    assertThat(bytesRead).isEqualTo(8);
 
     returnedBuffer = new byte[8];
     bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertArrayEquals(buildTestDataArray(8, 8), returnedBuffer);
-    assertEquals(8, bytesRead);
+    assertThat(returnedBuffer).isEqualTo(buildTestDataArray(8, 8));
+    assertThat(bytesRead).isEqualTo(8);
 
     // Should have only called read on cronet once.
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
@@ -380,11 +368,11 @@ public void testSecondRequestNoContentLength() throws HttpDataSourceException {
     dataSourceUnderTest.open(testDataSpec);
     returnedBuffer = new byte[16];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
-    assertEquals(10, bytesRead);
+    assertThat(bytesRead).isEqualTo(10);
     bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
-    assertEquals(6, bytesRead);
+    assertThat(bytesRead).isEqualTo(6);
     bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 10);
-    assertEquals(C.RESULT_END_OF_INPUT, bytesRead);
+    assertThat(bytesRead).isEqualTo(C.RESULT_END_OF_INPUT);
   }
 
   @Test
@@ -396,8 +384,8 @@ public void testReadWithOffset() throws HttpDataSourceException {
 
     byte[] returnedBuffer = new byte[16];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 8, 8);
-    assertEquals(8, bytesRead);
-    assertArrayEquals(prefixZeros(buildTestDataArray(0, 8), 16), returnedBuffer);
+    assertThat(bytesRead).isEqualTo(8);
+    assertThat(returnedBuffer).isEqualTo(prefixZeros(buildTestDataArray(0, 8), 16));
     verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 8);
   }
 
@@ -412,8 +400,8 @@ public void testRangeRequestWith206Response() throws HttpDataSourceException {
 
     byte[] returnedBuffer = new byte[16];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
-    assertEquals(16, bytesRead);
-    assertArrayEquals(buildTestDataArray(1000, 16), returnedBuffer);
+    assertThat(bytesRead).isEqualTo(16);
+    assertThat(returnedBuffer).isEqualTo(buildTestDataArray(1000, 16));
     verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 16);
   }
 
@@ -428,8 +416,8 @@ public void testRangeRequestWith200Response() throws HttpDataSourceException {
 
     byte[] returnedBuffer = new byte[16];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
-    assertEquals(16, bytesRead);
-    assertArrayEquals(buildTestDataArray(1000, 16), returnedBuffer);
+    assertThat(bytesRead).isEqualTo(16);
+    assertThat(returnedBuffer).isEqualTo(buildTestDataArray(1000, 16));
     verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 16);
   }
 
@@ -443,8 +431,8 @@ public void testReadWithUnsetLength() throws HttpDataSourceException {
 
     byte[] returnedBuffer = new byte[16];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 8, 8);
-    assertArrayEquals(prefixZeros(buildTestDataArray(0, 8), 16), returnedBuffer);
-    assertEquals(8, bytesRead);
+    assertThat(returnedBuffer).isEqualTo(prefixZeros(buildTestDataArray(0, 8), 16));
+    assertThat(bytesRead).isEqualTo(8);
     verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 8);
   }
 
@@ -457,8 +445,8 @@ public void testReadReturnsWhatItCan() throws HttpDataSourceException {
 
     byte[] returnedBuffer = new byte[24];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 24);
-    assertArrayEquals(suffixZeros(buildTestDataArray(0, 16), 24), returnedBuffer);
-    assertEquals(16, bytesRead);
+    assertThat(returnedBuffer).isEqualTo(suffixZeros(buildTestDataArray(0, 16), 24));
+    assertThat(bytesRead).isEqualTo(16);
     verify(mockTransferListener).onBytesTransferred(dataSourceUnderTest, 16);
   }
 
@@ -472,8 +460,8 @@ public void testClosedMeansClosed() throws HttpDataSourceException {
 
     byte[] returnedBuffer = new byte[8];
     bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
-    assertEquals(8, bytesRead);
+    assertThat(returnedBuffer).isEqualTo(buildTestDataArray(0, 8));
+    assertThat(bytesRead).isEqualTo(8);
 
     dataSourceUnderTest.close();
     verify(mockTransferListener).onTransferEnd(dataSourceUnderTest);
@@ -486,7 +474,7 @@ public void testClosedMeansClosed() throws HttpDataSourceException {
     }
 
     // 16 bytes were attempted but only 8 should have been successfully read.
-    assertEquals(8, bytesRead);
+    assertThat(bytesRead).isEqualTo(8);
   }
 
   @Test
@@ -500,20 +488,20 @@ public void testOverread() throws HttpDataSourceException {
 
     byte[] returnedBuffer = new byte[8];
     int bytesRead = dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertEquals(8, bytesRead);
-    assertArrayEquals(buildTestDataArray(0, 8), returnedBuffer);
+    assertThat(bytesRead).isEqualTo(8);
+    assertThat(returnedBuffer).isEqualTo(buildTestDataArray(0, 8));
 
     // The current buffer is kept if not completely consumed by DataSource reader.
     returnedBuffer = new byte[8];
     bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 6);
-    assertEquals(14, bytesRead);
-    assertArrayEquals(suffixZeros(buildTestDataArray(8, 6), 8), returnedBuffer);
+    assertThat(bytesRead).isEqualTo(14);
+    assertThat(returnedBuffer).isEqualTo(suffixZeros(buildTestDataArray(8, 6), 8));
 
     // 2 bytes left at this point.
     returnedBuffer = new byte[8];
     bytesRead += dataSourceUnderTest.read(returnedBuffer, 0, 8);
-    assertEquals(16, bytesRead);
-    assertArrayEquals(suffixZeros(buildTestDataArray(14, 2), 8), returnedBuffer);
+    assertThat(bytesRead).isEqualTo(16);
+    assertThat(returnedBuffer).isEqualTo(suffixZeros(buildTestDataArray(14, 2), 8));
 
     // Should have only called read on cronet once.
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
@@ -526,23 +514,23 @@ public void testOverread() throws HttpDataSourceException {
     // Return C.RESULT_END_OF_INPUT
     returnedBuffer = new byte[16];
     int bytesOverRead = dataSourceUnderTest.read(returnedBuffer, 0, 16);
-    assertEquals(C.RESULT_END_OF_INPUT, bytesOverRead);
-    assertArrayEquals(new byte[16], returnedBuffer);
+    assertThat(bytesOverRead).isEqualTo(C.RESULT_END_OF_INPUT);
+    assertThat(returnedBuffer).isEqualTo(new byte[16]);
     // C.RESULT_END_OF_INPUT should not be reported though the TransferListener.
-    verify(mockTransferListener, never()).onBytesTransferred(dataSourceUnderTest,
-        C.RESULT_END_OF_INPUT);
+    verify(mockTransferListener, never())
+        .onBytesTransferred(dataSourceUnderTest, C.RESULT_END_OF_INPUT);
     // There should still be only one call to read on cronet.
     verify(mockUrlRequest, times(1)).read(any(ByteBuffer.class));
     // Check for connection not automatically closed.
     verify(mockUrlRequest, never()).cancel();
-    assertEquals(16, bytesRead);
+    assertThat(bytesRead).isEqualTo(16);
   }
 
   @Test
-  public void testConnectTimeout() {
-    when(mockClock.elapsedRealtime()).thenReturn(0L);
+  public void testConnectTimeout() throws InterruptedException {
+    long startTimeMs = SystemClock.elapsedRealtime();
     final ConditionVariable startCondition = buildUrlRequestStartedCondition();
-    final ConditionVariable timedOutCondition = new ConditionVariable();
+    final CountDownLatch timedOutLatch = new CountDownLatch(1);
 
     new Thread() {
       @Override
@@ -552,34 +540,33 @@ public void run() {
           fail();
         } catch (HttpDataSourceException e) {
           // Expected.
-          assertTrue(e instanceof CronetDataSource.OpenException);
-          assertTrue(e.getCause() instanceof SocketTimeoutException);
-          assertEquals(
-              TEST_CONNECTION_STATUS,
-              ((CronetDataSource.OpenException) e).cronetConnectionStatus);
-          timedOutCondition.open();
+          assertThat(e instanceof CronetDataSource.OpenException).isTrue();
+          assertThat(e.getCause() instanceof SocketTimeoutException).isTrue();
+          assertThat(((CronetDataSource.OpenException) e).cronetConnectionStatus)
+              .isEqualTo(TEST_CONNECTION_STATUS);
+          timedOutLatch.countDown();
         }
       }
     }.start();
     startCondition.block();
 
     // We should still be trying to open.
-    assertFalse(timedOutCondition.block(50));
+    assertNotCountedDown(timedOutLatch);
     // We should still be trying to open as we approach the timeout.
-    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
-    assertFalse(timedOutCondition.block(50));
+    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
+    assertNotCountedDown(timedOutLatch);
     // Now we timeout.
-    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS);
-    timedOutCondition.block();
+    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS + 10);
+    timedOutLatch.await();
 
     verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
   }
 
   @Test
-  public void testConnectInterrupted() {
-    when(mockClock.elapsedRealtime()).thenReturn(0L);
+  public void testConnectInterrupted() throws InterruptedException {
+    long startTimeMs = SystemClock.elapsedRealtime();
     final ConditionVariable startCondition = buildUrlRequestStartedCondition();
-    final ConditionVariable timedOutCondition = new ConditionVariable();
+    final CountDownLatch timedOutLatch = new CountDownLatch(1);
 
     Thread thread =
         new Thread() {
@@ -590,12 +577,11 @@ public void run() {
               fail();
             } catch (HttpDataSourceException e) {
               // Expected.
-              assertTrue(e instanceof CronetDataSource.OpenException);
-              assertTrue(e.getCause() instanceof CronetDataSource.InterruptedIOException);
-              assertEquals(
-                  TEST_INVALID_CONNECTION_STATUS,
-                  ((CronetDataSource.OpenException) e).cronetConnectionStatus);
-              timedOutCondition.open();
+              assertThat(e instanceof CronetDataSource.OpenException).isTrue();
+              assertThat(e.getCause() instanceof CronetDataSource.InterruptedIOException).isTrue();
+              assertThat(((CronetDataSource.OpenException) e).cronetConnectionStatus)
+                  .isEqualTo(TEST_INVALID_CONNECTION_STATUS);
+              timedOutLatch.countDown();
             }
           }
         };
@@ -603,29 +589,29 @@ public void run() {
     startCondition.block();
 
     // We should still be trying to open.
-    assertFalse(timedOutCondition.block(50));
+    assertNotCountedDown(timedOutLatch);
     // We should still be trying to open as we approach the timeout.
-    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
-    assertFalse(timedOutCondition.block(50));
+    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
+    assertNotCountedDown(timedOutLatch);
     // Now we interrupt.
     thread.interrupt();
-    timedOutCondition.block();
+    timedOutLatch.await();
 
     verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
   }
 
   @Test
-  public void testConnectResponseBeforeTimeout() {
-    when(mockClock.elapsedRealtime()).thenReturn(0L);
+  public void testConnectResponseBeforeTimeout() throws InterruptedException {
+    long startTimeMs = SystemClock.elapsedRealtime();
     final ConditionVariable startCondition = buildUrlRequestStartedCondition();
-    final ConditionVariable openCondition = new ConditionVariable();
+    final CountDownLatch openLatch = new CountDownLatch(1);
 
     new Thread() {
       @Override
       public void run() {
         try {
           dataSourceUnderTest.open(testDataSpec);
-          openCondition.open();
+          openLatch.countDown();
         } catch (HttpDataSourceException e) {
           fail();
         }
@@ -634,20 +620,20 @@ public void run() {
     startCondition.block();
 
     // We should still be trying to open.
-    assertFalse(openCondition.block(50));
+    assertNotCountedDown(openLatch);
     // We should still be trying to open as we approach the timeout.
-    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
-    assertFalse(openCondition.block(50));
+    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
+    assertNotCountedDown(openLatch);
     // The response arrives just in time.
     dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
-    openCondition.block();
+    openLatch.await();
   }
 
   @Test
   public void testRedirectIncreasesConnectionTimeout() throws InterruptedException {
-    when(mockClock.elapsedRealtime()).thenReturn(0L);
+    long startTimeMs = SystemClock.elapsedRealtime();
     final ConditionVariable startCondition = buildUrlRequestStartedCondition();
-    final ConditionVariable timedOutCondition = new ConditionVariable();
+    final CountDownLatch timedOutLatch = new CountDownLatch(1);
     final AtomicInteger openExceptions = new AtomicInteger(0);
 
     new Thread() {
@@ -658,46 +644,42 @@ public void run() {
           fail();
         } catch (HttpDataSourceException e) {
           // Expected.
-          assertTrue(e instanceof CronetDataSource.OpenException);
-          assertTrue(e.getCause() instanceof SocketTimeoutException);
+          assertThat(e instanceof CronetDataSource.OpenException).isTrue();
+          assertThat(e.getCause() instanceof SocketTimeoutException).isTrue();
           openExceptions.getAndIncrement();
-          timedOutCondition.open();
+          timedOutLatch.countDown();
         }
       }
     }.start();
     startCondition.block();
 
     // We should still be trying to open.
-    assertFalse(timedOutCondition.block(50));
+    assertNotCountedDown(timedOutLatch);
     // We should still be trying to open as we approach the timeout.
-    when(mockClock.elapsedRealtime()).thenReturn((long) TEST_CONNECT_TIMEOUT_MS - 1);
-    assertFalse(timedOutCondition.block(50));
+    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + TEST_CONNECT_TIMEOUT_MS - 1);
+    assertNotCountedDown(timedOutLatch);
     // A redirect arrives just in time.
-    dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
-        "RandomRedirectedUrl1");
+    dataSourceUnderTest.onRedirectReceived(
+        mockUrlRequest, testUrlResponseInfo, "RandomRedirectedUrl1");
 
     long newTimeoutMs = 2 * TEST_CONNECT_TIMEOUT_MS - 1;
-    when(mockClock.elapsedRealtime()).thenReturn(newTimeoutMs - 1);
-    // Give the thread some time to run.
-    assertFalse(timedOutCondition.block(newTimeoutMs));
+    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + newTimeoutMs - 1);
     // We should still be trying to open as we approach the new timeout.
-    assertFalse(timedOutCondition.block(50));
+    assertNotCountedDown(timedOutLatch);
     // A redirect arrives just in time.
-    dataSourceUnderTest.onRedirectReceived(mockUrlRequest, testUrlResponseInfo,
-        "RandomRedirectedUrl2");
+    dataSourceUnderTest.onRedirectReceived(
+        mockUrlRequest, testUrlResponseInfo, "RandomRedirectedUrl2");
 
     newTimeoutMs = 3 * TEST_CONNECT_TIMEOUT_MS - 2;
-    when(mockClock.elapsedRealtime()).thenReturn(newTimeoutMs - 1);
-    // Give the thread some time to run.
-    assertFalse(timedOutCondition.block(newTimeoutMs));
+    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + newTimeoutMs - 1);
     // We should still be trying to open as we approach the new timeout.
-    assertFalse(timedOutCondition.block(50));
+    assertNotCountedDown(timedOutLatch);
     // Now we timeout.
-    when(mockClock.elapsedRealtime()).thenReturn(newTimeoutMs);
-    timedOutCondition.block();
+    ShadowSystemClock.setCurrentTimeMillis(startTimeMs + newTimeoutMs + 10);
+    timedOutLatch.await();
 
     verify(mockTransferListener, never()).onTransferStart(dataSourceUnderTest, testDataSpec);
-    assertEquals(1, openExceptions.get());
+    assertThat(openExceptions.get()).isEqualTo(1);
   }
 
   @Test
@@ -714,20 +696,22 @@ public void testRedirectParseAndAttachCookie_dataSourceDoesNotHandleSetCookie_fo
   }
 
   @Test
-  public void testRedirectParseAndAttachCookie_dataSourceHandlesSetCookie_andPreservesOriginalRequestHeaders()
-      throws HttpDataSourceException {
-    dataSourceUnderTest = spy(
-        new CronetDataSource(
-            mockCronetEngine,
-            mockExecutor,
-            mockContentTypePredicate,
-            mockTransferListener,
-            TEST_CONNECT_TIMEOUT_MS,
-            TEST_READ_TIMEOUT_MS,
-            true, // resetTimeoutOnRedirects
-            mockClock,
-            null,
-            true));
+  public void
+      testRedirectParseAndAttachCookie_dataSourceHandlesSetCookie_andPreservesOriginalRequestHeaders()
+          throws HttpDataSourceException {
+    dataSourceUnderTest =
+        spy(
+            new CronetDataSource(
+                mockCronetEngine,
+                mockExecutor,
+                mockContentTypePredicate,
+                mockTransferListener,
+                TEST_CONNECT_TIMEOUT_MS,
+                TEST_READ_TIMEOUT_MS,
+                true, // resetTimeoutOnRedirects
+                Clock.DEFAULT,
+                null,
+                true));
     dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
 
     mockSingleRedirectSuccess();
@@ -743,21 +727,23 @@ public void testRedirectParseAndAttachCookie_dataSourceHandlesSetCookie_andPrese
   }
 
   @Test
-  public void testRedirectParseAndAttachCookie_dataSourceHandlesSetCookie_andPreservesOriginalRequestHeadersIncludingByteRangeHeader()
-      throws HttpDataSourceException {
+  public void
+      testRedirectParseAndAttachCookie_dataSourceHandlesSetCookie_andPreservesOriginalRequestHeadersIncludingByteRangeHeader()
+          throws HttpDataSourceException {
     testDataSpec = new DataSpec(Uri.parse(TEST_URL), 1000, 5000, null);
-    dataSourceUnderTest = spy(
-        new CronetDataSource(
-            mockCronetEngine,
-            mockExecutor,
-            mockContentTypePredicate,
-            mockTransferListener,
-            TEST_CONNECT_TIMEOUT_MS,
-            TEST_READ_TIMEOUT_MS,
-            true, // resetTimeoutOnRedirects
-            mockClock,
-            null,
-            true));
+    dataSourceUnderTest =
+        spy(
+            new CronetDataSource(
+                mockCronetEngine,
+                mockExecutor,
+                mockContentTypePredicate,
+                mockTransferListener,
+                TEST_CONNECT_TIMEOUT_MS,
+                TEST_READ_TIMEOUT_MS,
+                true, // resetTimeoutOnRedirects
+                Clock.DEFAULT,
+                null,
+                true));
     dataSourceUnderTest.setRequestProperty("Content-Type", TEST_CONTENT_TYPE);
 
     mockSingleRedirectSuccess();
@@ -785,18 +771,19 @@ public void testRedirectNoSetCookieFollowsRedirect() throws HttpDataSourceExcept
   @Test
   public void testRedirectNoSetCookieFollowsRedirect_dataSourceHandlesSetCookie()
       throws HttpDataSourceException {
-    dataSourceUnderTest = spy(
-        new CronetDataSource(
-            mockCronetEngine,
-            mockExecutor,
-            mockContentTypePredicate,
-            mockTransferListener,
-            TEST_CONNECT_TIMEOUT_MS,
-            TEST_READ_TIMEOUT_MS,
-            true, // resetTimeoutOnRedirects
-            mockClock,
-            null,
-            true));
+    dataSourceUnderTest =
+        spy(
+            new CronetDataSource(
+                mockCronetEngine,
+                mockExecutor,
+                mockContentTypePredicate,
+                mockTransferListener,
+                TEST_CONNECT_TIMEOUT_MS,
+                TEST_READ_TIMEOUT_MS,
+                true, // resetTimeoutOnRedirects
+                Clock.DEFAULT,
+                null,
+                true));
     mockSingleRedirectSuccess();
     mockFollowRedirectSuccess();
 
@@ -811,8 +798,9 @@ public void testExceptionFromTransferListener() throws HttpDataSourceException {
 
     // Make mockTransferListener throw an exception in CronetDataSource.close(). Ensure that
     // the subsequent open() call succeeds.
-    doThrow(new NullPointerException()).when(mockTransferListener).onTransferEnd(
-        dataSourceUnderTest);
+    doThrow(new NullPointerException())
+        .when(mockTransferListener)
+        .onTransferEnd(dataSourceUnderTest);
     dataSourceUnderTest.open(testDataSpec);
     try {
       dataSourceUnderTest.close();
@@ -840,13 +828,12 @@ public void testReadFailure() throws HttpDataSourceException {
   }
 
   @Test
-  public void testReadInterrupted() throws HttpDataSourceException {
-    when(mockClock.elapsedRealtime()).thenReturn(0L);
+  public void testReadInterrupted() throws HttpDataSourceException, InterruptedException {
     mockResponseStartSuccess();
     dataSourceUnderTest.open(testDataSpec);
 
     final ConditionVariable startCondition = buildReadStartedCondition();
-    final ConditionVariable timedOutCondition = new ConditionVariable();
+    final CountDownLatch timedOutLatch = new CountDownLatch(1);
     byte[] returnedBuffer = new byte[8];
     Thread thread =
         new Thread() {
@@ -857,18 +844,18 @@ public void run() {
               fail();
             } catch (HttpDataSourceException e) {
               // Expected.
-              assertTrue(e.getCause() instanceof CronetDataSource.InterruptedIOException);
-              timedOutCondition.open();
+              assertThat(e.getCause() instanceof CronetDataSource.InterruptedIOException).isTrue();
+              timedOutLatch.countDown();
             }
           }
         };
     thread.start();
     startCondition.block();
 
-    assertFalse(timedOutCondition.block(50));
+    assertNotCountedDown(timedOutLatch);
     // Now we interrupt.
     thread.interrupt();
-    timedOutCondition.block();
+    timedOutLatch.await();
   }
 
   @Test
@@ -883,122 +870,135 @@ public void testAllowDirectExecutor() throws HttpDataSourceException {
   // Helper methods.
 
   private void mockStatusResponse() {
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        UrlRequest.StatusListener statusListener =
-            (UrlRequest.StatusListener) invocation.getArguments()[0];
-        statusListener.onStatus(TEST_CONNECTION_STATUS);
-        return null;
-      }
-    }).when(mockUrlRequest).getStatus(any(UrlRequest.StatusListener.class));
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                UrlRequest.StatusListener statusListener =
+                    (UrlRequest.StatusListener) invocation.getArguments()[0];
+                statusListener.onStatus(TEST_CONNECTION_STATUS);
+                return null;
+              }
+            })
+        .when(mockUrlRequest)
+        .getStatus(any(UrlRequest.StatusListener.class));
   }
 
   private void mockResponseStartSuccess() {
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        dataSourceUnderTest.onResponseStarted(
-            mockUrlRequest,
-            testUrlResponseInfo);
-        return null;
-      }
-    }).when(mockUrlRequest).start();
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
+                return null;
+              }
+            })
+        .when(mockUrlRequest)
+        .start();
   }
 
   private void mockResponseStartRedirect() {
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        dataSourceUnderTest.onRedirectReceived(
-            mockUrlRequest,
-            createUrlResponseInfo(307), // statusCode
-            "http://redirect.location.com");
-        return null;
-      }
-    }).when(mockUrlRequest).start();
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                dataSourceUnderTest.onRedirectReceived(
+                    mockUrlRequest,
+                    createUrlResponseInfo(307), // statusCode
+                    "http://redirect.location.com");
+                return null;
+              }
+            })
+        .when(mockUrlRequest)
+        .start();
   }
 
   private void mockSingleRedirectSuccess() {
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        if (!redirectCalled) {
-          redirectCalled = true;
-          dataSourceUnderTest.onRedirectReceived(
-              mockUrlRequest,
-              createUrlResponseInfoWithUrl("http://example.com/video", 300),
-              "http://example.com/video/redirect");
-        } else {
-          dataSourceUnderTest.onResponseStarted(
-              mockUrlRequest,
-              testUrlResponseInfo);
-        }
-        return null;
-      }
-    }).when(mockUrlRequest).start();
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                if (!redirectCalled) {
+                  redirectCalled = true;
+                  dataSourceUnderTest.onRedirectReceived(
+                      mockUrlRequest,
+                      createUrlResponseInfoWithUrl("http://example.com/video", 300),
+                      "http://example.com/video/redirect");
+                } else {
+                  dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
+                }
+                return null;
+              }
+            })
+        .when(mockUrlRequest)
+        .start();
   }
 
   private void mockFollowRedirectSuccess() {
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        dataSourceUnderTest.onResponseStarted(
-            mockUrlRequest,
-            testUrlResponseInfo);
-        return null;
-      }
-    }).when(mockUrlRequest).followRedirect();
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                dataSourceUnderTest.onResponseStarted(mockUrlRequest, testUrlResponseInfo);
+                return null;
+              }
+            })
+        .when(mockUrlRequest)
+        .followRedirect();
   }
 
   private void mockResponseStartFailure() {
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        dataSourceUnderTest.onFailed(
-            mockUrlRequest,
-            createUrlResponseInfo(500), // statusCode
-            mockNetworkException);
-        return null;
-      }
-    }).when(mockUrlRequest).start();
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                dataSourceUnderTest.onFailed(
+                    mockUrlRequest,
+                    createUrlResponseInfo(500), // statusCode
+                    mockNetworkException);
+                return null;
+              }
+            })
+        .when(mockUrlRequest)
+        .start();
   }
 
   private void mockReadSuccess(int position, int length) {
     final int[] positionAndRemaining = new int[] {position, length};
-    doAnswer(new Answer<Void>() {
-      @Override
-      public Void answer(InvocationOnMock invocation) throws Throwable {
-        if (positionAndRemaining[1] == 0) {
-          dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
-        } else {
-          ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
-          int readLength = Math.min(positionAndRemaining[1], inputBuffer.remaining());
-          inputBuffer.put(buildTestDataBuffer(positionAndRemaining[0], readLength));
-          positionAndRemaining[0] += readLength;
-          positionAndRemaining[1] -= readLength;
-          dataSourceUnderTest.onReadCompleted(
-              mockUrlRequest,
-              testUrlResponseInfo,
-              inputBuffer);
-        }
-        return null;
-      }
-    }).when(mockUrlRequest).read(any(ByteBuffer.class));
+    doAnswer(
+            new Answer<Void>() {
+              @Override
+              public Void answer(InvocationOnMock invocation) throws Throwable {
+                if (positionAndRemaining[1] == 0) {
+                  dataSourceUnderTest.onSucceeded(mockUrlRequest, testUrlResponseInfo);
+                } else {
+                  ByteBuffer inputBuffer = (ByteBuffer) invocation.getArguments()[0];
+                  int readLength = Math.min(positionAndRemaining[1], inputBuffer.remaining());
+                  inputBuffer.put(buildTestDataBuffer(positionAndRemaining[0], readLength));
+                  positionAndRemaining[0] += readLength;
+                  positionAndRemaining[1] -= readLength;
+                  dataSourceUnderTest.onReadCompleted(
+                      mockUrlRequest, testUrlResponseInfo, inputBuffer);
+                }
+                return null;
+              }
+            })
+        .when(mockUrlRequest)
+        .read(any(ByteBuffer.class));
   }
 
   private void mockReadFailure() {
     doAnswer(
-        new Answer<Object>() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            dataSourceUnderTest.onFailed(
-                mockUrlRequest,
-                createUrlResponseInfo(500), // statusCode
-                mockNetworkException);
-            return null;
-          }
-        })
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                dataSourceUnderTest.onFailed(
+                    mockUrlRequest,
+                    createUrlResponseInfo(500), // statusCode
+                    mockNetworkException);
+                return null;
+              }
+            })
         .when(mockUrlRequest)
         .read(any(ByteBuffer.class));
   }
@@ -1006,13 +1006,13 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
   private ConditionVariable buildReadStartedCondition() {
     final ConditionVariable startedCondition = new ConditionVariable();
     doAnswer(
-        new Answer<Object>() {
-          @Override
-          public Object answer(InvocationOnMock invocation) throws Throwable {
-            startedCondition.open();
-            return null;
-          }
-        })
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                startedCondition.open();
+                return null;
+              }
+            })
         .when(mockUrlRequest)
         .read(any(ByteBuffer.class));
     return startedCondition;
@@ -1020,16 +1020,26 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
 
   private ConditionVariable buildUrlRequestStartedCondition() {
     final ConditionVariable startedCondition = new ConditionVariable();
-    doAnswer(new Answer<Object>() {
-      @Override
-      public Object answer(InvocationOnMock invocation) throws Throwable {
-        startedCondition.open();
-        return null;
-      }
-    }).when(mockUrlRequest).start();
+    doAnswer(
+            new Answer<Object>() {
+              @Override
+              public Object answer(InvocationOnMock invocation) throws Throwable {
+                startedCondition.open();
+                return null;
+              }
+            })
+        .when(mockUrlRequest)
+        .start();
     return startedCondition;
   }
 
+  private void assertNotCountedDown(CountDownLatch countDownLatch) throws InterruptedException {
+    // We are asserting that another thread does not count down the latch. We therefore sleep some
+    // time to give the other thread the chance to fail this test.
+    Thread.sleep(50);
+    assertThat(countDownLatch.getCount()).isGreaterThan(0L);
+  }
+
   private static byte[] buildTestDataArray(int position, int length) {
     return buildTestDataBuffer(position, length).array();
   }
@@ -1052,5 +1062,4 @@ private static ByteBuffer buildTestDataBuffer(int position, int length) {
     testBuffer.flip();
     return testBuffer;
   }
-
 }
diff --git a/extensions/cronet/src/test/resources/robolectric.properties b/extensions/cronet/src/test/resources/robolectric.properties
new file mode 100644
index 0000000000..2f3210368e
--- /dev/null
+++ b/extensions/cronet/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+manifest=src/test/AndroidManifest.xml
diff --git a/extensions/ffmpeg/README.md b/extensions/ffmpeg/README.md
index b29c836887..fa7ac6b9fa 100644
--- a/extensions/ffmpeg/README.md
+++ b/extensions/ffmpeg/README.md
@@ -29,7 +29,8 @@ EXOPLAYER_ROOT="$(pwd)"
 FFMPEG_EXT_PATH="${EXOPLAYER_ROOT}/extensions/ffmpeg/src/main"
 ```
 
-* Download the [Android NDK][] and set its location in an environment variable:
+* Download the [Android NDK][] and set its location in an environment variable.
+  Only versions up to NDK 15c are supported currently.
 
 ```
 NDK_PATH="<path to Android NDK>"
diff --git a/extensions/ffmpeg/build.gradle b/extensions/ffmpeg/build.gradle
index 9820818f3e..e2d3a08e36 100644
--- a/extensions/ffmpeg/build.gradle
+++ b/extensions/ffmpeg/build.gradle
@@ -31,7 +31,7 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-core')
 }
 
 ext {
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
index ed8a5b0eac..3e23659bf8 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegAudioRenderer.java
@@ -21,6 +21,8 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
+import com.google.android.exoplayer2.audio.AudioSink;
+import com.google.android.exoplayer2.audio.DefaultAudioSink;
 import com.google.android.exoplayer2.audio.SimpleDecoderAudioRenderer;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.ExoMediaCrypto;
@@ -41,6 +43,8 @@
    */
   private static final int INITIAL_INPUT_BUFFER_SIZE = 960 * 6;
 
+  private final boolean enableFloatOutput;
+
   private FfmpegDecoder decoder;
 
   public FfmpegAudioRenderer() {
@@ -55,7 +59,23 @@ public FfmpegAudioRenderer() {
    */
   public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
       AudioProcessor... audioProcessors) {
-    super(eventHandler, eventListener, audioProcessors);
+    this(eventHandler, eventListener, new DefaultAudioSink(null, audioProcessors), false);
+  }
+
+  /**
+   * @param eventHandler A handler to use when delivering events to {@code eventListener}. May be
+   *     null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param audioSink The sink to which audio will be output.
+   * @param enableFloatOutput Whether to enable 32-bit float audio format, if supported on the
+   *     device/build and if the input format may have bit depth higher than 16-bit. When using
+   *     32-bit float output, any audio processing will be disabled, including playback speed/pitch
+   *     adjustment.
+   */
+  public FfmpegAudioRenderer(Handler eventHandler, AudioRendererEventListener eventListener,
+      AudioSink audioSink, boolean enableFloatOutput) {
+    super(eventHandler, eventListener, null, false, audioSink);
+    this.enableFloatOutput = enableFloatOutput;
   }
 
   @Override
@@ -64,7 +84,7 @@ protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessio
     String sampleMimeType = format.sampleMimeType;
     if (!FfmpegLibrary.isAvailable() || !MimeTypes.isAudio(sampleMimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
-    } else if (!FfmpegLibrary.supportsFormat(sampleMimeType)) {
+    } else if (!FfmpegLibrary.supportsFormat(sampleMimeType) || !isOutputSupported(format)) {
       return FORMAT_UNSUPPORTED_SUBTYPE;
     } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
@@ -82,7 +102,7 @@ public final int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
   protected FfmpegDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
       throws FfmpegDecoderException {
     decoder = new FfmpegDecoder(NUM_BUFFERS, NUM_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
-        format.sampleMimeType, format.initializationData);
+        format.sampleMimeType, format.initializationData, shouldUseFloatOutput(format));
     return decoder;
   }
 
@@ -90,8 +110,32 @@ protected FfmpegDecoder createDecoder(Format format, ExoMediaCrypto mediaCrypto)
   public Format getOutputFormat() {
     int channelCount = decoder.getChannelCount();
     int sampleRate = decoder.getSampleRate();
+    @C.PcmEncoding int encoding = decoder.getEncoding();
     return Format.createAudioSampleFormat(null, MimeTypes.AUDIO_RAW, null, Format.NO_VALUE,
-        Format.NO_VALUE, channelCount, sampleRate, C.ENCODING_PCM_16BIT, null, null, 0, null);
+        Format.NO_VALUE, channelCount, sampleRate, encoding, null, null, 0, null);
+  }
+
+  private boolean isOutputSupported(Format inputFormat) {
+    return shouldUseFloatOutput(inputFormat) || supportsOutputEncoding(C.ENCODING_PCM_16BIT);
+  }
+
+  private boolean shouldUseFloatOutput(Format inputFormat) {
+    if (!enableFloatOutput || !supportsOutputEncoding(C.ENCODING_PCM_FLOAT)) {
+      return false;
+    }
+    switch (inputFormat.sampleMimeType) {
+      case MimeTypes.AUDIO_RAW:
+        // For raw audio, output in 32-bit float encoding if the bit depth is > 16-bit.
+        return inputFormat.pcmEncoding == C.ENCODING_PCM_24BIT
+            || inputFormat.pcmEncoding == C.ENCODING_PCM_32BIT
+            || inputFormat.pcmEncoding == C.ENCODING_PCM_FLOAT;
+      case MimeTypes.AUDIO_AC3:
+        // AC-3 is always 16-bit, so there is no point outputting in 32-bit float encoding.
+        return false;
+      default:
+        // For all other formats, assume that it's worth using 32-bit float encoding.
+        return true;
+    }
   }
 
 }
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
index 2af2101ee7..91bd82ab2a 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.ffmpeg;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.decoder.SimpleDecoder;
 import com.google.android.exoplayer2.decoder.SimpleOutputBuffer;
@@ -29,11 +30,15 @@
 /* package */ final class FfmpegDecoder extends
     SimpleDecoder<DecoderInputBuffer, SimpleOutputBuffer, FfmpegDecoderException> {
 
-  // Space for 64 ms of 6 channel 48 kHz 16-bit PCM audio.
-  private static final int OUTPUT_BUFFER_SIZE = 1536 * 6 * 2 * 2;
+  // Space for 64 ms of 48 kHz 8 channel 16-bit PCM audio.
+  private static final int OUTPUT_BUFFER_SIZE_16BIT = 64 * 48  * 8 * 2;
+  // Space for 64 ms of 48 KhZ 8 channel 32-bit PCM audio.
+  private static final int OUTPUT_BUFFER_SIZE_32BIT = OUTPUT_BUFFER_SIZE_16BIT * 2;
 
   private final String codecName;
   private final byte[] extraData;
+  private final @C.Encoding int encoding;
+  private final int outputBufferSize;
 
   private long nativeContext; // May be reassigned on resetting the codec.
   private boolean hasOutputFormat;
@@ -41,14 +46,17 @@
   private volatile int sampleRate;
 
   public FfmpegDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize,
-      String mimeType, List<byte[]> initializationData) throws FfmpegDecoderException {
+      String mimeType, List<byte[]> initializationData, boolean outputFloat)
+      throws FfmpegDecoderException {
     super(new DecoderInputBuffer[numInputBuffers], new SimpleOutputBuffer[numOutputBuffers]);
     if (!FfmpegLibrary.isAvailable()) {
       throw new FfmpegDecoderException("Failed to load decoder native libraries.");
     }
     codecName = FfmpegLibrary.getCodecName(mimeType);
     extraData = getExtraData(mimeType, initializationData);
-    nativeContext = ffmpegInitialize(codecName, extraData);
+    encoding = outputFloat ? C.ENCODING_PCM_FLOAT : C.ENCODING_PCM_16BIT;
+    outputBufferSize = outputFloat ? OUTPUT_BUFFER_SIZE_32BIT : OUTPUT_BUFFER_SIZE_16BIT;
+    nativeContext = ffmpegInitialize(codecName, extraData, outputFloat);
     if (nativeContext == 0) {
       throw new FfmpegDecoderException("Initialization failed.");
     }
@@ -61,18 +69,23 @@ public String getName() {
   }
 
   @Override
-  public DecoderInputBuffer createInputBuffer() {
+  protected DecoderInputBuffer createInputBuffer() {
     return new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DIRECT);
   }
 
   @Override
-  public SimpleOutputBuffer createOutputBuffer() {
+  protected SimpleOutputBuffer createOutputBuffer() {
     return new SimpleOutputBuffer(this);
   }
 
   @Override
-  public FfmpegDecoderException decode(DecoderInputBuffer inputBuffer,
-      SimpleOutputBuffer outputBuffer, boolean reset) {
+  protected FfmpegDecoderException createUnexpectedDecodeException(Throwable error) {
+    return new FfmpegDecoderException("Unexpected decode error", error);
+  }
+
+  @Override
+  protected FfmpegDecoderException decode(
+      DecoderInputBuffer inputBuffer, SimpleOutputBuffer outputBuffer, boolean reset) {
     if (reset) {
       nativeContext = ffmpegReset(nativeContext, extraData);
       if (nativeContext == 0) {
@@ -81,8 +94,8 @@ public FfmpegDecoderException decode(DecoderInputBuffer inputBuffer,
     }
     ByteBuffer inputData = inputBuffer.data;
     int inputSize = inputData.limit();
-    ByteBuffer outputData = outputBuffer.init(inputBuffer.timeUs, OUTPUT_BUFFER_SIZE);
-    int result = ffmpegDecode(nativeContext, inputData, inputSize, outputData, OUTPUT_BUFFER_SIZE);
+    ByteBuffer outputData = outputBuffer.init(inputBuffer.timeUs, outputBufferSize);
+    int result = ffmpegDecode(nativeContext, inputData, inputSize, outputData, outputBufferSize);
     if (result < 0) {
       return new FfmpegDecoderException("Error decoding (see logcat). Code: " + result);
     }
@@ -124,6 +137,13 @@ public int getSampleRate() {
     return sampleRate;
   }
 
+  /**
+   * Returns the encoding of output audio.
+   */
+  public @C.Encoding int getEncoding() {
+    return encoding;
+  }
+
   /**
    * Returns FFmpeg-compatible codec-specific initialization data ("extra data"), or {@code null} if
    * not required.
@@ -153,7 +173,7 @@ public int getSampleRate() {
     }
   }
 
-  private native long ffmpegInitialize(String codecName, byte[] extraData);
+  private native long ffmpegInitialize(String codecName, byte[] extraData, boolean outputFloat);
   private native int ffmpegDecode(long context, ByteBuffer inputData, int inputSize,
       ByteBuffer outputData, int outputSize);
   private native int ffmpegGetChannelCount(long context);
diff --git a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoderException.java b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoderException.java
index b4cf327198..d6b5a62450 100644
--- a/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoderException.java
+++ b/extensions/ffmpeg/src/main/java/com/google/android/exoplayer2/ext/ffmpeg/FfmpegDecoderException.java
@@ -26,4 +26,7 @@
     super(message);
   }
 
+  /* package */ FfmpegDecoderException(String message, Throwable cause) {
+    super(message, cause);
+  }
 }
diff --git a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
index fa615f2ec1..d077c819ab 100644
--- a/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
+++ b/extensions/ffmpeg/src/main/jni/ffmpeg_jni.cc
@@ -57,8 +57,10 @@ extern "C" {
 
 #define ERROR_STRING_BUFFER_LENGTH 256
 
-// Request a format corresponding to AudioFormat.ENCODING_PCM_16BIT.
-static const AVSampleFormat OUTPUT_FORMAT = AV_SAMPLE_FMT_S16;
+// Output format corresponding to AudioFormat.ENCODING_PCM_16BIT.
+static const AVSampleFormat OUTPUT_FORMAT_PCM_16BIT = AV_SAMPLE_FMT_S16;
+// Output format corresponding to AudioFormat.ENCODING_PCM_FLOAT.
+static const AVSampleFormat OUTPUT_FORMAT_PCM_FLOAT = AV_SAMPLE_FMT_FLT;
 
 /**
  * Returns the AVCodec with the specified name, or NULL if it is not available.
@@ -71,7 +73,7 @@ AVCodec *getCodecByName(JNIEnv* env, jstring codecName);
  * Returns the created context.
  */
 AVCodecContext *createContext(JNIEnv *env, AVCodec *codec,
-                              jbyteArray extraData);
+                              jbyteArray extraData, jboolean outputFloat);
 
 /**
  * Decodes the packet into the output buffer, returning the number of bytes
@@ -107,13 +109,14 @@ LIBRARY_FUNC(jboolean, ffmpegHasDecoder, jstring codecName) {
   return getCodecByName(env, codecName) != NULL;
 }
 
-DECODER_FUNC(jlong, ffmpegInitialize, jstring codecName, jbyteArray extraData) {
+DECODER_FUNC(jlong, ffmpegInitialize, jstring codecName, jbyteArray extraData,
+    jboolean outputFloat) {
   AVCodec *codec = getCodecByName(env, codecName);
   if (!codec) {
     LOGE("Codec not found.");
     return 0L;
   }
-  return (jlong) createContext(env, codec, extraData);
+  return (jlong) createContext(env, codec, extraData, outputFloat);
 }
 
 DECODER_FUNC(jint, ffmpegDecode, jlong context, jobject inputData,
@@ -177,7 +180,8 @@ DECODER_FUNC(jlong, ffmpegReset, jlong jContext, jbyteArray extraData) {
       LOGE("Unexpected error finding codec %d.", codecId);
       return 0L;
     }
-    return (jlong) createContext(env, codec, extraData);
+    return (jlong) createContext(env, codec, extraData,
+        context->request_sample_fmt == OUTPUT_FORMAT_PCM_FLOAT);
   }
 
   avcodec_flush_buffers(context);
@@ -201,13 +205,14 @@ AVCodec *getCodecByName(JNIEnv* env, jstring codecName) {
 }
 
 AVCodecContext *createContext(JNIEnv *env, AVCodec *codec,
-                              jbyteArray extraData) {
+                              jbyteArray extraData, jboolean outputFloat) {
   AVCodecContext *context = avcodec_alloc_context3(codec);
   if (!context) {
     LOGE("Failed to allocate context.");
     return NULL;
   }
-  context->request_sample_fmt = OUTPUT_FORMAT;
+  context->request_sample_fmt =
+      outputFloat ? OUTPUT_FORMAT_PCM_FLOAT : OUTPUT_FORMAT_PCM_16BIT;
   if (extraData) {
     jsize size = env->GetArrayLength(extraData);
     context->extradata_size = size;
@@ -275,7 +280,9 @@ int decodePacket(AVCodecContext *context, AVPacket *packet,
       av_opt_set_int(resampleContext, "in_sample_rate", sampleRate, 0);
       av_opt_set_int(resampleContext, "out_sample_rate", sampleRate, 0);
       av_opt_set_int(resampleContext, "in_sample_fmt", sampleFormat, 0);
-      av_opt_set_int(resampleContext, "out_sample_fmt", OUTPUT_FORMAT, 0);
+      // The output format is always the requested format.
+      av_opt_set_int(resampleContext, "out_sample_fmt",
+          context->request_sample_fmt, 0);
       result = avresample_open(resampleContext);
       if (result < 0) {
         logError("avresample_open", result);
@@ -285,7 +292,7 @@ int decodePacket(AVCodecContext *context, AVPacket *packet,
       context->opaque = resampleContext;
     }
     int inSampleSize = av_get_bytes_per_sample(sampleFormat);
-    int outSampleSize = av_get_bytes_per_sample(OUTPUT_FORMAT);
+    int outSampleSize = av_get_bytes_per_sample(context->request_sample_fmt);
     int outSamples = avresample_get_out_samples(resampleContext, sampleCount);
     int bufferOutSize = outSampleSize * channelCount * outSamples;
     if (outSize + bufferOutSize > outputSize) {
diff --git a/extensions/flac/build.gradle b/extensions/flac/build.gradle
index 4d840d34ac..f617064ce5 100644
--- a/extensions/flac/build.gradle
+++ b/extensions/flac/build.gradle
@@ -31,8 +31,8 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    androidTestCompile project(modulePrefix + 'testutils')
+    implementation project(modulePrefix + 'library-core')
+    androidTestImplementation project(modulePrefix + 'testutils')
 }
 
 ext {
diff --git a/extensions/flac/src/androidTest/AndroidManifest.xml b/extensions/flac/src/androidTest/AndroidManifest.xml
index 8a7ad50429..38a6bfc927 100644
--- a/extensions/flac/src/androidTest/AndroidManifest.xml
+++ b/extensions/flac/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.ext.flac.test">
 
-  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="27"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/extensions/flac/src/androidTest/assets/bear.flac.0.dump b/extensions/flac/src/androidTest/assets/bear.flac.0.dump
index b03636f2bb..ad88981718 100644
--- a/extensions/flac/src/androidTest/assets/bear.flac.0.dump
+++ b/extensions/flac/src/androidTest/assets/bear.flac.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8880
+  getPosition(0) = [[timeUs=0, position=8880]]
 numberOfTracks = 1
 track 0:
   format:
@@ -9,7 +9,7 @@ track 0:
     id = null
     containerMimeType = null
     sampleMimeType = audio/raw
-    maxInputSize = -1
+    maxInputSize = 16384
     width = -1
     height = -1
     frameRate = -1.0
@@ -25,6 +25,7 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 526272
   sample count = 33
   sample 0:
     time = 0
diff --git a/extensions/flac/src/androidTest/assets/bear.flac.1.dump b/extensions/flac/src/androidTest/assets/bear.flac.1.dump
index 4e8388dba8..22f30e9db2 100644
--- a/extensions/flac/src/androidTest/assets/bear.flac.1.dump
+++ b/extensions/flac/src/androidTest/assets/bear.flac.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8880
+  getPosition(0) = [[timeUs=0, position=8880]]
 numberOfTracks = 1
 track 0:
   format:
@@ -9,7 +9,7 @@ track 0:
     id = null
     containerMimeType = null
     sampleMimeType = audio/raw
-    maxInputSize = -1
+    maxInputSize = 16384
     width = -1
     height = -1
     frameRate = -1.0
@@ -25,6 +25,7 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 362432
   sample count = 23
   sample 0:
     time = 853333
diff --git a/extensions/flac/src/androidTest/assets/bear.flac.2.dump b/extensions/flac/src/androidTest/assets/bear.flac.2.dump
index 0860c36cef..c52a74cbfb 100644
--- a/extensions/flac/src/androidTest/assets/bear.flac.2.dump
+++ b/extensions/flac/src/androidTest/assets/bear.flac.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8880
+  getPosition(0) = [[timeUs=0, position=8880]]
 numberOfTracks = 1
 track 0:
   format:
@@ -9,7 +9,7 @@ track 0:
     id = null
     containerMimeType = null
     sampleMimeType = audio/raw
-    maxInputSize = -1
+    maxInputSize = 16384
     width = -1
     height = -1
     frameRate = -1.0
@@ -25,6 +25,7 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 182208
   sample count = 12
   sample 0:
     time = 1792000
diff --git a/extensions/flac/src/androidTest/assets/bear.flac.3.dump b/extensions/flac/src/androidTest/assets/bear.flac.3.dump
index 6f7f72b806..760f369597 100644
--- a/extensions/flac/src/androidTest/assets/bear.flac.3.dump
+++ b/extensions/flac/src/androidTest/assets/bear.flac.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8880
+  getPosition(0) = [[timeUs=0, position=8880]]
 numberOfTracks = 1
 track 0:
   format:
@@ -9,7 +9,7 @@ track 0:
     id = null
     containerMimeType = null
     sampleMimeType = audio/raw
-    maxInputSize = -1
+    maxInputSize = 16384
     width = -1
     height = -1
     frameRate = -1.0
@@ -25,6 +25,7 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 18368
   sample count = 2
   sample 0:
     time = 2645333
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
index 7b193997c3..c5f1f5c146 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacExtractorTest.java
@@ -25,12 +25,23 @@
  */
 public class FlacExtractorTest extends InstrumentationTestCase {
 
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    if (!FlacLibrary.isAvailable()) {
+      fail("Flac library not available.");
+    }
+  }
+
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new FlacExtractor();
-      }
-    }, "bear.flac", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new FlacExtractor();
+          }
+        },
+        "bear.flac",
+        getInstrumentation().getContext());
   }
 }
diff --git a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
index 65fb4c8195..b236b706b8 100644
--- a/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
+++ b/extensions/flac/src/androidTest/java/com/google/android/exoplayer2/ext/flac/FlacPlaybackTest.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 
@@ -36,6 +37,14 @@
 
   private static final String BEAR_FLAC_URI = "asset:///bear-flac.mka";
 
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    if (!FlacLibrary.isAvailable()) {
+      fail("Flac library not available.");
+    }
+  }
+
   public void testBasicPlayback() throws ExoPlaybackException {
     playUri(BEAR_FLAC_URI);
   }
@@ -76,12 +85,11 @@ public void run() {
       DefaultTrackSelector trackSelector = new DefaultTrackSelector();
       player = ExoPlayerFactory.newInstance(new Renderer[] {audioRenderer}, trackSelector);
       player.addListener(this);
-      ExtractorMediaSource mediaSource = new ExtractorMediaSource(
-          uri,
-          new DefaultDataSourceFactory(context, "ExoPlayerExtFlacTest"),
-          MatroskaExtractor.FACTORY,
-          null,
-          null);
+      MediaSource mediaSource =
+          new ExtractorMediaSource.Factory(
+                  new DefaultDataSourceFactory(context, "ExoPlayerExtFlacTest"))
+              .setExtractorsFactory(MatroskaExtractor.FACTORY)
+              .createMediaSource(uri);
       player.prepare(mediaSource);
       player.setPlayWhenReady(true);
       Looper.loop();
@@ -100,7 +108,6 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
         Looper.myLooper().quit();
       }
     }
-
   }
 
 }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
index 3ecccd8246..15d294a35a 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoder.java
@@ -70,18 +70,23 @@ public String getName() {
   }
 
   @Override
-  public DecoderInputBuffer createInputBuffer() {
+  protected DecoderInputBuffer createInputBuffer() {
     return new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
   }
 
   @Override
-  public SimpleOutputBuffer createOutputBuffer() {
+  protected SimpleOutputBuffer createOutputBuffer() {
     return new SimpleOutputBuffer(this);
   }
 
   @Override
-  public FlacDecoderException decode(DecoderInputBuffer inputBuffer,
-      SimpleOutputBuffer outputBuffer, boolean reset) {
+  protected FlacDecoderException createUnexpectedDecodeException(Throwable error) {
+    return new FlacDecoderException("Unexpected decode error", error);
+  }
+
+  @Override
+  protected FlacDecoderException decode(
+      DecoderInputBuffer inputBuffer, SimpleOutputBuffer outputBuffer, boolean reset) {
     if (reset) {
       decoderJni.flush();
     }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderException.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderException.java
index 2bdff62935..95d7f87c05 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderException.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacDecoderException.java
@@ -26,4 +26,7 @@
     super(message);
   }
 
+  /* package */ FlacDecoderException(String message, Throwable cause) {
+    super(message, cause);
+  }
 }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
index a2f141a712..6859b44877 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/FlacExtractor.java
@@ -25,6 +25,7 @@
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.FlacStreamInfo;
 import com.google.android.exoplayer2.util.MimeTypes;
@@ -104,33 +105,18 @@ public int read(final ExtractorInput input, PositionHolder seekPosition)
       }
       metadataParsed = true;
 
-      extractorOutput.seekMap(new SeekMap() {
-        final boolean isSeekable = decoderJni.getSeekPosition(0) != -1;
-        final long durationUs = streamInfo.durationUs();
-
-        @Override
-        public boolean isSeekable() {
-          return isSeekable;
-        }
-
-        @Override
-        public long getPosition(long timeUs) {
-          return isSeekable ? decoderJni.getSeekPosition(timeUs) : 0;
-        }
-
-        @Override
-        public long getDurationUs() {
-          return durationUs;
-        }
-
-      });
+      boolean isSeekable = decoderJni.getSeekPosition(0) != -1;
+      extractorOutput.seekMap(
+          isSeekable
+              ? new FlacSeekMap(streamInfo.durationUs(), decoderJni)
+              : new SeekMap.Unseekable(streamInfo.durationUs(), 0));
       Format mediaFormat =
           Format.createAudioSampleFormat(
               null,
               MimeTypes.AUDIO_RAW,
               null,
               streamInfo.bitRate(),
-              Format.NO_VALUE,
+              streamInfo.maxDecodedFrameSize(),
               streamInfo.channels,
               streamInfo.sampleRate,
               getPcmEncoding(streamInfo.bitsPerSample),
@@ -184,4 +170,30 @@ public void release() {
     }
   }
 
+  private static final class FlacSeekMap implements SeekMap {
+
+    private final long durationUs;
+    private final FlacDecoderJni decoderJni;
+
+    public FlacSeekMap(long durationUs, FlacDecoderJni decoderJni) {
+      this.durationUs = durationUs;
+      this.decoderJni = decoderJni;
+    }
+
+    @Override
+    public boolean isSeekable() {
+      return true;
+    }
+
+    @Override
+    public SeekPoints getSeekPoints(long timeUs) {
+      // TODO: Access the seek table via JNI to return two seek points when appropriate.
+      return new SeekPoints(new SeekPoint(timeUs, decoderJni.getSeekPosition(timeUs)));
+    }
+
+    @Override
+    public long getDurationUs() {
+      return durationUs;
+    }
+  }
 }
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
index dc376d2ea4..a72b03cd44 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer2/ext/flac/LibflacAudioRenderer.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.ext.flac;
 
 import android.os.Handler;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.audio.AudioProcessor;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener;
@@ -52,6 +53,8 @@ protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessio
     if (!FlacLibrary.isAvailable()
         || !MimeTypes.AUDIO_FLAC.equalsIgnoreCase(format.sampleMimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
+    } else if (!supportsOutputEncoding(C.ENCODING_PCM_16BIT)) {
+      return FORMAT_UNSUPPORTED_SUBTYPE;
     } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
     } else {
diff --git a/extensions/flac/src/main/jni/flac_jni.cc b/extensions/flac/src/main/jni/flac_jni.cc
index c9e5d7ab36..59f37b0c2e 100644
--- a/extensions/flac/src/main/jni/flac_jni.cc
+++ b/extensions/flac/src/main/jni/flac_jni.cc
@@ -50,7 +50,8 @@ class JavaDataSource : public DataSource {
   ssize_t readAt(off64_t offset, void *const data, size_t size) {
     jobject byteBuffer = env->NewDirectByteBuffer(data, size);
     int result = env->CallIntMethod(flacDecoderJni, mid, byteBuffer);
-    if (env->ExceptionOccurred()) {
+    if (env->ExceptionCheck()) {
+      // Exception is thrown in Java when returning from the native call.
       result = -1;
     }
     env->DeleteLocalRef(byteBuffer);
diff --git a/extensions/flac/src/main/jni/include/data_source.h b/extensions/flac/src/main/jni/include/data_source.h
index 175431dd7a..88af3e1277 100644
--- a/extensions/flac/src/main/jni/include/data_source.h
+++ b/extensions/flac/src/main/jni/include/data_source.h
@@ -22,6 +22,7 @@
 
 class DataSource {
  public:
+  virtual ~DataSource() {}
   // Returns the number of bytes read, or -1 on failure. It's not an error if
   // this returns zero; it just means the given offset is equal to, or
   // beyond, the end of the source.
diff --git a/extensions/gvr/README.md b/extensions/gvr/README.md
index 250cf58c2f..5dab885436 100644
--- a/extensions/gvr/README.md
+++ b/extensions/gvr/README.md
@@ -12,10 +12,10 @@ of surround sound and ambisonic soundfields.
 The easiest way to use the extension is to add it as a gradle dependency:
 
 ```gradle
-compile 'com.google.android.exoplayer:extension-gvr:rX.X.X'
+implementation 'com.google.android.exoplayer:extension-gvr:2.X.X'
 ```
 
-where `rX.X.X` is the version, which must match the version of the ExoPlayer
+where `2.X.X` is the version, which must match the version of the ExoPlayer
 library being used.
 
 Alternatively, you can clone the ExoPlayer repository and depend on the module
diff --git a/extensions/gvr/build.gradle b/extensions/gvr/build.gradle
index 8236024512..f146ba4df6 100644
--- a/extensions/gvr/build.gradle
+++ b/extensions/gvr/build.gradle
@@ -25,8 +25,8 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile 'com.google.vr:sdk-audio:1.80.0'
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.google.vr:sdk-audio:1.80.0'
 }
 
 ext {
diff --git a/extensions/ima/README.md b/extensions/ima/README.md
index a796ca8694..c5ef1af35f 100644
--- a/extensions/ima/README.md
+++ b/extensions/ima/README.md
@@ -12,10 +12,10 @@ alongside content.
 The easiest way to use the extension is to add it as a gradle dependency:
 
 ```gradle
-compile 'com.google.android.exoplayer:extension-ima:rX.X.X'
+implementation 'com.google.android.exoplayer:extension-ima:2.X.X'
 ```
 
-where `rX.X.X` is the version, which must match the version of the ExoPlayer
+where `2.X.X` is the version, which must match the version of the ExoPlayer
 library being used.
 
 Alternatively, you can clone the ExoPlayer repository and depend on the module
diff --git a/extensions/ima/build.gradle b/extensions/ima/build.gradle
index 5038aaf5b9..3a20e378ae 100644
--- a/extensions/ima/build.gradle
+++ b/extensions/ima/build.gradle
@@ -26,7 +26,6 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
     // This dependency is necessary to force the supportLibraryVersion of
     // com.android.support:support-v4 to be used. Else an older version (25.2.0)
     // is included via:
@@ -34,14 +33,10 @@ dependencies {
     // |-- com.google.android.gms:play-services-ads-lite:11.4.2
     //   |-- com.google.android.gms:play-services-basement:11.4.2
     //     |-- com.android.support:support-v4:25.2.0
-    compile 'com.android.support:support-v4:' + supportLibraryVersion
-    compile 'com.google.ads.interactivemedia.v3:interactivemedia:3.7.4'
-    compile 'com.google.android.gms:play-services-ads:' + playServicesLibraryVersion
-    androidTestCompile project(modulePrefix + 'library')
-    androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
-    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
-    androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
-    androidTestCompile 'com.android.support.test:runner:' + testSupportLibraryVersion
+    api 'com.android.support:support-v4:' + supportLibraryVersion
+    api 'com.google.ads.interactivemedia.v3:interactivemedia:3.7.4'
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.google.android.gms:play-services-ads:' + playServicesLibraryVersion
 }
 
 ext {
diff --git a/extensions/ima/proguard-rules.txt b/extensions/ima/proguard-rules.txt
new file mode 100644
index 0000000000..feef3daf7a
--- /dev/null
+++ b/extensions/ima/proguard-rules.txt
@@ -0,0 +1,6 @@
+# Proguard rules specific to the IMA extension.
+
+-keep class com.google.ads.interactivemedia.** { *; }
+-keep interface com.google.ads.interactivemedia.** { *; }
+-keep class com.google.obf.** { *; }
+-keep interface com.google.obf.** { *; }
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
index 5b61db0264..8ab05c574d 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -19,11 +19,14 @@
 import android.net.Uri;
 import android.os.SystemClock;
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.view.ViewGroup;
 import android.webkit.WebView;
 import com.google.ads.interactivemedia.v3.api.Ad;
 import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
+import com.google.ads.interactivemedia.v3.api.AdError;
+import com.google.ads.interactivemedia.v3.api.AdError.AdErrorCode;
 import com.google.ads.interactivemedia.v3.api.AdErrorEvent;
 import com.google.ads.interactivemedia.v3.api.AdErrorEvent.AdErrorListener;
 import com.google.ads.interactivemedia.v3.api.AdEvent;
@@ -47,12 +50,17 @@
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ads.AdPlaybackState;
+import com.google.android.exoplayer2.source.ads.AdPlaybackState.AdState;
 import com.google.android.exoplayer2.source.ads.AdsLoader;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
@@ -66,6 +74,75 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.ima");
   }
 
+  /** Builder for {@link ImaAdsLoader}. */
+  public static final class Builder {
+
+    private final Context context;
+
+    private @Nullable ImaSdkSettings imaSdkSettings;
+    private long vastLoadTimeoutMs;
+
+    /**
+     * Creates a new builder for {@link ImaAdsLoader}.
+     *
+     * @param context The context;
+     */
+    public Builder(Context context) {
+      this.context = Assertions.checkNotNull(context);
+      vastLoadTimeoutMs = C.TIME_UNSET;
+    }
+
+    /**
+     * Sets the IMA SDK settings. The provided settings instance's player type and version fields
+     * may be overwritten.
+     *
+     * <p>If this method is not called the default settings will be used.
+     *
+     * @param imaSdkSettings The {@link ImaSdkSettings}.
+     * @return This builder, for convenience.
+     */
+    public Builder setImaSdkSettings(ImaSdkSettings imaSdkSettings) {
+      this.imaSdkSettings = Assertions.checkNotNull(imaSdkSettings);
+      return this;
+    }
+
+    /**
+     * Sets the VAST load timeout, in milliseconds.
+     *
+     * @param vastLoadTimeoutMs The VAST load timeout, in milliseconds.
+     * @return This builder, for convenience.
+     * @see AdsRequest#setVastLoadTimeout(float)
+     */
+    public Builder setVastLoadTimeoutMs(long vastLoadTimeoutMs) {
+      Assertions.checkArgument(vastLoadTimeoutMs >= 0);
+      this.vastLoadTimeoutMs = vastLoadTimeoutMs;
+      return this;
+    }
+
+    /**
+     * Returns a new {@link ImaAdsLoader} for the specified ad tag.
+     *
+     * @param adTagUri The URI of a compatible ad tag to load. See
+     *     https://developers.google.com/interactive-media-ads/docs/sdks/android/compatibility for
+     *     information on compatible ad tags.
+     * @return The new {@link ImaAdsLoader}.
+     */
+    public ImaAdsLoader buildForAdTag(Uri adTagUri) {
+      return new ImaAdsLoader(context, adTagUri, imaSdkSettings, null, vastLoadTimeoutMs);
+    }
+
+    /**
+     * Returns a new {@link ImaAdsLoader} with the specified sideloaded ads response.
+     *
+     * @param adsResponse The sideloaded VAST, VMAP, or ad rules response to be used instead of
+     *     making a request via an ad tag URL.
+     * @return The new {@link ImaAdsLoader}.
+     */
+    public ImaAdsLoader buildForAdsResponse(String adsResponse) {
+      return new ImaAdsLoader(context, null, imaSdkSettings, adsResponse, vastLoadTimeoutMs);
+    }
+  }
+
   private static final boolean DEBUG = false;
   private static final String TAG = "ImaAdsLoader";
 
@@ -77,12 +154,18 @@
   private static final String IMA_SDK_SETTINGS_PLAYER_TYPE = "google/exo.ext.ima";
   private static final String IMA_SDK_SETTINGS_PLAYER_VERSION = ExoPlayerLibraryInfo.VERSION;
 
+  /** The value used in {@link VideoProgressUpdate}s to indicate an unset duration. */
+  private static final long IMA_DURATION_UNSET = -1L;
+
   /**
    * Threshold before the end of content at which IMA is notified that content is complete if the
    * player buffers, in milliseconds.
    */
   private static final long END_OF_CONTENT_POSITION_THRESHOLD_MS = 5000;
 
+  /** The maximum duration before an ad break that IMA may start preloading the next ad. */
+  private static final long MAXIMUM_PRELOAD_DURATION_MS = 8000;
+
   /**
    * The "Skip ad" button rendered in the IMA WebView does not gain focus by default and cannot be
    * clicked via a keypress event. Workaround this issue by calling focus() on the HTML element in
@@ -91,9 +174,7 @@
   private static final String FOCUS_SKIP_BUTTON_WORKAROUND_JS = "javascript:"
       + "try{ document.getElementsByClassName(\"videoAdUiSkipButton\")[0].focus(); } catch (e) {}";
 
-  /**
-   * The state of ad playback based on IMA's calls to {@link #playAd()} and {@link #pauseAd()}.
-   */
+  /** The state of ad playback. */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({IMA_AD_STATE_NONE, IMA_AD_STATE_PLAYING, IMA_AD_STATE_PAUSED})
   private @interface ImaAdState {}
@@ -110,13 +191,17 @@
    */
   private static final int IMA_AD_STATE_PAUSED = 2;
 
-  private final Uri adTagUri;
+  private final @Nullable Uri adTagUri;
+  private final @Nullable String adsResponse;
+  private final long vastLoadTimeoutMs;
   private final Timeline.Period period;
   private final List<VideoAdPlayerCallback> adCallbacks;
   private final ImaSdkFactory imaSdkFactory;
   private final AdDisplayContainer adDisplayContainer;
   private final com.google.ads.interactivemedia.v3.api.AdsLoader adsLoader;
 
+  private Object pendingAdRequestContext;
+  private List<String> supportedMimeTypes;
   private EventListener eventListener;
   private Player player;
   private ViewGroup adUiViewGroup;
@@ -124,12 +209,16 @@
   private VideoProgressUpdate lastAdProgress;
 
   private AdsManager adsManager;
+  private AdErrorEvent pendingAdErrorEvent;
   private Timeline timeline;
   private long contentDurationMs;
+  private int podIndexOffset;
   private AdPlaybackState adPlaybackState;
 
   // Fields tracking IMA's state.
 
+  /** The expected ad group index that IMA should load next. */
+  private int expectedAdGroupIndex;
   /**
    * The index of the current ad group that IMA is loading.
    */
@@ -138,9 +227,7 @@
    * Whether IMA has sent an ad event to pause content since the last resume content event.
    */
   private boolean imaPausedContent;
-  /**
-   * The current ad playback state based on IMA's calls to {@link #playAd()} and {@link #stopAd()}.
-   */
+  /** The current ad playback state. */
   private @ImaAdState int imaAdState;
   /**
    * Whether {@link com.google.ads.interactivemedia.v3.api.AdsLoader#contentComplete()} has been
@@ -160,9 +247,13 @@
    */
   private int playingAdIndexInAdGroup;
   /**
-   * If a content period has finished but IMA has not yet sent an ad event with
-   * {@link AdEvent.AdEventType#CONTENT_PAUSE_REQUESTED}, stores the value of
-   * {@link SystemClock#elapsedRealtime()} when the content stopped playing. This can be used to
+   * Whether there's a pending ad preparation error which IMA needs to be notified of when it
+   * transitions from playing content to playing the ad.
+   */
+  private boolean shouldNotifyAdPrepareError;
+  /**
+   * If a content period has finished but IMA has not yet called {@link #playAd()}, stores the value
+   * of {@link SystemClock#elapsedRealtime()} when the content stopped playing. This can be used to
    * determine a fake, increasing content position. {@link C#TIME_UNSET} otherwise.
    */
   private long fakeContentProgressElapsedRealtimeMs;
@@ -179,21 +270,19 @@
    * Whether {@link #getContentProgress()} has sent {@link #pendingContentPositionMs} to IMA.
    */
   private boolean sentPendingContentPositionMs;
-  /**
-   * Whether {@link #release()} has been called.
-   */
-  private boolean released;
 
   /**
    * Creates a new IMA ads loader.
    *
+   * <p>If you need to customize the ad request, use {@link ImaAdsLoader.Builder} instead.
+   *
    * @param context The context.
    * @param adTagUri The {@link Uri} of an ad tag compatible with the Android IMA SDK. See
    *     https://developers.google.com/interactive-media-ads/docs/sdks/android/compatibility for
    *     more information.
    */
   public ImaAdsLoader(Context context, Uri adTagUri) {
-    this(context, adTagUri, null);
+    this(context, adTagUri, null, null, C.TIME_UNSET);
   }
 
   /**
@@ -205,9 +294,23 @@ public ImaAdsLoader(Context context, Uri adTagUri) {
    *     more information.
    * @param imaSdkSettings {@link ImaSdkSettings} used to configure the IMA SDK, or {@code null} to
    *     use the default settings. If set, the player type and version fields may be overwritten.
+   * @deprecated Use {@link ImaAdsLoader.Builder}.
    */
+  @Deprecated
   public ImaAdsLoader(Context context, Uri adTagUri, ImaSdkSettings imaSdkSettings) {
+    this(context, adTagUri, imaSdkSettings, null, C.TIME_UNSET);
+  }
+
+  private ImaAdsLoader(
+      Context context,
+      @Nullable Uri adTagUri,
+      @Nullable ImaSdkSettings imaSdkSettings,
+      @Nullable String adsResponse,
+      long vastLoadTimeoutMs) {
+    Assertions.checkArgument(adTagUri != null || adsResponse != null);
     this.adTagUri = adTagUri;
+    this.adsResponse = adsResponse;
+    this.vastLoadTimeoutMs = vastLoadTimeoutMs;
     period = new Timeline.Period();
     adCallbacks = new ArrayList<>(1);
     imaSdkFactory = ImaSdkFactory.getInstance();
@@ -236,8 +339,58 @@ public ImaAdsLoader(Context context, Uri adTagUri, ImaSdkSettings imaSdkSettings
     return adsLoader;
   }
 
+  /**
+   * Requests ads, if they have not already been requested. Must be called on the main thread.
+   *
+   * <p>Ads will be requested automatically when the player is prepared if this method has not been
+   * called, so it is only necessary to call this method if you want to request ads before preparing
+   * the player.
+   *
+   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   */
+  public void requestAds(ViewGroup adUiViewGroup) {
+    if (adPlaybackState != null || adsManager != null || pendingAdRequestContext != null) {
+      // Ads have already been requested.
+      return;
+    }
+    adDisplayContainer.setAdContainer(adUiViewGroup);
+    pendingAdRequestContext = new Object();
+    AdsRequest request = imaSdkFactory.createAdsRequest();
+    if (adTagUri != null) {
+      request.setAdTagUrl(adTagUri.toString());
+    } else /* adsResponse != null */ {
+      request.setAdsResponse(adsResponse);
+    }
+    if (vastLoadTimeoutMs != C.TIME_UNSET) {
+      request.setVastLoadTimeout(vastLoadTimeoutMs);
+    }
+    request.setAdDisplayContainer(adDisplayContainer);
+    request.setContentProgressProvider(this);
+    request.setUserRequestContext(pendingAdRequestContext);
+    adsLoader.requestAds(request);
+  }
+
   // AdsLoader implementation.
 
+  @Override
+  public void setSupportedContentTypes(@C.ContentType int... contentTypes) {
+    List<String> supportedMimeTypes = new ArrayList<>();
+    for (@C.ContentType int contentType : contentTypes) {
+      if (contentType == C.TYPE_DASH) {
+        supportedMimeTypes.add(MimeTypes.APPLICATION_MPD);
+      } else if (contentType == C.TYPE_HLS) {
+        supportedMimeTypes.add(MimeTypes.APPLICATION_M3U8);
+      } else if (contentType == C.TYPE_OTHER) {
+        supportedMimeTypes.addAll(Arrays.asList(
+            MimeTypes.VIDEO_MP4, MimeTypes.VIDEO_WEBM, MimeTypes.VIDEO_H263, MimeTypes.VIDEO_MPEG,
+            MimeTypes.AUDIO_MP4, MimeTypes.AUDIO_MPEG));
+      } else if (contentType == C.TYPE_SS) {
+        // IMA does not support Smooth Streaming ad media.
+      }
+    }
+    this.supportedMimeTypes = Collections.unmodifiableList(supportedMimeTypes);
+  }
+
   @Override
   public void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGroup adUiViewGroup) {
     this.player = player;
@@ -247,20 +400,28 @@ public void attachPlayer(ExoPlayer player, EventListener eventListener, ViewGrou
     lastContentProgress = null;
     adDisplayContainer.setAdContainer(adUiViewGroup);
     player.addListener(this);
+    maybeNotifyPendingAdLoadError();
     if (adPlaybackState != null) {
-      eventListener.onAdPlaybackState(adPlaybackState.copy());
+      // Pass the ad playback state to the player, and resume ads if necessary.
+      eventListener.onAdPlaybackState(adPlaybackState);
       if (imaPausedContent && player.getPlayWhenReady()) {
         adsManager.resume();
       }
+    } else if (adsManager != null) {
+      // Ads have loaded but the ads manager is not initialized.
+      startAdPlayback();
     } else {
-      requestAds();
+      // Ads haven't loaded yet, so request them.
+      requestAds(adUiViewGroup);
     }
   }
 
   @Override
   public void detachPlayer() {
     if (adsManager != null && imaPausedContent) {
-      adPlaybackState.setAdResumePositionUs(playingAd ? C.msToUs(player.getCurrentPosition()) : 0);
+      adPlaybackState =
+          adPlaybackState.withAdResumePositionUs(
+              playingAd ? C.msToUs(player.getCurrentPosition()) : 0);
       adsManager.pause();
     }
     lastAdProgress = getAdProgress();
@@ -273,42 +434,46 @@ public void detachPlayer() {
 
   @Override
   public void release() {
-    released = true;
+    pendingAdRequestContext = null;
     if (adsManager != null) {
       adsManager.destroy();
       adsManager = null;
     }
   }
 
+  @Override
+  public void handlePrepareError(int adGroupIndex, int adIndexInAdGroup, IOException exception) {
+    if (player == null) {
+      return;
+    }
+    try {
+      handleAdPrepareError(adGroupIndex, adIndexInAdGroup, exception);
+    } catch (Exception e) {
+      maybeNotifyInternalError("handlePrepareError", e);
+    }
+  }
+
   // com.google.ads.interactivemedia.v3.api.AdsLoader.AdsLoadedListener implementation.
 
   @Override
   public void onAdsManagerLoaded(AdsManagerLoadedEvent adsManagerLoadedEvent) {
     AdsManager adsManager = adsManagerLoadedEvent.getAdsManager();
-    if (released) {
+    if (!Util.areEqual(pendingAdRequestContext, adsManagerLoadedEvent.getUserRequestContext())) {
       adsManager.destroy();
       return;
     }
+    pendingAdRequestContext = null;
     this.adsManager = adsManager;
     adsManager.addAdErrorListener(this);
     adsManager.addAdEventListener(this);
-    if (ENABLE_PRELOADING) {
-      ImaSdkFactory imaSdkFactory = ImaSdkFactory.getInstance();
-      AdsRenderingSettings adsRenderingSettings = imaSdkFactory.createAdsRenderingSettings();
-      adsRenderingSettings.setEnablePreloading(true);
-      adsManager.init(adsRenderingSettings);
-      if (DEBUG) {
-        Log.d(TAG, "Initialized with preloading");
-      }
-    } else {
-      adsManager.init();
-      if (DEBUG) {
-        Log.d(TAG, "Initialized without preloading");
+    if (player != null) {
+      // If a player is attached already, start playback immediately.
+      try {
+        startAdPlayback();
+      } catch (Exception e) {
+        maybeNotifyInternalError("onAdsManagerLoaded", e);
       }
     }
-    long[] adGroupTimesUs = getAdGroupTimesUs(adsManager.getAdCuePoints());
-    adPlaybackState = new AdPlaybackState(adGroupTimesUs);
-    updateAdPlaybackState();
   }
 
   // AdEvent.AdEventListener implementation.
@@ -316,65 +481,17 @@ public void onAdsManagerLoaded(AdsManagerLoadedEvent adsManagerLoadedEvent) {
   @Override
   public void onAdEvent(AdEvent adEvent) {
     AdEventType adEventType = adEvent.getType();
-    boolean isLogAdEvent = adEventType == AdEventType.LOG;
-    if (DEBUG || isLogAdEvent) {
-      Log.w(TAG, "onAdEvent: " + adEventType);
-      if (isLogAdEvent) {
-        for (Map.Entry<String, String> entry : adEvent.getAdData().entrySet()) {
-          Log.w(TAG, "  " + entry.getKey() + ": " + entry.getValue());
-        }
-      }
+    if (DEBUG) {
+      Log.d(TAG, "onAdEvent: " + adEventType);
     }
     if (adsManager == null) {
       Log.w(TAG, "Dropping ad event after release: " + adEvent);
       return;
     }
-    Ad ad = adEvent.getAd();
-    switch (adEvent.getType()) {
-      case LOADED:
-        // The ad position is not always accurate when using preloading. See [Internal: b/62613240].
-        AdPodInfo adPodInfo = ad.getAdPodInfo();
-        int podIndex = adPodInfo.getPodIndex();
-        adGroupIndex = podIndex == -1 ? adPlaybackState.adGroupCount - 1 : podIndex;
-        int adPosition = adPodInfo.getAdPosition();
-        int adCountInAdGroup = adPodInfo.getTotalAds();
-        adsManager.start();
-        if (DEBUG) {
-          Log.d(TAG, "Loaded ad " + adPosition + " of " + adCountInAdGroup + " in ad group "
-              + adGroupIndex);
-        }
-        adPlaybackState.setAdCount(adGroupIndex, adCountInAdGroup);
-        updateAdPlaybackState();
-        break;
-      case CONTENT_PAUSE_REQUESTED:
-        // After CONTENT_PAUSE_REQUESTED, IMA will playAd/pauseAd/stopAd to show one or more ads
-        // before sending CONTENT_RESUME_REQUESTED.
-        imaPausedContent = true;
-        pauseContentInternal();
-        break;
-      case STARTED:
-        if (ad.isSkippable()) {
-          focusSkipButton();
-        }
-        break;
-      case TAPPED:
-        if (eventListener != null) {
-          eventListener.onAdTapped();
-        }
-        break;
-      case CLICKED:
-        if (eventListener != null) {
-          eventListener.onAdClicked();
-        }
-        break;
-      case CONTENT_RESUME_REQUESTED:
-        imaPausedContent = false;
-        resumeContentInternal();
-        break;
-      case ALL_ADS_COMPLETED:
-        // Do nothing. The ads manager will be released when the source is released.
-      default:
-        break;
+    try {
+      handleAdEvent(adEvent);
+    } catch (Exception e) {
+      maybeNotifyInternalError("onAdEvent", e);
     }
   }
 
@@ -382,17 +499,26 @@ public void onAdEvent(AdEvent adEvent) {
 
   @Override
   public void onAdError(AdErrorEvent adErrorEvent) {
+    AdError error = adErrorEvent.getError();
     if (DEBUG) {
-      Log.d(TAG, "onAdError " + adErrorEvent);
+      Log.d(TAG, "onAdError", error);
     }
     if (adsManager == null) {
-      adPlaybackState = new AdPlaybackState(new long[0]);
+      // No ads were loaded, so allow playback to start without any ads.
+      pendingAdRequestContext = null;
+      adPlaybackState = new AdPlaybackState();
       updateAdPlaybackState();
+    } else if (isAdGroupLoadError(error)) {
+      try {
+        handleAdGroupLoadError();
+      } catch (Exception e) {
+        maybeNotifyInternalError("onAdError", e);
+      }
     }
-    if (eventListener != null) {
-      IOException exception = new IOException("Ad error: " + adErrorEvent, adErrorEvent.getError());
-      eventListener.onLoadError(exception);
+    if (pendingAdErrorEvent == null) {
+      pendingAdErrorEvent = adErrorEvent;
     }
+    maybeNotifyPendingAdLoadError();
   }
 
   // ContentProgressProvider implementation.
@@ -401,18 +527,40 @@ public void onAdError(AdErrorEvent adErrorEvent) {
   public VideoProgressUpdate getContentProgress() {
     if (player == null) {
       return lastContentProgress;
-    } else if (pendingContentPositionMs != C.TIME_UNSET) {
+    }
+    boolean hasContentDuration = contentDurationMs != C.TIME_UNSET;
+    long contentPositionMs;
+    if (pendingContentPositionMs != C.TIME_UNSET) {
       sentPendingContentPositionMs = true;
-      return new VideoProgressUpdate(pendingContentPositionMs, contentDurationMs);
+      contentPositionMs = pendingContentPositionMs;
+      expectedAdGroupIndex =
+          adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
     } else if (fakeContentProgressElapsedRealtimeMs != C.TIME_UNSET) {
       long elapsedSinceEndMs = SystemClock.elapsedRealtime() - fakeContentProgressElapsedRealtimeMs;
-      long fakePositionMs = fakeContentProgressOffsetMs + elapsedSinceEndMs;
-      return new VideoProgressUpdate(fakePositionMs, contentDurationMs);
-    } else if (playingAd || contentDurationMs == C.TIME_UNSET) {
-      return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
+      contentPositionMs = fakeContentProgressOffsetMs + elapsedSinceEndMs;
+      expectedAdGroupIndex =
+          adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
+    } else if (imaAdState == IMA_AD_STATE_NONE && !playingAd && hasContentDuration) {
+      contentPositionMs = player.getCurrentPosition();
+      // Update the expected ad group index for the current content position. The update is delayed
+      // until MAXIMUM_PRELOAD_DURATION_MS before the ad so that an ad group load error delivered
+      // just after an ad group isn't incorrectly attributed to the next ad group.
+      int nextAdGroupIndex =
+          adPlaybackState.getAdGroupIndexAfterPositionUs(C.msToUs(contentPositionMs));
+      if (nextAdGroupIndex != expectedAdGroupIndex && nextAdGroupIndex != C.INDEX_UNSET) {
+        long nextAdGroupTimeMs = C.usToMs(adPlaybackState.adGroupTimesUs[nextAdGroupIndex]);
+        if (nextAdGroupTimeMs == C.TIME_END_OF_SOURCE) {
+          nextAdGroupTimeMs = contentDurationMs;
+        }
+        if (nextAdGroupTimeMs - contentPositionMs < MAXIMUM_PRELOAD_DURATION_MS) {
+          expectedAdGroupIndex = nextAdGroupIndex;
+        }
+      }
     } else {
-      return new VideoProgressUpdate(player.getCurrentPosition(), contentDurationMs);
+      return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
     }
+    long contentDurationMs = hasContentDuration ? this.contentDurationMs : IMA_DURATION_UNSET;
+    return new VideoProgressUpdate(contentPositionMs, contentDurationMs);
   }
 
   // VideoAdPlayer implementation.
@@ -421,22 +569,40 @@ public VideoProgressUpdate getContentProgress() {
   public VideoProgressUpdate getAdProgress() {
     if (player == null) {
       return lastAdProgress;
-    } else if (!playingAd) {
-      return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
-    } else {
+    } else if (imaAdState != IMA_AD_STATE_NONE && playingAd) {
       long adDuration = player.getDuration();
       return adDuration == C.TIME_UNSET ? VideoProgressUpdate.VIDEO_TIME_NOT_READY
           : new VideoProgressUpdate(player.getCurrentPosition(), adDuration);
+    } else {
+      return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
     }
   }
 
   @Override
   public void loadAd(String adUriString) {
+    if (adGroupIndex == C.INDEX_UNSET) {
+      Log.w(
+          TAG,
+          "Unexpected loadAd without LOADED event; assuming ad group index is actually "
+              + expectedAdGroupIndex);
+      adGroupIndex = expectedAdGroupIndex;
+      adsManager.start();
+    }
     if (DEBUG) {
       Log.d(TAG, "loadAd in ad group " + adGroupIndex);
     }
-    adPlaybackState.addAdUri(adGroupIndex, Uri.parse(adUriString));
-    updateAdPlaybackState();
+    try {
+      int adIndexInAdGroup = getAdIndexInAdGroupToLoad(adGroupIndex);
+      if (adIndexInAdGroup == C.INDEX_UNSET) {
+        Log.w(TAG, "Unexpected loadAd in an ad group with no remaining unavailable ads");
+        return;
+      }
+      adPlaybackState =
+          adPlaybackState.withAdUri(adGroupIndex, adIndexInAdGroup, Uri.parse(adUriString));
+      updateAdPlaybackState();
+    } catch (Exception e) {
+      maybeNotifyInternalError("loadAd", e);
+    }
   }
 
   @Override
@@ -461,10 +627,19 @@ public void playAd() {
         Log.w(TAG, "Unexpected playAd without stopAd");
         break;
       case IMA_AD_STATE_NONE:
+        // IMA is requesting to play the ad, so stop faking the content position.
+        fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
+        fakeContentProgressOffsetMs = C.TIME_UNSET;
         imaAdState = IMA_AD_STATE_PLAYING;
         for (int i = 0; i < adCallbacks.size(); i++) {
           adCallbacks.get(i).onPlay();
         }
+        if (shouldNotifyAdPrepareError) {
+          shouldNotifyAdPrepareError = false;
+          for (int i = 0; i < adCallbacks.size(); i++) {
+            adCallbacks.get(i).onError();
+          }
+        }
         break;
       case IMA_AD_STATE_PAUSED:
         imaAdState = IMA_AD_STATE_PLAYING;
@@ -496,7 +671,11 @@ public void stopAd() {
       Log.w(TAG, "Unexpected stopAd");
       return;
     }
-    stopAdInternal();
+    try {
+      stopAdInternal();
+    } catch (Exception e) {
+      maybeNotifyInternalError("stopAd", e);
+    }
   }
 
   @Override
@@ -517,15 +696,16 @@ public void pauseAd() {
   @Override
   public void resumeAd() {
     // This method is never called. See [Internal: b/18931719].
-    throw new IllegalStateException();
+    maybeNotifyInternalError("resumeAd", new IllegalStateException("Unexpected call to resumeAd"));
   }
 
   // Player.EventListener implementation.
 
   @Override
-  public void onTimelineChanged(Timeline timeline, Object manifest) {
-    if (timeline.isEmpty()) {
-      // The player is being re-prepared and this source will be released.
+  public void onTimelineChanged(Timeline timeline, Object manifest,
+      @Player.TimelineChangeReason int reason) {
+    if (reason == Player.TIMELINE_CHANGE_REASON_RESET) {
+      // The player is being reset and this source will be released.
       return;
     }
     Assertions.checkArgument(timeline.getPeriodCount() == 1);
@@ -533,7 +713,7 @@ public void onTimelineChanged(Timeline timeline, Object manifest) {
     long contentDurationUs = timeline.getPeriod(0, period).durationUs;
     contentDurationMs = C.usToMs(contentDurationUs);
     if (contentDurationUs != C.TIME_UNSET) {
-      adPlaybackState.contentDurationUs = contentDurationUs;
+      adPlaybackState = adPlaybackState.withContentDurationUs(contentDurationUs);
     }
     updateImaStateForPlayerState();
   }
@@ -563,12 +743,15 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
       for (int i = 0; i < adCallbacks.size(); i++) {
         adCallbacks.get(i).onEnded();
       }
+      if (DEBUG) {
+        Log.d(TAG, "VideoAdPlayerCallback.onEnded in onPlayerStateChanged");
+      }
     }
   }
 
   @Override
   public void onPlayerError(ExoPlaybackException error) {
-    if (playingAd) {
+    if (imaAdState != IMA_AD_STATE_NONE) {
       for (int i = 0; i < adCallbacks.size(); i++) {
         adCallbacks.get(i).onError();
       }
@@ -585,16 +768,20 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
       if (sentContentComplete) {
         for (int i = 0; i < adPlaybackState.adGroupCount; i++) {
           if (adPlaybackState.adGroupTimesUs[i] != C.TIME_END_OF_SOURCE) {
-            adPlaybackState.playedAdGroup(i);
+            adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
           }
         }
         updateAdPlaybackState();
       } else {
         long positionMs = player.getCurrentPosition();
         timeline.getPeriod(0, period);
-        if (period.getAdGroupIndexForPositionUs(C.msToUs(positionMs)) != C.INDEX_UNSET) {
+        int newAdGroupIndex = period.getAdGroupIndexForPositionUs(C.msToUs(positionMs));
+        if (newAdGroupIndex != C.INDEX_UNSET) {
           sentPendingContentPositionMs = false;
           pendingContentPositionMs = positionMs;
+          if (newAdGroupIndex != adGroupIndex) {
+            shouldNotifyAdPrepareError = false;
+          }
         }
       }
     } else {
@@ -604,30 +791,146 @@ public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
 
   // Internal methods.
 
-  private void requestAds() {
-    AdsRequest request = imaSdkFactory.createAdsRequest();
-    request.setAdTagUrl(adTagUri.toString());
-    request.setAdDisplayContainer(adDisplayContainer);
-    request.setContentProgressProvider(this);
-    adsLoader.requestAds(request);
+  private void startAdPlayback() {
+    ImaSdkFactory imaSdkFactory = ImaSdkFactory.getInstance();
+    AdsRenderingSettings adsRenderingSettings = imaSdkFactory.createAdsRenderingSettings();
+    adsRenderingSettings.setEnablePreloading(ENABLE_PRELOADING);
+    adsRenderingSettings.setMimeTypes(supportedMimeTypes);
+
+    // Set up the ad playback state, skipping ads based on the start position as required.
+    long[] adGroupTimesUs = getAdGroupTimesUs(adsManager.getAdCuePoints());
+    adPlaybackState = new AdPlaybackState(adGroupTimesUs);
+    long contentPositionMs = player.getCurrentPosition();
+    int adGroupIndexForPosition =
+        adPlaybackState.getAdGroupIndexForPositionUs(C.msToUs(contentPositionMs));
+    if (adGroupIndexForPosition == 0) {
+      podIndexOffset = 0;
+    } else if (adGroupIndexForPosition == C.INDEX_UNSET) {
+      // There is no preroll and midroll pod indices start at 1.
+      podIndexOffset = -1;
+    } else /* adGroupIndexForPosition > 0 */ {
+      // Skip ad groups before the one at or immediately before the playback position.
+      for (int i = 0; i < adGroupIndexForPosition; i++) {
+        adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
+      }
+      // Play ads after the midpoint between the ad to play and the one before it, to avoid issues
+      // with rounding one of the two ad times.
+      long adGroupForPositionTimeUs = adGroupTimesUs[adGroupIndexForPosition];
+      long adGroupBeforeTimeUs = adGroupTimesUs[adGroupIndexForPosition - 1];
+      double midpointTimeUs = (adGroupForPositionTimeUs + adGroupBeforeTimeUs) / 2d;
+      adsRenderingSettings.setPlayAdsAfterTime(midpointTimeUs / C.MICROS_PER_SECOND);
+
+      // We're removing one or more ads, which means that the earliest ad (if any) will be a
+      // midroll/postroll. Midroll pod indices start at 1.
+      podIndexOffset = adGroupIndexForPosition - 1;
+    }
+
+    if (adGroupIndexForPosition != C.INDEX_UNSET && hasMidrollAdGroups(adGroupTimesUs)) {
+      // Provide the player's initial position to trigger loading and playing the ad.
+      pendingContentPositionMs = contentPositionMs;
+    }
+
+    // Start ad playback.
+    adsManager.init(adsRenderingSettings);
+    updateAdPlaybackState();
+    if (DEBUG) {
+      Log.d(TAG, "Initialized with ads rendering settings: " + adsRenderingSettings);
+    }
+  }
+
+  private void handleAdEvent(AdEvent adEvent) {
+    Ad ad = adEvent.getAd();
+    switch (adEvent.getType()) {
+      case LOADED:
+        // The ad position is not always accurate when using preloading. See [Internal: b/62613240].
+        AdPodInfo adPodInfo = ad.getAdPodInfo();
+        int podIndex = adPodInfo.getPodIndex();
+        adGroupIndex =
+            podIndex == -1 ? (adPlaybackState.adGroupCount - 1) : (podIndex + podIndexOffset);
+        int adPosition = adPodInfo.getAdPosition();
+        int adCount = adPodInfo.getTotalAds();
+        adsManager.start();
+        if (DEBUG) {
+          Log.d(TAG, "Loaded ad " + adPosition + " of " + adCount + " in group " + adGroupIndex);
+        }
+        int oldAdCount = adPlaybackState.adGroups[adGroupIndex].count;
+        if (adCount != oldAdCount) {
+          if (oldAdCount == C.LENGTH_UNSET) {
+            adPlaybackState = adPlaybackState.withAdCount(adGroupIndex, adCount);
+            updateAdPlaybackState();
+          } else {
+            // IMA sometimes unexpectedly decreases the ad count in an ad group.
+            Log.w(TAG, "Unexpected ad count in LOADED, " + adCount + ", expected " + oldAdCount);
+          }
+        }
+        if (adGroupIndex != expectedAdGroupIndex) {
+          Log.w(
+              TAG,
+              "Expected ad group index "
+                  + expectedAdGroupIndex
+                  + ", actual ad group index "
+                  + adGroupIndex);
+          expectedAdGroupIndex = adGroupIndex;
+        }
+        break;
+      case CONTENT_PAUSE_REQUESTED:
+        // After CONTENT_PAUSE_REQUESTED, IMA will playAd/pauseAd/stopAd to show one or more ads
+        // before sending CONTENT_RESUME_REQUESTED.
+        imaPausedContent = true;
+        pauseContentInternal();
+        break;
+      case STARTED:
+        if (ad.isSkippable()) {
+          focusSkipButton();
+        }
+        break;
+      case TAPPED:
+        if (eventListener != null) {
+          eventListener.onAdTapped();
+        }
+        break;
+      case CLICKED:
+        if (eventListener != null) {
+          eventListener.onAdClicked();
+        }
+        break;
+      case CONTENT_RESUME_REQUESTED:
+        imaPausedContent = false;
+        resumeContentInternal();
+        break;
+      case LOG:
+        Map<String, String> adData = adEvent.getAdData();
+        Log.i(TAG, "Log AdEvent: " + adData);
+        if ("adLoadError".equals(adData.get("type"))) {
+          handleAdGroupLoadError();
+        }
+        break;
+      case ALL_ADS_COMPLETED:
+      default:
+        break;
+    }
   }
 
   private void updateImaStateForPlayerState() {
     boolean wasPlayingAd = playingAd;
+    int oldPlayingAdIndexInAdGroup = playingAdIndexInAdGroup;
     playingAd = player.isPlayingAd();
+    playingAdIndexInAdGroup = playingAd ? player.getCurrentAdIndexInAdGroup() : C.INDEX_UNSET;
     if (!sentContentComplete) {
-      boolean adFinished = (wasPlayingAd && !playingAd)
-          || playingAdIndexInAdGroup != player.getCurrentAdIndexInAdGroup();
+      boolean adFinished = wasPlayingAd && playingAdIndexInAdGroup != oldPlayingAdIndexInAdGroup;
       if (adFinished) {
         // IMA is waiting for the ad playback to finish so invoke the callback now.
         // Either CONTENT_RESUME_REQUESTED will be passed next, or playAd will be called again.
         for (int i = 0; i < adCallbacks.size(); i++) {
           adCallbacks.get(i).onEnded();
         }
+        if (DEBUG) {
+          Log.d(TAG, "VideoAdPlayerCallback.onEnded in onTimelineChanged/onPositionDiscontinuity");
+        }
       }
-      if (!wasPlayingAd && playingAd) {
+      if (!wasPlayingAd && playingAd && imaAdState == IMA_AD_STATE_NONE) {
         int adGroupIndex = player.getCurrentAdGroupIndex();
-        // IMA hasn't sent CONTENT_PAUSE_REQUESTED yet, so fake the content position.
+        // IMA hasn't called playAd yet, so fake the content position.
         fakeContentProgressElapsedRealtimeMs = SystemClock.elapsedRealtime();
         fakeContentProgressOffsetMs = C.usToMs(adPlaybackState.adGroupTimesUs[adGroupIndex]);
         if (fakeContentProgressOffsetMs == C.TIME_END_OF_SOURCE) {
@@ -635,7 +938,6 @@ private void updateImaStateForPlayerState() {
         }
       }
     }
-    playingAdIndexInAdGroup = playingAd ? player.getCurrentAdIndexInAdGroup() : C.INDEX_UNSET;
   }
 
   private void resumeContentInternal() {
@@ -645,8 +947,8 @@ private void resumeContentInternal() {
         Log.d(TAG, "Unexpected CONTENT_RESUME_REQUESTED without stopAd");
       }
     }
-    if (playingAd && adGroupIndex != C.INDEX_UNSET) {
-      adPlaybackState.playedAdGroup(adGroupIndex);
+    if (adGroupIndex != C.INDEX_UNSET) {
+      adPlaybackState = adPlaybackState.withSkippedAdGroup(adGroupIndex);
       adGroupIndex = C.INDEX_UNSET;
       updateAdPlaybackState();
     }
@@ -658,21 +960,76 @@ private void pauseContentInternal() {
       pendingContentPositionMs = C.TIME_UNSET;
       sentPendingContentPositionMs = false;
     }
-    // IMA is requesting to pause content, so stop faking the content position.
-    fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
-    fakeContentProgressOffsetMs = C.TIME_UNSET;
   }
 
   private void stopAdInternal() {
-    Assertions.checkState(imaAdState != IMA_AD_STATE_NONE);
     imaAdState = IMA_AD_STATE_NONE;
-    adPlaybackState.playedAd(adGroupIndex);
+    int adIndexInAdGroup = adPlaybackState.adGroups[adGroupIndex].getFirstAdIndexToPlay();
+    // TODO: Handle the skipped event so the ad can be marked as skipped rather than played.
+    adPlaybackState =
+        adPlaybackState.withPlayedAd(adGroupIndex, adIndexInAdGroup).withAdResumePositionUs(0);
     updateAdPlaybackState();
     if (!playingAd) {
       adGroupIndex = C.INDEX_UNSET;
     }
   }
 
+  private void handleAdGroupLoadError() {
+    int adGroupIndex =
+        this.adGroupIndex == C.INDEX_UNSET ? expectedAdGroupIndex : this.adGroupIndex;
+    if (adGroupIndex == C.INDEX_UNSET) {
+      // Drop the error, as we don't know which ad group it relates to.
+      return;
+    }
+    AdPlaybackState.AdGroup adGroup = adPlaybackState.adGroups[adGroupIndex];
+    if (adGroup.count == C.LENGTH_UNSET) {
+      adPlaybackState =
+          adPlaybackState.withAdCount(adGroupIndex, Math.max(1, adGroup.states.length));
+      adGroup = adPlaybackState.adGroups[adGroupIndex];
+    }
+    for (int i = 0; i < adGroup.count; i++) {
+      if (adGroup.states[i] == AdPlaybackState.AD_STATE_UNAVAILABLE) {
+        if (DEBUG) {
+          Log.d(TAG, "Removing ad " + i + " in ad group " + adGroupIndex);
+        }
+        adPlaybackState = adPlaybackState.withAdLoadError(adGroupIndex, i);
+      }
+    }
+    updateAdPlaybackState();
+  }
+
+  private void handleAdPrepareError(int adGroupIndex, int adIndexInAdGroup, Exception exception) {
+    if (DEBUG) {
+      Log.d(
+          TAG, "Prepare error for ad " + adIndexInAdGroup + " in group " + adGroupIndex, exception);
+    }
+    if (imaAdState == IMA_AD_STATE_NONE) {
+      // Send IMA a content position at the ad group so that it will try to play it, at which point
+      // we can notify that it failed to load.
+      fakeContentProgressElapsedRealtimeMs = SystemClock.elapsedRealtime();
+      fakeContentProgressOffsetMs = C.usToMs(adPlaybackState.adGroupTimesUs[adGroupIndex]);
+      if (fakeContentProgressOffsetMs == C.TIME_END_OF_SOURCE) {
+        fakeContentProgressOffsetMs = contentDurationMs;
+      }
+      shouldNotifyAdPrepareError = true;
+    } else {
+      // We're already playing an ad.
+      if (adIndexInAdGroup > playingAdIndexInAdGroup) {
+        // Mark the playing ad as ended so we can notify the error on the next ad and remove it,
+        // which means that the ad after will load (if any).
+        for (int i = 0; i < adCallbacks.size(); i++) {
+          adCallbacks.get(i).onEnded();
+        }
+      }
+      playingAdIndexInAdGroup = adPlaybackState.adGroups[adGroupIndex].getFirstAdIndexToPlay();
+      for (int i = 0; i < adCallbacks.size(); i++) {
+        adCallbacks.get(i).onError();
+      }
+    }
+    adPlaybackState = adPlaybackState.withAdLoadError(adGroupIndex, adIndexInAdGroup);
+    updateAdPlaybackState();
+  }
+
   private void checkForContentComplete() {
     if (contentDurationMs != C.TIME_UNSET && pendingContentPositionMs == C.TIME_UNSET
         && player.getContentPosition() + END_OF_CONTENT_POSITION_THRESHOLD_MS >= contentDurationMs
@@ -688,7 +1045,7 @@ private void checkForContentComplete() {
   private void updateAdPlaybackState() {
     // Ignore updates while detached. When a player is attached it will receive the latest state.
     if (eventListener != null) {
-      eventListener.onAdPlaybackState(adPlaybackState.copy());
+      eventListener.onAdPlaybackState(adPlaybackState);
     }
   }
 
@@ -701,6 +1058,48 @@ private void focusSkipButton() {
     }
   }
 
+  /**
+   * Returns the next ad index in the specified ad group to load, or {@link C#INDEX_UNSET} if all
+   * ads in the ad group have loaded.
+   */
+  private int getAdIndexInAdGroupToLoad(int adGroupIndex) {
+    @AdState int[] states = adPlaybackState.adGroups[adGroupIndex].states;
+    int adIndexInAdGroup = 0;
+    // IMA loads ads in order.
+    while (adIndexInAdGroup < states.length
+        && states[adIndexInAdGroup] != AdPlaybackState.AD_STATE_UNAVAILABLE) {
+      adIndexInAdGroup++;
+    }
+    return adIndexInAdGroup == states.length ? C.INDEX_UNSET : adIndexInAdGroup;
+  }
+
+  private void maybeNotifyPendingAdLoadError() {
+    if (pendingAdErrorEvent != null) {
+      if (eventListener != null) {
+        eventListener.onAdLoadError(
+            new IOException("Ad error: " + pendingAdErrorEvent, pendingAdErrorEvent.getError()));
+      }
+      pendingAdErrorEvent = null;
+    }
+  }
+
+  private void maybeNotifyInternalError(String name, Exception cause) {
+    String message = "Internal error in " + name;
+    Log.e(TAG, message, cause);
+    if (eventListener != null) {
+      eventListener.onInternalAdLoadError(new RuntimeException(message, cause));
+    }
+    // We can't recover from an unexpected error in general, so skip all remaining ads.
+    if (adPlaybackState == null) {
+      adPlaybackState = new AdPlaybackState();
+    } else {
+      for (int i = 0; i < adPlaybackState.adGroupCount; i++) {
+        adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
+      }
+    }
+    updateAdPlaybackState();
+  }
+
   private static long[] getAdGroupTimesUs(List<Float> cuePoints) {
     if (cuePoints.isEmpty()) {
       // If no cue points are specified, there is a preroll ad.
@@ -709,12 +1108,35 @@ private void focusSkipButton() {
 
     int count = cuePoints.size();
     long[] adGroupTimesUs = new long[count];
+    int adGroupIndex = 0;
     for (int i = 0; i < count; i++) {
       double cuePoint = cuePoints.get(i);
-      adGroupTimesUs[i] =
-          cuePoint == -1.0 ? C.TIME_END_OF_SOURCE : (long) (C.MICROS_PER_SECOND * cuePoint);
+      if (cuePoint == -1.0) {
+        adGroupTimesUs[count - 1] = C.TIME_END_OF_SOURCE;
+      } else {
+        adGroupTimesUs[adGroupIndex++] = (long) (C.MICROS_PER_SECOND * cuePoint);
+      }
     }
+    // Cue points may be out of order, so sort them.
+    Arrays.sort(adGroupTimesUs, 0, adGroupIndex);
     return adGroupTimesUs;
   }
 
+  private static boolean isAdGroupLoadError(AdError adError) {
+    // TODO: Find out what other errors need to be handled (if any), and whether each one relates to
+    // a single ad, ad group or the whole timeline.
+    return adError.getErrorCode() == AdErrorCode.VAST_LINEAR_ASSET_MISMATCH;
+  }
+
+  private static boolean hasMidrollAdGroups(long[] adGroupTimesUs) {
+    int count = adGroupTimesUs.length;
+    if (count == 1) {
+      return adGroupTimesUs[0] != 0 && adGroupTimesUs[0] != C.TIME_END_OF_SOURCE;
+    } else if (count == 2) {
+      return adGroupTimesUs[0] != 0 || adGroupTimesUs[1] != C.TIME_END_OF_SOURCE;
+    } else {
+      // There's at least one midroll ad group, as adGroupTimesUs is never empty.
+      return true;
+    }
+  }
 }
diff --git a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
index 02aa4807a5..1899c815da 100644
--- a/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
+++ b/extensions/ima/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsMediaSource.java
@@ -52,8 +52,8 @@ public ImaAdsMediaSource(MediaSource contentMediaSource, DataSource.Factory data
   }
 
   /**
-   * Constructs a new source that inserts ads linearly with the content specified by
-   * {@code contentMediaSource}.
+   * Constructs a new source that inserts ads linearly with the content specified by {@code
+   * contentMediaSource}.
    *
    * @param contentMediaSource The {@link MediaSource} providing the content to play.
    * @param dataSourceFactory Factory for data sources used to load ad media.
@@ -62,23 +62,30 @@ public ImaAdsMediaSource(MediaSource contentMediaSource, DataSource.Factory data
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public ImaAdsMediaSource(MediaSource contentMediaSource, DataSource.Factory dataSourceFactory,
-      ImaAdsLoader imaAdsLoader, ViewGroup adUiViewGroup, @Nullable Handler eventHandler,
-      @Nullable AdsMediaSource.AdsListener eventListener) {
+  public ImaAdsMediaSource(
+      MediaSource contentMediaSource,
+      DataSource.Factory dataSourceFactory,
+      ImaAdsLoader imaAdsLoader,
+      ViewGroup adUiViewGroup,
+      @Nullable Handler eventHandler,
+      @Nullable AdsMediaSource.EventListener eventListener) {
     adsMediaSource = new AdsMediaSource(contentMediaSource, dataSourceFactory, imaAdsLoader,
         adUiViewGroup, eventHandler, eventListener);
   }
 
   @Override
-  public void prepareSource(final ExoPlayer player, boolean isTopLevelSource,
-      final Listener listener) {
-    adsMediaSource.prepareSource(player, false, new Listener() {
-      @Override
-      public void onSourceInfoRefreshed(MediaSource source, Timeline timeline,
-          @Nullable Object manifest) {
-        listener.onSourceInfoRefreshed(ImaAdsMediaSource.this, timeline, manifest);
-      }
-    });
+  public void prepareSource(
+      final ExoPlayer player, boolean isTopLevelSource, final Listener listener) {
+    adsMediaSource.prepareSource(
+        player,
+        isTopLevelSource,
+        new Listener() {
+          @Override
+          public void onSourceInfoRefreshed(
+              MediaSource source, Timeline timeline, @Nullable Object manifest) {
+            listener.onSourceInfoRefreshed(ImaAdsMediaSource.this, timeline, manifest);
+          }
+        });
   }
 
   @Override
@@ -100,5 +107,4 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
   public void releaseSource() {
     adsMediaSource.releaseSource();
   }
-
 }
diff --git a/extensions/ima/src/main/proguard-rules.txt b/extensions/ima/src/main/proguard-rules.txt
new file mode 100644
index 0000000000..feef3daf7a
--- /dev/null
+++ b/extensions/ima/src/main/proguard-rules.txt
@@ -0,0 +1,6 @@
+# Proguard rules specific to the IMA extension.
+
+-keep class com.google.ads.interactivemedia.** { *; }
+-keep interface com.google.ads.interactivemedia.** { *; }
+-keep class com.google.obf.** { *; }
+-keep interface com.google.obf.** { *; }
diff --git a/extensions/leanback/README.md b/extensions/leanback/README.md
index 1fa71c9a8c..4eba6552e1 100644
--- a/extensions/leanback/README.md
+++ b/extensions/leanback/README.md
@@ -11,10 +11,10 @@ ExoPlayer.
 The easiest way to use the extension is to add it as a gradle dependency:
 
 ```gradle
-compile 'com.google.android.exoplayer:extension-leanback:rX.X.X'
+implementation 'com.google.android.exoplayer:extension-leanback:2.X.X'
 ```
 
-where `rX.X.X` is the version, which must match the version of the ExoPlayer
+where `2.X.X` is the version, which must match the version of the ExoPlayer
 library being used.
 
 Alternatively, you can clone the ExoPlayer repository and depend on the module
diff --git a/extensions/leanback/build.gradle b/extensions/leanback/build.gradle
index 715e2e56d7..dc187a5709 100644
--- a/extensions/leanback/build.gradle
+++ b/extensions/leanback/build.gradle
@@ -25,12 +25,12 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile('com.android.support:leanback-v17:' + supportLibraryVersion)
+    implementation project(modulePrefix + 'library-core')
+    implementation('com.android.support:leanback-v17:' + supportLibraryVersion)
 }
 
 ext {
-    javadocTitle = 'Leanback extension for Exoplayer library'
+    javadocTitle = 'Leanback extension'
 }
 apply from: '../../javadoc_library.gradle'
 
diff --git a/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
index 510ed9cf4f..e513084974 100644
--- a/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
+++ b/extensions/leanback/src/main/java/com/google/android/exoplayer2/ext/leanback/LeanbackPlayerAdapter.java
@@ -30,15 +30,15 @@
 import com.google.android.exoplayer2.DefaultControlDispatcher;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.PlaybackPreparer;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Player.DiscontinuityReason;
-import com.google.android.exoplayer2.SimpleExoPlayer;
+import com.google.android.exoplayer2.Player.TimelineChangeReason;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.util.ErrorMessageProvider;
+import com.google.android.exoplayer2.video.VideoListener;
 
-/**
- * Leanback {@code PlayerAdapter} implementation for {@link SimpleExoPlayer}.
- */
+/** Leanback {@code PlayerAdapter} implementation for {@link Player}. */
 public final class LeanbackPlayerAdapter extends PlayerAdapter {
 
   static {
@@ -46,11 +46,12 @@
   }
 
   private final Context context;
-  private final SimpleExoPlayer player;
+  private final Player player;
   private final Handler handler;
   private final ComponentListener componentListener;
   private final Runnable updateProgressRunnable;
 
+  private @Nullable PlaybackPreparer playbackPreparer;
   private ControlDispatcher controlDispatcher;
   private ErrorMessageProvider<? super ExoPlaybackException> errorMessageProvider;
   private SurfaceHolderGlueHost surfaceHolderGlueHost;
@@ -59,14 +60,14 @@
 
   /**
    * Builds an instance. Note that the {@code PlayerAdapter} does not manage the lifecycle of the
-   * {@link SimpleExoPlayer} instance. The caller remains responsible for releasing the player when
-   * it's no longer required.
+   * {@link Player} instance. The caller remains responsible for releasing the player when it's no
+   * longer required.
    *
    * @param context The current context (activity).
    * @param player Instance of your exoplayer that needs to be configured.
    * @param updatePeriodMs The delay between player control updates, in milliseconds.
    */
-  public LeanbackPlayerAdapter(Context context, SimpleExoPlayer player, final int updatePeriodMs) {
+  public LeanbackPlayerAdapter(Context context, Player player, final int updatePeriodMs) {
     this.context = context;
     this.player = player;
     handler = new Handler();
@@ -83,6 +84,15 @@ public void run() {
     };
   }
 
+  /**
+   * Sets the {@link PlaybackPreparer}.
+   *
+   * @param playbackPreparer The {@link PlaybackPreparer}.
+   */
+  public void setPlaybackPreparer(@Nullable PlaybackPreparer playbackPreparer) {
+    this.playbackPreparer = playbackPreparer;
+  }
+
   /**
    * Sets the {@link ControlDispatcher}.
    *
@@ -114,13 +124,19 @@ public void onAttachedToHost(PlaybackGlueHost host) {
     }
     notifyStateChanged();
     player.addListener(componentListener);
-    player.addVideoListener(componentListener);
+    Player.VideoComponent videoComponent = player.getVideoComponent();
+    if (videoComponent != null) {
+      videoComponent.addVideoListener(componentListener);
+    }
   }
 
   @Override
   public void onDetachedFromHost() {
     player.removeListener(componentListener);
-    player.removeVideoListener(componentListener);
+    Player.VideoComponent videoComponent = player.getVideoComponent();
+    if (videoComponent != null) {
+      videoComponent.removeVideoListener(componentListener);
+    }
     if (surfaceHolderGlueHost != null) {
       surfaceHolderGlueHost.setSurfaceHolderCallback(null);
       surfaceHolderGlueHost = null;
@@ -160,7 +176,11 @@ public long getCurrentPosition() {
 
   @Override
   public void play() {
-    if (player.getPlaybackState() == Player.STATE_ENDED) {
+    if (player.getPlaybackState() == Player.STATE_IDLE) {
+      if (playbackPreparer != null) {
+        playbackPreparer.preparePlayback();
+      }
+    } else if (player.getPlaybackState() == Player.STATE_ENDED) {
       controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
     }
     if (controlDispatcher.dispatchSetPlayWhenReady(player, true)) {
@@ -195,7 +215,10 @@ public boolean isPrepared() {
 
   /* package */ void setVideoSurface(Surface surface) {
     hasSurface = surface != null;
-    player.setVideoSurface(surface);
+    Player.VideoComponent videoComponent = player.getVideoComponent();
+    if (videoComponent != null) {
+      videoComponent.setVideoSurface(surface);
+    }
     maybeNotifyPreparedStateChanged(getCallback());
   }
 
@@ -218,8 +241,8 @@ private void maybeNotifyPreparedStateChanged(Callback callback) {
     }
   }
 
-  private final class ComponentListener extends Player.DefaultEventListener implements
-      SimpleExoPlayer.VideoListener, SurfaceHolder.Callback {
+  private final class ComponentListener extends Player.DefaultEventListener
+      implements SurfaceHolder.Callback, VideoListener {
 
     // SurfaceHolder.Callback implementation.
 
@@ -258,7 +281,8 @@ public void onPlayerError(ExoPlaybackException exception) {
     }
 
     @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest) {
+    public void onTimelineChanged(Timeline timeline, Object manifest,
+        @TimelineChangeReason int reason) {
       Callback callback = getCallback();
       callback.onDurationChanged(LeanbackPlayerAdapter.this);
       callback.onCurrentPositionChanged(LeanbackPlayerAdapter.this);
@@ -272,11 +296,11 @@ public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
       callback.onBufferedPositionChanged(LeanbackPlayerAdapter.this);
     }
 
-    // SimpleExoplayerView.Callback implementation.
+    // VideoListener implementation.
 
     @Override
-    public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-        float pixelWidthHeightRatio) {
+    public void onVideoSizeChanged(
+        int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
       getCallback().onVideoSizeChanged(LeanbackPlayerAdapter.this, width, height);
     }
 
diff --git a/extensions/mediasession/README.md b/extensions/mediasession/README.md
index 3278e8dba5..bd6b59c0c1 100644
--- a/extensions/mediasession/README.md
+++ b/extensions/mediasession/README.md
@@ -12,10 +12,10 @@ behaviour can be extended to support other playback and custom actions.
 The easiest way to use the extension is to add it as a gradle dependency:
 
 ```gradle
-compile 'com.google.android.exoplayer:extension-mediasession:rX.X.X'
+implementation 'com.google.android.exoplayer:extension-mediasession:2.X.X'
 ```
 
-where `rX.X.X` is the version, which must match the version of the ExoPlayer
+where `2.X.X` is the version, which must match the version of the ExoPlayer
 library being used.
 
 Alternatively, you can clone the ExoPlayer repository and depend on the module
diff --git a/extensions/mediasession/build.gradle b/extensions/mediasession/build.gradle
index 651bd952f8..eaaf078b5c 100644
--- a/extensions/mediasession/build.gradle
+++ b/extensions/mediasession/build.gradle
@@ -25,8 +25,8 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile 'com.android.support:support-media-compat:' + supportLibraryVersion
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.android.support:support-media-compat:' + supportLibraryVersion
 }
 
 ext {
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
index 1eb3ffd13d..ce597b45cd 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/DefaultPlaybackController.java
@@ -77,11 +77,10 @@ public DefaultPlaybackController(long rewindIncrementMs, long fastForwardIncreme
   public long getSupportedPlaybackActions(Player player) {
     if (player == null || player.getCurrentTimeline().isEmpty()) {
       return 0;
+    } else if (!player.isCurrentWindowSeekable()) {
+      return BASE_ACTIONS;
     }
-    long actions = BASE_ACTIONS;
-    if (player.isCurrentWindowSeekable()) {
-      actions |= PlaybackStateCompat.ACTION_SEEK_TO;
-    }
+    long actions = BASE_ACTIONS | PlaybackStateCompat.ACTION_SEEK_TO;
     if (fastForwardIncrementMs > 0) {
       actions |= PlaybackStateCompat.ACTION_FAST_FORWARD;
     }
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
index aa007ea1d6..544644d03b 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.ext.mediasession;
 
+import android.graphics.Bitmap;
 import android.net.Uri;
 import android.os.Bundle;
 import android.os.Handler;
@@ -104,23 +105,24 @@
    */
   public interface PlaybackPreparer extends CommandReceiver {
 
-    long ACTIONS = PlaybackStateCompat.ACTION_PREPARE
-        | PlaybackStateCompat.ACTION_PREPARE_FROM_MEDIA_ID
-        | PlaybackStateCompat.ACTION_PREPARE_FROM_SEARCH
-        | PlaybackStateCompat.ACTION_PREPARE_FROM_URI
-        | PlaybackStateCompat.ACTION_PLAY_FROM_MEDIA_ID
-        | PlaybackStateCompat.ACTION_PLAY_FROM_SEARCH
-        | PlaybackStateCompat.ACTION_PLAY_FROM_URI;
+    long ACTIONS =
+        PlaybackStateCompat.ACTION_PREPARE
+            | PlaybackStateCompat.ACTION_PREPARE_FROM_MEDIA_ID
+            | PlaybackStateCompat.ACTION_PREPARE_FROM_SEARCH
+            | PlaybackStateCompat.ACTION_PREPARE_FROM_URI
+            | PlaybackStateCompat.ACTION_PLAY_FROM_MEDIA_ID
+            | PlaybackStateCompat.ACTION_PLAY_FROM_SEARCH
+            | PlaybackStateCompat.ACTION_PLAY_FROM_URI;
 
     /**
      * Returns the actions which are supported by the preparer. The supported actions must be a
-     * bitmask combined out of {@link PlaybackStateCompat#ACTION_PREPARE},
-     * {@link PlaybackStateCompat#ACTION_PREPARE_FROM_MEDIA_ID},
-     * {@link PlaybackStateCompat#ACTION_PREPARE_FROM_SEARCH},
-     * {@link PlaybackStateCompat#ACTION_PREPARE_FROM_URI},
-     * {@link PlaybackStateCompat#ACTION_PLAY_FROM_MEDIA_ID},
-     * {@link PlaybackStateCompat#ACTION_PLAY_FROM_SEARCH} and
-     * {@link PlaybackStateCompat#ACTION_PLAY_FROM_URI}.
+     * bitmask combined out of {@link PlaybackStateCompat#ACTION_PREPARE}, {@link
+     * PlaybackStateCompat#ACTION_PREPARE_FROM_MEDIA_ID}, {@link
+     * PlaybackStateCompat#ACTION_PREPARE_FROM_SEARCH}, {@link
+     * PlaybackStateCompat#ACTION_PREPARE_FROM_URI}, {@link
+     * PlaybackStateCompat#ACTION_PLAY_FROM_MEDIA_ID}, {@link
+     * PlaybackStateCompat#ACTION_PLAY_FROM_SEARCH} and {@link
+     * PlaybackStateCompat#ACTION_PLAY_FROM_URI}.
      *
      * @return The bitmask of the supported media actions.
      */
@@ -263,15 +265,6 @@
    */
   public interface QueueEditor extends CommandReceiver {
 
-    long ACTIONS = PlaybackStateCompat.ACTION_SET_RATING;
-
-    /**
-     * Returns {@link PlaybackStateCompat#ACTION_SET_RATING} or {@code 0}. The Media API does
-     * not declare action constants for adding and removing queue items.
-     *
-     * @param player The {@link Player}.
-     */
-    long getSupportedQueueEditorActions(@Nullable Player player);
     /**
      * See {@link MediaSessionCompat.Callback#onAddQueueItem(MediaDescriptionCompat description)}.
      */
@@ -290,9 +283,14 @@
      * See {@link MediaSessionCompat.Callback#onRemoveQueueItemAt(int index)}.
      */
     void onRemoveQueueItemAt(Player player, int index);
-    /**
-     * See {@link MediaSessionCompat.Callback#onSetRating(RatingCompat)}.
-     */
+  }
+
+  /** Callback receiving a user rating for the active media item. */
+  public interface RatingCallback extends CommandReceiver {
+
+    long ACTIONS = PlaybackStateCompat.ACTION_SET_RATING;
+
+    /** See {@link MediaSessionCompat.Callback#onSetRating(RatingCompat)}. */
     void onSetRating(Player player, RatingCompat rating);
   }
 
@@ -330,6 +328,7 @@
   private final ExoPlayerEventListener exoPlayerEventListener;
   private final MediaSessionCallback mediaSessionCallback;
   private final PlaybackController playbackController;
+  private final String metadataExtrasPrefix;
   private final Map<String, CommandReceiver> commandMap;
 
   private Player player;
@@ -339,6 +338,7 @@
   private PlaybackPreparer playbackPreparer;
   private QueueNavigator queueNavigator;
   private QueueEditor queueEditor;
+  private RatingCallback ratingCallback;
   private ExoPlaybackException playbackException;
 
   /**
@@ -356,15 +356,15 @@ public MediaSessionConnector(MediaSessionCompat mediaSession) {
   /**
    * Creates an instance. Must be called on the same thread that is used to construct the player
    * instances passed to {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}.
-   * <p>
-   * Equivalent to {@code MediaSessionConnector(mediaSession, playbackController, true)}.
+   *
+   * <p>Equivalent to {@code MediaSessionConnector(mediaSession, playbackController, true, null)}.
    *
    * @param mediaSession The {@link MediaSessionCompat} to connect to.
    * @param playbackController A {@link PlaybackController} for handling playback actions.
    */
-  public MediaSessionConnector(MediaSessionCompat mediaSession,
-      PlaybackController playbackController) {
-    this(mediaSession, playbackController, true);
+  public MediaSessionConnector(
+      MediaSessionCompat mediaSession, PlaybackController playbackController) {
+    this(mediaSession, playbackController, true, null);
   }
 
   /**
@@ -372,17 +372,23 @@ public MediaSessionConnector(MediaSessionCompat mediaSession,
    * instances passed to {@link #setPlayer(Player, PlaybackPreparer, CustomActionProvider...)}.
    *
    * @param mediaSession The {@link MediaSessionCompat} to connect to.
-   * @param playbackController A {@link PlaybackController} for handling playback actions, or
-   *     {@code null} if the connector should handle playback actions directly.
+   * @param playbackController A {@link PlaybackController} for handling playback actions, or {@code
+   *     null} if the connector should handle playback actions directly.
    * @param doMaintainMetadata Whether the connector should maintain the metadata of the session. If
    *     {@code false}, you need to maintain the metadata of the media session yourself (provide at
    *     least the duration to allow clients to show a progress bar).
+   * @param metadataExtrasPrefix A string to prefix extra keys which are propagated from the active
+   *     queue item to the session metadata.
    */
-  public MediaSessionConnector(MediaSessionCompat mediaSession,
-      PlaybackController playbackController, boolean doMaintainMetadata) {
+  public MediaSessionConnector(
+      MediaSessionCompat mediaSession,
+      PlaybackController playbackController,
+      boolean doMaintainMetadata,
+      @Nullable String metadataExtrasPrefix) {
     this.mediaSession = mediaSession;
     this.playbackController = playbackController != null ? playbackController
         : new DefaultPlaybackController();
+    this.metadataExtrasPrefix = metadataExtrasPrefix != null ? metadataExtrasPrefix : "";
     this.handler = new Handler(Looper.myLooper() != null ? Looper.myLooper()
         : Looper.getMainLooper());
     this.doMaintainMetadata = doMaintainMetadata;
@@ -463,6 +469,17 @@ public void setQueueEditor(QueueEditor queueEditor) {
         : EDITOR_MEDIA_SESSION_FLAGS);
   }
 
+  /**
+   * Sets the {@link RatingCallback} to handle user ratings.
+   *
+   * @param ratingCallback The rating callback.
+   */
+  public void setRatingCallback(RatingCallback ratingCallback) {
+    unregisterCommandReceiver(this.ratingCallback);
+    this.ratingCallback = ratingCallback;
+    registerCommandReceiver(this.ratingCallback);
+  }
+
   private void registerCommandReceiver(CommandReceiver commandReceiver) {
     if (commandReceiver != null && commandReceiver.getCommands() != null) {
       for (String command : commandReceiver.getCommands()) {
@@ -531,8 +548,8 @@ private long buildPlaybackActions() {
       actions |= (QueueNavigator.ACTIONS & queueNavigator.getSupportedQueueNavigatorActions(
           player));
     }
-    if (queueEditor != null) {
-      actions |= (QueueEditor.ACTIONS & queueEditor.getSupportedQueueEditorActions(player));
+    if (ratingCallback != null) {
+      actions |= RatingCallback.ACTIONS;
     }
     return actions;
   }
@@ -553,6 +570,25 @@ private void updateMediaSessionMetadata() {
           MediaSessionCompat.QueueItem queueItem = queue.get(i);
           if (queueItem.getQueueId() == activeQueueItemId) {
             MediaDescriptionCompat description = queueItem.getDescription();
+            Bundle extras = description.getExtras();
+            if (extras != null) {
+              for (String key : extras.keySet()) {
+                Object value = extras.get(key);
+                if (value instanceof String) {
+                  builder.putString(metadataExtrasPrefix + key, (String) value);
+                } else if (value instanceof CharSequence) {
+                  builder.putText(metadataExtrasPrefix + key, (CharSequence) value);
+                } else if (value instanceof Long) {
+                  builder.putLong(metadataExtrasPrefix + key, (Long) value);
+                } else if (value instanceof Integer) {
+                  builder.putLong(metadataExtrasPrefix + key, (Integer) value);
+                } else if (value instanceof Bitmap) {
+                  builder.putBitmap(metadataExtrasPrefix + key, (Bitmap) value);
+                } else if (value instanceof RatingCompat) {
+                  builder.putRating(metadataExtrasPrefix + key, (RatingCompat) value);
+                }
+              }
+            }
             if (description.getTitle() != null) {
               builder.putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_TITLE,
                   String.valueOf(description.getTitle()));
@@ -607,6 +643,10 @@ private boolean canDispatchToPlaybackPreparer(long action) {
         & PlaybackPreparer.ACTIONS & action) != 0;
   }
 
+  private boolean canDispatchToRatingCallback(long action) {
+    return ratingCallback != null && (RatingCallback.ACTIONS & action) != 0;
+  }
+
   private boolean canDispatchToPlaybackController(long action) {
     return (playbackController.getSupportedPlaybackActions(player)
         & PlaybackController.ACTIONS & action) != 0;
@@ -617,18 +657,14 @@ private boolean canDispatchToQueueNavigator(long action) {
         & QueueNavigator.ACTIONS & action) != 0;
   }
 
-  private boolean canDispatchToQueueEditor(long action) {
-    return queueEditor != null && (queueEditor.getSupportedQueueEditorActions(player)
-        & QueueEditor.ACTIONS & action) != 0;
-  }
-
   private class ExoPlayerEventListener extends Player.DefaultEventListener {
 
     private int currentWindowIndex;
     private int currentWindowCount;
 
     @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest) {
+    public void onTimelineChanged(Timeline timeline, Object manifest,
+        @Player.TimelineChangeReason int reason) {
       int windowCount = player.getCurrentTimeline().getWindowCount();
       int windowIndex = player.getCurrentWindowIndex();
       if (queueNavigator != null) {
@@ -851,6 +887,13 @@ public void onPlayFromUri(Uri uri, Bundle extras) {
       }
     }
 
+    @Override
+    public void onSetRating(RatingCompat rating) {
+      if (canDispatchToRatingCallback(PlaybackStateCompat.ACTION_SET_RATING)) {
+        ratingCallback.onSetRating(player, rating);
+      }
+    }
+
     @Override
     public void onAddQueueItem(MediaDescriptionCompat description) {
       if (queueEditor != null) {
@@ -879,13 +922,6 @@ public void onRemoveQueueItemAt(int index) {
       }
     }
 
-    @Override
-    public void onSetRating(RatingCompat rating) {
-      if (canDispatchToQueueEditor(PlaybackStateCompat.ACTION_SET_RATING)) {
-        queueEditor.onSetRating(player, rating);
-      }
-    }
-
   }
 
 }
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
index 65090a3c1c..402abf7c70 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/TimelineQueueEditor.java
@@ -20,7 +20,6 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.media.MediaDescriptionCompat;
-import android.support.v4.media.RatingCompat;
 import android.support.v4.media.session.MediaControllerCompat;
 import android.support.v4.media.session.MediaSessionCompat;
 import com.google.android.exoplayer2.C;
@@ -164,11 +163,6 @@ public TimelineQueueEditor(@NonNull MediaControllerCompat mediaController,
     this.equalityChecker = equalityChecker;
   }
 
-  @Override
-  public long getSupportedQueueEditorActions(@Nullable Player player) {
-    return 0;
-  }
-
   @Override
   public void onAddQueueItem(Player player, MediaDescriptionCompat description) {
     onAddQueueItem(player, description, player.getCurrentTimeline().getWindowCount());
@@ -200,11 +194,6 @@ public void onRemoveQueueItemAt(Player player, int index) {
     queueMediaSource.removeMediaSource(index);
   }
 
-  @Override
-  public void onSetRating(Player player, RatingCompat rating) {
-    // Do nothing.
-  }
-
   // CommandReceiver implementation.
 
   @NonNull
diff --git a/extensions/mediasession/src/main/res/values-af/strings.xml b/extensions/mediasession/src/main/res/values-af/strings.xml
index 4ef78cd84f..65bc1e89d8 100644
--- a/extensions/mediasession/src/main/res/values-af/strings.xml
+++ b/extensions/mediasession/src/main/res/values-af/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Herhaal alles"</string>
-  <string name="exo_media_action_repeat_off_description">"Herhaal niks"</string>
-  <string name="exo_media_action_repeat_one_description">"Herhaal een"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Herhaal niks"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Herhaal een"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Herhaal alles"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-am/strings.xml b/extensions/mediasession/src/main/res/values-am/strings.xml
index 531f605584..0dc20aaa04 100644
--- a/extensions/mediasession/src/main/res/values-am/strings.xml
+++ b/extensions/mediasession/src/main/res/values-am/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"ሁሉንም ድገም"</string>
-  <string name="exo_media_action_repeat_off_description">"ምንም አትድገም"</string>
-  <string name="exo_media_action_repeat_one_description">"አንዱን ድገም"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"ምንም አትድገም"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"አንድ ድገም"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"ሁሉንም ድገም"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-ar/strings.xml b/extensions/mediasession/src/main/res/values-ar/strings.xml
index 0101a746e0..2776e28356 100644
--- a/extensions/mediasession/src/main/res/values-ar/strings.xml
+++ b/extensions/mediasession/src/main/res/values-ar/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"تكرار الكل"</string>
-  <string name="exo_media_action_repeat_off_description">"عدم التكرار"</string>
-  <string name="exo_media_action_repeat_one_description">"تكرار مقطع واحد"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"عدم التكرار"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"تكرار مقطع صوتي واحد"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"تكرار الكل"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-b+sr+Latn/strings.xml b/extensions/mediasession/src/main/res/values-b+sr+Latn/strings.xml
index 67a51cf85e..d20b16531a 100644
--- a/extensions/mediasession/src/main/res/values-b+sr+Latn/strings.xml
+++ b/extensions/mediasession/src/main/res/values-b+sr+Latn/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Ponovi sve"</string>
-  <string name="exo_media_action_repeat_off_description">"Ne ponavljaj nijednu"</string>
-  <string name="exo_media_action_repeat_one_description">"Ponovi jednu"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Ne ponavljaj nijednu"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Ponovi jednu"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Ponovi sve"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-bg/strings.xml b/extensions/mediasession/src/main/res/values-bg/strings.xml
index 16910d640a..087eaee8c2 100644
--- a/extensions/mediasession/src/main/res/values-bg/strings.xml
+++ b/extensions/mediasession/src/main/res/values-bg/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Повтаряне на всички"</string>
-  <string name="exo_media_action_repeat_off_description">"Без повтаряне"</string>
-  <string name="exo_media_action_repeat_one_description">"Повтаряне на един елемент"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Без повтаряне"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Повтаряне на един елемент"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Повтаряне на всички"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-ca/strings.xml b/extensions/mediasession/src/main/res/values-ca/strings.xml
index 89414d736e..4a4d8646a2 100644
--- a/extensions/mediasession/src/main/res/values-ca/strings.xml
+++ b/extensions/mediasession/src/main/res/values-ca/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Repeteix-ho tot"</string>
-  <string name="exo_media_action_repeat_off_description">"No en repeteixis cap"</string>
-  <string name="exo_media_action_repeat_one_description">"Repeteix-ne un"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"No en repeteixis cap"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Repeteix una"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Repeteix tot"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-cs/strings.xml b/extensions/mediasession/src/main/res/values-cs/strings.xml
index 784d872570..c59dcfc874 100644
--- a/extensions/mediasession/src/main/res/values-cs/strings.xml
+++ b/extensions/mediasession/src/main/res/values-cs/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Opakovat vše"</string>
-  <string name="exo_media_action_repeat_off_description">"Neopakovat"</string>
-  <string name="exo_media_action_repeat_one_description">"Opakovat jednu položku"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Neopakovat"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Opakovat jednu"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Opakovat vše"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-da/strings.xml b/extensions/mediasession/src/main/res/values-da/strings.xml
index 2c9784d122..0d31261f3d 100644
--- a/extensions/mediasession/src/main/res/values-da/strings.xml
+++ b/extensions/mediasession/src/main/res/values-da/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Gentag alle"</string>
-  <string name="exo_media_action_repeat_off_description">"Gentag ingen"</string>
-  <string name="exo_media_action_repeat_one_description">"Gentag en"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Gentag ingen"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Gentag én"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Gentag alle"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-de/strings.xml b/extensions/mediasession/src/main/res/values-de/strings.xml
index c11e449665..dfa86a54d4 100644
--- a/extensions/mediasession/src/main/res/values-de/strings.xml
+++ b/extensions/mediasession/src/main/res/values-de/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Alle wiederholen"</string>
-  <string name="exo_media_action_repeat_off_description">"Keinen Titel wiederholen"</string>
-  <string name="exo_media_action_repeat_one_description">"Einen Titel wiederholen"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Keinen wiederholen"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Einen wiederholen"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Alle wiederholen"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-el/strings.xml b/extensions/mediasession/src/main/res/values-el/strings.xml
index 6279af5d64..e73b24592e 100644
--- a/extensions/mediasession/src/main/res/values-el/strings.xml
+++ b/extensions/mediasession/src/main/res/values-el/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Επανάληψη όλων"</string>
-  <string name="exo_media_action_repeat_off_description">"Καμία επανάληψη"</string>
-  <string name="exo_media_action_repeat_one_description">"Επανάληψη ενός στοιχείου"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Καμία επανάληψη"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Επανάληψη ενός κομματιού"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Επανάληψη όλων"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-en-rAU/strings.xml b/extensions/mediasession/src/main/res/values-en-rAU/strings.xml
index a3fccf8b52..197222473d 100644
--- a/extensions/mediasession/src/main/res/values-en-rAU/strings.xml
+++ b/extensions/mediasession/src/main/res/values-en-rAU/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Repeat all"</string>
-  <string name="exo_media_action_repeat_off_description">"Repeat none"</string>
-  <string name="exo_media_action_repeat_one_description">"Repeat one"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Repeat none"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Repeat one"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Repeat all"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-en-rGB/strings.xml b/extensions/mediasession/src/main/res/values-en-rGB/strings.xml
index a3fccf8b52..197222473d 100644
--- a/extensions/mediasession/src/main/res/values-en-rGB/strings.xml
+++ b/extensions/mediasession/src/main/res/values-en-rGB/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Repeat all"</string>
-  <string name="exo_media_action_repeat_off_description">"Repeat none"</string>
-  <string name="exo_media_action_repeat_one_description">"Repeat one"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Repeat none"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Repeat one"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Repeat all"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-en-rIN/strings.xml b/extensions/mediasession/src/main/res/values-en-rIN/strings.xml
index a3fccf8b52..197222473d 100644
--- a/extensions/mediasession/src/main/res/values-en-rIN/strings.xml
+++ b/extensions/mediasession/src/main/res/values-en-rIN/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Repeat all"</string>
-  <string name="exo_media_action_repeat_off_description">"Repeat none"</string>
-  <string name="exo_media_action_repeat_one_description">"Repeat one"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Repeat none"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Repeat one"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Repeat all"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-es-rUS/strings.xml b/extensions/mediasession/src/main/res/values-es-rUS/strings.xml
index 0fe29d3d5a..192ad2f2ef 100644
--- a/extensions/mediasession/src/main/res/values-es-rUS/strings.xml
+++ b/extensions/mediasession/src/main/res/values-es-rUS/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Repetir todo"</string>
-  <string name="exo_media_action_repeat_off_description">"No repetir"</string>
-  <string name="exo_media_action_repeat_one_description">"Repetir uno"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"No repetir"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Repetir uno"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Repetir todo"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-es/strings.xml b/extensions/mediasession/src/main/res/values-es/strings.xml
index 0fe29d3d5a..192ad2f2ef 100644
--- a/extensions/mediasession/src/main/res/values-es/strings.xml
+++ b/extensions/mediasession/src/main/res/values-es/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Repetir todo"</string>
-  <string name="exo_media_action_repeat_off_description">"No repetir"</string>
-  <string name="exo_media_action_repeat_one_description">"Repetir uno"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"No repetir"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Repetir uno"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Repetir todo"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-fa/strings.xml b/extensions/mediasession/src/main/res/values-fa/strings.xml
index e37a08de64..42b1b14c90 100644
--- a/extensions/mediasession/src/main/res/values-fa/strings.xml
+++ b/extensions/mediasession/src/main/res/values-fa/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"تکرار همه"</string>
-  <string name="exo_media_action_repeat_off_description">"تکرار هیچ‌کدام"</string>
-  <string name="exo_media_action_repeat_one_description">"یک‌بار تکرار"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"تکرار هیچ‌کدام"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"یکبار تکرار"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"تکرار همه"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-fi/strings.xml b/extensions/mediasession/src/main/res/values-fi/strings.xml
index c920827976..68f1b6c93b 100644
--- a/extensions/mediasession/src/main/res/values-fi/strings.xml
+++ b/extensions/mediasession/src/main/res/values-fi/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Toista kaikki"</string>
-  <string name="exo_media_action_repeat_off_description">"Toista ei mitään"</string>
-  <string name="exo_media_action_repeat_one_description">"Toista yksi"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Ei uudelleentoistoa"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Toista yksi uudelleen"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Toista kaikki uudelleen"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-fr-rCA/strings.xml b/extensions/mediasession/src/main/res/values-fr-rCA/strings.xml
index c5191e74a9..62edf759bb 100644
--- a/extensions/mediasession/src/main/res/values-fr-rCA/strings.xml
+++ b/extensions/mediasession/src/main/res/values-fr-rCA/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Tout lire en boucle"</string>
-  <string name="exo_media_action_repeat_off_description">"Aucune répétition"</string>
-  <string name="exo_media_action_repeat_one_description">"Répéter un élément"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Ne rien lire en boucle"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Lire une chanson en boucle"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Tout lire en boucle"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-fr/strings.xml b/extensions/mediasession/src/main/res/values-fr/strings.xml
index 1d76358d1f..2ea8653e93 100644
--- a/extensions/mediasession/src/main/res/values-fr/strings.xml
+++ b/extensions/mediasession/src/main/res/values-fr/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Tout lire en boucle"</string>
-  <string name="exo_media_action_repeat_off_description">"Ne rien lire en boucle"</string>
-  <string name="exo_media_action_repeat_one_description">"Lire en boucle un élément"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Ne rien lire en boucle"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Lire un titre en boucle"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Tout lire en boucle"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-hi/strings.xml b/extensions/mediasession/src/main/res/values-hi/strings.xml
index 8ce336d5e5..79261e4e59 100644
--- a/extensions/mediasession/src/main/res/values-hi/strings.xml
+++ b/extensions/mediasession/src/main/res/values-hi/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"सभी को दोहराएं"</string>
-  <string name="exo_media_action_repeat_off_description">"कुछ भी न दोहराएं"</string>
-  <string name="exo_media_action_repeat_one_description">"एक दोहराएं"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"किसी को न दोहराएं"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"एक को दोहराएं"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"सभी को दोहराएं"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-hr/strings.xml b/extensions/mediasession/src/main/res/values-hr/strings.xml
index 9f995ec15b..81bb428528 100644
--- a/extensions/mediasession/src/main/res/values-hr/strings.xml
+++ b/extensions/mediasession/src/main/res/values-hr/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Ponovi sve"</string>
-  <string name="exo_media_action_repeat_off_description">"Bez ponavljanja"</string>
-  <string name="exo_media_action_repeat_one_description">"Ponovi jedno"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Bez ponavljanja"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Ponovi jedno"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Ponovi sve"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-hu/strings.xml b/extensions/mediasession/src/main/res/values-hu/strings.xml
index 2335ade72e..8e8369a61f 100644
--- a/extensions/mediasession/src/main/res/values-hu/strings.xml
+++ b/extensions/mediasession/src/main/res/values-hu/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Összes ismétlése"</string>
-  <string name="exo_media_action_repeat_off_description">"Nincs ismétlés"</string>
-  <string name="exo_media_action_repeat_one_description">"Egy ismétlése"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Nincs ismétlés"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Egy szám ismétlése"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Összes szám ismétlése"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-in/strings.xml b/extensions/mediasession/src/main/res/values-in/strings.xml
index 093a7f8576..a20a6362c8 100644
--- a/extensions/mediasession/src/main/res/values-in/strings.xml
+++ b/extensions/mediasession/src/main/res/values-in/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Ulangi Semua"</string>
-  <string name="exo_media_action_repeat_off_description">"Jangan Ulangi"</string>
-  <string name="exo_media_action_repeat_one_description">"Ulangi Satu"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Jangan ulangi"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Ulangi 1"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Ulangi semua"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-it/strings.xml b/extensions/mediasession/src/main/res/values-it/strings.xml
index c0682519f9..3a59bb5804 100644
--- a/extensions/mediasession/src/main/res/values-it/strings.xml
+++ b/extensions/mediasession/src/main/res/values-it/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Ripeti tutti"</string>
-  <string name="exo_media_action_repeat_off_description">"Non ripetere nessuno"</string>
-  <string name="exo_media_action_repeat_one_description">"Ripeti uno"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Non ripetere nulla"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Ripeti uno"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Ripeti tutto"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-iw/strings.xml b/extensions/mediasession/src/main/res/values-iw/strings.xml
index 5cf23d5a4c..f9eac73e59 100644
--- a/extensions/mediasession/src/main/res/values-iw/strings.xml
+++ b/extensions/mediasession/src/main/res/values-iw/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"חזור על הכל"</string>
-  <string name="exo_media_action_repeat_off_description">"אל תחזור על כלום"</string>
-  <string name="exo_media_action_repeat_one_description">"חזור על פריט אחד"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"אל תחזור על אף פריט"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"חזור על פריט אחד"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"חזור על הכול"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-ja/strings.xml b/extensions/mediasession/src/main/res/values-ja/strings.xml
index 6f543fbdee..bcfb6eb7c2 100644
--- a/extensions/mediasession/src/main/res/values-ja/strings.xml
+++ b/extensions/mediasession/src/main/res/values-ja/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"全曲を繰り返し"</string>
-  <string name="exo_media_action_repeat_off_description">"繰り返しなし"</string>
-  <string name="exo_media_action_repeat_one_description">"1曲を繰り返し"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"リピートなし"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"1 曲をリピート"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"全曲をリピート"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-ko/strings.xml b/extensions/mediasession/src/main/res/values-ko/strings.xml
index d269937771..7be13b133a 100644
--- a/extensions/mediasession/src/main/res/values-ko/strings.xml
+++ b/extensions/mediasession/src/main/res/values-ko/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"전체 반복"</string>
-  <string name="exo_media_action_repeat_off_description">"반복 안함"</string>
-  <string name="exo_media_action_repeat_one_description">"한 항목 반복"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"반복 안함"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"현재 미디어 반복"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"모두 반복"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-lt/strings.xml b/extensions/mediasession/src/main/res/values-lt/strings.xml
index ae8f1cf8c3..78d1753ed0 100644
--- a/extensions/mediasession/src/main/res/values-lt/strings.xml
+++ b/extensions/mediasession/src/main/res/values-lt/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Kartoti viską"</string>
-  <string name="exo_media_action_repeat_off_description">"Nekartoti nieko"</string>
-  <string name="exo_media_action_repeat_one_description">"Kartoti vieną"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Nekartoti nieko"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Kartoti vieną"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Kartoti viską"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-lv/strings.xml b/extensions/mediasession/src/main/res/values-lv/strings.xml
index a69f6a0ad5..085723a271 100644
--- a/extensions/mediasession/src/main/res/values-lv/strings.xml
+++ b/extensions/mediasession/src/main/res/values-lv/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Atkārtot visu"</string>
-  <string name="exo_media_action_repeat_off_description">"Neatkārtot nevienu"</string>
-  <string name="exo_media_action_repeat_one_description">"Atkārtot vienu"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Neatkārtot nevienu"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Atkārtot vienu"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Atkārtot visu"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-nb/strings.xml b/extensions/mediasession/src/main/res/values-nb/strings.xml
index 10f334b226..2e986733fc 100644
--- a/extensions/mediasession/src/main/res/values-nb/strings.xml
+++ b/extensions/mediasession/src/main/res/values-nb/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Gjenta alle"</string>
-  <string name="exo_media_action_repeat_off_description">"Ikke gjenta noen"</string>
-  <string name="exo_media_action_repeat_one_description">"Gjenta én"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Ikke gjenta noen"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Gjenta én"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Gjenta alle"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-nl/strings.xml b/extensions/mediasession/src/main/res/values-nl/strings.xml
index 55997be098..4dfc31bb98 100644
--- a/extensions/mediasession/src/main/res/values-nl/strings.xml
+++ b/extensions/mediasession/src/main/res/values-nl/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Alles herhalen"</string>
-  <string name="exo_media_action_repeat_off_description">"Niet herhalen"</string>
-  <string name="exo_media_action_repeat_one_description">"Eén herhalen"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Niets herhalen"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Eén herhalen"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Alles herhalen"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-pl/strings.xml b/extensions/mediasession/src/main/res/values-pl/strings.xml
index 6a52d58b63..37af4c1616 100644
--- a/extensions/mediasession/src/main/res/values-pl/strings.xml
+++ b/extensions/mediasession/src/main/res/values-pl/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Powtórz wszystkie"</string>
-  <string name="exo_media_action_repeat_off_description">"Nie powtarzaj"</string>
-  <string name="exo_media_action_repeat_one_description">"Powtórz jeden"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Nie powtarzaj"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Powtórz jeden"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Powtórz wszystkie"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-pt-rPT/strings.xml b/extensions/mediasession/src/main/res/values-pt-rPT/strings.xml
index efb8fc433f..43a4cd9e6a 100644
--- a/extensions/mediasession/src/main/res/values-pt-rPT/strings.xml
+++ b/extensions/mediasession/src/main/res/values-pt-rPT/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Repetir tudo"</string>
-  <string name="exo_media_action_repeat_off_description">"Não repetir"</string>
-  <string name="exo_media_action_repeat_one_description">"Repetir um"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Não repetir nenhum"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Repetir um"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Repetir tudo"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-pt/strings.xml b/extensions/mediasession/src/main/res/values-pt/strings.xml
index aadebbb3b0..4e7ce248cc 100644
--- a/extensions/mediasession/src/main/res/values-pt/strings.xml
+++ b/extensions/mediasession/src/main/res/values-pt/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Repetir tudo"</string>
-  <string name="exo_media_action_repeat_off_description">"Não repetir"</string>
-  <string name="exo_media_action_repeat_one_description">"Repetir uma"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Não repetir"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Repetir uma"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Repetir tudo"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-ro/strings.xml b/extensions/mediasession/src/main/res/values-ro/strings.xml
index f6aee447e5..9345a5df35 100644
--- a/extensions/mediasession/src/main/res/values-ro/strings.xml
+++ b/extensions/mediasession/src/main/res/values-ro/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Repetați toate"</string>
-  <string name="exo_media_action_repeat_off_description">"Repetați niciuna"</string>
-  <string name="exo_media_action_repeat_one_description">"Repetați unul"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Nu repetați niciunul"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Repetați unul"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Repetați-le pe toate"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-ru/strings.xml b/extensions/mediasession/src/main/res/values-ru/strings.xml
index 575ad9f930..8c52ea8395 100644
--- a/extensions/mediasession/src/main/res/values-ru/strings.xml
+++ b/extensions/mediasession/src/main/res/values-ru/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Повторять все"</string>
-  <string name="exo_media_action_repeat_off_description">"Не повторять"</string>
-  <string name="exo_media_action_repeat_one_description">"Повторять один элемент"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Не повторять"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Повторять трек"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Повторять все"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-sk/strings.xml b/extensions/mediasession/src/main/res/values-sk/strings.xml
index 5d092003e5..9a7cccd096 100644
--- a/extensions/mediasession/src/main/res/values-sk/strings.xml
+++ b/extensions/mediasession/src/main/res/values-sk/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Opakovať všetko"</string>
-  <string name="exo_media_action_repeat_off_description">"Neopakovať"</string>
-  <string name="exo_media_action_repeat_one_description">"Opakovať jednu položku"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Neopakovať"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Opakovať jednu"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Opakovať všetko"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-sl/strings.xml b/extensions/mediasession/src/main/res/values-sl/strings.xml
index ecac3800c8..7bf20baa19 100644
--- a/extensions/mediasession/src/main/res/values-sl/strings.xml
+++ b/extensions/mediasession/src/main/res/values-sl/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Ponovi vse"</string>
-  <string name="exo_media_action_repeat_off_description">"Ne ponovi"</string>
-  <string name="exo_media_action_repeat_one_description">"Ponovi eno"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Brez ponavljanja"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Ponavljanje ene"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Ponavljanje vseh"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-sr/strings.xml b/extensions/mediasession/src/main/res/values-sr/strings.xml
index 881cb2703b..b82940da2e 100644
--- a/extensions/mediasession/src/main/res/values-sr/strings.xml
+++ b/extensions/mediasession/src/main/res/values-sr/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,6 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Не понављај ниједну"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Понови једну"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Понови све"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-sv/strings.xml b/extensions/mediasession/src/main/res/values-sv/strings.xml
index 3a7bb630aa..13edc46d1f 100644
--- a/extensions/mediasession/src/main/res/values-sv/strings.xml
+++ b/extensions/mediasession/src/main/res/values-sv/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Upprepa alla"</string>
-  <string name="exo_media_action_repeat_off_description">"Upprepa inga"</string>
-  <string name="exo_media_action_repeat_one_description">"Upprepa en"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Upprepa inga"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Upprepa en"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Upprepa alla"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-sw/strings.xml b/extensions/mediasession/src/main/res/values-sw/strings.xml
index 726012ab88..b40ce1a727 100644
--- a/extensions/mediasession/src/main/res/values-sw/strings.xml
+++ b/extensions/mediasession/src/main/res/values-sw/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Rudia zote"</string>
-  <string name="exo_media_action_repeat_off_description">"Usirudie Yoyote"</string>
-  <string name="exo_media_action_repeat_one_description">"Rudia Moja"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Usirudie yoyote"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Rudia moja"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Rudia zote"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-th/strings.xml b/extensions/mediasession/src/main/res/values-th/strings.xml
index af502b3a4c..4e40f559d0 100644
--- a/extensions/mediasession/src/main/res/values-th/strings.xml
+++ b/extensions/mediasession/src/main/res/values-th/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"เล่นซ้ำทั้งหมด"</string>
-  <string name="exo_media_action_repeat_off_description">"ไม่เล่นซ้ำ"</string>
-  <string name="exo_media_action_repeat_one_description">"เล่นซ้ำรายการเดียว"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"ไม่เล่นซ้ำ"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"เล่นซ้ำเพลงเดียว"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"เล่นซ้ำทั้งหมด"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-tl/strings.xml b/extensions/mediasession/src/main/res/values-tl/strings.xml
index 239972a4c7..4fff164f9f 100644
--- a/extensions/mediasession/src/main/res/values-tl/strings.xml
+++ b/extensions/mediasession/src/main/res/values-tl/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Ulitin Lahat"</string>
-  <string name="exo_media_action_repeat_off_description">"Walang Uulitin"</string>
-  <string name="exo_media_action_repeat_one_description">"Ulitin ang Isa"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Walang uulitin"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Mag-ulit ng isa"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Ulitin lahat"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-tr/strings.xml b/extensions/mediasession/src/main/res/values-tr/strings.xml
index 89a98b1ed9..f93fd7fc80 100644
--- a/extensions/mediasession/src/main/res/values-tr/strings.xml
+++ b/extensions/mediasession/src/main/res/values-tr/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Tümünü Tekrarla"</string>
-  <string name="exo_media_action_repeat_off_description">"Hiçbirini Tekrarlama"</string>
-  <string name="exo_media_action_repeat_one_description">"Birini Tekrarla"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Hiçbirini tekrarlama"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Bir şarkıyı tekrarla"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Tümünü tekrarla"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-uk/strings.xml b/extensions/mediasession/src/main/res/values-uk/strings.xml
index 4e1d25eb8a..fb9d000474 100644
--- a/extensions/mediasession/src/main/res/values-uk/strings.xml
+++ b/extensions/mediasession/src/main/res/values-uk/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Повторити все"</string>
-  <string name="exo_media_action_repeat_off_description">"Не повторювати"</string>
-  <string name="exo_media_action_repeat_one_description">"Повторити один елемент"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Не повторювати"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Повторити 1"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Повторити всі"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-vi/strings.xml b/extensions/mediasession/src/main/res/values-vi/strings.xml
index dabc9e05d5..379dc36ee6 100644
--- a/extensions/mediasession/src/main/res/values-vi/strings.xml
+++ b/extensions/mediasession/src/main/res/values-vi/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Lặp lại tất cả"</string>
-  <string name="exo_media_action_repeat_off_description">"Không lặp lại"</string>
-  <string name="exo_media_action_repeat_one_description">"Lặp lại một mục"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Không lặp lại"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Lặp lại một"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Lặp lại tất cả"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-zh-rCN/strings.xml b/extensions/mediasession/src/main/res/values-zh-rCN/strings.xml
index beb3403cb9..6917f75bf9 100644
--- a/extensions/mediasession/src/main/res/values-zh-rCN/strings.xml
+++ b/extensions/mediasession/src/main/res/values-zh-rCN/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"重复播放全部"</string>
-  <string name="exo_media_action_repeat_off_description">"不重复播放"</string>
-  <string name="exo_media_action_repeat_one_description">"重复播放单个视频"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"不重复播放"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"重复播放一项"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"全部重复播放"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-zh-rHK/strings.xml b/extensions/mediasession/src/main/res/values-zh-rHK/strings.xml
index 775cd6441c..b63f103e2a 100644
--- a/extensions/mediasession/src/main/res/values-zh-rHK/strings.xml
+++ b/extensions/mediasession/src/main/res/values-zh-rHK/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"重複播放所有媒體項目"</string>
-  <string name="exo_media_action_repeat_off_description">"不重複播放任何媒體項目"</string>
-  <string name="exo_media_action_repeat_one_description">"重複播放一個媒體項目"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"不重複播放"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"重複播放一個"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"全部重複播放"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-zh-rTW/strings.xml b/extensions/mediasession/src/main/res/values-zh-rTW/strings.xml
index d3789f4145..0a460b9e08 100644
--- a/extensions/mediasession/src/main/res/values-zh-rTW/strings.xml
+++ b/extensions/mediasession/src/main/res/values-zh-rTW/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"重複播放所有媒體項目"</string>
-  <string name="exo_media_action_repeat_off_description">"不重複播放"</string>
-  <string name="exo_media_action_repeat_one_description">"重複播放單一媒體項目"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"不重複播放"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"重複播放單一項目"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"重複播放所有項目"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values-zu/strings.xml b/extensions/mediasession/src/main/res/values-zu/strings.xml
index 789b6fecb4..ccf8452d69 100644
--- a/extensions/mediasession/src/main/res/values-zu/strings.xml
+++ b/extensions/mediasession/src/main/res/values-zu/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,9 +12,11 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_media_action_repeat_all_description">"Phinda konke"</string>
-  <string name="exo_media_action_repeat_off_description">"Ungaphindi lutho"</string>
-  <string name="exo_media_action_repeat_one_description">"Phida okukodwa"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_media_action_repeat_off_description" msgid="160802313171921598">"Phinda okungekho"</string>
+    <string name="exo_media_action_repeat_one_description" msgid="120730756187958757">"Phinda okukodwa"</string>
+    <string name="exo_media_action_repeat_all_description" msgid="92377890871273452">"Phinda konke"</string>
 </resources>
diff --git a/extensions/mediasession/src/main/res/values/strings.xml b/extensions/mediasession/src/main/res/values/strings.xml
index 72a67ff01c..015fd04cea 100644
--- a/extensions/mediasession/src/main/res/values/strings.xml
+++ b/extensions/mediasession/src/main/res/values/strings.xml
@@ -14,7 +14,10 @@
      limitations under the License.
 -->
 <resources>
+  <!-- Description for a button that controls the repeat mode of a media playback. In this mode media is not repeated. [CHAR LIMIT=30] -->
   <string name="exo_media_action_repeat_off_description">Repeat none</string>
+  <!-- Description for a button that controls the repeat mode of a media playback. In this mode the current piece of media is repeated. [CHAR LIMIT=30] -->
   <string name="exo_media_action_repeat_one_description">Repeat one</string>
+  <!-- Description for a button that controls the repeat mode of a media playback. In this mode the entire playlist is repeated. [CHAR LIMIT=30] -->
   <string name="exo_media_action_repeat_all_description">Repeat all</string>
 </resources>
diff --git a/extensions/okhttp/README.md b/extensions/okhttp/README.md
index e40535d4e8..73297b54a9 100644
--- a/extensions/okhttp/README.md
+++ b/extensions/okhttp/README.md
@@ -19,10 +19,10 @@ licensed separately.
 The easiest way to use the extension is to add it as a gradle dependency:
 
 ```gradle
-compile 'com.google.android.exoplayer:extension-okhttp:rX.X.X'
+implementation 'com.google.android.exoplayer:extension-okhttp:2.X.X'
 ```
 
-where `rX.X.X` is the version, which must match the version of the ExoPlayer
+where `2.X.X` is the version, which must match the version of the ExoPlayer
 library being used.
 
 Alternatively, you can clone the ExoPlayer repository and depend on the module
diff --git a/extensions/okhttp/build.gradle b/extensions/okhttp/build.gradle
index 13bcff8a4e..2da245b1a5 100644
--- a/extensions/okhttp/build.gradle
+++ b/extensions/okhttp/build.gradle
@@ -30,8 +30,9 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile('com.squareup.okhttp3:okhttp:3.9.0') {
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation('com.squareup.okhttp3:okhttp:3.9.0') {
         exclude group: 'org.json'
     }
 }
diff --git a/extensions/opus/build.gradle b/extensions/opus/build.gradle
index 41b428070f..2d20c65697 100644
--- a/extensions/opus/build.gradle
+++ b/extensions/opus/build.gradle
@@ -31,7 +31,7 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-core')
 }
 
 ext {
diff --git a/extensions/opus/src/androidTest/AndroidManifest.xml b/extensions/opus/src/androidTest/AndroidManifest.xml
index aba71a0821..2d56e8d1a7 100644
--- a/extensions/opus/src/androidTest/AndroidManifest.xml
+++ b/extensions/opus/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.ext.opus.test">
 
-  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="27"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
index 591f43f38a..c547cff434 100644
--- a/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
+++ b/extensions/opus/src/androidTest/java/com/google/android/exoplayer2/ext/opus/OpusPlaybackTest.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 
@@ -36,6 +37,14 @@
 
   private static final String BEAR_OPUS_URI = "asset:///bear-opus.webm";
 
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    if (!OpusLibrary.isAvailable()) {
+      fail("Opus library not available.");
+    }
+  }
+
   public void testBasicPlayback() throws ExoPlaybackException {
     playUri(BEAR_OPUS_URI);
   }
@@ -76,12 +85,11 @@ public void run() {
       DefaultTrackSelector trackSelector = new DefaultTrackSelector();
       player = ExoPlayerFactory.newInstance(new Renderer[] {audioRenderer}, trackSelector);
       player.addListener(this);
-      ExtractorMediaSource mediaSource = new ExtractorMediaSource(
-          uri,
-          new DefaultDataSourceFactory(context, "ExoPlayerExtOpusTest"),
-          MatroskaExtractor.FACTORY,
-          null,
-          null);
+      MediaSource mediaSource =
+          new ExtractorMediaSource.Factory(
+                  new DefaultDataSourceFactory(context, "ExoPlayerExtOpusTest"))
+              .setExtractorsFactory(MatroskaExtractor.FACTORY)
+              .createMediaSource(uri);
       player.prepare(mediaSource);
       player.setPlayWhenReady(true);
       Looper.loop();
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
index e4745d0c29..b94f3e9332 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/LibopusAudioRenderer.java
@@ -76,6 +76,8 @@ protected int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessio
     if (!OpusLibrary.isAvailable()
         || !MimeTypes.AUDIO_OPUS.equalsIgnoreCase(format.sampleMimeType)) {
       return FORMAT_UNSUPPORTED_TYPE;
+    } else if (!supportsOutputEncoding(C.ENCODING_PCM_16BIT)) {
+      return FORMAT_UNSUPPORTED_SUBTYPE;
     } else if (!supportsFormatDrm(drmSessionManager, format.drmInitData)) {
       return FORMAT_UNSUPPORTED_DRM;
     } else {
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
index b4a4622346..f8ec477b88 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusDecoder.java
@@ -135,18 +135,23 @@ public String getName() {
   }
 
   @Override
-  public DecoderInputBuffer createInputBuffer() {
+  protected DecoderInputBuffer createInputBuffer() {
     return new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DIRECT);
   }
 
   @Override
-  public SimpleOutputBuffer createOutputBuffer() {
+  protected SimpleOutputBuffer createOutputBuffer() {
     return new SimpleOutputBuffer(this);
   }
 
   @Override
-  public OpusDecoderException decode(DecoderInputBuffer inputBuffer,
-      SimpleOutputBuffer outputBuffer, boolean reset) {
+  protected OpusDecoderException createUnexpectedDecodeException(Throwable error) {
+    return new OpusDecoderException("Unexpected decode error", error);
+  }
+
+  @Override
+  protected OpusDecoderException decode(
+      DecoderInputBuffer inputBuffer, SimpleOutputBuffer outputBuffer, boolean reset) {
     if (reset) {
       opusReset(nativeDecoderContext);
       // When seeking to 0, skip number of samples as specified in opus header. When seeking to
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
index 22985ea497..4cb3ce3190 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer2/ext/opus/OpusLibrary.java
@@ -27,7 +27,7 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.opus");
   }
 
-  private static final LibraryLoader LOADER = new LibraryLoader("opus", "opusJNI");
+  private static final LibraryLoader LOADER = new LibraryLoader("opusJNI");
 
   private OpusLibrary() {}
 
diff --git a/extensions/opus/src/main/jni/Android.mk b/extensions/opus/src/main/jni/Android.mk
index 2ceb8fc4f7..9d1e4fe726 100644
--- a/extensions/opus/src/main/jni/Android.mk
+++ b/extensions/opus/src/main/jni/Android.mk
@@ -17,7 +17,7 @@
 WORKING_DIR := $(call my-dir)
 include $(CLEAR_VARS)
 
-# build libopus.so
+# build libopus.a
 LOCAL_PATH := $(WORKING_DIR)
 include libopus.mk
 
@@ -29,5 +29,5 @@ LOCAL_ARM_MODE := arm
 LOCAL_CPP_EXTENSION := .cc
 LOCAL_SRC_FILES := opus_jni.cc
 LOCAL_LDLIBS := -llog -lz -lm
-LOCAL_SHARED_LIBRARIES := libopus
+LOCAL_STATIC_LIBRARIES := libopus
 include $(BUILD_SHARED_LIBRARY)
diff --git a/extensions/opus/src/main/jni/libopus.mk b/extensions/opus/src/main/jni/libopus.mk
index 0a5dd15b5a..672df600c0 100644
--- a/extensions/opus/src/main/jni/libopus.mk
+++ b/extensions/opus/src/main/jni/libopus.mk
@@ -47,4 +47,4 @@ endif
 
 LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
 
-include $(BUILD_SHARED_LIBRARY)
+include $(BUILD_STATIC_LIBRARY)
diff --git a/extensions/opus/src/main/jni/opus_jni.cc b/extensions/opus/src/main/jni/opus_jni.cc
index 8d9c1a4152..9042e4cb89 100644
--- a/extensions/opus/src/main/jni/opus_jni.cc
+++ b/extensions/opus/src/main/jni/opus_jni.cc
@@ -103,8 +103,16 @@ DECODER_FUNC(jint, opusDecode, jlong jDecoder, jlong jTimeUs,
       kMaxOpusOutputPacketSizeSamples * kBytesPerSample * channelCount;
 
   env->CallObjectMethod(jOutputBuffer, outputBufferInit, jTimeUs, outputSize);
+  if (env->ExceptionCheck()) {
+    // Exception is thrown in Java when returning from the native call.
+    return -1;
+  }
   const jobject jOutputBufferData = env->CallObjectMethod(jOutputBuffer,
       outputBufferInit, jTimeUs, outputSize);
+  if (env->ExceptionCheck()) {
+    // Exception is thrown in Java when returning from the native call.
+    return -1;
+  }
 
   int16_t* outputBufferData = reinterpret_cast<int16_t*>(
       env->GetDirectBufferAddress(jOutputBufferData));
diff --git a/extensions/rtmp/README.md b/extensions/rtmp/README.md
index fb822b8326..b222bdabd9 100644
--- a/extensions/rtmp/README.md
+++ b/extensions/rtmp/README.md
@@ -20,10 +20,10 @@ Android, which is licensed separately.
 The easiest way to use the extension is to add it as a gradle dependency:
 
 ```gradle
-compile 'com.google.android.exoplayer:extension-rtmp:rX.X.X'
+implementation 'com.google.android.exoplayer:extension-rtmp:2.X.X'
 ```
 
-where `rX.X.X` is the version, which must match the version of the ExoPlayer
+where `2.X.X` is the version, which must match the version of the ExoPlayer
 library being used.
 
 Alternatively, you can clone the ExoPlayer repository and depend on the module
diff --git a/extensions/rtmp/build.gradle b/extensions/rtmp/build.gradle
index 7687f03e32..c34e0b9999 100644
--- a/extensions/rtmp/build.gradle
+++ b/extensions/rtmp/build.gradle
@@ -25,8 +25,9 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile 'net.butterflytv.utils:rtmp-client:3.0.0'
+    implementation project(modulePrefix + 'library-core')
+    implementation 'net.butterflytv.utils:rtmp-client:3.0.1'
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
 }
 
 ext {
diff --git a/extensions/vp9/README.md b/extensions/vp9/README.md
index 941b413c09..9601829c91 100644
--- a/extensions/vp9/README.md
+++ b/extensions/vp9/README.md
@@ -28,7 +28,7 @@ EXOPLAYER_ROOT="$(pwd)"
 VP9_EXT_PATH="${EXOPLAYER_ROOT}/extensions/vp9/src/main"
 ```
 
-* Download the [Android NDK][] and set its location in an environment variable:
+* Download the [Android NDK][] and set its location in an environment variable.
 
 ```
 NDK_PATH="<path to Android NDK>"
@@ -70,6 +70,7 @@ ${NDK_PATH}/ndk-build APP_ABI=all -j4
 
 [top level README]: https://github.com/google/ExoPlayer/blob/release-v2/README.md
 [Android NDK]: https://developer.android.com/tools/sdk/ndk/index.html
+[#3520]: https://github.com/google/ExoPlayer/issues/3520
 
 ## Notes ##
 
diff --git a/extensions/vp9/build.gradle b/extensions/vp9/build.gradle
index de6dc65f74..7dc95b388f 100644
--- a/extensions/vp9/build.gradle
+++ b/extensions/vp9/build.gradle
@@ -31,7 +31,9 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    androidTestImplementation 'com.google.truth:truth:' + truthVersion
 }
 
 ext {
diff --git a/extensions/vp9/src/androidTest/AndroidManifest.xml b/extensions/vp9/src/androidTest/AndroidManifest.xml
index f29381a320..152ce2f533 100644
--- a/extensions/vp9/src/androidTest/AndroidManifest.xml
+++ b/extensions/vp9/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.ext.vp9.test">
 
-  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="27"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
index c2c1867a90..09701f9542 100644
--- a/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
+++ b/extensions/vp9/src/androidTest/java/com/google/android/exoplayer2/ext/vp9/VpxPlaybackTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import android.content.Context;
 import android.net.Uri;
 import android.os.Looper;
@@ -27,6 +29,7 @@
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
 
@@ -42,6 +45,14 @@
 
   private static final String TAG = "VpxPlaybackTest";
 
+  @Override
+  protected void setUp() throws Exception {
+    super.setUp();
+    if (!VpxLibrary.isAvailable()) {
+      fail("Vpx library not available.");
+    }
+  }
+
   public void testBasicPlayback() throws ExoPlaybackException {
     playUri(BEAR_URI);
   }
@@ -64,8 +75,8 @@ public void testInvalidBitstream() {
       playUri(INVALID_BITSTREAM_URI);
       fail();
     } catch (Exception e) {
-      assertNotNull(e.getCause());
-      assertTrue(e.getCause() instanceof VpxDecoderException);
+      assertThat(e.getCause()).isNotNull();
+      assertThat(e.getCause()).isInstanceOf(VpxDecoderException.class);
     }
   }
 
@@ -105,15 +116,16 @@ public void run() {
       DefaultTrackSelector trackSelector = new DefaultTrackSelector();
       player = ExoPlayerFactory.newInstance(new Renderer[] {videoRenderer}, trackSelector);
       player.addListener(this);
-      ExtractorMediaSource mediaSource = new ExtractorMediaSource(
-          uri,
-          new DefaultDataSourceFactory(context, "ExoPlayerExtVp9Test"),
-          MatroskaExtractor.FACTORY,
-          null,
-          null);
-      player.sendMessages(new ExoPlayer.ExoPlayerMessage(videoRenderer,
-          LibvpxVideoRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER,
-          new VpxVideoSurfaceView(context)));
+      MediaSource mediaSource =
+          new ExtractorMediaSource.Factory(
+                  new DefaultDataSourceFactory(context, "ExoPlayerExtVp9Test"))
+              .setExtractorsFactory(MatroskaExtractor.FACTORY)
+              .createMediaSource(uri);
+      player
+          .createMessage(videoRenderer)
+          .setType(LibvpxVideoRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER)
+          .setPayload(new VpxVideoSurfaceView(context))
+          .send();
       player.prepare(mediaSource);
       player.setPlayWhenReady(true);
       Looper.loop();
@@ -132,7 +144,6 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
         Looper.myLooper().quit();
       }
     }
-
   }
 
 }
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
index dd303af0d8..4d75f6076b 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/LibvpxVideoRenderer.java
@@ -20,7 +20,9 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.CallSuper;
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
@@ -28,6 +30,7 @@
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmSession;
@@ -45,8 +48,19 @@
 
 /**
  * Decodes and renders video using the native VP9 decoder.
+ *
+ * <p>This renderer accepts the following messages sent via {@link ExoPlayer#createMessage(Target)}
+ * on the playback thread:
+ *
+ * <ul>
+ *   <li>Message with type {@link C#MSG_SET_SURFACE} to set the output surface. The message payload
+ *       should be the target {@link Surface}, or null.
+ *   <li>Message with type {@link #MSG_SET_OUTPUT_BUFFER_RENDERER} to set the output buffer
+ *       renderer. The message payload should be the target {@link VpxOutputBufferRenderer}, or
+ *       null.
+ * </ul>
  */
-public final class LibvpxVideoRenderer extends BaseRenderer {
+public class LibvpxVideoRenderer extends BaseRenderer {
 
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({REINITIALIZATION_STATE_NONE, REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM,
@@ -70,9 +84,9 @@
   private static final int REINITIALIZATION_STATE_WAIT_END_OF_STREAM = 2;
 
   /**
-   * The type of a message that can be passed to an instance of this class via
-   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-   * should be the target {@link VpxOutputBufferRenderer}, or null.
+   * The type of a message that can be passed to an instance of this class via {@link
+   * ExoPlayer#createMessage(Target)}. The message payload should be the target {@link
+   * VpxOutputBufferRenderer}, or null.
    */
   public static final int MSG_SET_OUTPUT_BUFFER_RENDERER = C.MSG_CUSTOM_BASE;
 
@@ -84,7 +98,7 @@
    * The number of output buffers. The renderer may limit the minimum possible value due to
    * requiring multiple output buffers to be dequeued at a time for it to make progress.
    */
-  private static final int NUM_OUTPUT_BUFFERS = 16;
+  private static final int NUM_OUTPUT_BUFFERS = 8;
   /**
    * The initial input buffer size. Input buffers are reallocated dynamically if this value is
    * insufficient.
@@ -92,6 +106,7 @@
   private static final int INITIAL_INPUT_BUFFER_SIZE = 768 * 1024; // Value based on cs/SoftVpx.cpp.
 
   private final boolean scaleToFit;
+  private final boolean disableLoopFilter;
   private final long allowedJoiningTimeMs;
   private final int maxDroppedFramesToNotify;
   private final boolean playClearSamplesWithoutKeys;
@@ -100,12 +115,10 @@
   private final DecoderInputBuffer flagsOnlyBuffer;
   private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
 
-  private DecoderCounters decoderCounters;
   private Format format;
   private VpxDecoder decoder;
   private VpxInputBuffer inputBuffer;
   private VpxOutputBuffer outputBuffer;
-  private VpxOutputBuffer nextOutputBuffer;
   private DrmSession<ExoMediaCrypto> drmSession;
   private DrmSession<ExoMediaCrypto> pendingDrmSession;
 
@@ -114,7 +127,6 @@
 
   private Bitmap bitmap;
   private boolean renderedFirstFrame;
-  private boolean forceRenderFrame;
   private long joiningDeadlineMs;
   private Surface surface;
   private VpxOutputBufferRenderer outputBufferRenderer;
@@ -130,6 +142,9 @@
   private int droppedFrames;
   private int consecutiveDroppedFrameCount;
   private int buffersInCodecCount;
+  private long lastRenderTimeUs;
+
+  protected DecoderCounters decoderCounters;
 
   /**
    * @param scaleToFit Whether video frames should be scaled to fit when rendering.
@@ -154,7 +169,7 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
       Handler eventHandler, VideoRendererEventListener eventListener,
       int maxDroppedFramesToNotify) {
     this(scaleToFit, allowedJoiningTimeMs, eventHandler, eventListener, maxDroppedFramesToNotify,
-        null, false);
+        null, false, false);
   }
 
   /**
@@ -173,13 +188,15 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
    *     begin in parallel with key acquisition. This parameter specifies whether the renderer is
    *     permitted to play clear regions of encrypted media files before {@code drmSessionManager}
    *     has obtained the keys necessary to decrypt encrypted regions of the media.
+   * @param disableLoopFilter Disable the libvpx in-loop smoothing filter.
    */
   public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
       Handler eventHandler, VideoRendererEventListener eventListener,
       int maxDroppedFramesToNotify, DrmSessionManager<ExoMediaCrypto> drmSessionManager,
-      boolean playClearSamplesWithoutKeys) {
+      boolean playClearSamplesWithoutKeys, boolean disableLoopFilter) {
     super(C.TRACK_TYPE_VIDEO);
     this.scaleToFit = scaleToFit;
+    this.disableLoopFilter = disableLoopFilter;
     this.allowedJoiningTimeMs = allowedJoiningTimeMs;
     this.maxDroppedFramesToNotify = maxDroppedFramesToNotify;
     this.drmSessionManager = drmSessionManager;
@@ -193,6 +210,8 @@ public LibvpxVideoRenderer(boolean scaleToFit, long allowedJoiningTimeMs,
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
   }
 
+  // BaseRenderer implementation.
+
   @Override
   public int supportsFormat(Format format) {
     if (!VpxLibrary.isAvailable() || !MimeTypes.VIDEO_VP9.equalsIgnoreCase(format.sampleMimeType)) {
@@ -234,7 +253,7 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
       try {
         // Rendering loop.
         TraceUtil.beginSection("drainAndFeed");
-        while (drainOutputBuffer(positionUs)) {}
+        while (drainOutputBuffer(positionUs, elapsedRealtimeUs)) {}
         while (feedInputBuffer()) {}
         TraceUtil.endSection();
       } catch (VpxDecoderException e) {
@@ -244,273 +263,6 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     }
   }
 
-  private boolean drainOutputBuffer(long positionUs) throws ExoPlaybackException,
-      VpxDecoderException {
-    // Acquire outputBuffer either from nextOutputBuffer or from the decoder.
-    if (outputBuffer == null) {
-      if (nextOutputBuffer != null) {
-        outputBuffer = nextOutputBuffer;
-        nextOutputBuffer = null;
-      } else {
-        outputBuffer = decoder.dequeueOutputBuffer();
-      }
-      if (outputBuffer == null) {
-        return false;
-      }
-      decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;
-      buffersInCodecCount -= outputBuffer.skippedOutputBufferCount;
-    }
-
-    if (nextOutputBuffer == null) {
-      nextOutputBuffer = decoder.dequeueOutputBuffer();
-    }
-
-    if (outputBuffer.isEndOfStream()) {
-      if (decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
-        // We're waiting to re-initialize the decoder, and have now processed all final buffers.
-        releaseDecoder();
-        maybeInitDecoder();
-      } else {
-        outputBuffer.release();
-        outputBuffer = null;
-        outputStreamEnded = true;
-      }
-      return false;
-    }
-
-    if (outputMode == VpxDecoder.OUTPUT_MODE_NONE) {
-      // Skip frames in sync with playback, so we'll be at the right frame if the mode changes.
-      if (isBufferLate(outputBuffer.timeUs - positionUs)) {
-        forceRenderFrame = false;
-        skipBuffer();
-        buffersInCodecCount--;
-        return true;
-      }
-      return false;
-    }
-
-    if (forceRenderFrame) {
-      forceRenderFrame = false;
-      renderBuffer();
-      buffersInCodecCount--;
-      return true;
-    }
-
-    final long nextOutputBufferTimeUs =
-        nextOutputBuffer != null && !nextOutputBuffer.isEndOfStream()
-            ? nextOutputBuffer.timeUs : C.TIME_UNSET;
-
-    long earlyUs = outputBuffer.timeUs - positionUs;
-    if (shouldDropBuffersToKeyframe(earlyUs) && maybeDropBuffersToKeyframe(positionUs)) {
-      forceRenderFrame = true;
-      return false;
-    } else if (shouldDropOutputBuffer(
-        outputBuffer.timeUs, nextOutputBufferTimeUs, positionUs, joiningDeadlineMs)) {
-      dropBuffer();
-      buffersInCodecCount--;
-      return true;
-    }
-
-    // If we have yet to render a frame to the current output (either initially or immediately
-    // following a seek), render one irrespective of the state or current position.
-    if (!renderedFirstFrame
-        || (getState() == STATE_STARTED && earlyUs <= 30000)) {
-      renderBuffer();
-      buffersInCodecCount--;
-    }
-    return false;
-  }
-
-  /**
-   * Returns whether the current frame should be dropped.
-   *
-   * @param outputBufferTimeUs The timestamp of the current output buffer.
-   * @param nextOutputBufferTimeUs The timestamp of the next output buffer or {@link C#TIME_UNSET}
-   *     if the next output buffer is unavailable.
-   * @param positionUs The current playback position.
-   * @param joiningDeadlineMs The joining deadline.
-   * @return Returns whether to drop the current output buffer.
-   */
-  private boolean shouldDropOutputBuffer(long outputBufferTimeUs, long nextOutputBufferTimeUs,
-      long positionUs, long joiningDeadlineMs) {
-    return isBufferLate(outputBufferTimeUs - positionUs)
-        && (joiningDeadlineMs != C.TIME_UNSET || nextOutputBufferTimeUs != C.TIME_UNSET);
-  }
-
-  /**
-   * Returns whether to drop all buffers from the buffer being processed to the keyframe at or after
-   * the current playback position, if possible.
-   *
-   * @param earlyUs The time until the current buffer should be presented in microseconds. A
-   *     negative value indicates that the buffer is late.
-   */
-  private boolean shouldDropBuffersToKeyframe(long earlyUs) {
-    return isBufferVeryLate(earlyUs);
-  }
-
-  private void renderBuffer() {
-    int bufferMode = outputBuffer.mode;
-    boolean renderRgb = bufferMode == VpxDecoder.OUTPUT_MODE_RGB && surface != null;
-    boolean renderYuv = bufferMode == VpxDecoder.OUTPUT_MODE_YUV && outputBufferRenderer != null;
-    if (!renderRgb && !renderYuv) {
-      dropBuffer();
-    } else {
-      maybeNotifyVideoSizeChanged(outputBuffer.width, outputBuffer.height);
-      if (renderRgb) {
-        renderRgbFrame(outputBuffer, scaleToFit);
-        outputBuffer.release();
-      } else /* renderYuv */ {
-        outputBufferRenderer.setOutputBuffer(outputBuffer);
-        // The renderer will release the buffer.
-      }
-      outputBuffer = null;
-      consecutiveDroppedFrameCount = 0;
-      decoderCounters.renderedOutputBufferCount++;
-      maybeNotifyRenderedFirstFrame();
-    }
-  }
-
-  private void dropBuffer() {
-    updateDroppedBufferCounters(1);
-    outputBuffer.release();
-    outputBuffer = null;
-  }
-
-  private boolean maybeDropBuffersToKeyframe(long positionUs) throws ExoPlaybackException {
-    int droppedSourceBufferCount = skipSource(positionUs);
-    if (droppedSourceBufferCount == 0) {
-      return false;
-    }
-    decoderCounters.droppedToKeyframeCount++;
-    // We dropped some buffers to catch up, so update the decoder counters and flush the codec,
-    // which releases all pending buffers buffers including the current output buffer.
-    updateDroppedBufferCounters(buffersInCodecCount + droppedSourceBufferCount);
-    flushDecoder();
-    return true;
-  }
-
-  private void updateDroppedBufferCounters(int droppedBufferCount) {
-    decoderCounters.droppedBufferCount += droppedBufferCount;
-    droppedFrames += droppedBufferCount;
-    consecutiveDroppedFrameCount += droppedBufferCount;
-    decoderCounters.maxConsecutiveDroppedBufferCount = Math.max(consecutiveDroppedFrameCount,
-        decoderCounters.maxConsecutiveDroppedBufferCount);
-    if (droppedFrames >= maxDroppedFramesToNotify) {
-      maybeNotifyDroppedFrames();
-    }
-  }
-
-  private void skipBuffer() {
-    decoderCounters.skippedOutputBufferCount++;
-    outputBuffer.release();
-    outputBuffer = null;
-  }
-
-  private void renderRgbFrame(VpxOutputBuffer outputBuffer, boolean scale) {
-    if (bitmap == null || bitmap.getWidth() != outputBuffer.width
-        || bitmap.getHeight() != outputBuffer.height) {
-      bitmap = Bitmap.createBitmap(outputBuffer.width, outputBuffer.height, Bitmap.Config.RGB_565);
-    }
-    bitmap.copyPixelsFromBuffer(outputBuffer.data);
-    Canvas canvas = surface.lockCanvas(null);
-    if (scale) {
-      canvas.scale(((float) canvas.getWidth()) / outputBuffer.width,
-          ((float) canvas.getHeight()) / outputBuffer.height);
-    }
-    canvas.drawBitmap(bitmap, 0, 0, null);
-    surface.unlockCanvasAndPost(canvas);
-  }
-
-  private boolean feedInputBuffer() throws VpxDecoderException, ExoPlaybackException {
-    if (decoder == null || decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM
-        || inputStreamEnded) {
-      // We need to reinitialize the decoder or the input stream has ended.
-      return false;
-    }
-
-    if (inputBuffer == null) {
-      inputBuffer = decoder.dequeueInputBuffer();
-      if (inputBuffer == null) {
-        return false;
-      }
-    }
-
-    if (decoderReinitializationState == REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM) {
-      inputBuffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
-      decoder.queueInputBuffer(inputBuffer);
-      inputBuffer = null;
-      decoderReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
-      return false;
-    }
-
-    int result;
-    if (waitingForKeys) {
-      // We've already read an encrypted sample into buffer, and are waiting for keys.
-      result = C.RESULT_BUFFER_READ;
-    } else {
-      result = readSource(formatHolder, inputBuffer, false);
-    }
-
-    if (result == C.RESULT_NOTHING_READ) {
-      return false;
-    }
-    if (result == C.RESULT_FORMAT_READ) {
-      onInputFormatChanged(formatHolder.format);
-      return true;
-    }
-    if (inputBuffer.isEndOfStream()) {
-      inputStreamEnded = true;
-      decoder.queueInputBuffer(inputBuffer);
-      inputBuffer = null;
-      return false;
-    }
-    boolean bufferEncrypted = inputBuffer.isEncrypted();
-    waitingForKeys = shouldWaitForKeys(bufferEncrypted);
-    if (waitingForKeys) {
-      return false;
-    }
-    inputBuffer.flip();
-    inputBuffer.colorInfo = formatHolder.format.colorInfo;
-    decoder.queueInputBuffer(inputBuffer);
-    buffersInCodecCount++;
-    decoderReceivedBuffers = true;
-    decoderCounters.inputBufferCount++;
-    inputBuffer = null;
-    return true;
-  }
-
-  private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
-    if (drmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
-      return false;
-    }
-    @DrmSession.State int drmSessionState = drmSession.getState();
-    if (drmSessionState == DrmSession.STATE_ERROR) {
-      throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
-    }
-    return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
-  }
-
-  private void flushDecoder() throws ExoPlaybackException {
-    waitingForKeys = false;
-    forceRenderFrame = false;
-    buffersInCodecCount = 0;
-    if (decoderReinitializationState != REINITIALIZATION_STATE_NONE) {
-      releaseDecoder();
-      maybeInitDecoder();
-    } else {
-      inputBuffer = null;
-      if (outputBuffer != null) {
-        outputBuffer.release();
-        outputBuffer = null;
-      }
-      if (nextOutputBuffer != null) {
-        nextOutputBuffer.release();
-        nextOutputBuffer = null;
-      }
-      decoder.flush();
-      decoderReceivedBuffers = false;
-    }
-  }
 
   @Override
   public boolean isEnded() {
@@ -566,6 +318,7 @@ protected void onPositionReset(long positionUs, boolean joining) throws ExoPlayb
   protected void onStarted() {
     droppedFrames = 0;
     droppedFrameAccumulationStartTimeMs = SystemClock.elapsedRealtime();
+    lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
   }
 
   @Override
@@ -602,59 +355,70 @@ protected void onDisabled() {
     }
   }
 
-  private void maybeInitDecoder() throws ExoPlaybackException {
-    if (decoder != null) {
-      return;
-    }
+  /**
+   * Called when a decoder has been created and configured.
+   *
+   * <p>The default implementation is a no-op.
+   *
+   * @param name The name of the decoder that was initialized.
+   * @param initializedTimestampMs {@link SystemClock#elapsedRealtime()} when initialization
+   *     finished.
+   * @param initializationDurationMs The time taken to initialize the decoder, in milliseconds.
+   */
+  @CallSuper
+  protected void onDecoderInitialized(
+      String name, long initializedTimestampMs, long initializationDurationMs) {
+    eventDispatcher.decoderInitialized(name, initializedTimestampMs, initializationDurationMs);
+  }
 
-    drmSession = pendingDrmSession;
-    ExoMediaCrypto mediaCrypto = null;
-    if (drmSession != null) {
-      mediaCrypto = drmSession.getMediaCrypto();
-      if (mediaCrypto == null) {
-        DrmSessionException drmError = drmSession.getError();
-        if (drmError != null) {
-          throw ExoPlaybackException.createForRenderer(drmError, getIndex());
-        }
-        // The drm session isn't open yet.
-        return;
+  /**
+   * Flushes the decoder.
+   *
+   * @throws ExoPlaybackException If an error occurs reinitializing a decoder.
+   */
+  @CallSuper
+  protected void flushDecoder() throws ExoPlaybackException {
+    waitingForKeys = false;
+    buffersInCodecCount = 0;
+    if (decoderReinitializationState != REINITIALIZATION_STATE_NONE) {
+      releaseDecoder();
+      maybeInitDecoder();
+    } else {
+      inputBuffer = null;
+      if (outputBuffer != null) {
+        outputBuffer.release();
+        outputBuffer = null;
       }
-    }
-
-    try {
-      long codecInitializingTimestamp = SystemClock.elapsedRealtime();
-      TraceUtil.beginSection("createVpxDecoder");
-      decoder = new VpxDecoder(NUM_INPUT_BUFFERS, NUM_OUTPUT_BUFFERS, INITIAL_INPUT_BUFFER_SIZE,
-          mediaCrypto);
-      decoder.setOutputMode(outputMode);
-      TraceUtil.endSection();
-      long codecInitializedTimestamp = SystemClock.elapsedRealtime();
-      eventDispatcher.decoderInitialized(decoder.getName(), codecInitializedTimestamp,
-          codecInitializedTimestamp - codecInitializingTimestamp);
-      decoderCounters.decoderInitCount++;
-    } catch (VpxDecoderException e) {
-      throw ExoPlaybackException.createForRenderer(e, getIndex());
+      decoder.flush();
+      decoderReceivedBuffers = false;
     }
   }
 
-  private void releaseDecoder() {
+  /** Releases the decoder. */
+  @CallSuper
+  protected void releaseDecoder() {
     if (decoder == null) {
       return;
     }
 
     inputBuffer = null;
     outputBuffer = null;
-    nextOutputBuffer = null;
     decoder.release();
     decoder = null;
     decoderCounters.decoderReleaseCount++;
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
     decoderReceivedBuffers = false;
-    forceRenderFrame = false;
     buffersInCodecCount = 0;
   }
 
-  private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
+  /**
+   * Called when a new format is read from the upstream source.
+   *
+   * @param newFormat The new format.
+   * @throws ExoPlaybackException If an error occurs (re-)initializing the decoder.
+   */
+  @CallSuper
+  protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {
     Format oldFormat = format;
     format = newFormat;
 
@@ -689,6 +453,156 @@ private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException
     eventDispatcher.inputFormatChanged(format);
   }
 
+  /**
+   * Called immediately before an input buffer is queued into the decoder.
+   *
+   * <p>The default implementation is a no-op.
+   *
+   * @param buffer The buffer that will be queued.
+   */
+  protected void onQueueInputBuffer(VpxInputBuffer buffer) {
+    // Do nothing.
+  }
+
+  /**
+   * Called when an output buffer is successfully processed.
+   *
+   * @param presentationTimeUs The timestamp associated with the output buffer.
+   */
+  @CallSuper
+  protected void onProcessedOutputBuffer(long presentationTimeUs) {
+    buffersInCodecCount--;
+  }
+
+  /**
+   * Returns whether the buffer being processed should be dropped.
+   *
+   * @param earlyUs The time until the buffer should be presented in microseconds. A negative value
+   *     indicates that the buffer is late.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   */
+  protected boolean shouldDropOutputBuffer(long earlyUs, long elapsedRealtimeUs) {
+    return isBufferLate(earlyUs);
+  }
+
+  /**
+   * Returns whether to drop all buffers from the buffer being processed to the keyframe at or after
+   * the current playback position, if possible.
+   *
+   * @param earlyUs The time until the current buffer should be presented in microseconds. A
+   *     negative value indicates that the buffer is late.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   */
+  protected boolean shouldDropBuffersToKeyframe(long earlyUs, long elapsedRealtimeUs) {
+    return isBufferVeryLate(earlyUs);
+  }
+
+  /**
+   * Returns whether to force rendering an output buffer.
+   *
+   * @param earlyUs The time until the current buffer should be presented in microseconds. A
+   *     negative value indicates that the buffer is late.
+   * @param elapsedSinceLastRenderUs The elapsed time since the last output buffer was rendered, in
+   *     microseconds.
+   * @return Returns whether to force rendering an output buffer.
+   */
+  protected boolean shouldForceRenderOutputBuffer(long earlyUs, long elapsedSinceLastRenderUs) {
+    return isBufferLate(earlyUs) && elapsedSinceLastRenderUs > 100000;
+  }
+
+  /**
+   * Skips the specified output buffer and releases it.
+   *
+   * @param outputBuffer The output buffer to skip.
+   */
+  protected void skipOutputBuffer(VpxOutputBuffer outputBuffer) {
+    decoderCounters.skippedOutputBufferCount++;
+    outputBuffer.release();
+  }
+
+  /**
+   * Drops the specified output buffer and releases it.
+   *
+   * @param outputBuffer The output buffer to drop.
+   */
+  protected void dropOutputBuffer(VpxOutputBuffer outputBuffer) {
+    updateDroppedBufferCounters(1);
+    outputBuffer.release();
+  }
+
+  /**
+   * Renders the specified output buffer.
+   *
+   * <p>The implementation of this method takes ownership of the output buffer and is responsible
+   * for calling {@link VpxOutputBuffer#release()} either immediately or in the future.
+   *
+   * @param outputBuffer The buffer to render.
+   */
+  protected void renderOutputBuffer(VpxOutputBuffer outputBuffer) {
+    int bufferMode = outputBuffer.mode;
+    boolean renderRgb = bufferMode == VpxDecoder.OUTPUT_MODE_RGB && surface != null;
+    boolean renderYuv = bufferMode == VpxDecoder.OUTPUT_MODE_YUV && outputBufferRenderer != null;
+    lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
+    if (!renderRgb && !renderYuv) {
+      dropOutputBuffer(outputBuffer);
+    } else {
+      maybeNotifyVideoSizeChanged(outputBuffer.width, outputBuffer.height);
+      if (renderRgb) {
+        renderRgbFrame(outputBuffer, scaleToFit);
+        outputBuffer.release();
+      } else /* renderYuv */ {
+        outputBufferRenderer.setOutputBuffer(outputBuffer);
+        // The renderer will release the buffer.
+      }
+      consecutiveDroppedFrameCount = 0;
+      decoderCounters.renderedOutputBufferCount++;
+      maybeNotifyRenderedFirstFrame();
+    }
+  }
+
+  /**
+   * Drops frames from the current output buffer to the next keyframe at or before the playback
+   * position. If no such keyframe exists, as the playback position is inside the same group of
+   * pictures as the buffer being processed, returns {@code false}. Returns {@code true} otherwise.
+   *
+   * @param positionUs The current playback position, in microseconds.
+   * @return Whether any buffers were dropped.
+   * @throws ExoPlaybackException If an error occurs flushing the decoder.
+   */
+  protected boolean maybeDropBuffersToKeyframe(long positionUs) throws ExoPlaybackException {
+    int droppedSourceBufferCount = skipSource(positionUs);
+    if (droppedSourceBufferCount == 0) {
+      return false;
+    }
+    decoderCounters.droppedToKeyframeCount++;
+    // We dropped some buffers to catch up, so update the decoder counters and flush the decoder,
+    // which releases all pending buffers buffers including the current output buffer.
+    updateDroppedBufferCounters(buffersInCodecCount + droppedSourceBufferCount);
+    flushDecoder();
+    return true;
+  }
+
+  /**
+   * Updates decoder counters to reflect that {@code droppedBufferCount} additional buffers were
+   * dropped.
+   *
+   * @param droppedBufferCount The number of additional dropped buffers.
+   */
+  protected void updateDroppedBufferCounters(int droppedBufferCount) {
+    decoderCounters.droppedBufferCount += droppedBufferCount;
+    droppedFrames += droppedBufferCount;
+    consecutiveDroppedFrameCount += droppedBufferCount;
+    decoderCounters.maxConsecutiveDroppedBufferCount =
+        Math.max(consecutiveDroppedFrameCount, decoderCounters.maxConsecutiveDroppedBufferCount);
+    if (droppedFrames >= maxDroppedFramesToNotify) {
+      maybeNotifyDroppedFrames();
+    }
+  }
+
+  // PlayerMessage.Target implementation.
+
   @Override
   public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
     if (messageType == C.MSG_SET_SURFACE) {
@@ -700,7 +614,10 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
     }
   }
 
-  private void setOutput(Surface surface, VpxOutputBufferRenderer outputBufferRenderer) {
+  // Internal methods.
+
+  private void setOutput(
+      @Nullable Surface surface, @Nullable VpxOutputBufferRenderer outputBufferRenderer) {
     // At most one output may be non-null. Both may be null if the output is being cleared.
     Assertions.checkState(surface == null || outputBufferRenderer == null);
     if (this.surface != surface || this.outputBufferRenderer != outputBufferRenderer) {
@@ -734,6 +651,231 @@ private void setOutput(Surface surface, VpxOutputBufferRenderer outputBufferRend
     }
   }
 
+  private void maybeInitDecoder() throws ExoPlaybackException {
+    if (decoder != null) {
+      return;
+    }
+
+    drmSession = pendingDrmSession;
+    ExoMediaCrypto mediaCrypto = null;
+    if (drmSession != null) {
+      mediaCrypto = drmSession.getMediaCrypto();
+      if (mediaCrypto == null) {
+        DrmSessionException drmError = drmSession.getError();
+        if (drmError != null) {
+          // Continue for now. We may be able to avoid failure if the session recovers, or if a new
+          // input format causes the session to be replaced before it's used.
+        } else {
+          // The drm session isn't open yet.
+          return;
+        }
+      }
+    }
+
+    try {
+      long decoderInitializingTimestamp = SystemClock.elapsedRealtime();
+      TraceUtil.beginSection("createVpxDecoder");
+      decoder =
+          new VpxDecoder(
+              NUM_INPUT_BUFFERS,
+              NUM_OUTPUT_BUFFERS,
+              INITIAL_INPUT_BUFFER_SIZE,
+              mediaCrypto,
+              disableLoopFilter);
+      decoder.setOutputMode(outputMode);
+      TraceUtil.endSection();
+      long decoderInitializedTimestamp = SystemClock.elapsedRealtime();
+      onDecoderInitialized(
+          decoder.getName(),
+          decoderInitializedTimestamp,
+          decoderInitializedTimestamp - decoderInitializingTimestamp);
+      decoderCounters.decoderInitCount++;
+    } catch (VpxDecoderException e) {
+      throw ExoPlaybackException.createForRenderer(e, getIndex());
+    }
+  }
+
+  private boolean feedInputBuffer() throws VpxDecoderException, ExoPlaybackException {
+    if (decoder == null
+        || decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM
+        || inputStreamEnded) {
+      // We need to reinitialize the decoder or the input stream has ended.
+      return false;
+    }
+
+    if (inputBuffer == null) {
+      inputBuffer = decoder.dequeueInputBuffer();
+      if (inputBuffer == null) {
+        return false;
+      }
+    }
+
+    if (decoderReinitializationState == REINITIALIZATION_STATE_SIGNAL_END_OF_STREAM) {
+      inputBuffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer = null;
+      decoderReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
+      return false;
+    }
+
+    int result;
+    if (waitingForKeys) {
+      // We've already read an encrypted sample into buffer, and are waiting for keys.
+      result = C.RESULT_BUFFER_READ;
+    } else {
+      result = readSource(formatHolder, inputBuffer, false);
+    }
+
+    if (result == C.RESULT_NOTHING_READ) {
+      return false;
+    }
+    if (result == C.RESULT_FORMAT_READ) {
+      onInputFormatChanged(formatHolder.format);
+      return true;
+    }
+    if (inputBuffer.isEndOfStream()) {
+      inputStreamEnded = true;
+      decoder.queueInputBuffer(inputBuffer);
+      inputBuffer = null;
+      return false;
+    }
+    boolean bufferEncrypted = inputBuffer.isEncrypted();
+    waitingForKeys = shouldWaitForKeys(bufferEncrypted);
+    if (waitingForKeys) {
+      return false;
+    }
+    inputBuffer.flip();
+    inputBuffer.colorInfo = formatHolder.format.colorInfo;
+    onQueueInputBuffer(inputBuffer);
+    decoder.queueInputBuffer(inputBuffer);
+    buffersInCodecCount++;
+    decoderReceivedBuffers = true;
+    decoderCounters.inputBufferCount++;
+    inputBuffer = null;
+    return true;
+  }
+
+  /**
+   * Attempts to dequeue an output buffer from the decoder and, if successful, passes it to {@link
+   * #processOutputBuffer(long, long)}.
+   *
+   * @param positionUs The player's current position.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   * @return Whether it may be possible to drain more output data.
+   * @throws ExoPlaybackException If an error occurs draining the output buffer.
+   */
+  private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
+      throws ExoPlaybackException, VpxDecoderException {
+    if (outputBuffer == null) {
+      outputBuffer = decoder.dequeueOutputBuffer();
+      if (outputBuffer == null) {
+        return false;
+      }
+      decoderCounters.skippedOutputBufferCount += outputBuffer.skippedOutputBufferCount;
+      buffersInCodecCount -= outputBuffer.skippedOutputBufferCount;
+    }
+
+    if (outputBuffer.isEndOfStream()) {
+      if (decoderReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM) {
+        // We're waiting to re-initialize the decoder, and have now processed all final buffers.
+        releaseDecoder();
+        maybeInitDecoder();
+      } else {
+        outputBuffer.release();
+        outputBuffer = null;
+        outputStreamEnded = true;
+      }
+      return false;
+    }
+
+    boolean processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs);
+    if (processedOutputBuffer) {
+      onProcessedOutputBuffer(outputBuffer.timeUs);
+      outputBuffer = null;
+    }
+    return processedOutputBuffer;
+  }
+
+  /**
+   * Processes {@link #outputBuffer} by rendering it, skipping it or doing nothing, and returns
+   * whether it may be possible to process another output buffer.
+   *
+   * @param positionUs The player's current position.
+   * @param elapsedRealtimeUs {@link android.os.SystemClock#elapsedRealtime()} in microseconds,
+   *     measured at the start of the current iteration of the rendering loop.
+   * @return Whether it may be possible to drain another output buffer.
+   * @throws ExoPlaybackException If an error occurs processing the output buffer.
+   */
+  private boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs)
+      throws ExoPlaybackException {
+    long earlyUs = outputBuffer.timeUs - positionUs;
+    if (outputMode == VpxDecoder.OUTPUT_MODE_NONE) {
+      // Skip frames in sync with playback, so we'll be at the right frame if the mode changes.
+      if (isBufferLate(earlyUs)) {
+        skipOutputBuffer(outputBuffer);
+        return true;
+      }
+      return false;
+    }
+
+    long elapsedRealtimeNowUs = SystemClock.elapsedRealtime() * 1000;
+    boolean isStarted = getState() == STATE_STARTED;
+    if (!renderedFirstFrame
+        || (isStarted
+            && shouldForceRenderOutputBuffer(earlyUs, elapsedRealtimeNowUs - lastRenderTimeUs))) {
+      renderOutputBuffer(outputBuffer);
+      return true;
+    }
+
+    if (!isStarted) {
+      return false;
+    }
+
+    if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs)
+        && maybeDropBuffersToKeyframe(positionUs)) {
+      return false;
+    } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
+      dropOutputBuffer(outputBuffer);
+      return true;
+    }
+
+    if (earlyUs < 30000) {
+      renderOutputBuffer(outputBuffer);
+      return true;
+    }
+
+    return false;
+  }
+
+  private boolean shouldWaitForKeys(boolean bufferEncrypted) throws ExoPlaybackException {
+    if (drmSession == null || (!bufferEncrypted && playClearSamplesWithoutKeys)) {
+      return false;
+    }
+    @DrmSession.State int drmSessionState = drmSession.getState();
+    if (drmSessionState == DrmSession.STATE_ERROR) {
+      throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+    }
+    return drmSessionState != DrmSession.STATE_OPENED_WITH_KEYS;
+  }
+
+  private void renderRgbFrame(VpxOutputBuffer outputBuffer, boolean scale) {
+    if (bitmap == null
+        || bitmap.getWidth() != outputBuffer.width
+        || bitmap.getHeight() != outputBuffer.height) {
+      bitmap = Bitmap.createBitmap(outputBuffer.width, outputBuffer.height, Bitmap.Config.RGB_565);
+    }
+    bitmap.copyPixelsFromBuffer(outputBuffer.data);
+    Canvas canvas = surface.lockCanvas(null);
+    if (scale) {
+      canvas.scale(
+          ((float) canvas.getWidth()) / outputBuffer.width,
+          ((float) canvas.getHeight()) / outputBuffer.height);
+    }
+    canvas.drawBitmap(bitmap, 0, 0, null);
+    surface.unlockCanvasAndPost(canvas);
+  }
+
   private void setJoiningDeadlineMs() {
     joiningDeadlineMs = allowedJoiningTimeMs > 0
         ? (SystemClock.elapsedRealtime() + allowedJoiningTimeMs) : C.TIME_UNSET;
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
index ef999d5d2b..6f8c0a1918 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoder.java
@@ -49,10 +49,11 @@
    * @param initialInputBufferSize The initial size of each input buffer.
    * @param exoMediaCrypto The {@link ExoMediaCrypto} object required for decoding encrypted
    *     content. Maybe null and can be ignored if decoder does not handle encrypted content.
+   * @param disableLoopFilter Disable the libvpx in-loop smoothing filter.
    * @throws VpxDecoderException Thrown if an exception occurs when initializing the decoder.
    */
   public VpxDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBufferSize,
-      ExoMediaCrypto exoMediaCrypto) throws VpxDecoderException {
+      ExoMediaCrypto exoMediaCrypto, boolean disableLoopFilter) throws VpxDecoderException {
     super(new VpxInputBuffer[numInputBuffers], new VpxOutputBuffer[numOutputBuffers]);
     if (!VpxLibrary.isAvailable()) {
       throw new VpxDecoderException("Failed to load decoder native libraries.");
@@ -61,7 +62,7 @@ public VpxDecoder(int numInputBuffers, int numOutputBuffers, int initialInputBuf
     if (exoMediaCrypto != null && !VpxLibrary.vpxIsSecureDecodeSupported()) {
       throw new VpxDecoderException("Vpx decoder does not support secure decode.");
     }
-    vpxDecContext = vpxInit();
+    vpxDecContext = vpxInit(disableLoopFilter);
     if (vpxDecContext == 0) {
       throw new VpxDecoderException("Failed to initialize decoder");
     }
@@ -98,6 +99,11 @@ protected void releaseOutputBuffer(VpxOutputBuffer buffer) {
     super.releaseOutputBuffer(buffer);
   }
 
+  @Override
+  protected VpxDecoderException createUnexpectedDecodeException(Throwable error) {
+    return new VpxDecoderException("Unexpected decode error", error);
+  }
+
   @Override
   protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer,
       boolean reset) {
@@ -139,7 +145,7 @@ public void release() {
     vpxClose(vpxDecContext);
   }
 
-  private native long vpxInit();
+  private native long vpxInit(boolean disableLoopFilter);
   private native long vpxClose(long context);
   private native long vpxDecode(long context, ByteBuffer encoded, int length);
   private native long vpxSecureDecode(long context, ByteBuffer encoded, int length,
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoderException.java b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoderException.java
index 5f43b503ac..8de14629d3 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoderException.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer2/ext/vp9/VpxDecoderException.java
@@ -15,10 +15,8 @@
  */
 package com.google.android.exoplayer2.ext.vp9;
 
-/**
- * Thrown when a libvpx decoder error occurs.
- */
-public class VpxDecoderException extends Exception {
+/** Thrown when a libvpx decoder error occurs. */
+public final class VpxDecoderException extends Exception {
 
   /* package */ VpxDecoderException(String message) {
     super(message);
diff --git a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
index 5f058d0551..eab6862555 100755
--- a/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
+++ b/extensions/vp9/src/main/jni/generate_libvpx_android_configs.sh
@@ -102,7 +102,10 @@ for i in $(seq 0 ${limit}); do
   # configure and make
   echo "build_android_configs: "
   echo "configure ${config[${i}]} ${common_params}"
-  ../../libvpx/configure ${config[${i}]} ${common_params}
+  ../../libvpx/configure ${config[${i}]} ${common_params} --extra-cflags=" \
+    -isystem $ndk/sysroot/usr/include/arm-linux-androideabi \
+    -isystem $ndk/sysroot/usr/include \
+    "
   rm -f libvpx_srcs.txt
   for f in ${allowed_files}; do
     # the build system supports multiple different configurations. avoid
diff --git a/extensions/vp9/src/main/jni/vpx_jni.cc b/extensions/vp9/src/main/jni/vpx_jni.cc
index 5c480d1525..421b16d26d 100644
--- a/extensions/vp9/src/main/jni/vpx_jni.cc
+++ b/extensions/vp9/src/main/jni/vpx_jni.cc
@@ -218,7 +218,6 @@ static int convert_16_to_8_neon(const vpx_image_t* const img, jbyte* const data,
       dstV += 8;
     }
 
-    i *= 4;
     uint32_t randval = 0;
     while (i < uvWidth) {
       if (!randval) randval = random();
@@ -283,7 +282,7 @@ static void convert_16_to_8_standard(const vpx_image_t* const img,
   }
 }
 
-DECODER_FUNC(jlong, vpxInit) {
+DECODER_FUNC(jlong, vpxInit, jboolean disableLoopFilter) {
   vpx_codec_ctx_t* context = new vpx_codec_ctx_t();
   vpx_codec_dec_cfg_t cfg = {0, 0, 0};
   cfg.threads = android_getCpuCount();
@@ -295,6 +294,9 @@ DECODER_FUNC(jlong, vpxInit) {
     errorCode = err;
     return 0;
   }
+  if (disableLoopFilter) {
+    vpx_codec_control_(context, VP9_SET_SKIP_LOOP_FILTER, true);
+  }
 
   // Populate JNI References.
   const jclass outputBufferClass = env->FindClass(
@@ -360,7 +362,7 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     // resize buffer if required.
     jboolean initResult = env->CallBooleanMethod(jOutputBuffer, initForRgbFrame,
                                                  img->d_w, img->d_h);
-    if (initResult == JNI_FALSE) {
+    if (env->ExceptionCheck() || !initResult) {
       return -1;
     }
 
@@ -398,7 +400,7 @@ DECODER_FUNC(jint, vpxGetFrame, jlong jContext, jobject jOutputBuffer) {
     jboolean initResult = env->CallBooleanMethod(
         jOutputBuffer, initForYuvFrame, img->d_w, img->d_h,
         img->stride[VPX_PLANE_Y], img->stride[VPX_PLANE_U], colorspace);
-    if (initResult == JNI_FALSE) {
+    if (env->ExceptionCheck() || !initResult) {
       return -1;
     }
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 32ec7e3327..5559e8ccfa 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.4-all.zip
diff --git a/javadoc_combined.gradle b/javadoc_combined.gradle
index 1fec48ca25..aba4bf54bd 100644
--- a/javadoc_combined.gradle
+++ b/javadoc_combined.gradle
@@ -11,6 +11,8 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
+apply from: "${rootDir}/javadoc_util.gradle"
+
 class CombinedJavadocPlugin implements Plugin<Project> {
 
   static final String TASK_NAME = "generateCombinedJavadoc"
@@ -20,22 +22,32 @@ class CombinedJavadocPlugin implements Plugin<Project> {
     project.gradle.projectsEvaluated {
       Set<Project> libraryModules = getLibraryModules(project)
       if (!libraryModules.isEmpty()) {
-        String sdkDirectory = getSdkDirectory(libraryModules)
         project.task(TASK_NAME, type: Javadoc) {
           description = "Generates combined Javadoc."
           title = "ExoPlayer library"
           source = libraryModules.generateJavadoc.source
-          classpath = project.files(libraryModules.generateJavadoc.classpath)
+          classpath = project.files([])
           destinationDir = project.file("$project.buildDir/docs/javadoc")
           options {
-            links "http://docs.oracle.com/javase/7/docs/api/"
-            linksOffline "https://developer.android.com/reference",
-                         "${sdkDirectory}/docs/reference"
+            links "https://docs.oracle.com/javase/7/docs/api/",
+                "https://developer.android.com/reference"
             encoding = "UTF-8"
           }
           exclude "**/BuildConfig.java"
           exclude "**/R.java"
-          destinationDir project.file("$project.buildDir/docs/javadoc")
+          doFirst {
+            libraryModules.each { libraryModule ->
+              libraryModule.android.libraryVariants.all { variant ->
+                def name = variant.buildType.name
+                if (name.equals("release")) {
+                  classpath +=
+                      libraryModule.project.files(
+                          variant.javaCompile.classpath.files,
+                          libraryModule.project.android.getBootClasspath())
+                }
+              }
+            }
+          }
           doLast {
             libraryModules.each { libraryModule ->
               project.copy {
@@ -43,6 +55,7 @@ class CombinedJavadocPlugin implements Plugin<Project> {
                 into "${project.buildDir}/docs/javadoc"
               }
             }
+            project.fixJavadoc()
           }
         }
       }
@@ -57,12 +70,6 @@ class CombinedJavadocPlugin implements Plugin<Project> {
     }
   }
 
-  // Returns the Android SDK directory given a set of Android library modules.
-  private String getSdkDirectory(Set<Project> libraryModules) {
-    // We can retrieve the Android SDK directory from any module.
-    return libraryModules.iterator().next().android.sdkDirectory
-  }
-
 }
 
 apply plugin: CombinedJavadocPlugin
diff --git a/javadoc_library.gradle b/javadoc_library.gradle
index ea193e661c..a252b148c6 100644
--- a/javadoc_library.gradle
+++ b/javadoc_library.gradle
@@ -11,6 +11,8 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
+apply from: "${rootDir}/javadoc_util.gradle"
+
 android.libraryVariants.all { variant ->
     def name = variant.buildType.name
     if (!name.equals("release")) {
@@ -20,21 +22,26 @@ android.libraryVariants.all { variant ->
         description = "Generates Javadoc for the ${javadocTitle}."
         title = "ExoPlayer ${javadocTitle}"
         source = variant.javaCompile.source
-        classpath = files(variant.javaCompile.classpath.files,
-	                  project.android.getBootClasspath())
         options {
             links "http://docs.oracle.com/javase/7/docs/api/"
             linksOffline "https://developer.android.com/reference",
-                         "${android.sdkDirectory}/docs/reference"
+                "${android.sdkDirectory}/docs/reference"
             encoding = "UTF-8"
         }
         exclude "**/BuildConfig.java"
         exclude "**/R.java"
+        doFirst {
+            classpath =
+                files(
+                    variant.javaCompile.classpath.files,
+                    project.android.getBootClasspath())
+        }
         doLast {
             copy {
                 from "src/main/javadoc"
                 into "$buildDir/docs/javadoc"
             }
+            project.fixJavadoc()
         }
     }
 }
diff --git a/javadoc_util.gradle b/javadoc_util.gradle
new file mode 100644
index 0000000000..cff5f29392
--- /dev/null
+++ b/javadoc_util.gradle
@@ -0,0 +1,39 @@
+// Copyright (C) 2018 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+ext.fixJavadoc = {
+  def javadocPath = "${project.buildDir}/docs/javadoc"
+  // Fix external Android links to target the top frame.
+  def androidRoot = "https://developer.android.com/reference/"
+  def androidLink = "<a href=\"(${androidRoot}.*?)\\?is-external=true\""
+  def androidFixed = "<a href=\"\\1\" target=\"_top\""
+  ant.replaceregexp(match:androidLink, replace:androidFixed, flags:'g') {
+    fileset(dir: "${javadocPath}", includes: "**/*.html")
+  }
+  // Fix external Oracle links to use frames and target the top frame.
+  def oracleRoot = "https://docs.oracle.com/javase/7/docs/api/"
+  def oracleLink = "<a href=\"(${oracleRoot})(.*?)\\?is-external=true\""
+  def oracleFixed = "<a href=\"\\1index.html\\?\\2\" target=\"_top\""
+  ant.replaceregexp(match:oracleLink, replace:oracleFixed, flags:'g') {
+    fileset(dir: "${javadocPath}", includes: "**/*.html")
+  }
+  // Remove date metadata that changes every time Javadoc is generated.
+  def javadocGeneratedBy = "<!-- Generated by javadoc.*?-->\n"
+  ant.replaceregexp(match:javadocGeneratedBy, replace:"") {
+    fileset(dir: "${javadocPath}", includes: "**/*.html")
+  }
+  def dateMeta = "<meta name=\"date\".*?>\n"
+  ant.replaceregexp(match:dateMeta, replace:"") {
+    fileset(dir: "${javadocPath}", includes: "**/*.html")
+  }
+}
diff --git a/library/all/build.gradle b/library/all/build.gradle
index 79ed9c747b..bb832ba0ff 100644
--- a/library/all/build.gradle
+++ b/library/all/build.gradle
@@ -25,11 +25,11 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile project(modulePrefix + 'library-dash')
-    compile project(modulePrefix + 'library-hls')
-    compile project(modulePrefix + 'library-smoothstreaming')
-    compile project(modulePrefix + 'library-ui')
+    api project(modulePrefix + 'library-core')
+    api project(modulePrefix + 'library-dash')
+    api project(modulePrefix + 'library-hls')
+    api project(modulePrefix + 'library-smoothstreaming')
+    api project(modulePrefix + 'library-ui')
 }
 
 ext {
diff --git a/library/core/build.gradle b/library/core/build.gradle
index d50834efd5..fe6045c2e7 100644
--- a/library/core/build.gradle
+++ b/library/core/build.gradle
@@ -21,6 +21,7 @@ android {
     defaultConfig {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
+        consumerProguardFiles 'proguard-rules.txt'
     }
 
     // Workaround to prevent circular dependency on project :testutils.
@@ -30,6 +31,7 @@ android {
         }
         test {
             java.srcDirs += "../../testutils/src/main/java/"
+            java.srcDirs += "../../testutils_robolectric/src/main/java/"
         }
     }
 
@@ -43,14 +45,15 @@ android {
 }
 
 dependencies {
-    compile 'com.android.support:support-annotations:' + supportLibraryVersion
-    androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
-    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
-    androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
-    testCompile 'com.google.truth:truth:' + truthVersion
-    testCompile 'junit:junit:' + junitVersion
-    testCompile 'org.mockito:mockito-core:' + mockitoVersion
-    testCompile 'org.robolectric:robolectric:' + robolectricVersion
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    androidTestImplementation 'com.google.dexmaker:dexmaker:' + dexmakerVersion
+    androidTestImplementation 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
+    androidTestImplementation 'com.google.truth:truth:' + truthVersion
+    androidTestImplementation 'org.mockito:mockito-core:' + mockitoVersion
+    testImplementation 'com.google.truth:truth:' + truthVersion
+    testImplementation 'junit:junit:' + junitVersion
+    testImplementation 'org.mockito:mockito-core:' + mockitoVersion
+    testImplementation 'org.robolectric:robolectric:' + robolectricVersion
 }
 
 ext {
diff --git a/library/core/proguard-rules.txt b/library/core/proguard-rules.txt
new file mode 100644
index 0000000000..7dc81c3f73
--- /dev/null
+++ b/library/core/proguard-rules.txt
@@ -0,0 +1,31 @@
+# Proguard rules specific to the core module.
+
+# Constructors accessed via reflection in DefaultRenderersFactory
+-dontnote com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer
+-keepclassmembers class com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer {
+  <init>(boolean, long, android.os.Handler, com.google.android.exoplayer2.video.VideoRendererEventListener, int);
+}
+-dontnote com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer
+-keepclassmembers class com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer {
+  <init>(android.os.Handler, com.google.android.exoplayer2.audio.AudioRendererEventListener, com.google.android.exoplayer2.audio.AudioProcessor[]);
+}
+-dontnote com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer
+-keepclassmembers class com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer {
+  <init>(android.os.Handler, com.google.android.exoplayer2.audio.AudioRendererEventListener, com.google.android.exoplayer2.audio.AudioProcessor[]);
+}
+-dontnote com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer
+-keepclassmembers class com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer {
+  <init>(android.os.Handler, com.google.android.exoplayer2.audio.AudioRendererEventListener, com.google.android.exoplayer2.audio.AudioProcessor[]);
+}
+
+# Constructors accessed via reflection in DefaultExtractorsFactory
+-dontnote com.google.android.exoplayer2.ext.flac.FlacExtractor
+-keepclassmembers class com.google.android.exoplayer2.ext.flac.FlacExtractor {
+  <init>();
+}
+
+# Constructors accessed via reflection in DefaultDataSource
+-dontnote com.google.android.exoplayer2.ext.rtmp.RtmpDataSource
+-keepclassmembers class com.google.android.exoplayer2.ext.rtmp.RtmpDataSource {
+  <init>();
+}
diff --git a/library/core/src/androidTest/AndroidManifest.xml b/library/core/src/androidTest/AndroidManifest.xml
index 4997994e18..38ae6b0b2d 100644
--- a/library/core/src/androidTest/AndroidManifest.xml
+++ b/library/core/src/androidTest/AndroidManifest.xml
@@ -18,7 +18,7 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.core.test">
 
-  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="27"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/library/core/src/androidTest/assets/ssa/typical_format b/library/core/src/androidTest/assets/ssa/typical_format
deleted file mode 100644
index 0cc5f1690f..0000000000
--- a/library/core/src/androidTest/assets/ssa/typical_format
+++ /dev/null
@@ -1 +0,0 @@
-Format: Layer, Start, End, Style, Name, Text
\ No newline at end of file
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
deleted file mode 100644
index 56d5f05d00..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/ExoPlayerTest.java
+++ /dev/null
@@ -1,314 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2;
-
-import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.TrackGroup;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.testutil.ActionSchedule;
-import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner;
-import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner.Builder;
-import com.google.android.exoplayer2.testutil.FakeMediaClockRenderer;
-import com.google.android.exoplayer2.testutil.FakeMediaSource;
-import com.google.android.exoplayer2.testutil.FakeRenderer;
-import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
-import com.google.android.exoplayer2.testutil.FakeTimeline;
-import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import junit.framework.TestCase;
-
-/**
- * Unit test for {@link ExoPlayer}.
- */
-public final class ExoPlayerTest extends TestCase {
-
-  /**
-   * For tests that rely on the player transitioning to the ended state, the duration in
-   * milliseconds after starting the player before the test will time out. This is to catch cases
-   * where the player under test is not making progress, in which case the test should fail.
-   */
-  private static final int TIMEOUT_MS = 10000;
-
-  /**
-   * Tests playback of a source that exposes an empty timeline. Playback is expected to end without
-   * error.
-   */
-  public void testPlayEmptyTimeline() throws Exception {
-    Timeline timeline = Timeline.EMPTY;
-    FakeRenderer renderer = new FakeRenderer();
-    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
-        .setTimeline(timeline).setRenderers(renderer)
-        .build().start().blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertPositionDiscontinuityCount(0);
-    testRunner.assertTimelinesEqual();
-    assertEquals(0, renderer.formatReadCount);
-    assertEquals(0, renderer.bufferReadCount);
-    assertFalse(renderer.isEnded);
-  }
-
-  /**
-   * Tests playback of a source that exposes a single period.
-   */
-  public void testPlaySinglePeriodTimeline() throws Exception {
-    Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 0));
-    Object manifest = new Object();
-    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
-    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
-        .setTimeline(timeline).setManifest(manifest).setRenderers(renderer)
-        .build().start().blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertPositionDiscontinuityCount(0);
-    testRunner.assertTimelinesEqual(timeline);
-    testRunner.assertManifestsEqual(manifest);
-    testRunner.assertTrackGroupsEqual(new TrackGroupArray(new TrackGroup(Builder.VIDEO_FORMAT)));
-    assertEquals(1, renderer.formatReadCount);
-    assertEquals(1, renderer.bufferReadCount);
-    assertTrue(renderer.isEnded);
-  }
-
-  /**
-   * Tests playback of a source that exposes three periods.
-   */
-  public void testPlayMultiPeriodTimeline() throws Exception {
-    Timeline timeline = new FakeTimeline(
-        new TimelineWindowDefinition(false, false, 0),
-        new TimelineWindowDefinition(false, false, 0),
-        new TimelineWindowDefinition(false, false, 0));
-    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
-    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
-        .setTimeline(timeline).setRenderers(renderer)
-        .build().start().blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertPositionDiscontinuityCount(2);
-    testRunner.assertTimelinesEqual(timeline);
-    assertEquals(3, renderer.formatReadCount);
-    assertEquals(1, renderer.bufferReadCount);
-    assertTrue(renderer.isEnded);
-  }
-
-  /**
-   * Tests that the player does not unnecessarily reset renderers when playing a multi-period
-   * source.
-   */
-  public void testReadAheadToEndDoesNotResetRenderer() throws Exception {
-    Timeline timeline = new FakeTimeline(
-        new TimelineWindowDefinition(false, false, 10),
-        new TimelineWindowDefinition(false, false, 10),
-        new TimelineWindowDefinition(false, false, 10));
-    final FakeRenderer videoRenderer = new FakeRenderer(Builder.VIDEO_FORMAT);
-    FakeMediaClockRenderer audioRenderer = new FakeMediaClockRenderer(Builder.AUDIO_FORMAT) {
-
-      @Override
-      public long getPositionUs() {
-        // Simulate the playback position lagging behind the reading position: the renderer media
-        // clock position will be the start of the timeline until the stream is set to be final, at
-        // which point it jumps to the end of the timeline allowing the playing period to advance.
-        // TODO: Avoid hard-coding ExoPlayerImplInternal.RENDERER_TIMESTAMP_OFFSET_US.
-        return isCurrentStreamFinal() ? 60000030 : 60000000;
-      }
-
-      @Override
-      public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
-        return PlaybackParameters.DEFAULT;
-      }
-
-      @Override
-      public PlaybackParameters getPlaybackParameters() {
-        return PlaybackParameters.DEFAULT;
-      }
-
-      @Override
-      public boolean isEnded() {
-        return videoRenderer.isEnded();
-      }
-
-    };
-    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
-        .setTimeline(timeline).setRenderers(videoRenderer, audioRenderer)
-        .setSupportedFormats(Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT)
-        .build().start().blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertPositionDiscontinuityCount(2);
-    testRunner.assertTimelinesEqual(timeline);
-    assertEquals(1, audioRenderer.positionResetCount);
-    assertTrue(videoRenderer.isEnded);
-    assertTrue(audioRenderer.isEnded);
-  }
-
-  public void testRepreparationGivesFreshSourceInfo() throws Exception {
-    Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 0));
-    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
-    Object firstSourceManifest = new Object();
-    MediaSource firstSource = new FakeMediaSource(timeline, firstSourceManifest,
-        Builder.VIDEO_FORMAT);
-    final CountDownLatch queuedSourceInfoCountDownLatch = new CountDownLatch(1);
-    final CountDownLatch completePreparationCountDownLatch = new CountDownLatch(1);
-    MediaSource secondSource = new FakeMediaSource(timeline, new Object(), Builder.VIDEO_FORMAT) {
-      @Override
-      public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
-        super.prepareSource(player, isTopLevelSource, listener);
-        // We've queued a source info refresh on the playback thread's event queue. Allow the test
-        // thread to prepare the player with the third source, and block this thread (the playback
-        // thread) until the test thread's call to prepare() has returned.
-        queuedSourceInfoCountDownLatch.countDown();
-        try {
-          completePreparationCountDownLatch.await();
-        } catch (InterruptedException e) {
-          throw new IllegalStateException(e);
-        }
-      }
-    };
-    Object thirdSourceManifest = new Object();
-    MediaSource thirdSource = new FakeMediaSource(timeline, thirdSourceManifest,
-        Builder.VIDEO_FORMAT);
-
-    // Prepare the player with a source with the first manifest and a non-empty timeline. Prepare
-    // the player again with a source and a new manifest, which will never be exposed. Allow the
-    // test thread to prepare the player with a third source, and block the playback thread until
-    // the test thread's call to prepare() has returned.
-    ActionSchedule actionSchedule = new ActionSchedule.Builder("testRepreparation")
-        .waitForTimelineChanged(timeline)
-        .prepareSource(secondSource)
-        .executeRunnable(new Runnable() {
-          @Override
-          public void run() {
-            try {
-              queuedSourceInfoCountDownLatch.await();
-            } catch (InterruptedException e) {
-              // Ignore.
-            }
-          }
-        })
-        .prepareSource(thirdSource)
-        .executeRunnable(new Runnable() {
-          @Override
-          public void run() {
-            completePreparationCountDownLatch.countDown();
-          }
-        })
-        .build();
-    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
-        .setMediaSource(firstSource).setRenderers(renderer).setActionSchedule(actionSchedule)
-        .build().start().blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertPositionDiscontinuityCount(0);
-    // The first source's preparation completed with a non-empty timeline. When the player was
-    // re-prepared with the second source, it immediately exposed an empty timeline, but the source
-    // info refresh from the second source was suppressed as we re-prepared with the third source.
-    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, timeline);
-    testRunner.assertManifestsEqual(firstSourceManifest, null, thirdSourceManifest);
-    testRunner.assertTrackGroupsEqual(new TrackGroupArray(new TrackGroup(Builder.VIDEO_FORMAT)));
-    assertEquals(1, renderer.formatReadCount);
-    assertEquals(1, renderer.bufferReadCount);
-    assertTrue(renderer.isEnded);
-  }
-
-  public void testRepeatModeChanges() throws Exception {
-    Timeline timeline = new FakeTimeline(
-        new TimelineWindowDefinition(true, false, 100000),
-        new TimelineWindowDefinition(true, false, 100000),
-        new TimelineWindowDefinition(true, false, 100000));
-    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
-    ActionSchedule actionSchedule = new ActionSchedule.Builder("testRepeatMode") // 0 -> 1
-        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_ONE) // 1 -> 1
-        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_OFF) // 1 -> 2
-        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_ONE) // 2 -> 2
-        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_ALL) // 2 -> 0
-        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_ONE) // 0 -> 0
-        .waitForPositionDiscontinuity()                                       // 0 -> 0
-        .waitForPositionDiscontinuity().setRepeatMode(Player.REPEAT_MODE_OFF) // 0 -> end
-        .build();
-    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
-        .setTimeline(timeline).setRenderers(renderer).setActionSchedule(actionSchedule)
-        .build().start().blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertPlayedPeriodIndices(0, 1, 1, 2, 2, 0, 0, 0, 1, 2);
-    testRunner.assertTimelinesEqual(timeline);
-    assertTrue(renderer.isEnded);
-  }
-
-  public void testShuffleModeEnabledChanges() throws Exception {
-    Timeline fakeTimeline = new FakeTimeline(new TimelineWindowDefinition(true, false, 100000));
-    MediaSource[] fakeMediaSources = {
-        new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
-        new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
-        new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT)
-    };
-    ConcatenatingMediaSource mediaSource = new ConcatenatingMediaSource(false,
-        new FakeShuffleOrder(3), fakeMediaSources);
-    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
-    ActionSchedule actionSchedule = new ActionSchedule.Builder("testShuffleModeEnabled")
-        .setRepeatMode(Player.REPEAT_MODE_ALL).waitForPositionDiscontinuity() // 0 -> 1
-        .setShuffleModeEnabled(true).waitForPositionDiscontinuity()           // 1 -> 0
-        .waitForPositionDiscontinuity().waitForPositionDiscontinuity()        // 0 -> 2 -> 1
-        .setShuffleModeEnabled(false).setRepeatMode(Player.REPEAT_MODE_OFF)   // 1 -> 2 -> end
-        .build();
-    ExoPlayerTestRunner testRunner = new ExoPlayerTestRunner.Builder()
-        .setMediaSource(mediaSource).setRenderers(renderer).setActionSchedule(actionSchedule)
-        .build().start().blockUntilEnded(TIMEOUT_MS);
-    testRunner.assertPlayedPeriodIndices(0, 1, 0, 2, 1, 2);
-    assertTrue(renderer.isEnded);
-  }
-
-  public void testPeriodHoldersReleasedAfterSeekWithRepeatModeAll() throws Exception {
-    Timeline fakeTimeline = new FakeTimeline(new TimelineWindowDefinition(true, false, 100000));
-    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
-    ActionSchedule actionSchedule = new ActionSchedule.Builder("testPeriodHoldersReleased")
-        .setRepeatMode(Player.REPEAT_MODE_ALL)
-        .waitForPositionDiscontinuity()
-        .seek(0) // Seek with repeat mode set to REPEAT_MODE_ALL.
-        .waitForPositionDiscontinuity()
-        .setRepeatMode(Player.REPEAT_MODE_OFF) // Turn off repeat so that playback can finish.
-        .build();
-    new ExoPlayerTestRunner.Builder()
-        .setTimeline(fakeTimeline).setRenderers(renderer).setActionSchedule(actionSchedule)
-        .build().start().blockUntilEnded(TIMEOUT_MS);
-    assertTrue(renderer.isEnded);
-  }
-
-  public void testSeekProcessedCallback() throws Exception {
-    Timeline timeline = new FakeTimeline(
-        new TimelineWindowDefinition(true, false, 100000),
-        new TimelineWindowDefinition(true, false, 100000));
-    ActionSchedule actionSchedule = new ActionSchedule.Builder("testSeekProcessedCallback")
-        // Initial seek before timeline preparation finished.
-        .pause().seek(10).waitForPlaybackState(Player.STATE_READY)
-        // Re-seek to same position, start playback and wait until playback reaches second window.
-        .seek(10).play().waitForPositionDiscontinuity()
-        // Seek twice in concession, expecting the first seek to be replaced.
-        .seek(5).seek(60).build();
-    final List<Integer> playbackStatesWhenSeekProcessed = new ArrayList<>();
-    Player.EventListener eventListener = new Player.DefaultEventListener() {
-      private int currentPlaybackState = Player.STATE_IDLE;
-
-      @Override
-      public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-        currentPlaybackState = playbackState;
-      }
-
-      @Override
-      public void onSeekProcessed() {
-        playbackStatesWhenSeekProcessed.add(currentPlaybackState);
-      }
-    };
-    new ExoPlayerTestRunner.Builder()
-        .setTimeline(timeline).setEventListener(eventListener).setActionSchedule(actionSchedule)
-        .build().start().blockUntilEnded(TIMEOUT_MS);
-    assertEquals(3, playbackStatesWhenSeekProcessed.size());
-    assertEquals(Player.STATE_BUFFERING, (int) playbackStatesWhenSeekProcessed.get(0));
-    assertEquals(Player.STATE_READY, (int) playbackStatesWhenSeekProcessed.get(1));
-    assertEquals(Player.STATE_BUFFERING, (int) playbackStatesWhenSeekProcessed.get(2));
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
deleted file mode 100644
index 186b842bab..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.extractor.ogg;
-
-import android.test.InstrumentationTestCase;
-import android.test.MoreAsserts;
-import com.google.android.exoplayer2.testutil.FakeExtractorInput;
-import com.google.android.exoplayer2.testutil.OggTestData;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import com.google.android.exoplayer2.util.ParsableByteArray;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Random;
-
-/**
- * Unit test for {@link OggPacket}.
- */
-public final class OggPacketTest extends InstrumentationTestCase {
-
-  private static final String TEST_FILE = "ogg/bear.opus";
-
-  private Random random;
-  private OggPacket oggPacket;
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    random = new Random(0);
-    oggPacket = new OggPacket();
-  }
-
-  public void testReadPacketsWithEmptyPage() throws Exception {
-    byte[] firstPacket = TestUtil.buildTestData(8, random);
-    byte[] secondPacket = TestUtil.buildTestData(272, random);
-    byte[] thirdPacket = TestUtil.buildTestData(256, random);
-    byte[] fourthPacket = TestUtil.buildTestData(271, random);
-
-    FakeExtractorInput input = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            // First page with a single packet.
-            OggTestData.buildOggHeader(0x02,  0, 1000, 0x01),
-            TestUtil.createByteArray(0x08), // Laces
-            firstPacket,
-            // Second page with a single packet.
-            OggTestData.buildOggHeader(0x00,  16, 1001, 0x02),
-            TestUtil.createByteArray(0xFF, 0x11), // Laces
-            secondPacket,
-            // Third page with zero packets.
-            OggTestData.buildOggHeader(0x00,  16, 1002, 0x00),
-            // Fourth page with two packets.
-            OggTestData.buildOggHeader(0x04,  128, 1003, 0x04),
-            TestUtil.createByteArray(0xFF, 0x01, 0xFF, 0x10), // Laces
-            thirdPacket,
-            fourthPacket), true);
-
-    assertReadPacket(input, firstPacket);
-    assertTrue((oggPacket.getPageHeader().type & 0x02) == 0x02);
-    assertFalse((oggPacket.getPageHeader().type & 0x04) == 0x04);
-    assertEquals(0x02, oggPacket.getPageHeader().type);
-    assertEquals(27 + 1, oggPacket.getPageHeader().headerSize);
-    assertEquals(8, oggPacket.getPageHeader().bodySize);
-    assertEquals(0x00, oggPacket.getPageHeader().revision);
-    assertEquals(1, oggPacket.getPageHeader().pageSegmentCount);
-    assertEquals(1000, oggPacket.getPageHeader().pageSequenceNumber);
-    assertEquals(4096, oggPacket.getPageHeader().streamSerialNumber);
-    assertEquals(0, oggPacket.getPageHeader().granulePosition);
-
-    assertReadPacket(input, secondPacket);
-    assertFalse((oggPacket.getPageHeader().type & 0x02) == 0x02);
-    assertFalse((oggPacket.getPageHeader().type & 0x04) == 0x04);
-    assertEquals(0, oggPacket.getPageHeader().type);
-    assertEquals(27 + 2, oggPacket.getPageHeader().headerSize);
-    assertEquals(255 + 17, oggPacket.getPageHeader().bodySize);
-    assertEquals(2, oggPacket.getPageHeader().pageSegmentCount);
-    assertEquals(1001, oggPacket.getPageHeader().pageSequenceNumber);
-    assertEquals(16, oggPacket.getPageHeader().granulePosition);
-
-    assertReadPacket(input, thirdPacket);
-    assertFalse((oggPacket.getPageHeader().type & 0x02) == 0x02);
-    assertTrue((oggPacket.getPageHeader().type & 0x04) == 0x04);
-    assertEquals(4, oggPacket.getPageHeader().type);
-    assertEquals(27 + 4, oggPacket.getPageHeader().headerSize);
-    assertEquals(255 + 1 + 255 + 16, oggPacket.getPageHeader().bodySize);
-    assertEquals(4, oggPacket.getPageHeader().pageSegmentCount);
-    // Page 1002 is empty, so current page is 1003.
-    assertEquals(1003, oggPacket.getPageHeader().pageSequenceNumber);
-    assertEquals(128, oggPacket.getPageHeader().granulePosition);
-
-    assertReadPacket(input, fourthPacket);
-
-    assertReadEof(input);
-  }
-
-  public void testReadPacketWithZeroSizeTerminator() throws Exception {
-    byte[] firstPacket = TestUtil.buildTestData(255, random);
-    byte[] secondPacket = TestUtil.buildTestData(8, random);
-
-    FakeExtractorInput input = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            OggTestData.buildOggHeader(0x06, 0, 1000, 0x04),
-            TestUtil.createByteArray(0xFF, 0x00, 0x00, 0x08), // Laces.
-            firstPacket,
-            secondPacket), true);
-
-    assertReadPacket(input, firstPacket);
-    assertReadPacket(input, secondPacket);
-    assertReadEof(input);
-  }
-
-  public void testReadContinuedPacketOverTwoPages() throws Exception {
-    byte[] firstPacket = TestUtil.buildTestData(518);
-
-    FakeExtractorInput input = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            // First page.
-            OggTestData.buildOggHeader(0x02, 0, 1000, 0x02),
-            TestUtil.createByteArray(0xFF, 0xFF), // Laces.
-            Arrays.copyOf(firstPacket, 510),
-            // Second page (continued packet).
-            OggTestData.buildOggHeader(0x05, 10, 1001, 0x01),
-            TestUtil.createByteArray(0x08), // Laces.
-            Arrays.copyOfRange(firstPacket, 510, 510 + 8)), true);
-
-    assertReadPacket(input, firstPacket);
-    assertTrue((oggPacket.getPageHeader().type & 0x04) == 0x04);
-    assertFalse((oggPacket.getPageHeader().type & 0x02) == 0x02);
-    assertEquals(1001, oggPacket.getPageHeader().pageSequenceNumber);
-
-    assertReadEof(input);
-  }
-
-  public void testReadContinuedPacketOverFourPages() throws Exception {
-    byte[] firstPacket = TestUtil.buildTestData(1028);
-
-    FakeExtractorInput input = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            // First page.
-            OggTestData.buildOggHeader(0x02, 0, 1000, 0x02),
-            TestUtil.createByteArray(0xFF, 0xFF), // Laces.
-            Arrays.copyOf(firstPacket, 510),
-            // Second page (continued packet).
-            OggTestData.buildOggHeader(0x01, 10, 1001, 0x01),
-            TestUtil.createByteArray(0xFF), // Laces.
-            Arrays.copyOfRange(firstPacket, 510, 510 + 255),
-            // Third page (continued packet).
-            OggTestData.buildOggHeader(0x01, 10, 1002, 0x01),
-            TestUtil.createByteArray(0xFF), // Laces.
-            Arrays.copyOfRange(firstPacket, 510 + 255, 510 + 255 + 255),
-            // Fourth page (continued packet).
-            OggTestData.buildOggHeader(0x05, 10, 1003, 0x01),
-            TestUtil.createByteArray(0x08), // Laces.
-            Arrays.copyOfRange(firstPacket, 510 + 255 + 255, 510 + 255 + 255 + 8)), true);
-
-    assertReadPacket(input, firstPacket);
-    assertTrue((oggPacket.getPageHeader().type & 0x04) == 0x04);
-    assertFalse((oggPacket.getPageHeader().type & 0x02) == 0x02);
-    assertEquals(1003, oggPacket.getPageHeader().pageSequenceNumber);
-
-    assertReadEof(input);
-  }
-
-  public void testReadDiscardContinuedPacketAtStart() throws Exception {
-    byte[] pageBody = TestUtil.buildTestData(256 + 8);
-
-    FakeExtractorInput input = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            // Page with a continued packet at start.
-            OggTestData.buildOggHeader(0x01, 10, 1001, 0x03),
-            TestUtil.createByteArray(255, 1, 8), // Laces.
-            pageBody), true);
-
-    // Expect the first partial packet to be discarded.
-    assertReadPacket(input, Arrays.copyOfRange(pageBody, 256, 256 + 8));
-    assertReadEof(input);
-  }
-
-  public void testReadZeroSizedPacketsAtEndOfStream() throws Exception {
-    byte[] firstPacket = TestUtil.buildTestData(8, random);
-    byte[] secondPacket = TestUtil.buildTestData(8, random);
-    byte[] thirdPacket = TestUtil.buildTestData(8, random);
-
-    FakeExtractorInput input = OggTestData.createInput(
-        TestUtil.joinByteArrays(
-            OggTestData.buildOggHeader(0x02, 0, 1000, 0x01),
-            TestUtil.createByteArray(0x08), // Laces.
-            firstPacket,
-            OggTestData.buildOggHeader(0x04, 0, 1001, 0x03),
-            TestUtil.createByteArray(0x08, 0x00, 0x00), // Laces.
-            secondPacket,
-            OggTestData.buildOggHeader(0x04, 0, 1002, 0x03),
-            TestUtil.createByteArray(0x08, 0x00, 0x00), // Laces.
-            thirdPacket), true);
-
-    assertReadPacket(input, firstPacket);
-    assertReadPacket(input, secondPacket);
-    assertReadPacket(input, thirdPacket);
-    assertReadEof(input);
-  }
-
-
-  public void testParseRealFile() throws IOException, InterruptedException {
-    byte[] data = TestUtil.getByteArray(getInstrumentation(), TEST_FILE);
-    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
-    int packetCounter = 0;
-    while (readPacket(input)) {
-      packetCounter++;
-    }
-    assertEquals(277, packetCounter);
-  }
-
-  private void assertReadPacket(FakeExtractorInput extractorInput, byte[] expected)
-      throws IOException, InterruptedException {
-    assertTrue(readPacket(extractorInput));
-    ParsableByteArray payload = oggPacket.getPayload();
-    MoreAsserts.assertEquals(expected, Arrays.copyOf(payload.data, payload.limit()));
-  }
-
-  private void assertReadEof(FakeExtractorInput extractorInput)
-      throws IOException, InterruptedException {
-    assertFalse(readPacket(extractorInput));
-  }
-
-  private boolean readPacket(FakeExtractorInput input)
-      throws InterruptedException, IOException {
-    while (true) {
-      try {
-        return oggPacket.populate(input);
-      } catch (FakeExtractorInput.SimulatedIOException e) {
-        // Ignore.
-      }
-    }
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
deleted file mode 100644
index 5e615dbc7f..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source;
-
-import android.test.InstrumentationTestCase;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.Timeline.Period;
-import com.google.android.exoplayer2.Timeline.Window;
-import com.google.android.exoplayer2.testutil.FakeMediaSource;
-import com.google.android.exoplayer2.testutil.FakeTimeline;
-import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import com.google.android.exoplayer2.testutil.TimelineAsserts;
-
-/**
- * Unit tests for {@link ClippingMediaSource}.
- */
-public final class ClippingMediaSourceTest extends InstrumentationTestCase {
-
-  private static final long TEST_PERIOD_DURATION_US = 1000000;
-  private static final long TEST_CLIP_AMOUNT_US = 300000;
-
-  private Window window;
-  private Period period;
-
-  @Override
-  protected void setUp() throws Exception {
-    window = new Timeline.Window();
-    period = new Timeline.Period();
-  }
-
-  public void testNoClipping() {
-    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
-
-    Timeline clippedTimeline = getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
-
-    assertEquals(1, clippedTimeline.getWindowCount());
-    assertEquals(1, clippedTimeline.getPeriodCount());
-    assertEquals(TEST_PERIOD_DURATION_US, clippedTimeline.getWindow(0, window).getDurationUs());
-    assertEquals(TEST_PERIOD_DURATION_US, clippedTimeline.getPeriod(0, period).getDurationUs());
-  }
-
-  public void testClippingUnseekableWindowThrows() {
-    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), false);
-
-    // If the unseekable window isn't clipped, clipping succeeds.
-    getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
-    try {
-      // If the unseekable window is clipped, clipping fails.
-      getClippedTimeline(timeline, 1, TEST_PERIOD_DURATION_US);
-      fail("Expected clipping to fail.");
-    } catch (IllegalArgumentException e) {
-      // Expected.
-    }
-  }
-
-  public void testClippingStart() {
-    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
-
-    Timeline clippedTimeline = getClippedTimeline(timeline, TEST_CLIP_AMOUNT_US,
-        TEST_PERIOD_DURATION_US);
-    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
-        clippedTimeline.getWindow(0, window).getDurationUs());
-    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
-        clippedTimeline.getPeriod(0, period).getDurationUs());
-  }
-
-  public void testClippingEnd() {
-    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
-
-    Timeline clippedTimeline = getClippedTimeline(timeline, 0,
-        TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
-    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
-        clippedTimeline.getWindow(0, window).getDurationUs());
-    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US,
-        clippedTimeline.getPeriod(0, period).getDurationUs());
-  }
-
-  public void testClippingStartAndEnd() {
-    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true);
-
-    Timeline clippedTimeline = getClippedTimeline(timeline, TEST_CLIP_AMOUNT_US,
-        TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 2);
-    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3,
-        clippedTimeline.getWindow(0, window).getDurationUs());
-    assertEquals(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3,
-        clippedTimeline.getPeriod(0, period).getDurationUs());
-  }
-
-  public void testWindowAndPeriodIndices() {
-    Timeline timeline = new FakeTimeline(
-        new TimelineWindowDefinition(1, 111, true, false, TEST_PERIOD_DURATION_US));
-    Timeline clippedTimeline = getClippedTimeline(timeline, TEST_CLIP_AMOUNT_US,
-        TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
-    TimelineAsserts.assertWindowIds(clippedTimeline, 111);
-    TimelineAsserts.assertPeriodCounts(clippedTimeline, 1);
-    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_ONE, false, 0);
-    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_ALL, false, 0);
-    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_ONE, false, 0);
-    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_ALL, false, 0);
-  }
-
-  /**
-   * Wraps the specified timeline in a {@link ClippingMediaSource} and returns the clipped timeline.
-   */
-  private static Timeline getClippedTimeline(Timeline timeline, long startMs, long endMs) {
-    MediaSource mediaSource = new FakeMediaSource(timeline, null);
-    return TestUtil.extractTimelineFromMediaSource(
-        new ClippingMediaSource(mediaSource, startMs, endMs));
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
deleted file mode 100644
index 6f6556225e..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
-import com.google.android.exoplayer2.testutil.FakeMediaSource;
-import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
-import com.google.android.exoplayer2.testutil.FakeTimeline;
-import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import com.google.android.exoplayer2.testutil.TimelineAsserts;
-import junit.framework.TestCase;
-
-/**
- * Unit tests for {@link ConcatenatingMediaSource}.
- */
-public final class ConcatenatingMediaSourceTest extends TestCase {
-
-  public void testEmptyConcatenation() {
-    for (boolean atomic : new boolean[] {false, true}) {
-      Timeline timeline = getConcatenatedTimeline(atomic);
-      TimelineAsserts.assertEmpty(timeline);
-
-      timeline = getConcatenatedTimeline(atomic, Timeline.EMPTY);
-      TimelineAsserts.assertEmpty(timeline);
-
-      timeline = getConcatenatedTimeline(atomic, Timeline.EMPTY, Timeline.EMPTY, Timeline.EMPTY);
-      TimelineAsserts.assertEmpty(timeline);
-    }
-  }
-
-  public void testSingleMediaSource() {
-    Timeline timeline = getConcatenatedTimeline(false, createFakeTimeline(3, 111));
-    TimelineAsserts.assertWindowIds(timeline, 111);
-    TimelineAsserts.assertPeriodCounts(timeline, 3);
-    for (boolean shuffled : new boolean[] {false, true}) {
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          C.INDEX_UNSET);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          C.INDEX_UNSET);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
-    }
-
-    timeline = getConcatenatedTimeline(true, createFakeTimeline(3, 111));
-    TimelineAsserts.assertWindowIds(timeline, 111);
-    TimelineAsserts.assertPeriodCounts(timeline, 3);
-    for (boolean shuffled : new boolean[] {false, true}) {
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          C.INDEX_UNSET);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          C.INDEX_UNSET);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
-    }
-  }
-
-  public void testMultipleMediaSources() {
-    Timeline[] timelines = { createFakeTimeline(3, 111), createFakeTimeline(1, 222),
-        createFakeTimeline(3, 333) };
-    Timeline timeline = getConcatenatedTimeline(false, timelines);
-    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
-    TimelineAsserts.assertPeriodCounts(timeline, 3, 1, 3);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
-    assertEquals(0, timeline.getFirstWindowIndex(false));
-    assertEquals(2, timeline.getLastWindowIndex(false));
-    assertEquals(2, timeline.getFirstWindowIndex(true));
-    assertEquals(0, timeline.getLastWindowIndex(true));
-
-    timeline = getConcatenatedTimeline(true, timelines);
-    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
-    TimelineAsserts.assertPeriodCounts(timeline, 3, 1, 3);
-    for (boolean shuffled : new boolean[] {false, true}) {
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          C.INDEX_UNSET, 0, 1);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
-          2, 0, 1);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
-          2, 0, 1);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          1, 2, C.INDEX_UNSET);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 1, 2, 0);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
-      assertEquals(0, timeline.getFirstWindowIndex(shuffled));
-      assertEquals(2, timeline.getLastWindowIndex(shuffled));
-    }
-  }
-
-  public void testNestedMediaSources() {
-    Timeline timeline = getConcatenatedTimeline(false,
-        getConcatenatedTimeline(false, createFakeTimeline(1, 111), createFakeTimeline(1, 222)),
-        getConcatenatedTimeline(true, createFakeTimeline(1, 333), createFakeTimeline(1, 444)));
-    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333, 444);
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false,
-        0, 1, 3, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false,
-        3, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        1, 2, 3, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 3, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 3, 0);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        1, 3, C.INDEX_UNSET, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true,
-        0, 1, 3, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true,
-        1, 3, 0, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        C.INDEX_UNSET, 0, 3, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 3, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 3, 1);
-  }
-
-  public void testEmptyTimelineMediaSources() {
-    // Empty timelines in the front, back, and the middle (single and multiple in a row).
-    Timeline[] timelines = { Timeline.EMPTY, createFakeTimeline(1, 111), Timeline.EMPTY,
-        Timeline.EMPTY, createFakeTimeline(2, 222), Timeline.EMPTY, createFakeTimeline(3, 333),
-        Timeline.EMPTY };
-    Timeline timeline = getConcatenatedTimeline(false, timelines);
-    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
-    assertEquals(0, timeline.getFirstWindowIndex(false));
-    assertEquals(2, timeline.getLastWindowIndex(false));
-    assertEquals(2, timeline.getFirstWindowIndex(true));
-    assertEquals(0, timeline.getLastWindowIndex(true));
-
-    timeline = getConcatenatedTimeline(true, timelines);
-    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
-    for (boolean shuffled : new boolean[] {false, true}) {
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          C.INDEX_UNSET, 0, 1);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
-          2, 0, 1);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
-          2, 0, 1);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          1, 2, C.INDEX_UNSET);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 1, 2, 0);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
-      assertEquals(0, timeline.getFirstWindowIndex(shuffled));
-      assertEquals(2, timeline.getLastWindowIndex(shuffled));
-    }
-  }
-
-  public void testPeriodCreationWithAds() throws InterruptedException {
-    // Create media source with ad child source.
-    Timeline timelineContentOnly = new FakeTimeline(
-        new TimelineWindowDefinition(2, 111, true, false, 10 * C.MICROS_PER_SECOND));
-    Timeline timelineWithAds = new FakeTimeline(
-        new TimelineWindowDefinition(2, 222, true, false, 10 * C.MICROS_PER_SECOND, 1, 1));
-    FakeMediaSource mediaSourceContentOnly = new FakeMediaSource(timelineContentOnly, null);
-    FakeMediaSource mediaSourceWithAds = new FakeMediaSource(timelineWithAds, null);
-    ConcatenatingMediaSource mediaSource = new ConcatenatingMediaSource(mediaSourceContentOnly,
-        mediaSourceWithAds);
-
-    // Prepare and assert timeline contains ad groups.
-    Timeline timeline = TestUtil.extractTimelineFromMediaSource(mediaSource);
-    TimelineAsserts.assertAdGroupCounts(timeline, 0, 0, 1, 1);
-
-    // Create all periods and assert period creation of child media sources has been called.
-    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline, 10_000);
-    mediaSourceContentOnly.assertMediaPeriodCreated(new MediaPeriodId(0));
-    mediaSourceContentOnly.assertMediaPeriodCreated(new MediaPeriodId(1));
-    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(0));
-    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(1));
-    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(0, 0, 0));
-    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(1, 0, 0));
-  }
-
-  /**
-   * Wraps the specified timelines in a {@link ConcatenatingMediaSource} and returns
-   * the concatenated timeline.
-   */
-  private static Timeline getConcatenatedTimeline(boolean isRepeatOneAtomic,
-      Timeline... timelines) {
-    MediaSource[] mediaSources = new MediaSource[timelines.length];
-    for (int i = 0; i < timelines.length; i++) {
-      mediaSources[i] = new FakeMediaSource(timelines[i], null);
-    }
-    ConcatenatingMediaSource mediaSource = new ConcatenatingMediaSource(isRepeatOneAtomic,
-        new FakeShuffleOrder(mediaSources.length), mediaSources);
-    return TestUtil.extractTimelineFromMediaSource(mediaSource);
-  }
-
-  private static FakeTimeline createFakeTimeline(int periodCount, int windowId) {
-    return new FakeTimeline(new TimelineWindowDefinition(periodCount, windowId));
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java
deleted file mode 100644
index e506d0a4b3..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java
+++ /dev/null
@@ -1,939 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source;
-
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.os.ConditionVariable;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.Message;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.PlaybackParameters;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
-import com.google.android.exoplayer2.source.MediaSource.Listener;
-import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
-import com.google.android.exoplayer2.testutil.FakeMediaPeriod;
-import com.google.android.exoplayer2.testutil.FakeMediaSource;
-import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
-import com.google.android.exoplayer2.testutil.FakeTimeline;
-import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
-import com.google.android.exoplayer2.testutil.TimelineAsserts;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
-import com.google.android.exoplayer2.upstream.Allocator;
-import java.io.IOException;
-import java.util.Arrays;
-import junit.framework.TestCase;
-import org.mockito.Mockito;
-
-/**
- * Unit tests for {@link DynamicConcatenatingMediaSource}
- */
-public final class DynamicConcatenatingMediaSourceTest extends TestCase {
-
-  private static final int TIMEOUT_MS = 10000;
-
-  private Timeline timeline;
-  private boolean timelineUpdated;
-  private boolean customRunnableCalled;
-
-  public void testPlaylistChangesAfterPreparation() throws InterruptedException {
-    timeline = null;
-    FakeMediaSource[] childSources = createMediaSources(7);
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource(
-        new FakeShuffleOrder(0));
-    prepareAndListenToTimelineUpdates(mediaSource);
-    assertNotNull(timeline);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertEmpty(timeline);
-
-    // Add first source.
-    mediaSource.addMediaSource(childSources[0]);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 1);
-    TimelineAsserts.assertWindowIds(timeline, 111);
-
-    // Add at front of queue.
-    mediaSource.addMediaSource(0, childSources[1]);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 2, 1);
-    TimelineAsserts.assertWindowIds(timeline, 222, 111);
-
-    // Add at back of queue.
-    mediaSource.addMediaSource(childSources[2]);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 2, 1, 3);
-    TimelineAsserts.assertWindowIds(timeline, 222, 111, 333);
-
-    // Add in the middle.
-    mediaSource.addMediaSource(1, childSources[3]);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 1, 3);
-    TimelineAsserts.assertWindowIds(timeline, 222, 444, 111, 333);
-
-    // Add bulk.
-    mediaSource.addMediaSources(3, Arrays.asList((MediaSource) childSources[4],
-        (MediaSource) childSources[5], (MediaSource) childSources[6]));
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 1, 5, 6, 7, 3);
-    TimelineAsserts.assertWindowIds(timeline, 222, 444, 111, 555, 666, 777, 333);
-
-    // Move sources.
-    mediaSource.moveMediaSource(2, 3);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 5, 1, 6, 7, 3);
-    TimelineAsserts.assertWindowIds(timeline, 222, 444, 555, 111, 666, 777, 333);
-    mediaSource.moveMediaSource(3, 2);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 1, 5, 6, 7, 3);
-    TimelineAsserts.assertWindowIds(timeline, 222, 444, 111, 555, 666, 777, 333);
-    mediaSource.moveMediaSource(0, 6);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 4, 1, 5, 6, 7, 3, 2);
-    TimelineAsserts.assertWindowIds(timeline, 444, 111, 555, 666, 777, 333, 222);
-    mediaSource.moveMediaSource(6, 0);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 1, 5, 6, 7, 3);
-    TimelineAsserts.assertWindowIds(timeline, 222, 444, 111, 555, 666, 777, 333);
-
-    // Remove in the middle.
-    mediaSource.removeMediaSource(3);
-    waitForTimelineUpdate();
-    mediaSource.removeMediaSource(3);
-    waitForTimelineUpdate();
-    mediaSource.removeMediaSource(3);
-    waitForTimelineUpdate();
-    mediaSource.removeMediaSource(1);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 2, 1, 3);
-    TimelineAsserts.assertWindowIds(timeline, 222, 111, 333);
-    for (int i = 3; i <= 6; i++) {
-      childSources[i].assertReleased();
-    }
-
-    // Assert correct next and previous indices behavior after some insertions and removals.
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
-    assertEquals(0, timeline.getFirstWindowIndex(false));
-    assertEquals(timeline.getWindowCount() - 1, timeline.getLastWindowIndex(false));
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
-    assertEquals(timeline.getWindowCount() - 1, timeline.getFirstWindowIndex(true));
-    assertEquals(0, timeline.getLastWindowIndex(true));
-
-    // Assert all periods can be prepared.
-    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
-        TIMEOUT_MS);
-
-    // Remove at front of queue.
-    mediaSource.removeMediaSource(0);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 3);
-    TimelineAsserts.assertWindowIds(timeline, 111, 333);
-    childSources[1].assertReleased();
-
-    // Remove at back of queue.
-    mediaSource.removeMediaSource(1);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 1);
-    TimelineAsserts.assertWindowIds(timeline, 111);
-    childSources[2].assertReleased();
-
-    // Remove last source.
-    mediaSource.removeMediaSource(0);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertEmpty(timeline);
-    childSources[3].assertReleased();
-  }
-
-  public void testPlaylistChangesBeforePreparation() throws InterruptedException {
-    timeline = null;
-    FakeMediaSource[] childSources = createMediaSources(4);
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource(
-        new FakeShuffleOrder(0));
-    mediaSource.addMediaSource(childSources[0]);
-    mediaSource.addMediaSource(childSources[1]);
-    mediaSource.addMediaSource(0, childSources[2]);
-    mediaSource.moveMediaSource(0, 2);
-    mediaSource.removeMediaSource(0);
-    mediaSource.moveMediaSource(1, 0);
-    mediaSource.addMediaSource(1, childSources[3]);
-    assertNull(timeline);
-
-    prepareAndListenToTimelineUpdates(mediaSource);
-    waitForTimelineUpdate();
-    assertNotNull(timeline);
-    TimelineAsserts.assertPeriodCounts(timeline, 3, 4, 2);
-    TimelineAsserts.assertWindowIds(timeline, 333, 444, 222);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        1, 2, C.INDEX_UNSET);
-
-    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
-        TIMEOUT_MS);
-    mediaSource.releaseSource();
-    for (int i = 1; i < 4; i++) {
-      childSources[i].assertReleased();
-    }
-  }
-
-  public void testPlaylistWithLazyMediaSource() throws InterruptedException {
-    timeline = null;
-    FakeMediaSource[] childSources = createMediaSources(2);
-    LazyMediaSource[] lazySources = new LazyMediaSource[4];
-    for (int i = 0; i < 4; i++) {
-      lazySources[i] = new LazyMediaSource();
-    }
-
-    //Add lazy sources before preparation
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    mediaSource.addMediaSource(lazySources[0]);
-    mediaSource.addMediaSource(0, childSources[0]);
-    mediaSource.removeMediaSource(1);
-    mediaSource.addMediaSource(1, lazySources[1]);
-    assertNull(timeline);
-    prepareAndListenToTimelineUpdates(mediaSource);
-    waitForTimelineUpdate();
-    assertNotNull(timeline);
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 1);
-    TimelineAsserts.assertWindowIds(timeline, 111, null);
-    TimelineAsserts.assertWindowIsDynamic(timeline, false, true);
-
-    lazySources[1].triggerTimelineUpdate(createFakeTimeline(8));
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 9);
-    TimelineAsserts.assertWindowIds(timeline, 111, 999);
-    TimelineAsserts.assertWindowIsDynamic(timeline, false, false);
-    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
-        TIMEOUT_MS);
-
-    //Add lazy sources after preparation (and also try to prepare media period from lazy source).
-    mediaSource.addMediaSource(1, lazySources[2]);
-    waitForTimelineUpdate();
-    mediaSource.addMediaSource(2, childSources[1]);
-    waitForTimelineUpdate();
-    mediaSource.addMediaSource(0, lazySources[3]);
-    waitForTimelineUpdate();
-    mediaSource.removeMediaSource(2);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 2, 9);
-    TimelineAsserts.assertWindowIds(timeline, null, 111, 222, 999);
-    TimelineAsserts.assertWindowIsDynamic(timeline, true, false, false, false);
-
-    MediaPeriod lazyPeriod = mediaSource.createPeriod(new MediaPeriodId(0), null);
-    assertNotNull(lazyPeriod);
-    final ConditionVariable lazyPeriodPrepared = new ConditionVariable();
-    lazyPeriod.prepare(new Callback() {
-      @Override
-      public void onPrepared(MediaPeriod mediaPeriod) {
-        lazyPeriodPrepared.open();
-      }
-      @Override
-      public void onContinueLoadingRequested(MediaPeriod source) {}
-    }, 0);
-    assertFalse(lazyPeriodPrepared.block(1));
-    MediaPeriod secondLazyPeriod = mediaSource.createPeriod(new MediaPeriodId(0), null);
-    assertNotNull(secondLazyPeriod);
-    mediaSource.releasePeriod(secondLazyPeriod);
-
-    lazySources[3].triggerTimelineUpdate(createFakeTimeline(7));
-    waitForTimelineUpdate();
-    TimelineAsserts.assertPeriodCounts(timeline, 8, 1, 2, 9);
-    TimelineAsserts.assertWindowIds(timeline, 888, 111, 222, 999);
-    TimelineAsserts.assertWindowIsDynamic(timeline, false, false, false, false);
-    assertTrue(lazyPeriodPrepared.block(TIMEOUT_MS));
-    mediaSource.releasePeriod(lazyPeriod);
-
-    mediaSource.releaseSource();
-    childSources[0].assertReleased();
-    childSources[1].assertReleased();
-  }
-
-  public void testEmptyTimelineMediaSource() throws InterruptedException {
-    timeline = null;
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource(
-        new FakeShuffleOrder(0));
-    prepareAndListenToTimelineUpdates(mediaSource);
-    assertNotNull(timeline);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertEmpty(timeline);
-
-    mediaSource.addMediaSource(new FakeMediaSource(Timeline.EMPTY, null));
-    waitForTimelineUpdate();
-    TimelineAsserts.assertEmpty(timeline);
-
-    mediaSource.addMediaSources(Arrays.asList(new MediaSource[] {
-        new FakeMediaSource(Timeline.EMPTY, null), new FakeMediaSource(Timeline.EMPTY, null),
-        new FakeMediaSource(Timeline.EMPTY, null), new FakeMediaSource(Timeline.EMPTY, null),
-        new FakeMediaSource(Timeline.EMPTY, null), new FakeMediaSource(Timeline.EMPTY, null)
-    }));
-    waitForTimelineUpdate();
-    TimelineAsserts.assertEmpty(timeline);
-
-    // Insert non-empty media source to leave empty sources at the start, the end, and the middle
-    // (with single and multiple empty sources in a row).
-    MediaSource[] mediaSources = createMediaSources(3);
-    mediaSource.addMediaSource(1, mediaSources[0]);
-    waitForTimelineUpdate();
-    mediaSource.addMediaSource(4, mediaSources[1]);
-    waitForTimelineUpdate();
-    mediaSource.addMediaSource(6, mediaSources[2]);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        1, 2, C.INDEX_UNSET);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, true,
-        C.INDEX_UNSET, 0, 1);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
-    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
-    assertEquals(0, timeline.getFirstWindowIndex(false));
-    assertEquals(2, timeline.getLastWindowIndex(false));
-    assertEquals(2, timeline.getFirstWindowIndex(true));
-    assertEquals(0, timeline.getLastWindowIndex(true));
-    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
-        TIMEOUT_MS);
-  }
-
-  public void testIllegalArguments() {
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    MediaSource validSource = new FakeMediaSource(createFakeTimeline(1), null);
-
-    // Null sources.
-    try {
-      mediaSource.addMediaSource(null);
-      fail("Null mediaSource not allowed.");
-    } catch (NullPointerException e) {
-      // Expected.
-    }
-
-    MediaSource[] mediaSources = { validSource, null };
-    try {
-      mediaSource.addMediaSources(Arrays.asList(mediaSources));
-      fail("Null mediaSource not allowed.");
-    } catch (NullPointerException e) {
-      // Expected.
-    }
-
-    // Duplicate sources.
-    mediaSource.addMediaSource(validSource);
-    try {
-      mediaSource.addMediaSource(validSource);
-      fail("Duplicate mediaSource not allowed.");
-    } catch (IllegalArgumentException e) {
-      // Expected.
-    }
-
-    mediaSources = new MediaSource[] {
-        new FakeMediaSource(createFakeTimeline(2), null), validSource };
-    try {
-      mediaSource.addMediaSources(Arrays.asList(mediaSources));
-      fail("Duplicate mediaSource not allowed.");
-    } catch (IllegalArgumentException e) {
-      // Expected.
-    }
-  }
-
-  public void testCustomCallbackBeforePreparationAddSingle() {
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    Runnable runnable = Mockito.mock(Runnable.class);
-
-    mediaSource.addMediaSource(createFakeMediaSource(), runnable);
-    verify(runnable).run();
-  }
-
-  public void testCustomCallbackBeforePreparationAddMultiple() {
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    Runnable runnable = Mockito.mock(Runnable.class);
-
-    mediaSource.addMediaSources(Arrays.asList(
-        new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}), runnable);
-    verify(runnable).run();
-  }
-
-  public void testCustomCallbackBeforePreparationAddSingleWithIndex() {
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    Runnable runnable = Mockito.mock(Runnable.class);
-
-    mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), runnable);
-    verify(runnable).run();
-  }
-
-  public void testCustomCallbackBeforePreparationAddMultipleWithIndex() {
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    Runnable runnable = Mockito.mock(Runnable.class);
-
-    mediaSource.addMediaSources(/* index */ 0, Arrays.asList(
-        new MediaSource[]{createFakeMediaSource(), createFakeMediaSource()}), runnable);
-    verify(runnable).run();
-  }
-
-  public void testCustomCallbackBeforePreparationRemove() throws InterruptedException {
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    Runnable runnable = Mockito.mock(Runnable.class);
-    mediaSource.addMediaSource(createFakeMediaSource());
-
-    mediaSource.removeMediaSource(/* index */ 0, runnable);
-    verify(runnable).run();
-  }
-
-  public void testCustomCallbackBeforePreparationMove() throws InterruptedException {
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    Runnable runnable = Mockito.mock(Runnable.class);
-    mediaSource.addMediaSources(Arrays.asList(
-        new MediaSource[]{createFakeMediaSource(), createFakeMediaSource()}));
-
-    mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, runnable);
-    verify(runnable).run();
-  }
-
-  public void testCustomCallbackAfterPreparationAddSingle() throws InterruptedException {
-    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
-        setUpDynamicMediaSourceOnHandlerThread();
-    final Runnable runnable = createCustomRunnable();
-
-    sourceHandlerPair.handler.post(new Runnable() {
-      @Override
-      public void run() {
-        sourceHandlerPair.mediaSource.addMediaSource(createFakeMediaSource(), runnable);
-      }
-    });
-    waitForCustomRunnable();
-  }
-
-  public void testCustomCallbackAfterPreparationAddMultiple() throws InterruptedException {
-    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
-        setUpDynamicMediaSourceOnHandlerThread();
-    final Runnable runnable = createCustomRunnable();
-
-    sourceHandlerPair.handler.post(new Runnable() {
-      @Override
-      public void run() {
-        sourceHandlerPair.mediaSource.addMediaSources(Arrays.asList(
-            new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}), runnable);
-      }
-    });
-    waitForCustomRunnable();
-  }
-
-  public void testCustomCallbackAfterPreparationAddSingleWithIndex() throws InterruptedException {
-    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
-        setUpDynamicMediaSourceOnHandlerThread();
-    final Runnable runnable = createCustomRunnable();
-
-    sourceHandlerPair.handler.post(new Runnable() {
-      @Override
-      public void run() {
-        sourceHandlerPair.mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(),
-            runnable);
-      }
-    });
-    waitForCustomRunnable();
-  }
-
-  public void testCustomCallbackAfterPreparationAddMultipleWithIndex() throws InterruptedException {
-    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
-        setUpDynamicMediaSourceOnHandlerThread();
-    final Runnable runnable = createCustomRunnable();
-
-    sourceHandlerPair.handler.post(new Runnable() {
-      @Override
-      public void run() {
-        sourceHandlerPair.mediaSource.addMediaSources(/* index */ 0, Arrays.asList(
-            new MediaSource[]{createFakeMediaSource(), createFakeMediaSource()}), runnable);
-      }
-    });
-    waitForCustomRunnable();
-  }
-
-  public void testCustomCallbackAfterPreparationRemove() throws InterruptedException {
-    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
-        setUpDynamicMediaSourceOnHandlerThread();
-    final Runnable runnable = createCustomRunnable();
-    sourceHandlerPair.handler.post(new Runnable() {
-      @Override
-      public void run() {
-        sourceHandlerPair.mediaSource.addMediaSource(createFakeMediaSource());
-      }
-    });
-    waitForTimelineUpdate();
-
-    sourceHandlerPair.handler.post(new Runnable() {
-      @Override
-      public void run() {
-        sourceHandlerPair.mediaSource.removeMediaSource(/* index */ 0, runnable);
-      }
-    });
-    waitForCustomRunnable();
-  }
-
-  public void testCustomCallbackAfterPreparationMove() throws InterruptedException {
-    final DynamicConcatenatingMediaSourceAndHandler sourceHandlerPair =
-        setUpDynamicMediaSourceOnHandlerThread();
-    final Runnable runnable = createCustomRunnable();
-    sourceHandlerPair.handler.post(new Runnable() {
-      @Override
-      public void run() {
-        sourceHandlerPair.mediaSource.addMediaSources(Arrays.asList(
-            new MediaSource[]{createFakeMediaSource(), createFakeMediaSource()}));
-      }
-    });
-    waitForTimelineUpdate();
-
-    sourceHandlerPair.handler.post(new Runnable() {
-      @Override
-      public void run() {
-        sourceHandlerPair.mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0,
-            runnable);
-      }
-    });
-    waitForCustomRunnable();
-  }
-
-  public void testPeriodCreationWithAds() throws InterruptedException {
-    // Create dynamic media source with ad child source.
-    Timeline timelineContentOnly = new FakeTimeline(
-        new TimelineWindowDefinition(2, 111, true, false, 10 * C.MICROS_PER_SECOND));
-    Timeline timelineWithAds = new FakeTimeline(
-        new TimelineWindowDefinition(2, 222, true, false, 10 * C.MICROS_PER_SECOND, 1, 1));
-    FakeMediaSource mediaSourceContentOnly = new FakeMediaSource(timelineContentOnly, null);
-    FakeMediaSource mediaSourceWithAds = new FakeMediaSource(timelineWithAds, null);
-    DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    mediaSource.addMediaSource(mediaSourceContentOnly);
-    mediaSource.addMediaSource(mediaSourceWithAds);
-    assertNull(timeline);
-
-    // Prepare and assert timeline contains ad groups.
-    prepareAndListenToTimelineUpdates(mediaSource);
-    waitForTimelineUpdate();
-    TimelineAsserts.assertAdGroupCounts(timeline, 0, 0, 1, 1);
-
-    // Create all periods and assert period creation of child media sources has been called.
-    TimelineAsserts.assertAllPeriodsCanBeCreatedPreparedAndReleased(mediaSource, timeline,
-        TIMEOUT_MS);
-    mediaSourceContentOnly.assertMediaPeriodCreated(new MediaPeriodId(0));
-    mediaSourceContentOnly.assertMediaPeriodCreated(new MediaPeriodId(1));
-    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(0));
-    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(1));
-    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(0, 0, 0));
-    mediaSourceWithAds.assertMediaPeriodCreated(new MediaPeriodId(1, 0, 0));
-  }
-
-  private DynamicConcatenatingMediaSourceAndHandler setUpDynamicMediaSourceOnHandlerThread()
-      throws InterruptedException {
-    HandlerThread handlerThread = new HandlerThread("TestCustomCallbackExecutionThread");
-    handlerThread.start();
-    Handler.Callback handlerCallback = Mockito.mock(Handler.Callback.class);
-    when(handlerCallback.handleMessage(any(Message.class))).thenReturn(false);
-    Handler handler = new Handler(handlerThread.getLooper(), handlerCallback);
-    final DynamicConcatenatingMediaSource mediaSource = new DynamicConcatenatingMediaSource();
-    handler.post(new Runnable() {
-      @Override
-      public void run() {
-        prepareAndListenToTimelineUpdates(mediaSource);
-      }
-    });
-    waitForTimelineUpdate();
-    return new DynamicConcatenatingMediaSourceAndHandler(mediaSource, handler);
-  }
-
-  private void prepareAndListenToTimelineUpdates(MediaSource mediaSource) {
-    mediaSource.prepareSource(new StubExoPlayer(), true, new Listener() {
-      @Override
-      public void onSourceInfoRefreshed(MediaSource source, Timeline newTimeline, Object manifest) {
-        timeline = newTimeline;
-        synchronized (DynamicConcatenatingMediaSourceTest.this) {
-          timelineUpdated = true;
-          DynamicConcatenatingMediaSourceTest.this.notify();
-        }
-      }
-    });
-  }
-
-  private synchronized void waitForTimelineUpdate() throws InterruptedException {
-    long deadlineMs = System.currentTimeMillis() + TIMEOUT_MS;
-    while (!timelineUpdated) {
-      wait(TIMEOUT_MS);
-      if (System.currentTimeMillis() >= deadlineMs) {
-        fail("No timeline update occurred within timeout.");
-      }
-    }
-    timelineUpdated = false;
-  }
-
-  private Runnable createCustomRunnable() {
-    return new Runnable() {
-      @Override
-      public void run() {
-        synchronized (DynamicConcatenatingMediaSourceTest.this) {
-          assertTrue(timelineUpdated);
-          timelineUpdated = false;
-          customRunnableCalled = true;
-          DynamicConcatenatingMediaSourceTest.this.notify();
-        }
-      }
-    };
-  }
-
-  private synchronized void waitForCustomRunnable() throws InterruptedException {
-    long deadlineMs = System.currentTimeMillis() + TIMEOUT_MS;
-    while (!customRunnableCalled) {
-      wait(TIMEOUT_MS);
-      if (System.currentTimeMillis() >= deadlineMs) {
-        fail("No custom runnable call occurred within timeout.");
-      }
-    }
-    customRunnableCalled = false;
-  }
-
-  private static FakeMediaSource[] createMediaSources(int count) {
-    FakeMediaSource[] sources = new FakeMediaSource[count];
-    for (int i = 0; i < count; i++) {
-      sources[i] = new FakeMediaSource(createFakeTimeline(i), null);
-    }
-    return sources;
-  }
-
-  private static FakeMediaSource createFakeMediaSource() {
-    return new FakeMediaSource(createFakeTimeline(/* index */ 0), null);
-  }
-
-  private static FakeTimeline createFakeTimeline(int index) {
-    return new FakeTimeline(new TimelineWindowDefinition(index + 1, (index + 1) * 111));
-  }
-
-  private static class DynamicConcatenatingMediaSourceAndHandler {
-
-    public final DynamicConcatenatingMediaSource mediaSource;
-    public final Handler handler;
-
-    public DynamicConcatenatingMediaSourceAndHandler(DynamicConcatenatingMediaSource mediaSource,
-        Handler handler) {
-      this.mediaSource = mediaSource;
-      this.handler = handler;
-    }
-
-  }
-
-  private static class LazyMediaSource implements MediaSource {
-
-    private Listener listener;
-
-    public void triggerTimelineUpdate(Timeline timeline) {
-      listener.onSourceInfoRefreshed(this, timeline, null);
-    }
-
-    @Override
-    public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
-      this.listener = listener;
-    }
-
-    @Override
-    public void maybeThrowSourceInfoRefreshError() throws IOException {
-    }
-
-    @Override
-    public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
-      return new FakeMediaPeriod(TrackGroupArray.EMPTY);
-    }
-
-    @Override
-    public void releasePeriod(MediaPeriod mediaPeriod) {
-    }
-
-    @Override
-    public void releaseSource() {
-    }
-
-  }
-
-  /**
-   * Stub ExoPlayer which only accepts custom messages and runs them on a separate handler thread.
-   */
-  private static class StubExoPlayer implements ExoPlayer, Handler.Callback {
-
-    private final Handler handler;
-
-    public StubExoPlayer() {
-      HandlerThread handlerThread = new HandlerThread("StubExoPlayerThread");
-      handlerThread.start();
-      handler = new Handler(handlerThread.getLooper(), this);
-    }
-
-    @Override
-    public Looper getPlaybackLooper() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void addListener(Player.EventListener listener) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void removeListener(Player.EventListener listener) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getPlaybackState() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void prepare(MediaSource mediaSource) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void setPlayWhenReady(boolean playWhenReady) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean getPlayWhenReady() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void setRepeatMode(@RepeatMode int repeatMode) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getRepeatMode() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean getShuffleModeEnabled() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isLoading() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void seekToDefaultPosition() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void seekToDefaultPosition(int windowIndex) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void seekTo(long positionMs) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void seekTo(int windowIndex, long positionMs) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void setPlaybackParameters(PlaybackParameters playbackParameters) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public PlaybackParameters getPlaybackParameters() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void stop() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void release() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void sendMessages(ExoPlayerMessage... messages) {
-      handler.obtainMessage(0, messages).sendToTarget();
-    }
-
-    @Override
-    public void blockingSendMessages(ExoPlayerMessage... messages) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getRendererCount() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getRendererType(int index) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public TrackGroupArray getCurrentTrackGroups() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public TrackSelectionArray getCurrentTrackSelections() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public Object getCurrentManifest() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public Timeline getCurrentTimeline() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getCurrentPeriodIndex() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getCurrentWindowIndex() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getNextWindowIndex() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getPreviousWindowIndex() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public long getDuration() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public long getCurrentPosition() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public long getBufferedPosition() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getBufferedPercentage() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isCurrentWindowDynamic() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isCurrentWindowSeekable() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean isPlayingAd() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getCurrentAdGroupIndex() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getCurrentAdIndexInAdGroup() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public long getContentPosition() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean handleMessage(Message msg) {
-      ExoPlayerMessage[] messages = (ExoPlayerMessage[]) msg.obj;
-      for (ExoPlayerMessage message : messages) {
-        try {
-          message.target.handleMessage(message.messageType, message.message);
-        } catch (ExoPlaybackException e) {
-          fail("Unexpected ExoPlaybackException.");
-        }
-      }
-      return true;
-    }
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
deleted file mode 100644
index 2c8deb74b4..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source;
-
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.testutil.FakeMediaSource;
-import com.google.android.exoplayer2.testutil.FakeTimeline;
-import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import com.google.android.exoplayer2.testutil.TimelineAsserts;
-import junit.framework.TestCase;
-
-/**
- * Unit tests for {@link LoopingMediaSource}.
- */
-public class LoopingMediaSourceTest extends TestCase {
-
-  private final Timeline multiWindowTimeline;
-
-  public LoopingMediaSourceTest() {
-    multiWindowTimeline = TestUtil.extractTimelineFromMediaSource(new FakeMediaSource(
-        new FakeTimeline(new TimelineWindowDefinition(1, 111),
-            new TimelineWindowDefinition(1, 222), new TimelineWindowDefinition(1, 333)), null));
-  }
-
-  public void testSingleLoop() {
-    Timeline timeline = getLoopingTimeline(multiWindowTimeline, 1);
-    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1);
-    for (boolean shuffled : new boolean[] {false, true}) {
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          C.INDEX_UNSET, 0, 1);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
-          0, 1, 2);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
-          2, 0, 1);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          1, 2, C.INDEX_UNSET);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
-    }
-  }
-
-  public void testMultiLoop() {
-    Timeline timeline = getLoopingTimeline(multiWindowTimeline, 3);
-    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333, 111, 222, 333, 111, 222, 333);
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1, 1, 1, 1, 1, 1, 1);
-    for (boolean shuffled : new boolean[] {false, true}) {
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          C.INDEX_UNSET, 0, 1, 2, 3, 4, 5, 6, 7, 8);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
-          0, 1, 2, 3, 4, 5, 6, 7, 8);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
-          8, 0, 1, 2, 3, 4, 5, 6, 7);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          1, 2, 3, 4, 5, 6, 7, 8, C.INDEX_UNSET);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
-          0, 1, 2, 3, 4, 5, 6, 7, 8);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
-          1, 2, 3, 4, 5, 6, 7, 8, 0);
-    }
-  }
-
-  public void testInfiniteLoop() {
-    Timeline timeline = getLoopingTimeline(multiWindowTimeline, Integer.MAX_VALUE);
-    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
-    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1);
-    for (boolean shuffled : new boolean[] {false, true}) {
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled,
-          2, 0, 1);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled,
-          0, 1, 2);
-      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled,
-          2, 0, 1);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled, 1, 2, 0);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2);
-      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
-    }
-  }
-
-  public void testEmptyTimelineLoop() {
-    Timeline timeline = getLoopingTimeline(Timeline.EMPTY, 1);
-    TimelineAsserts.assertEmpty(timeline);
-
-    timeline = getLoopingTimeline(Timeline.EMPTY, 3);
-    TimelineAsserts.assertEmpty(timeline);
-
-    timeline = getLoopingTimeline(Timeline.EMPTY, Integer.MAX_VALUE);
-    TimelineAsserts.assertEmpty(timeline);
-  }
-
-  /**
-   * Wraps the specified timeline in a {@link LoopingMediaSource} and returns
-   * the looping timeline.
-   */
-  private static Timeline getLoopingTimeline(Timeline timeline, int loopCount) {
-    MediaSource mediaSource = new FakeMediaSource(timeline, null);
-    return TestUtil.extractTimelineFromMediaSource(
-        new LoopingMediaSource(mediaSource, loopCount));
-  }
-
-}
-
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
deleted file mode 100644
index 7d3c06b42e..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
+++ /dev/null
@@ -1,241 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.text.webvtt;
-
-import android.graphics.Typeface;
-import android.test.InstrumentationTestCase;
-import android.text.Layout.Alignment;
-import android.text.Spanned;
-import android.text.style.BackgroundColorSpan;
-import android.text.style.ForegroundColorSpan;
-import android.text.style.StyleSpan;
-import android.text.style.TypefaceSpan;
-import android.text.style.UnderlineSpan;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import com.google.android.exoplayer2.text.Cue;
-import com.google.android.exoplayer2.text.SubtitleDecoderException;
-import java.io.IOException;
-import java.util.List;
-
-/**
- * Unit test for {@link WebvttDecoder}.
- */
-public class WebvttDecoderTest extends InstrumentationTestCase {
-
-  private static final String TYPICAL_FILE = "webvtt/typical";
-  private static final String TYPICAL_WITH_BAD_TIMESTAMPS = "webvtt/typical_with_bad_timestamps";
-  private static final String TYPICAL_WITH_IDS_FILE = "webvtt/typical_with_identifiers";
-  private static final String TYPICAL_WITH_COMMENTS_FILE = "webvtt/typical_with_comments";
-  private static final String WITH_POSITIONING_FILE = "webvtt/with_positioning";
-  private static final String WITH_BAD_CUE_HEADER_FILE = "webvtt/with_bad_cue_header";
-  private static final String WITH_TAGS_FILE = "webvtt/with_tags";
-  private static final String WITH_CSS_STYLES = "webvtt/with_css_styles";
-  private static final String WITH_CSS_COMPLEX_SELECTORS = "webvtt/with_css_complex_selectors";
-  private static final String EMPTY_FILE = "webvtt/empty";
-
-  public void testDecodeEmpty() throws IOException {
-    WebvttDecoder decoder = new WebvttDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), EMPTY_FILE);
-    try {
-      decoder.decode(bytes, bytes.length, false);
-      fail();
-    } catch (SubtitleDecoderException expected) {
-      // Do nothing.
-    }
-  }
-
-  public void testDecodeTypical() throws IOException, SubtitleDecoderException {
-    WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_FILE);
-
-    // Test event count.
-    assertEquals(4, subtitle.getEventTimeCount());
-
-    // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
-  }
-
-  public void testDecodeTypicalWithBadTimestamps() throws IOException, SubtitleDecoderException {
-    WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_WITH_BAD_TIMESTAMPS);
-
-    // Test event count.
-    assertEquals(4, subtitle.getEventTimeCount());
-
-    // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
-  }
-
-  public void testDecodeTypicalWithIds() throws IOException, SubtitleDecoderException {
-    WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_WITH_IDS_FILE);
-
-    // Test event count.
-    assertEquals(4, subtitle.getEventTimeCount());
-
-    // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
-  }
-
-  public void testDecodeTypicalWithComments() throws IOException, SubtitleDecoderException {
-    WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_WITH_COMMENTS_FILE);
-
-    // test event count
-    assertEquals(4, subtitle.getEventTimeCount());
-
-    // test cues
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
-  }
-
-  public void testDecodeWithTags() throws IOException, SubtitleDecoderException {
-    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_TAGS_FILE);
-
-    // Test event count.
-    assertEquals(8, subtitle.getEventTimeCount());
-
-    // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
-    assertCue(subtitle, 4, 4000000, 5000000, "This is the third subtitle.");
-    assertCue(subtitle, 6, 6000000, 7000000, "This is the <fourth> &subtitle.");
-  }
-
-  public void testDecodeWithPositioning() throws IOException, SubtitleDecoderException {
-    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_POSITIONING_FILE);
-    // Test event count.
-    assertEquals(12, subtitle.getEventTimeCount());
-    // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.", Alignment.ALIGN_NORMAL,
-        Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.TYPE_UNSET, 0.1f, Cue.ANCHOR_TYPE_START, 0.35f);
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.",
-        Alignment.ALIGN_OPPOSITE, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET, 0.35f);
-    assertCue(subtitle, 4, 4000000, 5000000, "This is the third subtitle.",
-        Alignment.ALIGN_CENTER, 0.45f, Cue.LINE_TYPE_FRACTION, Cue.ANCHOR_TYPE_END, Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET, 0.35f);
-    assertCue(subtitle, 6, 6000000, 7000000, "This is the fourth subtitle.",
-        Alignment.ALIGN_CENTER, -11f, Cue.LINE_TYPE_NUMBER, Cue.TYPE_UNSET, Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
-    assertCue(subtitle, 8, 7000000, 8000000, "This is the fifth subtitle.",
-        Alignment.ALIGN_OPPOSITE, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.TYPE_UNSET, 0.1f,
-        Cue.ANCHOR_TYPE_END, 0.1f);
-    assertCue(subtitle, 10, 10000000, 11000000, "This is the sixth subtitle.",
-        Alignment.ALIGN_CENTER, 0.45f, Cue.LINE_TYPE_FRACTION, Cue.ANCHOR_TYPE_END, Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET, 0.35f);
-  }
-
-  public void testDecodeWithBadCueHeader() throws IOException, SubtitleDecoderException {
-    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_BAD_CUE_HEADER_FILE);
-
-    // Test event count.
-    assertEquals(4, subtitle.getEventTimeCount());
-
-    // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 4000000, 5000000, "This is the third subtitle.");
-  }
-
-  public void testWebvttWithCssStyle() throws IOException, SubtitleDecoderException {
-    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_CSS_STYLES);
-
-    // Test event count.
-    assertEquals(8, subtitle.getEventTimeCount());
-
-    // Test cues.
-    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
-    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
-
-    Spanned s1 = getUniqueSpanTextAt(subtitle, 0);
-    Spanned s2 = getUniqueSpanTextAt(subtitle, 2345000);
-    Spanned s3 = getUniqueSpanTextAt(subtitle, 20000000);
-    Spanned s4 = getUniqueSpanTextAt(subtitle, 25000000);
-    assertEquals(1, s1.getSpans(0, s1.length(), ForegroundColorSpan.class).length);
-    assertEquals(1, s1.getSpans(0, s1.length(), BackgroundColorSpan.class).length);
-    assertEquals(2, s2.getSpans(0, s2.length(), ForegroundColorSpan.class).length);
-    assertEquals(1, s3.getSpans(10, s3.length(), UnderlineSpan.class).length);
-    assertEquals(2, s4.getSpans(0, 16, BackgroundColorSpan.class).length);
-    assertEquals(1, s4.getSpans(17, s4.length(), StyleSpan.class).length);
-    assertEquals(Typeface.BOLD, s4.getSpans(17, s4.length(), StyleSpan.class)[0].getStyle());
-  }
-
-  public void testWithComplexCssSelectors() throws IOException, SubtitleDecoderException {
-    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_CSS_COMPLEX_SELECTORS);
-    Spanned text = getUniqueSpanTextAt(subtitle, 0);
-    assertEquals(1, text.getSpans(30, text.length(), ForegroundColorSpan.class).length);
-    assertEquals(0xFFEE82EE,
-        text.getSpans(30, text.length(), ForegroundColorSpan.class)[0].getForegroundColor());
-    assertEquals(1, text.getSpans(30, text.length(), TypefaceSpan.class).length);
-    assertEquals("courier", text.getSpans(30, text.length(), TypefaceSpan.class)[0].getFamily());
-
-    text = getUniqueSpanTextAt(subtitle, 2000000);
-    assertEquals(1, text.getSpans(5, text.length(), TypefaceSpan.class).length);
-    assertEquals("courier", text.getSpans(5, text.length(), TypefaceSpan.class)[0].getFamily());
-
-    text = getUniqueSpanTextAt(subtitle, 2500000);
-    assertEquals(1, text.getSpans(5, text.length(), StyleSpan.class).length);
-    assertEquals(Typeface.BOLD, text.getSpans(5, text.length(), StyleSpan.class)[0].getStyle());
-    assertEquals(1, text.getSpans(5, text.length(), TypefaceSpan.class).length);
-    assertEquals("courier", text.getSpans(5, text.length(), TypefaceSpan.class)[0].getFamily());
-
-    text = getUniqueSpanTextAt(subtitle, 4000000);
-    assertEquals(0, text.getSpans(6, 22, StyleSpan.class).length);
-    assertEquals(1, text.getSpans(30, text.length(), StyleSpan.class).length);
-    assertEquals(Typeface.BOLD, text.getSpans(30, text.length(), StyleSpan.class)[0].getStyle());
-
-    text = getUniqueSpanTextAt(subtitle, 5000000);
-    assertEquals(0, text.getSpans(9, 17, StyleSpan.class).length);
-    assertEquals(1, text.getSpans(19, text.length(), StyleSpan.class).length);
-    assertEquals(Typeface.ITALIC, text.getSpans(19, text.length(), StyleSpan.class)[0].getStyle());
-  }
-
-  private WebvttSubtitle getSubtitleForTestAsset(String asset) throws IOException,
-      SubtitleDecoderException {
-    WebvttDecoder decoder = new WebvttDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), asset);
-    return decoder.decode(bytes, bytes.length, false);
-  }
-
-  private Spanned getUniqueSpanTextAt(WebvttSubtitle sub, long timeUs) {
-    return (Spanned) sub.getCues(timeUs).get(0).text;
-  }
-
-  private static void assertCue(WebvttSubtitle subtitle, int eventTimeIndex, long startTimeUs,
-      int endTimeUs, String text) {
-    assertCue(subtitle, eventTimeIndex, startTimeUs, endTimeUs, text, null, Cue.DIMEN_UNSET,
-        Cue.TYPE_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
-  }
-
-  private static void assertCue(WebvttSubtitle subtitle, int eventTimeIndex, long startTimeUs,
-      int endTimeUs, String text, Alignment textAlignment, float line, int lineType, int lineAnchor,
-      float position, int positionAnchor, float size) {
-    assertEquals(startTimeUs, subtitle.getEventTime(eventTimeIndex));
-    assertEquals(endTimeUs, subtitle.getEventTime(eventTimeIndex + 1));
-    List<Cue> cues = subtitle.getCues(subtitle.getEventTime(eventTimeIndex));
-    assertEquals(1, cues.size());
-    // Assert cue properties.
-    Cue cue = cues.get(0);
-    assertEquals(text, cue.text.toString());
-    assertEquals(textAlignment, cue.textAlignment);
-    assertEquals(line, cue.line);
-    assertEquals(lineType, cue.lineType);
-    assertEquals(lineAnchor, cue.lineAnchor);
-    assertEquals(position, cue.position);
-    assertEquals(positionAnchor, cue.positionAnchor);
-    assertEquals(size, cue.size);
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
index e19f7ad033..3465393853 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.upstream;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import android.app.Instrumentation;
 import android.content.ContentProvider;
 import android.content.ContentResolver;
@@ -75,7 +77,7 @@ public void testReadInvalidUri() throws Exception {
       fail();
     } catch (ContentDataSource.ContentDataSourceException e) {
       // Expected.
-      assertTrue(e.getCause() instanceof FileNotFoundException);
+      assertThat(e.getCause()).isInstanceOf(FileNotFoundException.class);
     } finally {
       dataSource.close();
     }
@@ -87,7 +89,7 @@ private static void assertData(Instrumentation instrumentation, int offset, int
     ContentDataSource dataSource = new ContentDataSource(instrumentation.getContext());
     try {
       DataSpec dataSpec = new DataSpec(contentUri, offset, length, null);
-      byte[] completeData = TestUtil.getByteArray(instrumentation, DATA_PATH);
+      byte[] completeData = TestUtil.getByteArray(instrumentation.getContext(), DATA_PATH);
       byte[] expectedData = Arrays.copyOfRange(completeData, offset,
           length == C.LENGTH_UNSET ? completeData.length : offset + length);
       TestUtil.assertDataSourceContent(dataSource, dataSpec, expectedData, !pipeMode);
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
index 7f6e203c20..9791fdb46f 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndexTest.java
@@ -1,7 +1,9 @@
 package com.google.android.exoplayer2.upstream.cache;
 
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
 import android.test.InstrumentationTestCase;
-import android.test.MoreAsserts;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Util;
@@ -9,10 +11,8 @@
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Set;
-import junit.framework.AssertionFailedError;
 
 /**
  * Tests {@link CachedContentIndex}.
@@ -36,6 +36,7 @@
 
   @Override
   public void setUp() throws Exception {
+    super.setUp();
     cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
     index = new CachedContentIndex(cacheDir);
   }
@@ -43,6 +44,7 @@ public void setUp() throws Exception {
   @Override
   protected void tearDown() throws Exception {
     Util.recursiveDelete(cacheDir);
+    super.tearDown();
   }
 
   public void testAddGetRemove() throws Exception {
@@ -53,48 +55,46 @@ public void testAddGetRemove() throws Exception {
     // Add two CachedContents with add methods
     CachedContent cachedContent1 = new CachedContent(5, key1, 10);
     index.addNew(cachedContent1);
-    CachedContent cachedContent2 = index.add(key2);
-    assertTrue(cachedContent1.id != cachedContent2.id);
+    CachedContent cachedContent2 = index.getOrAdd(key2);
+    assertThat(cachedContent1.id != cachedContent2.id).isTrue();
 
     // add a span
     File cacheSpanFile = SimpleCacheSpanTest
         .createCacheSpanFile(cacheDir, cachedContent1.id, 10, 20, 30);
     SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(cacheSpanFile, index);
-    assertNotNull(span);
+    assertThat(span).isNotNull();
     cachedContent1.addSpan(span);
 
     // Check if they are added and get method returns null if the key isn't found
-    assertEquals(cachedContent1, index.get(key1));
-    assertEquals(cachedContent2, index.get(key2));
-    assertNull(index.get(key3));
+    assertThat(index.get(key1)).isEqualTo(cachedContent1);
+    assertThat(index.get(key2)).isEqualTo(cachedContent2);
+    assertThat(index.get(key3)).isNull();
 
     // test getAll()
     Collection<CachedContent> cachedContents = index.getAll();
-    assertEquals(2, cachedContents.size());
-    assertTrue(Arrays.asList(cachedContent1, cachedContent2).containsAll(cachedContents));
+    assertThat(cachedContents).containsExactly(cachedContent1, cachedContent2);
 
     // test getKeys()
     Set<String> keys = index.getKeys();
-    assertEquals(2, keys.size());
-    assertTrue(Arrays.asList(key1, key2).containsAll(keys));
+    assertThat(keys).containsExactly(key1, key2);
 
     // test getKeyForId()
-    assertEquals(key1, index.getKeyForId(cachedContent1.id));
-    assertEquals(key2, index.getKeyForId(cachedContent2.id));
+    assertThat(index.getKeyForId(cachedContent1.id)).isEqualTo(key1);
+    assertThat(index.getKeyForId(cachedContent2.id)).isEqualTo(key2);
 
     // test remove()
-    index.removeEmpty(key2);
-    index.removeEmpty(key3);
-    assertEquals(cachedContent1, index.get(key1));
-    assertNull(index.get(key2));
-    assertTrue(cacheSpanFile.exists());
+    index.maybeRemove(key2);
+    index.maybeRemove(key3);
+    assertThat(index.get(key1)).isEqualTo(cachedContent1);
+    assertThat(index.get(key2)).isNull();
+    assertThat(cacheSpanFile.exists()).isTrue();
 
     // test removeEmpty()
     index.addNew(cachedContent2);
     index.removeEmpty();
-    assertEquals(cachedContent1, index.get(key1));
-    assertNull(index.get(key2));
-    assertTrue(cacheSpanFile.exists());
+    assertThat(index.get(key1)).isEqualTo(cachedContent1);
+    assertThat(index.get(key2)).isNull();
+    assertThat(cacheSpanFile.exists()).isTrue();
   }
 
   public void testStoreAndLoad() throws Exception {
@@ -107,11 +107,11 @@ public void testLoadV1() throws Exception {
     fos.close();
 
     index.load();
-    assertEquals(2, index.getAll().size());
-    assertEquals(5, index.assignIdForKey("ABCDE"));
-    assertEquals(10, index.getContentLength("ABCDE"));
-    assertEquals(2, index.assignIdForKey("KLMNO"));
-    assertEquals(2560, index.getContentLength("KLMNO"));
+    assertThat(index.getAll()).hasSize(2);
+    assertThat(index.assignIdForKey("ABCDE")).isEqualTo(5);
+    assertThat(index.getContentLength("ABCDE")).isEqualTo(10);
+    assertThat(index.assignIdForKey("KLMNO")).isEqualTo(2);
+    assertThat(index.getContentLength("KLMNO")).isEqualTo(2560);
   }
 
   public void testStoreV1() throws Exception {
@@ -122,13 +122,13 @@ public void testStoreV1() throws Exception {
 
     byte[] buffer = new byte[testIndexV1File.length];
     FileInputStream fos = new FileInputStream(new File(cacheDir, CachedContentIndex.FILE_NAME));
-    assertEquals(testIndexV1File.length, fos.read(buffer));
-    assertEquals(-1, fos.read());
+    assertThat(fos.read(buffer)).isEqualTo(testIndexV1File.length);
+    assertThat(fos.read()).isEqualTo(-1);
     fos.close();
 
     // TODO: The order of the CachedContent stored in index file isn't defined so this test may fail
     // on a different implementation of the underlying set
-    MoreAsserts.assertEquals(testIndexV1File, buffer);
+    assertThat(buffer).isEqualTo(testIndexV1File);
   }
 
   public void testAssignIdForKeyAndGetKeyForId() throws Exception {
@@ -136,29 +136,29 @@ public void testAssignIdForKeyAndGetKeyForId() throws Exception {
     final String key2 = "key2";
     int id1 = index.assignIdForKey(key1);
     int id2 = index.assignIdForKey(key2);
-    assertEquals(key1, index.getKeyForId(id1));
-    assertEquals(key2, index.getKeyForId(id2));
-    assertTrue(id1 != id2);
-    assertEquals(id1, index.assignIdForKey(key1));
-    assertEquals(id2, index.assignIdForKey(key2));
+    assertThat(index.getKeyForId(id1)).isEqualTo(key1);
+    assertThat(index.getKeyForId(id2)).isEqualTo(key2);
+    assertThat(id1 != id2).isTrue();
+    assertThat(index.assignIdForKey(key1)).isEqualTo(id1);
+    assertThat(index.assignIdForKey(key2)).isEqualTo(id2);
   }
 
   public void testSetGetContentLength() throws Exception {
     final String key1 = "key1";
-    assertEquals(C.LENGTH_UNSET, index.getContentLength(key1));
+    assertThat(index.getContentLength(key1)).isEqualTo(C.LENGTH_UNSET);
     index.setContentLength(key1, 10);
-    assertEquals(10, index.getContentLength(key1));
+    assertThat(index.getContentLength(key1)).isEqualTo(10);
   }
 
   public void testGetNewId() throws Exception {
     SparseArray<String> idToKey = new SparseArray<>();
-    assertEquals(0, CachedContentIndex.getNewId(idToKey));
+    assertThat(CachedContentIndex.getNewId(idToKey)).isEqualTo(0);
     idToKey.put(10, "");
-    assertEquals(11, CachedContentIndex.getNewId(idToKey));
+    assertThat(CachedContentIndex.getNewId(idToKey)).isEqualTo(11);
     idToKey.put(Integer.MAX_VALUE, "");
-    assertEquals(0, CachedContentIndex.getNewId(idToKey));
+    assertThat(CachedContentIndex.getNewId(idToKey)).isEqualTo(0);
     idToKey.put(0, "");
-    assertEquals(1, CachedContentIndex.getNewId(idToKey));
+    assertThat(CachedContentIndex.getNewId(idToKey)).isEqualTo(1);
   }
 
   public void testEncryption() throws Exception {
@@ -171,36 +171,40 @@ public void testEncryption() throws Exception {
     // Rename the index file from the test above
     File file1 = new File(cacheDir, CachedContentIndex.FILE_NAME);
     File file2 = new File(cacheDir, "file2compare");
-    assertTrue(file1.renameTo(file2));
+    assertThat(file1.renameTo(file2)).isTrue();
 
     // Write a new index file
     assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
         new CachedContentIndex(cacheDir, key));
 
-    assertEquals(file2.length(), file1.length());
+    assertThat(file1.length()).isEqualTo(file2.length());
     // Assert file content is different
     FileInputStream fis1 = new FileInputStream(file1);
     FileInputStream fis2 = new FileInputStream(file2);
     for (int b; (b = fis1.read()) == fis2.read(); ) {
-      assertTrue(b != -1);
+      assertThat(b != -1).isTrue();
     }
 
     boolean threw = false;
     try {
       assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
           new CachedContentIndex(cacheDir, key2));
-    } catch (AssertionFailedError e) {
+    } catch (AssertionError e) {
       threw = true;
     }
-    assertTrue("Encrypted index file can not be read with different encryption key", threw);
+    assertWithMessage("Encrypted index file can not be read with different encryption key")
+        .that(threw)
+        .isTrue();
 
     try {
       assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir, key),
           new CachedContentIndex(cacheDir));
-    } catch (AssertionFailedError e) {
+    } catch (AssertionError e) {
       threw = true;
     }
-    assertTrue("Encrypted index file can not be read without encryption key", threw);
+    assertWithMessage("Encrypted index file can not be read without encryption key")
+        .that(threw)
+        .isTrue();
 
     // Non encrypted index file can be read even when encryption key provided.
     assertStoredAndLoadedEqual(new CachedContentIndex(cacheDir),
@@ -213,19 +217,51 @@ public void testEncryption() throws Exception {
     assertStoredAndLoadedEqual(index, new CachedContentIndex(cacheDir, key));
   }
 
+  public void testRemoveEmptyNotLockedCachedContent() throws Exception {
+    CachedContent cachedContent = new CachedContent(5, "key1", 10);
+    index.addNew(cachedContent);
+
+    index.maybeRemove(cachedContent.key);
+
+    assertThat(index.get(cachedContent.key)).isNull();
+  }
+
+  public void testCantRemoveNotEmptyCachedContent() throws Exception {
+    CachedContent cachedContent = new CachedContent(5, "key1", 10);
+    index.addNew(cachedContent);
+    File cacheSpanFile =
+        SimpleCacheSpanTest.createCacheSpanFile(cacheDir, cachedContent.id, 10, 20, 30);
+    SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(cacheSpanFile, index);
+    cachedContent.addSpan(span);
+
+    index.maybeRemove(cachedContent.key);
+
+    assertThat(index.get(cachedContent.key)).isNotNull();
+  }
+
+  public void testCantRemoveLockedCachedContent() throws Exception {
+    CachedContent cachedContent = new CachedContent(5, "key1", 10);
+    cachedContent.setLocked(true);
+    index.addNew(cachedContent);
+
+    index.maybeRemove(cachedContent.key);
+
+    assertThat(index.get(cachedContent.key)).isNotNull();
+  }
+
   private void assertStoredAndLoadedEqual(CachedContentIndex index, CachedContentIndex index2)
       throws IOException {
     index.addNew(new CachedContent(5, "key1", 10));
-    index.add("key2");
+    index.getOrAdd("key2");
     index.store();
 
     index2.load();
     Set<String> keys = index.getKeys();
     Set<String> keys2 = index2.getKeys();
-    assertEquals(keys, keys2);
+    assertThat(keys2).isEqualTo(keys);
     for (String key : keys) {
-      assertEquals(index.getContentLength(key), index2.getContentLength(key));
-      assertEquals(index.get(key).getSpans(), index2.get(key).getSpans());
+      assertThat(index2.getContentLength(key)).isEqualTo(index.getContentLength(key));
+      assertThat(index2.get(key).getSpans()).isEqualTo(index.get(key).getSpans());
     }
   }
 
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
deleted file mode 100644
index 472b5c724b..0000000000
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.upstream.cache;
-
-import android.test.InstrumentationTestCase;
-import com.google.android.exoplayer2.extractor.ChunkIndex;
-import com.google.android.exoplayer2.util.Util;
-import java.io.File;
-import java.io.IOException;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-/**
- * Tests for {@link CachedRegionTracker}.
- */
-public final class CachedRegionTrackerTest extends InstrumentationTestCase {
-
-  private static final String CACHE_KEY = "abc";
-  private static final long MS_IN_US = 1000;
-
-  // 5 chunks, each 20 bytes long and 100 ms long.
-  private static final ChunkIndex CHUNK_INDEX = new ChunkIndex(
-      new int[] {20, 20, 20, 20, 20},
-      new long[] {100, 120, 140, 160, 180},
-      new long[] {100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US},
-      new long[] {0, 100 * MS_IN_US, 200 * MS_IN_US, 300 * MS_IN_US, 400 * MS_IN_US});
-
-  @Mock private Cache cache;
-  private CachedRegionTracker tracker;
-
-  private CachedContentIndex index;
-  private File cacheDir;
-
-  @Override
-  protected void setUp() throws Exception {
-    setUpMockito(this);
-
-    tracker = new CachedRegionTracker(cache, CACHE_KEY, CHUNK_INDEX);
-    cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
-    index = new CachedContentIndex(cacheDir);
-  }
-
-  @Override
-  protected void tearDown() throws Exception {
-    Util.recursiveDelete(cacheDir);
-  }
-
-  public void testGetRegion_noSpansInCache() {
-    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(100));
-    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(150));
-  }
-
-  public void testGetRegion_fullyCached() throws Exception {
-    tracker.onSpanAdded(
-        cache,
-        newCacheSpan(100, 100));
-
-    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(101));
-    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(121));
-  }
-
-  public void testGetRegion_partiallyCached() throws Exception {
-    tracker.onSpanAdded(
-        cache,
-        newCacheSpan(100, 40));
-
-    assertEquals(200, tracker.getRegionEndTimeMs(101));
-    assertEquals(200, tracker.getRegionEndTimeMs(121));
-  }
-
-  public void testGetRegion_multipleSpanAddsJoinedCorrectly() throws Exception {
-    tracker.onSpanAdded(
-        cache,
-        newCacheSpan(100, 20));
-    tracker.onSpanAdded(
-        cache,
-        newCacheSpan(120, 20));
-
-    assertEquals(200, tracker.getRegionEndTimeMs(101));
-    assertEquals(200, tracker.getRegionEndTimeMs(121));
-  }
-
-  public void testGetRegion_fullyCachedThenPartiallyRemoved() throws Exception {
-    // Start with the full stream in cache.
-    tracker.onSpanAdded(
-        cache,
-        newCacheSpan(100, 100));
-
-    // Remove the middle bit.
-    tracker.onSpanRemoved(
-        cache,
-        newCacheSpan(140, 40));
-
-    assertEquals(200, tracker.getRegionEndTimeMs(101));
-    assertEquals(200, tracker.getRegionEndTimeMs(121));
-
-    assertEquals(CachedRegionTracker.CACHED_TO_END, tracker.getRegionEndTimeMs(181));
-  }
-
-  public void testGetRegion_subchunkEstimation() throws Exception {
-    tracker.onSpanAdded(
-        cache,
-        newCacheSpan(100, 10));
-
-    assertEquals(50, tracker.getRegionEndTimeMs(101));
-    assertEquals(CachedRegionTracker.NOT_CACHED, tracker.getRegionEndTimeMs(111));
-  }
-
-  private CacheSpan newCacheSpan(int position, int length) throws IOException {
-    return SimpleCacheSpanTest.createCacheSpan(index, cacheDir, CACHE_KEY, position, length, 0);
-  }
-
-  /**
-   * Sets up Mockito for an instrumentation test.
-   */
-  private static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
-    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
-    System.setProperty("dexmaker.dexcache",
-        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
-    MockitoAnnotations.initMocks(instrumentationTestCase);
-  }
-
-}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
index 8c684b1cb3..637a19cdd2 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
+++ b/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpanTest.java
@@ -15,6 +15,9 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
 import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
@@ -48,6 +51,7 @@ public static CacheSpan createCacheSpan(CachedContentIndex index, File cacheDir,
 
   @Override
   protected void setUp() throws Exception {
+    super.setUp();
     cacheDir = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
     index = new CachedContentIndex(cacheDir);
   }
@@ -55,6 +59,7 @@ protected void setUp() throws Exception {
   @Override
   protected void tearDown() throws Exception {
     Util.recursiveDelete(cacheDir);
+    super.tearDown();
   }
 
   public void testCacheFile() throws Exception {
@@ -86,39 +91,39 @@ public void testUpgradeFileName() throws Exception {
     for (File file : cacheDir.listFiles()) {
       SimpleCacheSpan cacheEntry = SimpleCacheSpan.createCacheEntry(file, index);
       if (file.equals(wrongEscapedV2file)) {
-        assertNull(cacheEntry);
+        assertThat(cacheEntry).isNull();
       } else {
-        assertNotNull(cacheEntry);
+        assertThat(cacheEntry).isNotNull();
       }
     }
 
-    assertTrue(v3file.exists());
-    assertFalse(v2file.exists());
-    assertTrue(wrongEscapedV2file.exists());
-    assertFalse(v1File.exists());
+    assertThat(v3file.exists()).isTrue();
+    assertThat(v2file.exists()).isFalse();
+    assertThat(wrongEscapedV2file.exists()).isTrue();
+    assertThat(v1File.exists()).isFalse();
 
     File[] files = cacheDir.listFiles();
-    assertEquals(4, files.length);
+    assertThat(files).hasLength(4);
 
     Set<String> keys = index.getKeys();
-    assertEquals("There should be only one key for all files.", 1, keys.size());
-    assertTrue(keys.contains(key));
+    assertWithMessage("There should be only one key for all files.").that(keys).hasSize(1);
+    assertThat(keys).contains(key);
 
     TreeSet<SimpleCacheSpan> spans = index.get(key).getSpans();
-    assertTrue("upgradeOldFiles() shouldn't add any spans.", spans.isEmpty());
+    assertWithMessage("upgradeOldFiles() shouldn't add any spans.").that(spans.isEmpty()).isTrue();
 
     HashMap<Long, Long> cachedPositions = new HashMap<>();
     for (File file : files) {
       SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(file, index);
       if (cacheSpan != null) {
-        assertEquals(key, cacheSpan.key);
+        assertThat(cacheSpan.key).isEqualTo(key);
         cachedPositions.put(cacheSpan.position, cacheSpan.lastAccessTimestamp);
       }
     }
 
-    assertEquals(1, (long) cachedPositions.get((long) 0));
-    assertEquals(2, (long) cachedPositions.get((long) 1));
-    assertEquals(6, (long) cachedPositions.get((long) 5));
+    assertThat(cachedPositions.get((long) 0)).isEqualTo(1);
+    assertThat(cachedPositions.get((long) 1)).isEqualTo(2);
+    assertThat(cachedPositions.get((long) 5)).isEqualTo(6);
   }
 
   private static void createTestFile(File file, int length) throws IOException {
@@ -141,14 +146,14 @@ private void assertCacheSpan(String key, long offset, long lastAccessTimestamp)
     File cacheFile = createCacheSpanFile(cacheDir, id, offset, 1, lastAccessTimestamp);
     SimpleCacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, index);
     String message = cacheFile.toString();
-    assertNotNull(message, cacheSpan);
-    assertEquals(message, cacheDir, cacheFile.getParentFile());
-    assertEquals(message, key, cacheSpan.key);
-    assertEquals(message, offset, cacheSpan.position);
-    assertEquals(message, 1, cacheSpan.length);
-    assertTrue(message, cacheSpan.isCached);
-    assertEquals(message, cacheFile, cacheSpan.file);
-    assertEquals(message, lastAccessTimestamp, cacheSpan.lastAccessTimestamp);
+    assertWithMessage(message).that(cacheSpan).isNotNull();
+    assertWithMessage(message).that(cacheFile.getParentFile()).isEqualTo(cacheDir);
+    assertWithMessage(message).that(cacheSpan.key).isEqualTo(key);
+    assertWithMessage(message).that(cacheSpan.position).isEqualTo(offset);
+    assertWithMessage(message).that(cacheSpan.length).isEqualTo(1);
+    assertWithMessage(message).that(cacheSpan.isCached).isTrue();
+    assertWithMessage(message).that(cacheSpan.file).isEqualTo(cacheFile);
+    assertWithMessage(message).that(cacheSpan.lastAccessTimestamp).isEqualTo(lastAccessTimestamp);
   }
 
   private void assertNullCacheSpan(File parent, String key, long offset,
@@ -156,7 +161,7 @@ private void assertNullCacheSpan(File parent, String key, long offset,
     File cacheFile = SimpleCacheSpan.getCacheFile(parent, index.assignIdForKey(key), offset,
         lastAccessTimestamp);
     CacheSpan cacheSpan = SimpleCacheSpan.createCacheEntry(cacheFile, index);
-    assertNull(cacheFile.toString(), cacheSpan);
+    assertWithMessage(cacheFile.toString()).that(cacheSpan).isNull();
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index a4103787d1..8ee9a13c55 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -157,7 +157,7 @@ public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
     return ADAPTIVE_NOT_SUPPORTED;
   }
 
-  // ExoPlayerComponent implementation.
+  // PlayerMessage.Target implementation.
 
   @Override
   public void handleMessage(int what, Object object) throws ExoPlaybackException {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/C.java b/library/core/src/main/java/com/google/android/exoplayer2/C.java
index 9d4049ada9..045f3bfc6e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/C.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/C.java
@@ -23,6 +23,7 @@
 import android.media.MediaFormat;
 import android.support.annotation.IntDef;
 import android.view.Surface;
+import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -122,13 +123,22 @@ private C() {}
    */
   public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
 
-  /**
-   * Represents an audio encoding, or an invalid or unset value.
-   */
+  /** Represents an audio encoding, or an invalid or unset value. */
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
-      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT, ENCODING_AC3, ENCODING_E_AC3, ENCODING_DTS,
-      ENCODING_DTS_HD})
+  @IntDef({
+    Format.NO_VALUE,
+    ENCODING_INVALID,
+    ENCODING_PCM_8BIT,
+    ENCODING_PCM_16BIT,
+    ENCODING_PCM_24BIT,
+    ENCODING_PCM_32BIT,
+    ENCODING_PCM_FLOAT,
+    ENCODING_AC3,
+    ENCODING_E_AC3,
+    ENCODING_DTS,
+    ENCODING_DTS_HD,
+    ENCODING_DOLBY_TRUEHD
+  })
   public @interface Encoding {}
 
   /**
@@ -136,44 +146,30 @@ private C() {}
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({Format.NO_VALUE, ENCODING_INVALID, ENCODING_PCM_8BIT, ENCODING_PCM_16BIT,
-      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT})
+      ENCODING_PCM_24BIT, ENCODING_PCM_32BIT, ENCODING_PCM_FLOAT})
   public @interface PcmEncoding {}
-  /**
-   * @see AudioFormat#ENCODING_INVALID
-   */
+  /** @see AudioFormat#ENCODING_INVALID */
   public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
-  /**
-   * @see AudioFormat#ENCODING_PCM_8BIT
-   */
+  /** @see AudioFormat#ENCODING_PCM_8BIT */
   public static final int ENCODING_PCM_8BIT = AudioFormat.ENCODING_PCM_8BIT;
-  /**
-   * @see AudioFormat#ENCODING_PCM_16BIT
-   */
+  /** @see AudioFormat#ENCODING_PCM_16BIT */
   public static final int ENCODING_PCM_16BIT = AudioFormat.ENCODING_PCM_16BIT;
-  /**
-   * PCM encoding with 24 bits per sample.
-   */
+  /** PCM encoding with 24 bits per sample. */
   public static final int ENCODING_PCM_24BIT = 0x80000000;
-  /**
-   * PCM encoding with 32 bits per sample.
-   */
+  /** PCM encoding with 32 bits per sample. */
   public static final int ENCODING_PCM_32BIT = 0x40000000;
-  /**
-   * @see AudioFormat#ENCODING_AC3
-   */
+  /** @see AudioFormat#ENCODING_PCM_FLOAT */
+  public static final int ENCODING_PCM_FLOAT = AudioFormat.ENCODING_PCM_FLOAT;
+  /** @see AudioFormat#ENCODING_AC3 */
   public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
-  /**
-   * @see AudioFormat#ENCODING_E_AC3
-   */
+  /** @see AudioFormat#ENCODING_E_AC3 */
   public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
-  /**
-   * @see AudioFormat#ENCODING_DTS
-   */
+  /** @see AudioFormat#ENCODING_DTS */
   public static final int ENCODING_DTS = AudioFormat.ENCODING_DTS;
-  /**
-   * @see AudioFormat#ENCODING_DTS_HD
-   */
+  /** @see AudioFormat#ENCODING_DTS_HD */
   public static final int ENCODING_DTS_HD = AudioFormat.ENCODING_DTS_HD;
+  /** @see AudioFormat#ENCODING_DOLBY_TRUEHD */
+  public static final int ENCODING_DOLBY_TRUEHD = AudioFormat.ENCODING_DOLBY_TRUEHD;
 
   /**
    * @see AudioFormat#CHANNEL_OUT_7POINT1_SURROUND
@@ -420,6 +416,11 @@ private C() {}
    */
   public static final int SELECTION_FLAG_AUTOSELECT = 4;
 
+  /**
+   * Represents an undetermined language as an ISO 639 alpha-3 language code.
+   */
+  public static final String LANGUAGE_UNDETERMINED = "und";
+
   /**
    * Represents a streaming or other media type.
    */
@@ -642,37 +643,37 @@ private C() {}
   public static final UUID PLAYREADY_UUID = new UUID(0x9A04F07998404286L, 0xAB92E65BE0885F95L);
 
   /**
-   * The type of a message that can be passed to a video {@link Renderer} via
-   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-   * should be the target {@link Surface}, or null.
+   * The type of a message that can be passed to a video {@link Renderer} via {@link
+   * ExoPlayer#createMessage(Target)}. The message payload should be the target {@link Surface}, or
+   * null.
    */
   public static final int MSG_SET_SURFACE = 1;
 
   /**
-   * A type of a message that can be passed to an audio {@link Renderer} via
-   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-   * should be a {@link Float} with 0 being silence and 1 being unity gain.
+   * A type of a message that can be passed to an audio {@link Renderer} via {@link
+   * ExoPlayer#createMessage(Target)}. The message payload should be a {@link Float} with 0 being
+   * silence and 1 being unity gain.
    */
   public static final int MSG_SET_VOLUME = 2;
 
   /**
-   * A type of a message that can be passed to an audio {@link Renderer} via
-   * {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message object
-   * should be an {@link com.google.android.exoplayer2.audio.AudioAttributes} instance that will
-   * configure the underlying audio track. If not set, the default audio attributes will be used.
-   * They are suitable for general media playback.
-   * <p>
-   * Setting the audio attributes during playback may introduce a short gap in audio output as the
-   * audio track is recreated. A new audio session id will also be generated.
-   * <p>
-   * If tunneling is enabled by the track selector, the specified audio attributes will be ignored,
-   * but they will take effect if audio is later played without tunneling.
-   * <p>
-   * If the device is running a build before platform API version 21, audio attributes cannot be set
-   * directly on the underlying audio track. In this case, the usage will be mapped onto an
+   * A type of a message that can be passed to an audio {@link Renderer} via {@link
+   * ExoPlayer#createMessage(Target)}. The message payload should be an {@link
+   * com.google.android.exoplayer2.audio.AudioAttributes} instance that will configure the
+   * underlying audio track. If not set, the default audio attributes will be used. They are
+   * suitable for general media playback.
+   *
+   * <p>Setting the audio attributes during playback may introduce a short gap in audio output as
+   * the audio track is recreated. A new audio session id will also be generated.
+   *
+   * <p>If tunneling is enabled by the track selector, the specified audio attributes will be
+   * ignored, but they will take effect if audio is later played without tunneling.
+   *
+   * <p>If the device is running a build before platform API version 21, audio attributes cannot be
+   * set directly on the underlying audio track. In this case, the usage will be mapped onto an
    * equivalent stream type using {@link Util#getStreamTypeForAudioUsage(int)}.
-   * <p>
-   * To get audio attributes that are equivalent to a legacy stream type, pass the stream type to
+   *
+   * <p>To get audio attributes that are equivalent to a legacy stream type, pass the stream type to
    * {@link Util#getAudioUsageForStreamType(int)} and use the returned {@link C.AudioUsage} to build
    * an audio attributes instance.
    */
@@ -680,17 +681,17 @@ private C() {}
 
   /**
    * The type of a message that can be passed to a {@link MediaCodec}-based video {@link Renderer}
-   * via {@link ExoPlayer#sendMessages} or {@link ExoPlayer#blockingSendMessages}. The message
-   * object should be one of the integer scaling modes in {@link C.VideoScalingMode}.
-   * <p>
-   * Note that the scaling mode only applies if the {@link Surface} targeted by the renderer is
+   * via {@link ExoPlayer#createMessage(Target)}. The message payload should be one of the integer
+   * scaling modes in {@link C.VideoScalingMode}.
+   *
+   * <p>Note that the scaling mode only applies if the {@link Surface} targeted by the renderer is
    * owned by a {@link android.view.SurfaceView}.
    */
   public static final int MSG_SET_SCALING_MODE = 4;
 
   /**
-   * Applications or extensions may define custom {@code MSG_*} constants greater than or equal to
-   * this value.
+   * Applications or extensions may define custom {@code MSG_*} constants that can be passed to
+   * {@link Renderer}s. These custom constants must be greater than or equal to this value.
    */
   public static final int MSG_CUSTOM_BASE = 10000;
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
index d8bc042ad7..e8ea2f1621 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultLoadControl.java
@@ -25,7 +25,7 @@
 /**
  * The default {@link LoadControl} implementation.
  */
-public final class DefaultLoadControl implements LoadControl {
+public class DefaultLoadControl implements LoadControl {
 
   /**
    * The default minimum duration of media that the player will attempt to ensure is buffered at all
@@ -51,9 +51,14 @@
    */
   public static final int DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS  = 5000;
 
-  private static final int ABOVE_HIGH_WATERMARK = 0;
-  private static final int BETWEEN_WATERMARKS = 1;
-  private static final int BELOW_LOW_WATERMARK = 2;
+  /**
+   * The default target buffer size in bytes. When set to {@link C#LENGTH_UNSET}, the load control
+   * automatically determines its target buffer size.
+   */
+  public static final int DEFAULT_TARGET_BUFFER_BYTES = C.LENGTH_UNSET;
+
+  /** The default prioritization of buffer time constraints over size constraints. */
+  public static final boolean DEFAULT_PRIORITIZE_TIME_OVER_SIZE_THRESHOLDS = true;
 
   private final DefaultAllocator allocator;
 
@@ -61,6 +66,8 @@
   private final long maxBufferUs;
   private final long bufferForPlaybackUs;
   private final long bufferForPlaybackAfterRebufferUs;
+  private final int targetBufferBytesOverwrite;
+  private final boolean prioritizeTimeOverSizeThresholds;
   private final PriorityTaskManager priorityTaskManager;
 
   private int targetBufferSize;
@@ -79,8 +86,14 @@ public DefaultLoadControl() {
    * @param allocator The {@link DefaultAllocator} used by the loader.
    */
   public DefaultLoadControl(DefaultAllocator allocator) {
-    this(allocator, DEFAULT_MIN_BUFFER_MS, DEFAULT_MAX_BUFFER_MS, DEFAULT_BUFFER_FOR_PLAYBACK_MS,
-        DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS);
+    this(
+        allocator,
+        DEFAULT_MIN_BUFFER_MS,
+        DEFAULT_MAX_BUFFER_MS,
+        DEFAULT_BUFFER_FOR_PLAYBACK_MS,
+        DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS,
+        DEFAULT_TARGET_BUFFER_BYTES,
+        DEFAULT_PRIORITIZE_TIME_OVER_SIZE_THRESHOLDS);
   }
 
   /**
@@ -96,10 +109,27 @@ public DefaultLoadControl(DefaultAllocator allocator) {
    * @param bufferForPlaybackAfterRebufferMs The default duration of media that must be buffered for
    *     playback to resume after a rebuffer, in milliseconds. A rebuffer is defined to be caused by
    *     buffer depletion rather than a user action.
+   * @param targetBufferBytes The target buffer size in bytes. If set to {@link C#LENGTH_UNSET}, the
+   *     target buffer size will be calculated using {@link #calculateTargetBufferSize(Renderer[],
+   *     TrackSelectionArray)}.
+   * @param prioritizeTimeOverSizeThresholds Whether the load control prioritizes buffer time
    */
-  public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs,
-      long bufferForPlaybackMs, long bufferForPlaybackAfterRebufferMs) {
-    this(allocator, minBufferMs, maxBufferMs, bufferForPlaybackMs, bufferForPlaybackAfterRebufferMs,
+  public DefaultLoadControl(
+      DefaultAllocator allocator,
+      int minBufferMs,
+      int maxBufferMs,
+      int bufferForPlaybackMs,
+      int bufferForPlaybackAfterRebufferMs,
+      int targetBufferBytes,
+      boolean prioritizeTimeOverSizeThresholds) {
+    this(
+        allocator,
+        minBufferMs,
+        maxBufferMs,
+        bufferForPlaybackMs,
+        bufferForPlaybackAfterRebufferMs,
+        targetBufferBytes,
+        prioritizeTimeOverSizeThresholds,
         null);
   }
 
@@ -116,18 +146,30 @@ public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBu
    * @param bufferForPlaybackAfterRebufferMs The default duration of media that must be buffered for
    *     playback to resume after a rebuffer, in milliseconds. A rebuffer is defined to be caused by
    *     buffer depletion rather than a user action.
-   * @param priorityTaskManager If not null, registers itself as a task with priority
-   *     {@link C#PRIORITY_PLAYBACK} during loading periods, and unregisters itself during draining
-   *     periods.
+   * @param targetBufferBytes The target buffer size in bytes. If set to {@link C#LENGTH_UNSET}, the
+   *     target buffer size will be calculated using {@link #calculateTargetBufferSize(Renderer[],
+   *     TrackSelectionArray)}.
+   * @param prioritizeTimeOverSizeThresholds Whether the load control prioritizes buffer time
+   *     constraints over buffer size constraints.
+   * @param priorityTaskManager If not null, registers itself as a task with priority {@link
+   *     C#PRIORITY_PLAYBACK} during loading periods, and unregisters itself during draining
    */
-  public DefaultLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs,
-      long bufferForPlaybackMs, long bufferForPlaybackAfterRebufferMs,
+  public DefaultLoadControl(
+      DefaultAllocator allocator,
+      int minBufferMs,
+      int maxBufferMs,
+      int bufferForPlaybackMs,
+      int bufferForPlaybackAfterRebufferMs,
+      int targetBufferBytes,
+      boolean prioritizeTimeOverSizeThresholds,
       PriorityTaskManager priorityTaskManager) {
     this.allocator = allocator;
     minBufferUs = minBufferMs * 1000L;
     maxBufferUs = maxBufferMs * 1000L;
     bufferForPlaybackUs = bufferForPlaybackMs * 1000L;
     bufferForPlaybackAfterRebufferUs = bufferForPlaybackAfterRebufferMs * 1000L;
+    targetBufferBytesOverwrite = targetBufferBytes;
+    this.prioritizeTimeOverSizeThresholds = prioritizeTimeOverSizeThresholds;
     this.priorityTaskManager = priorityTaskManager;
   }
 
@@ -139,12 +181,10 @@ public void onPrepared() {
   @Override
   public void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
       TrackSelectionArray trackSelections) {
-    targetBufferSize = 0;
-    for (int i = 0; i < renderers.length; i++) {
-      if (trackSelections.get(i) != null) {
-        targetBufferSize += Util.getDefaultBufferSize(renderers[i].getTrackType());
-      }
-    }
+    targetBufferSize =
+        targetBufferBytesOverwrite == C.LENGTH_UNSET
+            ? calculateTargetBufferSize(renderers, trackSelections)
+            : targetBufferBytesOverwrite;
     allocator.setTargetBufferSize(targetBufferSize);
   }
 
@@ -164,18 +204,31 @@ public Allocator getAllocator() {
   }
 
   @Override
-  public boolean shouldStartPlayback(long bufferedDurationUs, boolean rebuffering) {
-    long minBufferDurationUs = rebuffering ? bufferForPlaybackAfterRebufferUs : bufferForPlaybackUs;
-    return minBufferDurationUs <= 0 || bufferedDurationUs >= minBufferDurationUs;
+  public long getBackBufferDurationUs() {
+    return 0;
+  }
+
+  @Override
+  public boolean retainBackBufferFromKeyframe() {
+    return false;
   }
 
   @Override
-  public boolean shouldContinueLoading(long bufferedDurationUs) {
-    int bufferTimeState = getBufferTimeState(bufferedDurationUs);
+  public boolean shouldContinueLoading(long bufferedDurationUs, float playbackSpeed) {
     boolean targetBufferSizeReached = allocator.getTotalBytesAllocated() >= targetBufferSize;
     boolean wasBuffering = isBuffering;
-    isBuffering = bufferTimeState == BELOW_LOW_WATERMARK
-        || (bufferTimeState == BETWEEN_WATERMARKS && isBuffering && !targetBufferSizeReached);
+    if (prioritizeTimeOverSizeThresholds) {
+      isBuffering =
+          bufferedDurationUs < minBufferUs // below low watermark
+              || (bufferedDurationUs <= maxBufferUs // between watermarks
+                  && isBuffering
+                  && !targetBufferSizeReached);
+    } else {
+      isBuffering =
+          !targetBufferSizeReached
+              && (bufferedDurationUs < minBufferUs // below low watermark
+                  || (bufferedDurationUs <= maxBufferUs && isBuffering)); // between watermarks
+    }
     if (priorityTaskManager != null && isBuffering != wasBuffering) {
       if (isBuffering) {
         priorityTaskManager.add(C.PRIORITY_PLAYBACK);
@@ -186,9 +239,34 @@ public boolean shouldContinueLoading(long bufferedDurationUs) {
     return isBuffering;
   }
 
-  private int getBufferTimeState(long bufferedDurationUs) {
-    return bufferedDurationUs > maxBufferUs ? ABOVE_HIGH_WATERMARK
-        : (bufferedDurationUs < minBufferUs ? BELOW_LOW_WATERMARK : BETWEEN_WATERMARKS);
+  @Override
+  public boolean shouldStartPlayback(
+      long bufferedDurationUs, float playbackSpeed, boolean rebuffering) {
+    bufferedDurationUs = Util.getPlayoutDurationForMediaDuration(bufferedDurationUs, playbackSpeed);
+    long minBufferDurationUs = rebuffering ? bufferForPlaybackAfterRebufferUs : bufferForPlaybackUs;
+    return minBufferDurationUs <= 0
+        || bufferedDurationUs >= minBufferDurationUs
+        || (!prioritizeTimeOverSizeThresholds
+            && allocator.getTotalBytesAllocated() >= targetBufferSize);
+  }
+
+  /**
+   * Calculate target buffer size in bytes based on the selected tracks. The player will try not to
+   * exceed this target buffer. Only used when {@code targetBufferBytes} is {@link C#LENGTH_UNSET}.
+   *
+   * @param renderers The renderers for which the track were selected.
+   * @param trackSelectionArray The selected tracks.
+   * @return The target buffer size in bytes.
+   */
+  protected int calculateTargetBufferSize(
+      Renderer[] renderers, TrackSelectionArray trackSelectionArray) {
+    int targetBufferSize = 0;
+    for (int i = 0; i < renderers.length; i++) {
+      if (trackSelectionArray.get(i) != null) {
+        targetBufferSize += Util.getDefaultBufferSize(renderers[i].getTrackType());
+      }
+    }
+    return targetBufferSize;
   }
 
   private void reset(boolean resetAllocator) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
new file mode 100644
index 0000000000..ed57cec70c
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultMediaClock.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.MediaClock;
+import com.google.android.exoplayer2.util.StandaloneMediaClock;
+
+/**
+ * Default {@link MediaClock} which uses a renderer media clock and falls back to a
+ * {@link StandaloneMediaClock} if necessary.
+ */
+/* package */ final class DefaultMediaClock implements MediaClock {
+
+  /**
+   * Listener interface to be notified of changes to the active playback parameters.
+   */
+  public interface PlaybackParameterListener {
+
+    /**
+     * Called when the active playback parameters changed.
+     *
+     * @param newPlaybackParameters The newly active {@link PlaybackParameters}.
+     */
+    void onPlaybackParametersChanged(PlaybackParameters newPlaybackParameters);
+
+  }
+
+  private final StandaloneMediaClock standaloneMediaClock;
+  private final PlaybackParameterListener listener;
+
+  private @Nullable Renderer rendererClockSource;
+  private @Nullable MediaClock rendererClock;
+
+  /**
+   * Creates a new instance with listener for playback parameter changes and a {@link Clock} to use
+   * for the standalone clock implementation.
+   *
+   * @param listener A {@link PlaybackParameterListener} to listen for playback parameter
+   *     changes.
+   * @param clock A {@link Clock}.
+   */
+  public DefaultMediaClock(PlaybackParameterListener listener, Clock clock) {
+    this.listener = listener;
+    this.standaloneMediaClock = new StandaloneMediaClock(clock);
+  }
+
+  /**
+   * Starts the standalone fallback clock.
+   */
+  public void start() {
+    standaloneMediaClock.start();
+  }
+
+  /**
+   * Stops the standalone fallback clock.
+   */
+  public void stop() {
+    standaloneMediaClock.stop();
+  }
+
+  /**
+   * Resets the position of the standalone fallback clock.
+   *
+   * @param positionUs The position to set in microseconds.
+   */
+  public void resetPosition(long positionUs) {
+    standaloneMediaClock.resetPosition(positionUs);
+  }
+
+  /**
+   * Notifies the media clock that a renderer has been enabled. Starts using the media clock of the
+   * provided renderer if available.
+   *
+   * @param renderer The renderer which has been enabled.
+   * @throws ExoPlaybackException If the renderer provides a media clock and another renderer media
+   *     clock is already provided.
+   */
+  public void onRendererEnabled(Renderer renderer) throws ExoPlaybackException {
+    MediaClock rendererMediaClock = renderer.getMediaClock();
+    if (rendererMediaClock != null && rendererMediaClock != rendererClock) {
+      if (rendererClock != null) {
+        throw ExoPlaybackException.createForUnexpected(
+            new IllegalStateException("Multiple renderer media clocks enabled."));
+      }
+      this.rendererClock = rendererMediaClock;
+      this.rendererClockSource = renderer;
+      rendererClock.setPlaybackParameters(standaloneMediaClock.getPlaybackParameters());
+      ensureSynced();
+    }
+  }
+
+  /**
+   * Notifies the media clock that a renderer has been disabled. Stops using the media clock of this
+   * renderer if used.
+   *
+   * @param renderer The renderer which has been disabled.
+   */
+  public void onRendererDisabled(Renderer renderer) {
+    if (renderer == rendererClockSource) {
+      this.rendererClock = null;
+      this.rendererClockSource = null;
+    }
+  }
+
+  /**
+   * Syncs internal clock if needed and returns current clock position in microseconds.
+   */
+  public long syncAndGetPositionUs() {
+    if (isUsingRendererClock()) {
+      ensureSynced();
+      return rendererClock.getPositionUs();
+    } else {
+      return standaloneMediaClock.getPositionUs();
+    }
+  }
+
+  // MediaClock implementation.
+
+  @Override
+  public long getPositionUs() {
+    if (isUsingRendererClock()) {
+      return rendererClock.getPositionUs();
+    } else {
+      return standaloneMediaClock.getPositionUs();
+    }
+  }
+
+  @Override
+  public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
+    if (rendererClock != null) {
+      playbackParameters = rendererClock.setPlaybackParameters(playbackParameters);
+    }
+    standaloneMediaClock.setPlaybackParameters(playbackParameters);
+    listener.onPlaybackParametersChanged(playbackParameters);
+    return playbackParameters;
+  }
+
+  @Override
+  public PlaybackParameters getPlaybackParameters() {
+    return rendererClock != null ? rendererClock.getPlaybackParameters()
+        : standaloneMediaClock.getPlaybackParameters();
+  }
+
+  private void ensureSynced() {
+    long rendererClockPositionUs = rendererClock.getPositionUs();
+    standaloneMediaClock.resetPosition(rendererClockPositionUs);
+    PlaybackParameters playbackParameters = rendererClock.getPlaybackParameters();
+    if (!playbackParameters.equals(standaloneMediaClock.getPlaybackParameters())) {
+      standaloneMediaClock.setPlaybackParameters(playbackParameters);
+      listener.onPlaybackParametersChanged(playbackParameters);
+    }
+  }
+
+  private boolean isUsingRendererClock() {
+    // Use the renderer clock if the providing renderer has not ended or needs the next sample
+    // stream to reenter the ready state. The latter case uses the standalone clock to avoid getting
+    // stuck if tracks in the current period have uneven durations.
+    // See: https://github.com/google/ExoPlayer/issues/1874.
+    return rendererClockSource != null && !rendererClockSource.isEnded()
+        && (rendererClockSource.isReady() || !rendererClockSource.hasReadStreamToEnd());
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
index 2272306117..16074108b1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/DefaultRenderersFactory.java
@@ -185,18 +185,32 @@ protected void buildVideoRenderers(Context context,
     }
 
     try {
-      Class<?> clazz =
-          Class.forName("com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer");
-      Constructor<?> constructor = clazz.getConstructor(boolean.class, long.class, Handler.class,
-          VideoRendererEventListener.class, int.class);
-      Renderer renderer = (Renderer) constructor.newInstance(true, allowedVideoJoiningTimeMs,
-          eventHandler, eventListener, MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
+      // Full class names used for constructor args so the LINT rule triggers if any of them move.
+      // LINT.IfChange
+      Class<?> clazz = Class.forName("com.google.android.exoplayer2.ext.vp9.LibvpxVideoRenderer");
+      Constructor<?> constructor =
+          clazz.getConstructor(
+              boolean.class,
+              long.class,
+              android.os.Handler.class,
+              com.google.android.exoplayer2.video.VideoRendererEventListener.class,
+              int.class);
+      // LINT.ThenChange(../../../../../../../proguard-rules.txt)
+      Renderer renderer =
+          (Renderer)
+              constructor.newInstance(
+                  true,
+                  allowedVideoJoiningTimeMs,
+                  eventHandler,
+                  eventListener,
+                  MAX_DROPPED_VIDEO_FRAME_COUNT_TO_NOTIFY);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibvpxVideoRenderer.");
     } catch (ClassNotFoundException e) {
       // Expected if the app was built without the extension.
     } catch (Exception e) {
-      throw new RuntimeException(e);
+      // The extension is present, but instantiation failed.
+      throw new RuntimeException("Error instantiating VP9 extension", e);
     }
   }
 
@@ -230,48 +244,67 @@ protected void buildAudioRenderers(Context context,
     }
 
     try {
-      Class<?> clazz =
-          Class.forName("com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer");
-      Constructor<?> constructor = clazz.getConstructor(Handler.class,
-          AudioRendererEventListener.class, AudioProcessor[].class);
-      Renderer renderer = (Renderer) constructor.newInstance(eventHandler, eventListener,
-          audioProcessors);
+      // Full class names used for constructor args so the LINT rule triggers if any of them move.
+      // LINT.IfChange
+      Class<?> clazz = Class.forName("com.google.android.exoplayer2.ext.opus.LibopusAudioRenderer");
+      Constructor<?> constructor =
+          clazz.getConstructor(
+              android.os.Handler.class,
+              com.google.android.exoplayer2.audio.AudioRendererEventListener.class,
+              com.google.android.exoplayer2.audio.AudioProcessor[].class);
+      // LINT.ThenChange(../../../../../../../proguard-rules.txt)
+      Renderer renderer =
+          (Renderer) constructor.newInstance(eventHandler, eventListener, audioProcessors);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibopusAudioRenderer.");
     } catch (ClassNotFoundException e) {
       // Expected if the app was built without the extension.
     } catch (Exception e) {
-      throw new RuntimeException(e);
+      // The extension is present, but instantiation failed.
+      throw new RuntimeException("Error instantiating Opus extension", e);
     }
 
     try {
-      Class<?> clazz =
-          Class.forName("com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer");
-      Constructor<?> constructor = clazz.getConstructor(Handler.class,
-          AudioRendererEventListener.class, AudioProcessor[].class);
-      Renderer renderer = (Renderer) constructor.newInstance(eventHandler, eventListener,
-          audioProcessors);
+      // Full class names used for constructor args so the LINT rule triggers if any of them move.
+      // LINT.IfChange
+      Class<?> clazz = Class.forName("com.google.android.exoplayer2.ext.flac.LibflacAudioRenderer");
+      Constructor<?> constructor =
+          clazz.getConstructor(
+              android.os.Handler.class,
+              com.google.android.exoplayer2.audio.AudioRendererEventListener.class,
+              com.google.android.exoplayer2.audio.AudioProcessor[].class);
+      // LINT.ThenChange(../../../../../../../proguard-rules.txt)
+      Renderer renderer =
+          (Renderer) constructor.newInstance(eventHandler, eventListener, audioProcessors);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded LibflacAudioRenderer.");
     } catch (ClassNotFoundException e) {
       // Expected if the app was built without the extension.
     } catch (Exception e) {
-      throw new RuntimeException(e);
+      // The extension is present, but instantiation failed.
+      throw new RuntimeException("Error instantiating FLAC extension", e);
     }
 
     try {
+      // Full class names used for constructor args so the LINT rule triggers if any of them move.
+      // LINT.IfChange
       Class<?> clazz =
           Class.forName("com.google.android.exoplayer2.ext.ffmpeg.FfmpegAudioRenderer");
-      Constructor<?> constructor = clazz.getConstructor(Handler.class,
-          AudioRendererEventListener.class, AudioProcessor[].class);
-      Renderer renderer = (Renderer) constructor.newInstance(eventHandler, eventListener,
-          audioProcessors);
+      Constructor<?> constructor =
+          clazz.getConstructor(
+              android.os.Handler.class,
+              com.google.android.exoplayer2.audio.AudioRendererEventListener.class,
+              com.google.android.exoplayer2.audio.AudioProcessor[].class);
+      // LINT.ThenChange(../../../../../../../proguard-rules.txt)
+      Renderer renderer =
+          (Renderer) constructor.newInstance(eventHandler, eventListener, audioProcessors);
       out.add(extensionRendererIndex++, renderer);
       Log.i(TAG, "Loaded FfmpegAudioRenderer.");
     } catch (ClassNotFoundException e) {
       // Expected if the app was built without the extension.
     } catch (Exception e) {
-      throw new RuntimeException(e);
+      // The extension is present, but instantiation failed.
+      throw new RuntimeException("Error instantiating FFmpeg extension", e);
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
index 915a083657..c13fd6cacd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2;
 
 import android.os.Looper;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.audio.MediaCodecAudioRenderer;
 import com.google.android.exoplayer2.metadata.MetadataRenderer;
 import com.google.android.exoplayer2.source.ClippingMediaSource;
@@ -33,40 +34,43 @@
 import com.google.android.exoplayer2.video.MediaCodecVideoRenderer;
 
 /**
- * An extensible media player that plays {@link MediaSource}s. Instances can be obtained from
- * {@link ExoPlayerFactory}.
+ * An extensible media player that plays {@link MediaSource}s. Instances can be obtained from {@link
+ * ExoPlayerFactory}.
  *
  * <h3>Player components</h3>
+ *
  * <p>ExoPlayer is designed to make few assumptions about (and hence impose few restrictions on) the
  * type of the media being played, how and where it is stored, and how it is rendered. Rather than
  * implementing the loading and rendering of media directly, ExoPlayer implementations delegate this
  * work to components that are injected when a player is created or when it's prepared for playback.
  * Components common to all ExoPlayer implementations are:
+ *
  * <ul>
  *   <li>A <b>{@link MediaSource}</b> that defines the media to be played, loads the media, and from
- *   which the loaded media can be read. A MediaSource is injected via {@link #prepare(MediaSource)}
- *   at the start of playback. The library modules provide default implementations for regular media
- *   files ({@link ExtractorMediaSource}), DASH (DashMediaSource), SmoothStreaming (SsMediaSource)
- *   and HLS (HlsMediaSource), an implementation for loading single media samples
- *   ({@link SingleSampleMediaSource}) that's most often used for side-loaded subtitle files, and
- *   implementations for building more complex MediaSources from simpler ones
- *   ({@link MergingMediaSource}, {@link ConcatenatingMediaSource},
- *   {@link DynamicConcatenatingMediaSource}, {@link LoopingMediaSource} and
- *   {@link ClippingMediaSource}).</li>
+ *       which the loaded media can be read. A MediaSource is injected via {@link
+ *       #prepare(MediaSource)} at the start of playback. The library modules provide default
+ *       implementations for regular media files ({@link ExtractorMediaSource}), DASH
+ *       (DashMediaSource), SmoothStreaming (SsMediaSource) and HLS (HlsMediaSource), an
+ *       implementation for loading single media samples ({@link SingleSampleMediaSource}) that's
+ *       most often used for side-loaded subtitle files, and implementations for building more
+ *       complex MediaSources from simpler ones ({@link MergingMediaSource}, {@link
+ *       ConcatenatingMediaSource}, {@link DynamicConcatenatingMediaSource}, {@link
+ *       LoopingMediaSource} and {@link ClippingMediaSource}).
  *   <li><b>{@link Renderer}</b>s that render individual components of the media. The library
- *   provides default implementations for common media types ({@link MediaCodecVideoRenderer},
- *   {@link MediaCodecAudioRenderer}, {@link TextRenderer} and {@link MetadataRenderer}). A Renderer
- *   consumes media from the MediaSource being played. Renderers are injected when the player is
- *   created.</li>
+ *       provides default implementations for common media types ({@link MediaCodecVideoRenderer},
+ *       {@link MediaCodecAudioRenderer}, {@link TextRenderer} and {@link MetadataRenderer}). A
+ *       Renderer consumes media from the MediaSource being played. Renderers are injected when the
+ *       player is created.
  *   <li>A <b>{@link TrackSelector}</b> that selects tracks provided by the MediaSource to be
- *   consumed by each of the available Renderers. The library provides a default implementation
- *   ({@link DefaultTrackSelector}) suitable for most use cases. A TrackSelector is injected when
- *   the player is created.</li>
+ *       consumed by each of the available Renderers. The library provides a default implementation
+ *       ({@link DefaultTrackSelector}) suitable for most use cases. A TrackSelector is injected
+ *       when the player is created.
  *   <li>A <b>{@link LoadControl}</b> that controls when the MediaSource buffers more media, and how
- *   much media is buffered. The library provides a default implementation
- *   ({@link DefaultLoadControl}) suitable for most use cases. A LoadControl is injected when the
- *   player is created.</li>
+ *       much media is buffered. The library provides a default implementation ({@link
+ *       DefaultLoadControl}) suitable for most use cases. A LoadControl is injected when the player
+ *       is created.
  * </ul>
+ *
  * <p>An ExoPlayer can be built using the default components provided by the library, but may also
  * be built using custom implementations if non-standard behaviors are required. For example a
  * custom LoadControl could be injected to change the player's buffering strategy, or a custom
@@ -80,30 +84,31 @@
  * it's possible to load data from a non-standard source, or through a different network stack.
  *
  * <h3>Threading model</h3>
- * <p>The figure below shows ExoPlayer's threading model.</p>
- * <p align="center">
- *   <img src="doc-files/exoplayer-threading-model.svg" alt="ExoPlayer's threading model">
- * </p>
+ *
+ * <p>The figure below shows ExoPlayer's threading model.
+ *
+ * <p align="center"><img src="doc-files/exoplayer-threading-model.svg" alt="ExoPlayer's threading
+ * model">
  *
  * <ul>
- * <li>It is recommended that ExoPlayer instances are created and accessed from a single application
- * thread. The application's main thread is ideal. Accessing an instance from multiple threads is
- * discouraged, however if an application does wish to do this then it may do so provided that it
- * ensures accesses are synchronized.</li>
- * <li>Registered listeners are called on the thread that created the ExoPlayer instance, unless
- * the thread that created the ExoPlayer instance does not have a {@link Looper}. In that case,
- * registered listeners will be called on the application's main thread.</li>
- * <li>An internal playback thread is responsible for playback. Injected player components such as
- * Renderers, MediaSources, TrackSelectors and LoadControls are called by the player on this
- * thread.</li>
- * <li>When the application performs an operation on the player, for example a seek, a message is
- * delivered to the internal playback thread via a message queue. The internal playback thread
- * consumes messages from the queue and performs the corresponding operations. Similarly, when a
- * playback event occurs on the internal playback thread, a message is delivered to the application
- * thread via a second message queue. The application thread consumes messages from the queue,
- * updating the application visible state and calling corresponding listener methods.</li>
- * <li>Injected player components may use additional background threads. For example a MediaSource
- * may use background threads to load data. These are implementation specific.</li>
+ *   <li>It is strongly recommended that ExoPlayer instances are created and accessed from a single
+ *       application thread. The application's main thread is ideal. Accessing an instance from
+ *       multiple threads is discouraged as it may cause synchronization problems.
+ *   <li>Registered listeners are called on the thread that created the ExoPlayer instance, unless
+ *       the thread that created the ExoPlayer instance does not have a {@link Looper}. In that
+ *       case, registered listeners will be called on the application's main thread.
+ *   <li>An internal playback thread is responsible for playback. Injected player components such as
+ *       Renderers, MediaSources, TrackSelectors and LoadControls are called by the player on this
+ *       thread.
+ *   <li>When the application performs an operation on the player, for example a seek, a message is
+ *       delivered to the internal playback thread via a message queue. The internal playback thread
+ *       consumes messages from the queue and performs the corresponding operations. Similarly, when
+ *       a playback event occurs on the internal playback thread, a message is delivered to the
+ *       application thread via a second message queue. The application thread consumes messages
+ *       from the queue, updating the application visible state and calling corresponding listener
+ *       methods.
+ *   <li>Injected player components may use additional background threads. For example a MediaSource
+ *       may use background threads to load data. These are implementation specific.
  * </ul>
  */
 public interface ExoPlayer extends Player {
@@ -114,54 +119,28 @@
   @Deprecated
   interface EventListener extends Player.EventListener {}
 
-  /**
-   * A component of an {@link ExoPlayer} that can receive messages on the playback thread.
-   * <p>
-   * Messages can be delivered to a component via {@link #sendMessages} and
-   * {@link #blockingSendMessages}.
-   */
-  interface ExoPlayerComponent {
-
-    /**
-     * Handles a message delivered to the component. Called on the playback thread.
-     *
-     * @param messageType The message type.
-     * @param message The message.
-     * @throws ExoPlaybackException If an error occurred whilst handling the message.
-     */
-    void handleMessage(int messageType, Object message) throws ExoPlaybackException;
-
-  }
+  /** @deprecated Use {@link PlayerMessage.Target} instead. */
+  @Deprecated
+  interface ExoPlayerComponent extends PlayerMessage.Target {}
 
-  /**
-   * Defines a message and a target {@link ExoPlayerComponent} to receive it.
-   */
+  /** @deprecated Use {@link PlayerMessage} instead. */
+  @Deprecated
   final class ExoPlayerMessage {
 
-    /**
-     * The target to receive the message.
-     */
-    public final ExoPlayerComponent target;
-    /**
-     * The type of the message.
-     */
+    /** The target to receive the message. */
+    public final PlayerMessage.Target target;
+    /** The type of the message. */
     public final int messageType;
-    /**
-     * The message.
-     */
+    /** The message. */
     public final Object message;
 
-    /**
-     * @param target The target of the message.
-     * @param messageType The message type.
-     * @param message The message.
-     */
-    public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object message) {
+    /** @deprecated Use {@link ExoPlayer#createMessage(PlayerMessage.Target)} instead. */
+    @Deprecated
+    public ExoPlayerMessage(PlayerMessage.Target target, int messageType, Object message) {
       this.target = target;
       this.messageType = messageType;
       this.message = message;
     }
-
   }
 
   /**
@@ -235,20 +214,31 @@ public ExoPlayerMessage(ExoPlayerComponent target, int messageType, Object messa
   void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState);
 
   /**
-   * Sends messages to their target components. The messages are delivered on the playback thread.
-   * If a component throws an {@link ExoPlaybackException} then it is propagated out of the player
-   * as an error.
-   *
-   * @param messages The messages to be sent.
+   * Creates a message that can be sent to a {@link PlayerMessage.Target}. By default, the message
+   * will be delivered immediately without blocking on the playback thread. The default {@link
+   * PlayerMessage#getType()} is 0 and the default {@link PlayerMessage#getPayload()} is null. If a
+   * position is specified with {@link PlayerMessage#setPosition(long)}, the message will be
+   * delivered at this position in the current window defined by {@link #getCurrentWindowIndex()}.
+   * Alternatively, the message can be sent at a specific window using {@link
+   * PlayerMessage#setPosition(int, long)}.
    */
+  PlayerMessage createMessage(PlayerMessage.Target target);
+
+  /** @deprecated Use {@link #createMessage(PlayerMessage.Target)} instead. */
+  @Deprecated
   void sendMessages(ExoPlayerMessage... messages);
 
   /**
-   * Variant of {@link #sendMessages(ExoPlayerMessage...)} that blocks until after the messages have
-   * been delivered.
-   *
-   * @param messages The messages to be sent.
+   * @deprecated Use {@link #createMessage(PlayerMessage.Target)} with {@link
+   *     PlayerMessage#blockUntilDelivered()}.
    */
+  @Deprecated
   void blockingSendMessages(ExoPlayerMessage... messages);
 
+  /**
+   * Sets the parameters that control how seek operations are performed.
+   *
+   * @param seekParameters The seek parameters, or {@code null} to use the defaults.
+   */
+  void setSeekParameters(@Nullable SeekParameters seekParameters);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
index b647e541bc..821671e34e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java
@@ -20,6 +20,7 @@
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.util.Clock;
 
 /**
  * A factory for {@link ExoPlayer} instances.
@@ -160,7 +161,7 @@ public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSel
    */
   public static ExoPlayer newInstance(Renderer[] renderers, TrackSelector trackSelector,
       LoadControl loadControl) {
-    return new ExoPlayerImpl(renderers, trackSelector, loadControl);
+    return new ExoPlayerImpl(renderers, trackSelector, loadControl, Clock.DEFAULT);
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
index 349751eb59..0e0a6e3c26 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImpl.java
@@ -21,6 +21,8 @@
 import android.os.Message;
 import android.support.annotation.Nullable;
 import android.util.Log;
+import android.util.Pair;
+import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -29,7 +31,10 @@
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.CopyOnWriteArraySet;
 
 /**
@@ -41,23 +46,20 @@
 
   private final Renderer[] renderers;
   private final TrackSelector trackSelector;
-  private final TrackSelectionArray emptyTrackSelections;
+  private final TrackSelectorResult emptyTrackSelectorResult;
   private final Handler eventHandler;
   private final ExoPlayerImplInternal internalPlayer;
+  private final Handler internalPlayerHandler;
   private final CopyOnWriteArraySet<Player.EventListener> listeners;
   private final Timeline.Window window;
   private final Timeline.Period period;
 
-  private boolean tracksSelected;
   private boolean playWhenReady;
   private @RepeatMode int repeatMode;
   private boolean shuffleModeEnabled;
-  private int playbackState;
-  private int pendingSeekAcks;
-  private int pendingPrepareAcks;
-  private boolean isLoading;
-  private TrackGroupArray trackGroups;
-  private TrackSelectionArray trackSelections;
+  private int pendingOperationAcks;
+  private boolean hasPendingPrepare;
+  private boolean hasPendingSeek;
   private PlaybackParameters playbackParameters;
 
   // Playback information when there is no pending seek/set source operation.
@@ -74,9 +76,11 @@
    * @param renderers The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param clock The {@link Clock} that will be used by the instance.
    */
   @SuppressLint("HandlerLeak")
-  public ExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl) {
+  public ExoPlayerImpl(
+      Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl, Clock clock) {
     Log.i(TAG, "Init " + Integer.toHexString(System.identityHashCode(this)) + " ["
         + ExoPlayerLibraryInfo.VERSION_SLASHY + "] [" + Util.DEVICE_DEBUG_INFO + "]");
     Assertions.checkState(renderers.length > 0);
@@ -85,13 +89,16 @@ public ExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector, LoadCont
     this.playWhenReady = false;
     this.repeatMode = Player.REPEAT_MODE_OFF;
     this.shuffleModeEnabled = false;
-    this.playbackState = Player.STATE_IDLE;
     this.listeners = new CopyOnWriteArraySet<>();
-    emptyTrackSelections = new TrackSelectionArray(new TrackSelection[renderers.length]);
+    emptyTrackSelectorResult =
+        new TrackSelectorResult(
+            TrackGroupArray.EMPTY,
+            new boolean[renderers.length],
+            new TrackSelectionArray(new TrackSelection[renderers.length]),
+            null,
+            new RendererConfiguration[renderers.length]);
     window = new Timeline.Window();
     period = new Timeline.Period();
-    trackGroups = TrackGroupArray.EMPTY;
-    trackSelections = emptyTrackSelections;
     playbackParameters = PlaybackParameters.DEFAULT;
     Looper eventLooper = Looper.myLooper() != null ? Looper.myLooper() : Looper.getMainLooper();
     eventHandler = new Handler(eventLooper) {
@@ -100,9 +107,31 @@ public void handleMessage(Message msg) {
         ExoPlayerImpl.this.handleEvent(msg);
       }
     };
-    playbackInfo = new PlaybackInfo(Timeline.EMPTY, null, 0, 0);
-    internalPlayer = new ExoPlayerImplInternal(renderers, trackSelector, loadControl, playWhenReady,
-        repeatMode, shuffleModeEnabled, eventHandler, this);
+    playbackInfo =
+        new PlaybackInfo(Timeline.EMPTY, /* startPositionUs= */ 0, emptyTrackSelectorResult);
+    internalPlayer =
+        new ExoPlayerImplInternal(
+            renderers,
+            trackSelector,
+            emptyTrackSelectorResult,
+            loadControl,
+            playWhenReady,
+            repeatMode,
+            shuffleModeEnabled,
+            eventHandler,
+            this,
+            clock);
+    internalPlayerHandler = new Handler(internalPlayer.getPlaybackLooper());
+  }
+
+  @Override
+  public VideoComponent getVideoComponent() {
+    return null;
+  }
+
+  @Override
+  public TextComponent getTextComponent() {
+    return null;
   }
 
   @Override
@@ -122,7 +151,7 @@ public void removeListener(Player.EventListener listener) {
 
   @Override
   public int getPlaybackState() {
-    return playbackState;
+    return playbackInfo.playbackState;
   }
 
   @Override
@@ -132,34 +161,22 @@ public void prepare(MediaSource mediaSource) {
 
   @Override
   public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
-    if (!resetPosition) {
-      maskingWindowIndex = getCurrentWindowIndex();
-      maskingPeriodIndex = getCurrentPeriodIndex();
-      maskingWindowPositionMs = getCurrentPosition();
-    } else {
-      maskingWindowIndex = 0;
-      maskingPeriodIndex = 0;
-      maskingWindowPositionMs = 0;
-    }
-    if (resetState) {
-      if (!playbackInfo.timeline.isEmpty() || playbackInfo.manifest != null) {
-        playbackInfo = playbackInfo.copyWithTimeline(Timeline.EMPTY, null);
-        for (Player.EventListener listener : listeners) {
-          listener.onTimelineChanged(playbackInfo.timeline, playbackInfo.manifest);
-        }
-      }
-      if (tracksSelected) {
-        tracksSelected = false;
-        trackGroups = TrackGroupArray.EMPTY;
-        trackSelections = emptyTrackSelections;
-        trackSelector.onSelectionActivated(null);
-        for (Player.EventListener listener : listeners) {
-          listener.onTracksChanged(trackGroups, trackSelections);
-        }
-      }
-    }
-    pendingPrepareAcks++;
-    internalPlayer.prepare(mediaSource, resetPosition);
+    PlaybackInfo playbackInfo =
+        getResetPlaybackInfo(
+            resetPosition, resetState, /* playbackState= */ Player.STATE_BUFFERING);
+    // Trigger internal prepare first before updating the playback info and notifying external
+    // listeners to ensure that new operations issued in the listener notifications reach the
+    // player after this prepare. The internal player can't change the playback info immediately
+    // because it uses a callback.
+    hasPendingPrepare = true;
+    pendingOperationAcks++;
+    internalPlayer.prepare(mediaSource, resetPosition, resetState);
+    updatePlaybackInfo(
+        playbackInfo,
+        /* positionDiscontinuity= */ false,
+        /* ignored */ DISCONTINUITY_REASON_INTERNAL,
+        TIMELINE_CHANGE_REASON_RESET,
+        /* seekProcessed= */ false);
   }
 
   @Override
@@ -168,7 +185,7 @@ public void setPlayWhenReady(boolean playWhenReady) {
       this.playWhenReady = playWhenReady;
       internalPlayer.setPlayWhenReady(playWhenReady);
       for (Player.EventListener listener : listeners) {
-        listener.onPlayerStateChanged(playWhenReady, playbackState);
+        listener.onPlayerStateChanged(playWhenReady, playbackInfo.playbackState);
       }
     }
   }
@@ -212,7 +229,7 @@ public boolean getShuffleModeEnabled() {
 
   @Override
   public boolean isLoading() {
-    return isLoading;
+    return playbackInfo.isLoading;
   }
 
   @Override
@@ -236,37 +253,33 @@ public void seekTo(int windowIndex, long positionMs) {
     if (windowIndex < 0 || (!timeline.isEmpty() && windowIndex >= timeline.getWindowCount())) {
       throw new IllegalSeekPositionException(timeline, windowIndex, positionMs);
     }
+    hasPendingSeek = true;
+    pendingOperationAcks++;
     if (isPlayingAd()) {
       // TODO: Investigate adding support for seeking during ads. This is complicated to do in
       // general because the midroll ad preceding the seek destination must be played before the
       // content position can be played, if a different ad is playing at the moment.
       Log.w(TAG, "seekTo ignored because an ad is playing");
-      if (pendingSeekAcks == 0) {
-        for (Player.EventListener listener : listeners) {
-          listener.onSeekProcessed();
-        }
-      }
+      eventHandler
+          .obtainMessage(
+              ExoPlayerImplInternal.MSG_PLAYBACK_INFO_CHANGED,
+              /* operationAcks */ 1,
+              /* positionDiscontinuityReason */ C.INDEX_UNSET,
+              playbackInfo)
+          .sendToTarget();
       return;
     }
-    pendingSeekAcks++;
     maskingWindowIndex = windowIndex;
     if (timeline.isEmpty()) {
       maskingWindowPositionMs = positionMs == C.TIME_UNSET ? 0 : positionMs;
       maskingPeriodIndex = 0;
     } else {
-      timeline.getWindow(windowIndex, window);
-      long windowPositionUs = positionMs == C.TIME_UNSET ? window.getDefaultPositionUs()
-          : C.msToUs(positionMs);
-      int periodIndex = window.firstPeriodIndex;
-      long periodPositionUs = window.getPositionInFirstPeriodUs() + windowPositionUs;
-      long periodDurationUs = timeline.getPeriod(periodIndex, period).getDurationUs();
-      while (periodDurationUs != C.TIME_UNSET && periodPositionUs >= periodDurationUs
-          && periodIndex < window.lastPeriodIndex) {
-        periodPositionUs -= periodDurationUs;
-        periodDurationUs = timeline.getPeriod(++periodIndex, period).getDurationUs();
-      }
+      long windowPositionUs = positionMs == C.TIME_UNSET
+          ? timeline.getWindow(windowIndex, window).getDefaultPositionUs() : C.msToUs(positionMs);
+      Pair<Integer, Long> periodIndexAndPositon =
+          timeline.getPeriodPosition(window, period, windowIndex, windowPositionUs);
       maskingWindowPositionMs = C.usToMs(windowPositionUs);
-      maskingPeriodIndex = periodIndex;
+      maskingPeriodIndex = periodIndexAndPositon.first;
     }
     internalPlayer.seekTo(timeline, windowIndex, C.msToUs(positionMs));
     for (Player.EventListener listener : listeners) {
@@ -287,9 +300,38 @@ public PlaybackParameters getPlaybackParameters() {
     return playbackParameters;
   }
 
+  @Override
+  public void setSeekParameters(@Nullable SeekParameters seekParameters) {
+    if (seekParameters == null) {
+      seekParameters = SeekParameters.DEFAULT;
+    }
+    internalPlayer.setSeekParameters(seekParameters);
+  }
+
   @Override
   public void stop() {
-    internalPlayer.stop();
+    stop(/* reset= */ false);
+  }
+
+  @Override
+  public void stop(boolean reset) {
+    PlaybackInfo playbackInfo =
+        getResetPlaybackInfo(
+            /* resetPosition= */ reset,
+            /* resetState= */ reset,
+            /* playbackState= */ Player.STATE_IDLE);
+    // Trigger internal stop first before updating the playback info and notifying external
+    // listeners to ensure that new operations issued in the listener notifications reach the
+    // player after this stop. The internal player can't change the playback info immediately
+    // because it uses a callback.
+    pendingOperationAcks++;
+    internalPlayer.stop(reset);
+    updatePlaybackInfo(
+        playbackInfo,
+        /* positionDiscontinuity= */ false,
+        /* ignored */ DISCONTINUITY_REASON_INTERNAL,
+        TIMELINE_CHANGE_REASON_RESET,
+        /* seekProcessed= */ false);
   }
 
   @Override
@@ -303,12 +345,47 @@ public void release() {
 
   @Override
   public void sendMessages(ExoPlayerMessage... messages) {
-    internalPlayer.sendMessages(messages);
+    for (ExoPlayerMessage message : messages) {
+      createMessage(message.target).setType(message.messageType).setPayload(message.message).send();
+    }
+  }
+
+  @Override
+  public PlayerMessage createMessage(Target target) {
+    return new PlayerMessage(
+        internalPlayer,
+        target,
+        playbackInfo.timeline,
+        getCurrentWindowIndex(),
+        internalPlayerHandler);
   }
 
   @Override
   public void blockingSendMessages(ExoPlayerMessage... messages) {
-    internalPlayer.blockingSendMessages(messages);
+    List<PlayerMessage> playerMessages = new ArrayList<>();
+    for (ExoPlayerMessage message : messages) {
+      playerMessages.add(
+          createMessage(message.target)
+              .setType(message.messageType)
+              .setPayload(message.message)
+              .send());
+    }
+    boolean wasInterrupted = false;
+    for (PlayerMessage message : playerMessages) {
+      boolean blockMessage = true;
+      while (blockMessage) {
+        try {
+          message.blockUntilDelivered();
+          blockMessage = false;
+        } catch (InterruptedException e) {
+          wasInterrupted = true;
+        }
+      }
+    }
+    if (wasInterrupted) {
+      // Restore the interrupted status.
+      Thread.currentThread().interrupt();
+    }
   }
 
   @Override
@@ -435,12 +512,12 @@ public int getRendererType(int index) {
 
   @Override
   public TrackGroupArray getCurrentTrackGroups() {
-    return trackGroups;
+    return playbackInfo.trackSelectorResult.groups;
   }
 
   @Override
   public TrackSelectionArray getCurrentTrackSelections() {
-    return trackSelections;
+    return playbackInfo.trackSelectorResult.selections;
   }
 
   @Override
@@ -456,52 +533,14 @@ public Object getCurrentManifest() {
   // Not private so it can be called from an inner class without going through a thunk method.
   /* package */ void handleEvent(Message msg) {
     switch (msg.what) {
-      case ExoPlayerImplInternal.MSG_STATE_CHANGED: {
-        playbackState = msg.arg1;
-        for (Player.EventListener listener : listeners) {
-          listener.onPlayerStateChanged(playWhenReady, playbackState);
-        }
-        break;
-      }
-      case ExoPlayerImplInternal.MSG_LOADING_CHANGED: {
-        isLoading = msg.arg1 != 0;
-        for (Player.EventListener listener : listeners) {
-          listener.onLoadingChanged(isLoading);
-        }
-        break;
-      }
-      case ExoPlayerImplInternal.MSG_SOURCE_INFO_REFRESHED: {
-        int prepareAcks = msg.arg1;
-        int seekAcks = msg.arg2;
-        handlePlaybackInfo((PlaybackInfo) msg.obj, prepareAcks, seekAcks, false,
-            /* ignored */ DISCONTINUITY_REASON_INTERNAL);
-        break;
-      }
-      case ExoPlayerImplInternal.MSG_TRACKS_CHANGED: {
-        if (pendingPrepareAcks == 0) {
-          TrackSelectorResult trackSelectorResult = (TrackSelectorResult) msg.obj;
-          tracksSelected = true;
-          trackGroups = trackSelectorResult.groups;
-          trackSelections = trackSelectorResult.selections;
-          trackSelector.onSelectionActivated(trackSelectorResult.info);
-          for (Player.EventListener listener : listeners) {
-            listener.onTracksChanged(trackGroups, trackSelections);
-          }
-        }
+      case ExoPlayerImplInternal.MSG_PLAYBACK_INFO_CHANGED:
+        handlePlaybackInfo(
+            (PlaybackInfo) msg.obj,
+            /* operationAcks= */ msg.arg1,
+            /* positionDiscontinuity= */ msg.arg2 != C.INDEX_UNSET,
+            /* positionDiscontinuityReason= */ msg.arg2);
         break;
-      }
-      case ExoPlayerImplInternal.MSG_SEEK_ACK: {
-        boolean seekPositionAdjusted = msg.arg1 != 0;
-        handlePlaybackInfo((PlaybackInfo) msg.obj, 0, 1, seekPositionAdjusted,
-            DISCONTINUITY_REASON_SEEK_ADJUSTMENT);
-        break;
-      }
-      case ExoPlayerImplInternal.MSG_POSITION_DISCONTINUITY: {
-        @DiscontinuityReason int discontinuityReason = msg.arg1;
-        handlePlaybackInfo((PlaybackInfo) msg.obj, 0, 0, true, discontinuityReason);
-        break;
-      }
-      case ExoPlayerImplInternal.MSG_PLAYBACK_PARAMETERS_CHANGED: {
+      case ExoPlayerImplInternal.MSG_PLAYBACK_PARAMETERS_CHANGED:
         PlaybackParameters playbackParameters = (PlaybackParameters) msg.obj;
         if (!this.playbackParameters.equals(playbackParameters)) {
           this.playbackParameters = playbackParameters;
@@ -510,46 +549,119 @@ public Object getCurrentManifest() {
           }
         }
         break;
-      }
-      case ExoPlayerImplInternal.MSG_ERROR: {
+      case ExoPlayerImplInternal.MSG_ERROR:
         ExoPlaybackException exception = (ExoPlaybackException) msg.obj;
         for (Player.EventListener listener : listeners) {
           listener.onPlayerError(exception);
         }
         break;
-      }
       default:
         throw new IllegalStateException();
     }
   }
 
-  private void handlePlaybackInfo(PlaybackInfo playbackInfo, int prepareAcks, int seekAcks,
-      boolean positionDiscontinuity, @DiscontinuityReason int positionDiscontinuityReason) {
-    Assertions.checkNotNull(playbackInfo.timeline);
-    pendingPrepareAcks -= prepareAcks;
-    pendingSeekAcks -= seekAcks;
-    if (pendingPrepareAcks == 0 && pendingSeekAcks == 0) {
-      boolean timelineOrManifestChanged = this.playbackInfo.timeline != playbackInfo.timeline
-          || this.playbackInfo.manifest != playbackInfo.manifest;
-      this.playbackInfo = playbackInfo;
-      if (playbackInfo.timeline.isEmpty()) {
-        // Update the masking variables, which are used when the timeline is empty.
+  private void handlePlaybackInfo(
+      PlaybackInfo playbackInfo,
+      int operationAcks,
+      boolean positionDiscontinuity,
+      @DiscontinuityReason int positionDiscontinuityReason) {
+    pendingOperationAcks -= operationAcks;
+    if (pendingOperationAcks == 0) {
+      if (playbackInfo.startPositionUs == C.TIME_UNSET) {
+        // Replace internal unset start position with externally visible start position of zero.
+        playbackInfo =
+            playbackInfo.fromNewPosition(
+                playbackInfo.periodId, /* startPositionUs= */ 0, playbackInfo.contentPositionUs);
+      }
+      if ((!this.playbackInfo.timeline.isEmpty() || hasPendingPrepare)
+          && playbackInfo.timeline.isEmpty()) {
+        // Update the masking variables, which are used when the timeline becomes empty.
         maskingPeriodIndex = 0;
         maskingWindowIndex = 0;
         maskingWindowPositionMs = 0;
       }
-      if (timelineOrManifestChanged) {
-        for (Player.EventListener listener : listeners) {
-          listener.onTimelineChanged(playbackInfo.timeline, playbackInfo.manifest);
-        }
+      @Player.TimelineChangeReason
+      int timelineChangeReason =
+          hasPendingPrepare
+              ? Player.TIMELINE_CHANGE_REASON_PREPARED
+              : Player.TIMELINE_CHANGE_REASON_DYNAMIC;
+      boolean seekProcessed = hasPendingSeek;
+      hasPendingPrepare = false;
+      hasPendingSeek = false;
+      updatePlaybackInfo(
+          playbackInfo,
+          positionDiscontinuity,
+          positionDiscontinuityReason,
+          timelineChangeReason,
+          seekProcessed);
+    }
+  }
+
+  private PlaybackInfo getResetPlaybackInfo(
+      boolean resetPosition, boolean resetState, int playbackState) {
+    if (resetPosition) {
+      maskingWindowIndex = 0;
+      maskingPeriodIndex = 0;
+      maskingWindowPositionMs = 0;
+    } else {
+      maskingWindowIndex = getCurrentWindowIndex();
+      maskingPeriodIndex = getCurrentPeriodIndex();
+      maskingWindowPositionMs = getCurrentPosition();
+    }
+    return new PlaybackInfo(
+        resetState ? Timeline.EMPTY : playbackInfo.timeline,
+        resetState ? null : playbackInfo.manifest,
+        playbackInfo.periodId,
+        playbackInfo.startPositionUs,
+        playbackInfo.contentPositionUs,
+        playbackState,
+        /* isLoading= */ false,
+        resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult);
+  }
+
+  private void updatePlaybackInfo(
+      PlaybackInfo newPlaybackInfo,
+      boolean positionDiscontinuity,
+      @Player.DiscontinuityReason int positionDiscontinuityReason,
+      @Player.TimelineChangeReason int timelineChangeReason,
+      boolean seekProcessed) {
+    boolean timelineOrManifestChanged =
+        playbackInfo.timeline != newPlaybackInfo.timeline
+            || playbackInfo.manifest != newPlaybackInfo.manifest;
+    boolean playbackStateChanged = playbackInfo.playbackState != newPlaybackInfo.playbackState;
+    boolean isLoadingChanged = playbackInfo.isLoading != newPlaybackInfo.isLoading;
+    boolean trackSelectorResultChanged =
+        this.playbackInfo.trackSelectorResult != newPlaybackInfo.trackSelectorResult;
+    playbackInfo = newPlaybackInfo;
+    if (timelineOrManifestChanged || timelineChangeReason == TIMELINE_CHANGE_REASON_PREPARED) {
+      for (Player.EventListener listener : listeners) {
+        listener.onTimelineChanged(
+            playbackInfo.timeline, playbackInfo.manifest, timelineChangeReason);
       }
-      if (positionDiscontinuity) {
-        for (Player.EventListener listener : listeners) {
-          listener.onPositionDiscontinuity(positionDiscontinuityReason);
-        }
+    }
+    if (positionDiscontinuity) {
+      for (Player.EventListener listener : listeners) {
+        listener.onPositionDiscontinuity(positionDiscontinuityReason);
+      }
+    }
+    if (trackSelectorResultChanged) {
+      trackSelector.onSelectionActivated(playbackInfo.trackSelectorResult.info);
+      for (Player.EventListener listener : listeners) {
+        listener.onTracksChanged(
+            playbackInfo.trackSelectorResult.groups, playbackInfo.trackSelectorResult.selections);
       }
     }
-    if (pendingSeekAcks == 0 && seekAcks > 0) {
+    if (isLoadingChanged) {
+      for (Player.EventListener listener : listeners) {
+        listener.onLoadingChanged(playbackInfo.isLoading);
+      }
+    }
+    if (playbackStateChanged) {
+      for (Player.EventListener listener : listeners) {
+        listener.onPlayerStateChanged(playWhenReady, playbackInfo.playbackState);
+      }
+    }
+    if (seekProcessed) {
       for (Player.EventListener listener : listeners) {
         listener.onSeekProcessed();
       }
@@ -566,7 +678,6 @@ private long playbackInfoPositionUsToWindowPositionMs(long positionUs) {
   }
 
   private boolean shouldMaskPosition() {
-    return playbackInfo.timeline.isEmpty() || pendingSeekAcks > 0 || pendingPrepareAcks > 0;
+    return playbackInfo.timeline.isEmpty() || pendingOperationAcks > 0;
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
index 4d1767b64c..24bd31c62f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerImplInternal.java
@@ -22,43 +22,42 @@
 import android.os.Process;
 import android.os.SystemClock;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.util.Pair;
-import com.google.android.exoplayer2.ExoPlayer.ExoPlayerMessage;
-import com.google.android.exoplayer2.MediaPeriodInfoSequence.MediaPeriodInfo;
-import com.google.android.exoplayer2.source.ClippingMediaPeriod;
-import com.google.android.exoplayer2.source.EmptySampleStream;
+import com.google.android.exoplayer2.DefaultMediaClock.PlaybackParameterListener;
+import com.google.android.exoplayer2.Player.DiscontinuityReason;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.MediaClock;
-import com.google.android.exoplayer2.util.StandaloneMediaClock;
+import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.HandlerWrapper;
 import com.google.android.exoplayer2.util.TraceUtil;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-
-/**
- * Implements the internal behavior of {@link ExoPlayerImpl}.
- */
-/* package */ final class ExoPlayerImplInternal implements Handler.Callback,
-    MediaPeriod.Callback, TrackSelector.InvalidationListener, MediaSource.Listener {
+import java.util.ArrayList;
+import java.util.Collections;
+
+/** Implements the internal behavior of {@link ExoPlayerImpl}. */
+/* package */ final class ExoPlayerImplInternal
+    implements Handler.Callback,
+        MediaPeriod.Callback,
+        TrackSelector.InvalidationListener,
+        MediaSource.Listener,
+        PlaybackParameterListener,
+        PlayerMessage.Sender {
 
   private static final String TAG = "ExoPlayerImplInternal";
 
   // External messages
-  public static final int MSG_STATE_CHANGED = 0;
-  public static final int MSG_LOADING_CHANGED = 1;
-  public static final int MSG_TRACKS_CHANGED = 2;
-  public static final int MSG_SEEK_ACK = 3;
-  public static final int MSG_POSITION_DISCONTINUITY = 4;
-  public static final int MSG_SOURCE_INFO_REFRESHED = 5;
-  public static final int MSG_PLAYBACK_PARAMETERS_CHANGED = 6;
-  public static final int MSG_ERROR = 7;
+  public static final int MSG_PLAYBACK_INFO_CHANGED = 0;
+  public static final int MSG_PLAYBACK_PARAMETERS_CHANGED = 1;
+  public static final int MSG_ERROR = 2;
 
   // Internal messages
   private static final int MSG_PREPARE = 0;
@@ -66,27 +65,22 @@
   private static final int MSG_DO_SOME_WORK = 2;
   private static final int MSG_SEEK_TO = 3;
   private static final int MSG_SET_PLAYBACK_PARAMETERS = 4;
-  private static final int MSG_STOP = 5;
-  private static final int MSG_RELEASE = 6;
-  private static final int MSG_REFRESH_SOURCE_INFO = 7;
-  private static final int MSG_PERIOD_PREPARED = 8;
-  private static final int MSG_SOURCE_CONTINUE_LOADING_REQUESTED = 9;
-  private static final int MSG_TRACK_SELECTION_INVALIDATED = 10;
-  private static final int MSG_CUSTOM = 11;
+  private static final int MSG_SET_SEEK_PARAMETERS = 5;
+  private static final int MSG_STOP = 6;
+  private static final int MSG_RELEASE = 7;
+  private static final int MSG_REFRESH_SOURCE_INFO = 8;
+  private static final int MSG_PERIOD_PREPARED = 9;
+  private static final int MSG_SOURCE_CONTINUE_LOADING_REQUESTED = 10;
+  private static final int MSG_TRACK_SELECTION_INVALIDATED = 11;
   private static final int MSG_SET_REPEAT_MODE = 12;
   private static final int MSG_SET_SHUFFLE_ENABLED = 13;
+  private static final int MSG_SEND_MESSAGE = 14;
+  private static final int MSG_SEND_MESSAGE_TO_TARGET_THREAD = 15;
 
   private static final int PREPARING_SOURCE_INTERVAL_MS = 10;
   private static final int RENDERING_INTERVAL_MS = 10;
   private static final int IDLE_INTERVAL_MS = 1000;
 
-  /**
-   * Limits the maximum number of periods to buffer ahead of the current playing period. The
-   * buffering policy normally prevents buffering too far ahead, but the policy could allow too many
-   * small periods to be buffered if the period count were not limited.
-   */
-  private static final int MAXIMUM_BUFFER_AHEAD_PERIODS = 100;
-
   /**
    * Offset added to all sample timestamps read by renderers to make them non-negative. This is
    * provided for convenience of sources that may return negative timestamps due to prerolling
@@ -98,79 +92,93 @@
   private final Renderer[] renderers;
   private final RendererCapabilities[] rendererCapabilities;
   private final TrackSelector trackSelector;
+  private final TrackSelectorResult emptyTrackSelectorResult;
   private final LoadControl loadControl;
-  private final StandaloneMediaClock standaloneMediaClock;
-  private final Handler handler;
+  private final HandlerWrapper handler;
   private final HandlerThread internalPlaybackThread;
   private final Handler eventHandler;
   private final ExoPlayer player;
   private final Timeline.Window window;
   private final Timeline.Period period;
-  private final MediaPeriodInfoSequence mediaPeriodInfoSequence;
+  private final long backBufferDurationUs;
+  private final boolean retainBackBufferFromKeyframe;
+  private final DefaultMediaClock mediaClock;
+  private final PlaybackInfoUpdate playbackInfoUpdate;
+  private final ArrayList<PendingMessageInfo> pendingMessages;
+  private final Clock clock;
+  private final MediaPeriodQueue queue;
+
+  @SuppressWarnings("unused")
+  private SeekParameters seekParameters;
 
   private PlaybackInfo playbackInfo;
-  private PlaybackParameters playbackParameters;
-  private Renderer rendererMediaClockSource;
-  private MediaClock rendererMediaClock;
   private MediaSource mediaSource;
   private Renderer[] enabledRenderers;
   private boolean released;
   private boolean playWhenReady;
   private boolean rebuffering;
-  private boolean isLoading;
-  private int state;
-  private @Player.RepeatMode int repeatMode;
+  @Player.RepeatMode private int repeatMode;
   private boolean shuffleModeEnabled;
-  private int customMessagesSent;
-  private int customMessagesProcessed;
-  private long elapsedRealtimeUs;
 
   private int pendingPrepareCount;
-  private int pendingInitialSeekCount;
-  private SeekPosition pendingSeekPosition;
+  private SeekPosition pendingInitialSeekPosition;
   private long rendererPositionUs;
-
-  private MediaPeriodHolder loadingPeriodHolder;
-  private MediaPeriodHolder readingPeriodHolder;
-  private MediaPeriodHolder playingPeriodHolder;
-
-  public ExoPlayerImplInternal(Renderer[] renderers, TrackSelector trackSelector,
-      LoadControl loadControl, boolean playWhenReady, @Player.RepeatMode int repeatMode,
-      boolean shuffleModeEnabled, Handler eventHandler, ExoPlayer player) {
+  private int nextPendingMessageIndex;
+
+  public ExoPlayerImplInternal(
+      Renderer[] renderers,
+      TrackSelector trackSelector,
+      TrackSelectorResult emptyTrackSelectorResult,
+      LoadControl loadControl,
+      boolean playWhenReady,
+      @Player.RepeatMode int repeatMode,
+      boolean shuffleModeEnabled,
+      Handler eventHandler,
+      ExoPlayer player,
+      Clock clock) {
     this.renderers = renderers;
     this.trackSelector = trackSelector;
+    this.emptyTrackSelectorResult = emptyTrackSelectorResult;
     this.loadControl = loadControl;
     this.playWhenReady = playWhenReady;
     this.repeatMode = repeatMode;
     this.shuffleModeEnabled = shuffleModeEnabled;
     this.eventHandler = eventHandler;
-    this.state = Player.STATE_IDLE;
     this.player = player;
+    this.clock = clock;
+    this.queue = new MediaPeriodQueue();
+
+    backBufferDurationUs = loadControl.getBackBufferDurationUs();
+    retainBackBufferFromKeyframe = loadControl.retainBackBufferFromKeyframe();
 
-    playbackInfo = new PlaybackInfo(null, null, 0, C.TIME_UNSET);
+    seekParameters = SeekParameters.DEFAULT;
+    playbackInfo =
+        new PlaybackInfo(
+            Timeline.EMPTY, /* startPositionUs= */ C.TIME_UNSET, emptyTrackSelectorResult);
+    playbackInfoUpdate = new PlaybackInfoUpdate();
     rendererCapabilities = new RendererCapabilities[renderers.length];
     for (int i = 0; i < renderers.length; i++) {
       renderers[i].setIndex(i);
       rendererCapabilities[i] = renderers[i].getCapabilities();
     }
-    standaloneMediaClock = new StandaloneMediaClock();
+    mediaClock = new DefaultMediaClock(this, clock);
+    pendingMessages = new ArrayList<>();
     enabledRenderers = new Renderer[0];
     window = new Timeline.Window();
     period = new Timeline.Period();
-    mediaPeriodInfoSequence = new MediaPeriodInfoSequence();
     trackSelector.init(this);
-    playbackParameters = PlaybackParameters.DEFAULT;
 
     // Note: The documentation for Process.THREAD_PRIORITY_AUDIO that states "Applications can
     // not normally change to this priority" is incorrect.
     internalPlaybackThread = new HandlerThread("ExoPlayerImplInternal:Handler",
         Process.THREAD_PRIORITY_AUDIO);
     internalPlaybackThread.start();
-    handler = new Handler(internalPlaybackThread.getLooper(), this);
+    handler = clock.createHandler(internalPlaybackThread.getLooper(), this);
   }
 
-  public void prepare(MediaSource mediaSource, boolean resetPosition) {
-    handler.obtainMessage(MSG_PREPARE, resetPosition ? 1 : 0, 0, mediaSource)
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    handler
+        .obtainMessage(MSG_PREPARE, resetPosition ? 1 : 0, resetState ? 1 : 0, mediaSource)
         .sendToTarget();
   }
 
@@ -195,38 +203,22 @@ public void setPlaybackParameters(PlaybackParameters playbackParameters) {
     handler.obtainMessage(MSG_SET_PLAYBACK_PARAMETERS, playbackParameters).sendToTarget();
   }
 
-  public void stop() {
-    handler.sendEmptyMessage(MSG_STOP);
+  public void setSeekParameters(SeekParameters seekParameters) {
+    handler.obtainMessage(MSG_SET_SEEK_PARAMETERS, seekParameters).sendToTarget();
   }
 
-  public void sendMessages(ExoPlayerMessage... messages) {
-    if (released) {
-      Log.w(TAG, "Ignoring messages sent after release.");
-      return;
-    }
-    customMessagesSent++;
-    handler.obtainMessage(MSG_CUSTOM, messages).sendToTarget();
+  public void stop(boolean reset) {
+    handler.obtainMessage(MSG_STOP, reset ? 1 : 0, 0).sendToTarget();
   }
 
-  public synchronized void blockingSendMessages(ExoPlayerMessage... messages) {
+  @Override
+  public synchronized void sendMessage(PlayerMessage message) {
     if (released) {
       Log.w(TAG, "Ignoring messages sent after release.");
+      message.markAsProcessed(/* isDelivered= */ false);
       return;
     }
-    int messageNumber = customMessagesSent++;
-    handler.obtainMessage(MSG_CUSTOM, messages).sendToTarget();
-    boolean wasInterrupted = false;
-    while (customMessagesProcessed <= messageNumber) {
-      try {
-        wait();
-      } catch (InterruptedException e) {
-        wasInterrupted = true;
-      }
-    }
-    if (wasInterrupted) {
-      // Restore the interrupted status.
-      Thread.currentThread().interrupt();
-    }
+    handler.obtainMessage(MSG_SEND_MESSAGE, message).sendToTarget();
   }
 
   public synchronized void release() {
@@ -279,6 +271,14 @@ public void onTrackSelectionsInvalidated() {
     handler.sendEmptyMessage(MSG_TRACK_SELECTION_INVALIDATED);
   }
 
+  // DefaultMediaClock.PlaybackParameterListener implementation.
+
+  @Override
+  public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
+    eventHandler.obtainMessage(MSG_PLAYBACK_PARAMETERS_CHANGED, playbackParameters).sendToTarget();
+    updateTrackSelectionPlaybackSpeed(playbackParameters.speed);
+  }
+
   // Handler.Callback implementation.
 
   @SuppressWarnings("unchecked")
@@ -286,114 +286,118 @@ public void onTrackSelectionsInvalidated() {
   public boolean handleMessage(Message msg) {
     try {
       switch (msg.what) {
-        case MSG_PREPARE: {
-          prepareInternal((MediaSource) msg.obj, msg.arg1 != 0);
-          return true;
-        }
-        case MSG_SET_PLAY_WHEN_READY: {
+        case MSG_PREPARE:
+          prepareInternal(
+              (MediaSource) msg.obj,
+              /* resetPosition= */ msg.arg1 != 0,
+              /* resetState= */ msg.arg2 != 0);
+          break;
+        case MSG_SET_PLAY_WHEN_READY:
           setPlayWhenReadyInternal(msg.arg1 != 0);
-          return true;
-        }
-        case MSG_SET_REPEAT_MODE: {
+          break;
+        case MSG_SET_REPEAT_MODE:
           setRepeatModeInternal(msg.arg1);
-          return true;
-        }
-        case MSG_SET_SHUFFLE_ENABLED: {
+          break;
+        case MSG_SET_SHUFFLE_ENABLED:
           setShuffleModeEnabledInternal(msg.arg1 != 0);
-          return true;
-        }
-        case MSG_DO_SOME_WORK: {
+          break;
+        case MSG_DO_SOME_WORK:
           doSomeWork();
-          return true;
-        }
-        case MSG_SEEK_TO: {
+          break;
+        case MSG_SEEK_TO:
           seekToInternal((SeekPosition) msg.obj);
-          return true;
-        }
-        case MSG_SET_PLAYBACK_PARAMETERS: {
+          break;
+        case MSG_SET_PLAYBACK_PARAMETERS:
           setPlaybackParametersInternal((PlaybackParameters) msg.obj);
-          return true;
-        }
-        case MSG_STOP: {
-          stopInternal();
-          return true;
-        }
-        case MSG_RELEASE: {
-          releaseInternal();
-          return true;
-        }
-        case MSG_PERIOD_PREPARED: {
+          break;
+        case MSG_SET_SEEK_PARAMETERS:
+          setSeekParametersInternal((SeekParameters) msg.obj);
+          break;
+        case MSG_STOP:
+          stopInternal(/* reset= */ msg.arg1 != 0, /* acknowledgeStop= */ true);
+          break;
+        case MSG_PERIOD_PREPARED:
           handlePeriodPrepared((MediaPeriod) msg.obj);
-          return true;
-        }
-        case MSG_REFRESH_SOURCE_INFO: {
+          break;
+        case MSG_REFRESH_SOURCE_INFO:
           handleSourceInfoRefreshed((MediaSourceRefreshInfo) msg.obj);
-          return true;
-        }
-        case MSG_SOURCE_CONTINUE_LOADING_REQUESTED: {
+          break;
+        case MSG_SOURCE_CONTINUE_LOADING_REQUESTED:
           handleContinueLoadingRequested((MediaPeriod) msg.obj);
-          return true;
-        }
-        case MSG_TRACK_SELECTION_INVALIDATED: {
+          break;
+        case MSG_TRACK_SELECTION_INVALIDATED:
           reselectTracksInternal();
+          break;
+        case MSG_SEND_MESSAGE:
+          sendMessageInternal((PlayerMessage) msg.obj);
+          break;
+        case MSG_SEND_MESSAGE_TO_TARGET_THREAD:
+          sendMessageToTargetThread((PlayerMessage) msg.obj);
+          break;
+        case MSG_RELEASE:
+          releaseInternal();
+          // Return immediately to not send playback info updates after release.
           return true;
-        }
-        case MSG_CUSTOM: {
-          sendMessagesInternal((ExoPlayerMessage[]) msg.obj);
-          return true;
-        }
         default:
           return false;
       }
+      maybeNotifyPlaybackInfoChanged();
     } catch (ExoPlaybackException e) {
-      Log.e(TAG, "Renderer error.", e);
+      Log.e(TAG, "Playback error.", e);
+      stopInternal(/* reset= */ false, /* acknowledgeStop= */ false);
       eventHandler.obtainMessage(MSG_ERROR, e).sendToTarget();
-      stopInternal();
-      return true;
+      maybeNotifyPlaybackInfoChanged();
     } catch (IOException e) {
       Log.e(TAG, "Source error.", e);
+      stopInternal(/* reset= */ false, /* acknowledgeStop= */ false);
       eventHandler.obtainMessage(MSG_ERROR, ExoPlaybackException.createForSource(e)).sendToTarget();
-      stopInternal();
-      return true;
+      maybeNotifyPlaybackInfoChanged();
     } catch (RuntimeException e) {
       Log.e(TAG, "Internal runtime error.", e);
+      stopInternal(/* reset= */ false, /* acknowledgeStop= */ false);
       eventHandler.obtainMessage(MSG_ERROR, ExoPlaybackException.createForUnexpected(e))
           .sendToTarget();
-      stopInternal();
-      return true;
+      maybeNotifyPlaybackInfoChanged();
     }
+    return true;
   }
 
   // Private methods.
 
   private void setState(int state) {
-    if (this.state != state) {
-      this.state = state;
-      eventHandler.obtainMessage(MSG_STATE_CHANGED, state, 0).sendToTarget();
+    if (playbackInfo.playbackState != state) {
+      playbackInfo = playbackInfo.copyWithPlaybackState(state);
     }
   }
 
   private void setIsLoading(boolean isLoading) {
-    if (this.isLoading != isLoading) {
-      this.isLoading = isLoading;
-      eventHandler.obtainMessage(MSG_LOADING_CHANGED, isLoading ? 1 : 0, 0).sendToTarget();
+    if (playbackInfo.isLoading != isLoading) {
+      playbackInfo = playbackInfo.copyWithIsLoading(isLoading);
+    }
+  }
+
+  private void maybeNotifyPlaybackInfoChanged() {
+    if (playbackInfoUpdate.hasPendingUpdate(playbackInfo)) {
+      eventHandler
+          .obtainMessage(
+              MSG_PLAYBACK_INFO_CHANGED,
+              playbackInfoUpdate.operationAcks,
+              playbackInfoUpdate.positionDiscontinuity
+                  ? playbackInfoUpdate.discontinuityReason
+                  : C.INDEX_UNSET,
+              playbackInfo)
+          .sendToTarget();
+      playbackInfoUpdate.reset(playbackInfo);
     }
   }
 
-  private void prepareInternal(MediaSource mediaSource, boolean resetPosition) {
+  private void prepareInternal(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
     pendingPrepareCount++;
-    resetInternal(true);
+    resetInternal(/* releaseMediaSource= */ true, resetPosition, resetState);
     loadControl.onPrepared();
-    if (resetPosition) {
-      playbackInfo = new PlaybackInfo(null, null, 0, C.TIME_UNSET);
-    } else {
-      // The new start position is the current playback position.
-      playbackInfo = new PlaybackInfo(null, null, playbackInfo.periodId, playbackInfo.positionUs,
-          playbackInfo.contentPositionUs);
-    }
     this.mediaSource = mediaSource;
-    mediaSource.prepareSource(player, true, this);
     setState(Player.STATE_BUFFERING);
+    mediaSource.prepareSource(player, /* isTopLevelSource= */ true, /* listener= */ this);
     handler.sendEmptyMessage(MSG_DO_SOME_WORK);
   }
 
@@ -404,10 +408,10 @@ private void setPlayWhenReadyInternal(boolean playWhenReady) throws ExoPlaybackE
       stopRenderers();
       updatePlaybackPositions();
     } else {
-      if (state == Player.STATE_READY) {
+      if (playbackInfo.playbackState == Player.STATE_READY) {
         startRenderers();
         handler.sendEmptyMessage(MSG_DO_SOME_WORK);
-      } else if (state == Player.STATE_BUFFERING) {
+      } else if (playbackInfo.playbackState == Player.STATE_BUFFERING) {
         handler.sendEmptyMessage(MSG_DO_SOME_WORK);
       }
     }
@@ -416,149 +420,107 @@ private void setPlayWhenReadyInternal(boolean playWhenReady) throws ExoPlaybackE
   private void setRepeatModeInternal(@Player.RepeatMode int repeatMode)
       throws ExoPlaybackException {
     this.repeatMode = repeatMode;
-    mediaPeriodInfoSequence.setRepeatMode(repeatMode);
-    validateExistingPeriodHolders();
+    if (!queue.updateRepeatMode(repeatMode)) {
+      seekToCurrentPosition(/* sendDiscontinuity= */ true);
+    }
   }
 
   private void setShuffleModeEnabledInternal(boolean shuffleModeEnabled)
       throws ExoPlaybackException {
     this.shuffleModeEnabled = shuffleModeEnabled;
-    mediaPeriodInfoSequence.setShuffleModeEnabled(shuffleModeEnabled);
-    validateExistingPeriodHolders();
-  }
-
-  private void validateExistingPeriodHolders() throws ExoPlaybackException {
-    // Find the last existing period holder that matches the new period order.
-    MediaPeriodHolder lastValidPeriodHolder = playingPeriodHolder != null
-        ? playingPeriodHolder : loadingPeriodHolder;
-    if (lastValidPeriodHolder == null) {
-      return;
-    }
-    while (true) {
-      int nextPeriodIndex = playbackInfo.timeline.getNextPeriodIndex(
-          lastValidPeriodHolder.info.id.periodIndex, period, window, repeatMode,
-          shuffleModeEnabled);
-      while (lastValidPeriodHolder.next != null
-          && !lastValidPeriodHolder.info.isLastInTimelinePeriod) {
-        lastValidPeriodHolder = lastValidPeriodHolder.next;
-      }
-      if (nextPeriodIndex == C.INDEX_UNSET || lastValidPeriodHolder.next == null
-          || lastValidPeriodHolder.next.info.id.periodIndex != nextPeriodIndex) {
-        break;
-      }
-      lastValidPeriodHolder = lastValidPeriodHolder.next;
-    }
-
-    // Release any period holders that don't match the new period order.
-    int loadingPeriodHolderIndex = loadingPeriodHolder.index;
-    int readingPeriodHolderIndex =
-        readingPeriodHolder != null ? readingPeriodHolder.index : C.INDEX_UNSET;
-    if (lastValidPeriodHolder.next != null) {
-      releasePeriodHoldersFrom(lastValidPeriodHolder.next);
-      lastValidPeriodHolder.next = null;
-    }
-
-    // Update the period info for the last holder, as it may now be the last period in the timeline.
-    lastValidPeriodHolder.info =
-        mediaPeriodInfoSequence.getUpdatedMediaPeriodInfo(lastValidPeriodHolder.info);
-
-    // Handle cases where loadingPeriodHolder or readingPeriodHolder have been removed.
-    boolean seenLoadingPeriodHolder = loadingPeriodHolderIndex <= lastValidPeriodHolder.index;
-    if (!seenLoadingPeriodHolder) {
-      loadingPeriodHolder = lastValidPeriodHolder;
-    }
-    boolean seenReadingPeriodHolder = readingPeriodHolderIndex != C.INDEX_UNSET
-        && readingPeriodHolderIndex <= lastValidPeriodHolder.index;
-    if (!seenReadingPeriodHolder && playingPeriodHolder != null) {
-      // Renderers may have read from a period that's been removed. Seek back to the current
-      // position of the playing period to make sure none of the removed period is played.
-      MediaPeriodId periodId = playingPeriodHolder.info.id;
-      long newPositionUs = seekToPeriodPosition(periodId, playbackInfo.positionUs);
-      if (newPositionUs != playbackInfo.positionUs) {
-        playbackInfo = playbackInfo.fromNewPosition(periodId, newPositionUs,
-            playbackInfo.contentPositionUs);
-        eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, Player.DISCONTINUITY_REASON_INTERNAL,
-            0, playbackInfo).sendToTarget();
+    if (!queue.updateShuffleModeEnabled(shuffleModeEnabled)) {
+      seekToCurrentPosition(/* sendDiscontinuity= */ true);
+    }
+  }
+
+  private void seekToCurrentPosition(boolean sendDiscontinuity) throws ExoPlaybackException {
+    // Renderers may have read from a period that's been removed. Seek back to the current
+    // position of the playing period to make sure none of the removed period is played.
+    MediaPeriodId periodId = queue.getPlayingPeriod().info.id;
+    long newPositionUs =
+        seekToPeriodPosition(periodId, playbackInfo.positionUs, /* forceDisableRenderers= */ true);
+    if (newPositionUs != playbackInfo.positionUs) {
+      playbackInfo =
+          playbackInfo.fromNewPosition(periodId, newPositionUs, playbackInfo.contentPositionUs);
+      if (sendDiscontinuity) {
+        playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
       }
     }
   }
 
   private void startRenderers() throws ExoPlaybackException {
     rebuffering = false;
-    standaloneMediaClock.start();
+    mediaClock.start();
     for (Renderer renderer : enabledRenderers) {
       renderer.start();
     }
   }
 
   private void stopRenderers() throws ExoPlaybackException {
-    standaloneMediaClock.stop();
+    mediaClock.stop();
     for (Renderer renderer : enabledRenderers) {
       ensureStopped(renderer);
     }
   }
 
   private void updatePlaybackPositions() throws ExoPlaybackException {
-    if (playingPeriodHolder == null) {
+    if (!queue.hasPlayingPeriod()) {
       return;
     }
 
     // Update the playback position.
+    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
     long periodPositionUs = playingPeriodHolder.mediaPeriod.readDiscontinuity();
     if (periodPositionUs != C.TIME_UNSET) {
       resetRendererPosition(periodPositionUs);
-      playbackInfo = playbackInfo.fromNewPosition(playbackInfo.periodId, periodPositionUs,
-          playbackInfo.contentPositionUs);
-      eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, Player.DISCONTINUITY_REASON_INTERNAL,
-          0, playbackInfo).sendToTarget();
-    } else {
-      // Use the standalone clock if there's no renderer clock, or if the providing renderer has
-      // ended or needs the next sample stream to reenter the ready state. The latter case uses the
-      // standalone clock to avoid getting stuck if tracks in the current period have uneven
-      // durations. See: https://github.com/google/ExoPlayer/issues/1874.
-      if (rendererMediaClockSource == null || rendererMediaClockSource.isEnded()
-          || (!rendererMediaClockSource.isReady()
-              && rendererWaitingForNextStream(rendererMediaClockSource))) {
-        rendererPositionUs = standaloneMediaClock.getPositionUs();
-      } else {
-        rendererPositionUs = rendererMediaClock.getPositionUs();
-        standaloneMediaClock.setPositionUs(rendererPositionUs);
+      // A MediaPeriod may report a discontinuity at the current playback position to ensure the
+      // renderers are flushed. Only report the discontinuity externally if the position changed.
+      if (periodPositionUs != playbackInfo.positionUs) {
+        playbackInfo = playbackInfo.fromNewPosition(playbackInfo.periodId, periodPositionUs,
+            playbackInfo.contentPositionUs);
+        playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
       }
+    } else {
+      rendererPositionUs = mediaClock.syncAndGetPositionUs();
       periodPositionUs = playingPeriodHolder.toPeriodTime(rendererPositionUs);
+      maybeTriggerPendingMessages(playbackInfo.positionUs, periodPositionUs);
+      playbackInfo.positionUs = periodPositionUs;
     }
-    playbackInfo.positionUs = periodPositionUs;
-    elapsedRealtimeUs = SystemClock.elapsedRealtime() * 1000;
 
     // Update the buffered position.
-    long bufferedPositionUs = enabledRenderers.length == 0 ? C.TIME_END_OF_SOURCE
-        : playingPeriodHolder.mediaPeriod.getBufferedPositionUs();
-    playbackInfo.bufferedPositionUs = bufferedPositionUs == C.TIME_END_OF_SOURCE
-        ? playingPeriodHolder.info.durationUs : bufferedPositionUs;
+    playbackInfo.bufferedPositionUs =
+        enabledRenderers.length == 0
+            ? playingPeriodHolder.info.durationUs
+            : playingPeriodHolder.getBufferedPositionUs(/* convertEosToDuration= */ true);
   }
 
   private void doSomeWork() throws ExoPlaybackException, IOException {
-    long operationStartTimeMs = SystemClock.elapsedRealtime();
+    long operationStartTimeMs = clock.uptimeMillis();
     updatePeriods();
-    if (playingPeriodHolder == null) {
+    if (!queue.hasPlayingPeriod()) {
       // We're still waiting for the first period to be prepared.
       maybeThrowPeriodPrepareError();
       scheduleNextWork(operationStartTimeMs, PREPARING_SOURCE_INTERVAL_MS);
       return;
     }
+    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
 
     TraceUtil.beginSection("doSomeWork");
 
     updatePlaybackPositions();
-    playingPeriodHolder.mediaPeriod.discardBuffer(playbackInfo.positionUs);
+    long rendererPositionElapsedRealtimeUs = SystemClock.elapsedRealtime() * 1000;
+
+    playingPeriodHolder.mediaPeriod.discardBuffer(playbackInfo.positionUs - backBufferDurationUs,
+        retainBackBufferFromKeyframe);
 
-    boolean allRenderersEnded = true;
-    boolean allRenderersReadyOrEnded = true;
+    boolean renderersEnded = true;
+    boolean renderersReadyOrEnded = true;
     for (Renderer renderer : enabledRenderers) {
       // TODO: Each renderer should return the maximum delay before which it wishes to be called
       // again. The minimum of these values should then be used as the delay before the next
       // invocation of this method.
-      renderer.render(rendererPositionUs, elapsedRealtimeUs);
-      allRenderersEnded = allRenderersEnded && renderer.isEnded();
+      renderer.render(rendererPositionUs, rendererPositionElapsedRealtimeUs);
+      renderersEnded = renderersEnded && renderer.isEnded();
       // Determine whether the renderer is ready (or ended). We override to assume the renderer is
       // ready if it needs the next sample stream. This is necessary to avoid getting stuck if
       // tracks in the current period have uneven durations. See:
@@ -568,63 +530,42 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
       if (!rendererReadyOrEnded) {
         renderer.maybeThrowStreamError();
       }
-      allRenderersReadyOrEnded = allRenderersReadyOrEnded && rendererReadyOrEnded;
+      renderersReadyOrEnded = renderersReadyOrEnded && rendererReadyOrEnded;
     }
-
-    if (!allRenderersReadyOrEnded) {
+    if (!renderersReadyOrEnded) {
       maybeThrowPeriodPrepareError();
     }
 
-    // The standalone media clock never changes playback parameters, so just check the renderer.
-    if (rendererMediaClock != null) {
-      PlaybackParameters playbackParameters = rendererMediaClock.getPlaybackParameters();
-      if (!playbackParameters.equals(this.playbackParameters)) {
-        // TODO: Make LoadControl, period transition position projection, adaptive track selection
-        // and potentially any time-related code in renderers take into account the playback speed.
-        this.playbackParameters = playbackParameters;
-        standaloneMediaClock.setPlaybackParameters(playbackParameters);
-        eventHandler.obtainMessage(MSG_PLAYBACK_PARAMETERS_CHANGED, playbackParameters)
-            .sendToTarget();
-      }
-    }
-
     long playingPeriodDurationUs = playingPeriodHolder.info.durationUs;
-    if (allRenderersEnded
+    if (renderersEnded
         && (playingPeriodDurationUs == C.TIME_UNSET
-        || playingPeriodDurationUs <= playbackInfo.positionUs)
+            || playingPeriodDurationUs <= playbackInfo.positionUs)
         && playingPeriodHolder.info.isFinal) {
       setState(Player.STATE_ENDED);
       stopRenderers();
-    } else if (state == Player.STATE_BUFFERING) {
-      boolean isNewlyReady = enabledRenderers.length > 0
-          ? (allRenderersReadyOrEnded
-              && loadingPeriodHolder.haveSufficientBuffer(rebuffering, rendererPositionUs))
-          : isTimelineReady(playingPeriodDurationUs);
-      if (isNewlyReady) {
-        setState(Player.STATE_READY);
-        if (playWhenReady) {
-          startRenderers();
-        }
-      }
-    } else if (state == Player.STATE_READY) {
-      boolean isStillReady = enabledRenderers.length > 0 ? allRenderersReadyOrEnded
-          : isTimelineReady(playingPeriodDurationUs);
-      if (!isStillReady) {
-        rebuffering = playWhenReady;
-        setState(Player.STATE_BUFFERING);
-        stopRenderers();
+    } else if (playbackInfo.playbackState == Player.STATE_BUFFERING
+        && shouldTransitionToReadyState(renderersReadyOrEnded)) {
+      setState(Player.STATE_READY);
+      if (playWhenReady) {
+        startRenderers();
       }
+    } else if (playbackInfo.playbackState == Player.STATE_READY
+        && !(enabledRenderers.length == 0 ? isTimelineReady() : renderersReadyOrEnded)) {
+      rebuffering = playWhenReady;
+      setState(Player.STATE_BUFFERING);
+      stopRenderers();
     }
 
-    if (state == Player.STATE_BUFFERING) {
+    if (playbackInfo.playbackState == Player.STATE_BUFFERING) {
       for (Renderer renderer : enabledRenderers) {
         renderer.maybeThrowStreamError();
       }
     }
 
-    if ((playWhenReady && state == Player.STATE_READY) || state == Player.STATE_BUFFERING) {
+    if ((playWhenReady && playbackInfo.playbackState == Player.STATE_READY)
+        || playbackInfo.playbackState == Player.STATE_BUFFERING) {
       scheduleNextWork(operationStartTimeMs, RENDERING_INTERVAL_MS);
-    } else if (enabledRenderers.length != 0 && state != Player.STATE_ENDED) {
+    } else if (enabledRenderers.length != 0 && playbackInfo.playbackState != Player.STATE_ENDED) {
       scheduleNextWork(operationStartTimeMs, IDLE_INTERVAL_MS);
     } else {
       handler.removeMessages(MSG_DO_SOME_WORK);
@@ -635,118 +576,122 @@ private void doSomeWork() throws ExoPlaybackException, IOException {
 
   private void scheduleNextWork(long thisOperationStartTimeMs, long intervalMs) {
     handler.removeMessages(MSG_DO_SOME_WORK);
-    long nextOperationStartTimeMs = thisOperationStartTimeMs + intervalMs;
-    long nextOperationDelayMs = nextOperationStartTimeMs - SystemClock.elapsedRealtime();
-    if (nextOperationDelayMs <= 0) {
-      handler.sendEmptyMessage(MSG_DO_SOME_WORK);
-    } else {
-      handler.sendEmptyMessageDelayed(MSG_DO_SOME_WORK, nextOperationDelayMs);
-    }
+    handler.sendEmptyMessageAtTime(MSG_DO_SOME_WORK, thisOperationStartTimeMs + intervalMs);
   }
 
   private void seekToInternal(SeekPosition seekPosition) throws ExoPlaybackException {
-    Timeline timeline = playbackInfo.timeline;
-    if (timeline == null) {
-      pendingInitialSeekCount++;
-      pendingSeekPosition = seekPosition;
-      return;
-    }
-
-    Pair<Integer, Long> periodPosition = resolveSeekPosition(seekPosition);
-    if (periodPosition == null) {
-      int firstPeriodIndex = timeline.isEmpty() ? 0 : timeline.getWindow(
-          timeline.getFirstWindowIndex(shuffleModeEnabled), window).firstPeriodIndex;
+    playbackInfoUpdate.incrementPendingOperationAcks(/* operationAcks= */ 1);
+
+    MediaPeriodId periodId;
+    long periodPositionUs;
+    long contentPositionUs;
+    boolean seekPositionAdjusted;
+    Pair<Integer, Long> resolvedSeekPosition =
+        resolveSeekPosition(seekPosition, /* trySubsequentPeriods= */ true);
+    if (resolvedSeekPosition == null) {
       // The seek position was valid for the timeline that it was performed into, but the
-      // timeline has changed and a suitable seek position could not be resolved in the new one.
-      // Set the internal position to (firstPeriodIndex,TIME_UNSET) so that a subsequent seek to
-      // (firstPeriodIndex,0) isn't ignored.
-      playbackInfo = playbackInfo.fromNewPosition(firstPeriodIndex, C.TIME_UNSET, C.TIME_UNSET);
-      setState(Player.STATE_ENDED);
-      eventHandler.obtainMessage(MSG_SEEK_ACK, 1, 0,
-          playbackInfo.fromNewPosition(firstPeriodIndex, 0, C.TIME_UNSET)).sendToTarget();
-      // Reset, but retain the source so that it can still be used should a seek occur.
-      resetInternal(false);
-      return;
-    }
-
-    boolean seekPositionAdjusted = seekPosition.windowPositionUs == C.TIME_UNSET;
-    int periodIndex = periodPosition.first;
-    long periodPositionUs = periodPosition.second;
-    long contentPositionUs = periodPositionUs;
-    MediaPeriodId periodId =
-        mediaPeriodInfoSequence.resolvePeriodPositionForAds(periodIndex, periodPositionUs);
-    if (periodId.isAd()) {
+      // timeline has changed or is not ready and a suitable seek position could not be resolved.
+      periodId = new MediaPeriodId(getFirstPeriodIndex());
+      periodPositionUs = C.TIME_UNSET;
+      contentPositionUs = C.TIME_UNSET;
       seekPositionAdjusted = true;
-      periodPositionUs = 0;
+    } else {
+      // Update the resolved seek position to take ads into account.
+      int periodIndex = resolvedSeekPosition.first;
+      contentPositionUs = resolvedSeekPosition.second;
+      periodId = queue.resolveMediaPeriodIdForAds(periodIndex, contentPositionUs);
+      if (periodId.isAd()) {
+        periodPositionUs = 0;
+        seekPositionAdjusted = true;
+      } else {
+        periodPositionUs = resolvedSeekPosition.second;
+        seekPositionAdjusted = seekPosition.windowPositionUs == C.TIME_UNSET;
+      }
     }
+
     try {
-      if (periodId.equals(playbackInfo.periodId)
-          && ((periodPositionUs / 1000) == (playbackInfo.positionUs / 1000))) {
-        // Seek position equals the current position. Do nothing.
-        return;
+      if (mediaSource == null || pendingPrepareCount > 0) {
+        // Save seek position for later, as we are still waiting for a prepared source.
+        pendingInitialSeekPosition = seekPosition;
+      } else if (periodPositionUs == C.TIME_UNSET) {
+        // End playback, as we didn't manage to find a valid seek position.
+        setState(Player.STATE_ENDED);
+        resetInternal(
+            /* releaseMediaSource= */ false, /* resetPosition= */ true, /* resetState= */ false);
+      } else {
+        // Execute the seek in the current media periods.
+        long newPeriodPositionUs = periodPositionUs;
+        if (periodId.equals(playbackInfo.periodId)) {
+          MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
+          if (playingPeriodHolder != null && newPeriodPositionUs != 0) {
+            newPeriodPositionUs =
+                playingPeriodHolder.mediaPeriod.getAdjustedSeekPositionUs(
+                    newPeriodPositionUs, seekParameters);
+          }
+          if (C.usToMs(newPeriodPositionUs) == C.usToMs(playbackInfo.positionUs)) {
+            // Seek will be performed to the current position. Do nothing.
+            periodPositionUs = playbackInfo.positionUs;
+            return;
+          }
+        }
+        newPeriodPositionUs = seekToPeriodPosition(periodId, newPeriodPositionUs);
+        seekPositionAdjusted |= periodPositionUs != newPeriodPositionUs;
+        periodPositionUs = newPeriodPositionUs;
       }
-      long newPeriodPositionUs = seekToPeriodPosition(periodId, periodPositionUs);
-      seekPositionAdjusted |= periodPositionUs != newPeriodPositionUs;
-      periodPositionUs = newPeriodPositionUs;
     } finally {
       playbackInfo = playbackInfo.fromNewPosition(periodId, periodPositionUs, contentPositionUs);
-      eventHandler.obtainMessage(MSG_SEEK_ACK, seekPositionAdjusted ? 1 : 0, 0, playbackInfo)
-          .sendToTarget();
+      if (seekPositionAdjusted) {
+        playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT);
+      }
     }
   }
 
   private long seekToPeriodPosition(MediaPeriodId periodId, long periodPositionUs)
       throws ExoPlaybackException {
+    // Force disable renderers if they are reading from a period other than the one being played.
+    return seekToPeriodPosition(
+        periodId, periodPositionUs, queue.getPlayingPeriod() != queue.getReadingPeriod());
+  }
+
+  private long seekToPeriodPosition(
+      MediaPeriodId periodId, long periodPositionUs, boolean forceDisableRenderers)
+      throws ExoPlaybackException {
     stopRenderers();
     rebuffering = false;
     setState(Player.STATE_BUFFERING);
 
-    MediaPeriodHolder newPlayingPeriodHolder = null;
-    if (playingPeriodHolder == null) {
-      // We're still waiting for the first period to be prepared.
-      if (loadingPeriodHolder != null) {
-        loadingPeriodHolder.release();
-      }
-    } else {
-      // Clear the timeline, but keep the requested period if it is already prepared.
-      MediaPeriodHolder periodHolder = playingPeriodHolder;
-      while (periodHolder != null) {
-        if (newPlayingPeriodHolder == null
-            && shouldKeepPeriodHolder(periodId, periodPositionUs, periodHolder)) {
-          newPlayingPeriodHolder = periodHolder;
-        } else {
-          periodHolder.release();
-        }
-        periodHolder = periodHolder.next;
+    // Clear the timeline, but keep the requested period if it is already prepared.
+    MediaPeriodHolder oldPlayingPeriodHolder = queue.getPlayingPeriod();
+    MediaPeriodHolder newPlayingPeriodHolder = oldPlayingPeriodHolder;
+    while (newPlayingPeriodHolder != null) {
+      if (shouldKeepPeriodHolder(periodId, periodPositionUs, newPlayingPeriodHolder)) {
+        queue.removeAfter(newPlayingPeriodHolder);
+        break;
       }
+      newPlayingPeriodHolder = queue.advancePlayingPeriod();
     }
 
-    // Disable all the renderers if the period being played is changing, or if the renderers are
-    // reading from a period other than the one being played.
-    if (playingPeriodHolder != newPlayingPeriodHolder
-        || playingPeriodHolder != readingPeriodHolder) {
+    // Disable all the renderers if the period being played is changing, or if forced.
+    if (oldPlayingPeriodHolder != newPlayingPeriodHolder || forceDisableRenderers) {
       for (Renderer renderer : enabledRenderers) {
         disableRenderer(renderer);
       }
       enabledRenderers = new Renderer[0];
-      playingPeriodHolder = null;
+      oldPlayingPeriodHolder = null;
     }
 
     // Update the holders.
     if (newPlayingPeriodHolder != null) {
-      newPlayingPeriodHolder.next = null;
-      loadingPeriodHolder = newPlayingPeriodHolder;
-      readingPeriodHolder = newPlayingPeriodHolder;
-      setPlayingPeriodHolder(newPlayingPeriodHolder);
-      if (playingPeriodHolder.hasEnabledTracks) {
-        periodPositionUs = playingPeriodHolder.mediaPeriod.seekToUs(periodPositionUs);
+      updatePlayingPeriodRenderers(oldPlayingPeriodHolder);
+      if (newPlayingPeriodHolder.hasEnabledTracks) {
+        periodPositionUs = newPlayingPeriodHolder.mediaPeriod.seekToUs(periodPositionUs);
+        newPlayingPeriodHolder.mediaPeriod.discardBuffer(
+            periodPositionUs - backBufferDurationUs, retainBackBufferFromKeyframe);
       }
       resetRendererPosition(periodPositionUs);
       maybeContinueLoading();
     } else {
-      loadingPeriodHolder = null;
-      readingPeriodHolder = null;
-      playingPeriodHolder = null;
+      queue.clear();
       resetRendererPosition(periodPositionUs);
     }
 
@@ -754,8 +699,8 @@ private long seekToPeriodPosition(MediaPeriodId periodId, long periodPositionUs)
     return periodPositionUs;
   }
 
-  private boolean shouldKeepPeriodHolder(MediaPeriodId seekPeriodId, long positionUs,
-      MediaPeriodHolder holder) {
+  private boolean shouldKeepPeriodHolder(
+      MediaPeriodId seekPeriodId, long positionUs, MediaPeriodHolder holder) {
     if (seekPeriodId.equals(holder.info.id) && holder.prepared) {
       playbackInfo.timeline.getPeriod(holder.info.id.periodIndex, period);
       int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(positionUs);
@@ -768,32 +713,37 @@ private boolean shouldKeepPeriodHolder(MediaPeriodId seekPeriodId, long position
   }
 
   private void resetRendererPosition(long periodPositionUs) throws ExoPlaybackException {
-    rendererPositionUs = playingPeriodHolder == null
-        ? periodPositionUs + RENDERER_TIMESTAMP_OFFSET_US
-        : playingPeriodHolder.toRendererTime(periodPositionUs);
-    standaloneMediaClock.setPositionUs(rendererPositionUs);
+    rendererPositionUs =
+        !queue.hasPlayingPeriod()
+            ? periodPositionUs + RENDERER_TIMESTAMP_OFFSET_US
+            : queue.getPlayingPeriod().toRendererTime(periodPositionUs);
+    mediaClock.resetPosition(rendererPositionUs);
     for (Renderer renderer : enabledRenderers) {
       renderer.resetPosition(rendererPositionUs);
     }
   }
 
   private void setPlaybackParametersInternal(PlaybackParameters playbackParameters) {
-    if (rendererMediaClock != null) {
-      playbackParameters = rendererMediaClock.setPlaybackParameters(playbackParameters);
-    }
-    standaloneMediaClock.setPlaybackParameters(playbackParameters);
-    this.playbackParameters = playbackParameters;
-    eventHandler.obtainMessage(MSG_PLAYBACK_PARAMETERS_CHANGED, playbackParameters).sendToTarget();
+    mediaClock.setPlaybackParameters(playbackParameters);
+  }
+
+  private void setSeekParametersInternal(SeekParameters seekParameters) {
+    this.seekParameters = seekParameters;
   }
 
-  private void stopInternal() {
-    resetInternal(true);
+  private void stopInternal(boolean reset, boolean acknowledgeStop) {
+    resetInternal(
+        /* releaseMediaSource= */ true, /* resetPosition= */ reset, /* resetState= */ reset);
+    playbackInfoUpdate.incrementPendingOperationAcks(
+        pendingPrepareCount + (acknowledgeStop ? 1 : 0));
+    pendingPrepareCount = 0;
     loadControl.onStopped();
     setState(Player.STATE_IDLE);
   }
 
   private void releaseInternal() {
-    resetInternal(true);
+    resetInternal(
+        /* releaseMediaSource= */ true, /* resetPosition= */ true, /* resetState= */ true);
     loadControl.onReleased();
     setState(Player.STATE_IDLE);
     internalPlaybackThread.quit();
@@ -803,10 +753,19 @@ private void releaseInternal() {
     }
   }
 
-  private void resetInternal(boolean releaseMediaSource) {
+  private int getFirstPeriodIndex() {
+    Timeline timeline = playbackInfo.timeline;
+    return timeline.isEmpty()
+        ? 0
+        : timeline.getWindow(timeline.getFirstWindowIndex(shuffleModeEnabled), window)
+            .firstPeriodIndex;
+  }
+
+  private void resetInternal(
+      boolean releaseMediaSource, boolean resetPosition, boolean resetState) {
     handler.removeMessages(MSG_DO_SOME_WORK);
     rebuffering = false;
-    standaloneMediaClock.stop();
+    mediaClock.stop();
     rendererPositionUs = RENDERER_TIMESTAMP_OFFSET_US;
     for (Renderer renderer : enabledRenderers) {
       try {
@@ -817,36 +776,187 @@ private void resetInternal(boolean releaseMediaSource) {
       }
     }
     enabledRenderers = new Renderer[0];
-    releasePeriodHoldersFrom(playingPeriodHolder != null ? playingPeriodHolder
-        : loadingPeriodHolder);
-    loadingPeriodHolder = null;
-    readingPeriodHolder = null;
-    playingPeriodHolder = null;
+    queue.clear();
     setIsLoading(false);
+    if (resetPosition) {
+      pendingInitialSeekPosition = null;
+    }
+    if (resetState) {
+      queue.setTimeline(Timeline.EMPTY);
+      for (PendingMessageInfo pendingMessageInfo : pendingMessages) {
+        pendingMessageInfo.message.markAsProcessed(/* isDelivered= */ false);
+      }
+      pendingMessages.clear();
+      nextPendingMessageIndex = 0;
+    }
+    playbackInfo =
+        new PlaybackInfo(
+            resetState ? Timeline.EMPTY : playbackInfo.timeline,
+            resetState ? null : playbackInfo.manifest,
+            resetPosition ? new MediaPeriodId(getFirstPeriodIndex()) : playbackInfo.periodId,
+            // Set the start position to TIME_UNSET so that a subsequent seek to 0 isn't ignored.
+            resetPosition ? C.TIME_UNSET : playbackInfo.positionUs,
+            resetPosition ? C.TIME_UNSET : playbackInfo.contentPositionUs,
+            playbackInfo.playbackState,
+            /* isLoading= */ false,
+            resetState ? emptyTrackSelectorResult : playbackInfo.trackSelectorResult);
     if (releaseMediaSource) {
       if (mediaSource != null) {
         mediaSource.releaseSource();
         mediaSource = null;
       }
-      mediaPeriodInfoSequence.setTimeline(null);
-      playbackInfo = playbackInfo.copyWithTimeline(null, null);
     }
   }
 
-  private void sendMessagesInternal(ExoPlayerMessage[] messages) throws ExoPlaybackException {
-    try {
-      for (ExoPlayerMessage message : messages) {
-        message.target.handleMessage(message.messageType, message.message);
+  private void sendMessageInternal(PlayerMessage message) throws ExoPlaybackException {
+    if (message.getPositionMs() == C.TIME_UNSET) {
+      // If no delivery time is specified, trigger immediate message delivery.
+      sendMessageToTarget(message);
+    } else if (mediaSource == null || pendingPrepareCount > 0) {
+      // Still waiting for initial timeline to resolve position.
+      pendingMessages.add(new PendingMessageInfo(message));
+    } else {
+      PendingMessageInfo pendingMessageInfo = new PendingMessageInfo(message);
+      if (resolvePendingMessagePosition(pendingMessageInfo)) {
+        pendingMessages.add(pendingMessageInfo);
+        // Ensure new message is inserted according to playback order.
+        Collections.sort(pendingMessages);
+      } else {
+        message.markAsProcessed(/* isDelivered= */ false);
       }
-      if (state == Player.STATE_READY || state == Player.STATE_BUFFERING) {
+    }
+  }
+
+  private void sendMessageToTarget(PlayerMessage message) throws ExoPlaybackException {
+    if (message.getHandler().getLooper() == handler.getLooper()) {
+      deliverMessage(message);
+      if (playbackInfo.playbackState == Player.STATE_READY
+          || playbackInfo.playbackState == Player.STATE_BUFFERING) {
         // The message may have caused something to change that now requires us to do work.
         handler.sendEmptyMessage(MSG_DO_SOME_WORK);
       }
+    } else {
+      handler.obtainMessage(MSG_SEND_MESSAGE_TO_TARGET_THREAD, message).sendToTarget();
+    }
+  }
+
+  private void sendMessageToTargetThread(final PlayerMessage message) {
+    Handler handler = message.getHandler();
+    handler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            try {
+              deliverMessage(message);
+            } catch (ExoPlaybackException e) {
+              Log.e(TAG, "Unexpected error delivering message on external thread.", e);
+              throw new RuntimeException(e);
+            }
+          }
+        });
+  }
+
+  private void deliverMessage(PlayerMessage message) throws ExoPlaybackException {
+    try {
+      message.getTarget().handleMessage(message.getType(), message.getPayload());
     } finally {
-      synchronized (this) {
-        customMessagesProcessed++;
-        notifyAll();
+      message.markAsProcessed(/* isDelivered= */ true);
+    }
+  }
+
+  private void resolvePendingMessagePositions() {
+    for (int i = pendingMessages.size() - 1; i >= 0; i--) {
+      if (!resolvePendingMessagePosition(pendingMessages.get(i))) {
+        // Unable to resolve a new position for the message. Remove it.
+        pendingMessages.get(i).message.markAsProcessed(/* isDelivered= */ false);
+        pendingMessages.remove(i);
+      }
+    }
+    // Re-sort messages by playback order.
+    Collections.sort(pendingMessages);
+  }
+
+  private boolean resolvePendingMessagePosition(PendingMessageInfo pendingMessageInfo) {
+    if (pendingMessageInfo.resolvedPeriodUid == null) {
+      // Position is still unresolved. Try to find window in current timeline.
+      Pair<Integer, Long> periodPosition =
+          resolveSeekPosition(
+              new SeekPosition(
+                  pendingMessageInfo.message.getTimeline(),
+                  pendingMessageInfo.message.getWindowIndex(),
+                  C.msToUs(pendingMessageInfo.message.getPositionMs())),
+              /* trySubsequentPeriods= */ false);
+      if (periodPosition == null) {
+        return false;
       }
+      pendingMessageInfo.setResolvedPosition(
+          periodPosition.first,
+          periodPosition.second,
+          playbackInfo.timeline.getPeriod(periodPosition.first, period, true).uid);
+    } else {
+      // Position has been resolved for a previous timeline. Try to find the updated period index.
+      int index = playbackInfo.timeline.getIndexOfPeriod(pendingMessageInfo.resolvedPeriodUid);
+      if (index == C.INDEX_UNSET) {
+        return false;
+      }
+      pendingMessageInfo.resolvedPeriodIndex = index;
+    }
+    return true;
+  }
+
+  private void maybeTriggerPendingMessages(long oldPeriodPositionUs, long newPeriodPositionUs)
+      throws ExoPlaybackException {
+    if (pendingMessages.isEmpty() || playbackInfo.periodId.isAd()) {
+      return;
+    }
+    // If this is the first call from the start position, include oldPeriodPositionUs in potential
+    // trigger positions.
+    if (playbackInfo.startPositionUs == oldPeriodPositionUs) {
+      oldPeriodPositionUs--;
+    }
+    // Correct next index if necessary (e.g. after seeking, timeline changes, or new messages)
+    int currentPeriodIndex = playbackInfo.periodId.periodIndex;
+    PendingMessageInfo previousInfo =
+        nextPendingMessageIndex > 0 ? pendingMessages.get(nextPendingMessageIndex - 1) : null;
+    while (previousInfo != null
+        && (previousInfo.resolvedPeriodIndex > currentPeriodIndex
+            || (previousInfo.resolvedPeriodIndex == currentPeriodIndex
+                && previousInfo.resolvedPeriodTimeUs > oldPeriodPositionUs))) {
+      nextPendingMessageIndex--;
+      previousInfo =
+          nextPendingMessageIndex > 0 ? pendingMessages.get(nextPendingMessageIndex - 1) : null;
+    }
+    PendingMessageInfo nextInfo =
+        nextPendingMessageIndex < pendingMessages.size()
+            ? pendingMessages.get(nextPendingMessageIndex)
+            : null;
+    while (nextInfo != null
+        && nextInfo.resolvedPeriodUid != null
+        && (nextInfo.resolvedPeriodIndex < currentPeriodIndex
+            || (nextInfo.resolvedPeriodIndex == currentPeriodIndex
+                && nextInfo.resolvedPeriodTimeUs <= oldPeriodPositionUs))) {
+      nextPendingMessageIndex++;
+      nextInfo =
+          nextPendingMessageIndex < pendingMessages.size()
+              ? pendingMessages.get(nextPendingMessageIndex)
+              : null;
+    }
+    // Check if any message falls within the covered time span.
+    while (nextInfo != null
+        && nextInfo.resolvedPeriodUid != null
+        && nextInfo.resolvedPeriodIndex == currentPeriodIndex
+        && nextInfo.resolvedPeriodTimeUs > oldPeriodPositionUs
+        && nextInfo.resolvedPeriodTimeUs <= newPeriodPositionUs) {
+      sendMessageToTarget(nextInfo.message);
+      if (nextInfo.message.getDeleteAfterDelivery()) {
+        pendingMessages.remove(nextPendingMessageIndex);
+      } else {
+        nextPendingMessageIndex++;
+      }
+      nextInfo =
+          nextPendingMessageIndex < pendingMessages.size()
+              ? pendingMessages.get(nextPendingMessageIndex)
+              : null;
     }
   }
 
@@ -857,28 +967,27 @@ private void ensureStopped(Renderer renderer) throws ExoPlaybackException {
   }
 
   private void disableRenderer(Renderer renderer) throws ExoPlaybackException {
-    if (renderer == rendererMediaClockSource) {
-      rendererMediaClock = null;
-      rendererMediaClockSource = null;
-    }
+    mediaClock.onRendererDisabled(renderer);
     ensureStopped(renderer);
     renderer.disable();
   }
 
   private void reselectTracksInternal() throws ExoPlaybackException {
-    if (playingPeriodHolder == null) {
+    if (!queue.hasPlayingPeriod()) {
       // We don't have tracks yet, so we don't care.
       return;
     }
+    float playbackSpeed = mediaClock.getPlaybackParameters().speed;
     // Reselect tracks on each period in turn, until the selection changes.
-    MediaPeriodHolder periodHolder = playingPeriodHolder;
+    MediaPeriodHolder periodHolder = queue.getPlayingPeriod();
+    MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
     boolean selectionsChangedForReadPeriod = true;
     while (true) {
       if (periodHolder == null || !periodHolder.prepared) {
         // The reselection did not change any prepared periods.
         return;
       }
-      if (periodHolder.selectTracks()) {
+      if (periodHolder.selectTracks(playbackSpeed)) {
         // Selected tracks have changed for this period.
         break;
       }
@@ -891,20 +1000,19 @@ private void reselectTracksInternal() throws ExoPlaybackException {
 
     if (selectionsChangedForReadPeriod) {
       // Update streams and rebuffer for the new selection, recreating all streams if reading ahead.
-      boolean recreateStreams = readingPeriodHolder != playingPeriodHolder;
-      releasePeriodHoldersFrom(playingPeriodHolder.next);
-      playingPeriodHolder.next = null;
-      loadingPeriodHolder = playingPeriodHolder;
-      readingPeriodHolder = playingPeriodHolder;
+      MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
+      boolean recreateStreams = queue.removeAfter(playingPeriodHolder);
 
       boolean[] streamResetFlags = new boolean[renderers.length];
-      long periodPositionUs = playingPeriodHolder.updatePeriodTrackSelection(
-          playbackInfo.positionUs, recreateStreams, streamResetFlags);
-      if (state != Player.STATE_ENDED && periodPositionUs != playbackInfo.positionUs) {
+      long periodPositionUs =
+          playingPeriodHolder.applyTrackSelection(
+              playbackInfo.positionUs, recreateStreams, streamResetFlags);
+      updateLoadControlTrackSelection(playingPeriodHolder.trackSelectorResult);
+      if (playbackInfo.playbackState != Player.STATE_ENDED
+          && periodPositionUs != playbackInfo.positionUs) {
         playbackInfo = playbackInfo.fromNewPosition(playbackInfo.periodId, periodPositionUs,
             playbackInfo.contentPositionUs);
-        eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY, Player.DISCONTINUITY_REASON_INTERNAL,
-            0, playbackInfo).sendToTarget();
+        playbackInfoUpdate.setPositionDiscontinuity(Player.DISCONTINUITY_REASON_INTERNAL);
         resetRendererPosition(periodPositionUs);
       }
 
@@ -927,39 +1035,82 @@ private void reselectTracksInternal() throws ExoPlaybackException {
           }
         }
       }
-      eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.trackSelectorResult)
-          .sendToTarget();
+      playbackInfo =
+          playbackInfo.copyWithTrackSelectorResult(playingPeriodHolder.trackSelectorResult);
       enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
     } else {
       // Release and re-prepare/buffer periods after the one whose selection changed.
-      loadingPeriodHolder = periodHolder;
-      periodHolder = loadingPeriodHolder.next;
-      while (periodHolder != null) {
-        periodHolder.release();
-        periodHolder = periodHolder.next;
-      }
-      loadingPeriodHolder.next = null;
-      if (loadingPeriodHolder.prepared) {
-        long loadingPeriodPositionUs = Math.max(loadingPeriodHolder.info.startPositionUs,
-            loadingPeriodHolder.toPeriodTime(rendererPositionUs));
-        loadingPeriodHolder.updatePeriodTrackSelection(loadingPeriodPositionUs, false);
+      queue.removeAfter(periodHolder);
+      if (periodHolder.prepared) {
+        long loadingPeriodPositionUs =
+            Math.max(
+                periodHolder.info.startPositionUs, periodHolder.toPeriodTime(rendererPositionUs));
+        periodHolder.applyTrackSelection(loadingPeriodPositionUs, false);
+        updateLoadControlTrackSelection(periodHolder.trackSelectorResult);
       }
     }
-    if (state != Player.STATE_ENDED) {
+    if (playbackInfo.playbackState != Player.STATE_ENDED) {
       maybeContinueLoading();
       updatePlaybackPositions();
       handler.sendEmptyMessage(MSG_DO_SOME_WORK);
     }
   }
 
-  private boolean isTimelineReady(long playingPeriodDurationUs) {
+  private void updateLoadControlTrackSelection(TrackSelectorResult trackSelectorResult) {
+    loadControl.onTracksSelected(
+        renderers, trackSelectorResult.groups, trackSelectorResult.selections);
+  }
+
+  private void updateTrackSelectionPlaybackSpeed(float playbackSpeed) {
+    MediaPeriodHolder periodHolder = queue.getFrontPeriod();
+    while (periodHolder != null) {
+      if (periodHolder.trackSelectorResult != null) {
+        TrackSelection[] trackSelections = periodHolder.trackSelectorResult.selections.getAll();
+        for (TrackSelection trackSelection : trackSelections) {
+          if (trackSelection != null) {
+            trackSelection.onPlaybackSpeed(playbackSpeed);
+          }
+        }
+      }
+      periodHolder = periodHolder.next;
+    }
+  }
+
+  private boolean shouldTransitionToReadyState(boolean renderersReadyOrEnded) {
+    if (enabledRenderers.length == 0) {
+      // If there are no enabled renderers, determine whether we're ready based on the timeline.
+      return isTimelineReady();
+    }
+    if (!renderersReadyOrEnded) {
+      return false;
+    }
+    if (!playbackInfo.isLoading) {
+      // Renderers are ready and we're not loading. Transition to ready, since the alternative is
+      // getting stuck waiting for additional media that's not being loaded.
+      return true;
+    }
+    // Renderers are ready and we're loading. Ask the LoadControl whether to transition.
+    MediaPeriodHolder loadingHolder = queue.getLoadingPeriod();
+    long bufferedPositionUs = loadingHolder.getBufferedPositionUs(!loadingHolder.info.isFinal);
+    return bufferedPositionUs == C.TIME_END_OF_SOURCE
+        || loadControl.shouldStartPlayback(
+            bufferedPositionUs - loadingHolder.toPeriodTime(rendererPositionUs),
+            mediaClock.getPlaybackParameters().speed,
+            rebuffering);
+  }
+
+  private boolean isTimelineReady() {
+    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
+    long playingPeriodDurationUs = playingPeriodHolder.info.durationUs;
     return playingPeriodDurationUs == C.TIME_UNSET
         || playbackInfo.positionUs < playingPeriodDurationUs
         || (playingPeriodHolder.next != null
-        && (playingPeriodHolder.next.prepared || playingPeriodHolder.next.info.id.isAd()));
+            && (playingPeriodHolder.next.prepared || playingPeriodHolder.next.info.id.isAd()));
   }
 
   private void maybeThrowPeriodPrepareError() throws IOException {
+    MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
+    MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
     if (loadingPeriodHolder != null && !loadingPeriodHolder.prepared
         && (readingPeriodHolder == null || readingPeriodHolder.next == loadingPeriodHolder)) {
       for (Renderer renderer : enabledRenderers) {
@@ -981,57 +1132,62 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
     Timeline oldTimeline = playbackInfo.timeline;
     Timeline timeline = sourceRefreshInfo.timeline;
     Object manifest = sourceRefreshInfo.manifest;
-    mediaPeriodInfoSequence.setTimeline(timeline);
+    queue.setTimeline(timeline);
     playbackInfo = playbackInfo.copyWithTimeline(timeline, manifest);
+    resolvePendingMessagePositions();
 
-    if (oldTimeline == null) {
-      int processedPrepareAcks = pendingPrepareCount;
+    if (pendingPrepareCount > 0) {
+      playbackInfoUpdate.incrementPendingOperationAcks(pendingPrepareCount);
       pendingPrepareCount = 0;
-      if (pendingInitialSeekCount > 0) {
-        Pair<Integer, Long> periodPosition = resolveSeekPosition(pendingSeekPosition);
-        int processedInitialSeekCount = pendingInitialSeekCount;
-        pendingInitialSeekCount = 0;
-        pendingSeekPosition = null;
+      if (pendingInitialSeekPosition != null) {
+        Pair<Integer, Long> periodPosition =
+            resolveSeekPosition(pendingInitialSeekPosition, /* trySubsequentPeriods= */ true);
+        pendingInitialSeekPosition = null;
         if (periodPosition == null) {
           // The seek position was valid for the timeline that it was performed into, but the
           // timeline has changed and a suitable seek position could not be resolved in the new one.
-          handleSourceInfoRefreshEndedPlayback(processedPrepareAcks, processedInitialSeekCount);
+          handleSourceInfoRefreshEndedPlayback();
         } else {
           int periodIndex = periodPosition.first;
           long positionUs = periodPosition.second;
-          MediaPeriodId periodId =
-              mediaPeriodInfoSequence.resolvePeriodPositionForAds(periodIndex, positionUs);
-          playbackInfo = playbackInfo.fromNewPosition(periodId, periodId.isAd() ? 0 : positionUs,
-              positionUs);
-          notifySourceInfoRefresh(processedPrepareAcks, processedInitialSeekCount);
+          MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodIndex, positionUs);
+          playbackInfo =
+              playbackInfo.fromNewPosition(
+                  periodId, periodId.isAd() ? 0 : positionUs, /* contentPositionUs= */ positionUs);
         }
       } else if (playbackInfo.startPositionUs == C.TIME_UNSET) {
         if (timeline.isEmpty()) {
-          handleSourceInfoRefreshEndedPlayback(processedPrepareAcks, 0);
+          handleSourceInfoRefreshEndedPlayback();
         } else {
           Pair<Integer, Long> defaultPosition = getPeriodPosition(timeline,
               timeline.getFirstWindowIndex(shuffleModeEnabled), C.TIME_UNSET);
           int periodIndex = defaultPosition.first;
           long startPositionUs = defaultPosition.second;
-          MediaPeriodId periodId = mediaPeriodInfoSequence.resolvePeriodPositionForAds(periodIndex,
-              startPositionUs);
-          playbackInfo = playbackInfo.fromNewPosition(periodId,
-              periodId.isAd() ? 0 : startPositionUs, startPositionUs);
-          notifySourceInfoRefresh(processedPrepareAcks, 0);
+          MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodIndex, startPositionUs);
+          playbackInfo =
+              playbackInfo.fromNewPosition(
+                  periodId,
+                  periodId.isAd() ? 0 : startPositionUs,
+                  /* contentPositionUs= */ startPositionUs);
         }
-      } else {
-        notifySourceInfoRefresh(processedPrepareAcks, 0);
       }
       return;
     }
 
     int playingPeriodIndex = playbackInfo.periodId.periodIndex;
-    MediaPeriodHolder periodHolder = playingPeriodHolder != null ? playingPeriodHolder
-        : loadingPeriodHolder;
-    if (periodHolder == null && playingPeriodIndex >= oldTimeline.getPeriodCount()) {
-      notifySourceInfoRefresh();
+    long contentPositionUs = playbackInfo.contentPositionUs;
+    if (oldTimeline.isEmpty()) {
+      // If the old timeline is empty, the period queue is also empty.
+      if (!timeline.isEmpty()) {
+        MediaPeriodId periodId =
+            queue.resolveMediaPeriodIdForAds(playingPeriodIndex, contentPositionUs);
+        playbackInfo =
+            playbackInfo.fromNewPosition(
+                periodId, periodId.isAd() ? 0 : contentPositionUs, contentPositionUs);
+      }
       return;
     }
+    MediaPeriodHolder periodHolder = queue.getFrontPeriod();
     Object playingPeriodUid = periodHolder == null
         ? oldTimeline.getPeriod(playingPeriodIndex, period, true).uid : periodHolder.uid;
     int periodIndex = timeline.getIndexOfPeriod(playingPeriodUid);
@@ -1048,7 +1204,8 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       Pair<Integer, Long> defaultPosition = getPeriodPosition(timeline,
           timeline.getPeriod(newPeriodIndex, period).windowIndex, C.TIME_UNSET);
       newPeriodIndex = defaultPosition.first;
-      long newPositionUs = defaultPosition.second;
+      contentPositionUs = defaultPosition.second;
+      MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(newPeriodIndex, contentPositionUs);
       timeline.getPeriod(newPeriodIndex, period, true);
       if (periodHolder != null) {
         // Clear the index of each holder that doesn't contain the default position. If a holder
@@ -1058,18 +1215,15 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
         while (periodHolder.next != null) {
           periodHolder = periodHolder.next;
           if (periodHolder.uid.equals(newPeriodUid)) {
-            periodHolder.info = mediaPeriodInfoSequence.getUpdatedMediaPeriodInfo(periodHolder.info,
-                newPeriodIndex);
+            periodHolder.info = queue.getUpdatedMediaPeriodInfo(periodHolder.info, newPeriodIndex);
           } else {
             periodHolder.info = periodHolder.info.copyWithPeriodIndex(C.INDEX_UNSET);
           }
         }
       }
       // Actually do the seek.
-      MediaPeriodId periodId = new MediaPeriodId(newPeriodIndex);
-      newPositionUs = seekToPeriodPosition(periodId, newPositionUs);
-      playbackInfo = playbackInfo.fromNewPosition(periodId, newPositionUs, C.TIME_UNSET);
-      notifySourceInfoRefresh();
+      long seekPositionUs = seekToPeriodPosition(periodId, periodId.isAd() ? 0 : contentPositionUs);
+      playbackInfo = playbackInfo.fromNewPosition(periodId, seekPositionUs, contentPositionUs);
       return;
     }
 
@@ -1078,104 +1232,28 @@ private void handleSourceInfoRefreshed(MediaSourceRefreshInfo sourceRefreshInfo)
       playbackInfo = playbackInfo.copyWithPeriodIndex(periodIndex);
     }
 
-    if (playbackInfo.periodId.isAd()) {
-      // Check that the playing ad hasn't been marked as played. If it has, skip forward.
-      MediaPeriodId periodId = mediaPeriodInfoSequence.resolvePeriodPositionForAds(periodIndex,
-          playbackInfo.contentPositionUs);
-      if (!periodId.isAd() || periodId.adIndexInAdGroup != playbackInfo.periodId.adIndexInAdGroup) {
-        long newPositionUs = seekToPeriodPosition(periodId, playbackInfo.contentPositionUs);
-        long contentPositionUs = periodId.isAd() ? playbackInfo.contentPositionUs : C.TIME_UNSET;
-        playbackInfo = playbackInfo.fromNewPosition(periodId, newPositionUs, contentPositionUs);
-        notifySourceInfoRefresh();
+    MediaPeriodId playingPeriodId = playbackInfo.periodId;
+    if (playingPeriodId.isAd()) {
+      MediaPeriodId periodId = queue.resolveMediaPeriodIdForAds(periodIndex, contentPositionUs);
+      if (!periodId.equals(playingPeriodId)) {
+        // The previously playing ad should no longer be played, so skip it.
+        long seekPositionUs =
+            seekToPeriodPosition(periodId, periodId.isAd() ? 0 : contentPositionUs);
+        playbackInfo = playbackInfo.fromNewPosition(periodId, seekPositionUs, contentPositionUs);
         return;
       }
     }
 
-    if (periodHolder == null) {
-      // We don't have any period holders, so we're done.
-      notifySourceInfoRefresh();
-      return;
-    }
-
-    // Update the holder indices. If we find a subsequent holder that's inconsistent with the new
-    // timeline then take appropriate action.
-    periodHolder = updatePeriodInfo(periodHolder, periodIndex);
-    while (periodHolder.next != null) {
-      MediaPeriodHolder previousPeriodHolder = periodHolder;
-      periodHolder = periodHolder.next;
-      periodIndex = timeline.getNextPeriodIndex(periodIndex, period, window, repeatMode,
-          shuffleModeEnabled);
-      if (periodIndex != C.INDEX_UNSET
-          && periodHolder.uid.equals(timeline.getPeriod(periodIndex, period, true).uid)) {
-        // The holder is consistent with the new timeline. Update its index and continue.
-        periodHolder = updatePeriodInfo(periodHolder, periodIndex);
-      } else {
-        // The holder is inconsistent with the new timeline.
-        boolean seenReadingPeriodHolder =
-            readingPeriodHolder != null && readingPeriodHolder.index < periodHolder.index;
-        if (!seenReadingPeriodHolder) {
-          // Renderers may have read from a period that's been removed. Seek back to the current
-          // position of the playing period to make sure none of the removed period is played.
-          long newPositionUs =
-              seekToPeriodPosition(playingPeriodHolder.info.id, playbackInfo.positionUs);
-          playbackInfo = playbackInfo.fromNewPosition(playingPeriodHolder.info.id, newPositionUs,
-              playbackInfo.contentPositionUs);
-        } else {
-          // Update the loading period to be the last period that's still valid, and release all
-          // subsequent periods.
-          loadingPeriodHolder = previousPeriodHolder;
-          loadingPeriodHolder.next = null;
-          // Release the rest of the timeline.
-          releasePeriodHoldersFrom(periodHolder);
-        }
-        break;
-      }
-    }
-
-    notifySourceInfoRefresh();
-  }
-
-  private MediaPeriodHolder updatePeriodInfo(MediaPeriodHolder periodHolder, int periodIndex) {
-    while (true) {
-      periodHolder.info =
-          mediaPeriodInfoSequence.getUpdatedMediaPeriodInfo(periodHolder.info, periodIndex);
-      if (periodHolder.info.isLastInTimelinePeriod || periodHolder.next == null) {
-        return periodHolder;
-      }
-      periodHolder = periodHolder.next;
+    if (!queue.updateQueuedPeriods(playingPeriodId, rendererPositionUs)) {
+      seekToCurrentPosition(/* sendDiscontinuity= */ false);
     }
   }
 
   private void handleSourceInfoRefreshEndedPlayback() {
-    handleSourceInfoRefreshEndedPlayback(0, 0);
-  }
-
-  private void handleSourceInfoRefreshEndedPlayback(int prepareAcks, int seekAcks) {
-    Timeline timeline = playbackInfo.timeline;
-    int firstPeriodIndex = timeline.isEmpty() ? 0 : timeline.getWindow(
-        timeline.getFirstWindowIndex(shuffleModeEnabled), window).firstPeriodIndex;
-    // Set the internal position to (firstPeriodIndex,TIME_UNSET) so that a subsequent seek to
-    // (firstPeriodIndex,0) isn't ignored.
-    playbackInfo = playbackInfo.fromNewPosition(firstPeriodIndex, C.TIME_UNSET, C.TIME_UNSET);
     setState(Player.STATE_ENDED);
-    // Set the playback position to (firstPeriodIndex,0) for notifying the eventHandler.
-    notifySourceInfoRefresh(prepareAcks, seekAcks,
-        playbackInfo.fromNewPosition(firstPeriodIndex, 0, C.TIME_UNSET));
     // Reset, but retain the source so that it can still be used should a seek occur.
-    resetInternal(false);
-  }
-
-  private void notifySourceInfoRefresh() {
-    notifySourceInfoRefresh(0, 0);
-  }
-
-  private void notifySourceInfoRefresh(int prepareAcks, int seekAcks) {
-    notifySourceInfoRefresh(prepareAcks, seekAcks, playbackInfo);
-  }
-
-  private void notifySourceInfoRefresh(int prepareAcks, int seekAcks, PlaybackInfo playbackInfo) {
-    eventHandler.obtainMessage(MSG_SOURCE_INFO_REFRESHED, prepareAcks, seekAcks, playbackInfo)
-        .sendToTarget();
+    resetInternal(
+        /* releaseMediaSource= */ false, /* resetPosition= */ true, /* resetState= */ false);
   }
 
   /**
@@ -1188,8 +1266,8 @@ private void notifySourceInfoRefresh(int prepareAcks, int seekAcks, PlaybackInfo
    * @return The index in the new timeline of the first subsequent period, or {@link C#INDEX_UNSET}
    *     if no such period was found.
    */
-  private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
-      Timeline newTimeline) {
+  private int resolveSubsequentPeriod(
+      int oldPeriodIndex, Timeline oldTimeline, Timeline newTimeline) {
     int newPeriodIndex = C.INDEX_UNSET;
     int maxIterations = oldTimeline.getPeriodCount();
     for (int i = 0; i < maxIterations && newPeriodIndex == C.INDEX_UNSET; i++) {
@@ -1210,15 +1288,22 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
    * internal timeline.
    *
    * @param seekPosition The position to resolve.
+   * @param trySubsequentPeriods Whether the position can be resolved to a subsequent matching
+   *     period if the original period is no longer available.
    * @return The resolved position, or null if resolution was not successful.
    * @throws IllegalSeekPositionException If the window index of the seek position is outside the
    *     bounds of the timeline.
    */
-  private Pair<Integer, Long> resolveSeekPosition(SeekPosition seekPosition) {
+  private Pair<Integer, Long> resolveSeekPosition(
+      SeekPosition seekPosition, boolean trySubsequentPeriods) {
     Timeline timeline = playbackInfo.timeline;
     Timeline seekTimeline = seekPosition.timeline;
+    if (timeline.isEmpty()) {
+      // We don't have a valid timeline yet, so we can't resolve the position.
+      return null;
+    }
     if (seekTimeline.isEmpty()) {
-      // The application performed a blind seek without a non-empty timeline (most likely based on
+      // The application performed a blind seek with an empty timeline (most likely based on
       // knowledge of what the future timeline will be). Use the internal timeline.
       seekTimeline = timeline;
     }
@@ -1243,12 +1328,14 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
       // We successfully located the period in the internal timeline.
       return Pair.create(periodIndex, periodPosition.second);
     }
-    // Try and find a subsequent period from the seek timeline in the internal timeline.
-    periodIndex = resolveSubsequentPeriod(periodPosition.first, seekTimeline, timeline);
-    if (periodIndex != C.INDEX_UNSET) {
-      // We found one. Map the SeekPosition onto the corresponding default position.
-      return getPeriodPosition(timeline, timeline.getPeriod(periodIndex, period).windowIndex,
-          C.TIME_UNSET);
+    if (trySubsequentPeriods) {
+      // Try and find a subsequent period from the seek timeline in the internal timeline.
+      periodIndex = resolveSubsequentPeriod(periodPosition.first, seekTimeline, timeline);
+      if (periodIndex != C.INDEX_UNSET) {
+        // We found one. Map the SeekPosition onto the corresponding default position.
+        return getPeriodPosition(
+            timeline, timeline.getPeriod(periodIndex, period).windowIndex, C.TIME_UNSET);
+      }
     }
     // We didn't find one. Give up.
     return null;
@@ -1258,13 +1345,17 @@ private int resolveSubsequentPeriod(int oldPeriodIndex, Timeline oldTimeline,
    * Calls {@link Timeline#getPeriodPosition(Timeline.Window, Timeline.Period, int, long)} using the
    * current timeline.
    */
-  private Pair<Integer, Long> getPeriodPosition(Timeline timeline, int windowIndex,
-      long windowPositionUs) {
+  private Pair<Integer, Long> getPeriodPosition(
+      Timeline timeline, int windowIndex, long windowPositionUs) {
     return timeline.getPeriodPosition(window, period, windowIndex, windowPositionUs);
   }
 
   private void updatePeriods() throws ExoPlaybackException, IOException {
-    if (playbackInfo.timeline == null) {
+    if (mediaSource == null) {
+      // The player has no media source yet.
+      return;
+    }
+    if (pendingPrepareCount > 0) {
       // We're waiting to get information about periods.
       mediaSource.maybeThrowSourceInfoRefreshError();
       return;
@@ -1272,29 +1363,42 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
 
     // Update the loading period if required.
     maybeUpdateLoadingPeriod();
+    MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
     if (loadingPeriodHolder == null || loadingPeriodHolder.isFullyBuffered()) {
       setIsLoading(false);
-    } else if (loadingPeriodHolder != null && !isLoading) {
+    } else if (!playbackInfo.isLoading) {
       maybeContinueLoading();
     }
 
-    if (playingPeriodHolder == null) {
+    if (!queue.hasPlayingPeriod()) {
       // We're waiting for the first period to be prepared.
       return;
     }
 
     // Advance the playing period if necessary.
+    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
+    MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
+    boolean advancedPlayingPeriod = false;
     while (playWhenReady && playingPeriodHolder != readingPeriodHolder
         && rendererPositionUs >= playingPeriodHolder.next.rendererPositionOffsetUs) {
       // All enabled renderers' streams have been read to the end, and the playback position reached
       // the end of the playing period, so advance playback to the next period.
-      playingPeriodHolder.release();
-      setPlayingPeriodHolder(playingPeriodHolder.next);
+      if (advancedPlayingPeriod) {
+        // If we advance more than one period at a time, notify listeners after each update.
+        maybeNotifyPlaybackInfoChanged();
+      }
+      int discontinuityReason =
+          playingPeriodHolder.info.isLastInTimelinePeriod
+              ? Player.DISCONTINUITY_REASON_PERIOD_TRANSITION
+              : Player.DISCONTINUITY_REASON_AD_INSERTION;
+      MediaPeriodHolder oldPlayingPeriodHolder = playingPeriodHolder;
+      playingPeriodHolder = queue.advancePlayingPeriod();
+      updatePlayingPeriodRenderers(oldPlayingPeriodHolder);
       playbackInfo = playbackInfo.fromNewPosition(playingPeriodHolder.info.id,
           playingPeriodHolder.info.startPositionUs, playingPeriodHolder.info.contentPositionUs);
+      playbackInfoUpdate.setPositionDiscontinuity(discontinuityReason);
       updatePlaybackPositions();
-      eventHandler.obtainMessage(MSG_POSITION_DISCONTINUITY,
-          Player.DISCONTINUITY_REASON_PERIOD_TRANSITION, 0, playbackInfo).sendToTarget();
+      advancedPlayingPeriod = true;
     }
 
     if (readingPeriodHolder.info.isFinal) {
@@ -1328,7 +1432,7 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
     }
 
     TrackSelectorResult oldTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
-    readingPeriodHolder = readingPeriodHolder.next;
+    readingPeriodHolder = queue.advanceReadingPeriod();
     TrackSelectorResult newTrackSelectorResult = readingPeriodHolder.trackSelectorResult;
 
     boolean initialDiscontinuity =
@@ -1371,107 +1475,98 @@ private void updatePeriods() throws ExoPlaybackException, IOException {
   }
 
   private void maybeUpdateLoadingPeriod() throws IOException {
-    MediaPeriodInfo info;
-    if (loadingPeriodHolder == null) {
-      info = mediaPeriodInfoSequence.getFirstMediaPeriodInfo(playbackInfo);
-    } else {
-      if (loadingPeriodHolder.info.isFinal || !loadingPeriodHolder.isFullyBuffered()
-          || loadingPeriodHolder.info.durationUs == C.TIME_UNSET) {
-        return;
-      }
-      if (playingPeriodHolder != null) {
-        int bufferAheadPeriodCount = loadingPeriodHolder.index - playingPeriodHolder.index;
-        if (bufferAheadPeriodCount == MAXIMUM_BUFFER_AHEAD_PERIODS) {
-          // We are already buffering the maximum number of periods ahead.
-          return;
-        }
+    queue.reevaluateBuffer(rendererPositionUs);
+    if (queue.shouldLoadNextMediaPeriod()) {
+      MediaPeriodInfo info = queue.getNextMediaPeriodInfo(rendererPositionUs, playbackInfo);
+      if (info == null) {
+        mediaSource.maybeThrowSourceInfoRefreshError();
+      } else {
+        Object uid = playbackInfo.timeline.getPeriod(info.id.periodIndex, period, true).uid;
+        MediaPeriod mediaPeriod =
+            queue.enqueueNextMediaPeriod(
+                rendererCapabilities,
+                RENDERER_TIMESTAMP_OFFSET_US,
+                trackSelector,
+                loadControl.getAllocator(),
+                mediaSource,
+                uid,
+                info);
+        mediaPeriod.prepare(this, info.startPositionUs);
+        setIsLoading(true);
       }
-      info = mediaPeriodInfoSequence.getNextMediaPeriodInfo(loadingPeriodHolder.info,
-          loadingPeriodHolder.getRendererOffset(), rendererPositionUs);
-    }
-    if (info == null) {
-      mediaSource.maybeThrowSourceInfoRefreshError();
-      return;
-    }
-
-    long rendererPositionOffsetUs = loadingPeriodHolder == null
-        ? RENDERER_TIMESTAMP_OFFSET_US
-        : (loadingPeriodHolder.getRendererOffset() + loadingPeriodHolder.info.durationUs);
-    int holderIndex = loadingPeriodHolder == null ? 0 : loadingPeriodHolder.index + 1;
-    Object uid = playbackInfo.timeline.getPeriod(info.id.periodIndex, period, true).uid;
-    MediaPeriodHolder newPeriodHolder = new MediaPeriodHolder(renderers, rendererCapabilities,
-        rendererPositionOffsetUs, trackSelector, loadControl, mediaSource, uid, holderIndex, info);
-    if (loadingPeriodHolder != null) {
-      loadingPeriodHolder.next = newPeriodHolder;
     }
-    loadingPeriodHolder = newPeriodHolder;
-    loadingPeriodHolder.mediaPeriod.prepare(this, info.startPositionUs);
-    setIsLoading(true);
   }
 
-  private void handlePeriodPrepared(MediaPeriod period) throws ExoPlaybackException {
-    if (loadingPeriodHolder == null || loadingPeriodHolder.mediaPeriod != period) {
+  private void handlePeriodPrepared(MediaPeriod mediaPeriod) throws ExoPlaybackException {
+    if (!queue.isLoading(mediaPeriod)) {
       // Stale event.
       return;
     }
-    loadingPeriodHolder.handlePrepared();
-    if (playingPeriodHolder == null) {
+    TrackSelectorResult trackSelectorResult =
+        queue.handleLoadingPeriodPrepared(mediaClock.getPlaybackParameters().speed);
+    updateLoadControlTrackSelection(trackSelectorResult);
+    if (!queue.hasPlayingPeriod()) {
       // This is the first prepared period, so start playing it.
-      readingPeriodHolder = loadingPeriodHolder;
-      resetRendererPosition(readingPeriodHolder.info.startPositionUs);
-      setPlayingPeriodHolder(readingPeriodHolder);
+      MediaPeriodHolder playingPeriodHolder = queue.advancePlayingPeriod();
+      resetRendererPosition(playingPeriodHolder.info.startPositionUs);
+      updatePlayingPeriodRenderers(/* oldPlayingPeriodHolder= */ null);
     }
     maybeContinueLoading();
   }
 
-  private void handleContinueLoadingRequested(MediaPeriod period) {
-    if (loadingPeriodHolder == null || loadingPeriodHolder.mediaPeriod != period) {
+  private void handleContinueLoadingRequested(MediaPeriod mediaPeriod) {
+    if (!queue.isLoading(mediaPeriod)) {
       // Stale event.
       return;
     }
+    queue.reevaluateBuffer(rendererPositionUs);
     maybeContinueLoading();
   }
 
   private void maybeContinueLoading() {
-    boolean continueLoading = loadingPeriodHolder.shouldContinueLoading(rendererPositionUs);
+    MediaPeriodHolder loadingPeriodHolder = queue.getLoadingPeriod();
+    long nextLoadPositionUs = loadingPeriodHolder.getNextLoadPositionUs();
+    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
+      setIsLoading(false);
+      return;
+    }
+    long bufferedDurationUs =
+        nextLoadPositionUs - loadingPeriodHolder.toPeriodTime(rendererPositionUs);
+    boolean continueLoading =
+        loadControl.shouldContinueLoading(
+            bufferedDurationUs, mediaClock.getPlaybackParameters().speed);
     setIsLoading(continueLoading);
     if (continueLoading) {
       loadingPeriodHolder.continueLoading(rendererPositionUs);
     }
   }
 
-  private void releasePeriodHoldersFrom(MediaPeriodHolder periodHolder) {
-    while (periodHolder != null) {
-      periodHolder.release();
-      periodHolder = periodHolder.next;
-    }
-  }
-
-  private void setPlayingPeriodHolder(MediaPeriodHolder periodHolder) throws ExoPlaybackException {
-    if (playingPeriodHolder == periodHolder) {
+  private void updatePlayingPeriodRenderers(@Nullable MediaPeriodHolder oldPlayingPeriodHolder)
+      throws ExoPlaybackException {
+    MediaPeriodHolder newPlayingPeriodHolder = queue.getPlayingPeriod();
+    if (newPlayingPeriodHolder == null || oldPlayingPeriodHolder == newPlayingPeriodHolder) {
       return;
     }
-
     int enabledRendererCount = 0;
     boolean[] rendererWasEnabledFlags = new boolean[renderers.length];
     for (int i = 0; i < renderers.length; i++) {
       Renderer renderer = renderers[i];
       rendererWasEnabledFlags[i] = renderer.getState() != Renderer.STATE_DISABLED;
-      if (periodHolder.trackSelectorResult.renderersEnabled[i]) {
+      if (newPlayingPeriodHolder.trackSelectorResult.renderersEnabled[i]) {
         enabledRendererCount++;
       }
-      if (rendererWasEnabledFlags[i] && (!periodHolder.trackSelectorResult.renderersEnabled[i]
-          || (renderer.isCurrentStreamFinal()
-          && renderer.getStream() == playingPeriodHolder.sampleStreams[i]))) {
+      if (rendererWasEnabledFlags[i]
+          && (!newPlayingPeriodHolder.trackSelectorResult.renderersEnabled[i]
+              || (renderer.isCurrentStreamFinal()
+                  && renderer.getStream() == oldPlayingPeriodHolder.sampleStreams[i]))) {
         // The renderer should be disabled before playing the next period, either because it's not
         // needed to play the next period, or because we need to re-enable it as its current stream
         // is final and it's not reading ahead.
         disableRenderer(renderer);
       }
     }
-
-    playingPeriodHolder = periodHolder;
-    eventHandler.obtainMessage(MSG_TRACKS_CHANGED, periodHolder.trackSelectorResult).sendToTarget();
+    playbackInfo =
+        playbackInfo.copyWithTrackSelectorResult(newPlayingPeriodHolder.trackSelectorResult);
     enableRenderers(rendererWasEnabledFlags, enabledRendererCount);
   }
 
@@ -1479,6 +1574,7 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int totalEnabled
       throws ExoPlaybackException {
     enabledRenderers = new Renderer[totalEnabledRendererCount];
     int enabledRendererCount = 0;
+    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
     for (int i = 0; i < renderers.length; i++) {
       if (playingPeriodHolder.trackSelectorResult.renderersEnabled[i]) {
         enableRenderer(i, rendererWasEnabledFlags[i], enabledRendererCount++);
@@ -1486,8 +1582,10 @@ private void enableRenderers(boolean[] rendererWasEnabledFlags, int totalEnabled
     }
   }
 
-  private void enableRenderer(int rendererIndex, boolean wasRendererEnabled,
-      int enabledRendererIndex) throws ExoPlaybackException {
+  private void enableRenderer(
+      int rendererIndex, boolean wasRendererEnabled, int enabledRendererIndex)
+      throws ExoPlaybackException {
+    MediaPeriodHolder playingPeriodHolder = queue.getPlayingPeriod();
     Renderer renderer = renderers[rendererIndex];
     enabledRenderers[enabledRendererIndex] = renderer;
     if (renderer.getState() == Renderer.STATE_DISABLED) {
@@ -1497,23 +1595,14 @@ private void enableRenderer(int rendererIndex, boolean wasRendererEnabled,
           rendererIndex);
       Format[] formats = getFormats(newSelection);
       // The renderer needs enabling with its new track selection.
-      boolean playing = playWhenReady && state == Player.STATE_READY;
+      boolean playing = playWhenReady && playbackInfo.playbackState == Player.STATE_READY;
       // Consider as joining only if the renderer was previously disabled.
       boolean joining = !wasRendererEnabled && playing;
       // Enable the renderer.
       renderer.enable(rendererConfiguration, formats,
           playingPeriodHolder.sampleStreams[rendererIndex], rendererPositionUs,
           joining, playingPeriodHolder.getRendererOffset());
-      MediaClock mediaClock = renderer.getMediaClock();
-      if (mediaClock != null) {
-        if (rendererMediaClock != null) {
-          throw ExoPlaybackException.createForUnexpected(
-              new IllegalStateException("Multiple renderer media clocks enabled."));
-        }
-        rendererMediaClock = mediaClock;
-        rendererMediaClockSource = renderer;
-        rendererMediaClock.setPlaybackParameters(playbackParameters);
-      }
+      mediaClock.onRendererEnabled(renderer);
       // Start the renderer if playing.
       if (playing) {
         renderer.start();
@@ -1522,6 +1611,7 @@ private void enableRenderer(int rendererIndex, boolean wasRendererEnabled,
   }
 
   private boolean rendererWaitingForNextStream(Renderer renderer) {
+    MediaPeriodHolder readingPeriodHolder = queue.getReadingPeriod();
     return readingPeriodHolder.next != null && readingPeriodHolder.next.prepared
         && renderer.hasReadStreamToEnd();
   }
@@ -1537,212 +1627,54 @@ private boolean rendererWaitingForNextStream(Renderer renderer) {
     return formats;
   }
 
-  /**
-   * Holds a {@link MediaPeriod} with information required to play it as part of a timeline.
-   */
-  private static final class MediaPeriodHolder {
-
-    public final MediaPeriod mediaPeriod;
-    public final Object uid;
-    public final int index;
-    public final SampleStream[] sampleStreams;
-    public final boolean[] mayRetainStreamFlags;
-    public final long rendererPositionOffsetUs;
-
-    public MediaPeriodInfo info;
-    public boolean prepared;
-    public boolean hasEnabledTracks;
-    public MediaPeriodHolder next;
-    public TrackSelectorResult trackSelectorResult;
-
-    private final Renderer[] renderers;
-    private final RendererCapabilities[] rendererCapabilities;
-    private final TrackSelector trackSelector;
-    private final LoadControl loadControl;
-    private final MediaSource mediaSource;
-
-    private TrackSelectorResult periodTrackSelectorResult;
-
-    public MediaPeriodHolder(Renderer[] renderers, RendererCapabilities[] rendererCapabilities,
-        long rendererPositionOffsetUs, TrackSelector trackSelector, LoadControl loadControl,
-        MediaSource mediaSource, Object periodUid, int index, MediaPeriodInfo info) {
-      this.renderers = renderers;
-      this.rendererCapabilities = rendererCapabilities;
-      this.rendererPositionOffsetUs = rendererPositionOffsetUs;
-      this.trackSelector = trackSelector;
-      this.loadControl = loadControl;
-      this.mediaSource = mediaSource;
-      this.uid = Assertions.checkNotNull(periodUid);
-      this.index = index;
-      this.info = info;
-      sampleStreams = new SampleStream[renderers.length];
-      mayRetainStreamFlags = new boolean[renderers.length];
-      MediaPeriod mediaPeriod = mediaSource.createPeriod(info.id, loadControl.getAllocator());
-      if (info.endPositionUs != C.TIME_END_OF_SOURCE) {
-        ClippingMediaPeriod clippingMediaPeriod = new ClippingMediaPeriod(mediaPeriod, true);
-        clippingMediaPeriod.setClipping(0, info.endPositionUs);
-        mediaPeriod = clippingMediaPeriod;
-      }
-      this.mediaPeriod = mediaPeriod;
-    }
-
-    public long toRendererTime(long periodTimeUs) {
-      return periodTimeUs + getRendererOffset();
-    }
-
-    public long toPeriodTime(long rendererTimeUs) {
-      return rendererTimeUs - getRendererOffset();
-    }
-
-    public long getRendererOffset() {
-      return index == 0 ? rendererPositionOffsetUs
-          : (rendererPositionOffsetUs - info.startPositionUs);
-    }
-
-    public boolean isFullyBuffered() {
-      return prepared
-          && (!hasEnabledTracks || mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE);
-    }
+  private static final class SeekPosition {
 
-    public boolean haveSufficientBuffer(boolean rebuffering, long rendererPositionUs) {
-      long bufferedPositionUs = !prepared ? info.startPositionUs
-          : mediaPeriod.getBufferedPositionUs();
-      if (bufferedPositionUs == C.TIME_END_OF_SOURCE) {
-        if (info.isFinal) {
-          return true;
-        }
-        bufferedPositionUs = info.durationUs;
-      }
-      return loadControl.shouldStartPlayback(bufferedPositionUs - toPeriodTime(rendererPositionUs),
-          rebuffering);
-    }
+    public final Timeline timeline;
+    public final int windowIndex;
+    public final long windowPositionUs;
 
-    public void handlePrepared() throws ExoPlaybackException {
-      prepared = true;
-      selectTracks();
-      long newStartPositionUs = updatePeriodTrackSelection(info.startPositionUs, false);
-      info = info.copyWithStartPositionUs(newStartPositionUs);
+    public SeekPosition(Timeline timeline, int windowIndex, long windowPositionUs) {
+      this.timeline = timeline;
+      this.windowIndex = windowIndex;
+      this.windowPositionUs = windowPositionUs;
     }
+  }
 
-    public boolean shouldContinueLoading(long rendererPositionUs) {
-      long nextLoadPositionUs = !prepared ? 0 : mediaPeriod.getNextLoadPositionUs();
-      if (nextLoadPositionUs == C.TIME_END_OF_SOURCE) {
-        return false;
-      } else {
-        long loadingPeriodPositionUs = toPeriodTime(rendererPositionUs);
-        long bufferedDurationUs = nextLoadPositionUs - loadingPeriodPositionUs;
-        return loadControl.shouldContinueLoading(bufferedDurationUs);
-      }
-    }
+  private static final class PendingMessageInfo implements Comparable<PendingMessageInfo> {
 
-    public void continueLoading(long rendererPositionUs) {
-      long loadingPeriodPositionUs = toPeriodTime(rendererPositionUs);
-      mediaPeriod.continueLoading(loadingPeriodPositionUs);
-    }
+    public final PlayerMessage message;
 
-    public boolean selectTracks() throws ExoPlaybackException {
-      TrackSelectorResult selectorResult = trackSelector.selectTracks(rendererCapabilities,
-          mediaPeriod.getTrackGroups());
-      if (selectorResult.isEquivalent(periodTrackSelectorResult)) {
-        return false;
-      }
-      trackSelectorResult = selectorResult;
-      return true;
-    }
+    public int resolvedPeriodIndex;
+    public long resolvedPeriodTimeUs;
+    public @Nullable Object resolvedPeriodUid;
 
-    public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStreams) {
-      return updatePeriodTrackSelection(positionUs, forceRecreateStreams,
-          new boolean[renderers.length]);
+    public PendingMessageInfo(PlayerMessage message) {
+      this.message = message;
     }
 
-    public long updatePeriodTrackSelection(long positionUs, boolean forceRecreateStreams,
-        boolean[] streamResetFlags) {
-      TrackSelectionArray trackSelections = trackSelectorResult.selections;
-      for (int i = 0; i < trackSelections.length; i++) {
-        mayRetainStreamFlags[i] = !forceRecreateStreams
-            && trackSelectorResult.isEquivalent(periodTrackSelectorResult, i);
-      }
-
-      // Undo the effect of previous call to associate no-sample renderers with empty tracks
-      // so the mediaPeriod receives back whatever it sent us before.
-      disassociateNoSampleRenderersWithEmptySampleStream(sampleStreams);
-      // Disable streams on the period and get new streams for updated/newly-enabled tracks.
-      positionUs = mediaPeriod.selectTracks(trackSelections.getAll(), mayRetainStreamFlags,
-          sampleStreams, streamResetFlags, positionUs);
-      associateNoSampleRenderersWithEmptySampleStream(sampleStreams);
-      periodTrackSelectorResult = trackSelectorResult;
-
-      // Update whether we have enabled tracks and sanity check the expected streams are non-null.
-      hasEnabledTracks = false;
-      for (int i = 0; i < sampleStreams.length; i++) {
-        if (sampleStreams[i] != null) {
-          Assertions.checkState(trackSelectorResult.renderersEnabled[i]);
-          // hasEnabledTracks should be true only when non-empty streams exists.
-          if (rendererCapabilities[i].getTrackType() != C.TRACK_TYPE_NONE) {
-            hasEnabledTracks = true;
-          }
-        } else {
-          Assertions.checkState(trackSelections.get(i) == null);
-        }
-      }
-
-      // The track selection has changed.
-      loadControl.onTracksSelected(renderers, trackSelectorResult.groups, trackSelections);
-      return positionUs;
+    public void setResolvedPosition(int periodIndex, long periodTimeUs, Object periodUid) {
+      resolvedPeriodIndex = periodIndex;
+      resolvedPeriodTimeUs = periodTimeUs;
+      resolvedPeriodUid = periodUid;
     }
 
-    public void release() {
-      try {
-        if (info.endPositionUs != C.TIME_END_OF_SOURCE) {
-          mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
-        } else {
-          mediaSource.releasePeriod(mediaPeriod);
-        }
-      } catch (RuntimeException e) {
-        // There's nothing we can do.
-        Log.e(TAG, "Period release failed.", e);
+    @Override
+    public int compareTo(@NonNull PendingMessageInfo other) {
+      if ((resolvedPeriodUid == null) != (other.resolvedPeriodUid == null)) {
+        // PendingMessageInfos with a resolved period position are always smaller.
+        return resolvedPeriodUid != null ? -1 : 1;
       }
-    }
-
-    /**
-     * For each renderer of type {@link C#TRACK_TYPE_NONE}, we will remove the dummy
-     * {@link EmptySampleStream} that was associated with it.
-     */
-    private void disassociateNoSampleRenderersWithEmptySampleStream(SampleStream[] sampleStreams) {
-      for (int i = 0; i < rendererCapabilities.length; i++) {
-        if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE) {
-          sampleStreams[i] = null;
-        }
+      if (resolvedPeriodUid == null) {
+        // Don't sort message with unresolved positions.
+        return 0;
       }
-    }
-
-    /**
-     * For each renderer of type {@link C#TRACK_TYPE_NONE} that was enabled, we will
-     * associate it with a dummy {@link EmptySampleStream}.
-     */
-    private void associateNoSampleRenderersWithEmptySampleStream(SampleStream[] sampleStreams) {
-      for (int i = 0; i < rendererCapabilities.length; i++) {
-        if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE
-            && trackSelectorResult.renderersEnabled[i]) {
-          sampleStreams[i] = new EmptySampleStream();
-        }
+      // Sort resolved media times by period index and then by period position.
+      int comparePeriodIndex = resolvedPeriodIndex - other.resolvedPeriodIndex;
+      if (comparePeriodIndex != 0) {
+        return comparePeriodIndex;
       }
+      return Util.compareLong(resolvedPeriodTimeUs, other.resolvedPeriodTimeUs);
     }
-
-  }
-
-  private static final class SeekPosition {
-
-    public final Timeline timeline;
-    public final int windowIndex;
-    public final long windowPositionUs;
-
-    public SeekPosition(Timeline timeline, int windowIndex, long windowPositionUs) {
-      this.timeline = timeline;
-      this.windowIndex = windowIndex;
-      this.windowPositionUs = windowPositionUs;
-    }
-
   }
 
   private static final class MediaSourceRefreshInfo {
@@ -1756,7 +1688,40 @@ public MediaSourceRefreshInfo(MediaSource source, Timeline timeline, Object mani
       this.timeline = timeline;
       this.manifest = manifest;
     }
+  }
+
+  private static final class PlaybackInfoUpdate {
+
+    private PlaybackInfo lastPlaybackInfo;
+    private int operationAcks;
+    private boolean positionDiscontinuity;
+    private @DiscontinuityReason int discontinuityReason;
+
+    public boolean hasPendingUpdate(PlaybackInfo playbackInfo) {
+      return playbackInfo != lastPlaybackInfo || operationAcks > 0 || positionDiscontinuity;
+    }
+
+    public void reset(PlaybackInfo playbackInfo) {
+      lastPlaybackInfo = playbackInfo;
+      operationAcks = 0;
+      positionDiscontinuity = false;
+    }
 
+    public void incrementPendingOperationAcks(int operationAcks) {
+      this.operationAcks += operationAcks;
+    }
+
+    public void setPositionDiscontinuity(@DiscontinuityReason int discontinuityReason) {
+      if (positionDiscontinuity
+          && this.discontinuityReason != Player.DISCONTINUITY_REASON_INTERNAL) {
+        // We always prefer non-internal discontinuity reasons. We also assume that we won't report
+        // more than one non-internal discontinuity per message iteration.
+        Assertions.checkArgument(discontinuityReason == Player.DISCONTINUITY_REASON_INTERNAL);
+        return;
+      }
+      positionDiscontinuity = true;
+      this.discontinuityReason = discontinuityReason;
+    }
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
index f13a7de0ca..bb3732fb94 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java
@@ -27,27 +27,23 @@
    */
   public static final String TAG = "ExoPlayer";
 
-  /**
-   * The version of the library expressed as a string, for example "1.2.3".
-   */
+  /** The version of the library expressed as a string, for example "1.2.3". */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION_INT) or vice versa.
-  public static final String VERSION = "2.6.0";
+  public static final String VERSION = "2.7.2";
 
-  /**
-   * The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}.
-   */
+  /** The version of the library expressed as {@code "ExoPlayerLib/" + VERSION}. */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final String VERSION_SLASHY = "ExoPlayerLib/2.6.0";
+  public static final String VERSION_SLASHY = "ExoPlayerLib/2.7.2";
 
   /**
    * The version of the library expressed as an integer, for example 1002003.
-   * <p>
-   * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
+   *
+   * <p>Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
    * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
    * integer version 123045006 (123-045-006).
    */
   // Intentionally hardcoded. Do not derive from other constants (e.g. VERSION) or vice versa.
-  public static final int VERSION_INT = 2006000;
+  public static final int VERSION_INT = 2007002;
 
   /**
    * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Format.java b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
index 4bd23e2cb6..c830a246ae 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Format.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Format.java
@@ -21,7 +21,6 @@
 import android.os.Parcel;
 import android.os.Parcelable;
 import com.google.android.exoplayer2.drm.DrmInitData;
-import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
@@ -324,11 +323,41 @@ public static Format createTextSampleFormat(String id, String sampleMimeType, St
 
   // Image.
 
-  public static Format createImageSampleFormat(String id, String sampleMimeType, String codecs,
-      int bitrate, List<byte[]> initializationData, String language, DrmInitData drmInitData) {
-    return new Format(id, null, sampleMimeType, codecs, bitrate, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, NO_VALUE, NO_VALUE, null, NO_VALUE, null, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
-        NO_VALUE, 0, language, NO_VALUE, OFFSET_SAMPLE_RELATIVE, initializationData, drmInitData,
+  public static Format createImageSampleFormat(
+      String id,
+      String sampleMimeType,
+      String codecs,
+      int bitrate,
+      @C.SelectionFlags int selectionFlags,
+      List<byte[]> initializationData,
+      String language,
+      DrmInitData drmInitData) {
+    return new Format(
+        id,
+        null,
+        sampleMimeType,
+        codecs,
+        bitrate,
+        NO_VALUE,
+        NO_VALUE,
+        NO_VALUE,
+        NO_VALUE,
+        NO_VALUE,
+        NO_VALUE,
+        null,
+        NO_VALUE,
+        null,
+        NO_VALUE,
+        NO_VALUE,
+        NO_VALUE,
+        NO_VALUE,
+        NO_VALUE,
+        selectionFlags,
+        language,
+        NO_VALUE,
+        OFFSET_SAMPLE_RELATIVE,
+        initializationData,
+        drmInitData,
         null);
   }
 
@@ -444,8 +473,15 @@ public Format copyWithSubsampleOffsetUs(long subsampleOffsetUs) {
         drmInitData, metadata);
   }
 
-  public Format copyWithContainerInfo(String id, String codecs, int bitrate, int width, int height,
-      @C.SelectionFlags int selectionFlags, String language) {
+  public Format copyWithContainerInfo(
+      String id,
+      String sampleMimeType,
+      String codecs,
+      int bitrate,
+      int width,
+      int height,
+      @C.SelectionFlags int selectionFlags,
+      String language) {
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
         height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
         colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
@@ -465,8 +501,8 @@ public Format copyWithManifestFormatInfo(Format manifestFormat) {
     float frameRate = this.frameRate == NO_VALUE ? manifestFormat.frameRate : this.frameRate;
     @C.SelectionFlags int selectionFlags = this.selectionFlags |  manifestFormat.selectionFlags;
     String language = this.language == null ? manifestFormat.language : this.language;
-    DrmInitData drmInitData = manifestFormat.drmInitData != null
-        ? getFilledManifestDrmData(manifestFormat.drmInitData) : this.drmInitData;
+    DrmInitData drmInitData =
+        DrmInitData.createSessionCreationData(manifestFormat.drmInitData, this.drmInitData);
     return new Format(id, containerMimeType, sampleMimeType, codecs, bitrate, maxInputSize, width,
         height, frameRate, rotationDegrees, pixelWidthHeightRatio, projectionData, stereoMode,
         colorInfo, channelCount, sampleRate, pcmEncoding, encoderDelay, encoderPadding,
@@ -731,43 +767,4 @@ public Format createFromParcel(Parcel in) {
     }
 
   };
-
-  private DrmInitData getFilledManifestDrmData(DrmInitData manifestDrmData) {
-    // All exposed SchemeDatas must include key request information.
-    ArrayList<SchemeData> exposedSchemeDatas = new ArrayList<>();
-    ArrayList<SchemeData> emptySchemeDatas = new ArrayList<>();
-    for (int i = 0; i < manifestDrmData.schemeDataCount; i++) {
-      SchemeData schemeData = manifestDrmData.get(i);
-      if (schemeData.hasData()) {
-        exposedSchemeDatas.add(schemeData);
-      } else /* needs initialization data filling */ {
-        emptySchemeDatas.add(schemeData);
-      }
-    }
-
-    if (emptySchemeDatas.isEmpty()) {
-      // Manifest DRM information is complete.
-      return manifestDrmData;
-    } else if (drmInitData == null) {
-      // The manifest DRM data needs filling but this format does not include enough information to
-      // do it. A subset of the manifest's scheme datas should not be exposed because a
-      // DrmSessionManager could decide it does not support the format, while the missing
-      // information comes in a format feed immediately after.
-      return null;
-    }
-
-    int needFillingCount = emptySchemeDatas.size();
-    for (int i = 0; i < drmInitData.schemeDataCount; i++) {
-      SchemeData mediaSchemeData = drmInitData.get(i);
-      for (int j = 0; j < needFillingCount; j++) {
-        if (mediaSchemeData.canReplace(emptySchemeDatas.get(j))) {
-          exposedSchemeDatas.add(mediaSchemeData);
-          break;
-        }
-      }
-    }
-    return exposedSchemeDatas.isEmpty() ? null : new DrmInitData(manifestDrmData.schemeType,
-        exposedSchemeDatas.toArray(new SchemeData[exposedSchemeDatas.size()]));
-  }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/LoadControl.java b/library/core/src/main/java/com/google/android/exoplayer2/LoadControl.java
index c092480222..80be0b9e71 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/LoadControl.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/LoadControl.java
@@ -56,23 +56,58 @@ void onTracksSelected(Renderer[] renderers, TrackGroupArray trackGroups,
   Allocator getAllocator();
 
   /**
-   * Called by the player to determine whether sufficient media is buffered for playback to be
-   * started or resumed.
+   * Returns the duration of media to retain in the buffer prior to the current playback position,
+   * for fast backward seeking.
+   * <p>
+   * Note: If {@link #retainBackBufferFromKeyframe()} is false then seeking in the back-buffer will
+   * only be fast if the back-buffer contains a keyframe prior to the seek position.
+   * <p>
+   * Note: Implementations should return a single value. Dynamic changes to the back-buffer are not
+   * currently supported.
    *
-   * @param bufferedDurationUs The duration of media that's currently buffered.
-   * @param rebuffering Whether the player is rebuffering. A rebuffer is defined to be caused by
-   *     buffer depletion rather than a user action. Hence this parameter is false during initial
-   *     buffering and when buffering as a result of a seek operation.
-   * @return Whether playback should be allowed to start or resume.
+   * @return The duration of media to retain in the buffer prior to the current playback position,
+   *     in microseconds.
+   */
+  long getBackBufferDurationUs();
+
+  /**
+   * Returns whether media should be retained from the keyframe before the current playback position
+   * minus {@link #getBackBufferDurationUs()}, rather than any sample before or at that position.
+   * <p>
+   * Warning: Returning true will cause the back-buffer size to depend on the spacing of keyframes
+   * in the media being played. Returning true is not recommended unless you control the media and
+   * are comfortable with the back-buffer size exceeding {@link #getBackBufferDurationUs()} by as
+   * much as the maximum duration between adjacent keyframes in the media.
+   * <p>
+   * Note: Implementations should return a single value. Dynamic changes to the back-buffer are not
+   * currently supported.
+   *
+   * @return Whether media should be retained from the keyframe before the current playback position
+   * minus {@link #getBackBufferDurationUs()}, rather than any sample before or at that position.
    */
-  boolean shouldStartPlayback(long bufferedDurationUs, boolean rebuffering);
+  boolean retainBackBufferFromKeyframe();
 
   /**
    * Called by the player to determine whether it should continue to load the source.
    *
    * @param bufferedDurationUs The duration of media that's currently buffered.
+   * @param playbackSpeed The current playback speed.
    * @return Whether the loading should continue.
    */
-  boolean shouldContinueLoading(long bufferedDurationUs);
+  boolean shouldContinueLoading(long bufferedDurationUs, float playbackSpeed);
 
+  /**
+   * Called repeatedly by the player when it's loading the source, has yet to start playback, and
+   * has the minimum amount of data necessary for playback to be started. The value returned
+   * determines whether playback is actually started. The load control may opt to return {@code
+   * false} until some condition has been met (e.g. a certain amount of media is buffered).
+   *
+   * @param bufferedDurationUs The duration of media that's currently buffered.
+   * @param playbackSpeed The current playback speed.
+   * @param rebuffering Whether the player is rebuffering. A rebuffer is defined to be caused by
+   *     buffer depletion rather than a user action. Hence this parameter is false during initial
+   *     buffering and when buffering as a result of a seek operation.
+   * @return Whether playback should be allowed to start or resume.
+   */
+  boolean shouldStartPlayback(long bufferedDurationUs, float playbackSpeed, boolean rebuffering);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
new file mode 100644
index 0000000000..43036b154b
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodHolder.java
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.util.Log;
+import com.google.android.exoplayer2.source.ClippingMediaPeriod;
+import com.google.android.exoplayer2.source.EmptySampleStream;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.SampleStream;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.Assertions;
+
+/** Holds a {@link MediaPeriod} with information required to play it as part of a timeline. */
+/* package */ final class MediaPeriodHolder {
+
+  private static final String TAG = "MediaPeriodHolder";
+
+  public final MediaPeriod mediaPeriod;
+  public final Object uid;
+  public final SampleStream[] sampleStreams;
+  public final boolean[] mayRetainStreamFlags;
+
+  public long rendererPositionOffsetUs;
+  public boolean prepared;
+  public boolean hasEnabledTracks;
+  public MediaPeriodInfo info;
+  public MediaPeriodHolder next;
+  public TrackSelectorResult trackSelectorResult;
+
+  private final RendererCapabilities[] rendererCapabilities;
+  private final TrackSelector trackSelector;
+  private final MediaSource mediaSource;
+
+  private TrackSelectorResult periodTrackSelectorResult;
+
+  /**
+   * Creates a new holder with information required to play it as part of a timeline.
+   *
+   * @param rendererCapabilities The renderer capabilities.
+   * @param rendererPositionOffsetUs The time offset of the start of the media period to provide to
+   *     renderers.
+   * @param trackSelector The track selector.
+   * @param allocator The allocator.
+   * @param mediaSource The media source that produced the media period.
+   * @param uid The unique identifier for the containing timeline period.
+   * @param info Information used to identify this media period in its timeline period.
+   */
+  public MediaPeriodHolder(
+      RendererCapabilities[] rendererCapabilities,
+      long rendererPositionOffsetUs,
+      TrackSelector trackSelector,
+      Allocator allocator,
+      MediaSource mediaSource,
+      Object uid,
+      MediaPeriodInfo info) {
+    this.rendererCapabilities = rendererCapabilities;
+    this.rendererPositionOffsetUs = rendererPositionOffsetUs - info.startPositionUs;
+    this.trackSelector = trackSelector;
+    this.mediaSource = mediaSource;
+    this.uid = Assertions.checkNotNull(uid);
+    this.info = info;
+    sampleStreams = new SampleStream[rendererCapabilities.length];
+    mayRetainStreamFlags = new boolean[rendererCapabilities.length];
+    MediaPeriod mediaPeriod = mediaSource.createPeriod(info.id, allocator);
+    if (info.endPositionUs != C.TIME_END_OF_SOURCE) {
+      ClippingMediaPeriod clippingMediaPeriod = new ClippingMediaPeriod(mediaPeriod, true);
+      clippingMediaPeriod.setClipping(0, info.endPositionUs);
+      mediaPeriod = clippingMediaPeriod;
+    }
+    this.mediaPeriod = mediaPeriod;
+  }
+
+  public long toRendererTime(long periodTimeUs) {
+    return periodTimeUs + getRendererOffset();
+  }
+
+  public long toPeriodTime(long rendererTimeUs) {
+    return rendererTimeUs - getRendererOffset();
+  }
+
+  public long getRendererOffset() {
+    return rendererPositionOffsetUs;
+  }
+
+  public boolean isFullyBuffered() {
+    return prepared
+        && (!hasEnabledTracks || mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE);
+  }
+
+  public long getDurationUs() {
+    return info.durationUs;
+  }
+
+  /**
+   * Returns the buffered position in microseconds. If the period is buffered to the end then
+   * {@link C#TIME_END_OF_SOURCE} is returned unless {@code convertEosToDuration} is true, in which
+   * case the period duration is returned.
+   *
+   * @param convertEosToDuration Whether to return the period duration rather than
+   *     {@link C#TIME_END_OF_SOURCE} if the period is fully buffered.
+   * @return The buffered position in microseconds.
+   */
+  public long getBufferedPositionUs(boolean convertEosToDuration) {
+    if (!prepared) {
+      return info.startPositionUs;
+    }
+    long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
+    return bufferedPositionUs == C.TIME_END_OF_SOURCE && convertEosToDuration
+        ? info.durationUs
+        : bufferedPositionUs;
+  }
+
+  public long getNextLoadPositionUs() {
+    return !prepared ? 0 : mediaPeriod.getNextLoadPositionUs();
+  }
+
+  public TrackSelectorResult handlePrepared(float playbackSpeed) throws ExoPlaybackException {
+    prepared = true;
+    selectTracks(playbackSpeed);
+    long newStartPositionUs = applyTrackSelection(info.startPositionUs, false);
+    rendererPositionOffsetUs += info.startPositionUs - newStartPositionUs;
+    info = info.copyWithStartPositionUs(newStartPositionUs);
+    return trackSelectorResult;
+  }
+
+  public void reevaluateBuffer(long rendererPositionUs) {
+    if (prepared) {
+      mediaPeriod.reevaluateBuffer(toPeriodTime(rendererPositionUs));
+    }
+  }
+
+  public void continueLoading(long rendererPositionUs) {
+    long loadingPeriodPositionUs = toPeriodTime(rendererPositionUs);
+    mediaPeriod.continueLoading(loadingPeriodPositionUs);
+  }
+
+  public boolean selectTracks(float playbackSpeed) throws ExoPlaybackException {
+    TrackSelectorResult selectorResult =
+        trackSelector.selectTracks(rendererCapabilities, mediaPeriod.getTrackGroups());
+    if (selectorResult.isEquivalent(periodTrackSelectorResult)) {
+      return false;
+    }
+    trackSelectorResult = selectorResult;
+    for (TrackSelection trackSelection : trackSelectorResult.selections.getAll()) {
+      if (trackSelection != null) {
+        trackSelection.onPlaybackSpeed(playbackSpeed);
+      }
+    }
+    return true;
+  }
+
+  public long applyTrackSelection(long positionUs, boolean forceRecreateStreams) {
+    return applyTrackSelection(
+        positionUs, forceRecreateStreams, new boolean[rendererCapabilities.length]);
+  }
+
+  public long applyTrackSelection(
+      long positionUs, boolean forceRecreateStreams, boolean[] streamResetFlags) {
+    TrackSelectionArray trackSelections = trackSelectorResult.selections;
+    for (int i = 0; i < trackSelections.length; i++) {
+      mayRetainStreamFlags[i] =
+          !forceRecreateStreams && trackSelectorResult.isEquivalent(periodTrackSelectorResult, i);
+    }
+
+    // Undo the effect of previous call to associate no-sample renderers with empty tracks
+    // so the mediaPeriod receives back whatever it sent us before.
+    disassociateNoSampleRenderersWithEmptySampleStream(sampleStreams);
+    updatePeriodTrackSelectorResult(trackSelectorResult);
+    // Disable streams on the period and get new streams for updated/newly-enabled tracks.
+    positionUs =
+        mediaPeriod.selectTracks(
+            trackSelections.getAll(),
+            mayRetainStreamFlags,
+            sampleStreams,
+            streamResetFlags,
+            positionUs);
+    associateNoSampleRenderersWithEmptySampleStream(sampleStreams);
+
+    // Update whether we have enabled tracks and sanity check the expected streams are non-null.
+    hasEnabledTracks = false;
+    for (int i = 0; i < sampleStreams.length; i++) {
+      if (sampleStreams[i] != null) {
+        Assertions.checkState(trackSelectorResult.renderersEnabled[i]);
+        // hasEnabledTracks should be true only when non-empty streams exists.
+        if (rendererCapabilities[i].getTrackType() != C.TRACK_TYPE_NONE) {
+          hasEnabledTracks = true;
+        }
+      } else {
+        Assertions.checkState(trackSelections.get(i) == null);
+      }
+    }
+    return positionUs;
+  }
+
+  public void release() {
+    updatePeriodTrackSelectorResult(null);
+    try {
+      if (info.endPositionUs != C.TIME_END_OF_SOURCE) {
+        mediaSource.releasePeriod(((ClippingMediaPeriod) mediaPeriod).mediaPeriod);
+      } else {
+        mediaSource.releasePeriod(mediaPeriod);
+      }
+    } catch (RuntimeException e) {
+      // There's nothing we can do.
+      Log.e(TAG, "Period release failed.", e);
+    }
+  }
+
+  private void updatePeriodTrackSelectorResult(TrackSelectorResult trackSelectorResult) {
+    if (periodTrackSelectorResult != null) {
+      disableTrackSelectionsInResult(periodTrackSelectorResult);
+    }
+    periodTrackSelectorResult = trackSelectorResult;
+    if (periodTrackSelectorResult != null) {
+      enableTrackSelectionsInResult(periodTrackSelectorResult);
+    }
+  }
+
+  private void enableTrackSelectionsInResult(TrackSelectorResult trackSelectorResult) {
+    for (int i = 0; i < trackSelectorResult.renderersEnabled.length; i++) {
+      boolean rendererEnabled = trackSelectorResult.renderersEnabled[i];
+      TrackSelection trackSelection = trackSelectorResult.selections.get(i);
+      if (rendererEnabled && trackSelection != null) {
+        trackSelection.enable();
+      }
+    }
+  }
+
+  private void disableTrackSelectionsInResult(TrackSelectorResult trackSelectorResult) {
+    for (int i = 0; i < trackSelectorResult.renderersEnabled.length; i++) {
+      boolean rendererEnabled = trackSelectorResult.renderersEnabled[i];
+      TrackSelection trackSelection = trackSelectorResult.selections.get(i);
+      if (rendererEnabled && trackSelection != null) {
+        trackSelection.disable();
+      }
+    }
+  }
+
+  /**
+   * For each renderer of type {@link C#TRACK_TYPE_NONE}, we will remove the dummy {@link
+   * EmptySampleStream} that was associated with it.
+   */
+  private void disassociateNoSampleRenderersWithEmptySampleStream(SampleStream[] sampleStreams) {
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE) {
+        sampleStreams[i] = null;
+      }
+    }
+  }
+
+  /**
+   * For each renderer of type {@link C#TRACK_TYPE_NONE} that was enabled, we will associate it with
+   * a dummy {@link EmptySampleStream}.
+   */
+  private void associateNoSampleRenderersWithEmptySampleStream(SampleStream[] sampleStreams) {
+    for (int i = 0; i < rendererCapabilities.length; i++) {
+      if (rendererCapabilities[i].getTrackType() == C.TRACK_TYPE_NONE
+          && trackSelectorResult.renderersEnabled[i]) {
+        sampleStreams[i] = new EmptySampleStream();
+      }
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
new file mode 100644
index 0000000000..fce1780b71
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfo.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+
+/** Stores the information required to load and play a {@link MediaPeriod}. */
+/* package */ final class MediaPeriodInfo {
+
+  /** The media period's identifier. */
+  public final MediaPeriodId id;
+  /** The start position of the media to play within the media period, in microseconds. */
+  public final long startPositionUs;
+  /**
+   * The end position of the media to play within the media period, in microseconds, or {@link
+   * C#TIME_END_OF_SOURCE} if the end position is the end of the media period.
+   */
+  public final long endPositionUs;
+  /**
+   * If this is an ad, the position to play in the next content media period. {@link C#TIME_UNSET}
+   * otherwise.
+   */
+  public final long contentPositionUs;
+  /**
+   * The duration of the media period, like {@link #endPositionUs} but with {@link
+   * C#TIME_END_OF_SOURCE} resolved to the timeline period duration. May be {@link C#TIME_UNSET} if
+   * the end position is not known.
+   */
+  public final long durationUs;
+  /**
+   * Whether this is the last media period in its timeline period (e.g., a postroll ad, or a media
+   * period corresponding to a timeline period without ads).
+   */
+  public final boolean isLastInTimelinePeriod;
+  /**
+   * Whether this is the last media period in the entire timeline. If true, {@link
+   * #isLastInTimelinePeriod} will also be true.
+   */
+  public final boolean isFinal;
+
+  MediaPeriodInfo(
+      MediaPeriodId id,
+      long startPositionUs,
+      long endPositionUs,
+      long contentPositionUs,
+      long durationUs,
+      boolean isLastInTimelinePeriod,
+      boolean isFinal) {
+    this.id = id;
+    this.startPositionUs = startPositionUs;
+    this.endPositionUs = endPositionUs;
+    this.contentPositionUs = contentPositionUs;
+    this.durationUs = durationUs;
+    this.isLastInTimelinePeriod = isLastInTimelinePeriod;
+    this.isFinal = isFinal;
+  }
+
+  /**
+   * Returns a copy of this instance with the period identifier's period index set to the specified
+   * value.
+   */
+  public MediaPeriodInfo copyWithPeriodIndex(int periodIndex) {
+    return new MediaPeriodInfo(
+        id.copyWithPeriodIndex(periodIndex),
+        startPositionUs,
+        endPositionUs,
+        contentPositionUs,
+        durationUs,
+        isLastInTimelinePeriod,
+        isFinal);
+  }
+
+  /** Returns a copy of this instance with the start position set to the specified value. */
+  public MediaPeriodInfo copyWithStartPositionUs(long startPositionUs) {
+    return new MediaPeriodInfo(
+        id,
+        startPositionUs,
+        endPositionUs,
+        contentPositionUs,
+        durationUs,
+        isLastInTimelinePeriod,
+        isFinal);
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfoSequence.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfoSequence.java
deleted file mode 100644
index 6cb76e5471..0000000000
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodInfoSequence.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2;
-
-import android.util.Pair;
-import com.google.android.exoplayer2.Player.RepeatMode;
-import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
-
-/**
- * Provides a sequence of {@link MediaPeriodInfo}s to the player, determining the order and
- * start/end positions for {@link MediaPeriod}s to load and play.
- */
-/* package */ final class MediaPeriodInfoSequence {
-
-  // TODO: Consider merging this class with the MediaPeriodHolder queue in ExoPlayerImplInternal.
-
-  /**
-   * Stores the information required to load and play a {@link MediaPeriod}.
-   */
-  public static final class MediaPeriodInfo {
-
-    /**
-     * The media period's identifier.
-     */
-    public final MediaPeriodId id;
-    /**
-     * The start position of the media to play within the media period, in microseconds.
-     */
-    public final long startPositionUs;
-    /**
-     * The end position of the media to play within the media period, in microseconds, or
-     * {@link C#TIME_END_OF_SOURCE} if the end position is the end of the media period.
-     */
-    public final long endPositionUs;
-    /**
-     * If this is an ad, the position to play in the next content media period. {@link C#TIME_UNSET}
-     * otherwise.
-     */
-    public final long contentPositionUs;
-    /**
-     * The duration of the media to play within the media period, in microseconds, or
-     * {@link C#TIME_UNSET} if not known.
-     */
-    public final long durationUs;
-    /**
-     * Whether this is the last media period in its timeline period (e.g., a postroll ad, or a media
-     * period corresponding to a timeline period without ads).
-     */
-    public final boolean isLastInTimelinePeriod;
-    /**
-     * Whether this is the last media period in the entire timeline. If true,
-     * {@link #isLastInTimelinePeriod} will also be true.
-     */
-    public final boolean isFinal;
-
-    private MediaPeriodInfo(MediaPeriodId id, long startPositionUs, long endPositionUs,
-        long contentPositionUs, long durationUs, boolean isLastInTimelinePeriod, boolean isFinal) {
-      this.id = id;
-      this.startPositionUs = startPositionUs;
-      this.endPositionUs = endPositionUs;
-      this.contentPositionUs = contentPositionUs;
-      this.durationUs = durationUs;
-      this.isLastInTimelinePeriod = isLastInTimelinePeriod;
-      this.isFinal = isFinal;
-    }
-
-    /**
-     * Returns a copy of this instance with the period identifier's period index set to the
-     * specified value.
-     */
-    public MediaPeriodInfo copyWithPeriodIndex(int periodIndex) {
-      return new MediaPeriodInfo(id.copyWithPeriodIndex(periodIndex), startPositionUs,
-          endPositionUs, contentPositionUs, durationUs, isLastInTimelinePeriod, isFinal);
-    }
-
-    /**
-     * Returns a copy of this instance with the start position set to the specified value.
-     */
-    public MediaPeriodInfo copyWithStartPositionUs(long startPositionUs) {
-      return new MediaPeriodInfo(id, startPositionUs, endPositionUs, contentPositionUs, durationUs,
-          isLastInTimelinePeriod, isFinal);
-    }
-
-  }
-
-  private final Timeline.Period period;
-  private final Timeline.Window window;
-
-  private Timeline timeline;
-  private @RepeatMode int repeatMode;
-  private boolean shuffleModeEnabled;
-
-  /**
-   * Creates a new media period info sequence.
-   */
-  public MediaPeriodInfoSequence() {
-    period = new Timeline.Period();
-    window = new Timeline.Window();
-  }
-
-  /**
-   * Sets the {@link Timeline}. Call {@link #getUpdatedMediaPeriodInfo} to update period information
-   * taking into account the new timeline.
-   */
-  public void setTimeline(Timeline timeline) {
-    this.timeline = timeline;
-  }
-
-  /**
-   * Sets the {@link RepeatMode}. Call {@link #getUpdatedMediaPeriodInfo} to update period
-   * information taking into account the new repeat mode.
-   */
-  public void setRepeatMode(@RepeatMode int repeatMode) {
-    this.repeatMode = repeatMode;
-  }
-
-  /**
-   * Sets whether shuffling is enabled. Call {@link #getUpdatedMediaPeriodInfo} to update period
-   * information taking into account the shuffle mode.
-   */
-  public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
-    this.shuffleModeEnabled = shuffleModeEnabled;
-  }
-
-  /**
-   * Returns the first {@link MediaPeriodInfo} to play, based on the specified playback position.
-   */
-  public MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
-    return getMediaPeriodInfo(playbackInfo.periodId, playbackInfo.contentPositionUs,
-        playbackInfo.startPositionUs);
-  }
-
-  /**
-   * Returns the {@link MediaPeriodInfo} following {@code currentMediaPeriodInfo}.
-   *
-   * @param currentMediaPeriodInfo The current media period info.
-   * @param rendererOffsetUs The current renderer offset in microseconds.
-   * @param rendererPositionUs The current renderer position in microseconds.
-   * @return The following media period info, or {@code null} if it is not yet possible to get the
-   *     next media period info.
-   */
-  public MediaPeriodInfo getNextMediaPeriodInfo(MediaPeriodInfo currentMediaPeriodInfo,
-      long rendererOffsetUs, long rendererPositionUs) {
-    // TODO: This method is called repeatedly from ExoPlayerImplInternal.maybeUpdateLoadingPeriod
-    // but if the timeline is not ready to provide the next period it can't return a non-null value
-    // until the timeline is updated. Store whether the next timeline period is ready when the
-    // timeline is updated, to avoid repeatedly checking the same timeline.
-    if (currentMediaPeriodInfo.isLastInTimelinePeriod) {
-      int nextPeriodIndex = timeline.getNextPeriodIndex(currentMediaPeriodInfo.id.periodIndex,
-          period, window, repeatMode, shuffleModeEnabled);
-      if (nextPeriodIndex == C.INDEX_UNSET) {
-        // We can't create a next period yet.
-        return null;
-      }
-
-      long startPositionUs;
-      int nextWindowIndex = timeline.getPeriod(nextPeriodIndex, period).windowIndex;
-      if (timeline.getWindow(nextWindowIndex, window).firstPeriodIndex == nextPeriodIndex) {
-        // We're starting to buffer a new window. When playback transitions to this window we'll
-        // want it to be from its default start position. The expected delay until playback
-        // transitions is equal the duration of media that's currently buffered (assuming no
-        // interruptions). Hence we project the default start position forward by the duration of
-        // the buffer, and start buffering from this point.
-        long defaultPositionProjectionUs =
-            rendererOffsetUs + currentMediaPeriodInfo.durationUs - rendererPositionUs;
-        Pair<Integer, Long> defaultPosition = timeline.getPeriodPosition(window, period,
-            nextWindowIndex, C.TIME_UNSET, Math.max(0, defaultPositionProjectionUs));
-        if (defaultPosition == null) {
-          return null;
-        }
-        nextPeriodIndex = defaultPosition.first;
-        startPositionUs = defaultPosition.second;
-      } else {
-        startPositionUs = 0;
-      }
-      MediaPeriodId periodId = resolvePeriodPositionForAds(nextPeriodIndex, startPositionUs);
-      return getMediaPeriodInfo(periodId, startPositionUs, startPositionUs);
-    }
-
-    MediaPeriodId currentPeriodId = currentMediaPeriodInfo.id;
-    if (currentPeriodId.isAd()) {
-      int currentAdGroupIndex = currentPeriodId.adGroupIndex;
-      timeline.getPeriod(currentPeriodId.periodIndex, period);
-      int adCountInCurrentAdGroup = period.getAdCountInAdGroup(currentAdGroupIndex);
-      if (adCountInCurrentAdGroup == C.LENGTH_UNSET) {
-        return null;
-      }
-      int nextAdIndexInAdGroup = currentPeriodId.adIndexInAdGroup + 1;
-      if (nextAdIndexInAdGroup < adCountInCurrentAdGroup) {
-        // Play the next ad in the ad group if it's available.
-        return !period.isAdAvailable(currentAdGroupIndex, nextAdIndexInAdGroup) ? null
-            : getMediaPeriodInfoForAd(currentPeriodId.periodIndex, currentAdGroupIndex,
-                nextAdIndexInAdGroup, currentMediaPeriodInfo.contentPositionUs);
-      } else {
-        // Play content from the ad group position.
-        int nextAdGroupIndex =
-            period.getAdGroupIndexAfterPositionUs(currentMediaPeriodInfo.contentPositionUs);
-        long endUs = nextAdGroupIndex == C.INDEX_UNSET ? C.TIME_END_OF_SOURCE
-            : period.getAdGroupTimeUs(nextAdGroupIndex);
-        return getMediaPeriodInfoForContent(currentPeriodId.periodIndex,
-            currentMediaPeriodInfo.contentPositionUs, endUs);
-      }
-    } else if (currentMediaPeriodInfo.endPositionUs != C.TIME_END_OF_SOURCE) {
-      // Play the next ad group if it's available.
-      int nextAdGroupIndex =
-          period.getAdGroupIndexForPositionUs(currentMediaPeriodInfo.endPositionUs);
-      return !period.isAdAvailable(nextAdGroupIndex, 0) ? null
-          : getMediaPeriodInfoForAd(currentPeriodId.periodIndex, nextAdGroupIndex, 0,
-              currentMediaPeriodInfo.endPositionUs);
-    } else {
-      // Check if the postroll ad should be played.
-      int adGroupCount = period.getAdGroupCount();
-      if (adGroupCount == 0
-          || period.getAdGroupTimeUs(adGroupCount - 1) != C.TIME_END_OF_SOURCE
-          || period.hasPlayedAdGroup(adGroupCount - 1)
-          || !period.isAdAvailable(adGroupCount - 1, 0)) {
-        return null;
-      }
-      long contentDurationUs = period.getDurationUs();
-      return getMediaPeriodInfoForAd(currentPeriodId.periodIndex, adGroupCount - 1, 0,
-          contentDurationUs);
-    }
-  }
-
-  /**
-   * Resolves the specified timeline period and position to a {@link MediaPeriodId} that should be
-   * played, returning an identifier for an ad group if one needs to be played before the specified
-   * position, or an identifier for a content media period if not.
-   */
-  public MediaPeriodId resolvePeriodPositionForAds(int periodIndex, long positionUs) {
-    timeline.getPeriod(periodIndex, period);
-    int adGroupIndex = period.getAdGroupIndexForPositionUs(positionUs);
-    if (adGroupIndex == C.INDEX_UNSET) {
-      return new MediaPeriodId(periodIndex);
-    } else {
-      int adIndexInAdGroup = period.getPlayedAdCount(adGroupIndex);
-      return new MediaPeriodId(periodIndex, adGroupIndex, adIndexInAdGroup);
-    }
-  }
-
-  /**
-   * Returns the {@code mediaPeriodInfo} updated to take into account the current timeline.
-   */
-  public MediaPeriodInfo getUpdatedMediaPeriodInfo(MediaPeriodInfo mediaPeriodInfo) {
-    return getUpdatedMediaPeriodInfo(mediaPeriodInfo, mediaPeriodInfo.id);
-  }
-
-  /**
-   * Returns the {@code mediaPeriodInfo} updated to take into account the current timeline,
-   * resetting the identifier of the media period to the specified {@code newPeriodIndex}.
-   */
-  public MediaPeriodInfo getUpdatedMediaPeriodInfo(MediaPeriodInfo mediaPeriodInfo,
-      int newPeriodIndex) {
-    return getUpdatedMediaPeriodInfo(mediaPeriodInfo,
-        mediaPeriodInfo.id.copyWithPeriodIndex(newPeriodIndex));
-  }
-
-  // Internal methods.
-
-  private MediaPeriodInfo getUpdatedMediaPeriodInfo(MediaPeriodInfo info, MediaPeriodId newId) {
-    long startPositionUs = info.startPositionUs;
-    long endPositionUs = info.endPositionUs;
-    boolean isLastInPeriod = isLastInPeriod(newId, endPositionUs);
-    boolean isLastInTimeline = isLastInTimeline(newId, isLastInPeriod);
-    timeline.getPeriod(newId.periodIndex, period);
-    long durationUs = newId.isAd()
-        ? period.getAdDurationUs(newId.adGroupIndex, newId.adIndexInAdGroup)
-        : (endPositionUs == C.TIME_END_OF_SOURCE ? period.getDurationUs() : endPositionUs);
-    return new MediaPeriodInfo(newId, startPositionUs, endPositionUs, info.contentPositionUs,
-        durationUs, isLastInPeriod, isLastInTimeline);
-  }
-
-  private MediaPeriodInfo getMediaPeriodInfo(MediaPeriodId id, long contentPositionUs,
-      long startPositionUs) {
-    timeline.getPeriod(id.periodIndex, period);
-    if (id.isAd()) {
-      if (!period.isAdAvailable(id.adGroupIndex, id.adIndexInAdGroup)) {
-        return null;
-      }
-      return getMediaPeriodInfoForAd(id.periodIndex, id.adGroupIndex, id.adIndexInAdGroup,
-          contentPositionUs);
-    } else {
-      int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(startPositionUs);
-      long endUs = nextAdGroupIndex == C.INDEX_UNSET ? C.TIME_END_OF_SOURCE
-          : period.getAdGroupTimeUs(nextAdGroupIndex);
-      return getMediaPeriodInfoForContent(id.periodIndex, startPositionUs, endUs);
-    }
-  }
-
-  private MediaPeriodInfo getMediaPeriodInfoForAd(int periodIndex, int adGroupIndex,
-      int adIndexInAdGroup, long contentPositionUs) {
-    MediaPeriodId id = new MediaPeriodId(periodIndex, adGroupIndex, adIndexInAdGroup);
-    boolean isLastInPeriod = isLastInPeriod(id, C.TIME_END_OF_SOURCE);
-    boolean isLastInTimeline = isLastInTimeline(id, isLastInPeriod);
-    long durationUs = timeline.getPeriod(id.periodIndex, period)
-        .getAdDurationUs(id.adGroupIndex, id.adIndexInAdGroup);
-    long startPositionUs = adIndexInAdGroup == period.getPlayedAdCount(adGroupIndex)
-        ? period.getAdResumePositionUs() : 0;
-    return new MediaPeriodInfo(id, startPositionUs, C.TIME_END_OF_SOURCE, contentPositionUs,
-        durationUs, isLastInPeriod, isLastInTimeline);
-  }
-
-  private MediaPeriodInfo getMediaPeriodInfoForContent(int periodIndex, long startPositionUs,
-      long endUs) {
-    MediaPeriodId id = new MediaPeriodId(periodIndex);
-    boolean isLastInPeriod = isLastInPeriod(id, endUs);
-    boolean isLastInTimeline = isLastInTimeline(id, isLastInPeriod);
-    timeline.getPeriod(id.periodIndex, period);
-    long durationUs = endUs == C.TIME_END_OF_SOURCE ? period.getDurationUs() : endUs;
-    return new MediaPeriodInfo(id, startPositionUs, endUs, C.TIME_UNSET, durationUs, isLastInPeriod,
-        isLastInTimeline);
-  }
-
-  private boolean isLastInPeriod(MediaPeriodId id, long endPositionUs) {
-    int adGroupCount = timeline.getPeriod(id.periodIndex, period).getAdGroupCount();
-    if (adGroupCount == 0) {
-      return true;
-    }
-
-    int lastAdGroupIndex = adGroupCount - 1;
-    boolean isAd = id.isAd();
-    if (period.getAdGroupTimeUs(lastAdGroupIndex) != C.TIME_END_OF_SOURCE) {
-      // There's no postroll ad.
-      return !isAd && endPositionUs == C.TIME_END_OF_SOURCE;
-    }
-
-    int postrollAdCount = period.getAdCountInAdGroup(lastAdGroupIndex);
-    if (postrollAdCount == C.LENGTH_UNSET) {
-      // We won't know if this is the last ad until we know how many postroll ads there are.
-      return false;
-    }
-
-    boolean isLastAd = isAd && id.adGroupIndex == lastAdGroupIndex
-        && id.adIndexInAdGroup == postrollAdCount - 1;
-    return isLastAd || (!isAd && period.getPlayedAdCount(lastAdGroupIndex) == postrollAdCount);
-  }
-
-  private boolean isLastInTimeline(MediaPeriodId id, boolean isLastMediaPeriodInPeriod) {
-    int windowIndex = timeline.getPeriod(id.periodIndex, period).windowIndex;
-    return !timeline.getWindow(windowIndex, window).isDynamic
-        && timeline.isLastPeriod(id.periodIndex, period, window, repeatMode, shuffleModeEnabled)
-        && isLastMediaPeriodInPeriod;
-  }
-
-}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
new file mode 100644
index 0000000000..3efff58f5d
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -0,0 +1,742 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.support.annotation.Nullable;
+import android.util.Pair;
+import com.google.android.exoplayer2.Player.RepeatMode;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.Assertions;
+
+/**
+ * Holds a queue of media periods, from the currently playing media period at the front to the
+ * loading media period at the end of the queue, with methods for controlling loading and updating
+ * the queue. Also has a reference to the media period currently being read.
+ */
+@SuppressWarnings("UngroupedOverloads")
+/* package */ final class MediaPeriodQueue {
+
+  /**
+   * Limits the maximum number of periods to buffer ahead of the current playing period. The
+   * buffering policy normally prevents buffering too far ahead, but the policy could allow too many
+   * small periods to be buffered if the period count were not limited.
+   */
+  private static final int MAXIMUM_BUFFER_AHEAD_PERIODS = 100;
+
+  private final Timeline.Period period;
+  private final Timeline.Window window;
+
+  private long nextWindowSequenceNumber;
+  private Timeline timeline;
+  private @RepeatMode int repeatMode;
+  private boolean shuffleModeEnabled;
+  private MediaPeriodHolder playing;
+  private MediaPeriodHolder reading;
+  private MediaPeriodHolder loading;
+  private int length;
+
+  /** Creates a new media period queue. */
+  public MediaPeriodQueue() {
+    period = new Timeline.Period();
+    window = new Timeline.Window();
+  }
+
+  /**
+   * Sets the {@link Timeline}. Call {@link #updateQueuedPeriods(MediaPeriodId, long)} to update the
+   * queued media periods to take into account the new timeline.
+   */
+  public void setTimeline(Timeline timeline) {
+    this.timeline = timeline;
+  }
+
+  /**
+   * Sets the {@link RepeatMode} and returns whether the repeat mode change has been fully handled.
+   * If not, it is necessary to seek to the current playback position.
+   */
+  public boolean updateRepeatMode(@RepeatMode int repeatMode) {
+    this.repeatMode = repeatMode;
+    return updateForPlaybackModeChange();
+  }
+
+  /**
+   * Sets whether shuffling is enabled and returns whether the shuffle mode change has been fully
+   * handled. If not, it is necessary to seek to the current playback position.
+   */
+  public boolean updateShuffleModeEnabled(boolean shuffleModeEnabled) {
+    this.shuffleModeEnabled = shuffleModeEnabled;
+    return updateForPlaybackModeChange();
+  }
+
+  /** Returns whether {@code mediaPeriod} is the current loading media period. */
+  public boolean isLoading(MediaPeriod mediaPeriod) {
+    return loading != null && loading.mediaPeriod == mediaPeriod;
+  }
+
+  /**
+   * If there is a loading period, reevaluates its buffer.
+   *
+   * @param rendererPositionUs The current renderer position.
+   */
+  public void reevaluateBuffer(long rendererPositionUs) {
+    if (loading != null) {
+      loading.reevaluateBuffer(rendererPositionUs);
+    }
+  }
+
+  /** Returns whether a new loading media period should be enqueued, if available. */
+  public boolean shouldLoadNextMediaPeriod() {
+    return loading == null
+        || (!loading.info.isFinal
+            && loading.isFullyBuffered()
+            && loading.info.durationUs != C.TIME_UNSET
+            && length < MAXIMUM_BUFFER_AHEAD_PERIODS);
+  }
+
+  /**
+   * Returns the {@link MediaPeriodInfo} for the next media period to load.
+   *
+   * @param rendererPositionUs The current renderer position.
+   * @param playbackInfo The current playback information.
+   * @return The {@link MediaPeriodInfo} for the next media period to load, or {@code null} if not
+   *     yet known.
+   */
+  public @Nullable MediaPeriodInfo getNextMediaPeriodInfo(
+      long rendererPositionUs, PlaybackInfo playbackInfo) {
+    return loading == null
+        ? getFirstMediaPeriodInfo(playbackInfo)
+        : getFollowingMediaPeriodInfo(loading, rendererPositionUs);
+  }
+
+  /**
+   * Enqueues a new media period based on the specified information as the new loading media period,
+   * and returns it.
+   *
+   * @param rendererCapabilities The renderer capabilities.
+   * @param rendererTimestampOffsetUs The base time offset added to for renderers.
+   * @param trackSelector The track selector.
+   * @param allocator The allocator.
+   * @param mediaSource The media source that produced the media period.
+   * @param uid The unique identifier for the containing timeline period.
+   * @param info Information used to identify this media period in its timeline period.
+   */
+  public MediaPeriod enqueueNextMediaPeriod(
+      RendererCapabilities[] rendererCapabilities,
+      long rendererTimestampOffsetUs,
+      TrackSelector trackSelector,
+      Allocator allocator,
+      MediaSource mediaSource,
+      Object uid,
+      MediaPeriodInfo info) {
+    long rendererPositionOffsetUs =
+        loading == null
+            ? (info.startPositionUs + rendererTimestampOffsetUs)
+            : (loading.getRendererOffset() + loading.info.durationUs);
+    MediaPeriodHolder newPeriodHolder =
+        new MediaPeriodHolder(
+            rendererCapabilities,
+            rendererPositionOffsetUs,
+            trackSelector,
+            allocator,
+            mediaSource,
+            uid,
+            info);
+    if (loading != null) {
+      Assertions.checkState(hasPlayingPeriod());
+      loading.next = newPeriodHolder;
+    }
+    loading = newPeriodHolder;
+    length++;
+    return newPeriodHolder.mediaPeriod;
+  }
+
+  /**
+   * Handles the loading media period being prepared.
+   *
+   * @param playbackSpeed The current playback speed.
+   * @return The result of selecting tracks on the newly prepared loading media period.
+   */
+  public TrackSelectorResult handleLoadingPeriodPrepared(float playbackSpeed)
+      throws ExoPlaybackException {
+    return loading.handlePrepared(playbackSpeed);
+  }
+
+  /**
+   * Returns the loading period holder which is at the end of the queue, or null if the queue is
+   * empty.
+   */
+  public MediaPeriodHolder getLoadingPeriod() {
+    return loading;
+  }
+
+  /**
+   * Returns the playing period holder which is at the front of the queue, or null if the queue is
+   * empty or hasn't started playing.
+   */
+  public MediaPeriodHolder getPlayingPeriod() {
+    return playing;
+  }
+
+  /**
+   * Returns the reading period holder, or null if the queue is empty or the player hasn't started
+   * reading.
+   */
+  public MediaPeriodHolder getReadingPeriod() {
+    return reading;
+  }
+
+  /**
+   * Returns the period holder in the front of the queue which is the playing period holder when
+   * playing, or null if the queue is empty.
+   */
+  public MediaPeriodHolder getFrontPeriod() {
+    return hasPlayingPeriod() ? playing : loading;
+  }
+
+  /** Returns whether the reading and playing period holders are set. */
+  public boolean hasPlayingPeriod() {
+    return playing != null;
+  }
+
+  /**
+   * Continues reading from the next period holder in the queue.
+   *
+   * @return The updated reading period holder.
+   */
+  public MediaPeriodHolder advanceReadingPeriod() {
+    Assertions.checkState(reading != null && reading.next != null);
+    reading = reading.next;
+    return reading;
+  }
+
+  /**
+   * Dequeues the playing period holder from the front of the queue and advances the playing period
+   * holder to be the next item in the queue. If the playing period holder is unset, set it to the
+   * item in the front of the queue.
+   *
+   * @return The updated playing period holder, or null if the queue is or becomes empty.
+   */
+  public MediaPeriodHolder advancePlayingPeriod() {
+    if (playing != null) {
+      if (playing == reading) {
+        reading = playing.next;
+      }
+      playing.release();
+      playing = playing.next;
+      length--;
+      if (length == 0) {
+        loading = null;
+      }
+    } else {
+      playing = loading;
+      reading = loading;
+    }
+    return playing;
+  }
+
+  /**
+   * Removes all period holders after the given period holder. This process may also remove the
+   * currently reading period holder. If that is the case, the reading period holder is set to be
+   * the same as the playing period holder at the front of the queue.
+   *
+   * @param mediaPeriodHolder The media period holder that shall be the new end of the queue.
+   * @return Whether the reading period has been removed.
+   */
+  public boolean removeAfter(MediaPeriodHolder mediaPeriodHolder) {
+    Assertions.checkState(mediaPeriodHolder != null);
+    boolean removedReading = false;
+    loading = mediaPeriodHolder;
+    while (mediaPeriodHolder.next != null) {
+      mediaPeriodHolder = mediaPeriodHolder.next;
+      if (mediaPeriodHolder == reading) {
+        reading = playing;
+        removedReading = true;
+      }
+      mediaPeriodHolder.release();
+      length--;
+    }
+    loading.next = null;
+    return removedReading;
+  }
+
+  /** Clears the queue. */
+  public void clear() {
+    MediaPeriodHolder front = getFrontPeriod();
+    if (front != null) {
+      front.release();
+      removeAfter(front);
+    }
+    playing = null;
+    loading = null;
+    reading = null;
+    length = 0;
+  }
+
+  /**
+   * Updates media periods in the queue to take into account the latest timeline, and returns
+   * whether the timeline change has been fully handled. If not, it is necessary to seek to the
+   * current playback position. The method assumes that the first media period in the queue is still
+   * consistent with the new timeline.
+   *
+   * @param playingPeriodId The current playing media period identifier.
+   * @param rendererPositionUs The current renderer position in microseconds.
+   * @return Whether the timeline change has been handled completely.
+   */
+  public boolean updateQueuedPeriods(MediaPeriodId playingPeriodId, long rendererPositionUs) {
+    // TODO: Merge this into setTimeline so that the queue gets updated as soon as the new timeline
+    // is set, once all cases handled by ExoPlayerImplInternal.handleSourceInfoRefreshed can be
+    // handled here.
+    int periodIndex = playingPeriodId.periodIndex;
+    // The front period is either playing now, or is being loaded and will become the playing
+    // period.
+    MediaPeriodHolder previousPeriodHolder = null;
+    MediaPeriodHolder periodHolder = getFrontPeriod();
+    while (periodHolder != null) {
+      if (previousPeriodHolder == null) {
+        periodHolder.info = getUpdatedMediaPeriodInfo(periodHolder.info, periodIndex);
+      } else {
+        // Check this period holder still follows the previous one, based on the new timeline.
+        if (periodIndex == C.INDEX_UNSET
+            || !periodHolder.uid.equals(timeline.getPeriod(periodIndex, period, true).uid)) {
+          // The holder uid is inconsistent with the new timeline.
+          return !removeAfter(previousPeriodHolder);
+        }
+        MediaPeriodInfo periodInfo =
+            getFollowingMediaPeriodInfo(previousPeriodHolder, rendererPositionUs);
+        if (periodInfo == null) {
+          // We've loaded a next media period that is not in the new timeline.
+          return !removeAfter(previousPeriodHolder);
+        }
+        // Update the period index.
+        periodHolder.info = getUpdatedMediaPeriodInfo(periodHolder.info, periodIndex);
+        // Check the media period information matches the new timeline.
+        if (!canKeepMediaPeriodHolder(periodHolder, periodInfo)) {
+          return !removeAfter(previousPeriodHolder);
+        }
+      }
+
+      if (periodHolder.info.isLastInTimelinePeriod) {
+        // Move on to the next timeline period index, if there is one.
+        periodIndex =
+            timeline.getNextPeriodIndex(
+                periodIndex, period, window, repeatMode, shuffleModeEnabled);
+      }
+
+      previousPeriodHolder = periodHolder;
+      periodHolder = periodHolder.next;
+    }
+    return true;
+  }
+
+  /**
+   * Returns new media period info based on specified {@code mediaPeriodInfo} but taking into
+   * account the current timeline, and with the period index updated to {@code newPeriodIndex}.
+   *
+   * @param mediaPeriodInfo Media period info for a media period based on an old timeline.
+   * @param newPeriodIndex The new period index in the new timeline for the existing media period.
+   * @return The updated media period info for the current timeline.
+   */
+  public MediaPeriodInfo getUpdatedMediaPeriodInfo(
+      MediaPeriodInfo mediaPeriodInfo, int newPeriodIndex) {
+    return getUpdatedMediaPeriodInfo(
+        mediaPeriodInfo, mediaPeriodInfo.id.copyWithPeriodIndex(newPeriodIndex));
+  }
+
+  /**
+   * Resolves the specified timeline period and position to a {@link MediaPeriodId} that should be
+   * played, returning an identifier for an ad group if one needs to be played before the specified
+   * position, or an identifier for a content media period if not.
+   *
+   * @param periodIndex The index of the timeline period to play.
+   * @param positionUs The next content position in the period to play.
+   * @return The identifier for the first media period to play, taking into account unplayed ads.
+   */
+  public MediaPeriodId resolveMediaPeriodIdForAds(int periodIndex, long positionUs) {
+    long windowSequenceNumber = resolvePeriodIndexToWindowSequenceNumber(periodIndex);
+    return resolveMediaPeriodIdForAds(periodIndex, positionUs, windowSequenceNumber);
+  }
+
+  // Internal methods.
+
+  /**
+   * Resolves the specified timeline period and position to a {@link MediaPeriodId} that should be
+   * played, returning an identifier for an ad group if one needs to be played before the specified
+   * position, or an identifier for a content media period if not.
+   *
+   * @param periodIndex The index of the timeline period to play.
+   * @param positionUs The next content position in the period to play.
+   * @param windowSequenceNumber The sequence number of the window in the buffered sequence of
+   *     windows this period is part of.
+   * @return The identifier for the first media period to play, taking into account unplayed ads.
+   */
+  private MediaPeriodId resolveMediaPeriodIdForAds(
+      int periodIndex, long positionUs, long windowSequenceNumber) {
+    timeline.getPeriod(periodIndex, period);
+    int adGroupIndex = period.getAdGroupIndexForPositionUs(positionUs);
+    if (adGroupIndex == C.INDEX_UNSET) {
+      return new MediaPeriodId(periodIndex, windowSequenceNumber);
+    } else {
+      int adIndexInAdGroup = period.getFirstAdIndexToPlay(adGroupIndex);
+      return new MediaPeriodId(periodIndex, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
+    }
+  }
+
+  /**
+   * Resolves the specified period index to a corresponding window sequence number. Either by
+   * reusing the window sequence number of an existing matching media period or by creating a new
+   * window sequence number.
+   *
+   * @param periodIndex The index of the timeline period.
+   * @return A window sequence number for a media period created for this timeline period.
+   */
+  private long resolvePeriodIndexToWindowSequenceNumber(int periodIndex) {
+    Object periodUid = timeline.getPeriod(periodIndex, period, /* setIds= */ true).uid;
+    MediaPeriodHolder mediaPeriodHolder = getFrontPeriod();
+    while (mediaPeriodHolder != null) {
+      if (mediaPeriodHolder.uid.equals(periodUid)) {
+        // Reuse window sequence number of first exact period match.
+        return mediaPeriodHolder.info.id.windowSequenceNumber;
+      }
+      mediaPeriodHolder = mediaPeriodHolder.next;
+    }
+    int windowIndex = period.windowIndex;
+    mediaPeriodHolder = getFrontPeriod();
+    while (mediaPeriodHolder != null) {
+      int indexOfHolderInTimeline = timeline.getIndexOfPeriod(mediaPeriodHolder.uid);
+      if (indexOfHolderInTimeline != C.INDEX_UNSET) {
+        int holderWindowIndex = timeline.getPeriod(indexOfHolderInTimeline, period).windowIndex;
+        if (holderWindowIndex == windowIndex) {
+          // As an alternative, try to match other periods of the same window.
+          return mediaPeriodHolder.info.id.windowSequenceNumber;
+        }
+      }
+      mediaPeriodHolder = mediaPeriodHolder.next;
+    }
+    // If no match is found, create new sequence number.
+    return nextWindowSequenceNumber++;
+  }
+
+  /**
+   * Returns whether {@code periodHolder} can be kept for playing the media period described by
+   * {@code info}.
+   */
+  private boolean canKeepMediaPeriodHolder(MediaPeriodHolder periodHolder, MediaPeriodInfo info) {
+    MediaPeriodInfo periodHolderInfo = periodHolder.info;
+    return periodHolderInfo.startPositionUs == info.startPositionUs
+        && periodHolderInfo.endPositionUs == info.endPositionUs
+        && periodHolderInfo.id.equals(info.id);
+  }
+
+  /**
+   * Updates the queue for any playback mode change, and returns whether the change was fully
+   * handled. If not, it is necessary to seek to the current playback position.
+   */
+  private boolean updateForPlaybackModeChange() {
+    // Find the last existing period holder that matches the new period order.
+    MediaPeriodHolder lastValidPeriodHolder = getFrontPeriod();
+    if (lastValidPeriodHolder == null) {
+      return true;
+    }
+    while (true) {
+      int nextPeriodIndex =
+          timeline.getNextPeriodIndex(
+              lastValidPeriodHolder.info.id.periodIndex,
+              period,
+              window,
+              repeatMode,
+              shuffleModeEnabled);
+      while (lastValidPeriodHolder.next != null
+          && !lastValidPeriodHolder.info.isLastInTimelinePeriod) {
+        lastValidPeriodHolder = lastValidPeriodHolder.next;
+      }
+      if (nextPeriodIndex == C.INDEX_UNSET
+          || lastValidPeriodHolder.next == null
+          || lastValidPeriodHolder.next.info.id.periodIndex != nextPeriodIndex) {
+        break;
+      }
+      lastValidPeriodHolder = lastValidPeriodHolder.next;
+    }
+
+    // Release any period holders that don't match the new period order.
+    boolean readingPeriodRemoved = removeAfter(lastValidPeriodHolder);
+
+    // Update the period info for the last holder, as it may now be the last period in the timeline.
+    lastValidPeriodHolder.info =
+        getUpdatedMediaPeriodInfo(lastValidPeriodHolder.info, lastValidPeriodHolder.info.id);
+
+    // If renderers may have read from a period that's been removed, it is necessary to restart.
+    return !readingPeriodRemoved || !hasPlayingPeriod();
+  }
+
+  /**
+   * Returns the first {@link MediaPeriodInfo} to play, based on the specified playback position.
+   */
+  private MediaPeriodInfo getFirstMediaPeriodInfo(PlaybackInfo playbackInfo) {
+    return getMediaPeriodInfo(
+        playbackInfo.periodId, playbackInfo.contentPositionUs, playbackInfo.startPositionUs);
+  }
+
+  /**
+   * Returns the {@link MediaPeriodInfo} for the media period following {@code mediaPeriodHolder}'s
+   * media period.
+   *
+   * @param mediaPeriodHolder The media period holder.
+   * @param rendererPositionUs The current renderer position in microseconds.
+   * @return The following media period's info, or {@code null} if it is not yet possible to get the
+   *     next media period info.
+   */
+  private @Nullable MediaPeriodInfo getFollowingMediaPeriodInfo(
+      MediaPeriodHolder mediaPeriodHolder, long rendererPositionUs) {
+    // TODO: This method is called repeatedly from ExoPlayerImplInternal.maybeUpdateLoadingPeriod
+    // but if the timeline is not ready to provide the next period it can't return a non-null value
+    // until the timeline is updated. Store whether the next timeline period is ready when the
+    // timeline is updated, to avoid repeatedly checking the same timeline.
+    MediaPeriodInfo mediaPeriodInfo = mediaPeriodHolder.info;
+    if (mediaPeriodInfo.isLastInTimelinePeriod) {
+      int nextPeriodIndex =
+          timeline.getNextPeriodIndex(
+              mediaPeriodInfo.id.periodIndex, period, window, repeatMode, shuffleModeEnabled);
+      if (nextPeriodIndex == C.INDEX_UNSET) {
+        // We can't create a next period yet.
+        return null;
+      }
+
+      long startPositionUs;
+      int nextWindowIndex =
+          timeline.getPeriod(nextPeriodIndex, period, /* setIds= */ true).windowIndex;
+      Object nextPeriodUid = period.uid;
+      long windowSequenceNumber = mediaPeriodInfo.id.windowSequenceNumber;
+      if (timeline.getWindow(nextWindowIndex, window).firstPeriodIndex == nextPeriodIndex) {
+        // We're starting to buffer a new window. When playback transitions to this window we'll
+        // want it to be from its default start position. The expected delay until playback
+        // transitions is equal the duration of media that's currently buffered (assuming no
+        // interruptions). Hence we project the default start position forward by the duration of
+        // the buffer, and start buffering from this point.
+        long defaultPositionProjectionUs =
+            mediaPeriodHolder.getRendererOffset() + mediaPeriodInfo.durationUs - rendererPositionUs;
+        Pair<Integer, Long> defaultPosition =
+            timeline.getPeriodPosition(
+                window,
+                period,
+                nextWindowIndex,
+                C.TIME_UNSET,
+                Math.max(0, defaultPositionProjectionUs));
+        if (defaultPosition == null) {
+          return null;
+        }
+        nextPeriodIndex = defaultPosition.first;
+        startPositionUs = defaultPosition.second;
+        if (mediaPeriodHolder.next != null && mediaPeriodHolder.next.uid.equals(nextPeriodUid)) {
+          windowSequenceNumber = mediaPeriodHolder.next.info.id.windowSequenceNumber;
+        } else {
+          windowSequenceNumber = nextWindowSequenceNumber++;
+        }
+      } else {
+        startPositionUs = 0;
+      }
+      MediaPeriodId periodId =
+          resolveMediaPeriodIdForAds(nextPeriodIndex, startPositionUs, windowSequenceNumber);
+      return getMediaPeriodInfo(periodId, startPositionUs, startPositionUs);
+    }
+
+    MediaPeriodId currentPeriodId = mediaPeriodInfo.id;
+    timeline.getPeriod(currentPeriodId.periodIndex, period);
+    if (currentPeriodId.isAd()) {
+      int adGroupIndex = currentPeriodId.adGroupIndex;
+      int adCountInCurrentAdGroup = period.getAdCountInAdGroup(adGroupIndex);
+      if (adCountInCurrentAdGroup == C.LENGTH_UNSET) {
+        return null;
+      }
+      int nextAdIndexInAdGroup =
+          period.getNextAdIndexToPlay(adGroupIndex, currentPeriodId.adIndexInAdGroup);
+      if (nextAdIndexInAdGroup < adCountInCurrentAdGroup) {
+        // Play the next ad in the ad group if it's available.
+        return !period.isAdAvailable(adGroupIndex, nextAdIndexInAdGroup)
+            ? null
+            : getMediaPeriodInfoForAd(
+                currentPeriodId.periodIndex,
+                adGroupIndex,
+                nextAdIndexInAdGroup,
+                mediaPeriodInfo.contentPositionUs,
+                currentPeriodId.windowSequenceNumber);
+      } else {
+        // Play content from the ad group position.
+        return getMediaPeriodInfoForContent(
+            currentPeriodId.periodIndex,
+            mediaPeriodInfo.contentPositionUs,
+            currentPeriodId.windowSequenceNumber);
+      }
+    } else if (mediaPeriodInfo.endPositionUs != C.TIME_END_OF_SOURCE) {
+      // Play the next ad group if it's available.
+      int nextAdGroupIndex = period.getAdGroupIndexForPositionUs(mediaPeriodInfo.endPositionUs);
+      if (nextAdGroupIndex == C.INDEX_UNSET) {
+        // The next ad group can't be played. Play content from the ad group position instead.
+        return getMediaPeriodInfoForContent(
+            currentPeriodId.periodIndex,
+            mediaPeriodInfo.endPositionUs,
+            currentPeriodId.windowSequenceNumber);
+      }
+      int adIndexInAdGroup = period.getFirstAdIndexToPlay(nextAdGroupIndex);
+      return !period.isAdAvailable(nextAdGroupIndex, adIndexInAdGroup)
+          ? null
+          : getMediaPeriodInfoForAd(
+              currentPeriodId.periodIndex,
+              nextAdGroupIndex,
+              adIndexInAdGroup,
+              mediaPeriodInfo.endPositionUs,
+              currentPeriodId.windowSequenceNumber);
+    } else {
+      // Check if the postroll ad should be played.
+      int adGroupCount = period.getAdGroupCount();
+      if (adGroupCount == 0) {
+        return null;
+      }
+      int adGroupIndex = adGroupCount - 1;
+      if (period.getAdGroupTimeUs(adGroupIndex) != C.TIME_END_OF_SOURCE
+          || period.hasPlayedAdGroup(adGroupIndex)) {
+        return null;
+      }
+      int adIndexInAdGroup = period.getFirstAdIndexToPlay(adGroupIndex);
+      if (!period.isAdAvailable(adGroupIndex, adIndexInAdGroup)) {
+        return null;
+      }
+      long contentDurationUs = period.getDurationUs();
+      return getMediaPeriodInfoForAd(
+          currentPeriodId.periodIndex,
+          adGroupIndex,
+          adIndexInAdGroup,
+          contentDurationUs,
+          currentPeriodId.windowSequenceNumber);
+    }
+  }
+
+  private MediaPeriodInfo getUpdatedMediaPeriodInfo(MediaPeriodInfo info, MediaPeriodId newId) {
+    long startPositionUs = info.startPositionUs;
+    long endPositionUs = info.endPositionUs;
+    boolean isLastInPeriod = isLastInPeriod(newId, endPositionUs);
+    boolean isLastInTimeline = isLastInTimeline(newId, isLastInPeriod);
+    timeline.getPeriod(newId.periodIndex, period);
+    long durationUs =
+        newId.isAd()
+            ? period.getAdDurationUs(newId.adGroupIndex, newId.adIndexInAdGroup)
+            : (endPositionUs == C.TIME_END_OF_SOURCE ? period.getDurationUs() : endPositionUs);
+    return new MediaPeriodInfo(
+        newId,
+        startPositionUs,
+        endPositionUs,
+        info.contentPositionUs,
+        durationUs,
+        isLastInPeriod,
+        isLastInTimeline);
+  }
+
+  private MediaPeriodInfo getMediaPeriodInfo(
+      MediaPeriodId id, long contentPositionUs, long startPositionUs) {
+    timeline.getPeriod(id.periodIndex, period);
+    if (id.isAd()) {
+      if (!period.isAdAvailable(id.adGroupIndex, id.adIndexInAdGroup)) {
+        return null;
+      }
+      return getMediaPeriodInfoForAd(
+          id.periodIndex,
+          id.adGroupIndex,
+          id.adIndexInAdGroup,
+          contentPositionUs,
+          id.windowSequenceNumber);
+    } else {
+      return getMediaPeriodInfoForContent(id.periodIndex, startPositionUs, id.windowSequenceNumber);
+    }
+  }
+
+  private MediaPeriodInfo getMediaPeriodInfoForAd(
+      int periodIndex,
+      int adGroupIndex,
+      int adIndexInAdGroup,
+      long contentPositionUs,
+      long windowSequenceNumber) {
+    MediaPeriodId id =
+        new MediaPeriodId(periodIndex, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
+    boolean isLastInPeriod = isLastInPeriod(id, C.TIME_END_OF_SOURCE);
+    boolean isLastInTimeline = isLastInTimeline(id, isLastInPeriod);
+    long durationUs =
+        timeline
+            .getPeriod(id.periodIndex, period)
+            .getAdDurationUs(id.adGroupIndex, id.adIndexInAdGroup);
+    long startPositionUs =
+        adIndexInAdGroup == period.getFirstAdIndexToPlay(adGroupIndex)
+            ? period.getAdResumePositionUs()
+            : 0;
+    return new MediaPeriodInfo(
+        id,
+        startPositionUs,
+        C.TIME_END_OF_SOURCE,
+        contentPositionUs,
+        durationUs,
+        isLastInPeriod,
+        isLastInTimeline);
+  }
+
+  private MediaPeriodInfo getMediaPeriodInfoForContent(
+      int periodIndex, long startPositionUs, long windowSequenceNumber) {
+    MediaPeriodId id = new MediaPeriodId(periodIndex, windowSequenceNumber);
+    timeline.getPeriod(id.periodIndex, period);
+    int nextAdGroupIndex = period.getAdGroupIndexAfterPositionUs(startPositionUs);
+    long endUs =
+        nextAdGroupIndex == C.INDEX_UNSET
+            ? C.TIME_END_OF_SOURCE
+            : period.getAdGroupTimeUs(nextAdGroupIndex);
+    boolean isLastInPeriod = isLastInPeriod(id, endUs);
+    boolean isLastInTimeline = isLastInTimeline(id, isLastInPeriod);
+    long durationUs = endUs == C.TIME_END_OF_SOURCE ? period.getDurationUs() : endUs;
+    return new MediaPeriodInfo(
+        id, startPositionUs, endUs, C.TIME_UNSET, durationUs, isLastInPeriod, isLastInTimeline);
+  }
+
+  private boolean isLastInPeriod(MediaPeriodId id, long endPositionUs) {
+    int adGroupCount = timeline.getPeriod(id.periodIndex, period).getAdGroupCount();
+    if (adGroupCount == 0) {
+      return true;
+    }
+
+    int lastAdGroupIndex = adGroupCount - 1;
+    boolean isAd = id.isAd();
+    if (period.getAdGroupTimeUs(lastAdGroupIndex) != C.TIME_END_OF_SOURCE) {
+      // There's no postroll ad.
+      return !isAd && endPositionUs == C.TIME_END_OF_SOURCE;
+    }
+
+    int postrollAdCount = period.getAdCountInAdGroup(lastAdGroupIndex);
+    if (postrollAdCount == C.LENGTH_UNSET) {
+      // We won't know if this is the last ad until we know how many postroll ads there are.
+      return false;
+    }
+
+    boolean isLastAd =
+        isAd && id.adGroupIndex == lastAdGroupIndex && id.adIndexInAdGroup == postrollAdCount - 1;
+    return isLastAd || (!isAd && period.getFirstAdIndexToPlay(lastAdGroupIndex) == postrollAdCount);
+  }
+
+  private boolean isLastInTimeline(MediaPeriodId id, boolean isLastMediaPeriodInPeriod) {
+    int windowIndex = timeline.getPeriod(id.periodIndex, period).windowIndex;
+    return !timeline.getWindow(windowIndex, window).isDynamic
+        && timeline.isLastPeriod(id.periodIndex, period, window, repeatMode, shuffleModeEnabled)
+        && isLastMediaPeriodInPeriod;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
index 978f4f7a97..593d3d1fce 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/NoSampleRenderer.java
@@ -179,7 +179,7 @@ public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
     return ADAPTIVE_NOT_SUPPORTED;
   }
 
-  // ExoPlayerComponent implementation.
+  // PlayerMessage.Target implementation.
 
   @Override
   public void handleMessage(int what, Object object) throws ExoPlaybackException {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
index a2ffa43c4b..3a4ee0e501 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackInfo.java
@@ -15,7 +15,9 @@
  */
  package com.google.android.exoplayer2;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
 
 /**
  * Information about an ongoing playback.
@@ -23,49 +25,135 @@
 /* package */ final class PlaybackInfo {
 
   public final Timeline timeline;
-  public final Object manifest;
+  public final @Nullable Object manifest;
   public final MediaPeriodId periodId;
   public final long startPositionUs;
   public final long contentPositionUs;
+  public final int playbackState;
+  public final boolean isLoading;
+  public final TrackSelectorResult trackSelectorResult;
 
   public volatile long positionUs;
   public volatile long bufferedPositionUs;
 
-  public PlaybackInfo(Timeline timeline, Object manifest, int periodIndex, long startPositionUs) {
-    this(timeline, manifest, new MediaPeriodId(periodIndex), startPositionUs, C.TIME_UNSET);
+  public PlaybackInfo(
+      Timeline timeline, long startPositionUs, TrackSelectorResult trackSelectorResult) {
+    this(
+        timeline,
+        /* manifest= */ null,
+        new MediaPeriodId(/* periodIndex= */ 0),
+        startPositionUs,
+        /* contentPositionUs =*/ C.TIME_UNSET,
+        Player.STATE_IDLE,
+        /* isLoading= */ false,
+        trackSelectorResult);
   }
 
-  public PlaybackInfo(Timeline timeline, Object manifest, MediaPeriodId periodId,
-      long startPositionUs, long contentPositionUs) {
+  public PlaybackInfo(
+      Timeline timeline,
+      @Nullable Object manifest,
+      MediaPeriodId periodId,
+      long startPositionUs,
+      long contentPositionUs,
+      int playbackState,
+      boolean isLoading,
+      TrackSelectorResult trackSelectorResult) {
     this.timeline = timeline;
     this.manifest = manifest;
     this.periodId = periodId;
     this.startPositionUs = startPositionUs;
     this.contentPositionUs = contentPositionUs;
-    positionUs = startPositionUs;
-    bufferedPositionUs = startPositionUs;
-  }
-
-  public PlaybackInfo fromNewPosition(int periodIndex, long startPositionUs,
-      long contentPositionUs) {
-    return fromNewPosition(new MediaPeriodId(periodIndex), startPositionUs, contentPositionUs);
+    this.positionUs = startPositionUs;
+    this.bufferedPositionUs = startPositionUs;
+    this.playbackState = playbackState;
+    this.isLoading = isLoading;
+    this.trackSelectorResult = trackSelectorResult;
   }
 
   public PlaybackInfo fromNewPosition(MediaPeriodId periodId, long startPositionUs,
       long contentPositionUs) {
-    return new PlaybackInfo(timeline, manifest, periodId, startPositionUs, contentPositionUs);
+    return new PlaybackInfo(
+        timeline,
+        manifest,
+        periodId,
+        startPositionUs,
+        periodId.isAd() ? contentPositionUs : C.TIME_UNSET,
+        playbackState,
+        isLoading,
+        trackSelectorResult);
   }
 
   public PlaybackInfo copyWithPeriodIndex(int periodIndex) {
-    PlaybackInfo playbackInfo = new PlaybackInfo(timeline, manifest,
-        periodId.copyWithPeriodIndex(periodIndex), startPositionUs, contentPositionUs);
+    PlaybackInfo playbackInfo =
+        new PlaybackInfo(
+            timeline,
+            manifest,
+            periodId.copyWithPeriodIndex(periodIndex),
+            startPositionUs,
+            contentPositionUs,
+            playbackState,
+            isLoading,
+            trackSelectorResult);
     copyMutablePositions(this, playbackInfo);
     return playbackInfo;
   }
 
   public PlaybackInfo copyWithTimeline(Timeline timeline, Object manifest) {
-    PlaybackInfo playbackInfo = new PlaybackInfo(timeline, manifest, periodId, startPositionUs,
-        contentPositionUs);
+    PlaybackInfo playbackInfo =
+        new PlaybackInfo(
+            timeline,
+            manifest,
+            periodId,
+            startPositionUs,
+            contentPositionUs,
+            playbackState,
+            isLoading,
+            trackSelectorResult);
+    copyMutablePositions(this, playbackInfo);
+    return playbackInfo;
+  }
+
+  public PlaybackInfo copyWithPlaybackState(int playbackState) {
+    PlaybackInfo playbackInfo =
+        new PlaybackInfo(
+            timeline,
+            manifest,
+            periodId,
+            startPositionUs,
+            contentPositionUs,
+            playbackState,
+            isLoading,
+            trackSelectorResult);
+    copyMutablePositions(this, playbackInfo);
+    return playbackInfo;
+  }
+
+  public PlaybackInfo copyWithIsLoading(boolean isLoading) {
+    PlaybackInfo playbackInfo =
+        new PlaybackInfo(
+            timeline,
+            manifest,
+            periodId,
+            startPositionUs,
+            contentPositionUs,
+            playbackState,
+            isLoading,
+            trackSelectorResult);
+    copyMutablePositions(this, playbackInfo);
+    return playbackInfo;
+  }
+
+  public PlaybackInfo copyWithTrackSelectorResult(TrackSelectorResult trackSelectorResult) {
+    PlaybackInfo playbackInfo =
+        new PlaybackInfo(
+            timeline,
+            manifest,
+            periodId,
+            startPositionUs,
+            contentPositionUs,
+            playbackState,
+            isLoading,
+            trackSelectorResult);
     copyMutablePositions(this, playbackInfo);
     return playbackInfo;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackParameters.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackParameters.java
index 90aded7660..47d5bc88b9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackParameters.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackParameters.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2;
 
+import com.google.android.exoplayer2.util.Assertions;
+
 /**
  * The parameters that apply to playback.
  */
@@ -40,23 +42,25 @@
   /**
    * Creates new playback parameters.
    *
-   * @param speed The factor by which playback will be sped up.
-   * @param pitch The factor by which the audio pitch will be scaled.
+   * @param speed The factor by which playback will be sped up. Must be greater than zero.
+   * @param pitch The factor by which the audio pitch will be scaled. Must be greater than zero.
    */
   public PlaybackParameters(float speed, float pitch) {
+    Assertions.checkArgument(speed > 0);
+    Assertions.checkArgument(pitch > 0);
     this.speed = speed;
     this.pitch = pitch;
     scaledUsPerMs = Math.round(speed * 1000f);
   }
 
   /**
-   * Scales the millisecond duration {@code timeMs} by the playback speed, returning the result in
-   * microseconds.
+   * Returns the media time in microseconds that will elapse in {@code timeMs} milliseconds of
+   * wallclock time.
    *
    * @param timeMs The time to scale, in milliseconds.
    * @return The scaled time, in microseconds.
    */
-  public long getSpeedAdjustedDurationUs(long timeMs) {
+  public long getMediaTimeUsForPlayoutTimeMs(long timeMs) {
     return timeMs * scaledUsPerMs;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlaybackPreparer.java b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackPreparer.java
new file mode 100644
index 0000000000..8ff7f50402
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlaybackPreparer.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+/** Called to prepare a playback. */
+public interface PlaybackPreparer {
+
+  /** Called to prepare a playback. */
+  void preparePlayback();
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Player.java b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
index dc703f924a..443ff8a2ea 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Player.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Player.java
@@ -18,8 +18,14 @@
 import android.os.Looper;
 import android.support.annotation.IntDef;
 import android.support.annotation.Nullable;
+import android.view.Surface;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.TextureView;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.video.VideoListener;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 
@@ -44,6 +50,130 @@
  */
 public interface Player {
 
+  /** The video component of a {@link Player}. */
+  interface VideoComponent {
+
+    /**
+     * Sets the video scaling mode.
+     *
+     * @param videoScalingMode The video scaling mode.
+     */
+    void setVideoScalingMode(@C.VideoScalingMode int videoScalingMode);
+
+    /** Returns the video scaling mode. */
+    @C.VideoScalingMode
+    int getVideoScalingMode();
+
+    /**
+     * Adds a listener to receive video events.
+     *
+     * @param listener The listener to register.
+     */
+    void addVideoListener(VideoListener listener);
+
+    /**
+     * Removes a listener of video events.
+     *
+     * @param listener The listener to unregister.
+     */
+    void removeVideoListener(VideoListener listener);
+
+    /**
+     * Clears any {@link Surface}, {@link SurfaceHolder}, {@link SurfaceView} or {@link TextureView}
+     * currently set on the player.
+     */
+    void clearVideoSurface();
+
+    /**
+     * Sets the {@link Surface} onto which video will be rendered. The caller is responsible for
+     * tracking the lifecycle of the surface, and must clear the surface by calling {@code
+     * setVideoSurface(null)} if the surface is destroyed.
+     *
+     * <p>If the surface is held by a {@link SurfaceView}, {@link TextureView} or {@link
+     * SurfaceHolder} then it's recommended to use {@link #setVideoSurfaceView(SurfaceView)}, {@link
+     * #setVideoTextureView(TextureView)} or {@link #setVideoSurfaceHolder(SurfaceHolder)} rather
+     * than this method, since passing the holder allows the player to track the lifecycle of the
+     * surface automatically.
+     *
+     * @param surface The {@link Surface}.
+     */
+    void setVideoSurface(Surface surface);
+
+    /**
+     * Clears the {@link Surface} onto which video is being rendered if it matches the one passed.
+     * Else does nothing.
+     *
+     * @param surface The surface to clear.
+     */
+    void clearVideoSurface(Surface surface);
+
+    /**
+     * Sets the {@link SurfaceHolder} that holds the {@link Surface} onto which video will be
+     * rendered. The player will track the lifecycle of the surface automatically.
+     *
+     * @param surfaceHolder The surface holder.
+     */
+    void setVideoSurfaceHolder(SurfaceHolder surfaceHolder);
+
+    /**
+     * Clears the {@link SurfaceHolder} that holds the {@link Surface} onto which video is being
+     * rendered if it matches the one passed. Else does nothing.
+     *
+     * @param surfaceHolder The surface holder to clear.
+     */
+    void clearVideoSurfaceHolder(SurfaceHolder surfaceHolder);
+
+    /**
+     * Sets the {@link SurfaceView} onto which video will be rendered. The player will track the
+     * lifecycle of the surface automatically.
+     *
+     * @param surfaceView The surface view.
+     */
+    void setVideoSurfaceView(SurfaceView surfaceView);
+
+    /**
+     * Clears the {@link SurfaceView} onto which video is being rendered if it matches the one
+     * passed. Else does nothing.
+     *
+     * @param surfaceView The texture view to clear.
+     */
+    void clearVideoSurfaceView(SurfaceView surfaceView);
+
+    /**
+     * Sets the {@link TextureView} onto which video will be rendered. The player will track the
+     * lifecycle of the surface automatically.
+     *
+     * @param textureView The texture view.
+     */
+    void setVideoTextureView(TextureView textureView);
+
+    /**
+     * Clears the {@link TextureView} onto which video is being rendered if it matches the one
+     * passed. Else does nothing.
+     *
+     * @param textureView The texture view to clear.
+     */
+    void clearVideoTextureView(TextureView textureView);
+  }
+
+  /** The text component of a {@link Player}. */
+  interface TextComponent {
+
+    /**
+     * Registers an output to receive text events.
+     *
+     * @param listener The output to register.
+     */
+    void addTextOutput(TextOutput listener);
+
+    /**
+     * Removes a text output.
+     *
+     * @param listener The output to remove.
+     */
+    void removeTextOutput(TextOutput listener);
+  }
+
   /**
    * Listener of changes in player state.
    */
@@ -59,8 +189,9 @@
      *
      * @param timeline The latest timeline. Never null, but may be empty.
      * @param manifest The latest manifest. May be null.
+     * @param reason The {@link TimelineChangeReason} responsible for this timeline change.
      */
-    void onTimelineChanged(Timeline timeline, Object manifest);
+    void onTimelineChanged(Timeline timeline, Object manifest, @TimelineChangeReason int reason);
 
     /**
      * Called when the available or selected tracks change.
@@ -118,7 +249,8 @@
      * when the source introduces a discontinuity internally).
      * <p>
      * When a position discontinuity occurs as a result of a change to the timeline this method is
-     * <em>not</em> called. {@link #onTimelineChanged(Timeline, Object)} is called in this case.
+     * <em>not</em> called. {@link #onTimelineChanged(Timeline, Object, int)} is called in this
+     * case.
      *
      * @param reason The {@link DiscontinuityReason} responsible for the discontinuity.
      */
@@ -149,8 +281,10 @@
   abstract class DefaultEventListener implements EventListener {
 
     @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest) {
-      // Do nothing.
+    public void onTimelineChanged(Timeline timeline, Object manifest,
+        @TimelineChangeReason int reason) {
+      // Call deprecated version. Otherwise, do nothing.
+      onTimelineChanged(timeline, manifest);
     }
 
     @Override
@@ -198,6 +332,15 @@ public void onSeekProcessed() {
       // Do nothing.
     }
 
+    /**
+     * @deprecated Use {@link DefaultEventListener#onTimelineChanged(Timeline, Object, int)}
+     *     instead.
+     */
+    @Deprecated
+    public void onTimelineChanged(Timeline timeline, Object manifest) {
+      // Do nothing.
+    }
+
   }
 
   /**
@@ -238,31 +381,60 @@ public void onSeekProcessed() {
    */
   int REPEAT_MODE_ALL = 2;
 
-  /**
-   * Reasons for position discontinuities.
-   */
+  /** Reasons for position discontinuities. */
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({DISCONTINUITY_REASON_PERIOD_TRANSITION, DISCONTINUITY_REASON_SEEK,
-      DISCONTINUITY_REASON_SEEK_ADJUSTMENT, DISCONTINUITY_REASON_INTERNAL})
+  @IntDef({
+    DISCONTINUITY_REASON_PERIOD_TRANSITION,
+    DISCONTINUITY_REASON_SEEK,
+    DISCONTINUITY_REASON_SEEK_ADJUSTMENT,
+    DISCONTINUITY_REASON_AD_INSERTION,
+    DISCONTINUITY_REASON_INTERNAL
+  })
   public @interface DiscontinuityReason {}
   /**
    * Automatic playback transition from one period in the timeline to the next. The period index may
    * be the same as it was before the discontinuity in case the current period is repeated.
    */
   int DISCONTINUITY_REASON_PERIOD_TRANSITION = 0;
-  /**
-   * Seek within the current period or to another period.
-   */
+  /** Seek within the current period or to another period. */
   int DISCONTINUITY_REASON_SEEK = 1;
   /**
    * Seek adjustment due to being unable to seek to the requested position or because the seek was
    * permitted to be inexact.
    */
   int DISCONTINUITY_REASON_SEEK_ADJUSTMENT = 2;
+  /** Discontinuity to or from an ad within one period in the timeline. */
+  int DISCONTINUITY_REASON_AD_INSERTION = 3;
+  /** Discontinuity introduced internally by the source. */
+  int DISCONTINUITY_REASON_INTERNAL = 4;
+
+  /**
+   * Reasons for timeline and/or manifest changes.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({TIMELINE_CHANGE_REASON_PREPARED, TIMELINE_CHANGE_REASON_RESET,
+      TIMELINE_CHANGE_REASON_DYNAMIC})
+  public @interface TimelineChangeReason {}
   /**
-   * Discontinuity introduced internally by the source.
+   * Timeline and manifest changed as a result of a player initialization with new media.
    */
-  int DISCONTINUITY_REASON_INTERNAL = 3;
+  int TIMELINE_CHANGE_REASON_PREPARED = 0;
+  /**
+   * Timeline and manifest changed as a result of a player reset.
+   */
+  int TIMELINE_CHANGE_REASON_RESET = 1;
+  /**
+   * Timeline or manifest changed as a result of an dynamic update introduced by the played media.
+   */
+  int TIMELINE_CHANGE_REASON_DYNAMIC = 2;
+
+  /** Returns the component of this player for video output, or null if video is not supported. */
+  @Nullable
+  VideoComponent getVideoComponent();
+
+  /** Returns the component of this player for text output, or null if text is not supported. */
+  @Nullable
+  TextComponent getTextComponent();
 
   /**
    * Register a listener to receive events from the player. The listener's methods will be called on
@@ -368,6 +540,8 @@ public void onSeekProcessed() {
    * @param windowIndex The index of the window.
    * @param positionMs The seek position in the specified window, or {@link C#TIME_UNSET} to seek to
    *     the window's default position.
+   * @throws IllegalSeekPositionException If the player has a non-empty timeline and the provided
+   *     {@code windowIndex} is not within the bounds of the current timeline.
    */
   void seekTo(int windowIndex, long positionMs);
 
@@ -394,17 +568,29 @@ public void onSeekProcessed() {
   PlaybackParameters getPlaybackParameters();
 
   /**
-   * Stops playback. Use {@code setPlayWhenReady(false)} rather than this method if the intention
-   * is to pause playback.
-   * <p>
-   * Calling this method will cause the playback state to transition to {@link #STATE_IDLE}. The
+   * Stops playback without resetting the player. Use {@code setPlayWhenReady(false)} rather than
+   * this method if the intention is to pause playback.
+   *
+   * <p>Calling this method will cause the playback state to transition to {@link #STATE_IDLE}. The
    * player instance can still be used, and {@link #release()} must still be called on the player if
    * it's no longer required.
-   * <p>
-   * Calling this method does not reset the playback position.
+   *
+   * <p>Calling this method does not reset the playback position.
    */
   void stop();
 
+  /**
+   * Stops playback and optionally resets the player. Use {@code setPlayWhenReady(false)} rather
+   * than this method if the intention is to pause playback.
+   *
+   * <p>Calling this method will cause the playback state to transition to {@link #STATE_IDLE}. The
+   * player instance can still be used, and {@link #release()} must still be called on the player if
+   * it's no longer required.
+   *
+   * @param reset Whether the player should be reset.
+   */
+  void stop(boolean reset);
+
   /**
    * Releases the player. This method must be called when the player is no longer required. The
    * player must not be used after calling this method.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java b/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java
new file mode 100644
index 0000000000..408cbecaf1
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/PlayerMessage.java
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import android.os.Handler;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.util.Assertions;
+
+/**
+ * Defines a player message which can be sent with a {@link Sender} and received by a {@link
+ * Target}.
+ */
+public final class PlayerMessage {
+
+  /** A target for messages. */
+  public interface Target {
+
+    /**
+     * Handles a message delivered to the target.
+     *
+     * @param messageType The message type.
+     * @param payload The message payload.
+     * @throws ExoPlaybackException If an error occurred whilst handling the message. Should only be
+     *     thrown by targets that handle messages on the playback thread.
+     */
+    void handleMessage(int messageType, Object payload) throws ExoPlaybackException;
+  }
+
+  /** A sender for messages. */
+  public interface Sender {
+
+    /**
+     * Sends a message.
+     *
+     * @param message The message to be sent.
+     */
+    void sendMessage(PlayerMessage message);
+  }
+
+  private final Target target;
+  private final Sender sender;
+  private final Timeline timeline;
+
+  private int type;
+  private Object payload;
+  private Handler handler;
+  private int windowIndex;
+  private long positionMs;
+  private boolean deleteAfterDelivery;
+  private boolean isSent;
+  private boolean isDelivered;
+  private boolean isProcessed;
+
+  /**
+   * Creates a new message.
+   *
+   * @param sender The {@link Sender} used to send the message.
+   * @param target The {@link Target} the message is sent to.
+   * @param timeline The timeline used when setting the position with {@link #setPosition(long)}. If
+   *     set to {@link Timeline#EMPTY}, any position can be specified.
+   * @param defaultWindowIndex The default window index in the {@code timeline} when no other window
+   *     index is specified.
+   * @param defaultHandler The default handler to send the message on when no other handler is
+   *     specified.
+   */
+  public PlayerMessage(
+      Sender sender,
+      Target target,
+      Timeline timeline,
+      int defaultWindowIndex,
+      Handler defaultHandler) {
+    this.sender = sender;
+    this.target = target;
+    this.timeline = timeline;
+    this.handler = defaultHandler;
+    this.windowIndex = defaultWindowIndex;
+    this.positionMs = C.TIME_UNSET;
+    this.deleteAfterDelivery = true;
+  }
+
+  /** Returns the timeline used for setting the position with {@link #setPosition(long)}. */
+  public Timeline getTimeline() {
+    return timeline;
+  }
+
+  /** Returns the target the message is sent to. */
+  public Target getTarget() {
+    return target;
+  }
+
+  /**
+   * Sets the message type forwarded to {@link Target#handleMessage(int, Object)}.
+   *
+   * @param messageType The message type.
+   * @return This message.
+   * @throws IllegalStateException If {@link #send()} has already been called.
+   */
+  public PlayerMessage setType(int messageType) {
+    Assertions.checkState(!isSent);
+    this.type = messageType;
+    return this;
+  }
+
+  /** Returns the message type forwarded to {@link Target#handleMessage(int, Object)}. */
+  public int getType() {
+    return type;
+  }
+
+  /**
+   * Sets the message payload forwarded to {@link Target#handleMessage(int, Object)}.
+   *
+   * @param payload The message payload.
+   * @return This message.
+   * @throws IllegalStateException If {@link #send()} has already been called.
+   */
+  public PlayerMessage setPayload(@Nullable Object payload) {
+    Assertions.checkState(!isSent);
+    this.payload = payload;
+    return this;
+  }
+
+  /** Returns the message payload forwarded to {@link Target#handleMessage(int, Object)}. */
+  public Object getPayload() {
+    return payload;
+  }
+
+  /**
+   * Sets the handler the message is delivered on.
+   *
+   * @param handler A {@link Handler}.
+   * @return This message.
+   * @throws IllegalStateException If {@link #send()} has already been called.
+   */
+  public PlayerMessage setHandler(Handler handler) {
+    Assertions.checkState(!isSent);
+    this.handler = handler;
+    return this;
+  }
+
+  /** Returns the handler the message is delivered on. */
+  public Handler getHandler() {
+    return handler;
+  }
+
+  /**
+   * Sets a position in the current window at which the message will be delivered.
+   *
+   * @param positionMs The position in the current window at which the message will be sent, in
+   *     milliseconds.
+   * @return This message.
+   * @throws IllegalStateException If {@link #send()} has already been called.
+   */
+  public PlayerMessage setPosition(long positionMs) {
+    Assertions.checkState(!isSent);
+    this.positionMs = positionMs;
+    return this;
+  }
+
+  /**
+   * Returns position in window at {@link #getWindowIndex()} at which the message will be delivered,
+   * in milliseconds. If {@link C#TIME_UNSET}, the message will be delivered immediately.
+   */
+  public long getPositionMs() {
+    return positionMs;
+  }
+
+  /**
+   * Sets a position in a window at which the message will be delivered.
+   *
+   * @param windowIndex The index of the window at which the message will be sent.
+   * @param positionMs The position in the window with index {@code windowIndex} at which the
+   *     message will be sent, in milliseconds.
+   * @return This message.
+   * @throws IllegalSeekPositionException If the timeline returned by {@link #getTimeline()} is not
+   *     empty and the provided window index is not within the bounds of the timeline.
+   * @throws IllegalStateException If {@link #send()} has already been called.
+   */
+  public PlayerMessage setPosition(int windowIndex, long positionMs) {
+    Assertions.checkState(!isSent);
+    Assertions.checkArgument(positionMs != C.TIME_UNSET);
+    if (windowIndex < 0 || (!timeline.isEmpty() && windowIndex >= timeline.getWindowCount())) {
+      throw new IllegalSeekPositionException(timeline, windowIndex, positionMs);
+    }
+    this.windowIndex = windowIndex;
+    this.positionMs = positionMs;
+    return this;
+  }
+
+  /** Returns window index at which the message will be delivered. */
+  public int getWindowIndex() {
+    return windowIndex;
+  }
+
+  /**
+   * Sets whether the message will be deleted after delivery. If false, the message will be resent
+   * if playback reaches the specified position again. Only allowed to be false if a position is set
+   * with {@link #setPosition(long)}.
+   *
+   * @param deleteAfterDelivery Whether the message is deleted after delivery.
+   * @return This message.
+   * @throws IllegalStateException If {@link #send()} has already been called.
+   */
+  public PlayerMessage setDeleteAfterDelivery(boolean deleteAfterDelivery) {
+    Assertions.checkState(!isSent);
+    this.deleteAfterDelivery = deleteAfterDelivery;
+    return this;
+  }
+
+  /** Returns whether the message will be deleted after delivery. */
+  public boolean getDeleteAfterDelivery() {
+    return deleteAfterDelivery;
+  }
+
+  /**
+   * Sends the message. If the target throws an {@link ExoPlaybackException} then it is propagated
+   * out of the player as an error using {@link
+   * Player.EventListener#onPlayerError(ExoPlaybackException)}.
+   *
+   * @return This message.
+   * @throws IllegalStateException If {@link #send()} has already been called.
+   */
+  public PlayerMessage send() {
+    Assertions.checkState(!isSent);
+    if (positionMs == C.TIME_UNSET) {
+      Assertions.checkArgument(deleteAfterDelivery);
+    }
+    isSent = true;
+    sender.sendMessage(this);
+    return this;
+  }
+
+  /**
+   * Blocks until after the message has been delivered or the player is no longer able to deliver
+   * the message.
+   *
+   * <p>Note that this method can't be called if the current thread is the same thread used by the
+   * message handler set with {@link #setHandler(Handler)} as it would cause a deadlock.
+   *
+   * @return Whether the message was delivered successfully.
+   * @throws IllegalStateException If this method is called before {@link #send()}.
+   * @throws IllegalStateException If this method is called on the same thread used by the message
+   *     handler set with {@link #setHandler(Handler)}.
+   * @throws InterruptedException If the current thread is interrupted while waiting for the message
+   *     to be delivered.
+   */
+  public synchronized boolean blockUntilDelivered() throws InterruptedException {
+    Assertions.checkState(isSent);
+    Assertions.checkState(handler.getLooper().getThread() != Thread.currentThread());
+    while (!isProcessed) {
+      wait();
+    }
+    return isDelivered;
+  }
+
+  /**
+   * Marks the message as processed. Should only be called by a {@link Sender} and may be called
+   * multiple times.
+   *
+   * @param isDelivered Whether the message has been delivered to its target. The message is
+   *     considered as being delivered when this method has been called with {@code isDelivered} set
+   *     to true at least once.
+   */
+  public synchronized void markAsProcessed(boolean isDelivered) {
+    this.isDelivered |= isDelivered;
+    isProcessed = true;
+    notifyAll();
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
index 6def1591da..d0a07930e0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Renderer.java
@@ -15,22 +15,20 @@
  */
 package com.google.android.exoplayer2;
 
-import com.google.android.exoplayer2.ExoPlayer.ExoPlayerComponent;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.util.MediaClock;
 import java.io.IOException;
 
 /**
  * Renders media read from a {@link SampleStream}.
- * <p>
- * Internally, a renderer's lifecycle is managed by the owning {@link ExoPlayer}. The renderer is
+ *
+ * <p>Internally, a renderer's lifecycle is managed by the owning {@link ExoPlayer}. The renderer is
  * transitioned through various states as the overall playback state changes. The valid state
  * transitions are shown below, annotated with the methods that are called during each transition.
- * <p align="center">
- *   <img src="doc-files/renderer-states.svg" alt="Renderer state transitions">
- * </p>
+ *
+ * <p align="center"><img src="doc-files/renderer-states.svg" alt="Renderer state transitions">
  */
-public interface Renderer extends ExoPlayerComponent {
+public interface Renderer extends PlayerMessage.Target {
 
   /**
    * The renderer is disabled.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SeekParameters.java b/library/core/src/main/java/com/google/android/exoplayer2/SeekParameters.java
new file mode 100644
index 0000000000..2df9840cf8
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SeekParameters.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import com.google.android.exoplayer2.util.Assertions;
+
+/**
+ * Parameters that apply to seeking.
+ *
+ * <p>The predefined {@link #EXACT}, {@link #CLOSEST_SYNC}, {@link #PREVIOUS_SYNC} and {@link
+ * #NEXT_SYNC} parameters are suitable for most use cases. Seeking to sync points is typically
+ * faster but less accurate than exact seeking.
+ *
+ * <p>In the general case, an instance specifies a maximum tolerance before ({@link
+ * #toleranceBeforeUs}) and after ({@link #toleranceAfterUs}) a requested seek position ({@code x}).
+ * If one or more sync points falls within the window {@code [x - toleranceBeforeUs, x +
+ * toleranceAfterUs]} then the seek will be performed to the sync point within the window that's
+ * closest to {@code x}. If no sync point falls within the window then the seek will be performed to
+ * {@code x - toleranceBeforeUs}. Internally the player may need to seek to an earlier sync point
+ * and discard media until this position is reached.
+ */
+public final class SeekParameters {
+
+  /** Parameters for exact seeking. */
+  public static final SeekParameters EXACT = new SeekParameters(0, 0);
+  /** Parameters for seeking to the closest sync point. */
+  public static final SeekParameters CLOSEST_SYNC =
+      new SeekParameters(Long.MAX_VALUE, Long.MAX_VALUE);
+  /** Parameters for seeking to the sync point immediately before a requested seek position. */
+  public static final SeekParameters PREVIOUS_SYNC = new SeekParameters(Long.MAX_VALUE, 0);
+  /** Parameters for seeking to the sync point immediately after a requested seek position. */
+  public static final SeekParameters NEXT_SYNC = new SeekParameters(0, Long.MAX_VALUE);
+  /** Default parameters. */
+  public static final SeekParameters DEFAULT = EXACT;
+
+  /**
+   * The maximum time that the actual position seeked to may precede the requested seek position, in
+   * microseconds.
+   */
+  public final long toleranceBeforeUs;
+  /**
+   * The maximum time that the actual position seeked to may exceed the requested seek position, in
+   * microseconds.
+   */
+  public final long toleranceAfterUs;
+
+  /**
+   * @param toleranceBeforeUs The maximum time that the actual position seeked to may precede the
+   *     requested seek position, in microseconds. Must be non-negative.
+   * @param toleranceAfterUs The maximum time that the actual position seeked to may exceed the
+   *     requested seek position, in microseconds. Must be non-negative.
+   */
+  public SeekParameters(long toleranceBeforeUs, long toleranceAfterUs) {
+    Assertions.checkArgument(toleranceBeforeUs >= 0);
+    Assertions.checkArgument(toleranceAfterUs >= 0);
+    this.toleranceBeforeUs = toleranceBeforeUs;
+    this.toleranceAfterUs = toleranceAfterUs;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    SeekParameters other = (SeekParameters) obj;
+    return toleranceBeforeUs == other.toleranceBeforeUs
+        && toleranceAfterUs == other.toleranceAfterUs;
+  }
+
+  @Override
+  public int hashCode() {
+    return (31 * (int) toleranceBeforeUs) + (int) toleranceAfterUs;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
index 5a5a948d58..98ef35d62c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java
@@ -38,8 +38,10 @@
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
 import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.util.Clock;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArraySet;
 
@@ -48,39 +50,11 @@
  * be obtained from {@link ExoPlayerFactory}.
  */
 @TargetApi(16)
-public class SimpleExoPlayer implements ExoPlayer {
+public class SimpleExoPlayer implements ExoPlayer, Player.VideoComponent, Player.TextComponent {
 
-  /**
-   * A listener for video rendering information from a {@link SimpleExoPlayer}.
-   */
-  public interface VideoListener {
-
-    /**
-     * Called each time there's a change in the size of the video being rendered.
-     *
-     * @param width The video width in pixels.
-     * @param height The video height in pixels.
-     * @param unappliedRotationDegrees For videos that require a rotation, this is the clockwise
-     *     rotation in degrees that the application should apply for the video for it to be rendered
-     *     in the correct orientation. This value will always be zero on API levels 21 and above,
-     *     since the renderer will apply all necessary rotations internally. On earlier API levels
-     *     this is not possible. Applications that use {@link android.view.TextureView} can apply
-     *     the rotation by calling {@link android.view.TextureView#setTransform}. Applications that
-     *     do not expect to encounter rotated videos can safely ignore this parameter.
-     * @param pixelWidthHeightRatio The width to height ratio of each pixel. For the normal case
-     *     of square pixels this will be equal to 1.0. Different values are indicative of anamorphic
-     *     content.
-     */
-    void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-        float pixelWidthHeightRatio);
-
-    /**
-     * Called when a frame is rendered for the first time since setting the surface, and when a
-     * frame is rendered for the first time since a video track was selected.
-     */
-    void onRenderedFirstFrame();
-
-  }
+  /** @deprecated Use {@link com.google.android.exoplayer2.video.VideoListener}. */
+  @Deprecated
+  public interface VideoListener extends com.google.android.exoplayer2.video.VideoListener {}
 
   private static final String TAG = "SimpleExoPlayer";
 
@@ -88,11 +62,12 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
 
   private final ExoPlayer player;
   private final ComponentListener componentListener;
-  private final CopyOnWriteArraySet<VideoListener> videoListeners;
+  private final CopyOnWriteArraySet<com.google.android.exoplayer2.video.VideoListener>
+      videoListeners;
   private final CopyOnWriteArraySet<TextOutput> textOutputs;
   private final CopyOnWriteArraySet<MetadataOutput> metadataOutputs;
-  private final int videoRendererCount;
-  private final int audioRendererCount;
+  private final CopyOnWriteArraySet<VideoRendererEventListener> videoDebugListeners;
+  private final CopyOnWriteArraySet<AudioRendererEventListener> audioDebugListeners;
 
   private Format videoFormat;
   private Format audioFormat;
@@ -103,41 +78,45 @@ void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
   private int videoScalingMode;
   private SurfaceHolder surfaceHolder;
   private TextureView textureView;
-  private AudioRendererEventListener audioDebugListener;
-  private VideoRendererEventListener videoDebugListener;
   private DecoderCounters videoDecoderCounters;
   private DecoderCounters audioDecoderCounters;
   private int audioSessionId;
   private AudioAttributes audioAttributes;
   private float audioVolume;
 
-  protected SimpleExoPlayer(RenderersFactory renderersFactory, TrackSelector trackSelector,
-      LoadControl loadControl) {
+  /**
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   */
+  protected SimpleExoPlayer(
+      RenderersFactory renderersFactory, TrackSelector trackSelector, LoadControl loadControl) {
+    this(renderersFactory, trackSelector, loadControl, Clock.DEFAULT);
+  }
+
+  /**
+   * @param renderersFactory A factory for creating {@link Renderer}s to be used by the instance.
+   * @param trackSelector The {@link TrackSelector} that will be used by the instance.
+   * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param clock The {@link Clock} that will be used by the instance. Should always be {@link
+   *     Clock#DEFAULT}, unless the player is being used from a test.
+   */
+  protected SimpleExoPlayer(
+      RenderersFactory renderersFactory,
+      TrackSelector trackSelector,
+      LoadControl loadControl,
+      Clock clock) {
     componentListener = new ComponentListener();
     videoListeners = new CopyOnWriteArraySet<>();
     textOutputs = new CopyOnWriteArraySet<>();
     metadataOutputs = new CopyOnWriteArraySet<>();
+    videoDebugListeners = new CopyOnWriteArraySet<>();
+    audioDebugListeners = new CopyOnWriteArraySet<>();
     Looper eventLooper = Looper.myLooper() != null ? Looper.myLooper() : Looper.getMainLooper();
     Handler eventHandler = new Handler(eventLooper);
     renderers = renderersFactory.createRenderers(eventHandler, componentListener, componentListener,
         componentListener, componentListener);
 
-    // Obtain counts of video and audio renderers.
-    int videoRendererCount = 0;
-    int audioRendererCount = 0;
-    for (Renderer renderer : renderers) {
-      switch (renderer.getTrackType()) {
-        case C.TRACK_TYPE_VIDEO:
-          videoRendererCount++;
-          break;
-        case C.TRACK_TYPE_AUDIO:
-          audioRendererCount++;
-          break;
-      }
-    }
-    this.videoRendererCount = videoRendererCount;
-    this.audioRendererCount = audioRendererCount;
-
     // Set initial values.
     audioVolume = 1;
     audioSessionId = C.AUDIO_SESSION_ID_UNSET;
@@ -145,81 +124,65 @@ protected SimpleExoPlayer(RenderersFactory renderersFactory, TrackSelector track
     videoScalingMode = C.VIDEO_SCALING_MODE_DEFAULT;
 
     // Build the player and associated objects.
-    player = createExoPlayerImpl(renderers, trackSelector, loadControl);
+    player = createExoPlayerImpl(renderers, trackSelector, loadControl, clock);
+  }
+
+  @Override
+  public VideoComponent getVideoComponent() {
+    return this;
+  }
+
+  @Override
+  public TextComponent getTextComponent() {
+    return this;
   }
 
   /**
    * Sets the video scaling mode.
-   * <p>
-   * Note that the scaling mode only applies if a {@link MediaCodec}-based video {@link Renderer} is
-   * enabled and if the output surface is owned by a {@link android.view.SurfaceView}.
+   *
+   * <p>Note that the scaling mode only applies if a {@link MediaCodec}-based video {@link Renderer}
+   * is enabled and if the output surface is owned by a {@link android.view.SurfaceView}.
    *
    * @param videoScalingMode The video scaling mode.
    */
+  @Override
   public void setVideoScalingMode(@C.VideoScalingMode int videoScalingMode) {
     this.videoScalingMode = videoScalingMode;
-    ExoPlayerMessage[] messages = new ExoPlayerMessage[videoRendererCount];
-    int count = 0;
     for (Renderer renderer : renderers) {
       if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
-        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_SCALING_MODE,
-            videoScalingMode);
+        player
+            .createMessage(renderer)
+            .setType(C.MSG_SET_SCALING_MODE)
+            .setPayload(videoScalingMode)
+            .send();
       }
     }
-    player.sendMessages(messages);
   }
 
-  /**
-   * Returns the video scaling mode.
-   */
+  @Override
   public @C.VideoScalingMode int getVideoScalingMode() {
     return videoScalingMode;
   }
 
-  /**
-   * Clears any {@link Surface}, {@link SurfaceHolder}, {@link SurfaceView} or {@link TextureView}
-   * currently set on the player.
-   */
+  @Override
   public void clearVideoSurface() {
     setVideoSurface(null);
   }
 
-  /**
-   * Sets the {@link Surface} onto which video will be rendered. The caller is responsible for
-   * tracking the lifecycle of the surface, and must clear the surface by calling
-   * {@code setVideoSurface(null)} if the surface is destroyed.
-   * <p>
-   * If the surface is held by a {@link SurfaceView}, {@link TextureView} or {@link SurfaceHolder}
-   * then it's recommended to use {@link #setVideoSurfaceView(SurfaceView)},
-   * {@link #setVideoTextureView(TextureView)} or {@link #setVideoSurfaceHolder(SurfaceHolder)}
-   * rather than this method, since passing the holder allows the player to track the lifecycle of
-   * the surface automatically.
-   *
-   * @param surface The {@link Surface}.
-   */
+  @Override
   public void setVideoSurface(Surface surface) {
     removeSurfaceCallbacks();
     setVideoSurfaceInternal(surface, false);
   }
 
-  /**
-   * Clears the {@link Surface} onto which video is being rendered if it matches the one passed.
-   * Else does nothing.
-   *
-   * @param surface The surface to clear.
-   */
+  @Override
   public void clearVideoSurface(Surface surface) {
     if (surface != null && surface == this.surface) {
       setVideoSurface(null);
     }
   }
 
-  /**
-   * Sets the {@link SurfaceHolder} that holds the {@link Surface} onto which video will be
-   * rendered. The player will track the lifecycle of the surface automatically.
-   *
-   * @param surfaceHolder The surface holder.
-   */
+  @Override
   public void setVideoSurfaceHolder(SurfaceHolder surfaceHolder) {
     removeSurfaceCallbacks();
     this.surfaceHolder = surfaceHolder;
@@ -232,44 +195,24 @@ public void setVideoSurfaceHolder(SurfaceHolder surfaceHolder) {
     }
   }
 
-  /**
-   * Clears the {@link SurfaceHolder} that holds the {@link Surface} onto which video is being
-   * rendered if it matches the one passed. Else does nothing.
-   *
-   * @param surfaceHolder The surface holder to clear.
-   */
+  @Override
   public void clearVideoSurfaceHolder(SurfaceHolder surfaceHolder) {
     if (surfaceHolder != null && surfaceHolder == this.surfaceHolder) {
       setVideoSurfaceHolder(null);
     }
   }
 
-  /**
-   * Sets the {@link SurfaceView} onto which video will be rendered. The player will track the
-   * lifecycle of the surface automatically.
-   *
-   * @param surfaceView The surface view.
-   */
+  @Override
   public void setVideoSurfaceView(SurfaceView surfaceView) {
     setVideoSurfaceHolder(surfaceView == null ? null : surfaceView.getHolder());
   }
 
-  /**
-   * Clears the {@link SurfaceView} onto which video is being rendered if it matches the one passed.
-   * Else does nothing.
-   *
-   * @param surfaceView The texture view to clear.
-   */
+  @Override
   public void clearVideoSurfaceView(SurfaceView surfaceView) {
     clearVideoSurfaceHolder(surfaceView == null ? null : surfaceView.getHolder());
   }
 
-  /**
-   * Sets the {@link TextureView} onto which video will be rendered. The player will track the
-   * lifecycle of the surface automatically.
-   *
-   * @param textureView The texture view.
-   */
+  @Override
   public void setVideoTextureView(TextureView textureView) {
     removeSurfaceCallbacks();
     this.textureView = textureView;
@@ -286,12 +229,7 @@ public void setVideoTextureView(TextureView textureView) {
     }
   }
 
-  /**
-   * Clears the {@link TextureView} onto which video is being rendered if it matches the one passed.
-   * Else does nothing.
-   *
-   * @param textureView The texture view to clear.
-   */
+  @Override
   public void clearVideoTextureView(TextureView textureView) {
     if (textureView != null && textureView == this.textureView) {
       setVideoTextureView(null);
@@ -347,15 +285,15 @@ public void setAudioStreamType(@C.StreamType int streamType) {
    */
   public void setAudioAttributes(AudioAttributes audioAttributes) {
     this.audioAttributes = audioAttributes;
-    ExoPlayerMessage[] messages = new ExoPlayerMessage[audioRendererCount];
-    int count = 0;
     for (Renderer renderer : renderers) {
       if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
-        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_AUDIO_ATTRIBUTES,
-            audioAttributes);
+        player
+            .createMessage(renderer)
+            .setType(C.MSG_SET_AUDIO_ATTRIBUTES)
+            .setPayload(audioAttributes)
+            .send();
       }
     }
-    player.sendMessages(messages);
   }
 
   /**
@@ -372,14 +310,11 @@ public AudioAttributes getAudioAttributes() {
    */
   public void setVolume(float audioVolume) {
     this.audioVolume = audioVolume;
-    ExoPlayerMessage[] messages = new ExoPlayerMessage[audioRendererCount];
-    int count = 0;
     for (Renderer renderer : renderers) {
       if (renderer.getTrackType() == C.TRACK_TYPE_AUDIO) {
-        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_VOLUME, audioVolume);
+        player.createMessage(renderer).setType(C.MSG_SET_VOLUME).setPayload(audioVolume).send();
       }
     }
-    player.sendMessages(messages);
   }
 
   /**
@@ -443,21 +378,13 @@ public DecoderCounters getAudioDecoderCounters() {
     return audioDecoderCounters;
   }
 
-  /**
-   * Adds a listener to receive video events.
-   *
-   * @param listener The listener to register.
-   */
-  public void addVideoListener(VideoListener listener) {
+  @Override
+  public void addVideoListener(com.google.android.exoplayer2.video.VideoListener listener) {
     videoListeners.add(listener);
   }
 
-  /**
-   * Removes a listener of video events.
-   *
-   * @param listener The listener to unregister.
-   */
-  public void removeVideoListener(VideoListener listener) {
+  @Override
+  public void removeVideoListener(com.google.android.exoplayer2.video.VideoListener listener) {
     videoListeners.remove(listener);
   }
 
@@ -465,7 +392,7 @@ public void removeVideoListener(VideoListener listener) {
    * Sets a listener to receive video events, removing all existing listeners.
    *
    * @param listener The listener.
-   * @deprecated Use {@link #addVideoListener(VideoListener)}.
+   * @deprecated Use {@link #addVideoListener(com.google.android.exoplayer2.video.VideoListener)}.
    */
   @Deprecated
   public void setVideoListener(VideoListener listener) {
@@ -476,30 +403,23 @@ public void setVideoListener(VideoListener listener) {
   }
 
   /**
-   * Equivalent to {@link #removeVideoListener(VideoListener)}.
+   * Equivalent to {@link #removeVideoListener(com.google.android.exoplayer2.video.VideoListener)}.
    *
    * @param listener The listener to clear.
-   * @deprecated Use {@link #removeVideoListener(VideoListener)}.
+   * @deprecated Use {@link
+   *     #removeVideoListener(com.google.android.exoplayer2.video.VideoListener)}.
    */
   @Deprecated
   public void clearVideoListener(VideoListener listener) {
     removeVideoListener(listener);
   }
 
-  /**
-   * Registers an output to receive text events.
-   *
-   * @param listener The output to register.
-   */
+  @Override
   public void addTextOutput(TextOutput listener) {
     textOutputs.add(listener);
   }
 
-  /**
-   * Removes a text output.
-   *
-   * @param listener The output to remove.
-   */
+  @Override
   public void removeTextOutput(TextOutput listener) {
     textOutputs.remove(listener);
   }
@@ -529,20 +449,10 @@ public void clearTextOutput(TextOutput output) {
     removeTextOutput(output);
   }
 
-  /**
-   * Registers an output to receive metadata events.
-   *
-   * @param listener The output to register.
-   */
   public void addMetadataOutput(MetadataOutput listener) {
     metadataOutputs.add(listener);
   }
 
-  /**
-   * Removes a metadata output.
-   *
-   * @param listener The output to remove.
-   */
   public void removeMetadataOutput(MetadataOutput listener) {
     metadataOutputs.remove(listener);
   }
@@ -576,18 +486,64 @@ public void clearMetadataOutput(MetadataOutput output) {
    * Sets a listener to receive debug events from the video renderer.
    *
    * @param listener The listener.
+   * @deprecated Use {@link #addVideoDebugListener(VideoRendererEventListener)}.
    */
+  @Deprecated
   public void setVideoDebugListener(VideoRendererEventListener listener) {
-    videoDebugListener = listener;
+    videoDebugListeners.clear();
+    if (listener != null) {
+      addVideoDebugListener(listener);
+    }
+  }
+
+  /**
+   * Adds a listener to receive debug events from the video renderer.
+   *
+   * @param listener The listener.
+   */
+  public void addVideoDebugListener(VideoRendererEventListener listener) {
+    videoDebugListeners.add(listener);
+  }
+
+  /**
+   * Removes a listener to receive debug events from the video renderer.
+   *
+   * @param listener The listener.
+   */
+  public void removeVideoDebugListener(VideoRendererEventListener listener) {
+    videoDebugListeners.remove(listener);
   }
 
   /**
    * Sets a listener to receive debug events from the audio renderer.
    *
    * @param listener The listener.
+   * @deprecated Use {@link #addAudioDebugListener(AudioRendererEventListener)}.
    */
+  @Deprecated
   public void setAudioDebugListener(AudioRendererEventListener listener) {
-    audioDebugListener = listener;
+    audioDebugListeners.clear();
+    if (listener != null) {
+      addAudioDebugListener(listener);
+    }
+  }
+
+  /**
+   * Adds a listener to receive debug events from the audio renderer.
+   *
+   * @param listener The listener.
+   */
+  public void addAudioDebugListener(AudioRendererEventListener listener) {
+    audioDebugListeners.add(listener);
+  }
+
+  /**
+   * Removes a listener to receive debug events from the audio renderer.
+   *
+   * @param listener The listener.
+   */
+  public void removeAudioDebugListener(AudioRendererEventListener listener) {
+    audioDebugListeners.remove(listener);
   }
 
   // ExoPlayer implementation
@@ -678,7 +634,7 @@ public void seekTo(int windowIndex, long positionMs) {
   }
 
   @Override
-  public void setPlaybackParameters(PlaybackParameters playbackParameters) {
+  public void setPlaybackParameters(@Nullable PlaybackParameters playbackParameters) {
     player.setPlaybackParameters(playbackParameters);
   }
 
@@ -687,11 +643,21 @@ public PlaybackParameters getPlaybackParameters() {
     return player.getPlaybackParameters();
   }
 
+  @Override
+  public void setSeekParameters(@Nullable SeekParameters seekParameters) {
+    player.setSeekParameters(seekParameters);
+  }
+
   @Override
   public void stop() {
     player.stop();
   }
 
+  @Override
+  public void stop(boolean reset) {
+    player.stop(reset);
+  }
+
   @Override
   public void release() {
     player.release();
@@ -709,6 +675,11 @@ public void sendMessages(ExoPlayerMessage... messages) {
     player.sendMessages(messages);
   }
 
+  @Override
+  public PlayerMessage createMessage(PlayerMessage.Target target) {
+    return player.createMessage(target);
+  }
+
   @Override
   public void blockingSendMessages(ExoPlayerMessage... messages) {
     player.blockingSendMessages(messages);
@@ -817,16 +788,17 @@ public long getContentPosition() {
   // Internal methods.
 
   /**
-   * Creates the ExoPlayer implementation used by this {@link SimpleExoPlayer}.
+   * Creates the {@link ExoPlayer} implementation used by this instance.
    *
    * @param renderers The {@link Renderer}s that will be used by the instance.
    * @param trackSelector The {@link TrackSelector} that will be used by the instance.
    * @param loadControl The {@link LoadControl} that will be used by the instance.
+   * @param clock The {@link Clock} that will be used by this instance.
    * @return A new {@link ExoPlayer} instance.
    */
-  protected ExoPlayer createExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector,
-      LoadControl loadControl) {
-    return new ExoPlayerImpl(renderers, trackSelector, loadControl);
+  protected ExoPlayer createExoPlayerImpl(
+      Renderer[] renderers, TrackSelector trackSelector, LoadControl loadControl, Clock clock) {
+    return new ExoPlayerImpl(renderers, trackSelector, loadControl, clock);
   }
 
   private void removeSurfaceCallbacks() {
@@ -847,22 +819,26 @@ private void removeSurfaceCallbacks() {
   private void setVideoSurfaceInternal(Surface surface, boolean ownsSurface) {
     // Note: We don't turn this method into a no-op if the surface is being replaced with itself
     // so as to ensure onRenderedFirstFrame callbacks are still called in this case.
-    ExoPlayerMessage[] messages = new ExoPlayerMessage[videoRendererCount];
-    int count = 0;
+    List<PlayerMessage> messages = new ArrayList<>();
     for (Renderer renderer : renderers) {
       if (renderer.getTrackType() == C.TRACK_TYPE_VIDEO) {
-        messages[count++] = new ExoPlayerMessage(renderer, C.MSG_SET_SURFACE, surface);
+        messages.add(
+            player.createMessage(renderer).setType(C.MSG_SET_SURFACE).setPayload(surface).send());
       }
     }
     if (this.surface != null && this.surface != surface) {
       // We're replacing a surface. Block to ensure that it's not accessed after the method returns.
-      player.blockingSendMessages(messages);
+      try {
+        for (PlayerMessage message : messages) {
+          message.blockUntilDelivered();
+        }
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
       // If we created the previous surface, we are responsible for releasing it.
       if (this.ownsSurface) {
         this.surface.release();
       }
-    } else {
-      player.sendMessages(messages);
     }
     this.surface = surface;
     this.ownsSurface = ownsSurface;
@@ -877,7 +853,7 @@ private void setVideoSurfaceInternal(Surface surface, boolean ownsSurface) {
     @Override
     public void onVideoEnabled(DecoderCounters counters) {
       videoDecoderCounters = counters;
-      if (videoDebugListener != null) {
+      for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
         videoDebugListener.onVideoEnabled(counters);
       }
     }
@@ -885,7 +861,7 @@ public void onVideoEnabled(DecoderCounters counters) {
     @Override
     public void onVideoDecoderInitialized(String decoderName, long initializedTimestampMs,
         long initializationDurationMs) {
-      if (videoDebugListener != null) {
+      for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
         videoDebugListener.onVideoDecoderInitialized(decoderName, initializedTimestampMs,
             initializationDurationMs);
       }
@@ -894,14 +870,14 @@ public void onVideoDecoderInitialized(String decoderName, long initializedTimest
     @Override
     public void onVideoInputFormatChanged(Format format) {
       videoFormat = format;
-      if (videoDebugListener != null) {
+      for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
         videoDebugListener.onVideoInputFormatChanged(format);
       }
     }
 
     @Override
     public void onDroppedFrames(int count, long elapsed) {
-      if (videoDebugListener != null) {
+      for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
         videoDebugListener.onDroppedFrames(count, elapsed);
       }
     }
@@ -909,11 +885,11 @@ public void onDroppedFrames(int count, long elapsed) {
     @Override
     public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
         float pixelWidthHeightRatio) {
-      for (VideoListener videoListener : videoListeners) {
+      for (com.google.android.exoplayer2.video.VideoListener videoListener : videoListeners) {
         videoListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
             pixelWidthHeightRatio);
       }
-      if (videoDebugListener != null) {
+      for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
         videoDebugListener.onVideoSizeChanged(width, height, unappliedRotationDegrees,
             pixelWidthHeightRatio);
       }
@@ -922,18 +898,18 @@ public void onVideoSizeChanged(int width, int height, int unappliedRotationDegre
     @Override
     public void onRenderedFirstFrame(Surface surface) {
       if (SimpleExoPlayer.this.surface == surface) {
-        for (VideoListener videoListener : videoListeners) {
+        for (com.google.android.exoplayer2.video.VideoListener videoListener : videoListeners) {
           videoListener.onRenderedFirstFrame();
         }
       }
-      if (videoDebugListener != null) {
+      for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
         videoDebugListener.onRenderedFirstFrame(surface);
       }
     }
 
     @Override
     public void onVideoDisabled(DecoderCounters counters) {
-      if (videoDebugListener != null) {
+      for (VideoRendererEventListener videoDebugListener : videoDebugListeners) {
         videoDebugListener.onVideoDisabled(counters);
       }
       videoFormat = null;
@@ -945,7 +921,7 @@ public void onVideoDisabled(DecoderCounters counters) {
     @Override
     public void onAudioEnabled(DecoderCounters counters) {
       audioDecoderCounters = counters;
-      if (audioDebugListener != null) {
+      for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
         audioDebugListener.onAudioEnabled(counters);
       }
     }
@@ -953,7 +929,7 @@ public void onAudioEnabled(DecoderCounters counters) {
     @Override
     public void onAudioSessionId(int sessionId) {
       audioSessionId = sessionId;
-      if (audioDebugListener != null) {
+      for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
         audioDebugListener.onAudioSessionId(sessionId);
       }
     }
@@ -961,7 +937,7 @@ public void onAudioSessionId(int sessionId) {
     @Override
     public void onAudioDecoderInitialized(String decoderName, long initializedTimestampMs,
         long initializationDurationMs) {
-      if (audioDebugListener != null) {
+      for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
         audioDebugListener.onAudioDecoderInitialized(decoderName, initializedTimestampMs,
             initializationDurationMs);
       }
@@ -970,7 +946,7 @@ public void onAudioDecoderInitialized(String decoderName, long initializedTimest
     @Override
     public void onAudioInputFormatChanged(Format format) {
       audioFormat = format;
-      if (audioDebugListener != null) {
+      for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
         audioDebugListener.onAudioInputFormatChanged(format);
       }
     }
@@ -978,14 +954,14 @@ public void onAudioInputFormatChanged(Format format) {
     @Override
     public void onAudioSinkUnderrun(int bufferSize, long bufferSizeMs,
         long elapsedSinceLastFeedMs) {
-      if (audioDebugListener != null) {
+      for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
         audioDebugListener.onAudioSinkUnderrun(bufferSize, bufferSizeMs, elapsedSinceLastFeedMs);
       }
     }
 
     @Override
     public void onAudioDisabled(DecoderCounters counters) {
-      if (audioDebugListener != null) {
+      for (AudioRendererEventListener audioDebugListener : audioDebugListeners) {
         audioDebugListener.onAudioDisabled(counters);
       }
       audioFormat = null;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
index 783278a121..50a3e66880 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/Timeline.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2;
 
 import android.util.Pair;
+import com.google.android.exoplayer2.source.ads.AdPlaybackState;
 import com.google.android.exoplayer2.util.Assertions;
 
 /**
@@ -278,12 +279,7 @@ public long getPositionInFirstPeriodUs() {
     public long durationUs;
 
     private long positionInWindowUs;
-    private long[] adGroupTimesUs;
-    private int[] adCounts;
-    private int[] adsLoadedCounts;
-    private int[] adsPlayedCounts;
-    private long[][] adDurationsUs;
-    private long adResumePositionUs;
+    private AdPlaybackState adPlaybackState;
 
     /**
      * Sets the data held by this period.
@@ -300,8 +296,7 @@ public long getPositionInFirstPeriodUs() {
      */
     public Period set(Object id, Object uid, int windowIndex, long durationUs,
         long positionInWindowUs) {
-      return set(id, uid, windowIndex, durationUs, positionInWindowUs, null, null, null, null,
-          null, C.TIME_UNSET);
+      return set(id, uid, windowIndex, durationUs, positionInWindowUs, AdPlaybackState.NONE);
     }
 
     /**
@@ -315,33 +310,23 @@ public Period set(Object id, Object uid, int windowIndex, long durationUs,
      * @param positionInWindowUs The position of the start of this period relative to the start of
      *     the window to which it belongs, in milliseconds. May be negative if the start of the
      *     period is not within the window.
-     * @param adGroupTimesUs The times of ad groups relative to the start of the period, in
-     *     microseconds. A final element with the value {@link C#TIME_END_OF_SOURCE} indicates that
-     *     the period has a postroll ad.
-     * @param adCounts The number of ads in each ad group. An element may be {@link C#LENGTH_UNSET}
-     *     if the number of ads is not yet known.
-     * @param adsLoadedCounts The number of ads loaded so far in each ad group.
-     * @param adsPlayedCounts The number of ads played so far in each ad group.
-     * @param adDurationsUs The duration of each ad in each ad group, in microseconds. An element
-     *     may be {@link C#TIME_UNSET} if the duration is not yet known.
-     * @param adResumePositionUs The position offset in the first unplayed ad at which to begin
-     *     playback, in microseconds.
+     * @param adPlaybackState The state of the period's ads, or {@link AdPlaybackState#NONE} if
+     *     there are no ads.
      * @return This period, for convenience.
      */
-    public Period set(Object id, Object uid, int windowIndex, long durationUs,
-        long positionInWindowUs, long[] adGroupTimesUs, int[] adCounts, int[] adsLoadedCounts,
-        int[] adsPlayedCounts, long[][] adDurationsUs, long adResumePositionUs) {
+    public Period set(
+        Object id,
+        Object uid,
+        int windowIndex,
+        long durationUs,
+        long positionInWindowUs,
+        AdPlaybackState adPlaybackState) {
       this.id = id;
       this.uid = uid;
       this.windowIndex = windowIndex;
       this.durationUs = durationUs;
       this.positionInWindowUs = positionInWindowUs;
-      this.adGroupTimesUs = adGroupTimesUs;
-      this.adCounts = adCounts;
-      this.adsLoadedCounts = adsLoadedCounts;
-      this.adsPlayedCounts = adsPlayedCounts;
-      this.adDurationsUs = adDurationsUs;
-      this.adResumePositionUs = adResumePositionUs;
+      this.adPlaybackState = adPlaybackState;
       return this;
     }
 
@@ -381,7 +366,7 @@ public long getPositionInWindowUs() {
      * Returns the number of ad groups in the period.
      */
     public int getAdGroupCount() {
-      return adGroupTimesUs == null ? 0 : adGroupTimesUs.length;
+      return adPlaybackState.adGroupCount;
     }
 
     /**
@@ -392,17 +377,33 @@ public int getAdGroupCount() {
      * @return The time of the ad group at the index, in microseconds.
      */
     public long getAdGroupTimeUs(int adGroupIndex) {
-      return adGroupTimesUs[adGroupIndex];
+      return adPlaybackState.adGroupTimesUs[adGroupIndex];
+    }
+
+    /**
+     * Returns the index of the first ad in the specified ad group that should be played, or the
+     * number of ads in the ad group if no ads should be played.
+     *
+     * @param adGroupIndex The ad group index.
+     * @return The index of the first ad that should be played, or the number of ads in the ad group
+     *     if no ads should be played.
+     */
+    public int getFirstAdIndexToPlay(int adGroupIndex) {
+      return adPlaybackState.adGroups[adGroupIndex].getFirstAdIndexToPlay();
     }
 
     /**
-     * Returns the number of ads that have been played in the specified ad group in the period.
+     * Returns the index of the next ad in the specified ad group that should be played after
+     * playing {@code adIndexInAdGroup}, or the number of ads in the ad group if no later ads should
+     * be played.
      *
      * @param adGroupIndex The ad group index.
-     * @return The number of ads that have been played.
+     * @param lastPlayedAdIndex The last played ad index in the ad group.
+     * @return The index of the next ad that should be played, or the number of ads in the ad group
+     *     if the ad group does not have any ads remaining to play.
      */
-    public int getPlayedAdCount(int adGroupIndex) {
-      return adsPlayedCounts[adGroupIndex];
+    public int getNextAdIndexToPlay(int adGroupIndex, int lastPlayedAdIndex) {
+      return adPlaybackState.adGroups[adGroupIndex].getNextAdIndexToPlay(lastPlayedAdIndex);
     }
 
     /**
@@ -412,51 +413,30 @@ public int getPlayedAdCount(int adGroupIndex) {
      * @return Whether the ad group at index {@code adGroupIndex} has been played.
      */
     public boolean hasPlayedAdGroup(int adGroupIndex) {
-      return adCounts[adGroupIndex] != C.INDEX_UNSET
-          && adsPlayedCounts[adGroupIndex] == adCounts[adGroupIndex];
+      return !adPlaybackState.adGroups[adGroupIndex].hasUnplayedAds();
     }
 
     /**
      * Returns the index of the ad group at or before {@code positionUs}, if that ad group is
-     * unplayed. Returns {@link C#INDEX_UNSET} if the ad group before {@code positionUs} has been
-     * played, or if there is no such ad group.
+     * unplayed. Returns {@link C#INDEX_UNSET} if the ad group at or before {@code positionUs} has
+     * no ads remaining to be played, or if there is no such ad group.
      *
      * @param positionUs The position at or before which to find an ad group, in microseconds.
      * @return The index of the ad group, or {@link C#INDEX_UNSET}.
      */
     public int getAdGroupIndexForPositionUs(long positionUs) {
-      if (adGroupTimesUs == null) {
-        return C.INDEX_UNSET;
-      }
-      // Use a linear search as the array elements may not be increasing due to TIME_END_OF_SOURCE.
-      // In practice we expect there to be few ad groups so the search shouldn't be expensive.
-      int index = adGroupTimesUs.length - 1;
-      while (index >= 0 && (adGroupTimesUs[index] == C.TIME_END_OF_SOURCE
-          || adGroupTimesUs[index] > positionUs)) {
-        index--;
-      }
-      return index >= 0 && !hasPlayedAdGroup(index) ? index : C.INDEX_UNSET;
+      return adPlaybackState.getAdGroupIndexForPositionUs(positionUs);
     }
 
     /**
-     * Returns the index of the next unplayed ad group after {@code positionUs}. Returns
-     * {@link C#INDEX_UNSET} if there is no such ad group.
+     * Returns the index of the next ad group after {@code positionUs} that has ads remaining to be
+     * played. Returns {@link C#INDEX_UNSET} if there is no such ad group.
      *
      * @param positionUs The position after which to find an ad group, in microseconds.
      * @return The index of the ad group, or {@link C#INDEX_UNSET}.
      */
     public int getAdGroupIndexAfterPositionUs(long positionUs) {
-      if (adGroupTimesUs == null) {
-        return C.INDEX_UNSET;
-      }
-      // Use a linear search as the array elements may not be increasing due to TIME_END_OF_SOURCE.
-      // In practice we expect there to be few ad groups so the search shouldn't be expensive.
-      int index = 0;
-      while (index < adGroupTimesUs.length && adGroupTimesUs[index] != C.TIME_END_OF_SOURCE
-          && (positionUs >= adGroupTimesUs[index] || hasPlayedAdGroup(index))) {
-        index++;
-      }
-      return index < adGroupTimesUs.length ? index : C.INDEX_UNSET;
+      return adPlaybackState.getAdGroupIndexAfterPositionUs(positionUs);
     }
 
     /**
@@ -467,7 +447,7 @@ public int getAdGroupIndexAfterPositionUs(long positionUs) {
      * @return The number of ads in the ad group, or {@link C#LENGTH_UNSET} if not yet known.
      */
     public int getAdCountInAdGroup(int adGroupIndex) {
-      return adCounts[adGroupIndex];
+      return adPlaybackState.adGroups[adGroupIndex].count;
     }
 
     /**
@@ -478,7 +458,9 @@ public int getAdCountInAdGroup(int adGroupIndex) {
      * @return Whether the URL for the specified ad is known.
      */
     public boolean isAdAvailable(int adGroupIndex, int adIndexInAdGroup) {
-      return adIndexInAdGroup < adsLoadedCounts[adGroupIndex];
+      AdPlaybackState.AdGroup adGroup = adPlaybackState.adGroups[adGroupIndex];
+      return adGroup.count != C.LENGTH_UNSET
+          && adGroup.states[adIndexInAdGroup] != AdPlaybackState.AD_STATE_UNAVAILABLE;
     }
 
     /**
@@ -490,10 +472,8 @@ public boolean isAdAvailable(int adGroupIndex, int adIndexInAdGroup) {
      * @return The duration of the ad, or {@link C#TIME_UNSET} if not yet known.
      */
     public long getAdDurationUs(int adGroupIndex, int adIndexInAdGroup) {
-      if (adIndexInAdGroup >= adDurationsUs[adGroupIndex].length) {
-        return C.TIME_UNSET;
-      }
-      return adDurationsUs[adGroupIndex][adIndexInAdGroup];
+      AdPlaybackState.AdGroup adGroup = adPlaybackState.adGroups[adGroupIndex];
+      return adGroup.count != C.LENGTH_UNSET ? adGroup.durationsUs[adIndexInAdGroup] : C.TIME_UNSET;
     }
 
     /**
@@ -501,7 +481,7 @@ public long getAdDurationUs(int adGroupIndex, int adIndexInAdGroup) {
      * microseconds.
      */
     public long getAdResumePositionUs() {
-      return adResumePositionUs;
+      return adPlaybackState.adResumePositionUs;
     }
 
   }
@@ -710,18 +690,6 @@ public final boolean isLastPeriod(int periodIndex, Period period, Window window,
         == C.INDEX_UNSET;
   }
 
-  /**
-   * Populates a {@link Period} with data for the period at the specified index. Does not populate
-   * {@link Period#id} and {@link Period#uid}.
-   *
-   * @param periodIndex The index of the period.
-   * @param period The {@link Period} to populate. Must not be null.
-   * @return The populated {@link Period}, for convenience.
-   */
-  public final Period getPeriod(int periodIndex, Period period) {
-    return getPeriod(periodIndex, period, false);
-  }
-
   /**
    * Calls {@link #getPeriodPosition(Window, Period, int, long, long)} with a zero default position
    * projection.
@@ -766,6 +734,18 @@ public final Period getPeriod(int periodIndex, Period period) {
     return Pair.create(periodIndex, periodPositionUs);
   }
 
+  /**
+   * Populates a {@link Period} with data for the period at the specified index. Does not populate
+   * {@link Period#id} and {@link Period#uid}.
+   *
+   * @param periodIndex The index of the period.
+   * @param period The {@link Period} to populate. Must not be null.
+   * @return The populated {@link Period}, for convenience.
+   */
+  public final Period getPeriod(int periodIndex, Period period) {
+    return getPeriod(periodIndex, period, false);
+  }
+
   /**
    * Populates a {@link Period} with data for the period at the specified index.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
index e1a70e2579..f45a6a11c6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/Ac3Util.java
@@ -15,6 +15,10 @@
  */
 package com.google.android.exoplayer2.audio;
 
+import static com.google.android.exoplayer2.audio.Ac3Util.Ac3SyncFrameInfo.STREAM_TYPE_TYPE0;
+import static com.google.android.exoplayer2.audio.Ac3Util.Ac3SyncFrameInfo.STREAM_TYPE_TYPE1;
+import static com.google.android.exoplayer2.audio.Ac3Util.Ac3SyncFrameInfo.STREAM_TYPE_UNDEFINED;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
@@ -23,9 +27,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.nio.ByteBuffer;
 
-/**
- * Utility methods for parsing (E-)AC-3 syncframes, which are access units in (E-)AC-3 bitstreams.
- */
+/** Utility methods for parsing Dolby TrueHD and (E-)AC3 syncframes. */
 public final class Ac3Util {
 
   /**
@@ -89,6 +91,17 @@ private Ac3SyncFrameInfo(String mimeType, int streamType, int channelCount, int
 
   }
 
+  /**
+   * The number of samples to store in each output chunk when rechunking TrueHD streams. The number
+   * of samples extracted from the container corresponding to one syncframe must be an integer
+   * multiple of this value.
+   */
+  public static final int TRUEHD_RECHUNK_SAMPLE_COUNT = 8;
+  /**
+   * The number of bytes that must be parsed from a TrueHD syncframe to calculate the sample count.
+   */
+  public static final int TRUEHD_SYNCFRAME_PREFIX_LENGTH = 12;
+
   /**
    * The number of new samples per (E-)AC-3 audio block.
    */
@@ -181,7 +194,14 @@ public static Format parseEAc3AnnexFFormat(ParsableByteArray data, String trackI
         channelCount += 2;
       }
     }
-    return Format.createAudioSampleFormat(trackId, MimeTypes.AUDIO_E_AC3, null, Format.NO_VALUE,
+    String mimeType = MimeTypes.AUDIO_E_AC3;
+    if (data.bytesLeft() > 0) {
+      nextByte = data.readUnsignedByte();
+      if ((nextByte & 0x01) != 0) { // flag_ec3_extension_type_a
+        mimeType = MimeTypes.AUDIO_E_AC3_JOC;
+      }
+    }
+    return Format.createAudioSampleFormat(trackId, mimeType, null, Format.NO_VALUE,
         Format.NO_VALUE, channelCount, sampleRate, null, drmInitData, 0, language);
   }
 
@@ -198,29 +218,176 @@ public static Ac3SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {
     boolean isEac3 = data.readBits(5) == 16;
     data.setPosition(initialPosition);
     String mimeType;
-    int streamType = Ac3SyncFrameInfo.STREAM_TYPE_UNDEFINED;
+    int streamType = STREAM_TYPE_UNDEFINED;
     int sampleRate;
     int acmod;
     int frameSize;
     int sampleCount;
+    boolean lfeon;
+    int channelCount;
     if (isEac3) {
-      mimeType = MimeTypes.AUDIO_E_AC3;
+      // Syntax from ETSI TS 102 366 V1.2.1 subsections E.1.2.1 and E.1.2.2.
       data.skipBits(16); // syncword
       streamType = data.readBits(2);
       data.skipBits(3); // substreamid
       frameSize = (data.readBits(11) + 1) * 2;
       int fscod = data.readBits(2);
       int audioBlocks;
+      int numblkscod;
       if (fscod == 3) {
+        numblkscod = 3;
         sampleRate = SAMPLE_RATE_BY_FSCOD2[data.readBits(2)];
         audioBlocks = 6;
       } else {
-        int numblkscod = data.readBits(2);
+        numblkscod = data.readBits(2);
         audioBlocks = BLOCKS_PER_SYNCFRAME_BY_NUMBLKSCOD[numblkscod];
         sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
       }
       sampleCount = AUDIO_SAMPLES_PER_AUDIO_BLOCK * audioBlocks;
       acmod = data.readBits(3);
+      lfeon = data.readBit();
+      channelCount = CHANNEL_COUNT_BY_ACMOD[acmod] + (lfeon ? 1 : 0);
+      data.skipBits(5 + 5); // bsid, dialnorm
+      if (data.readBit()) { // compre
+        data.skipBits(8); // compr
+      }
+      if (acmod == 0) {
+        data.skipBits(5); // dialnorm2
+        if (data.readBit()) { // compr2e
+          data.skipBits(8); // compr2
+        }
+      }
+      if (streamType == STREAM_TYPE_TYPE1 && data.readBit()) { // chanmape
+        data.skipBits(16); // chanmap
+      }
+      if (data.readBit()) { // mixmdate
+        if (acmod > 2) {
+          data.skipBits(2); // dmixmod
+        }
+        if ((acmod & 0x01) != 0 && acmod > 2) {
+          data.skipBits(3 + 3); // ltrtcmixlev, lorocmixlev
+        }
+        if ((acmod & 0x04) != 0) {
+          data.skipBits(6); // ltrtsurmixlev, lorosurmixlev
+        }
+        if (lfeon && data.readBit()) { // lfemixlevcode
+          data.skipBits(5); // lfemixlevcod
+        }
+        if (streamType == STREAM_TYPE_TYPE0) {
+          if (data.readBit()) { // pgmscle
+            data.skipBits(6); //pgmscl
+          }
+          if (acmod == 0 && data.readBit()) { // pgmscl2e
+            data.skipBits(6); // pgmscl2
+          }
+          if (data.readBit()) { // extpgmscle
+            data.skipBits(6); // extpgmscl
+          }
+          int mixdef = data.readBits(2);
+          if (mixdef == 1) {
+            data.skipBits(1 + 1 + 3); // premixcmpsel, drcsrc, premixcmpscl
+          } else if (mixdef == 2) {
+            data.skipBits(12); // mixdata
+          } else if (mixdef == 3) {
+            int mixdeflen = data.readBits(5);
+            if (data.readBit()) { // mixdata2e
+              data.skipBits(1 + 1 + 3); // premixcmpsel, drcsrc, premixcmpscl
+              if (data.readBit()) { // extpgmlscle
+                data.skipBits(4); // extpgmlscl
+              }
+              if (data.readBit()) { // extpgmcscle
+                data.skipBits(4); // extpgmcscl
+              }
+              if (data.readBit()) { // extpgmrscle
+                data.skipBits(4); // extpgmrscl
+              }
+              if (data.readBit()) { // extpgmlsscle
+                data.skipBits(4); // extpgmlsscl
+              }
+              if (data.readBit()) { // extpgmrsscle
+                data.skipBits(4); // extpgmrsscl
+              }
+              if (data.readBit()) { // extpgmlfescle
+                data.skipBits(4); // extpgmlfescl
+              }
+              if (data.readBit()) { // dmixscle
+                data.skipBits(4); // dmixscl
+              }
+              if (data.readBit()) { // addche
+                if (data.readBit()) { // extpgmaux1scle
+                  data.skipBits(4); // extpgmaux1scl
+                }
+                if (data.readBit()) { // extpgmaux2scle
+                  data.skipBits(4); // extpgmaux2scl
+                }
+              }
+            }
+            if (data.readBit()) { // mixdata3e
+              data.skipBits(5); // spchdat
+              if (data.readBit()) { // addspchdate
+                data.skipBits(5 + 2); // spchdat1, spchan1att
+                if (data.readBit()) { // addspdat1e
+                  data.skipBits(5 + 3); // spchdat2, spchan2att
+                }
+              }
+            }
+            data.skipBits(8 * (mixdeflen + 2)); // mixdata
+            data.byteAlign(); // mixdatafill
+          }
+          if (acmod < 2) {
+            if (data.readBit()) { // paninfoe
+              data.skipBits(8 + 6); // panmean, paninfo
+            }
+            if (acmod == 0) {
+              if (data.readBit()) { // paninfo2e
+                data.skipBits(8 + 6); // panmean2, paninfo2
+              }
+            }
+          }
+          if (data.readBit()) { // frmmixcfginfoe
+            if (numblkscod == 0) {
+              data.skipBits(5); // blkmixcfginfo[0]
+            } else {
+              for (int blk = 0; blk < audioBlocks; blk++) {
+                if (data.readBit()) { // blkmixcfginfoe
+                  data.skipBits(5); // blkmixcfginfo[blk]
+                }
+              }
+            }
+          }
+        }
+      }
+      if (data.readBit()) { // infomdate
+        data.skipBits(3 + 1 + 1); // bsmod, copyrightb, origbs
+        if (acmod == 2) {
+          data.skipBits(2 + 2); // dsurmod, dheadphonmod
+        }
+        if (acmod >= 6) {
+          data.skipBits(2); // dsurexmod
+        }
+        if (data.readBit()) { // audioprodie
+          data.skipBits(5 + 2 + 1); // mixlevel, roomtyp, adconvtyp
+        }
+        if (acmod == 0 && data.readBit()) { // audioprodi2e
+          data.skipBits(5 + 2 + 1); // mixlevel2, roomtyp2, adconvtyp2
+        }
+        if (fscod < 3) {
+          data.skipBit(); // sourcefscod
+        }
+      }
+      if (streamType == 0 && numblkscod != 3) {
+        data.skipBit(); // convsync
+      }
+      if (streamType == 2 && (numblkscod == 3 || data.readBit())) { // blkid
+        data.skipBits(6); // frmsizecod
+      }
+      mimeType = MimeTypes.AUDIO_E_AC3;
+      if (data.readBit()) { // addbsie
+        int addbsil = data.readBits(6);
+        if (addbsil == 1 && data.readBits(8) == 1) { // addbsi
+          mimeType = MimeTypes.AUDIO_E_AC3_JOC;
+        }
+      }
     } else /* is AC-3 */ {
       mimeType = MimeTypes.AUDIO_AC3;
       data.skipBits(16 + 16); // syncword, crc1
@@ -240,9 +407,9 @@ public static Ac3SyncFrameInfo parseAc3SyncframeInfo(ParsableBitArray data) {
       }
       sampleRate = SAMPLE_RATE_BY_FSCOD[fscod];
       sampleCount = AC3_SYNCFRAME_AUDIO_SAMPLE_COUNT;
+      lfeon = data.readBit();
+      channelCount = CHANNEL_COUNT_BY_ACMOD[acmod] + (lfeon ? 1 : 0);
     }
-    boolean lfeon = data.readBit();
-    int channelCount = CHANNEL_COUNT_BY_ACMOD[acmod] + (lfeon ? 1 : 0);
     return new Ac3SyncFrameInfo(mimeType, streamType, channelCount, sampleRate, frameSize,
         sampleCount);
   }
@@ -283,6 +450,43 @@ public static int parseEAc3SyncframeAudioSampleCount(ByteBuffer buffer) {
         : BLOCKS_PER_SYNCFRAME_BY_NUMBLKSCOD[(buffer.get(buffer.position() + 4) & 0x30) >> 4]);
   }
 
+  /**
+   * Returns the number of audio samples represented by the given TrueHD syncframe, or 0 if the
+   * buffer is not the start of a syncframe.
+   *
+   * @param syncframe The bytes from which to read the syncframe. Must be at least {@link
+   *     #TRUEHD_SYNCFRAME_PREFIX_LENGTH} bytes long.
+   * @return The number of audio samples represented by the syncframe, or 0 if the buffer doesn't
+   *     contain the start of a syncframe.
+   */
+  public static int parseTrueHdSyncframeAudioSampleCount(byte[] syncframe) {
+    // TODO: Link to specification if available.
+    if (syncframe[4] != (byte) 0xF8
+        || syncframe[5] != (byte) 0x72
+        || syncframe[6] != (byte) 0x6F
+        || syncframe[7] != (byte) 0xBA) {
+      return 0;
+    }
+    return 40 << (syncframe[8] & 7);
+  }
+
+  /**
+   * Reads the number of audio samples represented by the given TrueHD syncframe, or 0 if the buffer
+   * is not the start of a syncframe. The buffer's position is not modified.
+   *
+   * @param buffer The {@link ByteBuffer} from which to read the syncframe. Must have at least
+   *     {@link #TRUEHD_SYNCFRAME_PREFIX_LENGTH} bytes remaining.
+   * @return The number of audio samples represented by the syncframe, or 0 if the buffer is not the
+   *     start of a syncframe.
+   */
+  public static int parseTrueHdSyncframeAudioSampleCount(ByteBuffer buffer) {
+    // TODO: Link to specification if available.
+    if (buffer.getInt(buffer.position() + 4) != 0xBA6F72F8) {
+      return 0;
+    }
+    return 40 << (buffer.get(buffer.position() + 8) & 0x07);
+  }
+
   private static int getAc3SyncframeSize(int fscod, int frmsizecod) {
     int halfFrmsizecod = frmsizecod / 2;
     if (fscod < 0 || fscod >= SAMPLE_RATE_BY_FSCOD.length || frmsizecod < 0
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioDecoderException.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioDecoderException.java
index b5ee052924..ac4f632d62 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioDecoderException.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioDecoderException.java
@@ -15,27 +15,21 @@
  */
 package com.google.android.exoplayer2.audio;
 
-/**
- * Thrown when an audio decoder error occurs.
- */
-public abstract class AudioDecoderException extends Exception {
+/** Thrown when an audio decoder error occurs. */
+public class AudioDecoderException extends Exception {
 
-  /**
-   * @param detailMessage The detail message for this exception.
-   */
-  public AudioDecoderException(String detailMessage) {
-    super(detailMessage);
+  /** @param message The detail message for this exception. */
+  public AudioDecoderException(String message) {
+    super(message);
   }
 
   /**
-   * @param detailMessage The detail message for this exception.
-   * @param cause the cause (which is saved for later retrieval by the
-   *     {@link #getCause()} method).  (A <tt>null</tt> value is
-   *     permitted, and indicates that the cause is nonexistent or
-   *     unknown.)
+   * @param message The detail message for this exception.
+   * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method).
+   *     A <tt>null</tt> value is permitted, and indicates that the cause is nonexistent or unknown.
    */
-  public AudioDecoderException(String detailMessage, Throwable cause) {
-    super(detailMessage, cause);
+  public AudioDecoderException(String message, Throwable cause) {
+    super(message, cause);
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
index 5408032907..6bb5bf7d8e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/AudioSink.java
@@ -25,14 +25,13 @@
  * A sink that consumes audio data.
  * <p>
  * Before starting playback, specify the input audio format by calling
- * {@link #configure(String, int, int, int, int, int[], int, int)}.
+ * {@link #configure(int, int, int, int, int[], int, int)}.
  * <p>
  * Call {@link #handleBuffer(ByteBuffer, long)} to write data, and {@link #handleDiscontinuity()}
  * when the data being fed is discontinuous. Call {@link #play()} to start playing the written data.
  * <p>
- * Call {@link #configure(String, int, int, int, int, int[], int, int)} whenever the input format
- * changes. The sink will be reinitialized on the next call to
- * {@link #handleBuffer(ByteBuffer, long)}.
+ * Call {@link #configure(int, int, int, int, int[], int, int)} whenever the input format changes.
+ * The sink will be reinitialized on the next call to {@link #handleBuffer(ByteBuffer, long)}.
  * <p>
  * Call {@link #reset()} to prepare the sink to receive audio data from a new playback position.
  * <p>
@@ -76,7 +75,7 @@
      *
      * @param bufferSize The size of the sink's buffer, in bytes.
      * @param bufferSizeMs The size of the sink's buffer, in milliseconds, if it is configured for
-     *     PCM output. {@link C#TIME_UNSET} if it is configured for passthrough output, as the
+     *     PCM output. {@link C#TIME_UNSET} if it is configured for encoded audio output, as the
      *     buffered media can have a variable bitrate so the duration may be unknown.
      * @param elapsedSinceLastFeedMs The time since the sink was last fed data, in milliseconds.
      */
@@ -166,13 +165,12 @@ public WriteException(int errorCode) {
   void setListener(Listener listener);
 
   /**
-   * Returns whether it's possible to play audio in the specified format using encoded audio
-   * passthrough.
+   * Returns whether it's possible to play audio in the specified encoding.
    *
-   * @param mimeType The format mime type.
-   * @return Whether it's possible to play audio in the format using encoded audio passthrough.
+   * @param encoding The audio encoding.
+   * @return Whether it's possible to play audio in the specified encoding.
    */
-  boolean isPassthroughSupported(String mimeType);
+  boolean isEncodingSupported(@C.Encoding int encoding);
 
   /**
    * Returns the playback position in the stream starting at zero, in microseconds, or
@@ -186,12 +184,9 @@ public WriteException(int errorCode) {
   /**
    * Configures (or reconfigures) the sink.
    *
-   * @param inputMimeType The MIME type of audio data provided in the input buffers.
+   * @param inputEncoding The encoding of audio data provided in the input buffers.
    * @param inputChannelCount The number of channels.
    * @param inputSampleRate The sample rate in Hz.
-   * @param inputPcmEncoding For PCM formats, the encoding used. One of
-   *     {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_16BIT}, {@link C#ENCODING_PCM_24BIT}
-   *     and {@link C#ENCODING_PCM_32BIT}.
    * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
    *     suitable buffer size.
    * @param outputChannels A mapping from input to output channels that is applied to this sink's
@@ -205,9 +200,9 @@ public WriteException(int errorCode) {
    *     immediately preceding the next call to {@link #reset()} or this method.
    * @throws ConfigurationException If an error occurs configuring the sink.
    */
-  void configure(String inputMimeType, int inputChannelCount, int inputSampleRate,
-      @C.PcmEncoding int inputPcmEncoding, int specifiedBufferSize, @Nullable int[] outputChannels,
-      int trimStartSamples, int trimEndSamples) throws ConfigurationException;
+  void configure(@C.Encoding int inputEncoding, int inputChannelCount, int inputSampleRate,
+      int specifiedBufferSize, @Nullable int[] outputChannels, int trimStartSamples,
+      int trimEndSamples) throws ConfigurationException;
 
   /**
    * Starts or resumes consuming audio if initialized.
@@ -228,8 +223,7 @@ void configure(String inputMimeType, int inputChannelCount, int inputSampleRate,
    * Returns whether the data was handled in full. If the data was not handled in full then the same
    * {@link ByteBuffer} must be provided to subsequent calls until it has been fully consumed,
    * except in the case of an intervening call to {@link #reset()} (or to
-   * {@link #configure(String, int, int, int, int, int[], int, int)} that causes the sink to be
-   * reset).
+   * {@link #configure(int, int, int, int, int[], int, int)} that causes the sink to be reset).
    *
    * @param buffer The buffer containing audio data.
    * @param presentationTimeUs The presentation timestamp of the buffer in microseconds.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
index c3f3e32526..50b484b938 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/ChannelMappingAudioProcessor.java
@@ -52,7 +52,7 @@ public ChannelMappingAudioProcessor() {
    * Resets the channel mapping. After calling this method, call {@link #configure(int, int, int)}
    * to start using the new channel map.
    *
-   * @see AudioSink#configure(String, int, int, int, int, int[], int, int)
+   * @see AudioSink#configure(int, int, int, int, int[], int, int)
    */
   public void setChannelMap(int[] outputChannels) {
     pendingOutputChannels = outputChannels;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
index 73c0bc20be..6d12dc66e8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DefaultAudioSink.java
@@ -29,15 +29,14 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.LinkedList;
 
 /**
  * Plays audio data. The implementation delegates to an {@link AudioTrack} and handles playback
@@ -56,11 +55,9 @@
    */
   public static final class InvalidAudioTrackTimestampException extends RuntimeException {
 
-    /**
-     * @param detailMessage The detail message for this exception.
-     */
-    public InvalidAudioTrackTimestampException(String detailMessage) {
-      super(detailMessage);
+    /** @param message The detail message for this exception. */
+    public InvalidAudioTrackTimestampException(String message) {
+      super(message);
     }
 
   }
@@ -167,14 +164,16 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
   public static boolean failOnSpuriousAudioTimestamp = false;
 
   @Nullable private final AudioCapabilities audioCapabilities;
+  private final boolean enableConvertHighResIntPcmToFloat;
   private final ChannelMappingAudioProcessor channelMappingAudioProcessor;
   private final TrimmingAudioProcessor trimmingAudioProcessor;
   private final SonicAudioProcessor sonicAudioProcessor;
-  private final AudioProcessor[] availableAudioProcessors;
+  private final AudioProcessor[] toIntPcmAvailableAudioProcessors;
+  private final AudioProcessor[] toFloatPcmAvailableAudioProcessors;
   private final ConditionVariable releasingConditionVariable;
   private final long[] playheadOffsets;
   private final AudioTrackUtil audioTrackUtil;
-  private final LinkedList<PlaybackParametersCheckpoint> playbackParametersCheckpoints;
+  private final ArrayDeque<PlaybackParametersCheckpoint> playbackParametersCheckpoints;
 
   @Nullable private Listener listener;
   /**
@@ -182,13 +181,15 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
    */
   private AudioTrack keepSessionIdAudioTrack;
   private AudioTrack audioTrack;
+  private boolean isInputPcm;
+  private boolean shouldConvertHighResIntPcmToFloat;
   private int inputSampleRate;
   private int sampleRate;
   private int channelConfig;
-  private @C.Encoding int encoding;
   private @C.Encoding int outputEncoding;
   private AudioAttributes audioAttributes;
-  private boolean passthrough;
+  private boolean processingEnabled;
+  private boolean canApplyPlaybackParameters;
   private int bufferSize;
   private long bufferSizeUs;
 
@@ -244,7 +245,25 @@ public InvalidAudioTrackTimestampException(String detailMessage) {
    */
   public DefaultAudioSink(@Nullable AudioCapabilities audioCapabilities,
       AudioProcessor[] audioProcessors) {
+    this(audioCapabilities, audioProcessors, /* enableConvertHighResIntPcmToFloat= */ false);
+  }
+
+  /**
+   * @param audioCapabilities The audio capabilities for playback on this device. May be null if the
+   *     default capabilities (no encoded audio passthrough support) should be assumed.
+   * @param audioProcessors An array of {@link AudioProcessor}s that will process PCM audio before
+   *     output. May be empty.
+   * @param enableConvertHighResIntPcmToFloat Whether to enable conversion of high resolution
+   *     integer PCM to 32-bit float for output, if possible. Functionality that uses 16-bit integer
+   *     audio processing (for example, speed and pitch adjustment) will not be available when float
+   *     output is in use.
+   */
+  public DefaultAudioSink(
+      @Nullable AudioCapabilities audioCapabilities,
+      AudioProcessor[] audioProcessors,
+      boolean enableConvertHighResIntPcmToFloat) {
     this.audioCapabilities = audioCapabilities;
+    this.enableConvertHighResIntPcmToFloat = enableConvertHighResIntPcmToFloat;
     releasingConditionVariable = new ConditionVariable(true);
     if (Util.SDK_INT >= 18) {
       try {
@@ -262,12 +281,14 @@ public DefaultAudioSink(@Nullable AudioCapabilities audioCapabilities,
     channelMappingAudioProcessor = new ChannelMappingAudioProcessor();
     trimmingAudioProcessor = new TrimmingAudioProcessor();
     sonicAudioProcessor = new SonicAudioProcessor();
-    availableAudioProcessors = new AudioProcessor[4 + audioProcessors.length];
-    availableAudioProcessors[0] = new ResamplingAudioProcessor();
-    availableAudioProcessors[1] = channelMappingAudioProcessor;
-    availableAudioProcessors[2] = trimmingAudioProcessor;
-    System.arraycopy(audioProcessors, 0, availableAudioProcessors, 3, audioProcessors.length);
-    availableAudioProcessors[3 + audioProcessors.length] = sonicAudioProcessor;
+    toIntPcmAvailableAudioProcessors = new AudioProcessor[4 + audioProcessors.length];
+    toIntPcmAvailableAudioProcessors[0] = new ResamplingAudioProcessor();
+    toIntPcmAvailableAudioProcessors[1] = channelMappingAudioProcessor;
+    toIntPcmAvailableAudioProcessors[2] = trimmingAudioProcessor;
+    System.arraycopy(
+        audioProcessors, 0, toIntPcmAvailableAudioProcessors, 3, audioProcessors.length);
+    toIntPcmAvailableAudioProcessors[3 + audioProcessors.length] = sonicAudioProcessor;
+    toFloatPcmAvailableAudioProcessors = new AudioProcessor[] {new FloatResamplingAudioProcessor()};
     playheadOffsets = new long[MAX_PLAYHEAD_OFFSET_COUNT];
     volume = 1.0f;
     startMediaTimeState = START_NOT_SET;
@@ -277,7 +298,7 @@ public DefaultAudioSink(@Nullable AudioCapabilities audioCapabilities,
     drainingAudioProcessorIndex = C.INDEX_UNSET;
     this.audioProcessors = new AudioProcessor[0];
     outputBuffers = new ByteBuffer[0];
-    playbackParametersCheckpoints = new LinkedList<>();
+    playbackParametersCheckpoints = new ArrayDeque<>();
   }
 
   @Override
@@ -286,9 +307,15 @@ public void setListener(Listener listener) {
   }
 
   @Override
-  public boolean isPassthroughSupported(String mimeType) {
-    return audioCapabilities != null
-        && audioCapabilities.supportsEncoding(getEncodingForMimeType(mimeType));
+  public boolean isEncodingSupported(@C.Encoding int encoding) {
+    if (isEncodingPcm(encoding)) {
+      // AudioTrack supports 16-bit integer PCM output in all platform API versions, and float
+      // output from platform API version 21 only. Other integer PCM encodings are resampled by this
+      // sink to 16-bit PCM.
+      return encoding != C.ENCODING_PCM_FLOAT || Util.SDK_INT >= 21;
+    } else {
+      return audioCapabilities != null && audioCapabilities.supportsEncoding(encoding);
+    }
   }
 
   @Override
@@ -331,21 +358,28 @@ public long getCurrentPositionUs(boolean sourceEnded) {
   }
 
   @Override
-  public void configure(String inputMimeType, int inputChannelCount, int inputSampleRate,
-      @C.PcmEncoding int inputPcmEncoding, int specifiedBufferSize, @Nullable int[] outputChannels,
-      int trimStartSamples, int trimEndSamples) throws ConfigurationException {
+  public void configure(@C.Encoding int inputEncoding, int inputChannelCount, int inputSampleRate,
+      int specifiedBufferSize, @Nullable int[] outputChannels, int trimStartSamples,
+      int trimEndSamples) throws ConfigurationException {
+    boolean flush = false;
     this.inputSampleRate = inputSampleRate;
     int channelCount = inputChannelCount;
     int sampleRate = inputSampleRate;
-    @C.Encoding int encoding;
-    boolean passthrough = !MimeTypes.AUDIO_RAW.equals(inputMimeType);
-    boolean flush = false;
-    if (!passthrough) {
-      encoding = inputPcmEncoding;
-      pcmFrameSize = Util.getPcmFrameSize(inputPcmEncoding, channelCount);
+    isInputPcm = isEncodingPcm(inputEncoding);
+    shouldConvertHighResIntPcmToFloat =
+        enableConvertHighResIntPcmToFloat
+            && isEncodingSupported(C.ENCODING_PCM_32BIT)
+            && Util.isEncodingHighResolutionIntegerPcm(inputEncoding);
+    if (isInputPcm) {
+      pcmFrameSize = Util.getPcmFrameSize(inputEncoding, channelCount);
+    }
+    @C.Encoding int encoding = inputEncoding;
+    boolean processingEnabled = isInputPcm && inputEncoding != C.ENCODING_PCM_FLOAT;
+    canApplyPlaybackParameters = processingEnabled && !shouldConvertHighResIntPcmToFloat;
+    if (processingEnabled) {
       trimmingAudioProcessor.setTrimSampleCount(trimStartSamples, trimEndSamples);
       channelMappingAudioProcessor.setChannelMap(outputChannels);
-      for (AudioProcessor audioProcessor : availableAudioProcessors) {
+      for (AudioProcessor audioProcessor : getAvailableAudioProcessors()) {
         try {
           flush |= audioProcessor.configure(sampleRate, channelCount, encoding);
         } catch (AudioProcessor.UnhandledFormatException e) {
@@ -357,11 +391,6 @@ public void configure(String inputMimeType, int inputChannelCount, int inputSamp
           encoding = audioProcessor.getOutputEncoding();
         }
       }
-      if (flush) {
-        resetAudioProcessors();
-      }
-    } else {
-      encoding = getEncodingForMimeType(inputMimeType);
     }
 
     int channelConfig;
@@ -411,11 +440,11 @@ public void configure(String inputMimeType, int inputChannelCount, int inputSamp
 
     // Workaround for Nexus Player not reporting support for mono passthrough.
     // (See [Internal: b/34268671].)
-    if (Util.SDK_INT <= 25 && "fugu".equals(Util.DEVICE) && passthrough && channelCount == 1) {
+    if (Util.SDK_INT <= 25 && "fugu".equals(Util.DEVICE) && !isInputPcm && channelCount == 1) {
       channelConfig = AudioFormat.CHANNEL_OUT_STEREO;
     }
 
-    if (!flush && isInitialized() && this.encoding == encoding && this.sampleRate == sampleRate
+    if (!flush && isInitialized() && outputEncoding == encoding && this.sampleRate == sampleRate
         && this.channelConfig == channelConfig) {
       // We already have an audio track with the correct sample rate, channel config and encoding.
       return;
@@ -423,45 +452,44 @@ public void configure(String inputMimeType, int inputChannelCount, int inputSamp
 
     reset();
 
-    this.encoding = encoding;
-    this.passthrough = passthrough;
+    this.processingEnabled = processingEnabled;
     this.sampleRate = sampleRate;
     this.channelConfig = channelConfig;
-    outputEncoding = passthrough ? encoding : C.ENCODING_PCM_16BIT;
-    outputPcmFrameSize = Util.getPcmFrameSize(C.ENCODING_PCM_16BIT, channelCount);
-
+    outputEncoding = encoding;
+    if (isInputPcm) {
+      outputPcmFrameSize = Util.getPcmFrameSize(outputEncoding, channelCount);
+    }
     if (specifiedBufferSize != 0) {
       bufferSize = specifiedBufferSize;
-    } else if (passthrough) {
+    } else if (isInputPcm) {
+      int minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, outputEncoding);
+      Assertions.checkState(minBufferSize != ERROR_BAD_VALUE);
+      int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
+      int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * outputPcmFrameSize;
+      int maxAppBufferSize = (int) Math.max(minBufferSize,
+          durationUsToFrames(MAX_BUFFER_DURATION_US) * outputPcmFrameSize);
+      bufferSize = Util.constrainValue(multipliedBufferSize, minAppBufferSize, maxAppBufferSize);
+    } else {
       // TODO: Set the minimum buffer size using getMinBufferSize when it takes the encoding into
       // account. [Internal: b/25181305]
       if (outputEncoding == C.ENCODING_AC3 || outputEncoding == C.ENCODING_E_AC3) {
         // AC-3 allows bitrates up to 640 kbit/s.
         bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 80 * 1024 / C.MICROS_PER_SECOND);
-      } else /* (outputEncoding == C.ENCODING_DTS || outputEncoding == C.ENCODING_DTS_HD */ {
+      } else if (outputEncoding == C.ENCODING_DTS) {
         // DTS allows an 'open' bitrate, but we assume the maximum listed value: 1536 kbit/s.
         bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 192 * 1024 / C.MICROS_PER_SECOND);
+      } else /* outputEncoding == C.ENCODING_DTS_HD || outputEncoding == C.ENCODING_DOLBY_TRUEHD*/ {
+        // HD passthrough requires a larger buffer to avoid underrun.
+        bufferSize = (int) (PASSTHROUGH_BUFFER_DURATION_US * 192 * 6 * 1024 / C.MICROS_PER_SECOND);
       }
-    } else {
-      int minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, outputEncoding);
-      Assertions.checkState(minBufferSize != ERROR_BAD_VALUE);
-      int multipliedBufferSize = minBufferSize * BUFFER_MULTIPLICATION_FACTOR;
-      int minAppBufferSize = (int) durationUsToFrames(MIN_BUFFER_DURATION_US) * outputPcmFrameSize;
-      int maxAppBufferSize = (int) Math.max(minBufferSize,
-          durationUsToFrames(MAX_BUFFER_DURATION_US) * outputPcmFrameSize);
-      bufferSize = multipliedBufferSize < minAppBufferSize ? minAppBufferSize
-          : multipliedBufferSize > maxAppBufferSize ? maxAppBufferSize
-          : multipliedBufferSize;
     }
-    bufferSizeUs = passthrough ? C.TIME_UNSET : framesToDurationUs(bufferSize / outputPcmFrameSize);
-
-    // The old playback parameters may no longer be applicable so try to reset them now.
-    setPlaybackParameters(playbackParameters);
+    bufferSizeUs =
+        isInputPcm ? framesToDurationUs(bufferSize / outputPcmFrameSize) : C.TIME_UNSET;
   }
 
   private void resetAudioProcessors() {
     ArrayList<AudioProcessor> newAudioProcessors = new ArrayList<>();
-    for (AudioProcessor audioProcessor : availableAudioProcessors) {
+    for (AudioProcessor audioProcessor : getAvailableAudioProcessors()) {
       if (audioProcessor.isActive()) {
         newAudioProcessors.add(audioProcessor);
       } else {
@@ -487,6 +515,13 @@ private void initialize() throws InitializationException {
     releasingConditionVariable.block();
 
     audioTrack = initializeAudioTrack();
+
+    // The old playback parameters may no longer be applicable so try to reset them now.
+    setPlaybackParameters(playbackParameters);
+
+    // Flush and reset active audio processors.
+    resetAudioProcessors();
+
     int audioSessionId = audioTrack.getAudioSessionId();
     if (enablePreV21AudioSessionWorkaround) {
       if (Util.SDK_INT < 21) {
@@ -574,9 +609,16 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         return true;
       }
 
-      if (passthrough && framesPerEncodedSample == 0) {
+      if (!isInputPcm && framesPerEncodedSample == 0) {
         // If this is the first encoded sample, calculate the sample size in frames.
         framesPerEncodedSample = getFramesPerEncodedSample(outputEncoding, buffer);
+        if (framesPerEncodedSample == 0) {
+          // We still don't know the number of frames per sample, so drop the buffer.
+          // For TrueHD this can occur after some seek operations, as not every sample starts with
+          // a syncframe header. If we chunked samples together so the extracted samples always
+          // started with a syncframe header, the chunks would be too large.
+          return true;
+        }
       }
 
       if (drainingPlaybackParameters != null) {
@@ -618,20 +660,19 @@ public boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs)
         }
       }
 
-      if (passthrough) {
-        submittedEncodedFrames += framesPerEncodedSample;
-      } else {
+      if (isInputPcm) {
         submittedPcmBytes += buffer.remaining();
+      } else {
+        submittedEncodedFrames += framesPerEncodedSample;
       }
 
       inputBuffer = buffer;
     }
 
-    if (passthrough) {
-      // Passthrough buffers are not processed.
-      writeBuffer(inputBuffer, presentationTimeUs);
-    } else {
+    if (processingEnabled) {
       processBuffers(presentationTimeUs);
+    } else {
+      writeBuffer(inputBuffer, presentationTimeUs);
     }
 
     if (!inputBuffer.hasRemaining()) {
@@ -679,10 +720,9 @@ private void processBuffers(long avSyncPresentationTimeUs) throws WriteException
   }
 
   @SuppressWarnings("ReferenceEquality")
-  private boolean writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs)
-      throws WriteException {
+  private void writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs) throws WriteException {
     if (!buffer.hasRemaining()) {
-      return true;
+      return;
     }
     if (outputBuffer != null) {
       Assertions.checkArgument(outputBuffer == buffer);
@@ -701,7 +741,7 @@ private boolean writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs)
     }
     int bytesRemaining = buffer.remaining();
     int bytesWritten = 0;
-    if (Util.SDK_INT < 21) { // passthrough == false
+    if (Util.SDK_INT < 21) { // isInputPcm == true
       // Work out how many bytes we can write without the risk of blocking.
       int bytesPending =
           (int) (writtenPcmBytes - (audioTrackUtil.getPlaybackHeadPosition() * outputPcmFrameSize));
@@ -728,17 +768,15 @@ private boolean writeBuffer(ByteBuffer buffer, long avSyncPresentationTimeUs)
       throw new WriteException(bytesWritten);
     }
 
-    if (!passthrough) {
+    if (isInputPcm) {
       writtenPcmBytes += bytesWritten;
     }
     if (bytesWritten == bytesRemaining) {
-      if (passthrough) {
+      if (!isInputPcm) {
         writtenEncodedFrames += framesPerEncodedSample;
       }
       outputBuffer = null;
-      return true;
     }
-    return false;
   }
 
   @Override
@@ -758,7 +796,7 @@ public void playToEndOfStream() throws WriteException {
   private boolean drainAudioProcessorsToEndOfStream() throws WriteException {
     boolean audioProcessorNeedsEndOfStream = false;
     if (drainingAudioProcessorIndex == C.INDEX_UNSET) {
-      drainingAudioProcessorIndex = passthrough ? audioProcessors.length : 0;
+      drainingAudioProcessorIndex = processingEnabled ? 0 : audioProcessors.length;
       audioProcessorNeedsEndOfStream = true;
     }
     while (drainingAudioProcessorIndex < audioProcessors.length) {
@@ -799,8 +837,7 @@ public boolean hasPendingData() {
 
   @Override
   public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
-    if (passthrough) {
-      // The playback parameters are always the default in passthrough mode.
+    if (isInitialized() && !canApplyPlaybackParameters) {
       this.playbackParameters = PlaybackParameters.DEFAULT;
       return this.playbackParameters;
     }
@@ -955,7 +992,10 @@ public void run() {
   public void release() {
     reset();
     releaseKeepSessionIdAudioTrack();
-    for (AudioProcessor audioProcessor : availableAudioProcessors) {
+    for (AudioProcessor audioProcessor : toIntPcmAvailableAudioProcessors) {
+      audioProcessor.reset();
+    }
+    for (AudioProcessor audioProcessor : toFloatPcmAvailableAudioProcessors) {
       audioProcessor.reset();
     }
     audioSessionId = C.AUDIO_SESSION_ID_UNSET;
@@ -1011,7 +1051,8 @@ private long applySpeedup(long positionUs) {
     }
     // We are playing data at a previous playback speed, so fall back to multiplying by the speed.
     return playbackParametersOffsetUs
-        + (long) ((double) playbackParameters.speed * (positionUs - playbackParametersPositionUs));
+        + Util.getMediaDurationForPlayoutDuration(
+            positionUs - playbackParametersPositionUs, playbackParameters.speed);
   }
 
   /**
@@ -1076,7 +1117,7 @@ private void maybeSampleSyncParams() {
           audioTimestampSet = false;
         }
       }
-      if (getLatencyMethod != null && !passthrough) {
+      if (getLatencyMethod != null && isInputPcm) {
         try {
           // Compute the audio track latency, excluding the latency due to the buffer (leaving
           // latency due to the mixer and audio hardware driver).
@@ -1115,11 +1156,11 @@ private long durationUsToFrames(long durationUs) {
   }
 
   private long getSubmittedFrames() {
-    return passthrough ? submittedEncodedFrames : (submittedPcmBytes / pcmFrameSize);
+    return isInputPcm ? (submittedPcmBytes / pcmFrameSize) : submittedEncodedFrames;
   }
 
   private long getWrittenFrames() {
-    return passthrough ? writtenEncodedFrames : (writtenPcmBytes / outputPcmFrameSize);
+    return isInputPcm ? (writtenPcmBytes / outputPcmFrameSize) : writtenEncodedFrames;
   }
 
   private void resetSyncParams() {
@@ -1212,20 +1253,16 @@ private AudioTrack initializeKeepSessionIdAudioTrack(int audioSessionId) {
         MODE_STATIC, audioSessionId);
   }
 
-  @C.Encoding
-  private static int getEncodingForMimeType(String mimeType) {
-    switch (mimeType) {
-      case MimeTypes.AUDIO_AC3:
-        return C.ENCODING_AC3;
-      case MimeTypes.AUDIO_E_AC3:
-        return C.ENCODING_E_AC3;
-      case MimeTypes.AUDIO_DTS:
-        return C.ENCODING_DTS;
-      case MimeTypes.AUDIO_DTS_HD:
-        return C.ENCODING_DTS_HD;
-      default:
-        return C.ENCODING_INVALID;
-    }
+  private AudioProcessor[] getAvailableAudioProcessors() {
+    return shouldConvertHighResIntPcmToFloat
+        ? toFloatPcmAvailableAudioProcessors
+        : toIntPcmAvailableAudioProcessors;
+  }
+
+  private static boolean isEncodingPcm(@C.Encoding int encoding) {
+    return encoding == C.ENCODING_PCM_8BIT || encoding == C.ENCODING_PCM_16BIT
+        || encoding == C.ENCODING_PCM_24BIT || encoding == C.ENCODING_PCM_32BIT
+        || encoding == C.ENCODING_PCM_FLOAT;
   }
 
   private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffer buffer) {
@@ -1235,6 +1272,9 @@ private static int getFramesPerEncodedSample(@C.Encoding int encoding, ByteBuffe
       return Ac3Util.getAc3SyncframeAudioSampleCount();
     } else if (encoding == C.ENCODING_E_AC3) {
       return Ac3Util.parseEAc3SyncframeAudioSampleCount(buffer);
+    } else if (encoding == C.ENCODING_DOLBY_TRUEHD) {
+      return Ac3Util.parseTrueHdSyncframeAudioSampleCount(buffer)
+          * Ac3Util.TRUEHD_RECHUNK_SAMPLE_COUNT;
     } else {
       throw new IllegalStateException("Unexpected audio encoding: " + encoding);
     }
@@ -1403,7 +1443,7 @@ public long getPlaybackHeadPosition() {
         rawPlaybackHeadPosition += passthroughWorkaroundPauseOffset;
       }
 
-      if (Util.SDK_INT <= 26) {
+      if (Util.SDK_INT <= 28) {
         if (rawPlaybackHeadPosition == 0 && lastRawPlaybackHeadPosition > 0
             && state == PLAYSTATE_PLAYING) {
           // If connecting a Bluetooth audio device fails, the AudioTrack may be left in a state
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java
index 9e9b927fab..dc07b1a646 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/DtsUtil.java
@@ -20,12 +20,22 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableBitArray;
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 
 /**
  * Utility methods for parsing DTS frames.
  */
 public final class DtsUtil {
 
+  private static final int SYNC_VALUE_BE = 0x7FFE8001;
+  private static final int SYNC_VALUE_14B_BE = 0x1FFFE800;
+  private static final int SYNC_VALUE_LE = 0xFE7F0180;
+  private static final int SYNC_VALUE_14B_LE = 0xFF1F00E8;
+  private static final byte FIRST_BYTE_BE = (byte) (SYNC_VALUE_BE >>> 24);
+  private static final byte FIRST_BYTE_14B_BE = (byte) (SYNC_VALUE_14B_BE >>> 24);
+  private static final byte FIRST_BYTE_LE = (byte) (SYNC_VALUE_LE >>> 24);
+  private static final byte FIRST_BYTE_14B_LE = (byte) (SYNC_VALUE_14B_LE >>> 24);
+
   /**
    * Maps AMODE to the number of channels. See ETSI TS 102 114 table 5.4.
    */
@@ -45,6 +55,20 @@
       384, 448, 512, 640, 768, 896, 1024, 1152, 1280, 1536, 1920, 2048, 2304, 2560, 2688, 2816,
       2823, 2944, 3072, 3840, 4096, 6144, 7680};
 
+  /**
+   * Returns whether a given integer matches a DTS sync word. Synchronization and storage modes are
+   * defined in ETSI TS 102 114 V1.1.1 (2002-08), Section 5.3.
+   *
+   * @param word An integer.
+   * @return Whether a given integer matches a DTS sync word.
+   */
+  public static boolean isSyncWord(int word) {
+    return word == SYNC_VALUE_BE
+        || word == SYNC_VALUE_LE
+        || word == SYNC_VALUE_14B_BE
+        || word == SYNC_VALUE_14B_LE;
+  }
+
   /**
    * Returns the DTS format given {@code data} containing the DTS frame according to ETSI TS 102 114
    * subsections 5.3/5.4.
@@ -57,8 +81,8 @@
    */
   public static Format parseDtsFormat(byte[] frame, String trackId, String language,
       DrmInitData drmInitData) {
-    ParsableBitArray frameBits = new ParsableBitArray(frame);
-    frameBits.skipBits(4 * 8 + 1 + 5 + 1 + 7 + 14); // SYNC, FTYPE, SHORT, CPF, NBLKS, FSIZE
+    ParsableBitArray frameBits = getNormalizedFrameHeader(frame);
+    frameBits.skipBits(32 + 1 + 5 + 1 + 7 + 14); // SYNC, FTYPE, SHORT, CPF, NBLKS, FSIZE
     int amode = frameBits.readBits(6);
     int channelCount = CHANNELS_BY_AMODE[amode];
     int sfreq = frameBits.readBits(4);
@@ -79,8 +103,21 @@ public static Format parseDtsFormat(byte[] frame, String trackId, String languag
    * @return The number of audio samples represented by the frame.
    */
   public static int parseDtsAudioSampleCount(byte[] data) {
-    // See ETSI TS 102 114 subsection 5.4.1.
-    int nblks = ((data[4] & 0x01) << 6) | ((data[5] & 0xFC) >> 2);
+    int nblks;
+    switch (data[0]) {
+      case FIRST_BYTE_LE:
+        nblks = ((data[5] & 0x01) << 6) | ((data[4] & 0xFC) >> 2);
+        break;
+      case FIRST_BYTE_14B_LE:
+        nblks = ((data[4] & 0x07) << 4) | ((data[7] & 0x3C) >> 2);
+        break;
+      case FIRST_BYTE_14B_BE:
+        nblks = ((data[5] & 0x07) << 4) | ((data[6] & 0x3C) >> 2);
+        break;
+      default:
+        // We blindly assume FIRST_BYTE_BE if none of the others match.
+        nblks = ((data[4] & 0x01) << 6) | ((data[5] & 0xFC) >> 2);
+    }
     return (nblks + 1) * 32;
   }
 
@@ -94,8 +131,21 @@ public static int parseDtsAudioSampleCount(byte[] data) {
   public static int parseDtsAudioSampleCount(ByteBuffer buffer) {
     // See ETSI TS 102 114 subsection 5.4.1.
     int position = buffer.position();
-    int nblks = ((buffer.get(position + 4) & 0x01) << 6)
-        | ((buffer.get(position + 5) & 0xFC) >> 2);
+    int nblks;
+    switch (buffer.get(position)) {
+      case FIRST_BYTE_LE:
+        nblks = ((buffer.get(position + 5) & 0x01) << 6) | ((buffer.get(position + 4) & 0xFC) >> 2);
+        break;
+      case FIRST_BYTE_14B_LE:
+        nblks = ((buffer.get(position + 4) & 0x07) << 4) | ((buffer.get(position + 7) & 0x3C) >> 2);
+        break;
+      case FIRST_BYTE_14B_BE:
+        nblks = ((buffer.get(position + 5) & 0x07) << 4) | ((buffer.get(position + 6) & 0x3C) >> 2);
+        break;
+      default:
+        // We blindly assume FIRST_BYTE_BE if none of the others match.
+        nblks = ((buffer.get(position + 4) & 0x01) << 6) | ((buffer.get(position + 5) & 0xFC) >> 2);
+    }
     return (nblks + 1) * 32;
   }
 
@@ -106,9 +156,59 @@ public static int parseDtsAudioSampleCount(ByteBuffer buffer) {
    * @return The frame's size in bytes.
    */
   public static int getDtsFrameSize(byte[] data) {
-    return (((data[5] & 0x02) << 12)
-        | ((data[6] & 0xFF) << 4)
-        | ((data[7] & 0xF0) >> 4)) + 1;
+    int fsize;
+    boolean uses14BitPerWord = false;
+    switch (data[0]) {
+      case FIRST_BYTE_14B_BE:
+        fsize = (((data[6] & 0x03) << 12) | ((data[7] & 0xFF) << 4) | ((data[8] & 0x3C) >> 2)) + 1;
+        uses14BitPerWord = true;
+        break;
+      case FIRST_BYTE_LE:
+        fsize = (((data[4] & 0x03) << 12) | ((data[7] & 0xFF) << 4) | ((data[6] & 0xF0) >> 4)) + 1;
+        break;
+      case FIRST_BYTE_14B_LE:
+        fsize = (((data[7] & 0x03) << 12) | ((data[6] & 0xFF) << 4) | ((data[9] & 0x3C) >> 2)) + 1;
+        uses14BitPerWord = true;
+        break;
+      default:
+        // We blindly assume FIRST_BYTE_BE if none of the others match.
+        fsize = (((data[5] & 0x03) << 12) | ((data[6] & 0xFF) << 4) | ((data[7] & 0xF0) >> 4)) + 1;
+    }
+
+    // If the frame is stored in 14-bit mode, adjust the frame size to reflect the actual byte size.
+    return uses14BitPerWord ? fsize * 16 / 14 : fsize;
+  }
+
+  private static ParsableBitArray getNormalizedFrameHeader(byte[] frameHeader) {
+    if (frameHeader[0] == FIRST_BYTE_BE) {
+      // The frame is already 16-bit mode, big endian.
+      return new ParsableBitArray(frameHeader);
+    }
+    // Data is not normalized, but we don't want to modify frameHeader.
+    frameHeader = Arrays.copyOf(frameHeader, frameHeader.length);
+    if (isLittleEndianFrameHeader(frameHeader)) {
+      // Change endianness.
+      for (int i = 0; i < frameHeader.length - 1; i += 2) {
+        byte temp = frameHeader[i];
+        frameHeader[i] = frameHeader[i + 1];
+        frameHeader[i + 1] = temp;
+      }
+    }
+    ParsableBitArray frameBits = new ParsableBitArray(frameHeader);
+    if (frameHeader[0] == (byte) (SYNC_VALUE_14B_BE >> 24)) {
+      // Discard the 2 most significant bits of each 16 bit word.
+      ParsableBitArray scratchBits = new ParsableBitArray(frameHeader);
+      while (scratchBits.bitsLeft() >= 16) {
+        scratchBits.skipBits(2);
+        frameBits.putInt(scratchBits.readBits(14), 14);
+      }
+    }
+    frameBits.reset(frameHeader);
+    return frameBits;
+  }
+
+  private static boolean isLittleEndianFrameHeader(byte[] frameHeader) {
+    return frameHeader[0] == FIRST_BYTE_LE || frameHeader[0] == FIRST_BYTE_14B_LE;
   }
 
   private DtsUtil() {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java
new file mode 100644
index 0000000000..215b04821b
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/FloatResamplingAudioProcessor.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.audio;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/**
+ * An {@link AudioProcessor} that converts 24-bit and 32-bit integer PCM audio to 32-bit float PCM
+ * audio.
+ */
+/* package */ final class FloatResamplingAudioProcessor implements AudioProcessor {
+
+  private static final int FLOAT_NAN_AS_INT = Float.floatToIntBits(Float.NaN);
+  private static final double PCM_32_BIT_INT_TO_PCM_32_BIT_FLOAT_FACTOR = 1.0 / 0x7FFFFFFF;
+
+  private int sampleRateHz;
+  private int channelCount;
+  private @C.PcmEncoding int sourceEncoding;
+  private ByteBuffer buffer;
+  private ByteBuffer outputBuffer;
+  private boolean inputEnded;
+
+  /** Creates a new audio processor that converts audio data to {@link C#ENCODING_PCM_FLOAT}. */
+  public FloatResamplingAudioProcessor() {
+    sampleRateHz = Format.NO_VALUE;
+    channelCount = Format.NO_VALUE;
+    sourceEncoding = C.ENCODING_INVALID;
+    buffer = EMPTY_BUFFER;
+    outputBuffer = EMPTY_BUFFER;
+  }
+
+  @Override
+  public boolean configure(int sampleRateHz, int channelCount, @C.Encoding int encoding)
+      throws UnhandledFormatException {
+    if (!Util.isEncodingHighResolutionIntegerPcm(encoding)) {
+      throw new UnhandledFormatException(sampleRateHz, channelCount, encoding);
+    }
+    if (this.sampleRateHz == sampleRateHz
+        && this.channelCount == channelCount
+        && sourceEncoding == encoding) {
+      return false;
+    }
+    this.sampleRateHz = sampleRateHz;
+    this.channelCount = channelCount;
+    sourceEncoding = encoding;
+    return true;
+  }
+
+  @Override
+  public boolean isActive() {
+    return Util.isEncodingHighResolutionIntegerPcm(sourceEncoding);
+  }
+
+  @Override
+  public int getOutputChannelCount() {
+    return channelCount;
+  }
+
+  @Override
+  public int getOutputEncoding() {
+    return C.ENCODING_PCM_FLOAT;
+  }
+
+  @Override
+  public int getOutputSampleRateHz() {
+    return sampleRateHz;
+  }
+
+  @Override
+  public void queueInput(ByteBuffer inputBuffer) {
+    Assertions.checkState(isActive());
+
+    boolean isInput32Bit = sourceEncoding == C.ENCODING_PCM_32BIT;
+    int position = inputBuffer.position();
+    int limit = inputBuffer.limit();
+    int size = limit - position;
+
+    int resampledSize = isInput32Bit ? size : (size / 3) * 4;
+    if (buffer.capacity() < resampledSize) {
+      buffer = ByteBuffer.allocateDirect(resampledSize).order(ByteOrder.nativeOrder());
+    } else {
+      buffer.clear();
+    }
+    if (isInput32Bit) {
+      for (int i = position; i < limit; i += 4) {
+        int pcm32BitInteger =
+            (inputBuffer.get(i) & 0xFF)
+                | ((inputBuffer.get(i + 1) & 0xFF) << 8)
+                | ((inputBuffer.get(i + 2) & 0xFF) << 16)
+                | ((inputBuffer.get(i + 3) & 0xFF) << 24);
+        writePcm32BitFloat(pcm32BitInteger, buffer);
+      }
+    } else {
+      for (int i = position; i < limit; i += 3) {
+        int pcm32BitInteger =
+            ((inputBuffer.get(i) & 0xFF) << 8)
+                | ((inputBuffer.get(i + 1) & 0xFF) << 16)
+                | ((inputBuffer.get(i + 2) & 0xFF) << 24);
+        writePcm32BitFloat(pcm32BitInteger, buffer);
+      }
+    }
+
+    inputBuffer.position(inputBuffer.limit());
+    buffer.flip();
+    outputBuffer = buffer;
+  }
+
+  @Override
+  public void queueEndOfStream() {
+    inputEnded = true;
+  }
+
+  @Override
+  public ByteBuffer getOutput() {
+    ByteBuffer outputBuffer = this.outputBuffer;
+    this.outputBuffer = EMPTY_BUFFER;
+    return outputBuffer;
+  }
+
+  @SuppressWarnings("ReferenceEquality")
+  @Override
+  public boolean isEnded() {
+    return inputEnded && outputBuffer == EMPTY_BUFFER;
+  }
+
+  @Override
+  public void flush() {
+    outputBuffer = EMPTY_BUFFER;
+    inputEnded = false;
+  }
+
+  @Override
+  public void reset() {
+    flush();
+    buffer = EMPTY_BUFFER;
+    sampleRateHz = Format.NO_VALUE;
+    channelCount = Format.NO_VALUE;
+    sourceEncoding = C.ENCODING_INVALID;
+  }
+
+  /**
+   * Converts the provided 32-bit integer to a 32-bit float value and writes it to {@code buffer}.
+   *
+   * @param pcm32BitInt The 32-bit integer value to convert to 32-bit float in [-1.0, 1.0].
+   * @param buffer The output buffer.
+   */
+  private static void writePcm32BitFloat(int pcm32BitInt, ByteBuffer buffer) {
+    float pcm32BitFloat = (float) (PCM_32_BIT_INT_TO_PCM_32_BIT_FLOAT_FACTOR * pcm32BitInt);
+    int floatBits = Float.floatToIntBits(pcm32BitFloat);
+    if (floatBits == FLOAT_NAN_AS_INT) {
+      floatBits = Float.floatToIntBits((float) 0.0);
+    }
+    buffer.putInt(floatBits);
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
index f8206e94cf..33a67554a5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/MediaCodecAudioRenderer.java
@@ -24,9 +24,12 @@
 import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener.EventDispatcher;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
 import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
@@ -41,6 +44,17 @@
 
 /**
  * Decodes and renders audio using {@link MediaCodec} and an {@link AudioSink}.
+ *
+ * <p>This renderer accepts the following messages sent via {@link ExoPlayer#createMessage(Target)}
+ * on the playback thread:
+ *
+ * <ul>
+ *   <li>Message with type {@link C#MSG_SET_VOLUME} to set the volume. The message payload should be
+ *       a {@link Float} with 0 being silence and 1 being unity gain.
+ *   <li>Message with type {@link C#MSG_SET_AUDIO_ATTRIBUTES} to set the audio attributes. The
+ *       message payload should be an {@link com.google.android.exoplayer2.audio.AudioAttributes}
+ *       instance that will configure the underlying audio track.
+ * </ul>
  */
 @TargetApi(16)
 public class MediaCodecAudioRenderer extends MediaCodecRenderer implements MediaClock {
@@ -51,11 +65,13 @@
   private boolean passthroughEnabled;
   private boolean codecNeedsDiscardChannelsWorkaround;
   private android.media.MediaFormat passthroughMediaFormat;
+  @C.Encoding
   private int pcmEncoding;
   private int channelCount;
   private int encoderDelay;
   private int encoderPadding;
   private long currentPositionUs;
+  private boolean allowFirstBufferPositionDiscontinuity;
   private boolean allowPositionDiscontinuity;
 
   /**
@@ -177,6 +193,11 @@ protected int supportsFormat(MediaCodecSelector mediaCodecSelector,
         && mediaCodecSelector.getPassthroughDecoderInfo() != null) {
       return ADAPTIVE_NOT_SEAMLESS | tunnelingSupport | FORMAT_HANDLED;
     }
+    if ((MimeTypes.AUDIO_RAW.equals(mimeType) && !audioSink.isEncodingSupported(format.pcmEncoding))
+        || !audioSink.isEncodingSupported(C.ENCODING_PCM_16BIT)) {
+      // Assume the decoder outputs 16-bit PCM, unless the input is raw.
+      return FORMAT_UNSUPPORTED_SUBTYPE;
+    }
     boolean requiresSecureDecryption = false;
     DrmInitData drmInitData = format.drmInitData;
     if (drmInitData != null) {
@@ -219,28 +240,30 @@ protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
 
   /**
    * Returns whether encoded audio passthrough should be used for playing back the input format.
-   * This implementation returns true if the {@link AudioSink} indicates that passthrough is
-   * supported.
+   * This implementation returns true if the {@link AudioSink} indicates that encoded audio output
+   * is supported.
    *
    * @param mimeType The type of input media.
    * @return Whether passthrough playback is supported.
    */
   protected boolean allowPassthrough(String mimeType) {
-    return audioSink.isPassthroughSupported(mimeType);
+    @C.Encoding int encoding = MimeTypes.getEncoding(mimeType);
+    return encoding != C.ENCODING_INVALID && audioSink.isEncodingSupported(encoding);
   }
 
   @Override
   protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
       MediaCrypto crypto) {
     codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);
+    MediaFormat mediaFormat = getMediaFormatForPlayback(format);
     if (passthroughEnabled) {
       // Override the MIME type used to configure the codec if we are using a passthrough decoder.
-      passthroughMediaFormat = format.getFrameworkMediaFormatV16();
+      passthroughMediaFormat = mediaFormat;
       passthroughMediaFormat.setString(MediaFormat.KEY_MIME, MimeTypes.AUDIO_RAW);
       codec.configure(passthroughMediaFormat, null, crypto, 0);
       passthroughMediaFormat.setString(MediaFormat.KEY_MIME, format.sampleMimeType);
     } else {
-      codec.configure(format.getFrameworkMediaFormatV16(), null, crypto, 0);
+      codec.configure(mediaFormat, null, crypto, 0);
       passthroughMediaFormat = null;
     }
   }
@@ -272,10 +295,15 @@ protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackExceptio
   @Override
   protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
       throws ExoPlaybackException {
-    boolean passthrough = passthroughMediaFormat != null;
-    String mimeType = passthrough ? passthroughMediaFormat.getString(MediaFormat.KEY_MIME)
-        : MimeTypes.AUDIO_RAW;
-    MediaFormat format = passthrough ? passthroughMediaFormat : outputFormat;
+    @C.Encoding int encoding;
+    MediaFormat format;
+    if (passthroughMediaFormat != null) {
+      encoding = MimeTypes.getEncoding(passthroughMediaFormat.getString(MediaFormat.KEY_MIME));
+      format = passthroughMediaFormat;
+    } else {
+      encoding = pcmEncoding;
+      format = outputFormat;
+    }
     int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);
     int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);
     int[] channelMap;
@@ -289,8 +317,8 @@ protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)
     }
 
     try {
-      audioSink.configure(mimeType, channelCount, sampleRate, pcmEncoding, 0, channelMap,
-          encoderDelay, encoderPadding);
+      audioSink.configure(encoding, channelCount, sampleRate, 0, channelMap, encoderDelay,
+          encoderPadding);
     } catch (AudioSink.ConfigurationException e) {
       throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
@@ -340,6 +368,7 @@ protected void onPositionReset(long positionUs, boolean joining) throws ExoPlayb
     super.onPositionReset(positionUs, joining);
     audioSink.reset();
     currentPositionUs = positionUs;
+    allowFirstBufferPositionDiscontinuity = true;
     allowPositionDiscontinuity = true;
   }
 
@@ -352,6 +381,7 @@ protected void onStarted() {
   @Override
   protected void onStopped() {
     audioSink.pause();
+    updateCurrentPosition();
     super.onStopped();
   }
 
@@ -381,11 +411,8 @@ public boolean isReady() {
 
   @Override
   public long getPositionUs() {
-    long newCurrentPositionUs = audioSink.getCurrentPositionUs(isEnded());
-    if (newCurrentPositionUs != AudioSink.CURRENT_POSITION_NOT_SET) {
-      currentPositionUs = allowPositionDiscontinuity ? newCurrentPositionUs
-          : Math.max(currentPositionUs, newCurrentPositionUs);
-      allowPositionDiscontinuity = false;
+    if (getState() == STATE_STARTED) {
+      updateCurrentPosition();
     }
     return currentPositionUs;
   }
@@ -400,6 +427,19 @@ public PlaybackParameters getPlaybackParameters() {
     return audioSink.getPlaybackParameters();
   }
 
+  @Override
+  protected void onQueueInputBuffer(DecoderInputBuffer buffer) {
+    if (allowFirstBufferPositionDiscontinuity && !buffer.isDecodeOnly()) {
+      // TODO: Remove this hack once we have a proper fix for [Internal: b/71876314].
+      // Allow the position to jump if the first presentable input buffer has a timestamp that
+      // differs significantly from what was expected.
+      if (Math.abs(buffer.timeUs - currentPositionUs) > 500000) {
+        currentPositionUs = buffer.timeUs;
+      }
+      allowFirstBufferPositionDiscontinuity = false;
+    }
+  }
+
   @Override
   protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, MediaCodec codec,
       ByteBuffer buffer, int bufferIndex, int bufferFlags, long bufferPresentationTimeUs,
@@ -454,6 +494,17 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
     }
   }
 
+  private void updateCurrentPosition() {
+    long newCurrentPositionUs = audioSink.getCurrentPositionUs(isEnded());
+    if (newCurrentPositionUs != AudioSink.CURRENT_POSITION_NOT_SET) {
+      currentPositionUs =
+          allowPositionDiscontinuity
+              ? newCurrentPositionUs
+              : Math.max(currentPositionUs, newCurrentPositionUs);
+      allowPositionDiscontinuity = false;
+    }
+  }
+
   /**
    * Returns whether the decoder is known to output six audio channels when provided with input with
    * fewer than six channels.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
index a78adbcee3..01123f3c59 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/ResamplingAudioProcessor.java
@@ -21,7 +21,8 @@
 import java.nio.ByteOrder;
 
 /**
- * An {@link AudioProcessor} that converts audio data to {@link C#ENCODING_PCM_16BIT}.
+ * An {@link AudioProcessor} that converts 8-bit, 24-bit and 32-bit integer PCM audio to 16-bit
+ * integer PCM audio.
  */
 /* package */ final class ResamplingAudioProcessor implements AudioProcessor {
 
@@ -102,6 +103,7 @@ public void queueInput(ByteBuffer inputBuffer) {
         resampledSize = size / 2;
         break;
       case C.ENCODING_PCM_16BIT:
+      case C.ENCODING_PCM_FLOAT:
       case C.ENCODING_INVALID:
       case Format.NO_VALUE:
       default:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index 98a84fdff8..83c33ee6d7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -23,9 +23,11 @@
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.audio.AudioRendererEventListener.EventDispatcher;
 import com.google.android.exoplayer2.decoder.DecoderCounters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
@@ -45,6 +47,17 @@
 
 /**
  * Decodes and renders audio using a {@link SimpleDecoder}.
+ *
+ * <p>This renderer accepts the following messages sent via {@link ExoPlayer#createMessage(Target)}
+ * on the playback thread:
+ *
+ * <ul>
+ *   <li>Message with type {@link C#MSG_SET_VOLUME} to set the volume. The message payload should be
+ *       a {@link Float} with 0 being silence and 1 being unity gain.
+ *   <li>Message with type {@link C#MSG_SET_AUDIO_ATTRIBUTES} to set the audio attributes. The
+ *       message payload should be an {@link com.google.android.exoplayer2.audio.AudioAttributes}
+ *       instance that will configure the underlying audio track.
+ * </ul>
  */
 public abstract class SimpleDecoderAudioRenderer extends BaseRenderer implements MediaClock {
 
@@ -92,6 +105,7 @@
   private boolean audioTrackNeedsConfigure;
 
   private long currentPositionUs;
+  private boolean allowFirstBufferPositionDiscontinuity;
   private boolean allowPositionDiscontinuity;
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
@@ -200,6 +214,16 @@ public final int supportsFormat(Format format) {
   protected abstract int supportsFormatInternal(DrmSessionManager<ExoMediaCrypto> drmSessionManager,
       Format format);
 
+  /**
+   * Returns whether the audio sink can accept audio in the specified encoding.
+   *
+   * @param encoding The audio encoding.
+   * @return Whether the audio sink can accept audio in the specified encoding.
+   */
+  protected final boolean supportsOutputEncoding(@C.Encoding int encoding) {
+    return audioSink.isEncodingSupported(encoding);
+  }
+
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     if (outputStreamEnded) {
@@ -329,8 +353,8 @@ private boolean drainOutputBuffer() throws ExoPlaybackException, AudioDecoderExc
 
     if (audioTrackNeedsConfigure) {
       Format outputFormat = getOutputFormat();
-      audioSink.configure(outputFormat.sampleMimeType, outputFormat.channelCount,
-          outputFormat.sampleRate, outputFormat.pcmEncoding, 0, null, encoderDelay, encoderPadding);
+      audioSink.configure(outputFormat.pcmEncoding, outputFormat.channelCount,
+          outputFormat.sampleRate, 0, null, encoderDelay, encoderPadding);
       audioTrackNeedsConfigure = false;
     }
 
@@ -393,6 +417,7 @@ private boolean feedInputBuffer() throws AudioDecoderException, ExoPlaybackExcep
       return false;
     }
     inputBuffer.flip();
+    onQueueInputBuffer(inputBuffer);
     decoder.queueInputBuffer(inputBuffer);
     decoderReceivedBuffers = true;
     decoderCounters.inputBufferCount++;
@@ -416,7 +441,7 @@ private void processEndOfStream() throws ExoPlaybackException {
     try {
       audioSink.playToEndOfStream();
     } catch (AudioSink.WriteException e) {
-      throw ExoPlaybackException.createForRenderer(drmSession.getError(), getIndex());
+      throw ExoPlaybackException.createForRenderer(e, getIndex());
     }
   }
 
@@ -449,11 +474,8 @@ public boolean isReady() {
 
   @Override
   public long getPositionUs() {
-    long newCurrentPositionUs = audioSink.getCurrentPositionUs(isEnded());
-    if (newCurrentPositionUs != AudioSink.CURRENT_POSITION_NOT_SET) {
-      currentPositionUs = allowPositionDiscontinuity ? newCurrentPositionUs
-          : Math.max(currentPositionUs, newCurrentPositionUs);
-      allowPositionDiscontinuity = false;
+    if (getState() == STATE_STARTED) {
+      updateCurrentPosition();
     }
     return currentPositionUs;
   }
@@ -484,6 +506,7 @@ protected void onEnabled(boolean joining) throws ExoPlaybackException {
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
     audioSink.reset();
     currentPositionUs = positionUs;
+    allowFirstBufferPositionDiscontinuity = true;
     allowPositionDiscontinuity = true;
     inputStreamEnded = false;
     outputStreamEnded = false;
@@ -500,6 +523,7 @@ protected void onStarted() {
   @Override
   protected void onStopped() {
     audioSink.pause();
+    updateCurrentPosition();
   }
 
   @Override
@@ -530,6 +554,22 @@ protected void onDisabled() {
     }
   }
 
+  @Override
+  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+    switch (messageType) {
+      case C.MSG_SET_VOLUME:
+        audioSink.setVolume((Float) message);
+        break;
+      case C.MSG_SET_AUDIO_ATTRIBUTES:
+        AudioAttributes audioAttributes = (AudioAttributes) message;
+        audioSink.setAudioAttributes(audioAttributes);
+        break;
+      default:
+        super.handleMessage(messageType, message);
+        break;
+    }
+  }
+
   private void maybeInitDecoder() throws ExoPlaybackException {
     if (decoder != null) {
       return;
@@ -542,10 +582,12 @@ private void maybeInitDecoder() throws ExoPlaybackException {
       if (mediaCrypto == null) {
         DrmSessionException drmError = drmSession.getError();
         if (drmError != null) {
-          throw ExoPlaybackException.createForRenderer(drmError, getIndex());
+          // Continue for now. We may be able to avoid failure if the session recovers, or if a new
+          // input format causes the session to be replaced before it's used.
+        } else {
+          // The drm session isn't open yet.
+          return;
         }
-        // The drm session isn't open yet.
-        return;
       }
     }
 
@@ -615,19 +657,26 @@ private void onInputFormatChanged(Format newFormat) throws ExoPlaybackException
     eventDispatcher.inputFormatChanged(newFormat);
   }
 
-  @Override
-  public void handleMessage(int messageType, Object message) throws ExoPlaybackException {
-    switch (messageType) {
-      case C.MSG_SET_VOLUME:
-        audioSink.setVolume((Float) message);
-        break;
-      case C.MSG_SET_AUDIO_ATTRIBUTES:
-        AudioAttributes audioAttributes = (AudioAttributes) message;
-        audioSink.setAudioAttributes(audioAttributes);
-        break;
-      default:
-        super.handleMessage(messageType, message);
-        break;
+  private void onQueueInputBuffer(DecoderInputBuffer buffer) {
+    if (allowFirstBufferPositionDiscontinuity && !buffer.isDecodeOnly()) {
+      // TODO: Remove this hack once we have a proper fix for [Internal: b/71876314].
+      // Allow the position to jump if the first presentable input buffer has a timestamp that
+      // differs significantly from what was expected.
+      if (Math.abs(buffer.timeUs - currentPositionUs) > 500000) {
+        currentPositionUs = buffer.timeUs;
+      }
+      allowFirstBufferPositionDiscontinuity = false;
+    }
+  }
+
+  private void updateCurrentPosition() {
+    long newCurrentPositionUs = audioSink.getCurrentPositionUs(isEnded());
+    if (newCurrentPositionUs != AudioSink.CURRENT_POSITION_NOT_SET) {
+      currentPositionUs =
+          allowPositionDiscontinuity
+              ? newCurrentPositionUs
+              : Math.max(currentPositionUs, newCurrentPositionUs);
+      allowPositionDiscontinuity = false;
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
index 1d380ef858..68089d7b41 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleDecoder.java
@@ -219,7 +219,18 @@ private boolean decode() throws InterruptedException {
       if (inputBuffer.isDecodeOnly()) {
         outputBuffer.addFlag(C.BUFFER_FLAG_DECODE_ONLY);
       }
-      exception = decode(inputBuffer, outputBuffer, resetDecoder);
+      try {
+        exception = decode(inputBuffer, outputBuffer, resetDecoder);
+      } catch (RuntimeException e) {
+        // This can occur if a sample is malformed in a way that the decoder is not robust against.
+        // We don't want the process to die in this case, but we do want to propagate the error.
+        exception = createUnexpectedDecodeException(e);
+      } catch (OutOfMemoryError e) {
+        // This can occur if a sample is malformed in a way that causes the decoder to think it
+        // needs to allocate a large amount of memory. We don't want the process to die in this
+        // case, but we do want to propagate the error.
+        exception = createUnexpectedDecodeException(e);
+      }
       if (exception != null) {
         // Memory barrier to ensure that the decoder exception is visible from the playback thread.
         synchronized (lock) {}
@@ -269,6 +280,14 @@ private void releaseOutputBufferInternal(O outputBuffer) {
    */
   protected abstract O createOutputBuffer();
 
+  /**
+   * Creates an exception to propagate for an unexpected decode error.
+   *
+   * @param error The unexpected decode error.
+   * @return The exception to propagate.
+   */
+  protected abstract E createUnexpectedDecodeException(Throwable error);
+
   /**
    * Decodes the {@code inputBuffer} and stores any decoded output in {@code outputBuffer}.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 08defdccee..ca0302cdca 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -23,6 +23,7 @@
 import android.support.annotation.IntDef;
 import android.support.annotation.NonNull;
 import android.text.TextUtils;
+import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.drm.DefaultDrmSession.ProvisioningManager;
@@ -83,11 +84,21 @@
 
   }
 
+  /**
+   * Signals that the {@link DrmInitData} passed to {@link #acquireSession} does not contain does
+   * not contain scheme data for the required UUID.
+   */
+  public static final class MissingSchemeDataException extends Exception {
+
+    private MissingSchemeDataException(UUID uuid) {
+      super("Media does not support uuid: " + uuid);
+    }
+  }
+
   /**
    * The key to use when passing CustomData to a PlayReady instance in an optional parameter map.
    */
   public static final String PLAYREADY_CUSTOM_DATA_KEY = "PRCustomData";
-  private static final String CENC_SCHEME_MIME_TYPE = "cenc";
 
   /** Determines the action to be done after a session acquired. */
   @Retention(RetentionPolicy.SOURCE)
@@ -109,6 +120,9 @@
   /** Number of times to retry for initial provisioning and key request for reporting error. */
   public static final int INITIAL_DRM_REQUEST_RETRY_COUNT = 3;
 
+  private static final String TAG = "DefaultDrmSessionMgr";
+  private static final String CENC_SCHEME_MIME_TYPE = "cenc";
+
   private final UUID uuid;
   private final ExoMediaDrm<T> mediaDrm;
   private final MediaDrmCallback callback;
@@ -348,10 +362,20 @@ public void setMode(@Mode int mode, byte[] offlineLicenseKeySetId) {
 
   @Override
   public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
+    if (offlineLicenseKeySetId != null) {
+      // An offline license can be restored so a session can always be acquired.
+      return true;
+    }
     SchemeData schemeData = getSchemeData(drmInitData, uuid, true);
     if (schemeData == null) {
-      // No data for this manager's scheme.
-      return false;
+      if (drmInitData.schemeDataCount == 1 && drmInitData.get(0).matches(C.COMMON_PSSH_UUID)) {
+        // Assume scheme specific data will be added before the session is opened.
+        Log.w(
+            TAG, "DrmInitData only contains common PSSH SchemeData. Assuming support for: " + uuid);
+      } else {
+        // No data for this manager's scheme.
+        return false;
+      }
     }
     String schemeType = drmInitData.schemeType;
     if (schemeType == null || C.CENC_TYPE_cenc.equals(schemeType)) {
@@ -381,15 +405,15 @@ public boolean canAcquireSession(@NonNull DrmInitData drmInitData) {
     if (offlineLicenseKeySetId == null) {
       SchemeData data = getSchemeData(drmInitData, uuid, false);
       if (data == null) {
-        final IllegalStateException error = new IllegalStateException(
-            "Media does not support uuid: " + uuid);
+        final MissingSchemeDataException error = new MissingSchemeDataException(uuid);
         if (eventHandler != null && eventListener != null) {
-          eventHandler.post(new Runnable() {
-            @Override
-            public void run() {
-              eventListener.onDrmSessionManagerError(error);
-            }
-          });
+          eventHandler.post(
+              new Runnable() {
+                @Override
+                public void run() {
+                  eventListener.onDrmSessionManagerError(error);
+                }
+              });
         }
         return new ErrorStateDrmSession<>(new DrmSessionException(error));
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
index 73b443dcec..0c7cb0ef01 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmInitData.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
@@ -32,6 +33,58 @@
  */
 public final class DrmInitData implements Comparator<SchemeData>, Parcelable {
 
+  /**
+   * Merges {@link DrmInitData} obtained from a media manifest and a media stream.
+   *
+   * <p>The result is generated as follows.
+   *
+   * <ol>
+   *   <li>
+   *     Include all {@link SchemeData}s from {@code manifestData} where {@link
+   *     SchemeData#hasData()} is true.
+   *   </li>
+   *   <li>
+   *     Include all {@link SchemeData}s in {@code mediaData} where {@link SchemeData#hasData()} is
+   *     true and for which we did not include an entry from the manifest targeting the same UUID.
+   *   </li>
+   *   <li>
+   *     If available, the scheme type from the manifest is used. If not, the scheme type from the
+   *     media is used.
+   *   </li>
+   * </ol>
+   *
+   * @param manifestData DRM session acquisition data obtained from the manifest.
+   * @param mediaData DRM session acquisition data obtained from the media.
+   * @return A {@link DrmInitData} obtained from merging a media manifest and a media stream.
+   */
+  public static @Nullable DrmInitData createSessionCreationData(
+      @Nullable DrmInitData manifestData, @Nullable DrmInitData mediaData) {
+    ArrayList<SchemeData> result = new ArrayList<>();
+    String schemeType = null;
+    if (manifestData != null) {
+      schemeType = manifestData.schemeType;
+      for (SchemeData data : manifestData.schemeDatas) {
+        if (data.hasData()) {
+          result.add(data);
+        }
+      }
+    }
+
+    if (mediaData != null) {
+      if (schemeType == null) {
+        schemeType = mediaData.schemeType;
+      }
+      int manifestDatasCount = result.size();
+      for (SchemeData data : mediaData.schemeDatas) {
+        if (data.hasData() && !containsSchemeDataWithUuid(result, manifestDatasCount, data.uuid)) {
+          result.add(data);
+        }
+      }
+    }
+
+    return result.isEmpty() ? null : new DrmInitData(schemeType, result);
+  }
+
   private final SchemeData[] schemeDatas;
 
   // Lazily initialized hashcode.
@@ -193,6 +246,18 @@ public DrmInitData createFromParcel(Parcel in) {
 
   };
 
+  // Internal methods.
+
+  private static boolean containsSchemeDataWithUuid(
+      ArrayList<SchemeData> datas, int limit, UUID uuid) {
+    for (int i = 0; i < limit; i++) {
+      if (datas.get(i).uuid.equals(uuid)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   /**
    * Scheme initialization data.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ChunkIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ChunkIndex.java
index baa5589f4b..d0c66f930a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ChunkIndex.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ChunkIndex.java
@@ -91,8 +91,15 @@ public long getDurationUs() {
   }
 
   @Override
-  public long getPosition(long timeUs) {
-    return offsets[getChunkIndex(timeUs)];
+  public SeekPoints getSeekPoints(long timeUs) {
+    int chunkIndex = getChunkIndex(timeUs);
+    SeekPoint seekPoint = new SeekPoint(timesUs[chunkIndex], offsets[chunkIndex]);
+    if (seekPoint.timeUs >= timeUs || chunkIndex == length - 1) {
+      return new SeekPoints(seekPoint);
+    } else {
+      SeekPoint nextSeekPoint = new SeekPoint(timesUs[chunkIndex + 1], offsets[chunkIndex + 1]);
+      return new SeekPoints(seekPoint, nextSeekPoint);
+    }
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
index 87355a6c78..c3f6304091 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorInput.java
@@ -30,8 +30,9 @@
 
   private static final int PEEK_MIN_FREE_SPACE_AFTER_RESIZE = 64 * 1024;
   private static final int PEEK_MAX_FREE_SPACE = 512 * 1024;
-  private static final byte[] SCRATCH_SPACE = new byte[4096];
+  private static final int SCRATCH_SPACE_SIZE = 4096;
 
+  private final byte[] scratchSpace;
   private final DataSource dataSource;
   private final long streamLength;
 
@@ -50,6 +51,7 @@ public DefaultExtractorInput(DataSource dataSource, long position, long length)
     this.position = position;
     this.streamLength = length;
     peekBuffer = new byte[PEEK_MIN_FREE_SPACE_AFTER_RESIZE];
+    scratchSpace = new byte[SCRATCH_SPACE_SIZE];
   }
 
   @Override
@@ -84,7 +86,7 @@ public int skip(int length) throws IOException, InterruptedException {
     int bytesSkipped = skipFromPeekBuffer(length);
     if (bytesSkipped == 0) {
       bytesSkipped =
-          readFromDataSource(SCRATCH_SPACE, 0, Math.min(length, SCRATCH_SPACE.length), 0, true);
+          readFromDataSource(scratchSpace, 0, Math.min(length, scratchSpace.length), 0, true);
     }
     commitBytesRead(bytesSkipped);
     return bytesSkipped;
@@ -95,8 +97,9 @@ public boolean skipFully(int length, boolean allowEndOfInput)
       throws IOException, InterruptedException {
     int bytesSkipped = skipFromPeekBuffer(length);
     while (bytesSkipped < length && bytesSkipped != C.RESULT_END_OF_INPUT) {
-      bytesSkipped = readFromDataSource(SCRATCH_SPACE, -bytesSkipped,
-          Math.min(length, bytesSkipped + SCRATCH_SPACE.length), bytesSkipped, allowEndOfInput);
+      int minLength = Math.min(length, bytesSkipped + scratchSpace.length);
+      bytesSkipped =
+          readFromDataSource(scratchSpace, -bytesSkipped, minLength, bytesSkipped, allowEndOfInput);
     }
     commitBytesRead(bytesSkipped);
     return bytesSkipped != C.RESULT_END_OF_INPUT;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
index 87165e7a9b..b85ecba3a4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java
@@ -55,13 +55,17 @@
   static {
     Constructor<? extends Extractor> flacExtractorConstructor = null;
     try {
+      // LINT.IfChange
       flacExtractorConstructor =
           Class.forName("com.google.android.exoplayer2.ext.flac.FlacExtractor")
-              .asSubclass(Extractor.class).getConstructor();
+              .asSubclass(Extractor.class)
+              .getConstructor();
+      // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
     } catch (ClassNotFoundException e) {
-      // Extractor not found.
-    } catch (NoSuchMethodException e) {
-      // Constructor not found.
+      // Expected if the app was built without the FLAC extension.
+    } catch (Exception e) {
+      // The FLAC extension is present, but instantiation failed.
+      throw new RuntimeException("Error instantiating FLAC extension", e);
     }
     FLAC_EXTRACTOR_CONSTRUCTOR = flacExtractorConstructor;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java
index 778aa4d715..aa718c23e5 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekMap.java
@@ -16,25 +16,36 @@
 package com.google.android.exoplayer2.extractor;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
 
 /**
  * Maps seek positions (in microseconds) to corresponding positions (byte offsets) in the stream.
  */
 public interface SeekMap {
 
-  /**
-   * A {@link SeekMap} that does not support seeking.
-   */
+  /** A {@link SeekMap} that does not support seeking. */
   final class Unseekable implements SeekMap {
 
     private final long durationUs;
+    private final SeekPoints startSeekPoints;
 
     /**
-     * @param durationUs The duration of the stream in microseconds, or {@link C#TIME_UNSET} if
-     *     the duration is unknown.
+     * @param durationUs The duration of the stream in microseconds, or {@link C#TIME_UNSET} if the
+     *     duration is unknown.
      */
     public Unseekable(long durationUs) {
+      this(durationUs, 0);
+    }
+
+    /**
+     * @param durationUs The duration of the stream in microseconds, or {@link C#TIME_UNSET} if the
+     *     duration is unknown.
+     * @param startPosition The position (byte offset) of the start of the media.
+     */
+    public Unseekable(long durationUs, long startPosition) {
       this.durationUs = durationUs;
+      startSeekPoints =
+          new SeekPoints(startPosition == 0 ? SeekPoint.START : new SeekPoint(0, startPosition));
     }
 
     @Override
@@ -48,17 +59,58 @@ public long getDurationUs() {
     }
 
     @Override
-    public long getPosition(long timeUs) {
-      return 0;
+    public SeekPoints getSeekPoints(long timeUs) {
+      return startSeekPoints;
     }
+  }
 
+  /** Contains one or two {@link SeekPoint}s. */
+  final class SeekPoints {
+
+    /** The first seek point. */
+    public final SeekPoint first;
+    /** The second seek point, or {@link #first} if there's only one seek point. */
+    public final SeekPoint second;
+
+    /** @param point The single seek point. */
+    public SeekPoints(SeekPoint point) {
+      this(point, point);
+    }
+
+    /**
+     * @param first The first seek point.
+     * @param second The second seek point.
+     */
+    public SeekPoints(SeekPoint first, SeekPoint second) {
+      this.first = Assertions.checkNotNull(first);
+      this.second = Assertions.checkNotNull(second);
+    }
+
+    @Override
+    public String toString() {
+      return "[" + first + (first.equals(second) ? "" : (", " + second)) + "]";
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj) {
+        return true;
+      }
+      if (obj == null || getClass() != obj.getClass()) {
+        return false;
+      }
+      SeekPoints other = (SeekPoints) obj;
+      return first.equals(other.first) && second.equals(other.second);
+    }
+
+    @Override
+    public int hashCode() {
+      return (31 * first.hashCode()) + second.hashCode();
+    }
   }
 
   /**
    * Returns whether seeking is supported.
-   * <p>
-   * If seeking is not supported then the only valid seek position is the start of the file, and so
-   * {@link #getPosition(long)} will return 0 for all input values.
    *
    * @return Whether seeking is supported.
    */
@@ -67,19 +119,22 @@ public long getPosition(long timeUs) {
   /**
    * Returns the duration of the stream in microseconds.
    *
-   * @return The duration of the stream in microseconds, or {@link C#TIME_UNSET} if the
-   *     duration is unknown.
+   * @return The duration of the stream in microseconds, or {@link C#TIME_UNSET} if the duration is
+   *     unknown.
    */
   long getDurationUs();
 
   /**
-   * Maps a seek position in microseconds to a corresponding position (byte offset) in the stream
-   * from which data can be provided to the extractor.
+   * Obtains seek points for the specified seek time in microseconds. The returned {@link
+   * SeekPoints} will contain one or two distinct seek points.
+   *
+   * <p>Two seek points [A, B] are returned in the case that seeking can only be performed to
+   * discrete points in time, there does not exist a seek point at exactly the requested time, and
+   * there exist seek points on both sides of it. In this case A and B are the closest seek points
+   * before and after the requested time. A single seek point is returned in all other cases.
    *
-   * @param timeUs A seek position in microseconds.
-   * @return The corresponding position (byte offset) in the stream from which data can be provided
-   *     to the extractor, or 0 if {@code #isSeekable()} returns false.
+   * @param timeUs A seek time in microseconds.
+   * @return The corresponding seek points.
    */
-  long getPosition(long timeUs);
-
+  SeekPoints getSeekPoints(long timeUs);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekPoint.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekPoint.java
new file mode 100644
index 0000000000..93cfbd9200
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/SeekPoint.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor;
+
+/** Defines a seek point in a media stream. */
+public final class SeekPoint {
+
+  /** A {@link SeekPoint} whose time and byte offset are both set to 0. */
+  public static final SeekPoint START = new SeekPoint(0, 0);
+
+  /** The time of the seek point, in microseconds. */
+  public final long timeUs;
+
+  /** The byte offset of the seek point. */
+  public final long position;
+
+  /**
+   * @param timeUs The time of the seek point, in microseconds.
+   * @param position The byte offset of the seek point.
+   */
+  public SeekPoint(long timeUs, long position) {
+    this.timeUs = timeUs;
+    this.position = position;
+  }
+
+  @Override
+  public String toString() {
+    return "[timeUs=" + timeUs + ", position=" + position + "]";
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null || getClass() != obj.getClass()) {
+      return false;
+    }
+    SeekPoint other = (SeekPoint) obj;
+    return timeUs == other.timeUs && position == other.position;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = (int) timeUs;
+    result = 31 * result + (int) position;
+    return result;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
index 218e6ffd82..d908f28945 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/FlvExtractor.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.extractor.flv;
 
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -25,11 +26,13 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
- * Facilitates the extraction of data from the FLV container format.
+ * Extracts data from the FLV container format.
  */
-public final class FlvExtractor implements Extractor, SeekMap {
+public final class FlvExtractor implements Extractor {
 
   /**
    * Factory for {@link FlvExtractor} instances.
@@ -43,16 +46,22 @@
 
   };
 
-  // Header sizes.
-  private static final int FLV_HEADER_SIZE = 9;
-  private static final int FLV_TAG_HEADER_SIZE = 11;
-
-  // Parser states.
+  /**
+   * Extractor states.
+   */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({STATE_READING_FLV_HEADER, STATE_SKIPPING_TO_TAG_HEADER, STATE_READING_TAG_HEADER,
+      STATE_READING_TAG_DATA})
+  private @interface States {}
   private static final int STATE_READING_FLV_HEADER = 1;
   private static final int STATE_SKIPPING_TO_TAG_HEADER = 2;
   private static final int STATE_READING_TAG_HEADER = 3;
   private static final int STATE_READING_TAG_DATA = 4;
 
+  // Header sizes.
+  private static final int FLV_HEADER_SIZE = 9;
+  private static final int FLV_TAG_HEADER_SIZE = 11;
+
   // Tag types.
   private static final int TAG_TYPE_AUDIO = 8;
   private static final int TAG_TYPE_VIDEO = 9;
@@ -61,33 +70,31 @@
   // FLV container identifier.
   private static final int FLV_TAG = Util.getIntegerCodeForString("FLV");
 
-  // Temporary buffers.
   private final ParsableByteArray scratch;
   private final ParsableByteArray headerBuffer;
   private final ParsableByteArray tagHeaderBuffer;
   private final ParsableByteArray tagData;
+  private final ScriptTagPayloadReader metadataReader;
 
-  // Extractor outputs.
   private ExtractorOutput extractorOutput;
-
-  // State variables.
-  private int parserState;
+  private @States int state;
+  private long mediaTagTimestampOffsetUs;
   private int bytesToNextTagHeader;
-  public int tagType;
-  public int tagDataSize;
-  public long tagTimestampUs;
-
-  // Tags readers.
+  private int tagType;
+  private int tagDataSize;
+  private long tagTimestampUs;
+  private boolean outputSeekMap;
   private AudioTagPayloadReader audioReader;
   private VideoTagPayloadReader videoReader;
-  private ScriptTagPayloadReader metadataReader;
 
   public FlvExtractor() {
     scratch = new ParsableByteArray(4);
     headerBuffer = new ParsableByteArray(FLV_HEADER_SIZE);
     tagHeaderBuffer = new ParsableByteArray(FLV_TAG_HEADER_SIZE);
     tagData = new ParsableByteArray();
-    parserState = STATE_READING_FLV_HEADER;
+    metadataReader = new ScriptTagPayloadReader();
+    state = STATE_READING_FLV_HEADER;
+    mediaTagTimestampOffsetUs = C.TIME_UNSET;
   }
 
   @Override
@@ -128,7 +135,8 @@ public void init(ExtractorOutput output) {
 
   @Override
   public void seek(long position, long timeUs) {
-    parserState = STATE_READING_FLV_HEADER;
+    state = STATE_READING_FLV_HEADER;
+    mediaTagTimestampOffsetUs = C.TIME_UNSET;
     bytesToNextTagHeader = 0;
   }
 
@@ -141,7 +149,7 @@ public void release() {
   public int read(ExtractorInput input, PositionHolder seekPosition) throws IOException,
       InterruptedException {
     while (true) {
-      switch (parserState) {
+      switch (state) {
         case STATE_READING_FLV_HEADER:
           if (!readFlvHeader(input)) {
             return RESULT_END_OF_INPUT;
@@ -160,6 +168,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
             return RESULT_CONTINUE;
           }
           break;
+        default:
+          // Never happens.
+          throw new IllegalStateException();
       }
     }
   }
@@ -191,15 +202,11 @@ private boolean readFlvHeader(ExtractorInput input) throws IOException, Interrup
       videoReader = new VideoTagPayloadReader(
           extractorOutput.track(TAG_TYPE_VIDEO, C.TRACK_TYPE_VIDEO));
     }
-    if (metadataReader == null) {
-      metadataReader = new ScriptTagPayloadReader(null);
-    }
     extractorOutput.endTracks();
-    extractorOutput.seekMap(this);
 
     // We need to skip any additional content in the FLV header, plus the 4 byte previous tag size.
     bytesToNextTagHeader = headerBuffer.readInt() - FLV_HEADER_SIZE + 4;
-    parserState = STATE_SKIPPING_TO_TAG_HEADER;
+    state = STATE_SKIPPING_TO_TAG_HEADER;
     return true;
   }
 
@@ -213,7 +220,7 @@ private boolean readFlvHeader(ExtractorInput input) throws IOException, Interrup
   private void skipToTagHeader(ExtractorInput input) throws IOException, InterruptedException {
     input.skipFully(bytesToNextTagHeader);
     bytesToNextTagHeader = 0;
-    parserState = STATE_READING_TAG_HEADER;
+    state = STATE_READING_TAG_HEADER;
   }
 
   /**
@@ -236,7 +243,7 @@ private boolean readTagHeader(ExtractorInput input) throws IOException, Interrup
     tagTimestampUs = tagHeaderBuffer.readUnsignedInt24();
     tagTimestampUs = ((tagHeaderBuffer.readUnsignedByte() << 24) | tagTimestampUs) * 1000L;
     tagHeaderBuffer.skipBytes(3); // streamId
-    parserState = STATE_READING_TAG_DATA;
+    state = STATE_READING_TAG_DATA;
     return true;
   }
 
@@ -251,17 +258,24 @@ private boolean readTagHeader(ExtractorInput input) throws IOException, Interrup
   private boolean readTagData(ExtractorInput input) throws IOException, InterruptedException {
     boolean wasConsumed = true;
     if (tagType == TAG_TYPE_AUDIO && audioReader != null) {
-      audioReader.consume(prepareTagData(input), tagTimestampUs);
+      ensureReadyForMediaOutput();
+      audioReader.consume(prepareTagData(input), mediaTagTimestampOffsetUs + tagTimestampUs);
     } else if (tagType == TAG_TYPE_VIDEO && videoReader != null) {
-      videoReader.consume(prepareTagData(input), tagTimestampUs);
-    } else if (tagType == TAG_TYPE_SCRIPT_DATA && metadataReader != null) {
+      ensureReadyForMediaOutput();
+      videoReader.consume(prepareTagData(input), mediaTagTimestampOffsetUs + tagTimestampUs);
+    } else if (tagType == TAG_TYPE_SCRIPT_DATA && !outputSeekMap) {
       metadataReader.consume(prepareTagData(input), tagTimestampUs);
+      long durationUs = metadataReader.getDurationUs();
+      if (durationUs != C.TIME_UNSET) {
+        extractorOutput.seekMap(new SeekMap.Unseekable(durationUs));
+        outputSeekMap = true;
+      }
     } else {
       input.skipFully(tagDataSize);
       wasConsumed = false;
     }
     bytesToNextTagHeader = 4; // There's a 4 byte previous tag size before the next header.
-    parserState = STATE_SKIPPING_TO_TAG_HEADER;
+    state = STATE_SKIPPING_TO_TAG_HEADER;
     return wasConsumed;
   }
 
@@ -277,21 +291,15 @@ private ParsableByteArray prepareTagData(ExtractorInput input) throws IOExceptio
     return tagData;
   }
 
-  // SeekMap implementation.
-
-  @Override
-  public boolean isSeekable() {
-    return false;
-  }
-
-  @Override
-  public long getDurationUs() {
-    return metadataReader.getDurationUs();
-  }
-
-  @Override
-  public long getPosition(long timeUs) {
-    return 0;
+  private void ensureReadyForMediaOutput() {
+    if (!outputSeekMap) {
+      extractorOutput.seekMap(new SeekMap.Unseekable(C.TIME_UNSET));
+      outputSeekMap = true;
+    }
+    if (mediaTagTimestampOffsetUs == C.TIME_UNSET) {
+      mediaTagTimestampOffsetUs =
+          metadataReader.getDurationUs() == C.TIME_UNSET ? -tagTimestampUs : 0;
+    }
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java
index 1a4f8f3e88..2dec85ffcc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/ScriptTagPayloadReader.java
@@ -17,7 +17,6 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
-import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.ArrayList;
 import java.util.Date;
@@ -44,11 +43,8 @@
 
   private long durationUs;
 
-  /**
-   * @param output A {@link TrackOutput} to which samples should be written.
-   */
-  public ScriptTagPayloadReader(TrackOutput output) {
-    super(output);
+  public ScriptTagPayloadReader() {
+    super(null);
     durationUs = C.TIME_UNSET;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
index 91bc170205..2c6130677f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReader.java
@@ -202,10 +202,11 @@ private double readFloat(ExtractorInput input, int byteLength)
   }
 
   /**
-   * Reads and returns a string of length {@code byteLength} from the {@link ExtractorInput}.
+   * Reads a string of length {@code byteLength} from the {@link ExtractorInput}. Zero padding is
+   * removed, so the returned string may be shorter than {@code byteLength}.
    *
    * @param input The {@link ExtractorInput} from which to read.
-   * @param byteLength The length of the float being read.
+   * @param byteLength The length of the string being read, including zero padding.
    * @return The read string value.
    * @throws IOException If an error occurs reading from the input.
    * @throws InterruptedException If the thread is interrupted.
@@ -217,7 +218,12 @@ private String readString(ExtractorInput input, int byteLength)
     }
     byte[] stringBytes = new byte[byteLength];
     input.readFully(stringBytes, 0, byteLength);
-    return new String(stringBytes);
+    // Remove zero padding.
+    int trimmedLength = byteLength;
+    while (trimmedLength > 0 && stringBytes[trimmedLength - 1] == 0) {
+      trimmedLength--;
+    }
+    return new String(stringBytes, 0, trimmedLength);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
index 5aefd041c4..57128f45f0 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractor.java
@@ -16,11 +16,13 @@
 package com.google.android.exoplayer2.extractor.mkv;
 
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.audio.Ac3Util;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.extractor.ChunkIndex;
@@ -32,6 +34,7 @@
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.LongArray;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.NalUnitUtil;
@@ -53,7 +56,7 @@
 import java.util.UUID;
 
 /**
- * Extracts data from a Matroska or WebM file.
+ * Extracts data from the Matroska and WebM container formats.
  */
 public final class MatroskaExtractor implements Extractor {
 
@@ -413,6 +416,9 @@ public void seek(long position, long timeUs) {
     reader.reset();
     varintReader.reset();
     resetSample();
+    for (int i = 0; i < tracks.size(); i++) {
+      tracks.valueAt(i).reset();
+    }
   }
 
   @Override
@@ -431,7 +437,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
         return Extractor.RESULT_SEEK;
       }
     }
-    return continueReading ? Extractor.RESULT_CONTINUE : Extractor.RESULT_END_OF_INPUT;
+    if (!continueReading) {
+      for (int i = 0; i < tracks.size(); i++) {
+        tracks.valueAt(i).outputPendingSampleMetadata();
+      }
+      return Extractor.RESULT_END_OF_INPUT;
+    }
+    return Extractor.RESULT_CONTINUE;
   }
 
   /* package */ int getElementType(int id) {
@@ -1077,14 +1089,26 @@ public int read(ExtractorInput input, PositionHolder seekPosition) throws IOExce
   }
 
   private void commitSampleToOutput(Track track, long timeUs) {
-    if (CODEC_ID_SUBRIP.equals(track.codecId)) {
-      commitSubtitleSample(track, SUBRIP_TIMECODE_FORMAT, SUBRIP_PREFIX_END_TIMECODE_OFFSET,
-          SUBRIP_TIMECODE_LAST_VALUE_SCALING_FACTOR, SUBRIP_TIMECODE_EMPTY);
-    } else if (CODEC_ID_ASS.equals(track.codecId)) {
-      commitSubtitleSample(track, SSA_TIMECODE_FORMAT, SSA_PREFIX_END_TIMECODE_OFFSET,
-          SSA_TIMECODE_LAST_VALUE_SCALING_FACTOR, SSA_TIMECODE_EMPTY);
+    if (track.trueHdSampleRechunker != null) {
+      track.trueHdSampleRechunker.sampleMetadata(track, timeUs);
+    } else {
+      if (CODEC_ID_SUBRIP.equals(track.codecId)) {
+        commitSubtitleSample(
+            track,
+            SUBRIP_TIMECODE_FORMAT,
+            SUBRIP_PREFIX_END_TIMECODE_OFFSET,
+            SUBRIP_TIMECODE_LAST_VALUE_SCALING_FACTOR,
+            SUBRIP_TIMECODE_EMPTY);
+      } else if (CODEC_ID_ASS.equals(track.codecId)) {
+        commitSubtitleSample(
+            track,
+            SSA_TIMECODE_FORMAT,
+            SSA_PREFIX_END_TIMECODE_OFFSET,
+            SSA_TIMECODE_LAST_VALUE_SCALING_FACTOR,
+            SSA_TIMECODE_EMPTY);
+      }
+      track.output.sampleMetadata(timeUs, blockFlags, sampleBytesWritten, 0, track.cryptoData);
     }
-    track.output.sampleMetadata(timeUs, blockFlags, sampleBytesWritten, 0, track.cryptoData);
     sampleRead = true;
     resetSample();
   }
@@ -1251,6 +1275,10 @@ private void writeSampleData(ExtractorInput input, Track track, int size)
         }
       }
     } else {
+      if (track.trueHdSampleRechunker != null) {
+        Assertions.checkState(sampleStrippedBytes.limit() == 0);
+        track.trueHdSampleRechunker.startSample(input, blockFlags, size);
+      }
       while (sampleBytesRead < size) {
         readToOutput(input, output, size - sampleBytesRead);
       }
@@ -1510,7 +1538,70 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
         throws IOException, InterruptedException {
       MatroskaExtractor.this.binaryElement(id, contentsSize, input);
     }
+  }
+
+  /**
+   * Rechunks TrueHD sample data into groups of {@link Ac3Util#TRUEHD_RECHUNK_SAMPLE_COUNT} samples.
+   */
+  private static final class TrueHdSampleRechunker {
+
+    private final byte[] syncframePrefix;
+
+    private boolean foundSyncframe;
+    private int sampleCount;
+    private int chunkSize;
+    private long timeUs;
+    private @C.BufferFlags int blockFlags;
+
+    public TrueHdSampleRechunker() {
+      syncframePrefix = new byte[Ac3Util.TRUEHD_SYNCFRAME_PREFIX_LENGTH];
+    }
+
+    public void reset() {
+      foundSyncframe = false;
+    }
+
+    public void startSample(ExtractorInput input, @C.BufferFlags int blockFlags, int size)
+        throws IOException, InterruptedException {
+      if (!foundSyncframe) {
+        input.peekFully(syncframePrefix, 0, Ac3Util.TRUEHD_SYNCFRAME_PREFIX_LENGTH);
+        input.resetPeekPosition();
+        if ((Ac3Util.parseTrueHdSyncframeAudioSampleCount(syncframePrefix) == C.INDEX_UNSET)) {
+          return;
+        }
+        foundSyncframe = true;
+        sampleCount = 0;
+      }
+      if (sampleCount == 0) {
+        // This is the first sample in the chunk, so reset the block flags and chunk size.
+        this.blockFlags = blockFlags;
+        chunkSize = 0;
+      }
+      chunkSize += size;
+    }
 
+    public void sampleMetadata(Track track, long timeUs) {
+      if (!foundSyncframe) {
+        return;
+      }
+      if (sampleCount++ == 0) {
+        // This is the first sample in the chunk, so update the timestamp.
+        this.timeUs = timeUs;
+      }
+      if (sampleCount < Ac3Util.TRUEHD_RECHUNK_SAMPLE_COUNT) {
+        // We haven't read enough samples to output a chunk.
+        return;
+      }
+      track.output.sampleMetadata(this.timeUs, blockFlags, chunkSize, 0, track.cryptoData);
+      sampleCount = 0;
+    }
+
+    public void outputPendingSampleMetadata(Track track) {
+      if (foundSyncframe && sampleCount > 0) {
+        track.output.sampleMetadata(this.timeUs, blockFlags, chunkSize, 0, track.cryptoData);
+        sampleCount = 0;
+      }
+    }
   }
 
   private static final class Track {
@@ -1573,6 +1664,7 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
     public int sampleRate = 8000;
     public long codecDelayNs = 0;
     public long seekPreRollNs = 0;
+    @Nullable public TrueHdSampleRechunker trueHdSampleRechunker;
 
     // Text elements.
     public boolean flagForced;
@@ -1583,9 +1675,7 @@ public void binaryElement(int id, int contentsSize, ExtractorInput input)
     public TrackOutput output;
     public int nalUnitLengthFieldLength;
 
-    /**
-     * Initializes the track with an output.
-     */
+    /** Initializes the track with an output. */
     public void initializeOutput(ExtractorOutput output, int trackId) throws ParserException {
       String mimeType;
       int maxInputSize = Format.NO_VALUE;
@@ -1669,6 +1759,7 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
           break;
         case CODEC_ID_TRUEHD:
           mimeType = MimeTypes.AUDIO_TRUEHD;
+          trueHdSampleRechunker = new TrueHdSampleRechunker();
           break;
         case CODEC_ID_DTS:
         case CODEC_ID_DTS_EXPRESS:
@@ -1776,8 +1867,16 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
           || MimeTypes.APPLICATION_PGS.equals(mimeType)
           || MimeTypes.APPLICATION_DVBSUBS.equals(mimeType)) {
         type = C.TRACK_TYPE_TEXT;
-        format = Format.createImageSampleFormat(Integer.toString(trackId), mimeType, null,
-            Format.NO_VALUE, initializationData, language, drmInitData);
+        format =
+            Format.createImageSampleFormat(
+                Integer.toString(trackId),
+                mimeType,
+                null,
+                Format.NO_VALUE,
+                selectionFlags,
+                initializationData,
+                language,
+                drmInitData);
       } else {
         throw new ParserException("Unexpected MIME type.");
       }
@@ -1786,9 +1885,21 @@ public void initializeOutput(ExtractorOutput output, int trackId) throws ParserE
       this.output.format(format);
     }
 
-    /**
-     * Returns the HDR Static Info as defined in CTA-861.3.
-     */
+    /** Forces any pending sample metadata to be flushed to the output. */
+    public void outputPendingSampleMetadata() {
+      if (trueHdSampleRechunker != null) {
+        trueHdSampleRechunker.outputPendingSampleMetadata(this);
+      }
+    }
+
+    /** Resets any state stored in the track in response to a seek. */
+    public void reset() {
+      if (trueHdSampleRechunker != null) {
+        trueHdSampleRechunker.reset();
+      }
+    }
+
+    /** Returns the HDR Static Info as defined in CTA-861.3. */
     private byte[] getHdrStaticInfo() {
       // Are all fields present.
       if (primaryRChromaticityX == Format.NO_VALUE || primaryRChromaticityY == Format.NO_VALUE
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
index df7748a910..d358c0cae1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java
@@ -16,6 +16,8 @@
 package com.google.android.exoplayer2.extractor.mp3;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.MpegAudioHeader;
+import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.util.Util;
 
 /**
@@ -26,27 +28,55 @@
   private static final int BITS_PER_BYTE = 8;
 
   private final long firstFramePosition;
+  private final int frameSize;
+  private final long dataSize;
   private final int bitrate;
   private final long durationUs;
 
-  public ConstantBitrateSeeker(long firstFramePosition, int bitrate, long inputLength) {
+  /**
+   * @param inputLength The length of the stream in bytes, or {@link C#LENGTH_UNSET} if unknown.
+   * @param firstFramePosition The position of the first frame in the stream.
+   * @param mpegAudioHeader The MPEG audio header associated with the first frame.
+   */
+  public ConstantBitrateSeeker(long inputLength, long firstFramePosition,
+      MpegAudioHeader mpegAudioHeader) {
     this.firstFramePosition = firstFramePosition;
-    this.bitrate = bitrate;
-    durationUs = inputLength == C.LENGTH_UNSET ? C.TIME_UNSET : getTimeUs(inputLength);
+    this.frameSize = mpegAudioHeader.frameSize;
+    this.bitrate = mpegAudioHeader.bitrate;
+    if (inputLength == C.LENGTH_UNSET) {
+      dataSize = C.LENGTH_UNSET;
+      durationUs = C.TIME_UNSET;
+    } else {
+      dataSize = inputLength - firstFramePosition;
+      durationUs = getTimeUs(inputLength);
+    }
   }
 
   @Override
   public boolean isSeekable() {
-    return durationUs != C.TIME_UNSET;
+    return dataSize != C.LENGTH_UNSET;
   }
 
   @Override
-  public long getPosition(long timeUs) {
-    if (durationUs == C.TIME_UNSET) {
-      return 0;
+  public SeekPoints getSeekPoints(long timeUs) {
+    if (dataSize == C.LENGTH_UNSET) {
+      return new SeekPoints(new SeekPoint(0, firstFramePosition));
+    }
+    long positionOffset = (timeUs * bitrate) / (C.MICROS_PER_SECOND * BITS_PER_BYTE);
+    // Constrain to nearest preceding frame offset.
+    positionOffset = (positionOffset / frameSize) * frameSize;
+    positionOffset = Util.constrainValue(positionOffset, 0, dataSize - frameSize);
+    long seekPosition = firstFramePosition + positionOffset;
+    long seekTimeUs = getTimeUs(seekPosition);
+    SeekPoint seekPoint = new SeekPoint(seekTimeUs, seekPosition);
+    if (seekTimeUs >= timeUs || positionOffset == dataSize - frameSize) {
+      return new SeekPoints(seekPoint);
+    } else {
+      long secondSeekPosition = seekPosition + frameSize;
+      long secondSeekTimeUs = getTimeUs(secondSeekPosition);
+      SeekPoint secondSeekPoint = new SeekPoint(secondSeekTimeUs, secondSeekPosition);
+      return new SeekPoints(seekPoint, secondSeekPoint);
     }
-    timeUs = Util.constrainValue(timeUs, 0, durationUs);
-    return firstFramePosition + (timeUs * bitrate) / (C.MICROS_PER_SECOND * BITS_PER_BYTE);
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
index a4349ada09..5c56dc460a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/Mp3Extractor.java
@@ -38,7 +38,7 @@
 import java.lang.annotation.RetentionPolicy;
 
 /**
- * Extracts data from an MP3 file.
+ * Extracts data from the MP3 container format.
  */
 public final class Mp3Extractor implements Extractor {
 
@@ -360,7 +360,7 @@ private Seeker maybeReadSeekFrame(ExtractorInput input) throws IOException, Inte
     int seekHeader = getSeekFrameHeader(frame, xingBase);
     Seeker seeker;
     if (seekHeader == SEEK_HEADER_XING || seekHeader == SEEK_HEADER_INFO) {
-      seeker = XingSeeker.create(synchronizedHeader, frame, input.getPosition(), input.getLength());
+      seeker = XingSeeker.create(input.getLength(), input.getPosition(), synchronizedHeader, frame);
       if (seeker != null && !gaplessInfoHolder.hasGaplessInfo()) {
         // If there is a Xing header, read gapless playback metadata at a fixed offset.
         input.resetPeekPosition();
@@ -375,7 +375,7 @@ private Seeker maybeReadSeekFrame(ExtractorInput input) throws IOException, Inte
         return getConstantBitrateSeeker(input);
       }
     } else if (seekHeader == SEEK_HEADER_VBRI) {
-      seeker = VbriSeeker.create(synchronizedHeader, frame, input.getPosition(), input.getLength());
+      seeker = VbriSeeker.create(input.getLength(), input.getPosition(), synchronizedHeader, frame);
       input.skipFully(synchronizedHeader.frameSize);
     } else { // seekerHeader == SEEK_HEADER_UNSET
       // This frame doesn't contain seeking information, so reset the peek position.
@@ -393,8 +393,7 @@ private Seeker getConstantBitrateSeeker(ExtractorInput input)
     input.peekFully(scratch.data, 0, 4);
     scratch.setPosition(0);
     MpegAudioHeader.populateHeader(scratch.readInt(), synchronizedHeader);
-    return new ConstantBitrateSeeker(input.getPosition(), synchronizedHeader.bitrate,
-        input.getLength());
+    return new ConstantBitrateSeeker(input.getLength(), input.getPosition(), synchronizedHeader);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
index c43f065592..f918b5c43d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/VbriSeeker.java
@@ -15,8 +15,10 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
+import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
+import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
@@ -25,21 +27,23 @@
  */
 /* package */ final class VbriSeeker implements Mp3Extractor.Seeker {
 
+  private static final String TAG = "VbriSeeker";
+
   /**
    * Returns a {@link VbriSeeker} for seeking in the stream, if required information is present.
    * Returns {@code null} if not. On returning, {@code frame}'s position is not specified so the
    * caller should reset it.
    *
+   * @param inputLength The length of the stream in bytes, or {@link C#LENGTH_UNSET} if unknown.
+   * @param position The position of the start of this frame in the stream.
    * @param mpegAudioHeader The MPEG audio header associated with the frame.
    * @param frame The data in this audio frame, with its position set to immediately after the
    *     'VBRI' tag.
-   * @param position The position (byte offset) of the start of this frame in the stream.
-   * @param inputLength The length of the stream in bytes.
    * @return A {@link VbriSeeker} for seeking in the stream, or {@code null} if the required
    *     information is not present.
    */
-  public static VbriSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArray frame,
-      long position, long inputLength) {
+  public static VbriSeeker create(long inputLength, long position, MpegAudioHeader mpegAudioHeader,
+      ParsableByteArray frame) {
     frame.skipBytes(10);
     int numFrames = frame.readInt();
     if (numFrames <= 0) {
@@ -53,15 +57,15 @@ public static VbriSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArr
     int entrySize = frame.readUnsignedShort();
     frame.skipBytes(2);
 
-    // Skip the frame containing the VBRI header.
-    position += mpegAudioHeader.frameSize;
-
+    long minPosition = position + mpegAudioHeader.frameSize;
     // Read table of contents entries.
-    long[] timesUs = new long[entryCount + 1];
-    long[] positions = new long[entryCount + 1];
-    timesUs[0] = 0L;
-    positions[0] = position;
-    for (int index = 1; index < timesUs.length; index++) {
+    long[] timesUs = new long[entryCount];
+    long[] positions = new long[entryCount];
+    for (int index = 0; index < entryCount; index++) {
+      timesUs[index] = (index * durationUs) / entryCount;
+      // Ensure positions do not fall within the frame containing the VBRI header. This constraint
+      // will normally only apply to the first entry in the table.
+      positions[index] = Math.max(position, minPosition);
       int segmentSize;
       switch (entrySize) {
         case 1:
@@ -80,9 +84,9 @@ public static VbriSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArr
           return null;
       }
       position += segmentSize * scale;
-      timesUs[index] = index * durationUs / entryCount;
-      positions[index] =
-          inputLength == C.LENGTH_UNSET ? position : Math.min(inputLength, position);
+    }
+    if (inputLength != C.LENGTH_UNSET && inputLength != position) {
+      Log.w(TAG, "VBRI data size mismatch: " + inputLength + ", " + position);
     }
     return new VbriSeeker(timesUs, positions, durationUs);
   }
@@ -103,8 +107,15 @@ public boolean isSeekable() {
   }
 
   @Override
-  public long getPosition(long timeUs) {
-    return positions[Util.binarySearchFloor(timesUs, timeUs, true, true)];
+  public SeekPoints getSeekPoints(long timeUs) {
+    int tableIndex = Util.binarySearchFloor(timesUs, timeUs, true, true);
+    SeekPoint seekPoint = new SeekPoint(timesUs[tableIndex], positions[tableIndex]);
+    if (seekPoint.timeUs >= timeUs || tableIndex == timesUs.length - 1) {
+      return new SeekPoints(seekPoint);
+    } else {
+      SeekPoint nextSeekPoint = new SeekPoint(timesUs[tableIndex + 1], positions[tableIndex + 1]);
+      return new SeekPoints(seekPoint, nextSeekPoint);
+    }
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
index 5e8d72f18d..a3bd5a2da2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/XingSeeker.java
@@ -15,8 +15,10 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
+import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
+import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 
@@ -25,24 +27,25 @@
  */
 /* package */ final class XingSeeker implements Mp3Extractor.Seeker {
 
+  private static final String TAG = "XingSeeker";
+
   /**
    * Returns a {@link XingSeeker} for seeking in the stream, if required information is present.
    * Returns {@code null} if not. On returning, {@code frame}'s position is not specified so the
    * caller should reset it.
    *
+   * @param inputLength The length of the stream in bytes, or {@link C#LENGTH_UNSET} if unknown.
+   * @param position The position of the start of this frame in the stream.
    * @param mpegAudioHeader The MPEG audio header associated with the frame.
    * @param frame The data in this audio frame, with its position set to immediately after the
    *    'Xing' or 'Info' tag.
-   * @param position The position (byte offset) of the start of this frame in the stream.
-   * @param inputLength The length of the stream in bytes.
    * @return A {@link XingSeeker} for seeking in the stream, or {@code null} if the required
    *     information is not present.
    */
-  public static XingSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArray frame,
-      long position, long inputLength) {
+  public static XingSeeker create(long inputLength, long position, MpegAudioHeader mpegAudioHeader,
+      ParsableByteArray frame) {
     int samplesPerFrame = mpegAudioHeader.samplesPerFrame;
     int sampleRate = mpegAudioHeader.sampleRate;
-    long firstFramePosition = position + mpegAudioHeader.frameSize;
 
     int flags = frame.readInt();
     int frameCount;
@@ -54,45 +57,49 @@ public static XingSeeker create(MpegAudioHeader mpegAudioHeader, ParsableByteArr
         sampleRate);
     if ((flags & 0x06) != 0x06) {
       // If the size in bytes or table of contents is missing, the stream is not seekable.
-      return new XingSeeker(firstFramePosition, durationUs, inputLength);
+      return new XingSeeker(position, mpegAudioHeader.frameSize, durationUs);
     }
 
-    long sizeBytes = frame.readUnsignedIntToInt();
-    frame.skipBytes(1);
-    long[] tableOfContents = new long[99];
-    for (int i = 0; i < 99; i++) {
+    long dataSize = frame.readUnsignedIntToInt();
+    long[] tableOfContents = new long[100];
+    for (int i = 0; i < 100; i++) {
       tableOfContents[i] = frame.readUnsignedByte();
     }
 
     // TODO: Handle encoder delay and padding in 3 bytes offset by xingBase + 213 bytes:
     // delay = (frame.readUnsignedByte() << 4) + (frame.readUnsignedByte() >> 4);
     // padding = ((frame.readUnsignedByte() & 0x0F) << 8) + frame.readUnsignedByte();
-    return new XingSeeker(firstFramePosition, durationUs, inputLength, tableOfContents,
-        sizeBytes, mpegAudioHeader.frameSize);
+
+    if (inputLength != C.LENGTH_UNSET && inputLength != position + dataSize) {
+      Log.w(TAG, "XING data size mismatch: " + inputLength + ", " + (position + dataSize));
+    }
+    return new XingSeeker(position, mpegAudioHeader.frameSize, durationUs, dataSize,
+        tableOfContents);
   }
 
-  private final long firstFramePosition;
+  private final long dataStartPosition;
+  private final int xingFrameSize;
   private final long durationUs;
-  private final long inputLength;
+  /**
+   * Data size, including the XING frame.
+   */
+  private final long dataSize;
   /**
    * Entries are in the range [0, 255], but are stored as long integers for convenience.
    */
   private final long[] tableOfContents;
-  private final long sizeBytes;
-  private final int headerSize;
 
-  private XingSeeker(long firstFramePosition, long durationUs, long inputLength) {
-    this(firstFramePosition, durationUs, inputLength, null, 0, 0);
+  private XingSeeker(long dataStartPosition, int xingFrameSize, long durationUs) {
+    this(dataStartPosition, xingFrameSize, durationUs, C.LENGTH_UNSET, null);
   }
 
-  private XingSeeker(long firstFramePosition, long durationUs, long inputLength,
-      long[] tableOfContents, long sizeBytes, int headerSize) {
-    this.firstFramePosition = firstFramePosition;
+  private XingSeeker(long dataStartPosition, int xingFrameSize, long durationUs, long dataSize,
+      long[] tableOfContents) {
+    this.dataStartPosition = dataStartPosition;
+    this.xingFrameSize = xingFrameSize;
     this.durationUs = durationUs;
-    this.inputLength = inputLength;
+    this.dataSize = dataSize;
     this.tableOfContents = tableOfContents;
-    this.sizeBytes = sizeBytes;
-    this.headerSize = headerSize;
   }
 
   @Override
@@ -101,55 +108,48 @@ public boolean isSeekable() {
   }
 
   @Override
-  public long getPosition(long timeUs) {
+  public SeekPoints getSeekPoints(long timeUs) {
     if (!isSeekable()) {
-      return firstFramePosition;
+      return new SeekPoints(new SeekPoint(0, dataStartPosition + xingFrameSize));
     }
-    float percent = timeUs * 100f / durationUs;
-    float fx;
-    if (percent <= 0f) {
-      fx = 0f;
-    } else if (percent >= 100f) {
-      fx = 256f;
+    timeUs = Util.constrainValue(timeUs, 0, durationUs);
+    double percent = (timeUs * 100d) / durationUs;
+    double scaledPosition;
+    if (percent <= 0) {
+      scaledPosition = 0;
+    } else if (percent >= 100) {
+      scaledPosition = 256;
     } else {
-      int a = (int) percent;
-      float fa, fb;
-      if (a == 0) {
-        fa = 0f;
-      } else {
-        fa = tableOfContents[a - 1];
-      }
-      if (a < 99) {
-        fb = tableOfContents[a];
-      } else {
-        fb = 256f;
-      }
-      fx = fa + (fb - fa) * (percent - a);
+      int prevTableIndex = (int) percent;
+      double prevScaledPosition = tableOfContents[prevTableIndex];
+      double nextScaledPosition = prevTableIndex == 99 ? 256 : tableOfContents[prevTableIndex + 1];
+      // Linearly interpolate between the two scaled positions.
+      double interpolateFraction = percent - prevTableIndex;
+      scaledPosition = prevScaledPosition
+          + (interpolateFraction * (nextScaledPosition - prevScaledPosition));
     }
-
-    long position = Math.round((1.0 / 256) * fx * sizeBytes) + firstFramePosition;
-    long maximumPosition = inputLength != C.LENGTH_UNSET ? inputLength - 1
-        : firstFramePosition - headerSize + sizeBytes - 1;
-    return Math.min(position, maximumPosition);
+    long positionOffset = Math.round((scaledPosition / 256) * dataSize);
+    // Ensure returned positions skip the frame containing the XING header.
+    positionOffset = Util.constrainValue(positionOffset, xingFrameSize, dataSize - 1);
+    return new SeekPoints(new SeekPoint(timeUs, dataStartPosition + positionOffset));
   }
 
   @Override
   public long getTimeUs(long position) {
-    if (!isSeekable() || position < firstFramePosition) {
+    long positionOffset = position - dataStartPosition;
+    if (!isSeekable() || positionOffset <= xingFrameSize) {
       return 0L;
     }
-    double offsetByte = 256.0 * (position - firstFramePosition) / sizeBytes;
-    int previousTocPosition =
-        Util.binarySearchFloor(tableOfContents, (long) offsetByte, true, false) + 1;
-    long previousTime = getTimeUsForTocPosition(previousTocPosition);
-
-    // Linearly interpolate the time taking into account the next entry.
-    long previousByte = previousTocPosition == 0 ? 0 : tableOfContents[previousTocPosition - 1];
-    long nextByte = previousTocPosition == 99 ? 256 : tableOfContents[previousTocPosition];
-    long nextTime = getTimeUsForTocPosition(previousTocPosition + 1);
-    long timeOffset = nextByte == previousByte ? 0 : (long) ((nextTime - previousTime)
-        * (offsetByte - previousByte) / (nextByte - previousByte));
-    return previousTime + timeOffset;
+    double scaledPosition = (positionOffset * 256d) / dataSize;
+    int prevTableIndex = Util.binarySearchFloor(tableOfContents, (long) scaledPosition, true, true);
+    long prevTimeUs = getTimeUsForTableIndex(prevTableIndex);
+    long prevScaledPosition = tableOfContents[prevTableIndex];
+    long nextTimeUs = getTimeUsForTableIndex(prevTableIndex + 1);
+    long nextScaledPosition = prevTableIndex == 99 ? 256 : tableOfContents[prevTableIndex + 1];
+    // Linearly interpolate between the two table entries.
+    double interpolateFraction = prevScaledPosition == nextScaledPosition ? 0
+        : ((scaledPosition - prevScaledPosition) / (nextScaledPosition - prevScaledPosition));
+    return prevTimeUs + Math.round(interpolateFraction * (nextTimeUs - prevTimeUs));
   }
 
   @Override
@@ -158,11 +158,13 @@ public long getDurationUs() {
   }
 
   /**
-   * Returns the time in microseconds corresponding to a table of contents position, which is
-   * interpreted as a percentage of the stream's duration between 0 and 100.
+   * Returns the time in microseconds for a given table index.
+   *
+   * @param tableIndex A table index in the range [0, 100].
+   * @return The corresponding time in microseconds.
    */
-  private long getTimeUsForTocPosition(int tocPosition) {
-    return durationUs * tocPosition / 100;
+  private long getTimeUsForTableIndex(int tableIndex) {
+    return (durationUs * tableIndex) / 100;
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
index 588282bc9b..30358ff7c7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/AtomParsers.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
+import static com.google.android.exoplayer2.util.MimeTypes.getMimeTypeFromMp4ObjectType;
+
 import android.util.Log;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
@@ -49,7 +51,6 @@
   private static final int TYPE_sbtl = Util.getIntegerCodeForString("sbtl");
   private static final int TYPE_subt = Util.getIntegerCodeForString("subt");
   private static final int TYPE_clcp = Util.getIntegerCodeForString("clcp");
-  private static final int TYPE_cenc = Util.getIntegerCodeForString("cenc");
   private static final int TYPE_meta = Util.getIntegerCodeForString("meta");
 
   /**
@@ -128,7 +129,8 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
 
     int sampleCount = sampleSizeBox.getSampleCount();
     if (sampleCount == 0) {
-      return new TrackSampleTable(new long[0], new int[0], 0, new long[0], new int[0]);
+      return new TrackSampleTable(
+          new long[0], new int[0], 0, new long[0], new int[0], C.TIME_UNSET);
     }
 
     // Entries are byte offsets of chunks.
@@ -193,6 +195,7 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     long[] timestamps;
     int[] flags;
     long timestampTimeUnits = 0;
+    long duration;
 
     if (!isRechunkable) {
       offsets = new long[sampleCount];
@@ -260,6 +263,7 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         offset += sizes[i];
         remainingSamplesInChunk--;
       }
+      duration = timestampTimeUnits + timestampOffset;
 
       Assertions.checkArgument(remainingSamplesAtTimestampOffset == 0);
       // Remove trailing ctts entries with 0-valued sample counts.
@@ -294,13 +298,15 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       maximumSize = rechunkedResults.maximumSize;
       timestamps = rechunkedResults.timestamps;
       flags = rechunkedResults.flags;
+      duration = rechunkedResults.duration;
     }
+    long durationUs = Util.scaleLargeTimestamp(duration, C.MICROS_PER_SECOND, track.timescale);
 
     if (track.editListDurations == null || gaplessInfoHolder.hasGaplessInfo()) {
       // There is no edit list, or we are ignoring it as we already have gapless metadata to apply.
       // This implementation does not support applying both gapless metadata and an edit list.
       Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
-      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
+      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
     }
 
     // See the BMFF spec (ISO 14496-12) subsection 8.6.6. Edit lists that require prerolling from a
@@ -317,10 +323,11 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       long editStartTime = track.editListMediaTimes[0];
       long editEndTime = editStartTime + Util.scaleLargeTimestamp(track.editListDurations[0],
           track.timescale, track.movieTimescale);
-      long lastSampleEndTime = timestampTimeUnits;
-      if (timestamps[0] <= editStartTime && editStartTime < timestamps[1]
-          && timestamps[timestamps.length - 1] < editEndTime && editEndTime <= lastSampleEndTime) {
-        long paddingTimeUnits = lastSampleEndTime - editEndTime;
+      if (timestamps[0] <= editStartTime
+          && editStartTime < timestamps[1]
+          && timestamps[timestamps.length - 1] < editEndTime
+          && editEndTime <= duration) {
+        long paddingTimeUnits = duration - editEndTime;
         long encoderDelay = Util.scaleLargeTimestamp(editStartTime - timestamps[0],
             track.format.sampleRate, track.timescale);
         long encoderPadding = Util.scaleLargeTimestamp(paddingTimeUnits,
@@ -330,7 +337,7 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
           gaplessInfoHolder.encoderDelay = (int) encoderDelay;
           gaplessInfoHolder.encoderPadding = (int) encoderPadding;
           Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
-          return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
+          return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
         }
       }
     }
@@ -339,11 +346,15 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       // The current version of the spec leaves handling of an edit with zero segment_duration in
       // unfragmented files open to interpretation. We handle this as a special case and include all
       // samples in the edit.
+      long editStartTime = track.editListMediaTimes[0];
       for (int i = 0; i < timestamps.length; i++) {
-        timestamps[i] = Util.scaleLargeTimestamp(timestamps[i] - track.editListMediaTimes[0],
-            C.MICROS_PER_SECOND, track.timescale);
+        timestamps[i] =
+            Util.scaleLargeTimestamp(
+                timestamps[i] - editStartTime, C.MICROS_PER_SECOND, track.timescale);
       }
-      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
+      durationUs =
+          Util.scaleLargeTimestamp(duration - editStartTime, C.MICROS_PER_SECOND, track.timescale);
+      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
     }
 
     // Omit any sample at the end point of an edit for audio tracks.
@@ -354,13 +365,15 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     int nextSampleIndex = 0;
     boolean copyMetadata = false;
     for (int i = 0; i < track.editListDurations.length; i++) {
-      long mediaTime = track.editListMediaTimes[i];
-      if (mediaTime != -1) {
-        long duration = Util.scaleLargeTimestamp(track.editListDurations[i], track.timescale,
-            track.movieTimescale);
-        int startIndex = Util.binarySearchCeil(timestamps, mediaTime, true, true);
-        int endIndex = Util.binarySearchCeil(timestamps, mediaTime + duration, omitClippedSample,
-            false);
+      long editMediaTime = track.editListMediaTimes[i];
+      if (editMediaTime != -1) {
+        long editDuration =
+            Util.scaleLargeTimestamp(
+                track.editListDurations[i], track.timescale, track.movieTimescale);
+        int startIndex = Util.binarySearchCeil(timestamps, editMediaTime, true, true);
+        int endIndex =
+            Util.binarySearchCeil(
+                timestamps, editMediaTime + editDuration, omitClippedSample, false);
         editedSampleCount += endIndex - startIndex;
         copyMetadata |= nextSampleIndex != startIndex;
         nextSampleIndex = endIndex;
@@ -377,12 +390,13 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
     long pts = 0;
     int sampleIndex = 0;
     for (int i = 0; i < track.editListDurations.length; i++) {
-      long mediaTime = track.editListMediaTimes[i];
-      long duration = track.editListDurations[i];
-      if (mediaTime != -1) {
-        long endMediaTime = mediaTime + Util.scaleLargeTimestamp(duration, track.timescale,
-            track.movieTimescale);
-        int startIndex = Util.binarySearchCeil(timestamps, mediaTime, true, true);
+      long editMediaTime = track.editListMediaTimes[i];
+      long editDuration = track.editListDurations[i];
+      if (editMediaTime != -1) {
+        long endMediaTime =
+            editMediaTime
+                + Util.scaleLargeTimestamp(editDuration, track.timescale, track.movieTimescale);
+        int startIndex = Util.binarySearchCeil(timestamps, editMediaTime, true, true);
         int endIndex = Util.binarySearchCeil(timestamps, endMediaTime, omitClippedSample, false);
         if (copyMetadata) {
           int count = endIndex - startIndex;
@@ -392,8 +406,9 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
         }
         for (int j = startIndex; j < endIndex; j++) {
           long ptsUs = Util.scaleLargeTimestamp(pts, C.MICROS_PER_SECOND, track.movieTimescale);
-          long timeInSegmentUs = Util.scaleLargeTimestamp(timestamps[j] - mediaTime,
-              C.MICROS_PER_SECOND, track.timescale);
+          long timeInSegmentUs =
+              Util.scaleLargeTimestamp(
+                  timestamps[j] - editMediaTime, C.MICROS_PER_SECOND, track.timescale);
           editedTimestamps[sampleIndex] = ptsUs + timeInSegmentUs;
           if (copyMetadata && editedSizes[sampleIndex] > editedMaximumSize) {
             editedMaximumSize = sizes[j];
@@ -401,8 +416,9 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
           sampleIndex++;
         }
       }
-      pts += duration;
+      pts += editDuration;
     }
+    long editedDurationUs = Util.scaleLargeTimestamp(pts, C.MICROS_PER_SECOND, track.timescale);
 
     boolean hasSyncSample = false;
     for (int i = 0; i < editedFlags.length && !hasSyncSample; i++) {
@@ -413,11 +429,16 @@ public static TrackSampleTable parseStbl(Track track, Atom.ContainerAtom stblAto
       // Such edit lists are often (although not always) broken, so we ignore it and continue.
       Log.w(TAG, "Ignoring edit list: Edited sample sequence does not contain a sync sample.");
       Util.scaleLargeTimestampsInPlace(timestamps, C.MICROS_PER_SECOND, track.timescale);
-      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags);
+      return new TrackSampleTable(offsets, sizes, maximumSize, timestamps, flags, durationUs);
     }
 
-    return new TrackSampleTable(editedOffsets, editedSizes, editedMaximumSize, editedTimestamps,
-        editedFlags);
+    return new TrackSampleTable(
+        editedOffsets,
+        editedSizes,
+        editedMaximumSize,
+        editedTimestamps,
+        editedFlags,
+        editedDurationUs);
   }
 
   /**
@@ -1011,47 +1032,11 @@ private static int findEsdsPosition(ParsableByteArray parent, int position, int
 
     // Set the MIME type based on the object type indication (14496-1 table 5).
     int objectTypeIndication = parent.readUnsignedByte();
-    String mimeType;
-    switch (objectTypeIndication) {
-      case 0x60:
-      case 0x61:
-        mimeType = MimeTypes.VIDEO_MPEG2;
-        break;
-      case 0x20:
-        mimeType = MimeTypes.VIDEO_MP4V;
-        break;
-      case 0x21:
-        mimeType = MimeTypes.VIDEO_H264;
-        break;
-      case 0x23:
-        mimeType = MimeTypes.VIDEO_H265;
-        break;
-      case 0x6B:
-        mimeType = MimeTypes.AUDIO_MPEG;
-        return Pair.create(mimeType, null);
-      case 0x40:
-      case 0x66:
-      case 0x67:
-      case 0x68:
-        mimeType = MimeTypes.AUDIO_AAC;
-        break;
-      case 0xA5:
-        mimeType = MimeTypes.AUDIO_AC3;
-        break;
-      case 0xA6:
-        mimeType = MimeTypes.AUDIO_E_AC3;
-        break;
-      case 0xA9:
-      case 0xAC:
-        mimeType = MimeTypes.AUDIO_DTS;
-        return Pair.create(mimeType, null);
-      case 0xAA:
-      case 0xAB:
-        mimeType = MimeTypes.AUDIO_DTS_HD;
-        return Pair.create(mimeType, null);
-      default:
-        mimeType = null;
-        break;
+    String mimeType = getMimeTypeFromMp4ObjectType(objectTypeIndication);
+    if (MimeTypes.AUDIO_MPEG.equals(mimeType)
+        || MimeTypes.AUDIO_DTS.equals(mimeType)
+        || MimeTypes.AUDIO_DTS_HD.equals(mimeType)) {
+      return Pair.create(mimeType, null);
     }
 
     parent.skipBytes(12);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FixedSampleSizeRechunker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FixedSampleSizeRechunker.java
index 5dd6c6ea9f..8336a280a2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FixedSampleSizeRechunker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FixedSampleSizeRechunker.java
@@ -33,13 +33,21 @@
     public final int maximumSize;
     public final long[] timestamps;
     public final int[] flags;
-
-    private Results(long[] offsets, int[] sizes, int maximumSize, long[] timestamps, int[] flags) {
+    public final long duration;
+
+    private Results(
+        long[] offsets,
+        int[] sizes,
+        int maximumSize,
+        long[] timestamps,
+        int[] flags,
+        long duration) {
       this.offsets = offsets;
       this.sizes = sizes;
       this.maximumSize = maximumSize;
       this.timestamps = timestamps;
       this.flags = flags;
+      this.duration = duration;
     }
 
   }
@@ -95,8 +103,9 @@ public static Results rechunk(int fixedSampleSize, long[] chunkOffsets, int[] ch
         newSampleIndex++;
       }
     }
+    long duration = timestampDeltaInTimeUnits * originalSampleIndex;
 
-    return new Results(offsets, sizes, maximumSize, timestamps, flags);
+    return new Results(offsets, sizes, maximumSize, timestamps, flags, duration);
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
index 867e4501fa..7e40f6d2ee 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.util.Pair;
 import android.util.SparseArray;
@@ -44,15 +45,16 @@
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.LinkedList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Stack;
 import java.util.UUID;
 
 /**
- * Facilitates the extraction of data from the fragmented mp4 container format.
+ * Extracts data from the FMP4 container format.
  */
 public final class FragmentedMp4Extractor implements Extractor {
 
@@ -73,8 +75,8 @@
    */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {FLAG_WORKAROUND_EVERY_VIDEO_FRAME_IS_SYNC_FRAME,
-      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_ENABLE_EMSG_TRACK, FLAG_ENABLE_CEA608_TRACK,
-      FLAG_SIDELOADED, FLAG_WORKAROUND_IGNORE_EDIT_LISTS})
+      FLAG_WORKAROUND_IGNORE_TFDT_BOX, FLAG_ENABLE_EMSG_TRACK, FLAG_SIDELOADED,
+      FLAG_WORKAROUND_IGNORE_EDIT_LISTS})
   public @interface Flags {}
   /**
    * Flag to work around an issue in some video streams where every frame is marked as a sync frame.
@@ -93,25 +95,22 @@
    * messages in the stream will be delivered as samples to this track.
    */
   public static final int FLAG_ENABLE_EMSG_TRACK = 4;
-  /**
-   * Flag to indicate that the extractor should output a CEA-608 text track. Any CEA-608 messages
-   * contained within SEI NAL units in the stream will be delivered as samples to this track.
-   */
-  public static final int FLAG_ENABLE_CEA608_TRACK = 8;
   /**
    * Flag to indicate that the {@link Track} was sideloaded, instead of being declared by the MP4
    * container.
    */
-  private static final int FLAG_SIDELOADED = 16;
+  private static final int FLAG_SIDELOADED = 8;
   /**
    * Flag to ignore any edit lists in the stream.
    */
-  public static final int FLAG_WORKAROUND_IGNORE_EDIT_LISTS = 32;
+  public static final int FLAG_WORKAROUND_IGNORE_EDIT_LISTS = 16;
 
   private static final String TAG = "FragmentedMp4Extractor";
   private static final int SAMPLE_GROUP_TYPE_seig = Util.getIntegerCodeForString("seig");
   private static final byte[] PIFF_SAMPLE_ENCRYPTION_BOX_EXTENDED_TYPE =
       new byte[] {-94, 57, 79, 82, 90, -101, 79, 20, -94, 68, 108, 66, 124, 100, -115, -12};
+  private static final Format EMSG_FORMAT =
+      Format.createSampleFormat(null, MimeTypes.APPLICATION_EMSG, Format.OFFSET_SAMPLE_RELATIVE);
 
   // Parser states.
   private static final int STATE_READING_ATOM_HEADER = 0;
@@ -124,7 +123,8 @@
   @Flags private final int flags;
   private final Track sideloadedTrack;
 
-  // Manifest DRM data.
+  // Sideloaded data.
+  private final List<Format> closedCaptionFormats;
   private final DrmInitData sideloadedDrmInitData;
 
   // Track-linked data bundle, accessible as a whole through trackID.
@@ -144,7 +144,8 @@
   private final ParsableByteArray atomHeader;
   private final byte[] extendedTypeScratch;
   private final Stack<ContainerAtom> containerAtoms;
-  private final LinkedList<MetadataSampleInfo> pendingMetadataSampleInfos;
+  private final ArrayDeque<MetadataSampleInfo> pendingMetadataSampleInfos;
+  private final @Nullable TrackOutput additionalEmsgTrackOutput;
 
   private int parserState;
   private int atomType;
@@ -164,7 +165,7 @@
 
   // Extractor output.
   private ExtractorOutput extractorOutput;
-  private TrackOutput eventMessageTrackOutput;
+  private TrackOutput[] emsgTrackOutputs;
   private TrackOutput[] cea608TrackOutputs;
 
   // Whether extractorOutput.seekMap has been called.
@@ -193,15 +194,54 @@ public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjus
    * @param flags Flags that control the extractor's behavior.
    * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
    * @param sideloadedTrack Sideloaded track information, in the case that the extractor
-   *     will not receive a moov box in the input data.
-   * @param sideloadedDrmInitData The {@link DrmInitData} to use for encrypted tracks.
+   *     will not receive a moov box in the input data. Null if a moov box is expected.
+   * @param sideloadedDrmInitData The {@link DrmInitData} to use for encrypted tracks. If null, the
+   *     pssh boxes (if present) will be used.
    */
   public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjuster,
       Track sideloadedTrack, DrmInitData sideloadedDrmInitData) {
+    this(flags, timestampAdjuster, sideloadedTrack, sideloadedDrmInitData,
+        Collections.<Format>emptyList());
+  }
+
+  /**
+   * @param flags Flags that control the extractor's behavior.
+   * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
+   * @param sideloadedTrack Sideloaded track information, in the case that the extractor
+   *     will not receive a moov box in the input data. Null if a moov box is expected.
+   * @param sideloadedDrmInitData The {@link DrmInitData} to use for encrypted tracks. If null, the
+   *     pssh boxes (if present) will be used.
+   * @param closedCaptionFormats For tracks that contain SEI messages, the formats of the closed
+   *     caption channels to expose.
+   */
+  public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjuster,
+      Track sideloadedTrack, DrmInitData sideloadedDrmInitData, List<Format> closedCaptionFormats) {
+    this(flags, timestampAdjuster, sideloadedTrack, sideloadedDrmInitData,
+        closedCaptionFormats, null);
+  }
+
+  /**
+   * @param flags Flags that control the extractor's behavior.
+   * @param timestampAdjuster Adjusts sample timestamps. May be null if no adjustment is needed.
+   * @param sideloadedTrack Sideloaded track information, in the case that the extractor
+   *     will not receive a moov box in the input data. Null if a moov box is expected.
+   * @param sideloadedDrmInitData The {@link DrmInitData} to use for encrypted tracks. If null, the
+   *     pssh boxes (if present) will be used.
+   * @param closedCaptionFormats For tracks that contain SEI messages, the formats of the closed
+   *     caption channels to expose.
+   * @param additionalEmsgTrackOutput An extra track output that will receive all emsg messages
+   *     targeting the player, even if {@link #FLAG_ENABLE_EMSG_TRACK} is not set. Null if special
+   *     handling of emsg messages for players is not required.
+   */
+  public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjuster,
+      Track sideloadedTrack, DrmInitData sideloadedDrmInitData, List<Format> closedCaptionFormats,
+      @Nullable TrackOutput additionalEmsgTrackOutput) {
     this.flags = flags | (sideloadedTrack != null ? FLAG_SIDELOADED : 0);
     this.timestampAdjuster = timestampAdjuster;
     this.sideloadedTrack = sideloadedTrack;
     this.sideloadedDrmInitData = sideloadedDrmInitData;
+    this.closedCaptionFormats = Collections.unmodifiableList(closedCaptionFormats);
+    this.additionalEmsgTrackOutput = additionalEmsgTrackOutput;
     atomHeader = new ParsableByteArray(Atom.LONG_HEADER_SIZE);
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalPrefix = new ParsableByteArray(5);
@@ -210,7 +250,7 @@ public FragmentedMp4Extractor(@Flags int flags, TimestampAdjuster timestampAdjus
     defaultInitializationVector = new ParsableByteArray();
     extendedTypeScratch = new byte[16];
     containerAtoms = new Stack<>();
-    pendingMetadataSampleInfos = new LinkedList<>();
+    pendingMetadataSampleInfos = new ArrayDeque<>();
     trackBundles = new SparseArray<>();
     durationUs = C.TIME_UNSET;
     segmentIndexEarliestPresentationTimeUs = C.TIME_UNSET;
@@ -330,7 +370,8 @@ private boolean readAtomHeader(ExtractorInput input) throws IOException, Interru
       currentTrackBundle = null;
       endOfMdatPosition = atomPosition + atomSize;
       if (!haveOutputSeekMap) {
-        extractorOutput.seekMap(new SeekMap.Unseekable(durationUs));
+        // This must be the first mdat in the stream.
+        extractorOutput.seekMap(new SeekMap.Unseekable(durationUs, atomPosition));
         haveOutputSeekMap = true;
       }
       parserState = STATE_READING_ENCRYPTION_DATA;
@@ -478,44 +519,61 @@ private void onMoofContainerAtomRead(ContainerAtom moof) throws ParserException
   }
 
   private void maybeInitExtraTracks() {
-    if ((flags & FLAG_ENABLE_EMSG_TRACK) != 0 && eventMessageTrackOutput == null) {
-      eventMessageTrackOutput = extractorOutput.track(trackBundles.size(), C.TRACK_TYPE_METADATA);
-      eventMessageTrackOutput.format(Format.createSampleFormat(null, MimeTypes.APPLICATION_EMSG,
-          Format.OFFSET_SAMPLE_RELATIVE));
-    }
-    if ((flags & FLAG_ENABLE_CEA608_TRACK) != 0 && cea608TrackOutputs == null) {
-      TrackOutput cea608TrackOutput = extractorOutput.track(trackBundles.size() + 1,
-          C.TRACK_TYPE_TEXT);
-      cea608TrackOutput.format(Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608, 0,
-          null));
-      cea608TrackOutputs = new TrackOutput[] {cea608TrackOutput};
+    if (emsgTrackOutputs == null) {
+      emsgTrackOutputs = new TrackOutput[2];
+      int emsgTrackOutputCount = 0;
+      if (additionalEmsgTrackOutput != null) {
+        emsgTrackOutputs[emsgTrackOutputCount++] = additionalEmsgTrackOutput;
+      }
+      if ((flags & FLAG_ENABLE_EMSG_TRACK) != 0) {
+        emsgTrackOutputs[emsgTrackOutputCount++] =
+            extractorOutput.track(trackBundles.size(), C.TRACK_TYPE_METADATA);
+      }
+      emsgTrackOutputs = Arrays.copyOf(emsgTrackOutputs, emsgTrackOutputCount);
+
+      for (TrackOutput eventMessageTrackOutput : emsgTrackOutputs) {
+        eventMessageTrackOutput.format(EMSG_FORMAT);
+      }
+    }
+    if (cea608TrackOutputs == null) {
+      cea608TrackOutputs = new TrackOutput[closedCaptionFormats.size()];
+      for (int i = 0; i < cea608TrackOutputs.length; i++) {
+        TrackOutput output = extractorOutput.track(trackBundles.size() + 1 + i, C.TRACK_TYPE_TEXT);
+        output.format(closedCaptionFormats.get(i));
+        cea608TrackOutputs[i] = output;
+      }
     }
   }
 
   /**
-   * Handles an emsg atom (defined in 23009-1).
+   * Parses an emsg atom (defined in 23009-1).
    */
   private void onEmsgLeafAtomRead(ParsableByteArray atom) {
-    if (eventMessageTrackOutput == null) {
+    if (emsgTrackOutputs == null || emsgTrackOutputs.length == 0) {
       return;
     }
-    // Parse the event's presentation time delta.
+
     atom.setPosition(Atom.FULL_HEADER_SIZE);
+    int sampleSize = atom.bytesLeft();
     atom.readNullTerminatedString(); // schemeIdUri
     atom.readNullTerminatedString(); // value
     long timescale = atom.readUnsignedInt();
     long presentationTimeDeltaUs =
         Util.scaleLargeTimestamp(atom.readUnsignedInt(), C.MICROS_PER_SECOND, timescale);
+
     // Output the sample data.
-    atom.setPosition(Atom.FULL_HEADER_SIZE);
-    int sampleSize = atom.bytesLeft();
-    eventMessageTrackOutput.sampleData(atom, sampleSize);
+    for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {
+      atom.setPosition(Atom.FULL_HEADER_SIZE);
+      emsgTrackOutput.sampleData(atom, sampleSize);
+    }
+
     // Output the sample metadata.
     if (segmentIndexEarliestPresentationTimeUs != C.TIME_UNSET) {
-      // We can output the sample metadata immediately.
-      eventMessageTrackOutput.sampleMetadata(
-          segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs,
-          C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0 /* offset */, null);
+      for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {
+        emsgTrackOutput.sampleMetadata(
+            segmentIndexEarliestPresentationTimeUs + presentationTimeDeltaUs,
+            C.BUFFER_FLAG_KEY_FRAME, sampleSize, 0 /* offset */, null);
+      }
     } else {
       // We need the first sample timestamp in the segment before we can output the metadata.
       pendingMetadataSampleInfos.addLast(
@@ -1123,7 +1181,7 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
           output.sampleData(nalStartCode, 4);
           // Write the NAL unit type byte.
           output.sampleData(nalPrefix, 1);
-          processSeiNalUnitPayload = cea608TrackOutputs != null
+          processSeiNalUnitPayload = cea608TrackOutputs.length > 0
               && NalUnitUtil.isNalUnitSei(track.format.sampleMimeType, nalPrefixData[4]);
           sampleBytesWritten += 5;
           sampleSize += nalUnitLengthFieldLengthDiff;
@@ -1177,13 +1235,8 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
 
     output.sampleMetadata(sampleTimeUs, sampleFlags, sampleSize, 0, cryptoData);
 
-    while (!pendingMetadataSampleInfos.isEmpty()) {
-      MetadataSampleInfo sampleInfo = pendingMetadataSampleInfos.removeFirst();
-      pendingMetadataSampleBytes -= sampleInfo.size;
-      eventMessageTrackOutput.sampleMetadata(
-          sampleTimeUs + sampleInfo.presentationTimeDeltaUs,
-          C.BUFFER_FLAG_KEY_FRAME, sampleInfo.size, pendingMetadataSampleBytes, null);
-    }
+    // After we have the sampleTimeUs, we can commit all the pending metadata samples
+    outputPendingMetadataSamples(sampleTimeUs);
 
     currentTrackBundle.currentSampleIndex++;
     currentTrackBundle.currentSampleInTrackRun++;
@@ -1197,6 +1250,18 @@ private boolean readSample(ExtractorInput input) throws IOException, Interrupted
     return true;
   }
 
+  private void outputPendingMetadataSamples(long sampleTimeUs) {
+    while (!pendingMetadataSampleInfos.isEmpty()) {
+      MetadataSampleInfo sampleInfo = pendingMetadataSampleInfos.removeFirst();
+      pendingMetadataSampleBytes -= sampleInfo.size;
+      for (TrackOutput emsgTrackOutput : emsgTrackOutputs) {
+        emsgTrackOutput.sampleMetadata(
+            sampleTimeUs + sampleInfo.presentationTimeDeltaUs,
+            C.BUFFER_FLAG_KEY_FRAME, sampleInfo.size, pendingMetadataSampleBytes, null);
+      }
+    }
+  }
+
   /**
    * Returns the {@link TrackBundle} whose fragment run has the earliest file position out of those
    * yet to be consumed, or null if all have been consumed.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
index f23af98e7f..75bd2c16ee 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.extractor.GaplessInfoHolder;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.mp4.Atom.ContainerAtom;
 import com.google.android.exoplayer2.metadata.Metadata;
@@ -41,7 +42,7 @@
 import java.util.Stack;
 
 /**
- * Extracts data from an unfragmented MP4 file.
+ * Extracts data from the MP4 container format.
  */
 public final class Mp4Extractor implements Extractor, SeekMap {
 
@@ -87,6 +88,12 @@
    */
   private static final long RELOAD_MINIMUM_SEEK_DISTANCE = 256 * 1024;
 
+  /**
+   * For poorly interleaved streams, the maximum byte difference one track is allowed to be read
+   * ahead before the source will be reloaded at a new position to read another track.
+   */
+  private static final long MAXIMUM_READ_AHEAD_BYTES_STREAM = 10 * 1024 * 1024;
+
   private final @Flags int flags;
 
   // Temporary arrays.
@@ -102,12 +109,15 @@
   private int atomHeaderBytesRead;
   private ParsableByteArray atomData;
 
+  private int sampleTrackIndex;
   private int sampleBytesWritten;
   private int sampleCurrentNalBytesRemaining;
 
   // Extractor outputs.
   private ExtractorOutput extractorOutput;
   private Mp4Track[] tracks;
+  private long[][] accumulatedSampleSizes;
+  private int firstVideoTrackIndex;
   private long durationUs;
   private boolean isQuickTime;
 
@@ -130,6 +140,7 @@ public Mp4Extractor(@Flags int flags) {
     containerAtoms = new Stack<>();
     nalStartCode = new ParsableByteArray(NalUnitUtil.NAL_START_CODE);
     nalLength = new ParsableByteArray(4);
+    sampleTrackIndex = C.INDEX_UNSET;
   }
 
   @Override
@@ -146,6 +157,7 @@ public void init(ExtractorOutput output) {
   public void seek(long position, long timeUs) {
     containerAtoms.clear();
     atomHeaderBytesRead = 0;
+    sampleTrackIndex = C.INDEX_UNSET;
     sampleBytesWritten = 0;
     sampleCurrentNalBytesRemaining = 0;
     if (position == 0) {
@@ -196,21 +208,56 @@ public long getDurationUs() {
   }
 
   @Override
-  public long getPosition(long timeUs) {
-    long earliestSamplePosition = Long.MAX_VALUE;
-    for (Mp4Track track : tracks) {
-      TrackSampleTable sampleTable = track.sampleTable;
-      int sampleIndex = sampleTable.getIndexOfEarlierOrEqualSynchronizationSample(timeUs);
+  public SeekPoints getSeekPoints(long timeUs) {
+    if (tracks.length == 0) {
+      return new SeekPoints(SeekPoint.START);
+    }
+
+    long firstTimeUs;
+    long firstOffset;
+    long secondTimeUs = C.TIME_UNSET;
+    long secondOffset = C.POSITION_UNSET;
+
+    // If we have a video track, use it to establish one or two seek points.
+    if (firstVideoTrackIndex != C.INDEX_UNSET) {
+      TrackSampleTable sampleTable = tracks[firstVideoTrackIndex].sampleTable;
+      int sampleIndex = getSynchronizationSampleIndex(sampleTable, timeUs);
       if (sampleIndex == C.INDEX_UNSET) {
-        // Handle the case where the requested time is before the first synchronization sample.
-        sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
+        return new SeekPoints(SeekPoint.START);
+      }
+      long sampleTimeUs = sampleTable.timestampsUs[sampleIndex];
+      firstTimeUs = sampleTimeUs;
+      firstOffset = sampleTable.offsets[sampleIndex];
+      if (sampleTimeUs < timeUs && sampleIndex < sampleTable.sampleCount - 1) {
+        int secondSampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
+        if (secondSampleIndex != C.INDEX_UNSET && secondSampleIndex != sampleIndex) {
+          secondTimeUs = sampleTable.timestampsUs[secondSampleIndex];
+          secondOffset = sampleTable.offsets[secondSampleIndex];
+        }
       }
-      long offset = sampleTable.offsets[sampleIndex];
-      if (offset < earliestSamplePosition) {
-        earliestSamplePosition = offset;
+    } else {
+      firstTimeUs = timeUs;
+      firstOffset = Long.MAX_VALUE;
+    }
+
+    // Take into account other tracks.
+    for (int i = 0; i < tracks.length; i++) {
+      if (i != firstVideoTrackIndex) {
+        TrackSampleTable sampleTable = tracks[i].sampleTable;
+        firstOffset = maybeAdjustSeekOffset(sampleTable, firstTimeUs, firstOffset);
+        if (secondTimeUs != C.TIME_UNSET) {
+          secondOffset = maybeAdjustSeekOffset(sampleTable, secondTimeUs, secondOffset);
+        }
       }
     }
-    return earliestSamplePosition;
+
+    SeekPoint firstSeekPoint = new SeekPoint(firstTimeUs, firstOffset);
+    if (secondTimeUs == C.TIME_UNSET) {
+      return new SeekPoints(firstSeekPoint);
+    } else {
+      SeekPoint secondSeekPoint = new SeekPoint(secondTimeUs, secondOffset);
+      return new SeekPoints(firstSeekPoint, secondSeekPoint);
+    }
   }
 
   // Private methods.
@@ -326,34 +373,13 @@ private void processAtomEnded(long atomEndPosition) throws ParserException {
     }
   }
 
-  /**
-   * Process an ftyp atom to determine whether the media is QuickTime.
-   *
-   * @param atomData The ftyp atom data.
-   * @return Whether the media is QuickTime.
-   */
-  private static boolean processFtypAtom(ParsableByteArray atomData) {
-    atomData.setPosition(Atom.HEADER_SIZE);
-    int majorBrand = atomData.readInt();
-    if (majorBrand == BRAND_QUICKTIME) {
-      return true;
-    }
-    atomData.skipBytes(4); // minor_version
-    while (atomData.bytesLeft() > 0) {
-      if (atomData.readInt() == BRAND_QUICKTIME) {
-        return true;
-      }
-    }
-    return false;
-  }
-
   /**
    * Updates the stored track metadata to reflect the contents of the specified moov atom.
    */
   private void processMoovAtom(ContainerAtom moov) throws ParserException {
+    int firstVideoTrackIndex = C.INDEX_UNSET;
     long durationUs = C.TIME_UNSET;
     List<Mp4Track> tracks = new ArrayList<>();
-    long earliestSampleOffset = Long.MAX_VALUE;
 
     Metadata metadata = null;
     GaplessInfoHolder gaplessInfoHolder = new GaplessInfoHolder();
@@ -401,16 +427,20 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
       }
       mp4Track.trackOutput.format(format);
 
-      durationUs = Math.max(durationUs, track.durationUs);
-      tracks.add(mp4Track);
-
-      long firstSampleOffset = trackSampleTable.offsets[0];
-      if (firstSampleOffset < earliestSampleOffset) {
-        earliestSampleOffset = firstSampleOffset;
+      durationUs =
+          Math.max(
+              durationUs,
+              track.durationUs != C.TIME_UNSET ? track.durationUs : trackSampleTable.durationUs);
+      if (track.type == C.TRACK_TYPE_VIDEO && firstVideoTrackIndex == C.INDEX_UNSET) {
+        firstVideoTrackIndex = tracks.size();
       }
+      tracks.add(mp4Track);
     }
+    this.firstVideoTrackIndex = firstVideoTrackIndex;
     this.durationUs = durationUs;
     this.tracks = tracks.toArray(new Mp4Track[tracks.size()]);
+    accumulatedSampleSizes = calculateAccumulatedSampleSizes(this.tracks);
+
     extractorOutput.endTracks();
     extractorOutput.seekMap(this);
   }
@@ -433,26 +463,29 @@ private void processMoovAtom(ContainerAtom moov) throws ParserException {
    */
   private int readSample(ExtractorInput input, PositionHolder positionHolder)
       throws IOException, InterruptedException {
-    int trackIndex = getTrackIndexOfEarliestCurrentSample();
-    if (trackIndex == C.INDEX_UNSET) {
-      return RESULT_END_OF_INPUT;
+    long inputPosition = input.getPosition();
+    if (sampleTrackIndex == C.INDEX_UNSET) {
+      sampleTrackIndex = getTrackIndexOfNextReadSample(inputPosition);
+      if (sampleTrackIndex == C.INDEX_UNSET) {
+        return RESULT_END_OF_INPUT;
+      }
     }
-    Mp4Track track = tracks[trackIndex];
+    Mp4Track track = tracks[sampleTrackIndex];
     TrackOutput trackOutput = track.trackOutput;
     int sampleIndex = track.sampleIndex;
     long position = track.sampleTable.offsets[sampleIndex];
     int sampleSize = track.sampleTable.sizes[sampleIndex];
+    long skipAmount = position - inputPosition + sampleBytesWritten;
+    if (skipAmount < 0 || skipAmount >= RELOAD_MINIMUM_SEEK_DISTANCE) {
+      positionHolder.position = position;
+      return RESULT_SEEK;
+    }
     if (track.track.sampleTransformation == Track.TRANSFORMATION_CEA608_CDAT) {
       // The sample information is contained in a cdat atom. The header must be discarded for
       // committing.
-      position += Atom.HEADER_SIZE;
+      skipAmount += Atom.HEADER_SIZE;
       sampleSize -= Atom.HEADER_SIZE;
     }
-    long skipAmount = position - input.getPosition() + sampleBytesWritten;
-    if (skipAmount < 0 || skipAmount >= RELOAD_MINIMUM_SEEK_DISTANCE) {
-      positionHolder.position = position;
-      return RESULT_SEEK;
-    }
     input.skipFully((int) skipAmount);
     if (track.track.nalUnitLengthFieldLength != 0) {
       // Zero the top three bytes of the array that we'll use to decode nal unit lengths, in case
@@ -494,33 +527,61 @@ private int readSample(ExtractorInput input, PositionHolder positionHolder)
     trackOutput.sampleMetadata(track.sampleTable.timestampsUs[sampleIndex],
         track.sampleTable.flags[sampleIndex], sampleSize, 0, null);
     track.sampleIndex++;
+    sampleTrackIndex = C.INDEX_UNSET;
     sampleBytesWritten = 0;
     sampleCurrentNalBytesRemaining = 0;
     return RESULT_CONTINUE;
   }
 
   /**
-   * Returns the index of the track that contains the earliest current sample, or
-   * {@link C#INDEX_UNSET} if no samples remain.
+   * Returns the index of the track that contains the next sample to be read, or {@link
+   * C#INDEX_UNSET} if no samples remain.
+   *
+   * <p>The preferred choice is the sample with the smallest offset not requiring a source reload,
+   * or if not available the sample with the smallest overall offset to avoid subsequent source
+   * reloads.
+   *
+   * <p>To deal with poor sample interleaving, we also check whether the required memory to catch up
+   * with the next logical sample (based on sample time) exceeds {@link
+   * #MAXIMUM_READ_AHEAD_BYTES_STREAM}. If this is the case, we continue with this sample even
+   * though it may require a source reload.
    */
-  private int getTrackIndexOfEarliestCurrentSample() {
-    int earliestSampleTrackIndex = C.INDEX_UNSET;
-    long earliestSampleOffset = Long.MAX_VALUE;
+  private int getTrackIndexOfNextReadSample(long inputPosition) {
+    long preferredSkipAmount = Long.MAX_VALUE;
+    boolean preferredRequiresReload = true;
+    int preferredTrackIndex = C.INDEX_UNSET;
+    long preferredAccumulatedBytes = Long.MAX_VALUE;
+    long minAccumulatedBytes = Long.MAX_VALUE;
+    boolean minAccumulatedBytesRequiresReload = true;
+    int minAccumulatedBytesTrackIndex = C.INDEX_UNSET;
     for (int trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
       Mp4Track track = tracks[trackIndex];
       int sampleIndex = track.sampleIndex;
       if (sampleIndex == track.sampleTable.sampleCount) {
         continue;
       }
-
-      long trackSampleOffset = track.sampleTable.offsets[sampleIndex];
-      if (trackSampleOffset < earliestSampleOffset) {
-        earliestSampleOffset = trackSampleOffset;
-        earliestSampleTrackIndex = trackIndex;
+      long sampleOffset = track.sampleTable.offsets[sampleIndex];
+      long sampleAccumulatedBytes = accumulatedSampleSizes[trackIndex][sampleIndex];
+      long skipAmount = sampleOffset - inputPosition;
+      boolean requiresReload = skipAmount < 0 || skipAmount >= RELOAD_MINIMUM_SEEK_DISTANCE;
+      if ((!requiresReload && preferredRequiresReload)
+          || (requiresReload == preferredRequiresReload && skipAmount < preferredSkipAmount)) {
+        preferredRequiresReload = requiresReload;
+        preferredSkipAmount = skipAmount;
+        preferredTrackIndex = trackIndex;
+        preferredAccumulatedBytes = sampleAccumulatedBytes;
+      }
+      if (sampleAccumulatedBytes < minAccumulatedBytes) {
+        minAccumulatedBytes = sampleAccumulatedBytes;
+        minAccumulatedBytesRequiresReload = requiresReload;
+        minAccumulatedBytesTrackIndex = trackIndex;
       }
     }
-
-    return earliestSampleTrackIndex;
+    return minAccumulatedBytes == Long.MAX_VALUE
+            || !minAccumulatedBytesRequiresReload
+            || preferredAccumulatedBytes < minAccumulatedBytes + MAXIMUM_READ_AHEAD_BYTES_STREAM
+        ? preferredTrackIndex
+        : minAccumulatedBytesTrackIndex;
   }
 
   /**
@@ -538,6 +599,105 @@ private void updateSampleIndices(long timeUs) {
     }
   }
 
+  /**
+   * For each sample of each track, calculates accumulated size of all samples which need to be read
+   * before this sample can be used.
+   */
+  private static long[][] calculateAccumulatedSampleSizes(Mp4Track[] tracks) {
+    long[][] accumulatedSampleSizes = new long[tracks.length][];
+    int[] nextSampleIndex = new int[tracks.length];
+    long[] nextSampleTimesUs = new long[tracks.length];
+    boolean[] tracksFinished = new boolean[tracks.length];
+    for (int i = 0; i < tracks.length; i++) {
+      accumulatedSampleSizes[i] = new long[tracks[i].sampleTable.sampleCount];
+      nextSampleTimesUs[i] = tracks[i].sampleTable.timestampsUs[0];
+    }
+    long accumulatedSampleSize = 0;
+    int finishedTracks = 0;
+    while (finishedTracks < tracks.length) {
+      long minTimeUs = Long.MAX_VALUE;
+      int minTimeTrackIndex = -1;
+      for (int i = 0; i < tracks.length; i++) {
+        if (!tracksFinished[i] && nextSampleTimesUs[i] <= minTimeUs) {
+          minTimeTrackIndex = i;
+          minTimeUs = nextSampleTimesUs[i];
+        }
+      }
+      int trackSampleIndex = nextSampleIndex[minTimeTrackIndex];
+      accumulatedSampleSizes[minTimeTrackIndex][trackSampleIndex] = accumulatedSampleSize;
+      accumulatedSampleSize += tracks[minTimeTrackIndex].sampleTable.sizes[trackSampleIndex];
+      nextSampleIndex[minTimeTrackIndex] = ++trackSampleIndex;
+      if (trackSampleIndex < accumulatedSampleSizes[minTimeTrackIndex].length) {
+        nextSampleTimesUs[minTimeTrackIndex] =
+            tracks[minTimeTrackIndex].sampleTable.timestampsUs[trackSampleIndex];
+      } else {
+        tracksFinished[minTimeTrackIndex] = true;
+        finishedTracks++;
+      }
+    }
+    return accumulatedSampleSizes;
+  }
+
+  /**
+   * Adjusts a seek point offset to take into account the track with the given {@code sampleTable},
+   * for a given {@code seekTimeUs}.
+   *
+   * @param sampleTable The sample table to use.
+   * @param seekTimeUs The seek time in microseconds.
+   * @param offset The current offset.
+   * @return The adjusted offset.
+   */
+  private static long maybeAdjustSeekOffset(
+      TrackSampleTable sampleTable, long seekTimeUs, long offset) {
+    int sampleIndex = getSynchronizationSampleIndex(sampleTable, seekTimeUs);
+    if (sampleIndex == C.INDEX_UNSET) {
+      return offset;
+    }
+    long sampleOffset = sampleTable.offsets[sampleIndex];
+    return Math.min(sampleOffset, offset);
+  }
+
+  /**
+   * Returns the index of the synchronization sample before or at {@code timeUs}, or the index of
+   * the first synchronization sample if located after {@code timeUs}, or {@link C#INDEX_UNSET} if
+   * there are no synchronization samples in the table.
+   *
+   * @param sampleTable The sample table in which to locate a synchronization sample.
+   * @param timeUs A time in microseconds.
+   * @return The index of the synchronization sample before or at {@code timeUs}, or the index of
+   *     the first synchronization sample if located after {@code timeUs}, or {@link C#INDEX_UNSET}
+   *     if there are no synchronization samples in the table.
+   */
+  private static int getSynchronizationSampleIndex(TrackSampleTable sampleTable, long timeUs) {
+    int sampleIndex = sampleTable.getIndexOfEarlierOrEqualSynchronizationSample(timeUs);
+    if (sampleIndex == C.INDEX_UNSET) {
+      // Handle the case where the requested time is before the first synchronization sample.
+      sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);
+    }
+    return sampleIndex;
+  }
+
+  /**
+   * Process an ftyp atom to determine whether the media is QuickTime.
+   *
+   * @param atomData The ftyp atom data.
+   * @return Whether the media is QuickTime.
+   */
+  private static boolean processFtypAtom(ParsableByteArray atomData) {
+    atomData.setPosition(Atom.HEADER_SIZE);
+    int majorBrand = atomData.readInt();
+    if (majorBrand == BRAND_QUICKTIME) {
+      return true;
+    }
+    atomData.skipBytes(4); // minor_version
+    while (atomData.bytesLeft() > 0) {
+      if (atomData.readInt() == BRAND_QUICKTIME) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   /**
    * Returns whether the extractor should decode a leaf atom with type {@code atom}.
    */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
index cf479eaf3e..9f77c49664 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp4/TrackSampleTable.java
@@ -48,9 +48,19 @@
    * Sample flags.
    */
   public final int[] flags;
+  /**
+   * The duration of the track sample table in microseconds, or {@link C#TIME_UNSET} if the sample
+   * table is empty.
+   */
+  public final long durationUs;
 
-  public TrackSampleTable(long[] offsets, int[] sizes, int maximumSize, long[] timestampsUs,
-      int[] flags) {
+  public TrackSampleTable(
+      long[] offsets,
+      int[] sizes,
+      int maximumSize,
+      long[] timestampsUs,
+      int[] flags,
+      long durationUs) {
     Assertions.checkArgument(sizes.length == timestampsUs.length);
     Assertions.checkArgument(offsets.length == timestampsUs.length);
     Assertions.checkArgument(flags.length == timestampsUs.length);
@@ -60,6 +70,7 @@ public TrackSampleTable(long[] offsets, int[] sizes, int maximumSize, long[] tim
     this.maximumSize = maximumSize;
     this.timestampsUs = timestampsUs;
     this.flags = flags;
+    this.durationUs = durationUs;
     sampleCount = offsets.length;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
index 5470e2badc..042ab681f9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeeker.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.EOFException;
 import java.io.IOException;
@@ -186,7 +187,7 @@ public long getNextSeekPosition(long targetGranule, ExtractorInput input)
         return start;
       }
 
-      long offset = pageSize * (granuleDistance <= 0 ? 2 : 1);
+      long offset = pageSize * (granuleDistance <= 0 ? 2L : 1L);
       long nextPosition = input.getPosition() - offset
           + (granuleDistance * (end - start) / (endGranule - startGranule));
 
@@ -219,12 +220,13 @@ public boolean isSeekable() {
     }
 
     @Override
-    public long getPosition(long timeUs) {
+    public SeekPoints getSeekPoints(long timeUs) {
       if (timeUs == 0) {
-        return startPosition;
+        return new SeekPoints(new SeekPoint(0, startPosition));
       }
       long granule = streamReader.convertTimeToGranule(timeUs);
-      return getEstimatedPosition(startPosition, granule, DEFAULT_OFFSET);
+      long estimatedPosition = getEstimatedPosition(startPosition, granule, DEFAULT_OFFSET);
+      return new SeekPoints(new SeekPoint(timeUs, estimatedPosition));
     }
 
     @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
index f4da6e3960..5eb0727908 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/FlacReader.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.util.FlacStreamInfo;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
@@ -118,8 +119,9 @@ private int getFlacFrameBlockSize(ParsableByteArray packet) {
       case 14:
       case 15:
         return 256 << (blockSizeCode - 8);
+      default:
+        return -1;
     }
-    return -1;
   }
 
   private class FlacOggSeeker implements OggSeeker, SeekMap {
@@ -191,10 +193,20 @@ public boolean isSeekable() {
     }
 
     @Override
-    public long getPosition(long timeUs) {
+    public SeekPoints getSeekPoints(long timeUs) {
       long granule = convertTimeToGranule(timeUs);
       int index = Util.binarySearchFloor(seekPointGranules, granule, true, true);
-      return firstFrameOffset + seekPointOffsets[index];
+      long seekTimeUs = convertGranuleToTime(seekPointGranules[index]);
+      long seekPosition = firstFrameOffset + seekPointOffsets[index];
+      SeekPoint seekPoint = new SeekPoint(seekTimeUs, seekPosition);
+      if (seekTimeUs >= timeUs || index == seekPointGranules.length - 1) {
+        return new SeekPoints(seekPoint);
+      } else {
+        long secondSeekTimeUs = convertGranuleToTime(seekPointGranules[index + 1]);
+        long secondSeekPosition = firstFrameOffset + seekPointOffsets[index + 1];
+        SeekPoint secondSeekPoint = new SeekPoint(secondSeekTimeUs, secondSeekPosition);
+        return new SeekPoints(seekPoint, secondSeekPoint);
+      }
     }
 
     @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
index 54e168c665..a4d8f97d5b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggExtractor.java
@@ -27,7 +27,7 @@
 import java.io.IOException;
 
 /**
- * Ogg {@link Extractor}.
+ * Extracts data from the Ogg container format.
  */
 public class OggExtractor implements Extractor {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
index 7840eafce6..aa77aba30e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractor.java
@@ -29,7 +29,7 @@
 import java.io.IOException;
 
 /**
- * Extracts CEA data from a RawCC file.
+ * Extracts data from the RawCC container format.
  */
 public final class RawCcExtractor implements Extractor {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
index 4d54600c6d..bc37277c57 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Extractor.java
@@ -29,7 +29,7 @@
 import java.io.IOException;
 
 /**
- * Extracts samples from (E-)AC-3 bitstreams.
+ * Extracts data from (E-)AC-3 bitstreams.
  */
 public final class Ac3Extractor implements Extractor {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
index 6a1c566faf..8383bfb8d2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/Ac3Reader.java
@@ -39,7 +39,7 @@
   private static final int STATE_READING_HEADER = 1;
   private static final int STATE_READING_SAMPLE = 2;
 
-  private static final int HEADER_SIZE = 8;
+  private static final int HEADER_SIZE = 128;
 
   private final ParsableBitArray headerScratchBits;
   private final ParsableByteArray headerScratchBytes;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
index 5ce15952a5..a0a748660e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractor.java
@@ -29,7 +29,7 @@
 import java.io.IOException;
 
 /**
- * Extracts samples from AAC bit streams with ADTS framing.
+ * Extracts data from AAC bit streams with ADTS framing.
  */
 public final class AdtsExtractor implements Extractor {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
index df1e8816f0..0fc3383015 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DtsReader.java
@@ -32,9 +32,7 @@
   private static final int STATE_READING_HEADER = 1;
   private static final int STATE_READING_SAMPLE = 2;
 
-  private static final int HEADER_SIZE = 15;
-  private static final int SYNC_VALUE = 0x7FFE8001;
-  private static final int SYNC_VALUE_SIZE = 4;
+  private static final int HEADER_SIZE = 18;
 
   private final ParsableByteArray headerScratchBytes;
   private final String language;
@@ -63,10 +61,6 @@
    */
   public DtsReader(String language) {
     headerScratchBytes = new ParsableByteArray(new byte[HEADER_SIZE]);
-    headerScratchBytes.data[0] = (byte) ((SYNC_VALUE >> 24) & 0xFF);
-    headerScratchBytes.data[1] = (byte) ((SYNC_VALUE >> 16) & 0xFF);
-    headerScratchBytes.data[2] = (byte) ((SYNC_VALUE >> 8) & 0xFF);
-    headerScratchBytes.data[3] = (byte) (SYNC_VALUE & 0xFF);
     state = STATE_FINDING_SYNC;
     this.language = language;
   }
@@ -96,7 +90,6 @@ public void consume(ParsableByteArray data) {
       switch (state) {
         case STATE_FINDING_SYNC:
           if (skipToNextSync(data)) {
-            bytesRead = SYNC_VALUE_SIZE;
             state = STATE_READING_HEADER;
           }
           break;
@@ -154,7 +147,12 @@ private boolean skipToNextSync(ParsableByteArray pesBuffer) {
     while (pesBuffer.bytesLeft() > 0) {
       syncBytes <<= 8;
       syncBytes |= pesBuffer.readUnsignedByte();
-      if (syncBytes == SYNC_VALUE) {
+      if (DtsUtil.isSyncWord(syncBytes)) {
+        headerScratchBytes.data[0] = (byte) ((syncBytes >> 24) & 0xFF);
+        headerScratchBytes.data[1] = (byte) ((syncBytes >> 16) & 0xFF);
+        headerScratchBytes.data[2] = (byte) ((syncBytes >> 8) & 0xFF);
+        headerScratchBytes.data[3] = (byte) (syncBytes & 0xFF);
+        bytesRead = 4;
         syncBytes = 0;
         return true;
       }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
index e00c63a354..0944d1810e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/DvbSubtitleReader.java
@@ -58,9 +58,16 @@ public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGen
       DvbSubtitleInfo subtitleInfo = subtitleInfos.get(i);
       idGenerator.generateNewId();
       TrackOutput output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_TEXT);
-      output.format(Format.createImageSampleFormat(idGenerator.getFormatId(),
-          MimeTypes.APPLICATION_DVBSUBS, null, Format.NO_VALUE,
-          Collections.singletonList(subtitleInfo.initializationData), subtitleInfo.language, null));
+      output.format(
+          Format.createImageSampleFormat(
+              idGenerator.getFormatId(),
+              MimeTypes.APPLICATION_DVBSUBS,
+              null,
+              Format.NO_VALUE,
+              0,
+              Collections.singletonList(subtitleInfo.initializationData),
+              subtitleInfo.language,
+              null));
       outputs[i] = output;
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
index d06c6f0cb4..313e556764 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/LatmReader.java
@@ -61,7 +61,6 @@
 
   // Container data.
   private boolean streamMuxRead;
-  private int audioMuxVersion;
   private int audioMuxVersionA;
   private int numSubframes;
   private int frameLengthType;
@@ -176,7 +175,7 @@ private void parseAudioMuxElement(ParsableBitArray data) throws ParserException
    * Parses a StreamMuxConfig as defined in ISO/IEC 14496-3:2009 Section 1.7.3.1, Table 1.42.
    */
   private void parseStreamMuxConfig(ParsableBitArray data) throws ParserException {
-    audioMuxVersion = data.readBits(1);
+    int audioMuxVersion = data.readBits(1);
     audioMuxVersionA = audioMuxVersion == 1 ? data.readBits(1) : 0;
     if (audioMuxVersionA == 0) {
       if (audioMuxVersion == 1) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
index 69c5745eaa..f3aad6ba6b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/PsExtractor.java
@@ -31,7 +31,7 @@
 import java.io.IOException;
 
 /**
- * Facilitates the extraction of data from the MPEG-2 PS container format.
+ * Extracts data from the MPEG-2 PS container format.
  */
 public final class PsExtractor implements Extractor {
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
index 213d30d47d..50931e2d90 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/TsExtractor.java
@@ -20,6 +20,7 @@
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
@@ -45,7 +46,7 @@
 import java.util.List;
 
 /**
- * Facilitates the extraction of data from the MPEG-2 TS container format.
+ * Extracts data from the MPEG-2 TS container format.
  */
 public final class TsExtractor implements Extractor {
 
@@ -122,6 +123,7 @@
   private int remainingPmts;
   private boolean tracksEnded;
   private TsPayloadReader id3Reader;
+  private int bytesSinceLastSync;
 
   public TsExtractor() {
     this(0);
@@ -163,7 +165,7 @@ public TsExtractor(@Mode int mode, TimestampAdjuster timestampAdjuster,
       timestampAdjusters = new ArrayList<>();
       timestampAdjusters.add(timestampAdjuster);
     }
-    tsPacketBuffer = new ParsableByteArray(BUFFER_SIZE);
+    tsPacketBuffer = new ParsableByteArray(new byte[BUFFER_SIZE], 0);
     trackIds = new SparseBooleanArray();
     tsPayloadReaders = new SparseArray<>();
     continuityCounters = new SparseIntArray();
@@ -206,6 +208,7 @@ public void seek(long position, long timeUs) {
     continuityCounters.clear();
     // Elementary stream readers' state should be cleared to get consistent behaviours when seeking.
     resetPayloadReaders();
+    bytesSinceLastSync = 0;
   }
 
   @Override
@@ -238,8 +241,9 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     }
 
     // Note: See ISO/IEC 13818-1, section 2.4.3.2 for details of the header format.
-    final int limit = tsPacketBuffer.limit();
+    int limit = tsPacketBuffer.limit();
     int position = tsPacketBuffer.getPosition();
+    int searchStart = position;
     while (position < limit && data[position] != TS_SYNC_BYTE) {
       position++;
     }
@@ -247,8 +251,13 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
     int endOfPacket = position + TS_PACKET_SIZE;
     if (endOfPacket > limit) {
+      bytesSinceLastSync += position - searchStart;
+      if (mode == MODE_HLS && bytesSinceLastSync > TS_PACKET_SIZE * 2) {
+        throw new ParserException("Cannot find sync byte. Most likely not a Transport Stream.");
+      }
       return RESULT_CONTINUE;
     }
+    bytesSinceLastSync = 0;
 
     int tsPacketHeader = tsPacketBuffer.readInt();
     if ((tsPacketHeader & 0x800000) != 0) { // transport_error_indicator
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
index cb46aa5519..4f2be71a69 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavExtractor.java
@@ -23,13 +23,14 @@
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
 import com.google.android.exoplayer2.extractor.PositionHolder;
-import com.google.android.exoplayer2.extractor.SeekMap;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
 
-/** {@link Extractor} to extract samples from a WAV byte stream. */
-public final class WavExtractor implements Extractor, SeekMap {
+/**
+ * Extracts data from WAV byte streams.
+ */
+public final class WavExtractor implements Extractor {
 
   /**
    * Factory for {@link WavExtractor} instances.
@@ -93,7 +94,7 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
 
     if (!wavHeader.hasDataBounds()) {
       WavHeaderReader.skipToData(input, wavHeader);
-      extractorOutput.seekMap(this);
+      extractorOutput.seekMap(wavHeader);
     }
 
     int bytesAppended = trackOutput.sampleData(input, MAX_INPUT_SIZE - pendingBytes, true);
@@ -113,20 +114,4 @@ public int read(ExtractorInput input, PositionHolder seekPosition)
     return bytesAppended == RESULT_END_OF_INPUT ? RESULT_END_OF_INPUT : RESULT_CONTINUE;
   }
 
-  // SeekMap implementation.
-
-  @Override
-  public long getDurationUs() {
-    return wavHeader.getDurationUs();
-  }
-
-  @Override
-  public boolean isSeekable() {
-    return true;
-  }
-
-  @Override
-  public long getPosition(long timeUs) {
-    return wavHeader.getPosition(timeUs);
-  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
index a57060f604..33db6c1e6c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeader.java
@@ -16,9 +16,12 @@
 package com.google.android.exoplayer2.extractor.wav;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.SeekPoint;
+import com.google.android.exoplayer2.util.Util;
 
 /** Header for a WAV file. */
-/*package*/ final class WavHeader {
+/* package */ final class WavHeader implements SeekMap {
 
   /** Number of audio chanels. */
   private final int numChannels;
@@ -49,12 +52,68 @@ public WavHeader(int numChannels, int sampleRateHz, int averageBytesPerSecond, i
     this.encoding = encoding;
   }
 
-  /** Returns the duration in microseconds of this WAV. */
+  // Setting bounds.
+
+  /**
+   * Sets the data start position and size in bytes of sample data in this WAV.
+   *
+   * @param dataStartPosition The data start position in bytes.
+   * @param dataSize The data size in bytes.
+   */
+  public void setDataBounds(long dataStartPosition, long dataSize) {
+    this.dataStartPosition = dataStartPosition;
+    this.dataSize = dataSize;
+  }
+
+  /** Returns whether the data start position and size have been set. */
+  public boolean hasDataBounds() {
+    return dataStartPosition != 0 && dataSize != 0;
+  }
+
+  // SeekMap implementation.
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
   public long getDurationUs() {
     long numFrames = dataSize / blockAlignment;
     return (numFrames * C.MICROS_PER_SECOND) / sampleRateHz;
   }
 
+  @Override
+  public SeekPoints getSeekPoints(long timeUs) {
+    long positionOffset = (timeUs * averageBytesPerSecond) / C.MICROS_PER_SECOND;
+    // Constrain to nearest preceding frame offset.
+    positionOffset = (positionOffset / blockAlignment) * blockAlignment;
+    positionOffset = Util.constrainValue(positionOffset, 0, dataSize - blockAlignment);
+    long seekPosition = dataStartPosition + positionOffset;
+    long seekTimeUs = getTimeUs(seekPosition);
+    SeekPoint seekPoint = new SeekPoint(seekTimeUs, seekPosition);
+    if (seekTimeUs >= timeUs || positionOffset == dataSize - blockAlignment) {
+      return new SeekPoints(seekPoint);
+    } else {
+      long secondSeekPosition = seekPosition + blockAlignment;
+      long secondSeekTimeUs = getTimeUs(secondSeekPosition);
+      SeekPoint secondSeekPoint = new SeekPoint(secondSeekTimeUs, secondSeekPosition);
+      return new SeekPoints(seekPoint, secondSeekPoint);
+    }
+  }
+
+  // Misc getters.
+
+  /**
+   * Returns the time in microseconds for the given position in bytes.
+   *
+   * @param position The position in bytes.
+   */
+  public long getTimeUs(long position) {
+    long positionOffset = Math.max(0, position - dataStartPosition);
+    return (positionOffset * C.MICROS_PER_SECOND) / averageBytesPerSecond;
+  }
+
   /** Returns the bytes per frame of this WAV. */
   public int getBytesPerFrame() {
     return blockAlignment;
@@ -75,33 +134,8 @@ public int getNumChannels() {
     return numChannels;
   }
 
-  /** Returns the position in bytes in this WAV for the given time in microseconds. */
-  public long getPosition(long timeUs) {
-    long unroundedPosition = (timeUs * averageBytesPerSecond) / C.MICROS_PER_SECOND;
-    // Round down to nearest frame.
-    long position = (unroundedPosition / blockAlignment) * blockAlignment;
-    return Math.min(position, dataSize - blockAlignment) + dataStartPosition;
-  }
-
-  /** Returns the time in microseconds for the given position in bytes in this WAV. */
-  public long getTimeUs(long position) {
-    return position * C.MICROS_PER_SECOND / averageBytesPerSecond;
-  }
-
-  /** Returns true if the data start position and size have been set. */
-  public boolean hasDataBounds() {
-    return dataStartPosition != 0 && dataSize != 0;
-  }
-
-  /** Sets the start position and size in bytes of sample data in this WAV. */
-  public void setDataBounds(long dataStartPosition, long dataSize) {
-    this.dataStartPosition = dataStartPosition;
-    this.dataSize = dataSize;
-  }
-
   /** Returns the PCM encoding. **/
-  @C.PcmEncoding
-  public int getEncoding() {
+  public @C.PcmEncoding int getEncoding() {
     return encoding;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
index 0e99380a1c..d0810a0629 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/extractor/wav/WavHeaderReader.java
@@ -31,6 +31,8 @@
 
   /** Integer PCM audio data. */
   private static final int TYPE_PCM = 0x0001;
+  /** Float PCM audio data. */
+  private static final int TYPE_FLOAT = 0x0003;
   /** Extended WAVE format. */
   private static final int TYPE_WAVE_FORMAT_EXTENSIBLE = 0xFFFE;
 
@@ -87,14 +89,22 @@ public static WavHeader peek(ExtractorInput input) throws IOException, Interrupt
           + blockAlignment);
     }
 
-    @C.PcmEncoding int encoding = Util.getPcmEncoding(bitsPerSample);
-    if (encoding == C.ENCODING_INVALID) {
-      Log.e(TAG, "Unsupported WAV bit depth: " + bitsPerSample);
-      return null;
+    @C.PcmEncoding int encoding;
+    switch (type) {
+      case TYPE_PCM:
+      case TYPE_WAVE_FORMAT_EXTENSIBLE:
+        encoding = Util.getPcmEncoding(bitsPerSample);
+        break;
+      case TYPE_FLOAT:
+        encoding = bitsPerSample == 32 ? C.ENCODING_PCM_FLOAT : C.ENCODING_INVALID;
+        break;
+      default:
+        Log.e(TAG, "Unsupported WAV format type: " + type);
+        return null;
     }
 
-    if (type != TYPE_PCM && type != TYPE_WAVE_FORMAT_EXTENSIBLE) {
-      Log.e(TAG, "Unsupported WAV format type: " + type);
+    if (encoding == C.ENCODING_INVALID) {
+      Log.e(TAG, "Unsupported WAV bit depth " + bitsPerSample + " for type " + type);
       return null;
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index ef7d691c5b..2e8fc602a2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -224,6 +224,7 @@ private static String buildCustomDiagnosticInfo(int errorCode) {
   private long codecHotswapDeadlineMs;
   private int inputIndex;
   private int outputIndex;
+  private ByteBuffer outputBuffer;
   private boolean shouldSkipOutputBuffer;
   private boolean codecReconfigured;
   private @ReconfigurationState int codecReconfigurationState;
@@ -322,7 +323,6 @@ protected MediaCodecInfo getDecoderInfo(MediaCodecSelector mediaCodecSelector,
   protected abstract void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format format,
       MediaCrypto crypto) throws DecoderQueryException;
 
-  @SuppressWarnings("deprecation")
   protected final void maybeInitCodec() throws ExoPlaybackException {
     if (codec != null || format == null) {
       // We have a codec already, or we don't have a format with which to instantiate one.
@@ -338,13 +338,16 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       if (mediaCrypto == null) {
         DrmSessionException drmError = drmSession.getError();
         if (drmError != null) {
-          throw ExoPlaybackException.createForRenderer(drmError, getIndex());
+          // Continue for now. We may be able to avoid failure if the session recovers, or if a new
+          // input format causes the session to be replaced before it's used.
+        } else {
+          // The drm session isn't open yet.
+          return;
         }
-        // The drm session isn't open yet.
-        return;
+      } else {
+        wrappedMediaCrypto = mediaCrypto.getWrappedMediaCrypto();
+        drmSessionRequiresSecureDecoder = mediaCrypto.requiresSecureDecoderComponent(mimeType);
       }
-      wrappedMediaCrypto = mediaCrypto.getWrappedMediaCrypto();
-      drmSessionRequiresSecureDecoder = mediaCrypto.requiresSecureDecoderComponent(mimeType);
     }
 
     if (codecInfo == null) {
@@ -399,16 +402,15 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
       long codecInitializedTimestamp = SystemClock.elapsedRealtime();
       onCodecInitialized(codecName, codecInitializedTimestamp,
           codecInitializedTimestamp - codecInitializingTimestamp);
-      inputBuffers = codec.getInputBuffers();
-      outputBuffers = codec.getOutputBuffers();
+      getCodecBuffers();
     } catch (Exception e) {
       throwDecoderInitError(new DecoderInitializationException(format, e,
           drmSessionRequiresSecureDecoder, codecName));
     }
     codecHotswapDeadlineMs = getState() == STATE_STARTED
         ? (SystemClock.elapsedRealtime() + MAX_CODEC_HOTSWAP_TIME_MS) : C.TIME_UNSET;
-    inputIndex = C.INDEX_UNSET;
-    outputIndex = C.INDEX_UNSET;
+    resetInputBuffer();
+    resetOutputBuffer();
     waitingForFirstSyncFrame = true;
     decoderCounters.decoderInitCount++;
   }
@@ -430,6 +432,21 @@ protected final MediaCodecInfo getCodecInfo() {
     return codecInfo;
   }
 
+  /**
+   * Returns the framework {@link MediaFormat} that can be used to configure a {@link MediaCodec}
+   * for decoding the given {@link Format} for playback.
+   *
+   * @param format The format of the media.
+   * @return The framework media format.
+   */
+  protected final MediaFormat getMediaFormatForPlayback(Format format) {
+    MediaFormat mediaFormat = format.getFrameworkMediaFormatV16();
+    if (Util.SDK_INT >= 23) {
+      configureMediaFormatForPlaybackV23(mediaFormat);
+    }
+    return mediaFormat;
+  }
+
   @Override
   protected void onEnabled(boolean joining) throws ExoPlaybackException {
     decoderCounters = new DecoderCounters();
@@ -469,13 +486,12 @@ protected void onDisabled() {
 
   protected void releaseCodec() {
     codecHotswapDeadlineMs = C.TIME_UNSET;
-    inputIndex = C.INDEX_UNSET;
-    outputIndex = C.INDEX_UNSET;
+    resetInputBuffer();
+    resetOutputBuffer();
     waitingForKeys = false;
     shouldSkipOutputBuffer = false;
     decodeOnlyPresentationTimestamps.clear();
-    inputBuffers = null;
-    outputBuffers = null;
+    resetCodecBuffers();
     codecInfo = null;
     codecReconfigured = false;
     codecReceivedBuffers = false;
@@ -490,7 +506,6 @@ protected void releaseCodec() {
     codecReceivedEos = false;
     codecReconfigurationState = RECONFIGURATION_STATE_NONE;
     codecReinitializationState = REINITIALIZATION_STATE_NONE;
-    buffer.data = null;
     if (codec != null) {
       decoderCounters.decoderReleaseCount++;
       try {
@@ -573,8 +588,8 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
 
   protected void flushCodec() throws ExoPlaybackException {
     codecHotswapDeadlineMs = C.TIME_UNSET;
-    inputIndex = C.INDEX_UNSET;
-    outputIndex = C.INDEX_UNSET;
+    resetInputBuffer();
+    resetOutputBuffer();
     waitingForFirstSyncFrame = true;
     waitingForKeys = false;
     shouldSkipOutputBuffer = false;
@@ -617,7 +632,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       if (inputIndex < 0) {
         return false;
       }
-      buffer.data = inputBuffers[inputIndex];
+      buffer.data = getInputBuffer(inputIndex);
       buffer.clear();
     }
 
@@ -629,7 +644,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       } else {
         codecReceivedEos = true;
         codec.queueInputBuffer(inputIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
-        inputIndex = C.INDEX_UNSET;
+        resetInputBuffer();
       }
       codecReinitializationState = REINITIALIZATION_STATE_WAIT_END_OF_STREAM;
       return false;
@@ -639,7 +654,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       codecNeedsAdaptationWorkaroundBuffer = false;
       buffer.data.put(ADAPTATION_WORKAROUND_BUFFER);
       codec.queueInputBuffer(inputIndex, 0, ADAPTATION_WORKAROUND_BUFFER.length, 0, 0);
-      inputIndex = C.INDEX_UNSET;
+      resetInputBuffer();
       codecReceivedBuffers = true;
       return true;
     }
@@ -697,7 +712,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         } else {
           codecReceivedEos = true;
           codec.queueInputBuffer(inputIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
-          inputIndex = C.INDEX_UNSET;
+          resetInputBuffer();
         }
       } catch (CryptoException e) {
         throw ExoPlaybackException.createForRenderer(e, getIndex());
@@ -742,7 +757,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
       } else {
         codec.queueInputBuffer(inputIndex, 0, buffer.data.limit(), presentationTimeUs, 0);
       }
-      inputIndex = C.INDEX_UNSET;
+      resetInputBuffer();
       codecReceivedBuffers = true;
       codecReconfigurationState = RECONFIGURATION_STATE_NONE;
       decoderCounters.inputBufferCount++;
@@ -752,6 +767,50 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
     return true;
   }
 
+  private void getCodecBuffers() {
+    if (Util.SDK_INT < 21) {
+      inputBuffers = codec.getInputBuffers();
+      outputBuffers = codec.getOutputBuffers();
+    }
+  }
+
+  private void resetCodecBuffers() {
+    if (Util.SDK_INT < 21) {
+      inputBuffers = null;
+      outputBuffers = null;
+    }
+  }
+
+  private ByteBuffer getInputBuffer(int inputIndex) {
+    if (Util.SDK_INT >= 21) {
+      return codec.getInputBuffer(inputIndex);
+    } else {
+      return inputBuffers[inputIndex];
+    }
+  }
+
+  private ByteBuffer getOutputBuffer(int outputIndex) {
+    if (Util.SDK_INT >= 21) {
+      return codec.getOutputBuffer(outputIndex);
+    } else {
+      return outputBuffers[outputIndex];
+    }
+  }
+
+  private boolean hasOutputBuffer() {
+    return outputIndex >= 0;
+  }
+
+  private void resetInputBuffer() {
+    inputIndex = C.INDEX_UNSET;
+    buffer.data = null;
+  }
+
+  private void resetOutputBuffer() {
+    outputIndex = C.INDEX_UNSET;
+    outputBuffer = null;
+  }
+
   private static MediaCodec.CryptoInfo getFrameworkCryptoInfo(DecoderInputBuffer buffer,
       int adaptiveReconfigurationBytes) {
     MediaCodec.CryptoInfo cryptoInfo = buffer.cryptoInfo.getFrameworkCryptoInfoV16();
@@ -904,9 +963,12 @@ public boolean isEnded() {
 
   @Override
   public boolean isReady() {
-    return format != null && !waitingForKeys && (isSourceReady() || outputIndex >= 0
-        || (codecHotswapDeadlineMs != C.TIME_UNSET
-        && SystemClock.elapsedRealtime() < codecHotswapDeadlineMs));
+    return format != null
+        && !waitingForKeys
+        && (isSourceReady()
+            || hasOutputBuffer()
+            || (codecHotswapDeadlineMs != C.TIME_UNSET
+                && SystemClock.elapsedRealtime() < codecHotswapDeadlineMs));
   }
 
   /**
@@ -922,14 +984,14 @@ protected long getDequeueOutputBufferTimeoutUs() {
    * @return Whether it may be possible to drain more output data.
    * @throws ExoPlaybackException If an error occurs draining the output buffer.
    */
-  @SuppressWarnings("deprecation")
   private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
       throws ExoPlaybackException {
-    if (outputIndex < 0) {
+    if (!hasOutputBuffer()) {
+      int outputIndex;
       if (codecNeedsEosOutputExceptionWorkaround && codecReceivedEos) {
         try {
-          outputIndex = codec.dequeueOutputBuffer(outputBufferInfo,
-              getDequeueOutputBufferTimeoutUs());
+          outputIndex =
+              codec.dequeueOutputBuffer(outputBufferInfo, getDequeueOutputBufferTimeoutUs());
         } catch (IllegalStateException e) {
           processEndOfStream();
           if (outputStreamEnded) {
@@ -939,26 +1001,25 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
           return false;
         }
       } else {
-        outputIndex = codec.dequeueOutputBuffer(outputBufferInfo,
-            getDequeueOutputBufferTimeoutUs());
+        outputIndex =
+            codec.dequeueOutputBuffer(outputBufferInfo, getDequeueOutputBufferTimeoutUs());
       }
+
       if (outputIndex >= 0) {
         // We've dequeued a buffer.
         if (shouldSkipAdaptationWorkaroundOutputBuffer) {
           shouldSkipAdaptationWorkaroundOutputBuffer = false;
           codec.releaseOutputBuffer(outputIndex, false);
-          outputIndex = C.INDEX_UNSET;
           return true;
-        }
-        if ((outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
+        } else if ((outputBufferInfo.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
           // The dequeued buffer indicates the end of the stream. Process it immediately.
           processEndOfStream();
-          outputIndex = C.INDEX_UNSET;
           return false;
         } else {
-          // The dequeued buffer is a media buffer. Do some initial setup. The buffer will be
-          // processed by calling processOutputBuffer (possibly multiple times) below.
-          ByteBuffer outputBuffer = outputBuffers[outputIndex];
+          this.outputIndex = outputIndex;
+          outputBuffer = getOutputBuffer(outputIndex);
+          // The dequeued buffer is a media buffer. Do some initial setup.
+          // It will be processed by calling processOutputBuffer (possibly multiple times).
           if (outputBuffer != null) {
             outputBuffer.position(outputBufferInfo.offset);
             outputBuffer.limit(outputBufferInfo.offset + outputBufferInfo.size);
@@ -972,8 +1033,9 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
         processOutputBuffersChanged();
         return true;
       } else /* MediaCodec.INFO_TRY_AGAIN_LATER (-1) or unknown negative return value */ {
-        if (codecNeedsEosPropagationWorkaround && (inputStreamEnded
-            || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM)) {
+        if (codecNeedsEosPropagationWorkaround
+            && (inputStreamEnded
+                || codecReinitializationState == REINITIALIZATION_STATE_WAIT_END_OF_STREAM)) {
           processEndOfStream();
         }
         return false;
@@ -983,9 +1045,16 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
     boolean processedOutputBuffer;
     if (codecNeedsEosOutputExceptionWorkaround && codecReceivedEos) {
       try {
-        processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs, codec,
-            outputBuffers[outputIndex], outputIndex, outputBufferInfo.flags,
-            outputBufferInfo.presentationTimeUs, shouldSkipOutputBuffer);
+        processedOutputBuffer =
+            processOutputBuffer(
+                positionUs,
+                elapsedRealtimeUs,
+                codec,
+                outputBuffer,
+                outputIndex,
+                outputBufferInfo.flags,
+                outputBufferInfo.presentationTimeUs,
+                shouldSkipOutputBuffer);
       } catch (IllegalStateException e) {
         processEndOfStream();
         if (outputStreamEnded) {
@@ -995,14 +1064,21 @@ private boolean drainOutputBuffer(long positionUs, long elapsedRealtimeUs)
         return false;
       }
     } else {
-      processedOutputBuffer = processOutputBuffer(positionUs, elapsedRealtimeUs, codec,
-          outputBuffers[outputIndex], outputIndex, outputBufferInfo.flags,
-          outputBufferInfo.presentationTimeUs, shouldSkipOutputBuffer);
+      processedOutputBuffer =
+          processOutputBuffer(
+              positionUs,
+              elapsedRealtimeUs,
+              codec,
+              outputBuffer,
+              outputIndex,
+              outputBufferInfo.flags,
+              outputBufferInfo.presentationTimeUs,
+              shouldSkipOutputBuffer);
     }
 
     if (processedOutputBuffer) {
       onProcessedOutputBuffer(outputBufferInfo.presentationTimeUs);
-      outputIndex = C.INDEX_UNSET;
+      resetOutputBuffer();
       return true;
     }
 
@@ -1030,9 +1106,10 @@ private void processOutputFormat() throws ExoPlaybackException {
   /**
    * Processes a change in the output buffers.
    */
-  @SuppressWarnings("deprecation")
   private void processOutputBuffersChanged() {
-    outputBuffers = codec.getOutputBuffers();
+    if (Util.SDK_INT < 21) {
+      outputBuffers = codec.getOutputBuffers();
+    }
   }
 
   /**
@@ -1108,6 +1185,11 @@ private boolean shouldSkipOutputBuffer(long presentationTimeUs) {
     return false;
   }
 
+  @TargetApi(23)
+  private static void configureMediaFormatForPlaybackV23(MediaFormat mediaFormat) {
+    mediaFormat.setInteger(MediaFormat.KEY_PRIORITY, 0 /* realtime priority */);
+  }
+
   /**
    * Returns whether the decoder is known to fail when flushed.
    * <p>
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index f75ce5a9e5..b80780884c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -20,6 +20,7 @@
 import android.media.MediaCodecInfo.CodecCapabilities;
 import android.media.MediaCodecInfo.CodecProfileLevel;
 import android.media.MediaCodecList;
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import android.util.Log;
 import android.util.Pair;
@@ -120,7 +121,7 @@ public static MediaCodecInfo getPassthroughDecoderInfo() {
    *     exists.
    * @throws DecoderQueryException If there was an error querying the available decoders.
    */
-  public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure)
+  public static @Nullable MediaCodecInfo getDecoderInfo(String mimeType, boolean secure)
       throws DecoderQueryException {
     List<MediaCodecInfo> decoderInfos = getDecoderInfos(mimeType, secure);
     return decoderInfos.isEmpty() ? null : decoderInfos.get(0);
@@ -140,27 +141,34 @@ public static MediaCodecInfo getDecoderInfo(String mimeType, boolean secure)
   public static synchronized List<MediaCodecInfo> getDecoderInfos(String mimeType,
       boolean secure) throws DecoderQueryException {
     CodecKey key = new CodecKey(mimeType, secure);
-    List<MediaCodecInfo> decoderInfos = decoderInfosCache.get(key);
-    if (decoderInfos != null) {
-      return decoderInfos;
+    List<MediaCodecInfo> cachedDecoderInfos = decoderInfosCache.get(key);
+    if (cachedDecoderInfos != null) {
+      return cachedDecoderInfos;
     }
     MediaCodecListCompat mediaCodecList = Util.SDK_INT >= 21
         ? new MediaCodecListCompatV21(secure) : new MediaCodecListCompatV16();
-    decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
+    ArrayList<MediaCodecInfo> decoderInfos = getDecoderInfosInternal(key, mediaCodecList, mimeType);
     if (secure && decoderInfos.isEmpty() && 21 <= Util.SDK_INT && Util.SDK_INT <= 23) {
       // Some devices don't list secure decoders on API level 21 [Internal: b/18678462]. Try the
       // legacy path. We also try this path on API levels 22 and 23 as a defensive measure.
       mediaCodecList = new MediaCodecListCompatV16();
-      decoderInfos = getDecoderInfosInternal(key, mediaCodecList);
+      decoderInfos = getDecoderInfosInternal(key, mediaCodecList, mimeType);
       if (!decoderInfos.isEmpty()) {
         Log.w(TAG, "MediaCodecList API didn't list secure decoder for: " + mimeType
             + ". Assuming: " + decoderInfos.get(0).name);
       }
     }
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(mimeType)) {
+      // E-AC3 decoders can decode JOC streams, but in 2-D rather than 3-D.
+      CodecKey eac3Key = new CodecKey(MimeTypes.AUDIO_E_AC3, key.secure);
+      ArrayList<MediaCodecInfo> eac3DecoderInfos =
+          getDecoderInfosInternal(eac3Key, mediaCodecList, mimeType);
+      decoderInfos.addAll(eac3DecoderInfos);
+    }
     applyWorkarounds(decoderInfos);
-    decoderInfos = Collections.unmodifiableList(decoderInfos);
-    decoderInfosCache.put(key, decoderInfos);
-    return decoderInfos;
+    List<MediaCodecInfo> unmodifiableDecoderInfos = Collections.unmodifiableList(decoderInfos);
+    decoderInfosCache.put(key, unmodifiableDecoderInfos);
+    return unmodifiableDecoderInfos;
   }
 
   /**
@@ -212,10 +220,21 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
 
   // Internal methods.
 
-  private static List<MediaCodecInfo> getDecoderInfosInternal(
-      CodecKey key, MediaCodecListCompat mediaCodecList) throws DecoderQueryException {
+  /**
+   * Returns {@link MediaCodecInfo}s for the given codec {@code key} in the order given by
+   * {@code mediaCodecList}.
+   *
+   * @param key The codec key.
+   * @param mediaCodecList The codec list.
+   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
+   *     key MIME type if the codec key is being considered as a fallback.
+   * @return The codec information for usable codecs matching the specified key.
+   * @throws DecoderQueryException If there was an error querying the available decoders.
+   */
+  private static ArrayList<MediaCodecInfo> getDecoderInfosInternal(CodecKey key,
+      MediaCodecListCompat mediaCodecList, String requestedMimeType) throws DecoderQueryException {
     try {
-      List<MediaCodecInfo> decoderInfos = new ArrayList<>();
+      ArrayList<MediaCodecInfo> decoderInfos = new ArrayList<>();
       String mimeType = key.mimeType;
       int numberOfCodecs = mediaCodecList.getCodecCount();
       boolean secureDecodersExplicit = mediaCodecList.secureDecodersExplicit();
@@ -223,7 +242,7 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
       for (int i = 0; i < numberOfCodecs; i++) {
         android.media.MediaCodecInfo codecInfo = mediaCodecList.getCodecInfoAt(i);
         String codecName = codecInfo.getName();
-        if (isCodecUsableDecoder(codecInfo, codecName, secureDecodersExplicit)) {
+        if (isCodecUsableDecoder(codecInfo, codecName, secureDecodersExplicit, requestedMimeType)) {
           for (String supportedType : codecInfo.getSupportedTypes()) {
             if (supportedType.equalsIgnoreCase(mimeType)) {
               try {
@@ -265,9 +284,16 @@ public static int maxH264DecodableFrameSize() throws DecoderQueryException {
 
   /**
    * Returns whether the specified codec is usable for decoding on the current device.
+   *
+   * @param info The codec information.
+   * @param name The name of the codec
+   * @param secureDecodersExplicit Whether secure decoders were explicitly listed, if present.
+   * @param requestedMimeType The originally requested MIME type, which may differ from the codec
+   *     key MIME type if the codec key is being considered as a fallback.
+   * @return Whether the specified codec is usable for decoding on the current device.
    */
   private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, String name,
-      boolean secureDecodersExplicit) {
+      boolean secureDecodersExplicit, String requestedMimeType) {
     if (info.isEncoder() || (!secureDecodersExplicit && name.endsWith(".secure"))) {
       return false;
     }
@@ -356,6 +382,12 @@ private static boolean isCodecUsableDecoder(android.media.MediaCodecInfo info, S
       return false;
     }
 
+    // MTK E-AC3 decoder doesn't support decoding JOC streams in 2-D. See [Internal: b/69400041].
+    if (MimeTypes.AUDIO_E_AC3_JOC.equals(requestedMimeType)
+        && "OMX.MTK.AUDIO.DECODER.DSPAC3".equals(name)) {
+      return false;
+    }
+
     return true;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
index fbe3184c0d..57e7f0bfd6 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessage.java
@@ -41,6 +41,13 @@
    */
   public final long durationMs;
 
+  /**
+   * The presentation time value of this event message in microseconds.
+   * <p>
+   * Except in special cases, application code should <em>not</em> use this field.
+   */
+  public final long presentationTimeUs;
+
   /**
    * The instance identifier.
    */
@@ -55,25 +62,27 @@
   private int hashCode;
 
   /**
-   *
    * @param schemeIdUri The message scheme.
    * @param value The value for the event.
    * @param durationMs The duration of the event in milliseconds.
    * @param id The instance identifier.
    * @param messageData The body of the message.
+   * @param presentationTimeUs The presentation time value of this event message in microseconds.
    */
   public EventMessage(String schemeIdUri, String value, long durationMs, long id,
-      byte[] messageData) {
+      byte[] messageData, long presentationTimeUs) {
     this.schemeIdUri = schemeIdUri;
     this.value = value;
     this.durationMs = durationMs;
     this.id = id;
     this.messageData = messageData;
+    this.presentationTimeUs = presentationTimeUs;
   }
 
   /* package */ EventMessage(Parcel in) {
     schemeIdUri = in.readString();
     value = in.readString();
+    presentationTimeUs = in.readLong();
     durationMs = in.readLong();
     id = in.readLong();
     messageData = in.createByteArray();
@@ -85,6 +94,7 @@ public int hashCode() {
       int result = 17;
       result = 31 * result + (schemeIdUri != null ? schemeIdUri.hashCode() : 0);
       result = 31 * result + (value != null ? value.hashCode() : 0);
+      result = 31 * result + (int) (presentationTimeUs ^ (presentationTimeUs >>> 32));
       result = 31 * result + (int) (durationMs ^ (durationMs >>> 32));
       result = 31 * result + (int) (id ^ (id >>> 32));
       result = 31 * result + Arrays.hashCode(messageData);
@@ -102,9 +112,9 @@ public boolean equals(Object obj) {
       return false;
     }
     EventMessage other = (EventMessage) obj;
-    return durationMs == other.durationMs && id == other.id
-        && Util.areEqual(schemeIdUri, other.schemeIdUri) && Util.areEqual(value, other.value)
-        && Arrays.equals(messageData, other.messageData);
+    return presentationTimeUs == other.presentationTimeUs && durationMs == other.durationMs
+        && id == other.id && Util.areEqual(schemeIdUri, other.schemeIdUri)
+        && Util.areEqual(value, other.value) && Arrays.equals(messageData, other.messageData);
   }
 
   // Parcelable implementation.
@@ -118,6 +128,7 @@ public int describeContents() {
   public void writeToParcel(Parcel dest, int flags) {
     dest.writeString(schemeIdUri);
     dest.writeString(value);
+    dest.writeLong(presentationTimeUs);
     dest.writeLong(durationMs);
     dest.writeLong(id);
     dest.writeByteArray(messageData);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
index fd6996aa80..7e5125e71c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoder.java
@@ -15,15 +15,17 @@
  */
 package com.google.android.exoplayer2.metadata.emsg;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.metadata.Metadata;
 import com.google.android.exoplayer2.metadata.MetadataDecoder;
 import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
 /**
- * Decodes Event Message (emsg) atoms, as defined in ISO 23009-1.
+ * Decodes Event Message (emsg) atoms, as defined in ISO/IEC 23009-1:2014, Section 5.10.3.3.
  * <p>
  * Atom data should be provided to the decoder without the full atom header (i.e. starting from the
  * first byte of the scheme_id_uri field).
@@ -39,11 +41,13 @@ public Metadata decode(MetadataInputBuffer inputBuffer) {
     String schemeIdUri = emsgData.readNullTerminatedString();
     String value = emsgData.readNullTerminatedString();
     long timescale = emsgData.readUnsignedInt();
-    emsgData.skipBytes(4); // presentation_time_delta
-    long durationMs = (emsgData.readUnsignedInt() * 1000) / timescale;
+    long presentationTimeUs = Util.scaleLargeTimestamp(emsgData.readUnsignedInt(),
+        C.MICROS_PER_SECOND, timescale);
+    long durationMs = Util.scaleLargeTimestamp(emsgData.readUnsignedInt(), 1000, timescale);
     long id = emsgData.readUnsignedInt();
     byte[] messageData = Arrays.copyOfRange(data, emsgData.getPosition(), size);
-    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData));
+    return new Metadata(new EventMessage(schemeIdUri, value, durationMs, id, messageData,
+        presentationTimeUs));
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java
new file mode 100644
index 0000000000..eca498a6df
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoder.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+/**
+ * Encodes data that can be decoded by {@link EventMessageDecoder}. This class isn't thread safe.
+ */
+public final class EventMessageEncoder {
+
+  private final ByteArrayOutputStream byteArrayOutputStream;
+  private final DataOutputStream dataOutputStream;
+
+  public EventMessageEncoder() {
+    byteArrayOutputStream = new ByteArrayOutputStream(512);
+    dataOutputStream = new DataOutputStream(byteArrayOutputStream);
+  }
+
+  /**
+   * Encodes an {@link EventMessage} to a byte array that can be decoded by
+   * {@link EventMessageDecoder}.
+   *
+   * @param eventMessage The event message to be encoded.
+   * @param timescale Timescale of the event message, in units per second.
+   * @return The serialized byte array.
+   */
+  @Nullable
+  public byte[] encode(EventMessage eventMessage, long timescale) {
+    Assertions.checkArgument(timescale >= 0);
+    byteArrayOutputStream.reset();
+    try {
+      writeNullTerminatedString(dataOutputStream, eventMessage.schemeIdUri);
+      String nonNullValue = eventMessage.value != null ? eventMessage.value : "";
+      writeNullTerminatedString(dataOutputStream, nonNullValue);
+      writeUnsignedInt(dataOutputStream, timescale);
+      long presentationTime = Util.scaleLargeTimestamp(eventMessage.presentationTimeUs,
+          timescale, C.MICROS_PER_SECOND);
+      writeUnsignedInt(dataOutputStream, presentationTime);
+      long duration = Util.scaleLargeTimestamp(eventMessage.durationMs, timescale, 1000);
+      writeUnsignedInt(dataOutputStream, duration);
+      writeUnsignedInt(dataOutputStream, eventMessage.id);
+      dataOutputStream.write(eventMessage.messageData);
+      dataOutputStream.flush();
+      return byteArrayOutputStream.toByteArray();
+    } catch (IOException e) {
+      // Should never happen.
+      throw new RuntimeException(e);
+    }
+  }
+
+  private static void writeNullTerminatedString(DataOutputStream dataOutputStream, String value)
+      throws IOException {
+    dataOutputStream.writeBytes(value);
+    dataOutputStream.writeByte(0);
+  }
+
+  private static void writeUnsignedInt(DataOutputStream outputStream, long value)
+      throws IOException {
+    outputStream.writeByte((int) (value >>> 24) & 0xFF);
+    outputStream.writeByte((int) (value >>> 16) & 0xFF);
+    outputStream.writeByte((int) (value >>> 8) & 0xFF);
+    outputStream.writeByte((int) value & 0xFF);
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
index 6b2e5c3675..7646af718d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/id3/Id3Decoder.java
@@ -405,14 +405,9 @@ private static TextInformationFrame decodeTxxxFrame(ParsableByteArray id3Data, i
     int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
-    String value;
     int valueStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    if (valueStartIndex < data.length) {
-      int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
-      value = new String(data, valueStartIndex, valueEndIndex - valueStartIndex, charset);
-    } else {
-      value = "";
-    }
+    int valueEndIndex = indexOfEos(data, valueStartIndex, encoding);
+    String value = decodeStringIfValid(data, valueStartIndex, valueEndIndex, charset);
 
     return new TextInformationFrame("TXXX", description, value);
   }
@@ -452,14 +447,9 @@ private static UrlLinkFrame decodeWxxxFrame(ParsableByteArray id3Data, int frame
     int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
-    String url;
     int urlStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    if (urlStartIndex < data.length) {
-      int urlEndIndex = indexOfZeroByte(data, urlStartIndex);
-      url = new String(data, urlStartIndex, urlEndIndex - urlStartIndex, "ISO-8859-1");
-    } else {
-      url = "";
-    }
+    int urlEndIndex = indexOfZeroByte(data, urlStartIndex);
+    String url = decodeStringIfValid(data, urlStartIndex, urlEndIndex, "ISO-8859-1");
 
     return new UrlLinkFrame("WXXX", description, url);
   }
@@ -502,13 +492,12 @@ private static GeobFrame decodeGeobFrame(ParsableByteArray id3Data, int frameSiz
 
     int filenameStartIndex = mimeTypeEndIndex + 1;
     int filenameEndIndex = indexOfEos(data, filenameStartIndex, encoding);
-    String filename = new String(data, filenameStartIndex, filenameEndIndex - filenameStartIndex,
-        charset);
+    String filename = decodeStringIfValid(data, filenameStartIndex, filenameEndIndex, charset);
 
     int descriptionStartIndex = filenameEndIndex + delimiterLength(encoding);
     int descriptionEndIndex = indexOfEos(data, descriptionStartIndex, encoding);
-    String description = new String(data, descriptionStartIndex,
-        descriptionEndIndex - descriptionStartIndex, charset);
+    String description =
+        decodeStringIfValid(data, descriptionStartIndex, descriptionEndIndex, charset);
 
     int objectDataStartIndex = descriptionEndIndex + delimiterLength(encoding);
     byte[] objectData = copyOfRangeIfValid(data, objectDataStartIndex, data.length);
@@ -573,14 +562,9 @@ private static CommentFrame decodeCommentFrame(ParsableByteArray id3Data, int fr
     int descriptionEndIndex = indexOfEos(data, 0, encoding);
     String description = new String(data, 0, descriptionEndIndex, charset);
 
-    String text;
     int textStartIndex = descriptionEndIndex + delimiterLength(encoding);
-    if (textStartIndex < data.length) {
-      int textEndIndex = indexOfEos(data, textStartIndex, encoding);
-      text = new String(data, textStartIndex, textEndIndex - textStartIndex, charset);
-    } else {
-      text = "";
-    }
+    int textEndIndex = indexOfEos(data, textStartIndex, encoding);
+    String text = decodeStringIfValid(data, textStartIndex, textEndIndex, charset);
 
     return new CommentFrame(language, description, text);
   }
@@ -760,6 +744,25 @@ private static int delimiterLength(int encodingByte) {
     return Arrays.copyOfRange(data, from, to);
   }
 
+  /**
+   * Returns a string obtained by decoding the specified range of {@code data} using the specified
+   * {@code charsetName}. An empty string is returned if the range is invalid.
+   *
+   * @param data The array from which to decode the string.
+   * @param from The start of the range.
+   * @param to The end of the range (exclusive).
+   * @param charsetName The name of the Charset to use.
+   * @return The decoded string, or an empty string if the range is invalid.
+   * @throws UnsupportedEncodingException If the Charset is not supported.
+   */
+  private static String decodeStringIfValid(byte[] data, int from, int to, String charsetName)
+      throws UnsupportedEncodingException {
+    if (to <= from || to > data.length) {
+      return "";
+    }
+    return new String(data, from, to - from, charsetName);
+  }
+
   private static final class Id3Header {
 
     private final int majorVersion;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
index 3cb5db30ec..6abb950254 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
@@ -104,10 +104,17 @@ public final M getManifest() throws IOException {
    * previous selection is cleared. If keys are null or empty, all representations are downloaded.
    */
   public final void selectRepresentations(K[] keys) {
-    this.keys = keys != null ? keys.clone() : null;
+    this.keys = (keys != null && keys.length > 0) ? keys.clone() : null;
     resetCounters();
   }
 
+  /**
+   * Returns keys for all representations.
+   *
+   * @see #selectRepresentations(Object[])
+   */
+  public abstract K[] getAllRepresentationKeys() throws IOException;
+
   /**
    * Initializes the total segments, downloaded segments and downloaded bytes counters for the
    * selected representations.
@@ -221,7 +228,7 @@ public final void remove() throws InterruptedException {
     if (manifest != null) {
       List<Segment> segments = null;
       try {
-        segments = getAllSegments(offlineDataSource, manifest, true);
+        segments = getSegments(offlineDataSource, manifest, getAllRepresentationKeys(), true);
       } catch (IOException e) {
         // Ignore exceptions. We do our best with what's available offline.
       }
@@ -262,14 +269,6 @@ public final void remove() throws InterruptedException {
   protected abstract List<Segment> getSegments(DataSource dataSource, M manifest, K[] keys,
       boolean allowIncompleteIndex) throws InterruptedException, IOException;
 
-  /**
-   * Returns a list of all segments.
-   *
-   * @see #getSegments(DataSource, M, Object[], boolean)
-   */
-  protected abstract List<Segment> getAllSegments(DataSource dataSource, M manifest,
-      boolean allowPartialIndex) throws InterruptedException, IOException;
-
   private void resetCounters() {
     totalSegments = C.LENGTH_UNSET;
     downloadedSegments = C.LENGTH_UNSET;
@@ -295,9 +294,10 @@ private void notifyListener(ProgressListener listener) {
   private synchronized List<Segment> initStatus(boolean offline)
       throws IOException, InterruptedException {
     DataSource dataSource = getDataSource(offline);
-    List<Segment> segments = keys != null && keys.length > 0
-        ? getSegments(dataSource, manifest, keys, offline)
-        : getAllSegments(dataSource, manifest, offline);
+    if (keys == null) {
+      keys = getAllRepresentationKeys();
+    }
+    List<Segment> segments = getSegments(dataSource, manifest, keys, offline);
     CachingCounters cachingCounters = new CachingCounters();
     totalSegments = segments.size();
     downloadedSegments = 0;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
index 35234753b0..696a6f6fad 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/AbstractConcatenatedTimeline.java
@@ -27,14 +27,18 @@
 
   private final int childCount;
   private final ShuffleOrder shuffleOrder;
+  private final boolean isAtomic;
 
   /**
    * Sets up a concatenated timeline with a shuffle order of child timelines.
    *
+   * @param isAtomic Whether the child timelines shall be treated as atomic, i.e., treated as a
+   *     single item for repeating and shuffling.
    * @param shuffleOrder A shuffle order of child timelines. The number of child timelines must
    *     match the number of elements in the shuffle order.
    */
-  public AbstractConcatenatedTimeline(ShuffleOrder shuffleOrder) {
+  public AbstractConcatenatedTimeline(boolean isAtomic, ShuffleOrder shuffleOrder) {
+    this.isAtomic = isAtomic;
     this.shuffleOrder = shuffleOrder;
     this.childCount = shuffleOrder.getLength();
   }
@@ -42,6 +46,11 @@ public AbstractConcatenatedTimeline(ShuffleOrder shuffleOrder) {
   @Override
   public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
       boolean shuffleModeEnabled) {
+    if (isAtomic) {
+      // Adapt repeat and shuffle mode to atomic concatenation.
+      repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;
+      shuffleModeEnabled = false;
+    }
     // Find next window within current child.
     int childIndex = getChildIndexByWindowIndex(windowIndex);
     int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
@@ -71,6 +80,11 @@ public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode
   @Override
   public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
       boolean shuffleModeEnabled) {
+    if (isAtomic) {
+      // Adapt repeat and shuffle mode to atomic concatenation.
+      repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;
+      shuffleModeEnabled = false;
+    }
     // Find previous window within current child.
     int childIndex = getChildIndexByWindowIndex(windowIndex);
     int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);
@@ -103,6 +117,9 @@ public int getLastWindowIndex(boolean shuffleModeEnabled) {
     if (childCount == 0) {
       return C.INDEX_UNSET;
     }
+    if (isAtomic) {
+      shuffleModeEnabled = false;
+    }
     // Find last non-empty child.
     int lastChildIndex = shuffleModeEnabled ? shuffleOrder.getLastIndex() : childCount - 1;
     while (getTimelineByChildIndex(lastChildIndex).isEmpty()) {
@@ -121,6 +138,9 @@ public int getFirstWindowIndex(boolean shuffleModeEnabled) {
     if (childCount == 0) {
       return C.INDEX_UNSET;
     }
+    if (isAtomic) {
+      shuffleModeEnabled = false;
+    }
     // Find first non-empty child.
     int firstChildIndex = shuffleModeEnabled ? shuffleOrder.getFirstIndex() : 0;
     while (getTimelineByChildIndex(firstChildIndex).isEmpty()) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java
index be07cbb5dc..ccc3beac55 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/AdaptiveMediaSourceEventListener.java
@@ -15,309 +15,10 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.os.Handler;
-import android.os.SystemClock;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.upstream.DataSpec;
-import com.google.android.exoplayer2.util.Assertions;
-import java.io.IOException;
-
 /**
- * Interface for callbacks to be notified of adaptive {@link MediaSource} events.
+ * Interface for callbacks to be notified of {@link MediaSource} events.
+ *
+ * @deprecated Use {@link MediaSourceEventListener}.
  */
-public interface AdaptiveMediaSourceEventListener {
-
-  /**
-   * Called when a load begins.
-   *
-   * @param dataSpec Defines the data being loaded.
-   * @param dataType One of the {@link C} {@code DATA_TYPE_*} constants defining the type of data
-   *     being loaded.
-   * @param trackType One of the {@link C} {@code TRACK_TYPE_*} constants if the data corresponds
-   *     to media of a specific type. {@link C#TRACK_TYPE_UNKNOWN} otherwise.
-   * @param trackFormat The format of the track to which the data belongs. Null if the data does
-   *     not belong to a track.
-   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
-   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
-   * @param trackSelectionData Optional data associated with the selection of the track to which the
-   *     data belongs. Null if the data does not belong to a track.
-   * @param mediaStartTimeMs The start time of the media being loaded, or {@link C#TIME_UNSET} if
-   *     the load is not for media data.
-   * @param mediaEndTimeMs The end time of the media being loaded, or {@link C#TIME_UNSET} if the
-   *     load is not for media data.
-   * @param elapsedRealtimeMs The value of {@link SystemClock#elapsedRealtime} when the load began.
-   */
-  void onLoadStarted(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
-      long mediaEndTimeMs, long elapsedRealtimeMs);
-
-  /**
-   * Called when a load ends.
-   *
-   * @param dataSpec Defines the data being loaded.
-   * @param dataType One of the {@link C} {@code DATA_TYPE_*} constants defining the type of data
-   *     being loaded.
-   * @param trackType One of the {@link C} {@code TRACK_TYPE_*} constants if the data corresponds
-   *     to media of a specific type. {@link C#TRACK_TYPE_UNKNOWN} otherwise.
-   * @param trackFormat The format of the track to which the data belongs. Null if the data does
-   *     not belong to a track.
-   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
-   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
-   * @param trackSelectionData Optional data associated with the selection of the track to which the
-   *     data belongs. Null if the data does not belong to a track.
-   * @param mediaStartTimeMs The start time of the media being loaded, or {@link C#TIME_UNSET} if
-   *     the load is not for media data.
-   * @param mediaEndTimeMs The end time of the media being loaded, or {@link C#TIME_UNSET} if the
-   *     load is not for media data.
-   * @param elapsedRealtimeMs The value of {@link SystemClock#elapsedRealtime} when the load ended.
-   * @param loadDurationMs The duration of the load.
-   * @param bytesLoaded The number of bytes that were loaded.
-   */
-  void onLoadCompleted(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
-      long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded);
-
-  /**
-   * Called when a load is canceled.
-   *
-   * @param dataSpec Defines the data being loaded.
-   * @param dataType One of the {@link C} {@code DATA_TYPE_*} constants defining the type of data
-   *     being loaded.
-   * @param trackType One of the {@link C} {@code TRACK_TYPE_*} constants if the data corresponds
-   *     to media of a specific type. {@link C#TRACK_TYPE_UNKNOWN} otherwise.
-   * @param trackFormat The format of the track to which the data belongs. Null if the data does
-   *     not belong to a track.
-   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
-   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
-   * @param trackSelectionData Optional data associated with the selection of the track to which the
-   *     data belongs. Null if the data does not belong to a track.
-   * @param mediaStartTimeMs The start time of the media being loaded, or {@link C#TIME_UNSET} if
-   *     the load is not for media data.
-   * @param mediaEndTimeMs The end time of the media being loaded, or {@link C#TIME_UNSET} if the
-   *     load is not for media data.
-   * @param elapsedRealtimeMs The value of {@link SystemClock#elapsedRealtime} when the load was
-   *     canceled.
-   * @param loadDurationMs The duration of the load up to the point at which it was canceled.
-   * @param bytesLoaded The number of bytes that were loaded prior to cancelation.
-   */
-  void onLoadCanceled(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
-      long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded);
-
-  /**
-   * Called when a load error occurs.
-   * <p>
-   * The error may or may not have resulted in the load being canceled, as indicated by the
-   * {@code wasCanceled} parameter. If the load was canceled, {@link #onLoadCanceled} will
-   * <em>not</em> be called in addition to this method.
-   * <p>
-   * This method being called does not indicate that playback has failed, or that it will fail. The
-   * player may be able to recover from the error and continue. Hence applications should
-   * <em>not</em> implement this method to display a user visible error or initiate an application
-   * level retry ({@link Player.EventListener#onPlayerError} is the appropriate place to implement
-   * such behavior). This method is called to provide the application with an opportunity to log the
-   * error if it wishes to do so.
-   *
-   * @param dataSpec Defines the data being loaded.
-   * @param dataType One of the {@link C} {@code DATA_TYPE_*} constants defining the type of data
-   *     being loaded.
-   * @param trackType One of the {@link C} {@code TRACK_TYPE_*} constants if the data corresponds
-   *     to media of a specific type. {@link C#TRACK_TYPE_UNKNOWN} otherwise.
-   * @param trackFormat The format of the track to which the data belongs. Null if the data does
-   *     not belong to a track.
-   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
-   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
-   * @param trackSelectionData Optional data associated with the selection of the track to which the
-   *     data belongs. Null if the data does not belong to a track.
-   * @param mediaStartTimeMs The start time of the media being loaded, or {@link C#TIME_UNSET} if
-   *     the load is not for media data.
-   * @param mediaEndTimeMs The end time of the media being loaded, or {@link C#TIME_UNSET} if the
-   *     load is not for media data.
-   * @param elapsedRealtimeMs The value of {@link SystemClock#elapsedRealtime} when the error
-   *     occurred.
-   * @param loadDurationMs The duration of the load up to the point at which the error occurred.
-   * @param bytesLoaded The number of bytes that were loaded prior to the error.
-   * @param error The load error.
-   * @param wasCanceled Whether the load was canceled as a result of the error.
-   */
-  void onLoadError(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
-      long mediaEndTimeMs, long elapsedRealtimeMs, long loadDurationMs, long bytesLoaded,
-      IOException error, boolean wasCanceled);
-
-  /**
-   * Called when data is removed from the back of a media buffer, typically so that it can be
-   * re-buffered in a different format.
-   *
-   * @param trackType The type of the media. One of the {@link C} {@code TRACK_TYPE_*} constants.
-   * @param mediaStartTimeMs The start time of the media being discarded.
-   * @param mediaEndTimeMs The end time of the media being discarded.
-   */
-  void onUpstreamDiscarded(int trackType, long mediaStartTimeMs, long mediaEndTimeMs);
-
-  /**
-   * Called when a downstream format change occurs (i.e. when the format of the media being read
-   * from one or more {@link SampleStream}s provided by the source changes).
-   *
-   * @param trackType The type of the media. One of the {@link C} {@code TRACK_TYPE_*} constants.
-   * @param trackFormat The format of the track to which the data belongs. Null if the data does
-   *     not belong to a track.
-   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
-   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
-   * @param trackSelectionData Optional data associated with the selection of the track to which the
-   *     data belongs. Null if the data does not belong to a track.
-   * @param mediaTimeMs The media time at which the change occurred.
-   */
-  void onDownstreamFormatChanged(int trackType, Format trackFormat, int trackSelectionReason,
-      Object trackSelectionData, long mediaTimeMs);
-
-  /**
-   * Dispatches events to a {@link AdaptiveMediaSourceEventListener}.
-   */
-  final class EventDispatcher {
-
-    private final Handler handler;
-    private final AdaptiveMediaSourceEventListener listener;
-    private final long mediaTimeOffsetMs;
-
-    public EventDispatcher(Handler handler, AdaptiveMediaSourceEventListener listener) {
-      this(handler, listener, 0);
-    }
-
-    public EventDispatcher(Handler handler, AdaptiveMediaSourceEventListener listener,
-        long mediaTimeOffsetMs) {
-      this.handler = listener != null ? Assertions.checkNotNull(handler) : null;
-      this.listener = listener;
-      this.mediaTimeOffsetMs = mediaTimeOffsetMs;
-    }
-
-    public EventDispatcher copyWithMediaTimeOffsetMs(long mediaTimeOffsetMs) {
-      return new EventDispatcher(handler, listener, mediaTimeOffsetMs);
-    }
-
-    public void loadStarted(DataSpec dataSpec, int dataType, long elapsedRealtimeMs) {
-      loadStarted(dataSpec, dataType, C.TRACK_TYPE_UNKNOWN, null, C.SELECTION_REASON_UNKNOWN,
-          null, C.TIME_UNSET, C.TIME_UNSET, elapsedRealtimeMs);
-    }
-
-    public void loadStarted(final DataSpec dataSpec, final int dataType, final int trackType,
-        final Format trackFormat, final int trackSelectionReason, final Object trackSelectionData,
-        final long mediaStartTimeUs, final long mediaEndTimeUs, final long elapsedRealtimeMs) {
-      if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onLoadStarted(dataSpec, dataType, trackType, trackFormat, trackSelectionReason,
-                trackSelectionData, adjustMediaTime(mediaStartTimeUs),
-                adjustMediaTime(mediaEndTimeUs), elapsedRealtimeMs);
-          }
-        });
-      }
-    }
-
-    public void loadCompleted(DataSpec dataSpec, int dataType, long elapsedRealtimeMs,
-        long loadDurationMs, long bytesLoaded) {
-      loadCompleted(dataSpec, dataType, C.TRACK_TYPE_UNKNOWN, null, C.SELECTION_REASON_UNKNOWN,
-          null, C.TIME_UNSET, C.TIME_UNSET, elapsedRealtimeMs, loadDurationMs, bytesLoaded);
-    }
-
-    public void loadCompleted(final DataSpec dataSpec, final int dataType, final int trackType,
-        final Format trackFormat, final int trackSelectionReason, final Object trackSelectionData,
-        final long mediaStartTimeUs, final long mediaEndTimeUs, final long elapsedRealtimeMs,
-        final long loadDurationMs, final long bytesLoaded) {
-      if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onLoadCompleted(dataSpec, dataType, trackType, trackFormat,
-                trackSelectionReason, trackSelectionData, adjustMediaTime(mediaStartTimeUs),
-                adjustMediaTime(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs, bytesLoaded);
-          }
-        });
-      }
-    }
-
-    public void loadCanceled(DataSpec dataSpec, int dataType, long elapsedRealtimeMs,
-        long loadDurationMs, long bytesLoaded) {
-      loadCanceled(dataSpec, dataType, C.TRACK_TYPE_UNKNOWN, null, C.SELECTION_REASON_UNKNOWN,
-          null, C.TIME_UNSET, C.TIME_UNSET, elapsedRealtimeMs, loadDurationMs, bytesLoaded);
-    }
-
-    public void loadCanceled(final DataSpec dataSpec, final int dataType, final int trackType,
-        final Format trackFormat, final int trackSelectionReason, final Object trackSelectionData,
-        final long mediaStartTimeUs, final long mediaEndTimeUs, final long elapsedRealtimeMs,
-        final long loadDurationMs, final long bytesLoaded) {
-      if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onLoadCanceled(dataSpec, dataType, trackType, trackFormat,
-                trackSelectionReason, trackSelectionData, adjustMediaTime(mediaStartTimeUs),
-                adjustMediaTime(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs, bytesLoaded);
-          }
-        });
-      }
-    }
-
-    public void loadError(DataSpec dataSpec, int dataType, long elapsedRealtimeMs,
-        long loadDurationMs, long bytesLoaded, IOException error, boolean wasCanceled) {
-      loadError(dataSpec, dataType, C.TRACK_TYPE_UNKNOWN, null, C.SELECTION_REASON_UNKNOWN,
-          null, C.TIME_UNSET, C.TIME_UNSET, elapsedRealtimeMs, loadDurationMs, bytesLoaded,
-          error, wasCanceled);
-    }
-
-    public void loadError(final DataSpec dataSpec, final int dataType, final int trackType,
-        final Format trackFormat, final int trackSelectionReason, final Object trackSelectionData,
-        final long mediaStartTimeUs, final long mediaEndTimeUs, final long elapsedRealtimeMs,
-        final long loadDurationMs, final long bytesLoaded, final IOException error,
-        final boolean wasCanceled) {
-      if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onLoadError(dataSpec, dataType, trackType, trackFormat, trackSelectionReason,
-                trackSelectionData, adjustMediaTime(mediaStartTimeUs),
-                adjustMediaTime(mediaEndTimeUs), elapsedRealtimeMs, loadDurationMs, bytesLoaded,
-                error, wasCanceled);
-          }
-        });
-      }
-    }
-
-    public void upstreamDiscarded(final int trackType, final long mediaStartTimeUs,
-        final long mediaEndTimeUs) {
-      if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onUpstreamDiscarded(trackType, adjustMediaTime(mediaStartTimeUs),
-                adjustMediaTime(mediaEndTimeUs));
-          }
-        });
-      }
-    }
-
-    public void downstreamFormatChanged(final int trackType, final Format trackFormat,
-        final int trackSelectionReason, final Object trackSelectionData,
-        final long mediaTimeUs) {
-      if (listener != null) {
-        handler.post(new Runnable()  {
-          @Override
-          public void run() {
-            listener.onDownstreamFormatChanged(trackType, trackFormat, trackSelectionReason,
-                trackSelectionData, adjustMediaTime(mediaTimeUs));
-          }
-        });
-      }
-    }
-
-    private long adjustMediaTime(long mediaTimeUs) {
-      long mediaTimeMs = C.usToMs(mediaTimeUs);
-      return mediaTimeMs == C.TIME_UNSET ? C.TIME_UNSET : mediaTimeOffsetMs + mediaTimeMs;
-    }
-
-  }
-
-}
+@Deprecated
+public interface AdaptiveMediaSourceEventListener extends MediaSourceEventListener {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
index 89af07a3f0..f14c0faad4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java
@@ -18,6 +18,7 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.util.Assertions;
@@ -36,10 +37,10 @@
   public final MediaPeriod mediaPeriod;
 
   private MediaPeriod.Callback callback;
-  private long startUs;
-  private long endUs;
   private ClippingSampleStream[] sampleStreams;
-  private boolean pendingInitialDiscontinuity;
+  private long pendingInitialDiscontinuityPositionUs;
+  /* package */ long startUs;
+  /* package */ long endUs;
 
   /**
    * Creates a new clipping media period that provides a clipped view of the specified
@@ -57,10 +58,10 @@
    */
   public ClippingMediaPeriod(MediaPeriod mediaPeriod, boolean enableInitialDiscontinuity) {
     this.mediaPeriod = mediaPeriod;
+    sampleStreams = new ClippingSampleStream[0];
+    pendingInitialDiscontinuityPositionUs = enableInitialDiscontinuity ? 0 : C.TIME_UNSET;
     startUs = C.TIME_UNSET;
     endUs = C.TIME_UNSET;
-    sampleStreams = new ClippingSampleStream[0];
-    pendingInitialDiscontinuity = enableInitialDiscontinuity;
   }
 
   /**
@@ -95,48 +96,47 @@ public TrackGroupArray getTrackGroups() {
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
     sampleStreams = new ClippingSampleStream[streams.length];
-    SampleStream[] internalStreams = new SampleStream[streams.length];
+    SampleStream[] childStreams = new SampleStream[streams.length];
     for (int i = 0; i < streams.length; i++) {
       sampleStreams[i] = (ClippingSampleStream) streams[i];
-      internalStreams[i] = sampleStreams[i] != null ? sampleStreams[i].stream : null;
+      childStreams[i] = sampleStreams[i] != null ? sampleStreams[i].childStream : null;
     }
     long enablePositionUs = mediaPeriod.selectTracks(selections, mayRetainStreamFlags,
-        internalStreams, streamResetFlags, positionUs + startUs);
-    if (pendingInitialDiscontinuity) {
-      pendingInitialDiscontinuity = startUs != 0 && shouldKeepInitialDiscontinuity(selections);
-    }
-    Assertions.checkState(enablePositionUs == positionUs + startUs
-        || (enablePositionUs >= startUs
-        && (endUs == C.TIME_END_OF_SOURCE || enablePositionUs <= endUs)));
+        childStreams, streamResetFlags, positionUs + startUs) - startUs;
+    pendingInitialDiscontinuityPositionUs = isPendingInitialDiscontinuity() && positionUs == 0
+        && shouldKeepInitialDiscontinuity(startUs, selections) ? enablePositionUs : C.TIME_UNSET;
+    Assertions.checkState(enablePositionUs == positionUs
+        || (enablePositionUs >= 0
+        && (endUs == C.TIME_END_OF_SOURCE || startUs + enablePositionUs <= endUs)));
     for (int i = 0; i < streams.length; i++) {
-      if (internalStreams[i] == null) {
+      if (childStreams[i] == null) {
         sampleStreams[i] = null;
-      } else if (streams[i] == null || sampleStreams[i].stream != internalStreams[i]) {
-        sampleStreams[i] = new ClippingSampleStream(this, internalStreams[i], startUs, endUs,
-            pendingInitialDiscontinuity);
+      } else if (streams[i] == null || sampleStreams[i].childStream != childStreams[i]) {
+        sampleStreams[i] = new ClippingSampleStream(childStreams[i]);
       }
       streams[i] = sampleStreams[i];
     }
-    return enablePositionUs - startUs;
+    return enablePositionUs;
+  }
+
+  @Override
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
+    mediaPeriod.discardBuffer(positionUs + startUs, toKeyframe);
   }
 
   @Override
-  public void discardBuffer(long positionUs) {
-    mediaPeriod.discardBuffer(positionUs + startUs);
+  public void reevaluateBuffer(long positionUs) {
+    mediaPeriod.reevaluateBuffer(positionUs + startUs);
   }
 
   @Override
   public long readDiscontinuity() {
-    if (pendingInitialDiscontinuity) {
-      for (ClippingSampleStream sampleStream : sampleStreams) {
-        if (sampleStream != null) {
-          sampleStream.clearPendingDiscontinuity();
-        }
-      }
-      pendingInitialDiscontinuity = false;
-      // Always read an initial discontinuity, using mediaPeriod's discontinuity if set.
-      long discontinuityUs = readDiscontinuity();
-      return discontinuityUs != C.TIME_UNSET ? discontinuityUs : 0;
+    if (isPendingInitialDiscontinuity()) {
+      long initialDiscontinuityUs = pendingInitialDiscontinuityPositionUs;
+      pendingInitialDiscontinuityPositionUs = C.TIME_UNSET;
+      // Always read an initial discontinuity from the child, and use it if set.
+      long childDiscontinuityUs = readDiscontinuity();
+      return childDiscontinuityUs != C.TIME_UNSET ? childDiscontinuityUs : initialDiscontinuityUs;
     }
     long discontinuityUs = mediaPeriod.readDiscontinuity();
     if (discontinuityUs == C.TIME_UNSET) {
@@ -159,17 +159,31 @@ public long getBufferedPositionUs() {
 
   @Override
   public long seekToUs(long positionUs) {
+    pendingInitialDiscontinuityPositionUs = C.TIME_UNSET;
     for (ClippingSampleStream sampleStream : sampleStreams) {
       if (sampleStream != null) {
         sampleStream.clearSentEos();
       }
     }
-    long seekUs = mediaPeriod.seekToUs(positionUs + startUs);
-    Assertions.checkState(seekUs == positionUs + startUs
-        || (seekUs >= startUs && (endUs == C.TIME_END_OF_SOURCE || seekUs <= endUs)));
+    long offsetPositionUs = positionUs + startUs;
+    long seekUs = mediaPeriod.seekToUs(offsetPositionUs);
+    Assertions.checkState(
+        seekUs == offsetPositionUs
+            || (seekUs >= startUs && (endUs == C.TIME_END_OF_SOURCE || seekUs <= endUs)));
     return seekUs - startUs;
   }
 
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    if (positionUs == startUs) {
+      // Never adjust seeks to the start of the clipped view.
+      return 0;
+    }
+    long offsetPositionUs = positionUs + startUs;
+    SeekParameters clippedSeekParameters = clipSeekParameters(offsetPositionUs, seekParameters);
+    return mediaPeriod.getAdjustedSeekPositionUs(offsetPositionUs, clippedSeekParameters) - startUs;
+  }
+
   @Override
   public long getNextLoadPositionUs() {
     long nextLoadPositionUs = mediaPeriod.getNextLoadPositionUs();
@@ -198,7 +212,25 @@ public void onContinueLoadingRequested(MediaPeriod source) {
     callback.onContinueLoadingRequested(this);
   }
 
-  private static boolean shouldKeepInitialDiscontinuity(TrackSelection[] selections) {
+  /* package */ boolean isPendingInitialDiscontinuity() {
+    return pendingInitialDiscontinuityPositionUs != C.TIME_UNSET;
+  }
+
+  private SeekParameters clipSeekParameters(long offsetPositionUs, SeekParameters seekParameters) {
+    long toleranceBeforeMs = Math.min(offsetPositionUs - startUs, seekParameters.toleranceBeforeUs);
+    long toleranceAfterMs =
+        endUs == C.TIME_END_OF_SOURCE
+            ? seekParameters.toleranceAfterUs
+            : Math.min(endUs - offsetPositionUs, seekParameters.toleranceAfterUs);
+    if (toleranceBeforeMs == seekParameters.toleranceBeforeUs
+        && toleranceAfterMs == seekParameters.toleranceAfterUs) {
+      return seekParameters;
+    } else {
+      return new SeekParameters(toleranceBeforeMs, toleranceAfterMs);
+    }
+  }
+
+  private static boolean shouldKeepInitialDiscontinuity(long startUs, TrackSelection[] selections) {
     // If the clipping start position is non-zero, the clipping sample streams will adjust
     // timestamps on buffers they read from the unclipped sample streams. These adjusted buffer
     // timestamps can be negative, because sample streams provide buffers starting at a key-frame,
@@ -208,11 +240,13 @@ private static boolean shouldKeepInitialDiscontinuity(TrackSelection[] selection
     // discontinuity which resets the renderers before they read the clipping sample stream.
     // However, for audio-only track selections we assume to have random access seek behaviour and
     // do not need an initial discontinuity to reset the renderer.
-    for (TrackSelection trackSelection : selections) {
-      if (trackSelection != null) {
-        Format selectedFormat = trackSelection.getSelectedFormat();
-        if (!MimeTypes.isAudio(selectedFormat.sampleMimeType)) {
-          return true;
+    if (startUs != 0) {
+      for (TrackSelection trackSelection : selections) {
+        if (trackSelection != null) {
+          Format selectedFormat = trackSelection.getSelectedFormat();
+          if (!MimeTypes.isAudio(selectedFormat.sampleMimeType)) {
+            return true;
+          }
         }
       }
     }
@@ -222,27 +256,14 @@ private static boolean shouldKeepInitialDiscontinuity(TrackSelection[] selection
   /**
    * Wraps a {@link SampleStream} and clips its samples.
    */
-  private static final class ClippingSampleStream implements SampleStream {
+  private final class ClippingSampleStream implements SampleStream {
 
-    private final MediaPeriod mediaPeriod;
-    private final SampleStream stream;
-    private final long startUs;
-    private final long endUs;
+    public final SampleStream childStream;
 
-    private boolean pendingDiscontinuity;
     private boolean sentEos;
 
-    public ClippingSampleStream(MediaPeriod mediaPeriod, SampleStream stream, long startUs,
-        long endUs, boolean pendingDiscontinuity) {
-      this.mediaPeriod = mediaPeriod;
-      this.stream = stream;
-      this.startUs = startUs;
-      this.endUs = endUs;
-      this.pendingDiscontinuity = pendingDiscontinuity;
-    }
-
-    public void clearPendingDiscontinuity() {
-      pendingDiscontinuity = false;
+    public ClippingSampleStream(SampleStream childStream) {
+      this.childStream = childStream;
     }
 
     public void clearSentEos() {
@@ -251,36 +272,39 @@ public void clearSentEos() {
 
     @Override
     public boolean isReady() {
-      return stream.isReady();
+      return !isPendingInitialDiscontinuity() && childStream.isReady();
     }
 
     @Override
     public void maybeThrowError() throws IOException {
-      stream.maybeThrowError();
+      childStream.maybeThrowError();
     }
 
     @Override
     public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
         boolean requireFormat) {
-      if (pendingDiscontinuity) {
+      if (isPendingInitialDiscontinuity()) {
         return C.RESULT_NOTHING_READ;
       }
       if (sentEos) {
         buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
         return C.RESULT_BUFFER_READ;
       }
-      int result = stream.readData(formatHolder, buffer, requireFormat);
+      int result = childStream.readData(formatHolder, buffer, requireFormat);
       if (result == C.RESULT_FORMAT_READ) {
-        // Clear gapless playback metadata if the start/end points don't match the media.
         Format format = formatHolder.format;
-        int encoderDelay = startUs != 0 ? 0 : format.encoderDelay;
-        int encoderPadding = endUs != C.TIME_END_OF_SOURCE ? 0 : format.encoderPadding;
-        formatHolder.format = format.copyWithGaplessInfo(encoderDelay, encoderPadding);
+        if (format.encoderDelay != Format.NO_VALUE || format.encoderPadding != Format.NO_VALUE) {
+          // Clear gapless playback metadata if the start/end points don't match the media.
+          int encoderDelay = startUs != 0 ? 0 : format.encoderDelay;
+          int encoderPadding = endUs != C.TIME_END_OF_SOURCE ? 0 : format.encoderPadding;
+          formatHolder.format = format.copyWithGaplessInfo(encoderDelay, encoderPadding);
+        }
         return C.RESULT_FORMAT_READ;
       }
-      if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ
-          && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ
-          && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
+      if (endUs != C.TIME_END_OF_SOURCE
+          && ((result == C.RESULT_BUFFER_READ && buffer.timeUs >= endUs)
+              || (result == C.RESULT_NOTHING_READ
+                  && getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
         buffer.clear();
         buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
         sentEos = true;
@@ -294,7 +318,10 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
 
     @Override
     public int skipData(long positionUs) {
-      return stream.skipData(startUs + positionUs);
+      if (isPendingInitialDiscontinuity()) {
+        return C.RESULT_NOTHING_READ;
+      }
+      return childStream.skipData(startUs + positionUs);
     }
 
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
index c6924e844a..9ff704e75a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ClippingMediaSource.java
@@ -15,20 +15,68 @@
  */
 package com.google.android.exoplayer2.source;
 
+import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 
 /**
  * {@link MediaSource} that wraps a source and clips its timeline based on specified start/end
- * positions. The wrapped source may only have a single period/window and it must not be dynamic
- * (live).
+ * positions. The wrapped source must consist of a single period that starts at the beginning of the
+ * corresponding window.
  */
-public final class ClippingMediaSource implements MediaSource, MediaSource.Listener {
+public final class ClippingMediaSource extends CompositeMediaSource<Void> {
+
+  /**
+   * Thrown when a {@link ClippingMediaSource} cannot clip its wrapped source.
+   */
+  public static final class IllegalClippingException extends IOException {
+
+    /**
+     * The reason the clipping failed.
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({REASON_INVALID_PERIOD_COUNT, REASON_PERIOD_OFFSET_IN_WINDOW,
+        REASON_NOT_SEEKABLE_TO_START, REASON_START_EXCEEDS_END})
+    public @interface Reason {}
+    /**
+     * The wrapped source doesn't consist of a single period.
+     */
+    public static final int REASON_INVALID_PERIOD_COUNT = 0;
+    /**
+     * The wrapped source period doesn't start at the beginning of the corresponding window.
+     */
+    public static final int REASON_PERIOD_OFFSET_IN_WINDOW = 1;
+    /**
+     * The wrapped source is not seekable and a non-zero clipping start position was specified.
+     */
+    public static final int REASON_NOT_SEEKABLE_TO_START = 2;
+    /**
+     * The wrapped source ends before the specified clipping start position.
+     */
+    public static final int REASON_START_EXCEEDS_END = 3;
+
+    /**
+     * The reason clipping failed.
+     */
+    @Reason
+    public final int reason;
+
+    /**
+     * @param reason The reason clipping failed.
+     */
+    public IllegalClippingException(@Reason int reason) {
+      this.reason = reason;
+    }
+
+  }
 
   private final MediaSource mediaSource;
   private final long startUs;
@@ -37,11 +85,12 @@
   private final ArrayList<ClippingMediaPeriod> mediaPeriods;
 
   private MediaSource.Listener sourceListener;
+  private IllegalClippingException clippingError;
 
   /**
    * Creates a new clipping source that wraps the specified source.
    *
-   * @param mediaSource The single-period, non-dynamic source to wrap.
+   * @param mediaSource The single-period source to wrap.
    * @param startPositionUs The start position within {@code mediaSource}'s timeline at which to
    *     start providing samples, in microseconds.
    * @param endPositionUs The end position within {@code mediaSource}'s timeline at which to stop
@@ -61,7 +110,7 @@ public ClippingMediaSource(MediaSource mediaSource, long startPositionUs, long e
    * {@code enableInitialPositionDiscontinuity} to suppress an initial discontinuity when a period
    * is first read from.
    *
-   * @param mediaSource The single-period, non-dynamic source to wrap.
+   * @param mediaSource The single-period source to wrap.
    * @param startPositionUs The start position within {@code mediaSource}'s timeline at which to
    *     start providing samples, in microseconds.
    * @param endPositionUs The end position within {@code mediaSource}'s timeline at which to stop
@@ -83,13 +132,17 @@ public ClippingMediaSource(MediaSource mediaSource, long startPositionUs, long e
 
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
-    this.sourceListener = listener;
-    mediaSource.prepareSource(player, false, this);
+    super.prepareSource(player, isTopLevelSource, listener);
+    sourceListener = listener;
+    prepareChildSource(/* id= */ null, mediaSource);
   }
 
   @Override
   public void maybeThrowSourceInfoRefreshError() throws IOException {
-    mediaSource.maybeThrowSourceInfoRefreshError();
+    if (clippingError != null) {
+      throw clippingError;
+    }
+    super.maybeThrowSourceInfoRefreshError();
   }
 
   @Override
@@ -109,15 +162,25 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSource() {
-    mediaSource.releaseSource();
+    super.releaseSource();
+    clippingError = null;
+    sourceListener = null;
   }
 
-  // MediaSource.Listener implementation.
-
   @Override
-  public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
-    sourceListener.onSourceInfoRefreshed(this, new ClippingTimeline(timeline, startUs, endUs),
-        manifest);
+  protected void onChildSourceInfoRefreshed(
+      Void id, MediaSource mediaSource, Timeline timeline, @Nullable Object manifest) {
+    if (clippingError != null) {
+      return;
+    }
+    ClippingTimeline clippingTimeline;
+    try {
+      clippingTimeline = new ClippingTimeline(timeline, startUs, endUs);
+    } catch (IllegalClippingException e) {
+      clippingError = e;
+      return;
+    }
+    sourceListener.onSourceInfoRefreshed(this, clippingTimeline, manifest);
     int count = mediaPeriods.size();
     for (int i = 0; i < count; i++) {
       mediaPeriods.get(i).setClipping(startUs, endUs);
@@ -139,23 +202,30 @@ public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object
      * @param startUs The number of microseconds to clip from the start of {@code timeline}.
      * @param endUs The end position in microseconds for the clipped timeline relative to the start
      *     of {@code timeline}, or {@link C#TIME_END_OF_SOURCE} to clip no samples from the end.
+     * @throws IllegalClippingException If the timeline could not be clipped.
      */
-    public ClippingTimeline(Timeline timeline, long startUs, long endUs) {
+    public ClippingTimeline(Timeline timeline, long startUs, long endUs)
+        throws IllegalClippingException {
       super(timeline);
-      Assertions.checkArgument(timeline.getWindowCount() == 1);
-      Assertions.checkArgument(timeline.getPeriodCount() == 1);
+      if (timeline.getPeriodCount() != 1) {
+        throw new IllegalClippingException(IllegalClippingException.REASON_INVALID_PERIOD_COUNT);
+      }
+      if (timeline.getPeriod(0, new Period()).getPositionInWindowUs() != 0) {
+        throw new IllegalClippingException(IllegalClippingException.REASON_PERIOD_OFFSET_IN_WINDOW);
+      }
       Window window = timeline.getWindow(0, new Window(), false);
-      Assertions.checkArgument(!window.isDynamic);
       long resolvedEndUs = endUs == C.TIME_END_OF_SOURCE ? window.durationUs : endUs;
       if (window.durationUs != C.TIME_UNSET) {
         if (resolvedEndUs > window.durationUs) {
           resolvedEndUs = window.durationUs;
         }
-        Assertions.checkArgument(startUs == 0 || window.isSeekable);
-        Assertions.checkArgument(startUs <= resolvedEndUs);
+        if (startUs != 0 && !window.isSeekable) {
+          throw new IllegalClippingException(IllegalClippingException.REASON_NOT_SEEKABLE_TO_START);
+        }
+        if (startUs > resolvedEndUs) {
+          throw new IllegalClippingException(IllegalClippingException.REASON_START_EXCEEDS_END);
+        }
       }
-      Period period = timeline.getPeriod(0, new Period());
-      Assertions.checkArgument(period.getPositionInWindowUs() == 0);
       this.startUs = startUs;
       this.endUs = resolvedEndUs;
     }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
new file mode 100644
index 0000000000..6472fe3c2f
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeMediaSource.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import android.support.annotation.CallSuper;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+import java.util.HashMap;
+
+/**
+ * Composite {@link MediaSource} consisting of multiple child sources.
+ *
+ * @param <T> The type of the id used to identify prepared child sources.
+ */
+public abstract class CompositeMediaSource<T> implements MediaSource {
+
+  private final HashMap<T, MediaSource> childSources;
+  private ExoPlayer player;
+
+  /** Create composite media source without child sources. */
+  protected CompositeMediaSource() {
+    childSources = new HashMap<>();
+  }
+
+  @Override
+  @CallSuper
+  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    this.player = player;
+  }
+
+  @Override
+  @CallSuper
+  public void maybeThrowSourceInfoRefreshError() throws IOException {
+    for (MediaSource childSource : childSources.values()) {
+      childSource.maybeThrowSourceInfoRefreshError();
+    }
+  }
+
+  @Override
+  @CallSuper
+  public void releaseSource() {
+    for (MediaSource childSource : childSources.values()) {
+      childSource.releaseSource();
+    }
+    childSources.clear();
+    player = null;
+  }
+
+  /**
+   * Called when the source info of a child source has been refreshed.
+   *
+   * @param id The unique id used to prepare the child source.
+   * @param mediaSource The child source whose source info has been refreshed.
+   * @param timeline The timeline of the child source.
+   * @param manifest The manifest of the child source.
+   */
+  protected abstract void onChildSourceInfoRefreshed(
+      @Nullable T id, MediaSource mediaSource, Timeline timeline, @Nullable Object manifest);
+
+  /**
+   * Prepares a child source.
+   *
+   * <p>{@link #onChildSourceInfoRefreshed(Object, MediaSource, Timeline, Object)} will be called
+   * when the child source updates its timeline and/or manifest with the same {@code id} passed to
+   * this method.
+   *
+   * <p>Any child sources that aren't explicitly released with {@link #releaseChildSource(Object)}
+   * will be released in {@link #releaseSource()}.
+   *
+   * @param id A unique id to identify the child source preparation. Null is allowed as an id.
+   * @param mediaSource The child {@link MediaSource}.
+   */
+  protected void prepareChildSource(@Nullable final T id, final MediaSource mediaSource) {
+    Assertions.checkArgument(!childSources.containsKey(id));
+    childSources.put(id, mediaSource);
+    mediaSource.prepareSource(
+        player,
+        /* isTopLevelSource= */ false,
+        new Listener() {
+          @Override
+          public void onSourceInfoRefreshed(
+              MediaSource source, Timeline timeline, @Nullable Object manifest) {
+            onChildSourceInfoRefreshed(id, mediaSource, timeline, manifest);
+          }
+        });
+  }
+
+  /**
+   * Releases a child source.
+   *
+   * @param id The unique id used to prepare the child source.
+   */
+  protected void releaseChildSource(@Nullable T id) {
+    MediaSource removedChild = childSources.remove(id);
+    removedChild.releaseSource();
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
index a85d589762..c41933b48b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoader.java
@@ -20,9 +20,9 @@
 /**
  * A {@link SequenceableLoader} that encapsulates multiple other {@link SequenceableLoader}s.
  */
-public final class CompositeSequenceableLoader implements SequenceableLoader {
+public class CompositeSequenceableLoader implements SequenceableLoader {
 
-  private final SequenceableLoader[] loaders;
+  protected final SequenceableLoader[] loaders;
 
   public CompositeSequenceableLoader(SequenceableLoader[] loaders) {
     this.loaders = loaders;
@@ -53,7 +53,14 @@ public final long getNextLoadPositionUs() {
   }
 
   @Override
-  public final boolean continueLoading(long positionUs) {
+  public final void reevaluateBuffer(long positionUs) {
+    for (SequenceableLoader loader : loaders) {
+      loader.reevaluateBuffer(positionUs);
+    }
+  }
+
+  @Override
+  public boolean continueLoading(long positionUs) {
     boolean madeProgress = false;
     boolean madeProgressThisIteration;
     do {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderFactory.java
new file mode 100644
index 0000000000..b4a266feef
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderFactory.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+/**
+ * A factory to create composite {@link SequenceableLoader}s.
+ */
+public interface CompositeSequenceableLoaderFactory {
+
+  /**
+   * Creates a composite {@link SequenceableLoader}.
+   *
+   * @param loaders The sub-loaders that make up the {@link SequenceableLoader} to be built.
+   * @return A composite {@link SequenceableLoader} that comprises the given loaders.
+   */
+  SequenceableLoader createCompositeSequenceableLoader(SequenceableLoader... loaders);
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
index 058471f31f..c29367e109 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ConcatenatingMediaSource.java
@@ -15,15 +15,14 @@
  */
 package com.google.android.exoplayer2.source;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
 import java.util.HashMap;
 import java.util.IdentityHashMap;
 import java.util.Map;
@@ -32,13 +31,12 @@
  * Concatenates multiple {@link MediaSource}s. It is valid for the same {@link MediaSource} instance
  * to be present more than once in the concatenation.
  */
-public final class ConcatenatingMediaSource implements MediaSource {
+public final class ConcatenatingMediaSource extends CompositeMediaSource<Integer> {
 
   private final MediaSource[] mediaSources;
   private final Timeline[] timelines;
   private final Object[] manifests;
   private final Map<MediaPeriod, Integer> sourceIndexByMediaPeriod;
-  private final boolean[] duplicateFlags;
   private final boolean isAtomic;
   private final ShuffleOrder shuffleOrder;
 
@@ -84,39 +82,24 @@ public ConcatenatingMediaSource(boolean isAtomic, ShuffleOrder shuffleOrder,
     timelines = new Timeline[mediaSources.length];
     manifests = new Object[mediaSources.length];
     sourceIndexByMediaPeriod = new HashMap<>();
-    duplicateFlags = buildDuplicateFlags(mediaSources);
   }
 
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    super.prepareSource(player, isTopLevelSource, listener);
     this.listener = listener;
+    boolean[] duplicateFlags = buildDuplicateFlags(mediaSources);
     if (mediaSources.length == 0) {
       listener.onSourceInfoRefreshed(this, Timeline.EMPTY, null);
     } else {
       for (int i = 0; i < mediaSources.length; i++) {
         if (!duplicateFlags[i]) {
-          final int index = i;
-          mediaSources[i].prepareSource(player, false, new Listener() {
-            @Override
-            public void onSourceInfoRefreshed(MediaSource source, Timeline timeline,
-                Object manifest) {
-              handleSourceInfoRefreshed(index, timeline, manifest);
-            }
-          });
+          prepareChildSource(i, mediaSources[i]);
         }
       }
     }
   }
 
-  @Override
-  public void maybeThrowSourceInfoRefreshError() throws IOException {
-    for (int i = 0; i < mediaSources.length; i++) {
-      if (!duplicateFlags[i]) {
-        mediaSources[i].maybeThrowSourceInfoRefreshError();
-      }
-    }
-  }
-
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     int sourceIndex = timeline.getChildIndexByPeriodIndex(id.periodIndex);
@@ -136,21 +119,23 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSource() {
-    for (int i = 0; i < mediaSources.length; i++) {
-      if (!duplicateFlags[i]) {
-        mediaSources[i].releaseSource();
-      }
-    }
+    super.releaseSource();
+    listener = null;
+    timeline = null;
   }
 
-  private void handleSourceInfoRefreshed(int sourceFirstIndex, Timeline sourceTimeline,
-      Object sourceManifest) {
+  @Override
+  protected void onChildSourceInfoRefreshed(
+      Integer sourceFirstIndex,
+      MediaSource mediaSource,
+      Timeline sourceTimeline,
+      @Nullable Object sourceManifest) {
     // Set the timeline and manifest.
     timelines[sourceFirstIndex] = sourceTimeline;
     manifests[sourceFirstIndex] = sourceManifest;
     // Also set the timeline and manifest for any duplicate entries of the same source.
     for (int i = sourceFirstIndex + 1; i < mediaSources.length; i++) {
-      if (mediaSources[i] == mediaSources[sourceFirstIndex]) {
+      if (mediaSources[i] == mediaSource) {
         timelines[i] = sourceTimeline;
         manifests[i] = sourceManifest;
       }
@@ -187,10 +172,9 @@ private void handleSourceInfoRefreshed(int sourceFirstIndex, Timeline sourceTime
     private final Timeline[] timelines;
     private final int[] sourcePeriodOffsets;
     private final int[] sourceWindowOffsets;
-    private final boolean isAtomic;
 
     public ConcatenatedTimeline(Timeline[] timelines, boolean isAtomic, ShuffleOrder shuffleOrder) {
-      super(shuffleOrder);
+      super(isAtomic, shuffleOrder);
       int[] sourcePeriodOffsets = new int[timelines.length];
       int[] sourceWindowOffsets = new int[timelines.length];
       long periodCount = 0;
@@ -207,7 +191,6 @@ public ConcatenatedTimeline(Timeline[] timelines, boolean isAtomic, ShuffleOrder
       this.timelines = timelines;
       this.sourcePeriodOffsets = sourcePeriodOffsets;
       this.sourceWindowOffsets = sourceWindowOffsets;
-      this.isAtomic = isAtomic;
     }
 
     @Override
@@ -220,34 +203,6 @@ public int getPeriodCount() {
       return sourcePeriodOffsets[sourcePeriodOffsets.length - 1];
     }
 
-    @Override
-    public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
-        boolean shuffleModeEnabled) {
-      if (isAtomic && repeatMode == Player.REPEAT_MODE_ONE) {
-        repeatMode = Player.REPEAT_MODE_ALL;
-      }
-      return super.getNextWindowIndex(windowIndex, repeatMode, !isAtomic && shuffleModeEnabled);
-    }
-
-    @Override
-    public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,
-        boolean shuffleModeEnabled) {
-      if (isAtomic && repeatMode == Player.REPEAT_MODE_ONE) {
-        repeatMode = Player.REPEAT_MODE_ALL;
-      }
-      return super.getPreviousWindowIndex(windowIndex, repeatMode, !isAtomic && shuffleModeEnabled);
-    }
-
-    @Override
-    public int getLastWindowIndex(boolean shuffleModeEnabled) {
-      return super.getLastWindowIndex(!isAtomic && shuffleModeEnabled);
-    }
-
-    @Override
-    public int getFirstWindowIndex(boolean shuffleModeEnabled) {
-      return super.getFirstWindowIndex(!isAtomic && shuffleModeEnabled);
-    }
-
     @Override
     protected int getChildIndexByPeriodIndex(int periodIndex) {
       return Util.binarySearchFloor(sourcePeriodOffsets, periodIndex + 1, false, false) + 1;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaOutputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DefaultCompositeSequenceableLoaderFactory.java
similarity index 52%
rename from library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaOutputBuffer.java
rename to library/core/src/main/java/com/google/android/exoplayer2/source/DefaultCompositeSequenceableLoaderFactory.java
index 4cc32bb9e4..759b0824af 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaOutputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DefaultCompositeSequenceableLoaderFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2017 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,28 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.text.cea;
-
-import com.google.android.exoplayer2.text.SubtitleOutputBuffer;
+package com.google.android.exoplayer2.source;
 
 /**
- * A {@link SubtitleOutputBuffer} for {@link CeaDecoder}s.
+ * Default implementation of {@link CompositeSequenceableLoaderFactory}.
  */
-public final class CeaOutputBuffer extends SubtitleOutputBuffer {
-
-  private final CeaDecoder owner;
-
-  /**
-   * @param owner The decoder that owns this buffer.
-   */
-  public CeaOutputBuffer(CeaDecoder owner) {
-    super();
-    this.owner = owner;
-  }
+public final class DefaultCompositeSequenceableLoaderFactory
+    implements CompositeSequenceableLoaderFactory {
 
   @Override
-  public final void release() {
-    owner.releaseOutputBuffer(this);
+  public SequenceableLoader createCompositeSequenceableLoader(SequenceableLoader... loaders) {
+    return new CompositeSequenceableLoader(loaders);
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
new file mode 100644
index 0000000000..e13a563d50
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DeferredMediaPeriod.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.upstream.Allocator;
+import java.io.IOException;
+
+/**
+ * Media period that wraps a media source and defers calling its
+ * {@link MediaSource#createPeriod(MediaPeriodId, Allocator)} method until {@link #createPeriod()}
+ * has been called. This is useful if you need to return a media period immediately but the media
+ * source that should create it is not yet prepared.
+ */
+public final class DeferredMediaPeriod implements MediaPeriod, MediaPeriod.Callback {
+
+  /** Listener for preparation errors. */
+  public interface PrepareErrorListener {
+
+    /**
+     * Called the first time an error occurs while refreshing source info or preparing the period.
+     */
+    void onPrepareError(IOException exception);
+  }
+
+  public final MediaSource mediaSource;
+
+  private final MediaPeriodId id;
+  private final Allocator allocator;
+
+  private MediaPeriod mediaPeriod;
+  private Callback callback;
+  private long preparePositionUs;
+  private @Nullable PrepareErrorListener listener;
+  private boolean notifiedPrepareError;
+
+  /**
+   * Creates a new deferred media period.
+   *
+   * @param mediaSource The media source to wrap.
+   * @param id The identifier for the media period to create when {@link #createPeriod()} is called.
+   * @param allocator The allocator used to create the media period.
+   */
+  public DeferredMediaPeriod(MediaSource mediaSource, MediaPeriodId id, Allocator allocator) {
+    this.id = id;
+    this.allocator = allocator;
+    this.mediaSource = mediaSource;
+  }
+
+  /**
+   * Sets a listener for preparation errors.
+   *
+   * @param listener An listener to be notified of media period preparation errors. If a listener is
+   *     set, {@link #maybeThrowPrepareError()} will not throw but will instead pass the first
+   *     preparation error (if any) to the listener.
+   */
+  public void setPrepareErrorListener(PrepareErrorListener listener) {
+    this.listener = listener;
+  }
+
+  /**
+   * Calls {@link MediaSource#createPeriod(MediaPeriodId, Allocator)} on the wrapped source then
+   * prepares it if {@link #prepare(Callback, long)} has been called. Call {@link #releasePeriod()}
+   * to release the period.
+   */
+  public void createPeriod() {
+    mediaPeriod = mediaSource.createPeriod(id, allocator);
+    if (callback != null) {
+      mediaPeriod.prepare(this, preparePositionUs);
+    }
+  }
+
+  /**
+   * Releases the period.
+   */
+  public void releasePeriod() {
+    if (mediaPeriod != null) {
+      mediaSource.releasePeriod(mediaPeriod);
+    }
+  }
+
+  @Override
+  public void prepare(Callback callback, long preparePositionUs) {
+    this.callback = callback;
+    this.preparePositionUs = preparePositionUs;
+    if (mediaPeriod != null) {
+      mediaPeriod.prepare(this, preparePositionUs);
+    }
+  }
+
+  @Override
+  public void maybeThrowPrepareError() throws IOException {
+    try {
+      if (mediaPeriod != null) {
+        mediaPeriod.maybeThrowPrepareError();
+      } else {
+        mediaSource.maybeThrowSourceInfoRefreshError();
+      }
+    } catch (final IOException e) {
+      if (listener == null) {
+        throw e;
+      }
+      if (!notifiedPrepareError) {
+        notifiedPrepareError = true;
+        listener.onPrepareError(e);
+      }
+    }
+  }
+
+  @Override
+  public TrackGroupArray getTrackGroups() {
+    return mediaPeriod.getTrackGroups();
+  }
+
+  @Override
+  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
+    return mediaPeriod.selectTracks(selections, mayRetainStreamFlags, streams, streamResetFlags,
+        positionUs);
+  }
+
+  @Override
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
+    mediaPeriod.discardBuffer(positionUs, toKeyframe);
+  }
+
+  @Override
+  public long readDiscontinuity() {
+    return mediaPeriod.readDiscontinuity();
+  }
+
+  @Override
+  public long getBufferedPositionUs() {
+    return mediaPeriod.getBufferedPositionUs();
+  }
+
+  @Override
+  public long seekToUs(long positionUs) {
+    return mediaPeriod.seekToUs(positionUs);
+  }
+
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    return mediaPeriod.getAdjustedSeekPositionUs(positionUs, seekParameters);
+  }
+
+  @Override
+  public long getNextLoadPositionUs() {
+    return mediaPeriod.getNextLoadPositionUs();
+  }
+
+  @Override
+  public void reevaluateBuffer(long positionUs) {
+    mediaPeriod.reevaluateBuffer(positionUs);
+  }
+
+  @Override
+  public boolean continueLoading(long positionUs) {
+    return mediaPeriod != null && mediaPeriod.continueLoading(positionUs);
+  }
+
+  @Override
+  public void onContinueLoadingRequested(MediaPeriod source) {
+    callback.onContinueLoadingRequested(this);
+  }
+
+  // MediaPeriod.Callback implementation
+
+  @Override
+  public void onPrepared(MediaPeriod mediaPeriod) {
+    callback.onPrepared(this);
+  }
+
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSource.java
index e80abad3ef..f52c1bfd0f 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSource.java
@@ -23,15 +23,13 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.ExoPlayer.ExoPlayerComponent;
-import com.google.android.exoplayer2.ExoPlayer.ExoPlayerMessage;
+import com.google.android.exoplayer2.PlayerMessage;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.DynamicConcatenatingMediaSource.MediaSourceHolder;
 import com.google.android.exoplayer2.source.ShuffleOrder.DefaultShuffleOrder;
-import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -43,7 +41,8 @@
  * Concatenates multiple {@link MediaSource}s. The list of {@link MediaSource}s can be modified
  * during playback. Access to this class is thread-safe.
  */
-public final class DynamicConcatenatingMediaSource implements MediaSource, ExoPlayerComponent {
+public final class DynamicConcatenatingMediaSource extends CompositeMediaSource<MediaSourceHolder>
+    implements PlayerMessage.Target {
 
   private static final int MSG_ADD = 0;
   private static final int MSG_ADD_MULTIPLE = 1;
@@ -57,8 +56,9 @@
   // Accessed on the playback thread.
   private final List<MediaSourceHolder> mediaSourceHolders;
   private final MediaSourceHolder query;
-  private final Map<MediaPeriod, MediaSource> mediaSourceByMediaPeriod;
+  private final Map<MediaPeriod, MediaSourceHolder> mediaSourceByMediaPeriod;
   private final List<DeferredMediaPeriod> deferredMediaPeriods;
+  private final boolean isAtomic;
 
   private ExoPlayer player;
   private Listener listener;
@@ -71,22 +71,35 @@
    * Creates a new dynamic concatenating media source.
    */
   public DynamicConcatenatingMediaSource() {
-    this(new DefaultShuffleOrder(0));
+    this(/* isAtomic= */ false, new DefaultShuffleOrder(0));
+  }
+
+  /**
+   * Creates a new dynamic concatenating media source.
+   *
+   * @param isAtomic Whether the concatenating media source will be treated as atomic, i.e., treated
+   *     as a single item for repeating and shuffling.
+   */
+  public DynamicConcatenatingMediaSource(boolean isAtomic) {
+    this(isAtomic, new DefaultShuffleOrder(0));
   }
 
   /**
    * Creates a new dynamic concatenating media source with a custom shuffle order.
    *
+   * @param isAtomic Whether the concatenating media source will be treated as atomic, i.e., treated
+   *     as a single item for repeating and shuffling.
    * @param shuffleOrder The {@link ShuffleOrder} to use when shuffling the child media sources.
    *     This shuffle order must be empty.
    */
-  public DynamicConcatenatingMediaSource(ShuffleOrder shuffleOrder) {
+  public DynamicConcatenatingMediaSource(boolean isAtomic, ShuffleOrder shuffleOrder) {
     this.shuffleOrder = shuffleOrder;
     this.mediaSourceByMediaPeriod = new IdentityHashMap<>();
     this.mediaSourcesPublic = new ArrayList<>();
     this.mediaSourceHolders = new ArrayList<>();
     this.deferredMediaPeriods = new ArrayList<>(1);
     this.query = new MediaSourceHolder(null, null, -1, -1, -1);
+    this.isAtomic = isAtomic;
   }
 
   /**
@@ -148,8 +161,11 @@ public synchronized void addMediaSource(int index, MediaSource mediaSource,
     Assertions.checkArgument(!mediaSourcesPublic.contains(mediaSource));
     mediaSourcesPublic.add(index, mediaSource);
     if (player != null) {
-      player.sendMessages(new ExoPlayerMessage(this, MSG_ADD,
-          new MessageData<>(index, mediaSource, actionOnCompletion)));
+      player
+          .createMessage(this)
+          .setType(MSG_ADD)
+          .setPayload(new MessageData<>(index, mediaSource, actionOnCompletion))
+          .send();
     } else if (actionOnCompletion != null) {
       actionOnCompletion.run();
     }
@@ -221,8 +237,11 @@ public synchronized void addMediaSources(int index, Collection<MediaSource> medi
     }
     mediaSourcesPublic.addAll(index, mediaSources);
     if (player != null && !mediaSources.isEmpty()) {
-      player.sendMessages(new ExoPlayerMessage(this, MSG_ADD_MULTIPLE,
-          new MessageData<>(index, mediaSources, actionOnCompletion)));
+      player
+          .createMessage(this)
+          .setType(MSG_ADD_MULTIPLE)
+          .setPayload(new MessageData<>(index, mediaSources, actionOnCompletion))
+          .send();
     } else if (actionOnCompletion != null){
       actionOnCompletion.run();
     }
@@ -257,8 +276,11 @@ public synchronized void removeMediaSource(int index) {
   public synchronized void removeMediaSource(int index, @Nullable Runnable actionOnCompletion) {
     mediaSourcesPublic.remove(index);
     if (player != null) {
-      player.sendMessages(new ExoPlayerMessage(this, MSG_REMOVE,
-          new MessageData<>(index, null, actionOnCompletion)));
+      player
+          .createMessage(this)
+          .setType(MSG_REMOVE)
+          .setPayload(new MessageData<>(index, null, actionOnCompletion))
+          .send();
     } else if (actionOnCompletion != null) {
       actionOnCompletion.run();
     }
@@ -294,8 +316,11 @@ public synchronized void moveMediaSource(int currentIndex, int newIndex,
     }
     mediaSourcesPublic.add(newIndex, mediaSourcesPublic.remove(currentIndex));
     if (player != null) {
-      player.sendMessages(new ExoPlayerMessage(this, MSG_MOVE,
-          new MessageData<>(currentIndex, newIndex, actionOnCompletion)));
+      player
+          .createMessage(this)
+          .setType(MSG_MOVE)
+          .setPayload(new MessageData<>(currentIndex, newIndex, actionOnCompletion))
+          .send();
     } else if (actionOnCompletion != null) {
       actionOnCompletion.run();
     }
@@ -321,6 +346,7 @@ public synchronized MediaSource getMediaSource(int index) {
   @Override
   public synchronized void prepareSource(ExoPlayer player, boolean isTopLevelSource,
       Listener listener) {
+    super.prepareSource(player, isTopLevelSource, listener);
     this.player = player;
     this.listener = listener;
     preventListenerNotification = true;
@@ -330,13 +356,6 @@ public synchronized void prepareSource(ExoPlayer player, boolean isTopLevelSourc
     maybeNotifyListener(null);
   }
 
-  @Override
-  public void maybeThrowSourceInfoRefreshError() throws IOException {
-    for (int i = 0; i < mediaSourceHolders.size(); i++) {
-      mediaSourceHolders.get(i).mediaSource.maybeThrowSourceInfoRefreshError();
-    }
-  }
-
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     int mediaSourceHolderIndex = findMediaSourceHolderByPeriodIndex(id.periodIndex);
@@ -350,27 +369,44 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     } else {
       mediaPeriod = holder.mediaSource.createPeriod(idInSource, allocator);
     }
-    mediaSourceByMediaPeriod.put(mediaPeriod, holder.mediaSource);
+    mediaSourceByMediaPeriod.put(mediaPeriod, holder);
+    holder.activeMediaPeriods++;
     return mediaPeriod;
   }
 
   @Override
   public void releasePeriod(MediaPeriod mediaPeriod) {
-    MediaSource mediaSource = mediaSourceByMediaPeriod.get(mediaPeriod);
-    mediaSourceByMediaPeriod.remove(mediaPeriod);
+    MediaSourceHolder holder = mediaSourceByMediaPeriod.remove(mediaPeriod);
     if (mediaPeriod instanceof DeferredMediaPeriod) {
       deferredMediaPeriods.remove(mediaPeriod);
       ((DeferredMediaPeriod) mediaPeriod).releasePeriod();
     } else {
-      mediaSource.releasePeriod(mediaPeriod);
+      holder.mediaSource.releasePeriod(mediaPeriod);
+    }
+    holder.activeMediaPeriods--;
+    if (holder.activeMediaPeriods == 0 && holder.isRemoved) {
+      releaseChildSource(holder);
     }
   }
 
   @Override
   public void releaseSource() {
-    for (int i = 0; i < mediaSourceHolders.size(); i++) {
-      mediaSourceHolders.get(i).mediaSource.releaseSource();
-    }
+    super.releaseSource();
+    mediaSourceHolders.clear();
+    player = null;
+    listener = null;
+    shuffleOrder = shuffleOrder.cloneAndClear();
+    windowCount = 0;
+    periodCount = 0;
+  }
+
+  @Override
+  protected void onChildSourceInfoRefreshed(
+      MediaSourceHolder mediaSourceHolder,
+      MediaSource mediaSource,
+      Timeline timeline,
+      @Nullable Object manifest) {
+    updateMediaSourceInternal(mediaSourceHolder, timeline);
   }
 
   @Override
@@ -424,37 +460,39 @@ public void handleMessage(int messageType, Object message) throws ExoPlaybackExc
 
   private void maybeNotifyListener(@Nullable EventDispatcher actionOnCompletion) {
     if (!preventListenerNotification) {
-      listener.onSourceInfoRefreshed(this,
-          new ConcatenatedTimeline(mediaSourceHolders, windowCount, periodCount, shuffleOrder),
+      listener.onSourceInfoRefreshed(
+          this,
+          new ConcatenatedTimeline(
+              mediaSourceHolders, windowCount, periodCount, shuffleOrder, isAtomic),
           null);
       if (actionOnCompletion != null) {
-        player.sendMessages(
-            new ExoPlayerMessage(this, MSG_ON_COMPLETION, actionOnCompletion));
+        player.createMessage(this).setType(MSG_ON_COMPLETION).setPayload(actionOnCompletion).send();
       }
     }
   }
 
   private void addMediaSourceInternal(int newIndex, MediaSource newMediaSource) {
     final MediaSourceHolder newMediaSourceHolder;
-    Object newUid = System.identityHashCode(newMediaSource);
     DeferredTimeline newTimeline = new DeferredTimeline();
     if (newIndex > 0) {
       MediaSourceHolder previousHolder = mediaSourceHolders.get(newIndex - 1);
-      newMediaSourceHolder = new MediaSourceHolder(newMediaSource, newTimeline,
-          previousHolder.firstWindowIndexInChild + previousHolder.timeline.getWindowCount(),
-          previousHolder.firstPeriodIndexInChild + previousHolder.timeline.getPeriodCount(),
-          newUid);
+      newMediaSourceHolder =
+          new MediaSourceHolder(
+              newMediaSource,
+              newTimeline,
+              newIndex,
+              previousHolder.firstWindowIndexInChild + previousHolder.timeline.getWindowCount(),
+              previousHolder.firstPeriodIndexInChild + previousHolder.timeline.getPeriodCount());
     } else {
-      newMediaSourceHolder = new MediaSourceHolder(newMediaSource, newTimeline, 0, 0, newUid);
+      newMediaSourceHolder = new MediaSourceHolder(newMediaSource, newTimeline, 0, 0, 0);
     }
-    correctOffsets(newIndex, newTimeline.getWindowCount(), newTimeline.getPeriodCount());
+    correctOffsets(
+        newIndex,
+        /* childIndexUpdate= */ 1,
+        newTimeline.getWindowCount(),
+        newTimeline.getPeriodCount());
     mediaSourceHolders.add(newIndex, newMediaSourceHolder);
-    newMediaSourceHolder.mediaSource.prepareSource(player, false, new Listener() {
-      @Override
-      public void onSourceInfoRefreshed(MediaSource source, Timeline newTimeline, Object manifest) {
-        updateMediaSourceInternal(newMediaSourceHolder, newTimeline);
-      }
-    });
+    prepareChildSource(newMediaSourceHolder, newMediaSourceHolder.mediaSource);
   }
 
   private void addMediaSourcesInternal(int index, Collection<MediaSource> mediaSources) {
@@ -474,8 +512,11 @@ private void updateMediaSourceInternal(MediaSourceHolder mediaSourceHolder, Time
     int windowOffsetUpdate = timeline.getWindowCount() - deferredTimeline.getWindowCount();
     int periodOffsetUpdate = timeline.getPeriodCount() - deferredTimeline.getPeriodCount();
     if (windowOffsetUpdate != 0 || periodOffsetUpdate != 0) {
-      int index = findMediaSourceHolderByPeriodIndex(mediaSourceHolder.firstPeriodIndexInChild);
-      correctOffsets(index + 1, windowOffsetUpdate, periodOffsetUpdate);
+      correctOffsets(
+          mediaSourceHolder.childIndex + 1,
+          /* childIndexUpdate= */ 0,
+          windowOffsetUpdate,
+          periodOffsetUpdate);
     }
     mediaSourceHolder.timeline = deferredTimeline.cloneWithNewTimeline(timeline);
     if (!mediaSourceHolder.isPrepared) {
@@ -494,8 +535,15 @@ private void removeMediaSourceInternal(int index) {
     MediaSourceHolder holder = mediaSourceHolders.get(index);
     mediaSourceHolders.remove(index);
     Timeline oldTimeline = holder.timeline;
-    correctOffsets(index, -oldTimeline.getWindowCount(), -oldTimeline.getPeriodCount());
-    holder.mediaSource.releaseSource();
+    correctOffsets(
+        index,
+        /* childIndexUpdate= */ -1,
+        -oldTimeline.getWindowCount(),
+        -oldTimeline.getPeriodCount());
+    holder.isRemoved = true;
+    if (holder.activeMediaPeriods == 0) {
+      releaseChildSource(holder);
+    }
   }
 
   private void moveMediaSourceInternal(int currentIndex, int newIndex) {
@@ -513,10 +561,12 @@ private void moveMediaSourceInternal(int currentIndex, int newIndex) {
     }
   }
 
-  private void correctOffsets(int startIndex, int windowOffsetUpdate, int periodOffsetUpdate) {
+  private void correctOffsets(
+      int startIndex, int childIndexUpdate, int windowOffsetUpdate, int periodOffsetUpdate) {
     windowCount += windowOffsetUpdate;
     periodCount += periodOffsetUpdate;
     for (int i = startIndex; i < mediaSourceHolders.size(); i++) {
+      mediaSourceHolders.get(i).childIndex += childIndexUpdate;
       mediaSourceHolders.get(i).firstWindowIndexInChild += windowOffsetUpdate;
       mediaSourceHolders.get(i).firstPeriodIndexInChild += periodOffsetUpdate;
     }
@@ -535,26 +585,32 @@ private int findMediaSourceHolderByPeriodIndex(int periodIndex) {
     return index;
   }
 
-  /**
-   * Data class to hold playlist media sources together with meta data needed to process them.
-   */
-  private static final class MediaSourceHolder implements Comparable<MediaSourceHolder> {
+  /** Data class to hold playlist media sources together with meta data needed to process them. */
+  /* package */ static final class MediaSourceHolder implements Comparable<MediaSourceHolder> {
 
     public final MediaSource mediaSource;
-    public final Object uid;
+    public final int uid;
 
     public DeferredTimeline timeline;
+    public int childIndex;
     public int firstWindowIndexInChild;
     public int firstPeriodIndexInChild;
     public boolean isPrepared;
-
-    public MediaSourceHolder(MediaSource mediaSource, DeferredTimeline timeline, int window,
-        int period, Object uid) {
+    public boolean isRemoved;
+    public int activeMediaPeriods;
+
+    public MediaSourceHolder(
+        MediaSource mediaSource,
+        DeferredTimeline timeline,
+        int childIndex,
+        int window,
+        int period) {
       this.mediaSource = mediaSource;
       this.timeline = timeline;
+      this.childIndex = childIndex;
       this.firstWindowIndexInChild = window;
       this.firstPeriodIndexInChild = period;
-      this.uid = uid;
+      this.uid = System.identityHashCode(this);
     }
 
     @Override
@@ -583,16 +639,14 @@ public void dispatchEvent() {
 
   }
 
-  /**
-   * Message used to post actions from app thread to playback thread.
-   */
-  private static final class MessageData<CustomType> {
+  /** Message used to post actions from app thread to playback thread. */
+  private static final class MessageData<T> {
 
     public final int index;
-    public final CustomType customData;
+    public final T customData;
     public final @Nullable EventDispatcher actionOnCompletion;
 
-    public MessageData(int index, CustomType customData, @Nullable Runnable actionOnCompletion) {
+    public MessageData(int index, T customData, @Nullable Runnable actionOnCompletion) {
       this.index = index;
       this.actionOnCompletion = actionOnCompletion != null
           ? new EventDispatcher(actionOnCompletion) : null;
@@ -614,9 +668,13 @@ public MessageData(int index, CustomType customData, @Nullable Runnable actionOn
     private final int[] uids;
     private final SparseIntArray childIndexByUid;
 
-    public ConcatenatedTimeline(Collection<MediaSourceHolder> mediaSourceHolders, int windowCount,
-        int periodCount, ShuffleOrder shuffleOrder) {
-      super(shuffleOrder);
+    public ConcatenatedTimeline(
+        Collection<MediaSourceHolder> mediaSourceHolders,
+        int windowCount,
+        int periodCount,
+        ShuffleOrder shuffleOrder,
+        boolean isAtomic) {
+      super(isAtomic, shuffleOrder);
       this.windowCount = windowCount;
       this.periodCount = periodCount;
       int childCount = mediaSourceHolders.size();
@@ -630,7 +688,7 @@ public ConcatenatedTimeline(Collection<MediaSourceHolder> mediaSourceHolders, in
         timelines[index] = mediaSourceHolder.timeline;
         firstPeriodInChildIndices[index] = mediaSourceHolder.firstPeriodIndexInChild;
         firstWindowInChildIndices[index] = mediaSourceHolder.firstWindowIndexInChild;
-        uids[index] = (int) mediaSourceHolder.uid;
+        uids[index] = mediaSourceHolder.uid;
         childIndexByUid.put(uids[index], index++);
       }
     }
@@ -690,61 +748,39 @@ public int getPeriodCount() {
    * Timeline used as placeholder for an unprepared media source. After preparation, a copy of the
    * DeferredTimeline is used to keep the originally assigned first period ID.
    */
-  private static final class DeferredTimeline extends Timeline {
+  private static final class DeferredTimeline extends ForwardingTimeline {
 
     private static final Object DUMMY_ID = new Object();
     private static final Period period = new Period();
+    private static final DummyTimeline dummyTimeline = new DummyTimeline();
 
-    private final Timeline timeline;
-    private final Object replacedID;
+    private final Object replacedId;
 
     public DeferredTimeline() {
-      timeline = null;
-      replacedID = null;
+      this(dummyTimeline, /* replacedId= */ null);
     }
 
-    private DeferredTimeline(Timeline timeline, Object replacedID) {
-      this.timeline = timeline;
-      this.replacedID = replacedID;
+    private DeferredTimeline(Timeline timeline, Object replacedId) {
+      super(timeline);
+      this.replacedId = replacedId;
     }
 
     public DeferredTimeline cloneWithNewTimeline(Timeline timeline) {
-      return new DeferredTimeline(timeline, replacedID == null && timeline.getPeriodCount() > 0
-          ? timeline.getPeriod(0, period, true).uid : replacedID);
+      return new DeferredTimeline(
+          timeline,
+          replacedId == null && timeline.getPeriodCount() > 0
+              ? timeline.getPeriod(0, period, true).uid
+              : replacedId);
     }
 
     public Timeline getTimeline() {
       return timeline;
     }
 
-    @Override
-    public int getWindowCount() {
-      return timeline == null ? 1 : timeline.getWindowCount();
-    }
-
-    @Override
-    public Window getWindow(int windowIndex, Window window, boolean setIds,
-        long defaultPositionProjectionUs) {
-      return timeline == null
-          // Dynamic window to indicate pending timeline updates.
-          ? window.set(setIds ? DUMMY_ID : null, C.TIME_UNSET, C.TIME_UNSET, false, true, 0,
-              C.TIME_UNSET, 0, 0, 0)
-          : timeline.getWindow(windowIndex, window, setIds, defaultPositionProjectionUs);
-    }
-
-    @Override
-    public int getPeriodCount() {
-      return timeline == null ? 1 : timeline.getPeriodCount();
-    }
-
     @Override
     public Period getPeriod(int periodIndex, Period period, boolean setIds) {
-      if (timeline == null) {
-        return period.set(setIds ? DUMMY_ID : null, setIds ? DUMMY_ID : null, 0, C.TIME_UNSET,
-            C.TIME_UNSET);
-      }
       timeline.getPeriod(periodIndex, period, setIds);
-      if (period.uid == replacedID) {
+      if (Util.areEqual(period.uid, replacedId)) {
         period.uid = DUMMY_ID;
       }
       return period;
@@ -752,117 +788,54 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
 
     @Override
     public int getIndexOfPeriod(Object uid) {
-      return timeline == null ? (uid == DUMMY_ID ? 0 : C.INDEX_UNSET)
-          : timeline.getIndexOfPeriod(uid == DUMMY_ID ? replacedID : uid);
+      return timeline.getIndexOfPeriod(DUMMY_ID.equals(uid) ? replacedId : uid);
     }
-
   }
 
-  /**
-   * Media period used for periods created from unprepared media sources exposed through
-   * {@link DeferredTimeline}. Period preparation is postponed until the actual media source becomes
-   * available.
-   */
-  private static final class DeferredMediaPeriod implements MediaPeriod, MediaPeriod.Callback {
-
-    public final MediaSource mediaSource;
-
-    private final MediaPeriodId id;
-    private final Allocator allocator;
-
-    private MediaPeriod mediaPeriod;
-    private Callback callback;
-    private long preparePositionUs;
-
-    public DeferredMediaPeriod(MediaSource mediaSource, MediaPeriodId id, Allocator allocator) {
-      this.id = id;
-      this.allocator = allocator;
-      this.mediaSource = mediaSource;
-    }
-
-    public void createPeriod() {
-      mediaPeriod = mediaSource.createPeriod(id, allocator);
-      if (callback != null) {
-        mediaPeriod.prepare(this, preparePositionUs);
-      }
-    }
-
-    public void releasePeriod() {
-      if (mediaPeriod != null) {
-        mediaSource.releasePeriod(mediaPeriod);
-      }
-    }
+  /** Dummy placeholder timeline with one dynamic window with a period of indeterminate duration. */
+  private static final class DummyTimeline extends Timeline {
 
     @Override
-    public void prepare(Callback callback, long preparePositionUs) {
-      this.callback = callback;
-      this.preparePositionUs = preparePositionUs;
-      if (mediaPeriod != null) {
-        mediaPeriod.prepare(this, preparePositionUs);
-      }
-    }
-
-    @Override
-    public void maybeThrowPrepareError() throws IOException {
-      if (mediaPeriod != null) {
-        mediaPeriod.maybeThrowPrepareError();
-      } else {
-        mediaSource.maybeThrowSourceInfoRefreshError();
-      }
-    }
-
-    @Override
-    public TrackGroupArray getTrackGroups() {
-      return mediaPeriod.getTrackGroups();
-    }
-
-    @Override
-    public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-        SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-      return mediaPeriod.selectTracks(selections, mayRetainStreamFlags, streams, streamResetFlags,
-          positionUs);
-    }
-
-    @Override
-    public void discardBuffer(long positionUs) {
-      mediaPeriod.discardBuffer(positionUs);
-    }
-
-    @Override
-    public long readDiscontinuity() {
-      return mediaPeriod.readDiscontinuity();
-    }
-
-    @Override
-    public long getBufferedPositionUs() {
-      return mediaPeriod.getBufferedPositionUs();
-    }
-
-    @Override
-    public long seekToUs(long positionUs) {
-      return mediaPeriod.seekToUs(positionUs);
+    public int getWindowCount() {
+      return 1;
     }
 
     @Override
-    public long getNextLoadPositionUs() {
-      return mediaPeriod.getNextLoadPositionUs();
+    public Window getWindow(int windowIndex, Window window, boolean setIds,
+        long defaultPositionProjectionUs) {
+      // Dynamic window to indicate pending timeline updates.
+      return window.set(
+          /* id= */ null,
+          /* presentationStartTimeMs= */ C.TIME_UNSET,
+          /* windowStartTimeMs= */ C.TIME_UNSET,
+          /* isSeekable= */ false,
+          /* isDynamic= */ true,
+          /* defaultPositionUs= */ 0,
+          /* durationUs= */ C.TIME_UNSET,
+          /* firstPeriodIndex= */ 0,
+          /* lastPeriodIndex= */ 0,
+          /* positionInFirstPeriodUs= */ 0);
     }
 
     @Override
-    public boolean continueLoading(long positionUs) {
-      return mediaPeriod != null && mediaPeriod.continueLoading(positionUs);
+    public int getPeriodCount() {
+      return 1;
     }
 
     @Override
-    public void onContinueLoadingRequested(MediaPeriod source) {
-      callback.onContinueLoadingRequested(this);
+    public Period getPeriod(int periodIndex, Period period, boolean setIds) {
+      return period.set(
+          /* id= */ null,
+          /* uid= */ null,
+          /* windowIndex= */ 0,
+          /* durationUs = */ C.TIME_UNSET,
+          /* positionInWindowUs= */ C.TIME_UNSET);
     }
 
     @Override
-    public void onPrepared(MediaPeriod mediaPeriod) {
-      callback.onPrepared(this);
+    public int getIndexOfPeriod(Object uid) {
+      return uid == null ? 0 : C.INDEX_UNSET;
     }
   }
-
 }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
index 1228061cde..c771188e3b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaPeriod.java
@@ -17,9 +17,11 @@
 
 import android.net.Uri;
 import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.extractor.DefaultExtractorInput;
 import com.google.android.exoplayer2.extractor.Extractor;
@@ -27,7 +29,9 @@
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.PositionHolder;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.SeekMap.SeekPoints;
 import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleQueue.UpstreamFormatChangedListener;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
@@ -74,11 +78,10 @@
   private final Uri uri;
   private final DataSource dataSource;
   private final int minLoadableRetryCount;
-  private final Handler eventHandler;
-  private final ExtractorMediaSource.EventListener eventListener;
+  private final EventDispatcher eventDispatcher;
   private final Listener listener;
   private final Allocator allocator;
-  private final String customCacheKey;
+  @Nullable private final String customCacheKey;
   private final long continueLoadingCheckIntervalBytes;
   private final Loader loader;
   private final ExtractorHolder extractorHolder;
@@ -102,11 +105,13 @@
   private long durationUs;
   private boolean[] trackEnabledStates;
   private boolean[] trackIsAudioVideoFlags;
+  private boolean[] trackFormatNotificationSent;
   private boolean haveAudioVideoTracks;
   private long length;
 
   private long lastSeekPositionUs;
   private long pendingResetPositionUs;
+  private boolean pendingDeferredRetry;
 
   private int extractedSamplesCountAtStartOfLoad;
   private boolean loadingFinished;
@@ -117,8 +122,7 @@
    * @param dataSource The data source to read the media.
    * @param extractors The extractors to use to read the data source.
    * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
-   * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @param eventDispatcher A dispatcher to notify of events.
    * @param listener A listener to notify when information about the period changes.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
    * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
@@ -126,15 +130,20 @@
    * @param continueLoadingCheckIntervalBytes The number of bytes that should be loaded between each
    *     invocation of {@link Callback#onContinueLoadingRequested(SequenceableLoader)}.
    */
-  public ExtractorMediaPeriod(Uri uri, DataSource dataSource, Extractor[] extractors,
-      int minLoadableRetryCount, Handler eventHandler,
-      ExtractorMediaSource.EventListener eventListener, Listener listener,
-      Allocator allocator, String customCacheKey, int continueLoadingCheckIntervalBytes) {
+  public ExtractorMediaPeriod(
+      Uri uri,
+      DataSource dataSource,
+      Extractor[] extractors,
+      int minLoadableRetryCount,
+      EventDispatcher eventDispatcher,
+      Listener listener,
+      Allocator allocator,
+      @Nullable String customCacheKey,
+      int continueLoadingCheckIntervalBytes) {
     this.uri = uri;
     this.dataSource = dataSource;
     this.minLoadableRetryCount = minLoadableRetryCount;
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
+    this.eventDispatcher = eventDispatcher;
     this.listener = listener;
     this.allocator = allocator;
     this.customCacheKey = customCacheKey;
@@ -161,6 +170,7 @@ public void run() {
     sampleQueues = new SampleQueue[0];
     pendingResetPositionUs = C.TIME_UNSET;
     length = C.LENGTH_UNSET;
+    durationUs = C.TIME_UNSET;
     // Assume on-demand for MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, until prepared.
     actualMinLoadableRetryCount =
         minLoadableRetryCount == ExtractorMediaSource.MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA
@@ -169,24 +179,24 @@ public void run() {
   }
 
   public void release() {
-    boolean releasedSynchronously = loader.release(this);
-    if (prepared && !releasedSynchronously) {
+    if (prepared) {
       // Discard as much as we can synchronously. We only do this if we're prepared, since otherwise
       // sampleQueues may still be being modified by the loading thread.
       for (SampleQueue sampleQueue : sampleQueues) {
         sampleQueue.discardToEnd();
       }
     }
+    loader.release(this);
     handler.removeCallbacksAndMessages(null);
     released = true;
   }
 
   @Override
   public void onLoaderReleased() {
-    extractorHolder.release();
     for (SampleQueue sampleQueue : sampleQueues) {
       sampleQueue.reset();
     }
+    extractorHolder.release();
   }
 
   @Override
@@ -250,6 +260,7 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
       }
     }
     if (enabledTrackCount == 0) {
+      pendingDeferredRetry = false;
       notifyDiscontinuity = false;
       if (loader.isLoading()) {
         // Discard as much as we can synchronously.
@@ -276,16 +287,21 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
   }
 
   @Override
-  public void discardBuffer(long positionUs) {
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
     int trackCount = sampleQueues.length;
     for (int i = 0; i < trackCount; i++) {
-      sampleQueues[i].discardTo(positionUs, false, trackEnabledStates[i]);
+      sampleQueues[i].discardTo(positionUs, toKeyframe, trackEnabledStates[i]);
     }
   }
 
+  @Override
+  public void reevaluateBuffer(long positionUs) {
+    // Do nothing.
+  }
+
   @Override
   public boolean continueLoading(long playbackPositionUs) {
-    if (loadingFinished || (prepared && enabledTrackCount == 0)) {
+    if (loadingFinished || pendingDeferredRetry || (prepared && enabledTrackCount == 0)) {
       return false;
     }
     boolean continuedLoading = loadCondition.open();
@@ -303,7 +319,8 @@ public long getNextLoadPositionUs() {
 
   @Override
   public long readDiscontinuity() {
-    if (notifyDiscontinuity) {
+    if (notifyDiscontinuity
+        && (loadingFinished || getExtractedSamplesCount() > extractedSamplesCountAtStartOfLoad)) {
       notifyDiscontinuity = false;
       return lastSeekPositionUs;
     }
@@ -346,6 +363,7 @@ public long seekToUs(long positionUs) {
       return positionUs;
     }
     // We were unable to seek within the buffer, so need to reset.
+    pendingDeferredRetry = false;
     pendingResetPositionUs = positionUs;
     loadingFinished = false;
     if (loader.isLoading()) {
@@ -358,6 +376,17 @@ public long seekToUs(long positionUs) {
     return positionUs;
   }
 
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    if (!seekMap.isSeekable()) {
+      // Treat all seeks into non-seekable media as being to t=0.
+      return 0;
+    }
+    SeekPoints seekPoints = seekMap.getSeekPoints(positionUs);
+    return Util.resolveSeekPositionUs(
+        positionUs, seekParameters, seekPoints.first.timeUs, seekPoints.second.timeUs);
+  }
+
   // SampleStream methods.
 
   /* package */ boolean isReady(int track) {
@@ -373,8 +402,15 @@ public long seekToUs(long positionUs) {
     if (suppressRead()) {
       return C.RESULT_NOTHING_READ;
     }
-    return sampleQueues[track].read(formatHolder, buffer, formatRequired, loadingFinished,
-        lastSeekPositionUs);
+    int result =
+        sampleQueues[track].read(
+            formatHolder, buffer, formatRequired, loadingFinished, lastSeekPositionUs);
+    if (result == C.RESULT_BUFFER_READ) {
+      maybeNotifyTrackFormat(track);
+    } else if (result == C.RESULT_NOTHING_READ) {
+      maybeStartDeferredRetry(track);
+    }
+    return result;
   }
 
   /* package */ int skipData(int track, long positionUs) {
@@ -382,12 +418,51 @@ public long seekToUs(long positionUs) {
       return 0;
     }
     SampleQueue sampleQueue = sampleQueues[track];
+    int skipCount;
     if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
-      return sampleQueue.advanceToEnd();
+      skipCount = sampleQueue.advanceToEnd();
+    } else {
+      skipCount = sampleQueue.advanceTo(positionUs, true, true);
+      if (skipCount == SampleQueue.ADVANCE_FAILED) {
+        skipCount = 0;
+      }
+    }
+    if (skipCount > 0) {
+      maybeNotifyTrackFormat(track);
     } else {
-      int skipCount = sampleQueue.advanceTo(positionUs, true, true);
-      return skipCount == SampleQueue.ADVANCE_FAILED ? 0 : skipCount;
+      maybeStartDeferredRetry(track);
     }
+    return skipCount;
+  }
+
+  private void maybeNotifyTrackFormat(int track) {
+    if (!trackFormatNotificationSent[track]) {
+      Format trackFormat = tracks.get(track).getFormat(0);
+      eventDispatcher.downstreamFormatChanged(
+          MimeTypes.getTrackType(trackFormat.sampleMimeType),
+          trackFormat,
+          C.SELECTION_REASON_UNKNOWN,
+          /* trackSelectionData= */ null,
+          lastSeekPositionUs);
+      trackFormatNotificationSent[track] = true;
+    }
+  }
+
+  private void maybeStartDeferredRetry(int track) {
+    if (!pendingDeferredRetry
+        || !trackIsAudioVideoFlags[track]
+        || sampleQueues[track].hasNextSample()) {
+      return;
+    }
+    pendingResetPositionUs = 0;
+    pendingDeferredRetry = false;
+    notifyDiscontinuity = true;
+    lastSeekPositionUs = 0;
+    extractedSamplesCountAtStartOfLoad = 0;
+    for (SampleQueue sampleQueue : sampleQueues) {
+      sampleQueue.reset();
+    }
+    callback.onContinueLoadingRequested(this);
   }
 
   private boolean suppressRead() {
@@ -399,45 +474,82 @@ private boolean suppressRead() {
   @Override
   public void onLoadCompleted(ExtractingLoadable loadable, long elapsedRealtimeMs,
       long loadDurationMs) {
-    copyLengthFromLoader(loadable);
-    loadingFinished = true;
     if (durationUs == C.TIME_UNSET) {
       long largestQueuedTimestampUs = getLargestQueuedTimestampUs();
       durationUs = largestQueuedTimestampUs == Long.MIN_VALUE ? 0
           : largestQueuedTimestampUs + DEFAULT_LAST_SAMPLE_DURATION_US;
       listener.onSourceInfoRefreshed(durationUs, seekMap.isSeekable());
     }
+    eventDispatcher.loadCompleted(
+        loadable.dataSpec,
+        C.DATA_TYPE_MEDIA,
+        C.TRACK_TYPE_UNKNOWN,
+        /* trackFormat= */ null,
+        C.SELECTION_REASON_UNKNOWN,
+        /* trackSelectionData= */ null,
+        /* mediaStartTimeUs= */ loadable.seekTimeUs,
+        durationUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        loadable.bytesLoaded);
+    copyLengthFromLoader(loadable);
+    loadingFinished = true;
     callback.onContinueLoadingRequested(this);
   }
 
   @Override
   public void onLoadCanceled(ExtractingLoadable loadable, long elapsedRealtimeMs,
       long loadDurationMs, boolean released) {
-    if (released) {
-      return;
-    }
-    copyLengthFromLoader(loadable);
-    for (SampleQueue sampleQueue : sampleQueues) {
-      sampleQueue.reset();
-    }
-    if (enabledTrackCount > 0) {
-      callback.onContinueLoadingRequested(this);
+    eventDispatcher.loadCanceled(
+        loadable.dataSpec,
+        C.DATA_TYPE_MEDIA,
+        C.TRACK_TYPE_UNKNOWN,
+        /* trackFormat= */ null,
+        C.SELECTION_REASON_UNKNOWN,
+        /* trackSelectionData= */ null,
+        /* mediaStartTimeUs= */ loadable.seekTimeUs,
+        durationUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        loadable.bytesLoaded);
+    if (!released) {
+      copyLengthFromLoader(loadable);
+      for (SampleQueue sampleQueue : sampleQueues) {
+        sampleQueue.reset();
+      }
+      if (enabledTrackCount > 0) {
+        callback.onContinueLoadingRequested(this);
+      }
     }
   }
 
   @Override
   public int onLoadError(ExtractingLoadable loadable, long elapsedRealtimeMs,
       long loadDurationMs, IOException error) {
+    boolean isErrorFatal = isLoadableExceptionFatal(error);
+    eventDispatcher.loadError(
+        loadable.dataSpec,
+        C.DATA_TYPE_MEDIA,
+        C.TRACK_TYPE_UNKNOWN,
+        /* trackFormat= */ null,
+        C.SELECTION_REASON_UNKNOWN,
+        /* trackSelectionData= */ null,
+        /* mediaStartTimeUs= */ loadable.seekTimeUs,
+        durationUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        loadable.bytesLoaded,
+        error,
+        /* wasCanceled= */ isErrorFatal);
     copyLengthFromLoader(loadable);
-    notifyLoadError(error);
-    if (isLoadableExceptionFatal(error)) {
+    if (isErrorFatal) {
       return Loader.DONT_RETRY_FATAL;
     }
     int extractedSamplesCount = getExtractedSamplesCount();
     boolean madeProgress = extractedSamplesCount > extractedSamplesCountAtStartOfLoad;
-    configureRetry(loadable); // May reset the sample queues.
-    extractedSamplesCountAtStartOfLoad = getExtractedSamplesCount();
-    return madeProgress ? Loader.RETRY_RESET_ERROR_COUNT : Loader.RETRY;
+    return configureRetry(loadable, extractedSamplesCount)
+        ? (madeProgress ? Loader.RETRY_RESET_ERROR_COUNT : Loader.RETRY)
+        : Loader.DONT_RETRY;
   }
 
   // ExtractorOutput implementation. Called by the loading thread.
@@ -494,6 +606,7 @@ private void maybeFinishPrepare() {
     TrackGroup[] trackArray = new TrackGroup[trackCount];
     trackIsAudioVideoFlags = new boolean[trackCount];
     trackEnabledStates = new boolean[trackCount];
+    trackFormatNotificationSent = new boolean[trackCount];
     durationUs = seekMap.getDurationUs();
     for (int i = 0; i < trackCount; i++) {
       Format trackFormat = sampleQueues[i].getUpstreamFormat();
@@ -529,30 +642,65 @@ private void startLoading() {
         pendingResetPositionUs = C.TIME_UNSET;
         return;
       }
-      loadable.setLoadPosition(seekMap.getPosition(pendingResetPositionUs), pendingResetPositionUs);
+      loadable.setLoadPosition(
+          seekMap.getSeekPoints(pendingResetPositionUs).first.position, pendingResetPositionUs);
       pendingResetPositionUs = C.TIME_UNSET;
     }
     extractedSamplesCountAtStartOfLoad = getExtractedSamplesCount();
-    loader.startLoading(loadable, this, actualMinLoadableRetryCount);
+    long elapsedRealtimeMs = loader.startLoading(loadable, this, actualMinLoadableRetryCount);
+    eventDispatcher.loadStarted(
+        loadable.dataSpec,
+        C.DATA_TYPE_MEDIA,
+        C.TRACK_TYPE_UNKNOWN,
+        /* trackFormat= */ null,
+        C.SELECTION_REASON_UNKNOWN,
+        /* trackSelectionData= */ null,
+        /* mediaStartTimeUs= */ loadable.seekTimeUs,
+        durationUs,
+        elapsedRealtimeMs);
   }
 
-  private void configureRetry(ExtractingLoadable loadable) {
+  /**
+   * Called to configure a retry when a load error occurs.
+   *
+   * @param loadable The current loadable for which the error was encountered.
+   * @param currentExtractedSampleCount The current number of samples that have been extracted into
+   *     the sample queues.
+   * @return Whether the loader should retry with the current loadable. False indicates a deferred
+   *     retry.
+   */
+  private boolean configureRetry(ExtractingLoadable loadable, int currentExtractedSampleCount) {
     if (length != C.LENGTH_UNSET
         || (seekMap != null && seekMap.getDurationUs() != C.TIME_UNSET)) {
       // We're playing an on-demand stream. Resume the current loadable, which will
       // request data starting from the point it left off.
+      extractedSamplesCountAtStartOfLoad = currentExtractedSampleCount;
+      return true;
+    } else if (prepared && !suppressRead()) {
+      // We're playing a stream of unknown length and duration. Assume it's live, and therefore that
+      // the data at the uri is a continuously shifting window of the latest available media. For
+      // this case there's no way to continue loading from where a previous load finished, so it's
+      // necessary to load from the start whenever commencing a new load. Deferring the retry until
+      // we run out of buffered data makes for a much better user experience. See:
+      // https://github.com/google/ExoPlayer/issues/1606.
+      // Note that the suppressRead() check means only a single deferred retry can occur without
+      // progress being made. Any subsequent failures without progress will go through the else
+      // block below.
+      pendingDeferredRetry = true;
+      return false;
     } else {
-      // We're playing a stream of unknown length and duration. Assume it's live, and
-      // therefore that the data at the uri is a continuously shifting window of the latest
-      // available media. For this case there's no way to continue loading from where a
-      // previous load finished, so it's necessary to load from the start whenever commencing
-      // a new load.
-      lastSeekPositionUs = 0;
+      // This is the same case as above, except in this case there's no value in deferring the retry
+      // because there's no buffered data to be read. This case also covers an on-demand stream with
+      // unknown length that has yet to be prepared. This case cannot be disambiguated from the live
+      // stream case, so we have no option but to load from the start.
       notifyDiscontinuity = prepared;
+      lastSeekPositionUs = 0;
+      extractedSamplesCountAtStartOfLoad = 0;
       for (SampleQueue sampleQueue : sampleQueues) {
         sampleQueue.reset();
       }
       loadable.setLoadPosition(0, 0);
+      return true;
     }
   }
 
@@ -576,7 +724,6 @@ private boolean seekInsideBufferUs(long positionUs) {
       if (!seekInsideQueue && (trackIsAudioVideoFlags[i] || !haveAudioVideoTracks)) {
         return false;
       }
-      sampleQueue.discardToRead();
     }
     return true;
   }
@@ -602,21 +749,10 @@ private boolean isPendingReset() {
     return pendingResetPositionUs != C.TIME_UNSET;
   }
 
-  private boolean isLoadableExceptionFatal(IOException e) {
+  private static boolean isLoadableExceptionFatal(IOException e) {
     return e instanceof UnrecognizedInputFormatException;
   }
 
-  private void notifyLoadError(final IOException error) {
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable()  {
-        @Override
-        public void run() {
-          eventListener.onLoadError(error);
-        }
-      });
-    }
-  }
-
   private final class SampleStreamImpl implements SampleStream {
 
     private final int track;
@@ -663,7 +799,9 @@ public int skipData(long positionUs) {
 
     private boolean pendingExtractorSeek;
     private long seekTimeUs;
+    private DataSpec dataSpec;
     private long length;
+    private long bytesLoaded;
 
     public ExtractingLoadable(Uri uri, DataSource dataSource, ExtractorHolder extractorHolder,
         ConditionVariable loadCondition) {
@@ -699,7 +837,8 @@ public void load() throws IOException, InterruptedException {
         ExtractorInput input = null;
         try {
           long position = positionHolder.position;
-          length = dataSource.open(new DataSpec(uri, position, C.LENGTH_UNSET, customCacheKey));
+          dataSpec = new DataSpec(uri, position, C.LENGTH_UNSET, customCacheKey);
+          length = dataSource.open(dataSpec);
           if (length != C.LENGTH_UNSET) {
             length += position;
           }
@@ -723,6 +862,7 @@ public void load() throws IOException, InterruptedException {
             result = Extractor.RESULT_CONTINUE;
           } else if (input != null) {
             positionHolder.position = input.getPosition();
+            bytesLoaded = positionHolder.position - dataSpec.absoluteStreamPosition;
           }
           Util.closeQuietly(dataSource);
         }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
index 1b3f6cb95c..14453653af 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ExtractorMediaSource.java
@@ -17,14 +17,19 @@
 
 import android.net.Uri;
 import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Player;
 import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorsFactory;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 
@@ -40,10 +45,12 @@
  * Note that the built-in extractors for AAC, MPEG PS/TS and FLV streams do not support seeking.
  */
 public final class ExtractorMediaSource implements MediaSource, ExtractorMediaPeriod.Listener {
-
   /**
    * Listener of {@link ExtractorMediaSource} events.
+   *
+   * @deprecated Use {@link MediaSourceEventListener}.
    */
+  @Deprecated
   public interface EventListener {
 
     /**
@@ -89,8 +96,7 @@
   private final DataSource.Factory dataSourceFactory;
   private final ExtractorsFactory extractorsFactory;
   private final int minLoadableRetryCount;
-  private final Handler eventHandler;
-  private final EventListener eventListener;
+  private final EventDispatcher eventDispatcher;
   private final String customCacheKey;
   private final int continueLoadingCheckIntervalBytes;
 
@@ -98,6 +104,127 @@
   private long timelineDurationUs;
   private boolean timelineIsSeekable;
 
+  /** Factory for {@link ExtractorMediaSource}s. */
+  public static final class Factory implements AdsMediaSource.MediaSourceFactory {
+
+    private final DataSource.Factory dataSourceFactory;
+
+    private @Nullable ExtractorsFactory extractorsFactory;
+    private @Nullable String customCacheKey;
+    private int minLoadableRetryCount;
+    private int continueLoadingCheckIntervalBytes;
+    private boolean isCreateCalled;
+
+    /**
+     * Creates a new factory for {@link ExtractorMediaSource}s.
+     *
+     * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
+     */
+    public Factory(DataSource.Factory dataSourceFactory) {
+      this.dataSourceFactory = dataSourceFactory;
+      minLoadableRetryCount = MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA;
+      continueLoadingCheckIntervalBytes = DEFAULT_LOADING_CHECK_INTERVAL_BYTES;
+    }
+
+    /**
+     * Sets the factory for {@link Extractor}s to process the media stream. The default value is an
+     * instance of {@link DefaultExtractorsFactory}.
+     *
+     * @param extractorsFactory A factory for {@link Extractor}s to process the media stream. If the
+     *     possible formats are known, pass a factory that instantiates extractors for those
+     *     formats.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setExtractorsFactory(ExtractorsFactory extractorsFactory) {
+      Assertions.checkState(!isCreateCalled);
+      this.extractorsFactory = extractorsFactory;
+      return this;
+    }
+
+    /**
+     * Sets the custom key that uniquely identifies the original stream. Used for cache indexing.
+     * The default value is {@code null}.
+     *
+     * @param customCacheKey A custom key that uniquely identifies the original stream. Used for
+     *     cache indexing.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setCustomCacheKey(String customCacheKey) {
+      Assertions.checkState(!isCreateCalled);
+      this.customCacheKey = customCacheKey;
+      return this;
+    }
+
+    /**
+     * Sets the minimum number of times to retry if a loading error occurs. The default value is
+     * {@link #MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA}.
+     *
+     * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
+      Assertions.checkState(!isCreateCalled);
+      this.minLoadableRetryCount = minLoadableRetryCount;
+      return this;
+    }
+
+    /**
+     * Sets the number of bytes that should be loaded between each invocation of {@link
+     * MediaPeriod.Callback#onContinueLoadingRequested(SequenceableLoader)}. The default value is
+     * {@link #DEFAULT_LOADING_CHECK_INTERVAL_BYTES}.
+     *
+     * @param continueLoadingCheckIntervalBytes The number of bytes that should be loaded between
+     *     each invocation of {@link
+     *     MediaPeriod.Callback#onContinueLoadingRequested(SequenceableLoader)}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setContinueLoadingCheckIntervalBytes(int continueLoadingCheckIntervalBytes) {
+      Assertions.checkState(!isCreateCalled);
+      this.continueLoadingCheckIntervalBytes = continueLoadingCheckIntervalBytes;
+      return this;
+    }
+
+    /**
+     * Returns a new {@link ExtractorMediaSource} using the current parameters. Media source events
+     * will not be delivered.
+     *
+     * @param uri The {@link Uri}.
+     * @return The new {@link ExtractorMediaSource}.
+     */
+    public ExtractorMediaSource createMediaSource(Uri uri) {
+      return createMediaSource(uri, null, null);
+    }
+
+    /**
+     * Returns a new {@link ExtractorMediaSource} using the current parameters.
+     *
+     * @param uri The {@link Uri}.
+     * @param eventHandler A handler for events.
+     * @param eventListener A listener of events.
+     * @return The new {@link ExtractorMediaSource}.
+     */
+    @Override
+    public ExtractorMediaSource createMediaSource(
+        Uri uri, @Nullable Handler eventHandler, @Nullable MediaSourceEventListener eventListener) {
+      isCreateCalled = true;
+      if (extractorsFactory == null) {
+        extractorsFactory = new DefaultExtractorsFactory();
+      }
+      return new ExtractorMediaSource(uri, dataSourceFactory, extractorsFactory,
+          minLoadableRetryCount, eventHandler, eventListener, customCacheKey,
+          continueLoadingCheckIntervalBytes);
+    }
+
+    @Override
+    public int[] getSupportedTypes() {
+      return new int[] {C.TYPE_OTHER};
+    }
+  }
+
   /**
    * @param uri The {@link Uri} of the media stream.
    * @param dataSourceFactory A factory for {@link DataSource}s to read the media.
@@ -106,9 +233,15 @@
    *     Otherwise, pass a {@link DefaultExtractorsFactory} to use default extractors.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
-      ExtractorsFactory extractorsFactory, Handler eventHandler, EventListener eventListener) {
+  @Deprecated
+  public ExtractorMediaSource(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      ExtractorsFactory extractorsFactory,
+      Handler eventHandler,
+      EventListener eventListener) {
     this(uri, dataSourceFactory, extractorsFactory, eventHandler, eventListener, null);
   }
 
@@ -122,9 +255,15 @@ public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    * @param customCacheKey A custom key that uniquely identifies the original stream. Used for cache
    *     indexing. May be null.
+   * @deprecated Use {@link Factory} instead.
    */
-  public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
-      ExtractorsFactory extractorsFactory, Handler eventHandler, EventListener eventListener,
+  @Deprecated
+  public ExtractorMediaSource(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      ExtractorsFactory extractorsFactory,
+      Handler eventHandler,
+      EventListener eventListener,
       String customCacheKey) {
     this(uri, dataSourceFactory, extractorsFactory, MIN_RETRY_COUNT_DEFAULT_FOR_MEDIA, eventHandler,
         eventListener, customCacheKey, DEFAULT_LOADING_CHECK_INTERVAL_BYTES);
@@ -143,16 +282,43 @@ public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
    *     indexing. May be null.
    * @param continueLoadingCheckIntervalBytes The number of bytes that should be loaded between each
    *     invocation of {@link MediaPeriod.Callback#onContinueLoadingRequested(SequenceableLoader)}.
+   * @deprecated Use {@link Factory} instead.
    */
-  public ExtractorMediaSource(Uri uri, DataSource.Factory dataSourceFactory,
-      ExtractorsFactory extractorsFactory, int minLoadableRetryCount, Handler eventHandler,
-      EventListener eventListener, String customCacheKey, int continueLoadingCheckIntervalBytes) {
+  @Deprecated
+  public ExtractorMediaSource(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      ExtractorsFactory extractorsFactory,
+      int minLoadableRetryCount,
+      Handler eventHandler,
+      EventListener eventListener,
+      String customCacheKey,
+      int continueLoadingCheckIntervalBytes) {
+    this(
+        uri,
+        dataSourceFactory,
+        extractorsFactory,
+        minLoadableRetryCount,
+        eventHandler,
+        eventListener == null ? null : new EventListenerWrapper(eventListener),
+        customCacheKey,
+        continueLoadingCheckIntervalBytes);
+  }
+
+  private ExtractorMediaSource(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      ExtractorsFactory extractorsFactory,
+      int minLoadableRetryCount,
+      @Nullable Handler eventHandler,
+      @Nullable MediaSourceEventListener eventListener,
+      @Nullable String customCacheKey,
+      int continueLoadingCheckIntervalBytes) {
     this.uri = uri;
     this.dataSourceFactory = dataSourceFactory;
     this.extractorsFactory = extractorsFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
+    this.eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     this.customCacheKey = customCacheKey;
     this.continueLoadingCheckIntervalBytes = continueLoadingCheckIntervalBytes;
   }
@@ -171,9 +337,16 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     Assertions.checkArgument(id.periodIndex == 0);
-    return new ExtractorMediaPeriod(uri, dataSourceFactory.createDataSource(),
-        extractorsFactory.createExtractors(), minLoadableRetryCount, eventHandler, eventListener,
-        this, allocator, customCacheKey, continueLoadingCheckIntervalBytes);
+    return new ExtractorMediaPeriod(
+        uri,
+        dataSourceFactory.createDataSource(),
+        extractorsFactory.createExtractors(),
+        minLoadableRetryCount,
+        eventDispatcher,
+        this,
+        allocator,
+        customCacheKey,
+        continueLoadingCheckIntervalBytes);
   }
 
   @Override
@@ -204,8 +377,99 @@ public void onSourceInfoRefreshed(long durationUs, boolean isSeekable) {
   private void notifySourceInfoRefreshed(long durationUs, boolean isSeekable) {
     timelineDurationUs = durationUs;
     timelineIsSeekable = isSeekable;
-    sourceListener.onSourceInfoRefreshed(
-        this, new SinglePeriodTimeline(timelineDurationUs, timelineIsSeekable), null);
+    // TODO: Make timeline dynamic until its duration is known. This is non-trivial. See b/69703223.
+    sourceListener.onSourceInfoRefreshed(this,
+        new SinglePeriodTimeline(timelineDurationUs, timelineIsSeekable, false), null);
   }
 
+  /**
+   * Wraps a deprecated {@link EventListener}, invoking its callback from the equivalent callback in
+   * {@link MediaSourceEventListener}.
+   */
+  private static final class EventListenerWrapper implements MediaSourceEventListener {
+    private final EventListener eventListener;
+
+    public EventListenerWrapper(EventListener eventListener) {
+      this.eventListener = Assertions.checkNotNull(eventListener);
+    }
+
+    @Override
+    public void onLoadStarted(
+        DataSpec dataSpec,
+        int dataType,
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaStartTimeMs,
+        long mediaEndTimeMs,
+        long elapsedRealtimeMs) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onLoadCompleted(
+        DataSpec dataSpec,
+        int dataType,
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaStartTimeMs,
+        long mediaEndTimeMs,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onLoadCanceled(
+        DataSpec dataSpec,
+        int dataType,
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaStartTimeMs,
+        long mediaEndTimeMs,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onLoadError(
+        DataSpec dataSpec,
+        int dataType,
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaStartTimeMs,
+        long mediaEndTimeMs,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded,
+        IOException error,
+        boolean wasCanceled) {
+      eventListener.onLoadError(error);
+    }
+
+    @Override
+    public void onUpstreamDiscarded(int trackType, long mediaStartTimeMs, long mediaEndTimeMs) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onDownstreamFormatChanged(
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaTimeMs) {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
index 984820cc6a..e2ef4eb5fa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/LoopingMediaSource.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
@@ -22,20 +23,20 @@
 import com.google.android.exoplayer2.source.ShuffleOrder.UnshuffledShuffleOrder;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
-import java.io.IOException;
 
 /**
  * Loops a {@link MediaSource} a specified number of times.
- * <p>
- * Note: To loop a {@link MediaSource} indefinitely, it is usually better to use
- * {@link ExoPlayer#setRepeatMode(int)}.
+ *
+ * <p>Note: To loop a {@link MediaSource} indefinitely, it is usually better to use {@link
+ * ExoPlayer#setRepeatMode(int)}.
  */
-public final class LoopingMediaSource implements MediaSource {
+public final class LoopingMediaSource extends CompositeMediaSource<Void> {
 
   private final MediaSource childSource;
   private final int loopCount;
 
   private int childPeriodCount;
+  private Listener listener;
 
   /**
    * Loops the provided source indefinitely. Note that it is usually better to use
@@ -61,20 +62,9 @@ public LoopingMediaSource(MediaSource childSource, int loopCount) {
 
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, final Listener listener) {
-    childSource.prepareSource(player, false, new Listener() {
-      @Override
-      public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
-        childPeriodCount = timeline.getPeriodCount();
-        Timeline loopingTimeline = loopCount != Integer.MAX_VALUE
-            ? new LoopingTimeline(timeline, loopCount) : new InfinitelyLoopingTimeline(timeline);
-        listener.onSourceInfoRefreshed(LoopingMediaSource.this, loopingTimeline, manifest);
-      }
-    });
-  }
-
-  @Override
-  public void maybeThrowSourceInfoRefreshError() throws IOException {
-    childSource.maybeThrowSourceInfoRefreshError();
+    super.prepareSource(player, isTopLevelSource, listener);
+    this.listener = listener;
+    prepareChildSource(/* id= */ null, childSource);
   }
 
   @Override
@@ -92,7 +82,20 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSource() {
-    childSource.releaseSource();
+    super.releaseSource();
+    listener = null;
+    childPeriodCount = 0;
+  }
+
+  @Override
+  protected void onChildSourceInfoRefreshed(
+      Void id, MediaSource mediaSource, Timeline timeline, @Nullable Object manifest) {
+    childPeriodCount = timeline.getPeriodCount();
+    Timeline loopingTimeline =
+        loopCount != Integer.MAX_VALUE
+            ? new LoopingTimeline(timeline, loopCount)
+            : new InfinitelyLoopingTimeline(timeline);
+    listener.onSourceInfoRefreshed(this, loopingTimeline, manifest);
   }
 
   private static final class LoopingTimeline extends AbstractConcatenatedTimeline {
@@ -103,7 +106,7 @@ public void releaseSource() {
     private final int loopCount;
 
     public LoopingTimeline(Timeline childTimeline, int loopCount) {
-      super(new UnshuffledShuffleOrder(loopCount));
+      super(/* isAtomic= */ false, new UnshuffledShuffleOrder(loopCount));
       this.childTimeline = childTimeline;
       childPeriodCount = childTimeline.getPeriodCount();
       childWindowCount = childTimeline.getWindowCount();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
index c297229d78..a5b2314d78 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java
@@ -17,6 +17,7 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import java.io.IOException;
@@ -35,27 +36,25 @@
 
     /**
      * Called when preparation completes.
-     * <p>
-     * Called on the playback thread. After invoking this method, the {@link MediaPeriod} can expect
-     * for {@link #selectTracks(TrackSelection[], boolean[], SampleStream[], boolean[], long)} to be
-     * called with the initial track selection.
+     *
+     * <p>Called on the playback thread. After invoking this method, the {@link MediaPeriod} can
+     * expect for {@link #selectTracks(TrackSelection[], boolean[], SampleStream[], boolean[],
+     * long)} to be called with the initial track selection.
      *
      * @param mediaPeriod The prepared {@link MediaPeriod}.
      */
     void onPrepared(MediaPeriod mediaPeriod);
-
   }
 
   /**
    * Prepares this media period asynchronously.
-   * <p>
-   * {@code callback.onPrepared} is called when preparation completes. If preparation fails,
+   *
+   * <p>{@code callback.onPrepared} is called when preparation completes. If preparation fails,
    * {@link #maybeThrowPrepareError()} will throw an {@link IOException}.
-   * <p>
-   * If preparation succeeds and results in a source timeline change (e.g. the period duration
-   * becoming known),
-   * {@link MediaSource.Listener#onSourceInfoRefreshed(MediaSource, Timeline, Object)} will be
-   * called before {@code callback.onPrepared}.
+   *
+   * <p>If preparation succeeds and results in a source timeline change (e.g. the period duration
+   * becoming known), {@link MediaSource.Listener#onSourceInfoRefreshed(MediaSource, Timeline,
+   * Object)} will be called before {@code callback.onPrepared}.
    *
    * @param callback Callback to receive updates from this period, including being notified when
    *     preparation completes.
@@ -66,8 +65,8 @@
   /**
    * Throws an error that's preventing the period from becoming prepared. Does nothing if no such
    * error exists.
-   * <p>
-   * This method should only be called before the period has completed preparation.
+   *
+   * <p>This method should only be called before the period has completed preparation.
    *
    * @throws IOException The underlying error.
    */
@@ -75,8 +74,8 @@
 
   /**
    * Returns the {@link TrackGroup}s exposed by the period.
-   * <p>
-   * This method should only be called after the period has been prepared.
+   *
+   * <p>This method should only be called after the period has been prepared.
    *
    * @return The {@link TrackGroup}s.
    */
@@ -84,16 +83,16 @@
 
   /**
    * Performs a track selection.
-   * <p>
-   * The call receives track {@code selections} for each renderer, {@code mayRetainStreamFlags}
+   *
+   * <p>The call receives track {@code selections} for each renderer, {@code mayRetainStreamFlags}
    * indicating whether the existing {@code SampleStream} can be retained for each selection, and
    * the existing {@code stream}s themselves. The call will update {@code streams} to reflect the
    * provided selections, clearing, setting and replacing entries as required. If an existing sample
    * stream is retained but with the requirement that the consuming renderer be reset, then the
    * corresponding flag in {@code streamResetFlags} will be set to true. This flag will also be set
    * if a new sample stream is created.
-   * <p>
-   * This method should only be called after the period has been prepared.
+   *
+   * <p>This method should only be called after the period has been prepared.
    *
    * @param selections The renderer track selections.
    * @param mayRetainStreamFlags Flags indicating whether the existing sample stream can be retained
@@ -104,28 +103,34 @@
    * @param streamResetFlags Will be updated to indicate new sample streams, and sample streams that
    *     have been retained but with the requirement that the consuming renderer be reset.
    * @param positionUs The current playback position in microseconds. If playback of this period has
-    *    not yet started, the value will be the starting position.
+   *     not yet started, the value will be the starting position.
    * @return The actual position at which the tracks were enabled, in microseconds.
    */
-  long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
-      SampleStream[] streams, boolean[] streamResetFlags, long positionUs);
+  long selectTracks(
+      TrackSelection[] selections,
+      boolean[] mayRetainStreamFlags,
+      SampleStream[] streams,
+      boolean[] streamResetFlags,
+      long positionUs);
 
   /**
    * Discards buffered media up to the specified position.
-   * <p>
-   * This method should only be called after the period has been prepared.
+   *
+   * <p>This method should only be called after the period has been prepared.
    *
    * @param positionUs The position in microseconds.
+   * @param toKeyframe If true then for each track discards samples up to the keyframe before or at
+   *     the specified position, rather than any sample before or at that position.
    */
-  void discardBuffer(long positionUs);
+  void discardBuffer(long positionUs, boolean toKeyframe);
 
   /**
    * Attempts to read a discontinuity.
-   * <p>
-   * After this method has returned a value other than {@link C#TIME_UNSET}, all
-   * {@link SampleStream}s provided by the period are guaranteed to start from a key frame.
-   * <p>
-   * This method should only be called after the period has been prepared.
+   *
+   * <p>After this method has returned a value other than {@link C#TIME_UNSET}, all {@link
+   * SampleStream}s provided by the period are guaranteed to start from a key frame.
+   *
+   * <p>This method should only be called after the period has been prepared.
    *
    * @return If a discontinuity was read then the playback position in microseconds after the
    *     discontinuity. Else {@link C#TIME_UNSET}.
@@ -134,23 +139,36 @@ long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
 
   /**
    * Attempts to seek to the specified position in microseconds.
-   * <p>
-   * After this method has been called, all {@link SampleStream}s provided by the period are
+   *
+   * <p>After this method has been called, all {@link SampleStream}s provided by the period are
    * guaranteed to start from a key frame.
-   * <p>
-   * This method should only be called when at least one track is selected.
+   *
+   * <p>This method should only be called when at least one track is selected.
    *
    * @param positionUs The seek position in microseconds.
    * @return The actual position to which the period was seeked, in microseconds.
    */
   long seekToUs(long positionUs);
 
+  /**
+   * Returns the position to which a seek will be performed, given the specified seek position and
+   * {@link SeekParameters}.
+   *
+   * <p>This method should only be called after the period has been prepared.
+   *
+   * @param positionUs The seek position in microseconds.
+   * @param seekParameters Parameters that control how the seek is performed. Implementations may
+   *     apply seek parameters on a best effort basis.
+   * @return The actual position to which a seek will be performed, in microseconds.
+   */
+  long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters);
+
   // SequenceableLoader interface. Overridden to provide more specific documentation.
 
   /**
    * Returns an estimate of the position up to which data is buffered for the enabled tracks.
-   * <p>
-   * This method should only be called when at least one track is selected.
+   *
+   * <p>This method should only be called when at least one track is selected.
    *
    * @return An estimate of the absolute position in microseconds up to which data is buffered, or
    *     {@link C#TIME_END_OF_SOURCE} if the track is fully buffered.
@@ -160,19 +178,19 @@ long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
 
   /**
    * Returns the next load time, or {@link C#TIME_END_OF_SOURCE} if loading has finished.
-   * <p>
-   * This method should only be called after the period has been prepared. It may be called when no
-   * tracks are selected.
+   *
+   * <p>This method should only be called after the period has been prepared. It may be called when
+   * no tracks are selected.
    */
   @Override
   long getNextLoadPositionUs();
 
   /**
    * Attempts to continue loading.
-   * <p>
-   * This method may be called both during and after the period has been prepared.
-   * <p>
-   * A period may call {@link Callback#onContinueLoadingRequested(SequenceableLoader)} on the
+   *
+   * <p>This method may be called both during and after the period has been prepared.
+   *
+   * <p>A period may call {@link Callback#onContinueLoadingRequested(SequenceableLoader)} on the
    * {@link Callback} passed to {@link #prepare(Callback, long)} to request that this method be
    * called when the period is permitted to continue loading data. A period may do this both during
    * and after preparation.
@@ -180,10 +198,24 @@ long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
    * @param positionUs The current playback position in microseconds. If playback of this period has
    *     not yet started, the value will be the starting position in this period minus the duration
    *     of any media in previous periods still to be played.
-   * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return
-   *     a different value than prior to the call. False otherwise.
+   * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return a
+   *     different value than prior to the call. False otherwise.
    */
   @Override
   boolean continueLoading(long positionUs);
 
+  /**
+   * Re-evaluates the buffer given the playback position.
+   *
+   * <p>This method should only be called after the period has been prepared.
+   *
+   * <p>A period may choose to discard buffered media so that it can be re-buffered in a different
+   * quality.
+   *
+   * @param positionUs The current playback position in microseconds. If playback of this period has
+   *     not yet started, the value will be the starting position in this period minus the duration
+   *     of any media in previous periods still to be played.
+   */
+  @Override
+  void reevaluateBuffer(long positionUs);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
index 7288b39897..02bd0cdbc7 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSource.java
@@ -35,7 +35,8 @@
  *   player to load and read the media.</li>
  * </ul>
  * All methods are called on the player's internal playback thread, as described in the
- * {@link ExoPlayer} Javadoc.
+ * {@link ExoPlayer} Javadoc. They should not be called directly from application code. Instances
+ * should not be re-used, meaning they should be passed to {@link ExoPlayer#prepare} at most once.
  */
 public interface MediaSource {
 
@@ -62,12 +63,6 @@
    */
   final class MediaPeriodId {
 
-    /**
-     * Value for unset media period identifiers.
-     */
-    public static final MediaPeriodId UNSET =
-        new MediaPeriodId(C.INDEX_UNSET, C.INDEX_UNSET, C.INDEX_UNSET);
-
     /**
      * The timeline period index.
      */
@@ -85,13 +80,32 @@
      */
     public final int adIndexInAdGroup;
 
+    /**
+     * The sequence number of the window in the buffered sequence of windows this media period is
+     * part of. {@link C#INDEX_UNSET} if the media period id is not part of a buffered sequence of
+     * windows.
+     */
+    public final long windowSequenceNumber;
+
+    /**
+     * Creates a media period identifier for a dummy period which is not part of a buffered sequence
+     * of windows.
+     *
+     * @param periodIndex The period index.
+     */
+    public MediaPeriodId(int periodIndex) {
+      this(periodIndex, C.INDEX_UNSET);
+    }
+
     /**
      * Creates a media period identifier for the specified period in the timeline.
      *
      * @param periodIndex The timeline period index.
+     * @param windowSequenceNumber The sequence number of the window in the buffered sequence of
+     *     windows this media period is part of.
      */
-    public MediaPeriodId(int periodIndex) {
-      this(periodIndex, C.INDEX_UNSET, C.INDEX_UNSET);
+    public MediaPeriodId(int periodIndex, long windowSequenceNumber) {
+      this(periodIndex, C.INDEX_UNSET, C.INDEX_UNSET, windowSequenceNumber);
     }
 
     /**
@@ -101,19 +115,24 @@ public MediaPeriodId(int periodIndex) {
      * @param periodIndex The index of the timeline period that contains the ad group.
      * @param adGroupIndex The index of the ad group.
      * @param adIndexInAdGroup The index of the ad in the ad group.
+     * @param windowSequenceNumber The sequence number of the window in the buffered sequence of
+     *     windows this media period is part of.
      */
-    public MediaPeriodId(int periodIndex, int adGroupIndex, int adIndexInAdGroup) {
+    public MediaPeriodId(
+        int periodIndex, int adGroupIndex, int adIndexInAdGroup, long windowSequenceNumber) {
       this.periodIndex = periodIndex;
       this.adGroupIndex = adGroupIndex;
       this.adIndexInAdGroup = adIndexInAdGroup;
+      this.windowSequenceNumber = windowSequenceNumber;
     }
 
     /**
      * Returns a copy of this period identifier but with {@code newPeriodIndex} as its period index.
      */
     public MediaPeriodId copyWithPeriodIndex(int newPeriodIndex) {
-      return periodIndex == newPeriodIndex ? this
-          : new MediaPeriodId(newPeriodIndex, adGroupIndex, adIndexInAdGroup);
+      return periodIndex == newPeriodIndex
+          ? this
+          : new MediaPeriodId(newPeriodIndex, adGroupIndex, adIndexInAdGroup, windowSequenceNumber);
     }
 
     /**
@@ -133,8 +152,10 @@ public boolean equals(Object obj) {
       }
 
       MediaPeriodId periodId = (MediaPeriodId) obj;
-      return periodIndex == periodId.periodIndex && adGroupIndex == periodId.adGroupIndex
-          && adIndexInAdGroup == periodId.adIndexInAdGroup;
+      return periodIndex == periodId.periodIndex
+          && adGroupIndex == periodId.adGroupIndex
+          && adIndexInAdGroup == periodId.adIndexInAdGroup
+          && windowSequenceNumber == periodId.windowSequenceNumber;
     }
 
     @Override
@@ -143,13 +164,18 @@ public int hashCode() {
       result = 31 * result + periodIndex;
       result = 31 * result + adGroupIndex;
       result = 31 * result + adIndexInAdGroup;
+      result = 31 * result + (int) windowSequenceNumber;
       return result;
     }
 
   }
 
+  String MEDIA_SOURCE_REUSED_ERROR_MESSAGE = "MediaSource instances are not allowed to be reused.";
+
   /**
    * Starts preparation of the source.
+   * <p>
+   * Should not be called directly from application code.
    *
    * @param player The player for which this source is being prepared.
    * @param isTopLevelSource Whether this source has been passed directly to
@@ -162,6 +188,8 @@ public int hashCode() {
 
   /**
    * Throws any pending error encountered while loading or refreshing source information.
+   * <p>
+   * Should not be called directly from application code.
    */
   void maybeThrowSourceInfoRefreshError() throws IOException;
 
@@ -169,6 +197,8 @@ public int hashCode() {
    * Returns a new {@link MediaPeriod} identified by {@code periodId}. This method may be called
    * multiple times with the same period identifier without an intervening call to
    * {@link #releasePeriod(MediaPeriod)}.
+   * <p>
+   * Should not be called directly from application code.
    *
    * @param id The identifier of the period.
    * @param allocator An {@link Allocator} from which to obtain media buffer allocations.
@@ -178,6 +208,8 @@ public int hashCode() {
 
   /**
    * Releases the period.
+   * <p>
+   * Should not be called directly from application code.
    *
    * @param mediaPeriod The period to release.
    */
@@ -186,8 +218,7 @@ public int hashCode() {
   /**
    * Releases the source.
    * <p>
-   * This method should be called when the source is no longer required. It may be called in any
-   * state.
+   * Should not be called directly from application code.
    */
   void releaseSource();
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
new file mode 100644
index 0000000000..9fc2572b55
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MediaSourceEventListener.java
@@ -0,0 +1,491 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import android.os.Handler;
+import android.os.SystemClock;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.util.Assertions;
+import java.io.IOException;
+
+/** Interface for callbacks to be notified of {@link MediaSource} events. */
+public interface MediaSourceEventListener {
+  /**
+   * Called when a load begins.
+   *
+   * @param dataSpec Defines the data being loaded.
+   * @param dataType One of the {@link C} {@code DATA_TYPE_*} constants defining the type of data
+   *     being loaded.
+   * @param trackType One of the {@link C} {@code TRACK_TYPE_*} constants if the data corresponds to
+   *     media of a specific type. {@link C#TRACK_TYPE_UNKNOWN} otherwise.
+   * @param trackFormat The format of the track to which the data belongs. Null if the data does not
+   *     belong to a track.
+   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
+   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
+   * @param trackSelectionData Optional data associated with the selection of the track to which the
+   *     data belongs. Null if the data does not belong to a track.
+   * @param mediaStartTimeMs The start time of the media being loaded, or {@link C#TIME_UNSET} if
+   *     the load is not for media data.
+   * @param mediaEndTimeMs The end time of the media being loaded, or {@link C#TIME_UNSET} if the
+   *     load is not for media data or the end time is unknown.
+   * @param elapsedRealtimeMs The value of {@link SystemClock#elapsedRealtime} when the load began.
+   */
+  void onLoadStarted(
+      DataSpec dataSpec,
+      int dataType,
+      int trackType,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long mediaStartTimeMs,
+      long mediaEndTimeMs,
+      long elapsedRealtimeMs);
+
+  /**
+   * Called when a load ends.
+   *
+   * @param dataSpec Defines the data being loaded.
+   * @param dataType One of the {@link C} {@code DATA_TYPE_*} constants defining the type of data
+   *     being loaded.
+   * @param trackType One of the {@link C} {@code TRACK_TYPE_*} constants if the data corresponds to
+   *     media of a specific type. {@link C#TRACK_TYPE_UNKNOWN} otherwise.
+   * @param trackFormat The format of the track to which the data belongs. Null if the data does not
+   *     belong to a track.
+   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
+   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
+   * @param trackSelectionData Optional data associated with the selection of the track to which the
+   *     data belongs. Null if the data does not belong to a track.
+   * @param mediaStartTimeMs The start time of the media being loaded, or {@link C#TIME_UNSET} if
+   *     the load is not for media data.
+   * @param mediaEndTimeMs The end time of the media being loaded, or {@link C#TIME_UNSET} if the
+   *     load is not for media data.
+   * @param elapsedRealtimeMs The value of {@link SystemClock#elapsedRealtime} when the load ended.
+   * @param loadDurationMs The duration of the load.
+   * @param bytesLoaded The number of bytes that were loaded.
+   */
+  void onLoadCompleted(
+      DataSpec dataSpec,
+      int dataType,
+      int trackType,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long mediaStartTimeMs,
+      long mediaEndTimeMs,
+      long elapsedRealtimeMs,
+      long loadDurationMs,
+      long bytesLoaded);
+
+  /**
+   * Called when a load is canceled.
+   *
+   * @param dataSpec Defines the data being loaded.
+   * @param dataType One of the {@link C} {@code DATA_TYPE_*} constants defining the type of data
+   *     being loaded.
+   * @param trackType One of the {@link C} {@code TRACK_TYPE_*} constants if the data corresponds to
+   *     media of a specific type. {@link C#TRACK_TYPE_UNKNOWN} otherwise.
+   * @param trackFormat The format of the track to which the data belongs. Null if the data does not
+   *     belong to a track.
+   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
+   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
+   * @param trackSelectionData Optional data associated with the selection of the track to which the
+   *     data belongs. Null if the data does not belong to a track.
+   * @param mediaStartTimeMs The start time of the media being loaded, or {@link C#TIME_UNSET} if
+   *     the load is not for media data.
+   * @param mediaEndTimeMs The end time of the media being loaded, or {@link C#TIME_UNSET} if the
+   *     load is not for media data.
+   * @param elapsedRealtimeMs The value of {@link SystemClock#elapsedRealtime} when the load was
+   *     canceled.
+   * @param loadDurationMs The duration of the load up to the point at which it was canceled.
+   * @param bytesLoaded The number of bytes that were loaded prior to cancelation.
+   */
+  void onLoadCanceled(
+      DataSpec dataSpec,
+      int dataType,
+      int trackType,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long mediaStartTimeMs,
+      long mediaEndTimeMs,
+      long elapsedRealtimeMs,
+      long loadDurationMs,
+      long bytesLoaded);
+
+  /**
+   * Called when a load error occurs.
+   *
+   * <p>The error may or may not have resulted in the load being canceled, as indicated by the
+   * {@code wasCanceled} parameter. If the load was canceled, {@link #onLoadCanceled} will
+   * <em>not</em> be called in addition to this method.
+   *
+   * <p>This method being called does not indicate that playback has failed, or that it will fail.
+   * The player may be able to recover from the error and continue. Hence applications should
+   * <em>not</em> implement this method to display a user visible error or initiate an application
+   * level retry ({@link Player.EventListener#onPlayerError} is the appropriate place to implement
+   * such behavior). This method is called to provide the application with an opportunity to log the
+   * error if it wishes to do so.
+   *
+   * @param dataSpec Defines the data being loaded.
+   * @param dataType One of the {@link C} {@code DATA_TYPE_*} constants defining the type of data
+   *     being loaded.
+   * @param trackType One of the {@link C} {@code TRACK_TYPE_*} constants if the data corresponds to
+   *     media of a specific type. {@link C#TRACK_TYPE_UNKNOWN} otherwise.
+   * @param trackFormat The format of the track to which the data belongs. Null if the data does not
+   *     belong to a track.
+   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
+   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
+   * @param trackSelectionData Optional data associated with the selection of the track to which the
+   *     data belongs. Null if the data does not belong to a track.
+   * @param mediaStartTimeMs The start time of the media being loaded, or {@link C#TIME_UNSET} if
+   *     the load is not for media data.
+   * @param mediaEndTimeMs The end time of the media being loaded, or {@link C#TIME_UNSET} if the
+   *     load is not for media data.
+   * @param elapsedRealtimeMs The value of {@link SystemClock#elapsedRealtime} when the error
+   *     occurred.
+   * @param loadDurationMs The duration of the load up to the point at which the error occurred.
+   * @param bytesLoaded The number of bytes that were loaded prior to the error.
+   * @param error The load error.
+   * @param wasCanceled Whether the load was canceled as a result of the error.
+   */
+  void onLoadError(
+      DataSpec dataSpec,
+      int dataType,
+      int trackType,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long mediaStartTimeMs,
+      long mediaEndTimeMs,
+      long elapsedRealtimeMs,
+      long loadDurationMs,
+      long bytesLoaded,
+      IOException error,
+      boolean wasCanceled);
+
+  /**
+   * Called when data is removed from the back of a media buffer, typically so that it can be
+   * re-buffered in a different format.
+   *
+   * @param trackType The type of the media. One of the {@link C} {@code TRACK_TYPE_*} constants.
+   * @param mediaStartTimeMs The start time of the media being discarded.
+   * @param mediaEndTimeMs The end time of the media being discarded.
+   */
+  void onUpstreamDiscarded(int trackType, long mediaStartTimeMs, long mediaEndTimeMs);
+
+  /**
+   * Called when a downstream format change occurs (i.e. when the format of the media being read
+   * from one or more {@link SampleStream}s provided by the source changes).
+   *
+   * @param trackType The type of the media. One of the {@link C} {@code TRACK_TYPE_*} constants.
+   * @param trackFormat The format of the track to which the data belongs. Null if the data does not
+   *     belong to a track.
+   * @param trackSelectionReason One of the {@link C} {@code SELECTION_REASON_*} constants if the
+   *     data belongs to a track. {@link C#SELECTION_REASON_UNKNOWN} otherwise.
+   * @param trackSelectionData Optional data associated with the selection of the track to which the
+   *     data belongs. Null if the data does not belong to a track.
+   * @param mediaTimeMs The media time at which the change occurred.
+   */
+  void onDownstreamFormatChanged(
+      int trackType,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long mediaTimeMs);
+
+  /** Dispatches events to a {@link MediaSourceEventListener}. */
+  final class EventDispatcher {
+
+    @Nullable private final Handler handler;
+    @Nullable private final MediaSourceEventListener listener;
+    private final long mediaTimeOffsetMs;
+
+    public EventDispatcher(@Nullable Handler handler, @Nullable MediaSourceEventListener listener) {
+      this(handler, listener, 0);
+    }
+
+    public EventDispatcher(
+        @Nullable Handler handler,
+        @Nullable MediaSourceEventListener listener,
+        long mediaTimeOffsetMs) {
+      this.handler = listener != null ? Assertions.checkNotNull(handler) : null;
+      this.listener = listener;
+      this.mediaTimeOffsetMs = mediaTimeOffsetMs;
+    }
+
+    public EventDispatcher copyWithMediaTimeOffsetMs(long mediaTimeOffsetMs) {
+      return new EventDispatcher(handler, listener, mediaTimeOffsetMs);
+    }
+
+    public void loadStarted(DataSpec dataSpec, int dataType, long elapsedRealtimeMs) {
+      loadStarted(
+          dataSpec,
+          dataType,
+          C.TRACK_TYPE_UNKNOWN,
+          null,
+          C.SELECTION_REASON_UNKNOWN,
+          null,
+          C.TIME_UNSET,
+          C.TIME_UNSET,
+          elapsedRealtimeMs);
+    }
+
+    public void loadStarted(
+        final DataSpec dataSpec,
+        final int dataType,
+        final int trackType,
+        final Format trackFormat,
+        final int trackSelectionReason,
+        final Object trackSelectionData,
+        final long mediaStartTimeUs,
+        final long mediaEndTimeUs,
+        final long elapsedRealtimeMs) {
+      if (listener != null && handler != null) {
+        handler.post(
+            new Runnable() {
+              @Override
+              public void run() {
+                listener.onLoadStarted(
+                    dataSpec,
+                    dataType,
+                    trackType,
+                    trackFormat,
+                    trackSelectionReason,
+                    trackSelectionData,
+                    adjustMediaTime(mediaStartTimeUs),
+                    adjustMediaTime(mediaEndTimeUs),
+                    elapsedRealtimeMs);
+              }
+            });
+      }
+    }
+
+    public void loadCompleted(
+        DataSpec dataSpec,
+        int dataType,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded) {
+      loadCompleted(
+          dataSpec,
+          dataType,
+          C.TRACK_TYPE_UNKNOWN,
+          null,
+          C.SELECTION_REASON_UNKNOWN,
+          null,
+          C.TIME_UNSET,
+          C.TIME_UNSET,
+          elapsedRealtimeMs,
+          loadDurationMs,
+          bytesLoaded);
+    }
+
+    public void loadCompleted(
+        final DataSpec dataSpec,
+        final int dataType,
+        final int trackType,
+        final Format trackFormat,
+        final int trackSelectionReason,
+        final Object trackSelectionData,
+        final long mediaStartTimeUs,
+        final long mediaEndTimeUs,
+        final long elapsedRealtimeMs,
+        final long loadDurationMs,
+        final long bytesLoaded) {
+      if (listener != null && handler != null) {
+        handler.post(
+            new Runnable() {
+              @Override
+              public void run() {
+                listener.onLoadCompleted(
+                    dataSpec,
+                    dataType,
+                    trackType,
+                    trackFormat,
+                    trackSelectionReason,
+                    trackSelectionData,
+                    adjustMediaTime(mediaStartTimeUs),
+                    adjustMediaTime(mediaEndTimeUs),
+                    elapsedRealtimeMs,
+                    loadDurationMs,
+                    bytesLoaded);
+              }
+            });
+      }
+    }
+
+    public void loadCanceled(
+        DataSpec dataSpec,
+        int dataType,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded) {
+      loadCanceled(
+          dataSpec,
+          dataType,
+          C.TRACK_TYPE_UNKNOWN,
+          null,
+          C.SELECTION_REASON_UNKNOWN,
+          null,
+          C.TIME_UNSET,
+          C.TIME_UNSET,
+          elapsedRealtimeMs,
+          loadDurationMs,
+          bytesLoaded);
+    }
+
+    public void loadCanceled(
+        final DataSpec dataSpec,
+        final int dataType,
+        final int trackType,
+        final Format trackFormat,
+        final int trackSelectionReason,
+        final Object trackSelectionData,
+        final long mediaStartTimeUs,
+        final long mediaEndTimeUs,
+        final long elapsedRealtimeMs,
+        final long loadDurationMs,
+        final long bytesLoaded) {
+      if (listener != null && handler != null) {
+        handler.post(
+            new Runnable() {
+              @Override
+              public void run() {
+                listener.onLoadCanceled(
+                    dataSpec,
+                    dataType,
+                    trackType,
+                    trackFormat,
+                    trackSelectionReason,
+                    trackSelectionData,
+                    adjustMediaTime(mediaStartTimeUs),
+                    adjustMediaTime(mediaEndTimeUs),
+                    elapsedRealtimeMs,
+                    loadDurationMs,
+                    bytesLoaded);
+              }
+            });
+      }
+    }
+
+    public void loadError(
+        DataSpec dataSpec,
+        int dataType,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded,
+        IOException error,
+        boolean wasCanceled) {
+      loadError(
+          dataSpec,
+          dataType,
+          C.TRACK_TYPE_UNKNOWN,
+          null,
+          C.SELECTION_REASON_UNKNOWN,
+          null,
+          C.TIME_UNSET,
+          C.TIME_UNSET,
+          elapsedRealtimeMs,
+          loadDurationMs,
+          bytesLoaded,
+          error,
+          wasCanceled);
+    }
+
+    public void loadError(
+        final DataSpec dataSpec,
+        final int dataType,
+        final int trackType,
+        final Format trackFormat,
+        final int trackSelectionReason,
+        final Object trackSelectionData,
+        final long mediaStartTimeUs,
+        final long mediaEndTimeUs,
+        final long elapsedRealtimeMs,
+        final long loadDurationMs,
+        final long bytesLoaded,
+        final IOException error,
+        final boolean wasCanceled) {
+      if (listener != null && handler != null) {
+        handler.post(
+            new Runnable() {
+              @Override
+              public void run() {
+                listener.onLoadError(
+                    dataSpec,
+                    dataType,
+                    trackType,
+                    trackFormat,
+                    trackSelectionReason,
+                    trackSelectionData,
+                    adjustMediaTime(mediaStartTimeUs),
+                    adjustMediaTime(mediaEndTimeUs),
+                    elapsedRealtimeMs,
+                    loadDurationMs,
+                    bytesLoaded,
+                    error,
+                    wasCanceled);
+              }
+            });
+      }
+    }
+
+    public void upstreamDiscarded(
+        final int trackType, final long mediaStartTimeUs, final long mediaEndTimeUs) {
+      if (listener != null && handler != null) {
+        handler.post(
+            new Runnable() {
+              @Override
+              public void run() {
+                listener.onUpstreamDiscarded(
+                    trackType, adjustMediaTime(mediaStartTimeUs), adjustMediaTime(mediaEndTimeUs));
+              }
+            });
+      }
+    }
+
+    public void downstreamFormatChanged(
+        final int trackType,
+        final Format trackFormat,
+        final int trackSelectionReason,
+        final Object trackSelectionData,
+        final long mediaTimeUs) {
+      if (listener != null && handler != null) {
+        handler.post(
+            new Runnable() {
+              @Override
+              public void run() {
+                listener.onDownstreamFormatChanged(
+                    trackType,
+                    trackFormat,
+                    trackSelectionReason,
+                    trackSelectionData,
+                    adjustMediaTime(mediaTimeUs));
+              }
+            });
+      }
+    }
+
+    private long adjustMediaTime(long mediaTimeUs) {
+      long mediaTimeMs = C.usToMs(mediaTimeUs);
+      return mediaTimeMs == C.TIME_UNSET ? C.TIME_UNSET : mediaTimeOffsetMs + mediaTimeMs;
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
index e6a4d4e603..cc0c63ef41 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaPeriod.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source;
 
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
@@ -30,15 +31,18 @@
   public final MediaPeriod[] periods;
 
   private final IdentityHashMap<SampleStream, Integer> streamPeriodIndices;
+  private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
 
   private Callback callback;
   private int pendingChildPrepareCount;
   private TrackGroupArray trackGroups;
 
   private MediaPeriod[] enabledPeriods;
-  private SequenceableLoader sequenceableLoader;
+  private SequenceableLoader compositeSequenceableLoader;
 
-  public MergingMediaPeriod(MediaPeriod... periods) {
+  public MergingMediaPeriod(CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
+      MediaPeriod... periods) {
+    this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
     this.periods = periods;
     streamPeriodIndices = new IdentityHashMap<>();
   }
@@ -124,25 +128,31 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     // Update the local state.
     enabledPeriods = new MediaPeriod[enabledPeriodsList.size()];
     enabledPeriodsList.toArray(enabledPeriods);
-    sequenceableLoader = new CompositeSequenceableLoader(enabledPeriods);
+    compositeSequenceableLoader =
+        compositeSequenceableLoaderFactory.createCompositeSequenceableLoader(enabledPeriods);
     return positionUs;
   }
 
   @Override
-  public void discardBuffer(long positionUs) {
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
     for (MediaPeriod period : enabledPeriods) {
-      period.discardBuffer(positionUs);
+      period.discardBuffer(positionUs, toKeyframe);
     }
   }
 
+  @Override
+  public void reevaluateBuffer(long positionUs) {
+    compositeSequenceableLoader.reevaluateBuffer(positionUs);
+  }
+
   @Override
   public boolean continueLoading(long positionUs) {
-    return sequenceableLoader.continueLoading(positionUs);
+    return compositeSequenceableLoader.continueLoading(positionUs);
   }
 
   @Override
   public long getNextLoadPositionUs() {
-    return sequenceableLoader.getNextLoadPositionUs();
+    return compositeSequenceableLoader.getNextLoadPositionUs();
   }
 
   @Override
@@ -168,7 +178,7 @@ public long readDiscontinuity() {
 
   @Override
   public long getBufferedPositionUs() {
-    return sequenceableLoader.getBufferedPositionUs();
+    return compositeSequenceableLoader.getBufferedPositionUs();
   }
 
   @Override
@@ -183,6 +193,11 @@ public long seekToUs(long positionUs) {
     return positionUs;
   }
 
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    return enabledPeriods[0].getAdjustedSeekPositionUs(positionUs, seekParameters);
+  }
+
   // MediaPeriod.Callback implementation
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
index 1550970e47..a738cb1893 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/MergingMediaSource.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.source;
 
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.upstream.Allocator;
@@ -24,14 +25,14 @@
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 
 /**
  * Merges multiple {@link MediaSource}s.
- * <p>
- * The {@link Timeline}s of the sources being merged must have the same number of periods, and must
- * not have any dynamic windows.
+ *
+ * <p>The {@link Timeline}s of the sources being merged must have the same number of periods.
  */
-public final class MergingMediaSource implements MediaSource {
+public final class MergingMediaSource extends CompositeMediaSource<Integer> {
 
   /**
    * Thrown when a {@link MergingMediaSource} cannot merge its sources.
@@ -42,26 +43,20 @@
      * The reason the merge failed.
      */
     @Retention(RetentionPolicy.SOURCE)
-    @IntDef({REASON_WINDOWS_ARE_DYNAMIC, REASON_PERIOD_COUNT_MISMATCH})
+    @IntDef({REASON_PERIOD_COUNT_MISMATCH})
     public @interface Reason {}
     /**
-     * The merge failed because one of the sources being merged has a dynamic window.
-     */
-    public static final int REASON_WINDOWS_ARE_DYNAMIC = 0;
-    /**
-     * The merge failed because the sources have different period counts.
+     * The sources have different period counts.
      */
-    public static final int REASON_PERIOD_COUNT_MISMATCH = 1;
+    public static final int REASON_PERIOD_COUNT_MISMATCH = 0;
 
     /**
-     * The reason the merge failed. One of {@link #REASON_WINDOWS_ARE_DYNAMIC} and
-     * {@link #REASON_PERIOD_COUNT_MISMATCH}.
+     * The reason the merge failed.
      */
     @Reason public final int reason;
 
     /**
-     * @param reason The reason the merge failed. One of {@link #REASON_WINDOWS_ARE_DYNAMIC} and
-     *     {@link #REASON_PERIOD_COUNT_MISMATCH}.
+     * @param reason The reason the merge failed.
      */
     public IllegalMergeException(@Reason int reason) {
       this.reason = reason;
@@ -73,7 +68,7 @@ public IllegalMergeException(@Reason int reason) {
 
   private final MediaSource[] mediaSources;
   private final ArrayList<MediaSource> pendingTimelineSources;
-  private final Timeline.Window window;
+  private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
 
   private Listener listener;
   private Timeline primaryTimeline;
@@ -85,23 +80,29 @@ public IllegalMergeException(@Reason int reason) {
    * @param mediaSources The {@link MediaSource}s to merge.
    */
   public MergingMediaSource(MediaSource... mediaSources) {
+    this(new DefaultCompositeSequenceableLoaderFactory(), mediaSources);
+  }
+
+  /**
+   * @param compositeSequenceableLoaderFactory A factory to create composite
+   *     {@link SequenceableLoader}s for when this media source loads data from multiple streams
+   *     (video, audio etc...).
+   * @param mediaSources The {@link MediaSource}s to merge.
+   */
+  public MergingMediaSource(CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
+      MediaSource... mediaSources) {
     this.mediaSources = mediaSources;
+    this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
     pendingTimelineSources = new ArrayList<>(Arrays.asList(mediaSources));
-    window = new Timeline.Window();
     periodCount = PERIOD_COUNT_UNSET;
   }
 
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    super.prepareSource(player, isTopLevelSource, listener);
     this.listener = listener;
     for (int i = 0; i < mediaSources.length; i++) {
-      final int sourceIndex = i;
-      mediaSources[sourceIndex].prepareSource(player, false, new Listener() {
-        @Override
-        public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
-          handleSourceInfoRefreshed(sourceIndex, timeline, manifest);
-        }
-      });
+      prepareChildSource(i, mediaSources[i]);
     }
   }
 
@@ -110,9 +111,7 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
     if (mergeError != null) {
       throw mergeError;
     }
-    for (MediaSource mediaSource : mediaSources) {
-      mediaSource.maybeThrowSourceInfoRefreshError();
-    }
+    super.maybeThrowSourceInfoRefreshError();
   }
 
   @Override
@@ -121,7 +120,7 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     for (int i = 0; i < periods.length; i++) {
       periods[i] = mediaSources[i].createPeriod(id, allocator);
     }
-    return new MergingMediaPeriod(periods);
+    return new MergingMediaPeriod(compositeSequenceableLoaderFactory, periods);
   }
 
   @Override
@@ -134,20 +133,27 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSource() {
-    for (MediaSource mediaSource : mediaSources) {
-      mediaSource.releaseSource();
-    }
+    super.releaseSource();
+    listener = null;
+    primaryTimeline = null;
+    primaryManifest = null;
+    periodCount = PERIOD_COUNT_UNSET;
+    mergeError = null;
+    pendingTimelineSources.clear();
+    Collections.addAll(pendingTimelineSources, mediaSources);
   }
 
-  private void handleSourceInfoRefreshed(int sourceIndex, Timeline timeline, Object manifest) {
+  @Override
+  protected void onChildSourceInfoRefreshed(
+      Integer id, MediaSource mediaSource, Timeline timeline, @Nullable Object manifest) {
     if (mergeError == null) {
       mergeError = checkTimelineMerges(timeline);
     }
     if (mergeError != null) {
       return;
     }
-    pendingTimelineSources.remove(mediaSources[sourceIndex]);
-    if (sourceIndex == 0) {
+    pendingTimelineSources.remove(mediaSource);
+    if (mediaSource == mediaSources[0]) {
       primaryTimeline = timeline;
       primaryManifest = manifest;
     }
@@ -157,12 +163,6 @@ private void handleSourceInfoRefreshed(int sourceIndex, Timeline timeline, Objec
   }
 
   private IllegalMergeException checkTimelineMerges(Timeline timeline) {
-    int windowCount = timeline.getWindowCount();
-    for (int i = 0; i < windowCount; i++) {
-      if (timeline.getWindow(i, window, false).isDynamic) {
-        return new IllegalMergeException(IllegalMergeException.REASON_WINDOWS_ARE_DYNAMIC);
-      }
-    }
     if (periodCount == PERIOD_COUNT_UNSET) {
       periodCount = timeline.getPeriodCount();
     } else if (timeline.getPeriodCount() != periodCount) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
index d70c59b195..e5b950cf2e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleMetadataQueue.java
@@ -51,8 +51,8 @@
   private Format[] formats;
 
   private int length;
-  private int absoluteStartIndex;
-  private int relativeStartIndex;
+  private int absoluteFirstIndex;
+  private int relativeFirstIndex;
   private int readPosition;
 
   private long largestDiscardedTimestampUs;
@@ -87,8 +87,8 @@ public SampleMetadataQueue() {
    */
   public void reset(boolean resetUpstreamFormat) {
     length = 0;
-    absoluteStartIndex = 0;
-    relativeStartIndex = 0;
+    absoluteFirstIndex = 0;
+    relativeFirstIndex = 0;
     readPosition = 0;
     upstreamKeyframeRequired = true;
     largestDiscardedTimestampUs = Long.MIN_VALUE;
@@ -103,7 +103,7 @@ public void reset(boolean resetUpstreamFormat) {
    * Returns the current absolute write index.
    */
   public int getWriteIndex() {
-    return absoluteStartIndex + length;
+    return absoluteFirstIndex + length;
   }
 
   /**
@@ -132,11 +132,18 @@ public void sourceId(int sourceId) {
 
   // Called by the consuming thread.
 
+  /**
+   * Returns the current absolute start index.
+   */
+  public int getFirstIndex() {
+    return absoluteFirstIndex;
+  }
+
   /**
    * Returns the current absolute read index.
    */
   public int getReadIndex() {
-    return absoluteStartIndex + readPosition;
+    return absoluteFirstIndex + readPosition;
   }
 
   /**
@@ -179,6 +186,11 @@ public synchronized long getLargestQueuedTimestampUs() {
     return largestQueuedTimestampUs;
   }
 
+  /** Returns the timestamp of the first sample, or {@link Long#MIN_VALUE} if the queue is empty. */
+  public synchronized long getFirstTimestampUs() {
+    return length == 0 ? Long.MIN_VALUE : timesUs[relativeFirstIndex];
+  }
+
   /**
    * Rewinds the read position to the first sample retained in the queue.
    */
@@ -284,6 +296,22 @@ public synchronized int advanceToEnd() {
     return skipCount;
   }
 
+  /**
+   * Attempts to set the read position to the specified sample index.
+   *
+   * @param sampleIndex The sample index.
+   * @return Whether the read position was set successfully. False is returned if the specified
+   *     index is smaller than the index of the first sample in the queue, or larger than the index
+   *     of the next sample that will be written.
+   */
+  public synchronized boolean setReadPosition(int sampleIndex) {
+    if (absoluteFirstIndex <= sampleIndex && sampleIndex <= absoluteFirstIndex + length) {
+      readPosition = sampleIndex - absoluteFirstIndex;
+      return true;
+    }
+    return false;
+  }
+
   /**
    * Discards up to but not including the sample immediately before or at the specified time.
    *
@@ -297,11 +325,11 @@ public synchronized int advanceToEnd() {
    *     {@link C#POSITION_UNSET} if no discarding of data is necessary.
    */
   public synchronized long discardTo(long timeUs, boolean toKeyframe, boolean stopAtReadPosition) {
-    if (length == 0 || timeUs < timesUs[relativeStartIndex]) {
+    if (length == 0 || timeUs < timesUs[relativeFirstIndex]) {
       return C.POSITION_UNSET;
     }
     int searchLength = stopAtReadPosition && readPosition != length ? readPosition + 1 : length;
-    int discardCount = findSampleBefore(relativeStartIndex, searchLength, timeUs, toKeyframe);
+    int discardCount = findSampleBefore(relativeFirstIndex, searchLength, timeUs, toKeyframe);
     if (discardCount == -1) {
       return C.POSITION_UNSET;
     }
@@ -382,15 +410,15 @@ public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlag
       int[] newSizes = new int[newCapacity];
       CryptoData[] newCryptoDatas = new CryptoData[newCapacity];
       Format[] newFormats = new Format[newCapacity];
-      int beforeWrap = capacity - relativeStartIndex;
-      System.arraycopy(offsets, relativeStartIndex, newOffsets, 0, beforeWrap);
-      System.arraycopy(timesUs, relativeStartIndex, newTimesUs, 0, beforeWrap);
-      System.arraycopy(flags, relativeStartIndex, newFlags, 0, beforeWrap);
-      System.arraycopy(sizes, relativeStartIndex, newSizes, 0, beforeWrap);
-      System.arraycopy(cryptoDatas, relativeStartIndex, newCryptoDatas, 0, beforeWrap);
-      System.arraycopy(formats, relativeStartIndex, newFormats, 0, beforeWrap);
-      System.arraycopy(sourceIds, relativeStartIndex, newSourceIds, 0, beforeWrap);
-      int afterWrap = relativeStartIndex;
+      int beforeWrap = capacity - relativeFirstIndex;
+      System.arraycopy(offsets, relativeFirstIndex, newOffsets, 0, beforeWrap);
+      System.arraycopy(timesUs, relativeFirstIndex, newTimesUs, 0, beforeWrap);
+      System.arraycopy(flags, relativeFirstIndex, newFlags, 0, beforeWrap);
+      System.arraycopy(sizes, relativeFirstIndex, newSizes, 0, beforeWrap);
+      System.arraycopy(cryptoDatas, relativeFirstIndex, newCryptoDatas, 0, beforeWrap);
+      System.arraycopy(formats, relativeFirstIndex, newFormats, 0, beforeWrap);
+      System.arraycopy(sourceIds, relativeFirstIndex, newSourceIds, 0, beforeWrap);
+      int afterWrap = relativeFirstIndex;
       System.arraycopy(offsets, 0, newOffsets, beforeWrap, afterWrap);
       System.arraycopy(timesUs, 0, newTimesUs, beforeWrap, afterWrap);
       System.arraycopy(flags, 0, newFlags, beforeWrap, afterWrap);
@@ -405,7 +433,7 @@ public synchronized void commitSample(long timeUs, @C.BufferFlags int sampleFlag
       cryptoDatas = newCryptoDatas;
       formats = newFormats;
       sourceIds = newSourceIds;
-      relativeStartIndex = 0;
+      relativeFirstIndex = 0;
       length = capacity;
       capacity = newCapacity;
     }
@@ -440,7 +468,7 @@ public synchronized boolean attemptSplice(long timeUs) {
         relativeSampleIndex = capacity - 1;
       }
     }
-    discardUpstreamSamples(absoluteStartIndex + retainCount);
+    discardUpstreamSamples(absoluteFirstIndex + retainCount);
     return true;
   }
 
@@ -454,7 +482,7 @@ public synchronized boolean attemptSplice(long timeUs) {
    * @param length The length of the range being searched.
    * @param timeUs The specified time.
    * @param keyframe Whether only keyframes should be considered.
-   * @return The offset from {@code relativeStartIndex} to the found sample, or -1 if no matching
+   * @return The offset from {@code relativeFirstIndex} to the found sample, or -1 if no matching
    *     sample was found.
    */
   private int findSampleBefore(int relativeStartIndex, int length, long timeUs, boolean keyframe) {
@@ -480,27 +508,26 @@ private int findSampleBefore(int relativeStartIndex, int length, long timeUs, bo
    * Discards the specified number of samples.
    *
    * @param discardCount The number of samples to discard.
-   * @return The corresponding offset up to which data should be discarded, or
-   *     {@link C#POSITION_UNSET} if no discarding of data is necessary.
+   * @return The corresponding offset up to which data should be discarded.
    */
   private long discardSamples(int discardCount) {
     largestDiscardedTimestampUs = Math.max(largestDiscardedTimestampUs,
         getLargestTimestamp(discardCount));
     length -= discardCount;
-    absoluteStartIndex += discardCount;
-    relativeStartIndex += discardCount;
-    if (relativeStartIndex >= capacity) {
-      relativeStartIndex -= capacity;
+    absoluteFirstIndex += discardCount;
+    relativeFirstIndex += discardCount;
+    if (relativeFirstIndex >= capacity) {
+      relativeFirstIndex -= capacity;
     }
     readPosition -= discardCount;
     if (readPosition < 0) {
       readPosition = 0;
     }
     if (length == 0) {
-      int relativeLastDiscardIndex = (relativeStartIndex == 0 ? capacity : relativeStartIndex) - 1;
+      int relativeLastDiscardIndex = (relativeFirstIndex == 0 ? capacity : relativeFirstIndex) - 1;
       return offsets[relativeLastDiscardIndex] + sizes[relativeLastDiscardIndex];
     } else {
-      return offsets[relativeStartIndex];
+      return offsets[relativeFirstIndex];
     }
   }
 
@@ -537,7 +564,7 @@ private long getLargestTimestamp(int length) {
     * @param offset The offset, which must be in the range [0, length].
     */
   private int getRelativeIndex(int offset) {
-    int relativeIndex = relativeStartIndex + offset;
+    int relativeIndex = relativeFirstIndex + offset;
     return relativeIndex < capacity ? relativeIndex : relativeIndex - capacity;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
index b83cf7df5b..d9090baf3b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SampleQueue.java
@@ -181,6 +181,13 @@ public boolean hasNextSample() {
     return metadataQueue.hasNextSample();
   }
 
+  /**
+   * Returns the absolute index of the first sample.
+   */
+  public int getFirstIndex() {
+    return metadataQueue.getFirstIndex();
+  }
+
   /**
    * Returns the current absolute read index.
    */
@@ -219,6 +226,11 @@ public long getLargestQueuedTimestampUs() {
     return metadataQueue.getLargestQueuedTimestampUs();
   }
 
+  /** Returns the timestamp of the first sample, or {@link Long#MIN_VALUE} if the queue is empty. */
+  public long getFirstTimestampUs() {
+    return metadataQueue.getFirstTimestampUs();
+  }
+
   /**
    * Rewinds the read position to the first sample in the queue.
    */
@@ -281,6 +293,18 @@ public int advanceTo(long timeUs, boolean toKeyframe, boolean allowTimeBeyondBuf
     return metadataQueue.advanceTo(timeUs, toKeyframe, allowTimeBeyondBuffer);
   }
 
+  /**
+   * Attempts to set the read position to the specified sample index.
+   *
+   * @param sampleIndex The sample index.
+   * @return Whether the read position was set successfully. False is returned if the specified
+   *     index is smaller than the index of the first sample in the queue, or larger than the index
+   *     of the next sample that will be written.
+   */
+  public boolean setReadPosition(int sampleIndex) {
+    return metadataQueue.setReadPosition(sampleIndex);
+  }
+
   /**
    * Attempts to read from the queue.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
index 6daa1e847a..182f0f17cc 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SequenceableLoader.java
@@ -60,4 +60,15 @@
    */
   boolean continueLoading(long positionUs);
 
+  /**
+   * Re-evaluates the buffer given the playback position.
+   *
+   * <p>Re-evaluation may discard buffered media so that it can be re-buffered in a different
+   * quality.
+   *
+   * @param positionUs The current playback position in microseconds. If playback of this period has
+   *     not yet started, the value will be the starting position in this period minus the duration
+   *     of any media in previous periods still to be played.
+   */
+  void reevaluateBuffer(long positionUs);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
index 4307fd2c19..f5f98e4d8a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ShuffleOrder.java
@@ -136,6 +136,11 @@ public ShuffleOrder cloneAndRemove(int removalIndex) {
       return new DefaultShuffleOrder(newShuffled, new Random(random.nextLong()));
     }
 
+    @Override
+    public ShuffleOrder cloneAndClear() {
+      return new DefaultShuffleOrder(/* length= */ 0, new Random(random.nextLong()));
+    }
+
     private static int[] createShuffledList(int length, Random random) {
       int[] shuffled = new int[length];
       for (int i = 0; i < length; i++) {
@@ -199,6 +204,10 @@ public ShuffleOrder cloneAndRemove(int removalIndex) {
       return new UnshuffledShuffleOrder(length - 1);
     }
 
+    @Override
+    public ShuffleOrder cloneAndClear() {
+      return new UnshuffledShuffleOrder(/* length= */ 0);
+    }
   }
 
   /**
@@ -237,7 +246,7 @@ public ShuffleOrder cloneAndRemove(int removalIndex) {
   int getFirstIndex();
 
   /**
-   * Return a copy of the shuffle order with newly inserted elements.
+   * Returns a copy of the shuffle order with newly inserted elements.
    *
    * @param insertionIndex The index in the unshuffled order at which elements are inserted.
    * @param insertionCount The number of elements inserted at {@code insertionIndex}.
@@ -246,11 +255,13 @@ public ShuffleOrder cloneAndRemove(int removalIndex) {
   ShuffleOrder cloneAndInsert(int insertionIndex, int insertionCount);
 
   /**
-   * Return a copy of the shuffle order with one element removed.
+   * Returns a copy of the shuffle order with one element removed.
    *
    * @param removalIndex The index of the element in the unshuffled order which is to be removed.
    * @return A copy of this {@link ShuffleOrder} without the removed element.
    */
   ShuffleOrder cloneAndRemove(int removalIndex);
 
+  /** Returns a copy of the shuffle order with all elements removed. */
+  ShuffleOrder cloneAndClear();
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
index 6f35438444..9cce67f68c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SinglePeriodTimeline.java
@@ -36,14 +36,14 @@
   private final boolean isDynamic;
 
   /**
-   * Creates a timeline of one period of known duration, and a static window starting at zero and
-   * extending to that duration.
+   * Creates a timeline containing a single period and a window that spans it.
    *
    * @param durationUs The duration of the period, in microseconds.
    * @param isSeekable Whether seeking is supported within the period.
+   * @param isDynamic Whether the window may change when the timeline is updated.
    */
-  public SinglePeriodTimeline(long durationUs, boolean isSeekable) {
-    this(durationUs, durationUs, 0, 0, isSeekable, false);
+  public SinglePeriodTimeline(long durationUs, boolean isSeekable, boolean isDynamic) {
+    this(durationUs, durationUs, 0, 0, isSeekable, isDynamic);
   }
 
   /**
@@ -63,7 +63,7 @@ public SinglePeriodTimeline(long periodDurationUs, long windowDurationUs,
       long windowPositionInPeriodUs, long windowDefaultStartPositionUs, boolean isSeekable,
       boolean isDynamic) {
     this(C.TIME_UNSET, C.TIME_UNSET, periodDurationUs, windowDurationUs, windowPositionInPeriodUs,
-    windowDefaultStartPositionUs, isSeekable, isDynamic);
+        windowDefaultStartPositionUs, isSeekable, isDynamic);
   }
 
   /**
@@ -106,11 +106,16 @@ public Window getWindow(int windowIndex, Window window, boolean setIds,
     Assertions.checkIndex(windowIndex, 0, 1);
     Object id = setIds ? ID : null;
     long windowDefaultStartPositionUs = this.windowDefaultStartPositionUs;
-    if (isDynamic) {
-      windowDefaultStartPositionUs += defaultPositionProjectionUs;
-      if (windowDefaultStartPositionUs > windowDurationUs) {
-        // The projection takes us beyond the end of the live window.
+    if (isDynamic && defaultPositionProjectionUs != 0) {
+      if (windowDurationUs == C.TIME_UNSET) {
+        // Don't allow projection into a window that has an unknown duration.
         windowDefaultStartPositionUs = C.TIME_UNSET;
+      } else {
+        windowDefaultStartPositionUs += defaultPositionProjectionUs;
+        if (windowDefaultStartPositionUs > windowDurationUs) {
+          // The projection takes us beyond the end of the window.
+          windowDefaultStartPositionUs = C.TIME_UNSET;
+        }
       }
     }
     return window.set(id, presentationStartTimeMs, windowStartTimeMs, isSeekable, isDynamic,
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
index 6101c79b7f..36e5d910c4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaPeriod.java
@@ -15,18 +15,18 @@
  */
 package com.google.android.exoplayer2.source;
 
-import android.net.Uri;
-import android.os.Handler;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
-import com.google.android.exoplayer2.source.SingleSampleMediaSource.EventListener;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.upstream.Loader.Loadable;
+import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -43,14 +43,14 @@
    */
   private static final int INITIAL_SAMPLE_SIZE = 1024;
 
-  private final Uri uri;
+  private final DataSpec dataSpec;
   private final DataSource.Factory dataSourceFactory;
   private final int minLoadableRetryCount;
-  private final Handler eventHandler;
-  private final EventListener eventListener;
-  private final int eventSourceId;
+  private final EventDispatcher eventDispatcher;
   private final TrackGroupArray tracks;
   private final ArrayList<SampleStreamImpl> sampleStreams;
+  private final long durationUs;
+
   // Package private to avoid thunk methods.
   /* package */ final Loader loader;
   /* package */ final Format format;
@@ -62,16 +62,20 @@
   /* package */ int sampleSize;
   private int errorCount;
 
-  public SingleSampleMediaPeriod(Uri uri, DataSource.Factory dataSourceFactory, Format format,
-      int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
-      int eventSourceId, boolean treatLoadErrorsAsEndOfStream) {
-    this.uri = uri;
+  public SingleSampleMediaPeriod(
+      DataSpec dataSpec,
+      DataSource.Factory dataSourceFactory,
+      Format format,
+      long durationUs,
+      int minLoadableRetryCount,
+      EventDispatcher eventDispatcher,
+      boolean treatLoadErrorsAsEndOfStream) {
+    this.dataSpec = dataSpec;
     this.dataSourceFactory = dataSourceFactory;
     this.format = format;
+    this.durationUs = durationUs;
     this.minLoadableRetryCount = minLoadableRetryCount;
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
-    this.eventSourceId = eventSourceId;
+    this.eventDispatcher = eventDispatcher;
     this.treatLoadErrorsAsEndOfStream = treatLoadErrorsAsEndOfStream;
     tracks = new TrackGroupArray(new TrackGroup(format));
     sampleStreams = new ArrayList<>();
@@ -116,7 +120,12 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
   }
 
   @Override
-  public void discardBuffer(long positionUs) {
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
+    // Do nothing.
+  }
+
+  @Override
+  public void reevaluateBuffer(long positionUs) {
     // Do nothing.
   }
 
@@ -125,8 +134,21 @@ public boolean continueLoading(long positionUs) {
     if (loadingFinished || loader.isLoading()) {
       return false;
     }
-    loader.startLoading(new SourceLoadable(uri, dataSourceFactory.createDataSource()), this,
-        minLoadableRetryCount);
+    long elapsedRealtimeMs =
+        loader.startLoading(
+            new SourceLoadable(dataSpec, dataSourceFactory.createDataSource()),
+            this,
+            minLoadableRetryCount);
+    eventDispatcher.loadStarted(
+        dataSpec,
+        C.DATA_TYPE_MEDIA,
+        C.TRACK_TYPE_UNKNOWN,
+        format,
+        C.SELECTION_REASON_UNKNOWN,
+        /* trackSelectionData= */ null,
+        /* mediaStartTimeUs= */ 0,
+        durationUs,
+        elapsedRealtimeMs);
     return true;
   }
 
@@ -148,16 +170,33 @@ public long getBufferedPositionUs() {
   @Override
   public long seekToUs(long positionUs) {
     for (int i = 0; i < sampleStreams.size(); i++) {
-      sampleStreams.get(i).seekToUs(positionUs);
+      sampleStreams.get(i).reset();
     }
     return positionUs;
   }
 
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    return positionUs;
+  }
+
   // Loader.Callback implementation.
 
   @Override
   public void onLoadCompleted(SourceLoadable loadable, long elapsedRealtimeMs,
       long loadDurationMs) {
+    eventDispatcher.loadCompleted(
+        loadable.dataSpec,
+        C.DATA_TYPE_MEDIA,
+        C.TRACK_TYPE_UNKNOWN,
+        format,
+        C.SELECTION_REASON_UNKNOWN,
+        /* trackSelectionData= */ null,
+        /* mediaStartTimeUs= */ 0,
+        durationUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        loadable.sampleSize);
     sampleSize = loadable.sampleSize;
     sampleData = loadable.sampleData;
     loadingFinished = true;
@@ -167,34 +206,46 @@ public void onLoadCompleted(SourceLoadable loadable, long elapsedRealtimeMs,
   @Override
   public void onLoadCanceled(SourceLoadable loadable, long elapsedRealtimeMs, long loadDurationMs,
       boolean released) {
-    // Do nothing.
+    eventDispatcher.loadCanceled(
+        loadable.dataSpec,
+        C.DATA_TYPE_MEDIA,
+        C.TRACK_TYPE_UNKNOWN,
+        /* trackFormat= */ null,
+        C.SELECTION_REASON_UNKNOWN,
+        /* trackSelectionData= */ null,
+        /* mediaStartTimeUs= */ 0,
+        durationUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        loadable.sampleSize);
   }
 
   @Override
   public int onLoadError(SourceLoadable loadable, long elapsedRealtimeMs, long loadDurationMs,
       IOException error) {
-    notifyLoadError(error);
     errorCount++;
-    if (treatLoadErrorsAsEndOfStream && errorCount >= minLoadableRetryCount) {
+    boolean cancel = treatLoadErrorsAsEndOfStream && errorCount >= minLoadableRetryCount;
+    eventDispatcher.loadError(
+        loadable.dataSpec,
+        C.DATA_TYPE_MEDIA,
+        C.TRACK_TYPE_UNKNOWN,
+        format,
+        C.SELECTION_REASON_UNKNOWN,
+        /* trackSelectionData= */ null,
+        /* mediaStartTimeUs= */ 0,
+        durationUs,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        loadable.sampleSize,
+        error,
+        /* wasCanceled= */ cancel);
+    if (cancel) {
       loadingFinished = true;
       return Loader.DONT_RETRY;
     }
     return Loader.RETRY;
   }
 
-  // Internal methods.
-
-  private void notifyLoadError(final IOException e) {
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          eventListener.onLoadError(eventSourceId, e);
-        }
-      });
-    }
-  }
-
   private final class SampleStreamImpl implements SampleStream {
 
     private static final int STREAM_STATE_SEND_FORMAT = 0;
@@ -202,8 +253,9 @@ public void run() {
     private static final int STREAM_STATE_END_OF_STREAM = 2;
 
     private int streamState;
+    private boolean formatSent;
 
-    public void seekToUs(long positionUs) {
+    public void reset() {
       if (streamState == STREAM_STATE_END_OF_STREAM) {
         streamState = STREAM_STATE_SEND_SAMPLE;
       }
@@ -237,6 +289,7 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
           buffer.addFlag(C.BUFFER_FLAG_KEY_FRAME);
           buffer.ensureSpaceForWrite(sampleSize);
           buffer.data.put(sampleData, 0, sampleSize);
+          sendFormat();
         } else {
           buffer.addFlag(C.BUFFER_FLAG_END_OF_STREAM);
         }
@@ -250,23 +303,36 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
     public int skipData(long positionUs) {
       if (positionUs > 0 && streamState != STREAM_STATE_END_OF_STREAM) {
         streamState = STREAM_STATE_END_OF_STREAM;
+        sendFormat();
         return 1;
       }
       return 0;
     }
 
+    private void sendFormat() {
+      if (!formatSent) {
+        eventDispatcher.downstreamFormatChanged(
+            MimeTypes.getTrackType(format.sampleMimeType),
+            format,
+            C.SELECTION_REASON_UNKNOWN,
+            /* trackSelectionData= */ null,
+            /* mediaTimeUs= */ 0);
+        formatSent = true;
+      }
+    }
   }
 
   /* package */ static final class SourceLoadable implements Loadable {
 
-    private final Uri uri;
+    public final DataSpec dataSpec;
+
     private final DataSource dataSource;
 
     private int sampleSize;
     private byte[] sampleData;
 
-    public SourceLoadable(Uri uri, DataSource dataSource) {
-      this.uri = uri;
+    public SourceLoadable(DataSpec dataSpec, DataSource dataSource) {
+      this.dataSpec = dataSpec;
       this.dataSource = dataSource;
     }
 
@@ -286,7 +352,7 @@ public void load() throws IOException, InterruptedException {
       sampleSize = 0;
       try {
         // Create and open the input.
-        dataSource.open(new DataSpec(uri));
+        dataSource.open(dataSpec);
         // Load the sample data.
         int result = 0;
         while (result != C.RESULT_END_OF_INPUT) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
index dd901958fd..b92085d15e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/SingleSampleMediaSource.java
@@ -17,11 +17,14 @@
 
 import android.net.Uri;
 import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 
@@ -32,7 +35,10 @@
 
   /**
    * Listener of {@link SingleSampleMediaSource} events.
+   *
+   * @deprecated Use {@link MediaSourceEventListener}.
    */
+  @Deprecated
   public interface EventListener {
 
     /**
@@ -45,18 +51,110 @@
 
   }
 
+  /** Factory for {@link SingleSampleMediaSource}. */
+  public static final class Factory {
+
+    private final DataSource.Factory dataSourceFactory;
+
+    private int minLoadableRetryCount;
+    private boolean treatLoadErrorsAsEndOfStream;
+    private boolean isCreateCalled;
+
+    /**
+     * Creates a factory for {@link SingleSampleMediaSource}s.
+     *
+     * @param dataSourceFactory The factory from which the {@link DataSource} to read the media will
+     *     be obtained.
+     */
+    public Factory(DataSource.Factory dataSourceFactory) {
+      this.dataSourceFactory = Assertions.checkNotNull(dataSourceFactory);
+      this.minLoadableRetryCount = DEFAULT_MIN_LOADABLE_RETRY_COUNT;
+    }
+
+    /**
+     * Sets the minimum number of times to retry if a loading error occurs. The default value is
+     * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+     *
+     * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
+      Assertions.checkState(!isCreateCalled);
+      this.minLoadableRetryCount = minLoadableRetryCount;
+      return this;
+    }
+
+    /**
+     * Sets whether load errors will be treated as end-of-stream signal (load errors will not be
+     * propagated). The default value is false.
+     *
+     * @param treatLoadErrorsAsEndOfStream If true, load errors will not be propagated by sample
+     *     streams, treating them as ended instead. If false, load errors will be propagated
+     *     normally by {@link SampleStream#maybeThrowError()}.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setTreatLoadErrorsAsEndOfStream(boolean treatLoadErrorsAsEndOfStream) {
+      Assertions.checkState(!isCreateCalled);
+      this.treatLoadErrorsAsEndOfStream = treatLoadErrorsAsEndOfStream;
+      return this;
+    }
+
+    /**
+     * Returns a new {@link ExtractorMediaSource} using the current parameters. Media source events
+     * will not be delivered.
+     *
+     * @param uri The {@link Uri}.
+     * @param format The {@link Format} of the media stream.
+     * @param durationUs The duration of the media stream in microseconds.
+     * @return The new {@link ExtractorMediaSource}.
+     */
+    public SingleSampleMediaSource createMediaSource(Uri uri, Format format, long durationUs) {
+      return createMediaSource(uri, format, durationUs, null, null);
+    }
+
+    /**
+     * Returns a new {@link SingleSampleMediaSource} using the current parameters.
+     *
+     * @param uri The {@link Uri}.
+     * @param format The {@link Format} of the media stream.
+     * @param durationUs The duration of the media stream in microseconds.
+     * @param eventHandler A handler for events.
+     * @param eventListener A listener of events., Format format, long durationUs
+     * @return The newly built {@link SingleSampleMediaSource}.
+     */
+    public SingleSampleMediaSource createMediaSource(
+        Uri uri,
+        Format format,
+        long durationUs,
+        @Nullable Handler eventHandler,
+        @Nullable MediaSourceEventListener eventListener) {
+      isCreateCalled = true;
+      return new SingleSampleMediaSource(
+          uri,
+          dataSourceFactory,
+          format,
+          durationUs,
+          minLoadableRetryCount,
+          eventHandler,
+          eventListener,
+          treatLoadErrorsAsEndOfStream);
+    }
+
+  }
+
   /**
    * The default minimum number of times to retry loading data prior to failing.
    */
   public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
 
-  private final Uri uri;
+  private final DataSpec dataSpec;
   private final DataSource.Factory dataSourceFactory;
   private final Format format;
+  private final long durationUs;
+  private final MediaSourceEventListener.EventDispatcher eventDispatcher;
   private final int minLoadableRetryCount;
-  private final Handler eventHandler;
-  private final EventListener eventListener;
-  private final int eventSourceId;
   private final boolean treatLoadErrorsAsEndOfStream;
   private final Timeline timeline;
 
@@ -66,9 +164,11 @@
    *     be obtained.
    * @param format The {@link Format} associated with the output track.
    * @param durationUs The duration of the media stream in microseconds.
+   * @deprecated Use {@link Factory} instead.
    */
-  public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
-      long durationUs) {
+  @Deprecated
+  public SingleSampleMediaSource(
+      Uri uri, DataSource.Factory dataSourceFactory, Format format, long durationUs) {
     this(uri, dataSourceFactory, format, durationUs, DEFAULT_MIN_LOADABLE_RETRY_COUNT);
   }
 
@@ -79,10 +179,16 @@ public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Fo
    * @param format The {@link Format} associated with the output track.
    * @param durationUs The duration of the media stream in microseconds.
    * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+   * @deprecated Use {@link Factory} instead.
    */
-  public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
-      long durationUs, int minLoadableRetryCount) {
-    this(uri, dataSourceFactory, format, durationUs, minLoadableRetryCount, null, null, 0, false);
+  @Deprecated
+  public SingleSampleMediaSource(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      Format format,
+      long durationUs,
+      int minLoadableRetryCount) {
+    this(uri, dataSourceFactory, format, durationUs, minLoadableRetryCount, null, null, false);
   }
 
   /**
@@ -98,19 +204,47 @@ public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Fo
    * @param treatLoadErrorsAsEndOfStream If true, load errors will not be propagated by sample
    *     streams, treating them as ended instead. If false, load errors will be propagated normally
    *     by {@link SampleStream#maybeThrowError()}.
+   * @deprecated Use {@link Factory} instead.
    */
-  public SingleSampleMediaSource(Uri uri, DataSource.Factory dataSourceFactory, Format format,
-      long durationUs, int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
-      int eventSourceId, boolean treatLoadErrorsAsEndOfStream) {
-    this.uri = uri;
+  @Deprecated
+  public SingleSampleMediaSource(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      Format format,
+      long durationUs,
+      int minLoadableRetryCount,
+      Handler eventHandler,
+      EventListener eventListener,
+      int eventSourceId,
+      boolean treatLoadErrorsAsEndOfStream) {
+    this(
+        uri,
+        dataSourceFactory,
+        format,
+        durationUs,
+        minLoadableRetryCount,
+        eventHandler,
+        eventListener == null ? null : new EventListenerWrapper(eventListener, eventSourceId),
+        treatLoadErrorsAsEndOfStream);
+  }
+
+  private SingleSampleMediaSource(
+      Uri uri,
+      DataSource.Factory dataSourceFactory,
+      Format format,
+      long durationUs,
+      int minLoadableRetryCount,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener,
+      boolean treatLoadErrorsAsEndOfStream) {
     this.dataSourceFactory = dataSourceFactory;
     this.format = format;
+    this.durationUs = durationUs;
     this.minLoadableRetryCount = minLoadableRetryCount;
-    this.eventHandler = eventHandler;
-    this.eventListener = eventListener;
-    this.eventSourceId = eventSourceId;
     this.treatLoadErrorsAsEndOfStream = treatLoadErrorsAsEndOfStream;
-    timeline = new SinglePeriodTimeline(durationUs, true);
+    this.eventDispatcher = new EventDispatcher(eventHandler, eventListener);
+    dataSpec = new DataSpec(uri);
+    timeline = new SinglePeriodTimeline(durationUs, true, false);
   }
 
   // MediaSource implementation.
@@ -128,8 +262,14 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     Assertions.checkArgument(id.periodIndex == 0);
-    return new SingleSampleMediaPeriod(uri, dataSourceFactory, format, minLoadableRetryCount,
-        eventHandler, eventListener, eventSourceId, treatLoadErrorsAsEndOfStream);
+    return new SingleSampleMediaPeriod(
+        dataSpec,
+        dataSourceFactory,
+        format,
+        durationUs,
+        minLoadableRetryCount,
+        eventDispatcher,
+        treatLoadErrorsAsEndOfStream);
   }
 
   @Override
@@ -142,4 +282,97 @@ public void releaseSource() {
     // Do nothing.
   }
 
+  /**
+   * Wraps a deprecated {@link EventListener}, invoking its callback from the equivalent callback in
+   * {@link MediaSourceEventListener}.
+   */
+  private static final class EventListenerWrapper implements MediaSourceEventListener {
+
+    private final EventListener eventListener;
+    private final int eventSourceId;
+
+    public EventListenerWrapper(EventListener eventListener, int eventSourceId) {
+      this.eventListener = Assertions.checkNotNull(eventListener);
+      this.eventSourceId = eventSourceId;
+    }
+
+    @Override
+    public void onLoadStarted(
+        DataSpec dataSpec,
+        int dataType,
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaStartTimeMs,
+        long mediaEndTimeMs,
+        long elapsedRealtimeMs) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onLoadCompleted(
+        DataSpec dataSpec,
+        int dataType,
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaStartTimeMs,
+        long mediaEndTimeMs,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onLoadCanceled(
+        DataSpec dataSpec,
+        int dataType,
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaStartTimeMs,
+        long mediaEndTimeMs,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onLoadError(
+        DataSpec dataSpec,
+        int dataType,
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaStartTimeMs,
+        long mediaEndTimeMs,
+        long elapsedRealtimeMs,
+        long loadDurationMs,
+        long bytesLoaded,
+        IOException error,
+        boolean wasCanceled) {
+      eventListener.onLoadError(eventSourceId, error);
+    }
+
+    @Override
+    public void onUpstreamDiscarded(int trackType, long mediaStartTimeMs, long mediaEndTimeMs) {
+      // Do nothing.
+    }
+
+    @Override
+    public void onDownstreamFormatChanged(
+        int trackType,
+        Format trackFormat,
+        int trackSelectionReason,
+        Object trackSelectionData,
+        long mediaTimeMs) {
+      // Do nothing.
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java b/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
index 394cec891b..fb28da581c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroupArray.java
@@ -62,8 +62,11 @@ public TrackGroup get(int index) {
    * @param group The group.
    * @return The index of the group, or {@link C#INDEX_UNSET} if no such group exists.
    */
+  @SuppressWarnings("ReferenceEquality")
   public int indexOf(TrackGroup group) {
     for (int i = 0; i < length; i++) {
+      // Suppressed reference equality warning because this is looking for the index of a specific
+      // TrackGroup object, not the index of a potential equal TrackGroup.
       if (trackGroups[i] == group) {
         return i;
       }
@@ -71,6 +74,13 @@ public int indexOf(TrackGroup group) {
     return C.INDEX_UNSET;
   }
 
+  /**
+   * Returns whether this track group array is empty.
+   */
+  public boolean isEmpty() {
+    return length == 0;
+  }
+
   @Override
   public int hashCode() {
     if (hashCode == 0) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
index 58fa149b59..8654e94bdb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdPlaybackState.java
@@ -16,49 +16,237 @@
 package com.google.android.exoplayer2.source.ads;
 
 import android.net.Uri;
+import android.support.annotation.CheckResult;
+import android.support.annotation.IntDef;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.util.Assertions;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
 
 /**
- * Represents the structure of ads to play and the state of loaded/played ads.
+ * Represents ad group times relative to the start of the media and information on the state and
+ * URIs of ads within each ad group.
+ *
+ * <p>Instances are immutable. Call the {@code with*} methods to get new instances that have the
+ * required changes.
  */
 public final class AdPlaybackState {
 
   /**
-   * The number of ad groups.
+   * Represents a group of ads, with information about their states.
+   *
+   * <p>Instances are immutable. Call the {@code with*} methods to get new instances that have the
+   * required changes.
    */
+  public static final class AdGroup {
+
+    /** The number of ads in the ad group, or {@link C#LENGTH_UNSET} if unknown. */
+    public final int count;
+    /** The URI of each ad in the ad group. */
+    public final Uri[] uris;
+    /** The state of each ad in the ad group. */
+    public final @AdState int[] states;
+    /** The durations of each ad in the ad group, in microseconds. */
+    public final long[] durationsUs;
+
+    /** Creates a new ad group with an unspecified number of ads. */
+    public AdGroup() {
+      this(
+          /* count= */ C.LENGTH_UNSET,
+          /* states= */ new int[0],
+          /* uris= */ new Uri[0],
+          /* durationsUs= */ new long[0]);
+    }
+
+    private AdGroup(int count, @AdState int[] states, Uri[] uris, long[] durationsUs) {
+      Assertions.checkArgument(states.length == uris.length);
+      this.count = count;
+      this.states = states;
+      this.uris = uris;
+      this.durationsUs = durationsUs;
+    }
+
+    /**
+     * Returns the index of the first ad in the ad group that should be played, or {@link #count} if
+     * no ads should be played.
+     */
+    public int getFirstAdIndexToPlay() {
+      return getNextAdIndexToPlay(-1);
+    }
+
+    /**
+     * Returns the index of the next ad in the ad group that should be played after playing {@code
+     * lastPlayedAdIndex}, or {@link #count} if no later ads should be played.
+     */
+    public int getNextAdIndexToPlay(int lastPlayedAdIndex) {
+      int nextAdIndexToPlay = lastPlayedAdIndex + 1;
+      while (nextAdIndexToPlay < states.length) {
+        if (states[nextAdIndexToPlay] == AD_STATE_UNAVAILABLE
+            || states[nextAdIndexToPlay] == AD_STATE_AVAILABLE) {
+          break;
+        }
+        nextAdIndexToPlay++;
+      }
+      return nextAdIndexToPlay;
+    }
+
+    /** Returns whether the ad group has at least one ad that still needs to be played. */
+    public boolean hasUnplayedAds() {
+      return count == C.LENGTH_UNSET || getFirstAdIndexToPlay() < count;
+    }
+
+    /**
+     * Returns a new instance with the ad count set to {@code count}. This method may only be called
+     * if this instance's ad count has not yet been specified.
+     */
+    @CheckResult
+    public AdGroup withAdCount(int count) {
+      Assertions.checkArgument(this.count == C.LENGTH_UNSET && states.length <= count);
+      @AdState int[] states = copyStatesWithSpaceForAdCount(this.states, count);
+      long[] durationsUs = copyDurationsUsWithSpaceForAdCount(this.durationsUs, count);
+      Uri[] uris = Arrays.copyOf(this.uris, count);
+      return new AdGroup(count, states, uris, durationsUs);
+    }
+
+    /**
+     * Returns a new instance with the specified {@code uri} set for the specified ad, and the ad
+     * marked as {@link #AD_STATE_AVAILABLE}. The specified ad must currently be in {@link
+     * #AD_STATE_UNAVAILABLE}, which is the default state.
+     *
+     * <p>This instance's ad count may be unknown, in which case {@code index} must be less than the
+     * ad count specified later. Otherwise, {@code index} must be less than the current ad count.
+     */
+    @CheckResult
+    public AdGroup withAdUri(Uri uri, int index) {
+      Assertions.checkArgument(count == C.LENGTH_UNSET || index < count);
+      @AdState int[] states = copyStatesWithSpaceForAdCount(this.states, index + 1);
+      Assertions.checkArgument(states[index] == AD_STATE_UNAVAILABLE);
+      long[] durationsUs =
+          this.durationsUs.length == states.length
+              ? this.durationsUs
+              : copyDurationsUsWithSpaceForAdCount(this.durationsUs, states.length);
+      Uri[] uris = Arrays.copyOf(this.uris, states.length);
+      uris[index] = uri;
+      states[index] = AD_STATE_AVAILABLE;
+      return new AdGroup(count, states, uris, durationsUs);
+    }
+
+    /**
+     * Returns a new instance with the specified ad set to the specified {@code state}. The ad
+     * specified must currently either be in {@link #AD_STATE_UNAVAILABLE} or {@link
+     * #AD_STATE_AVAILABLE}.
+     *
+     * <p>This instance's ad count may be unknown, in which case {@code index} must be less than the
+     * ad count specified later. Otherwise, {@code index} must be less than the current ad count.
+     */
+    @CheckResult
+    public AdGroup withAdState(@AdState int state, int index) {
+      Assertions.checkArgument(count == C.LENGTH_UNSET || index < count);
+      @AdState int[] states = copyStatesWithSpaceForAdCount(this.states, index + 1);
+      Assertions.checkArgument(
+          states[index] == AD_STATE_UNAVAILABLE
+              || states[index] == AD_STATE_AVAILABLE
+              || states[index] == state);
+      long[] durationsUs =
+          this.durationsUs.length == states.length
+              ? this.durationsUs
+              : copyDurationsUsWithSpaceForAdCount(this.durationsUs, states.length);
+      Uri[] uris =
+          this.uris.length == states.length ? this.uris : Arrays.copyOf(this.uris, states.length);
+      states[index] = state;
+      return new AdGroup(count, states, uris, durationsUs);
+    }
+
+    /** Returns a new instance with the specified ad durations, in microseconds. */
+    @CheckResult
+    public AdGroup withAdDurationsUs(long[] durationsUs) {
+      Assertions.checkArgument(count == C.LENGTH_UNSET || durationsUs.length <= this.uris.length);
+      if (durationsUs.length < this.uris.length) {
+        durationsUs = copyDurationsUsWithSpaceForAdCount(durationsUs, uris.length);
+      }
+      return new AdGroup(count, states, uris, durationsUs);
+    }
+
+    /**
+     * Returns an instance with all unavailable and available ads marked as skipped. If the ad count
+     * hasn't been set, it will be set to zero.
+     */
+    @CheckResult
+    public AdGroup withAllAdsSkipped() {
+      if (count == C.LENGTH_UNSET) {
+        return new AdGroup(
+            /* count= */ 0,
+            /* states= */ new int[0],
+            /* uris= */ new Uri[0],
+            /* durationsUs= */ new long[0]);
+      }
+      int count = this.states.length;
+      @AdState int[] states = Arrays.copyOf(this.states, count);
+      for (int i = 0; i < count; i++) {
+        if (states[i] == AD_STATE_AVAILABLE || states[i] == AD_STATE_UNAVAILABLE) {
+          states[i] = AD_STATE_SKIPPED;
+        }
+      }
+      return new AdGroup(count, states, uris, durationsUs);
+    }
+
+    @CheckResult
+    private static @AdState int[] copyStatesWithSpaceForAdCount(@AdState int[] states, int count) {
+      int oldStateCount = states.length;
+      int newStateCount = Math.max(count, oldStateCount);
+      states = Arrays.copyOf(states, newStateCount);
+      Arrays.fill(states, oldStateCount, newStateCount, AD_STATE_UNAVAILABLE);
+      return states;
+    }
+
+    @CheckResult
+    private static long[] copyDurationsUsWithSpaceForAdCount(long[] durationsUs, int count) {
+      int oldDurationsUsCount = durationsUs.length;
+      int newDurationsUsCount = Math.max(count, oldDurationsUsCount);
+      durationsUs = Arrays.copyOf(durationsUs, newDurationsUsCount);
+      Arrays.fill(durationsUs, oldDurationsUsCount, newDurationsUsCount, C.TIME_UNSET);
+      return durationsUs;
+    }
+  }
+
+  /** Represents the state of an ad in an ad group. */
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({
+    AD_STATE_UNAVAILABLE,
+    AD_STATE_AVAILABLE,
+    AD_STATE_SKIPPED,
+    AD_STATE_PLAYED,
+    AD_STATE_ERROR,
+  })
+  public @interface AdState {}
+  /** State for an ad that does not yet have a URL. */
+  public static final int AD_STATE_UNAVAILABLE = 0;
+  /** State for an ad that has a URL but has not yet been played. */
+  public static final int AD_STATE_AVAILABLE = 1;
+  /** State for an ad that was skipped. */
+  public static final int AD_STATE_SKIPPED = 2;
+  /** State for an ad that was played in full. */
+  public static final int AD_STATE_PLAYED = 3;
+  /** State for an ad that could not be loaded. */
+  public static final int AD_STATE_ERROR = 4;
+
+  /** Ad playback state with no ads. */
+  public static final AdPlaybackState NONE = new AdPlaybackState();
+
+  /** The number of ad groups. */
   public final int adGroupCount;
   /**
-   * The times of ad groups, in microseconds. A final element with the value
-   * {@link C#TIME_END_OF_SOURCE} indicates a postroll ad.
+   * The times of ad groups, in microseconds. A final element with the value {@link
+   * C#TIME_END_OF_SOURCE} indicates a postroll ad.
    */
   public final long[] adGroupTimesUs;
-  /**
-   * The number of ads in each ad group. An element may be {@link C#LENGTH_UNSET} if the number of
-   * ads is not yet known.
-   */
-  public final int[] adCounts;
-  /**
-   * The number of ads loaded so far in each ad group.
-   */
-  public final int[] adsLoadedCounts;
-  /**
-   * The number of ads played so far in each ad group.
-   */
-  public final int[] adsPlayedCounts;
-  /**
-   * The URI of each ad in each ad group.
-   */
-  public final Uri[][] adUris;
-
-  /**
-   * The content duration in microseconds, if known. {@link C#TIME_UNSET} otherwise.
-   */
-  public long contentDurationUs;
-  /**
-   * The position offset in the first unplayed ad at which to begin playback, in microseconds.
-   */
-  public long adResumePositionUs;
+  /** The ad groups. */
+  public final AdGroup[] adGroups;
+  /** The position offset in the first unplayed ad at which to begin playback, in microseconds. */
+  public final long adResumePositionUs;
+  /** The content duration in microseconds, if known. {@link C#TIME_UNSET} otherwise. */
+  public final long contentDurationUs;
 
   /**
    * Creates a new ad playback state with the specified ad group times.
@@ -66,85 +254,143 @@
    * @param adGroupTimesUs The times of ad groups in microseconds. A final element with the value
    *     {@link C#TIME_END_OF_SOURCE} indicates that there is a postroll ad.
    */
-  public AdPlaybackState(long[] adGroupTimesUs) {
-    this.adGroupTimesUs = adGroupTimesUs;
-    adGroupCount = adGroupTimesUs.length;
-    adsPlayedCounts = new int[adGroupCount];
-    adCounts = new int[adGroupCount];
-    Arrays.fill(adCounts, C.LENGTH_UNSET);
-    adUris = new Uri[adGroupCount][];
-    Arrays.fill(adUris, new Uri[0]);
-    adsLoadedCounts = new int[adGroupTimesUs.length];
+  public AdPlaybackState(long... adGroupTimesUs) {
+    int count = adGroupTimesUs.length;
+    adGroupCount = count;
+    this.adGroupTimesUs = Arrays.copyOf(adGroupTimesUs, count);
+    this.adGroups = new AdGroup[count];
+    for (int i = 0; i < count; i++) {
+      adGroups[i] = new AdGroup();
+    }
+    adResumePositionUs = 0;
     contentDurationUs = C.TIME_UNSET;
   }
 
-  private AdPlaybackState(long[] adGroupTimesUs, int[] adCounts, int[] adsLoadedCounts,
-      int[] adsPlayedCounts, Uri[][] adUris, long contentDurationUs, long adResumePositionUs) {
+  private AdPlaybackState(
+      long[] adGroupTimesUs, AdGroup[] adGroups, long adResumePositionUs, long contentDurationUs) {
+    adGroupCount = adGroups.length;
     this.adGroupTimesUs = adGroupTimesUs;
-    this.adCounts = adCounts;
-    this.adsLoadedCounts = adsLoadedCounts;
-    this.adsPlayedCounts = adsPlayedCounts;
-    this.adUris = adUris;
-    this.contentDurationUs = contentDurationUs;
+    this.adGroups = adGroups;
     this.adResumePositionUs = adResumePositionUs;
-    adGroupCount = adGroupTimesUs.length;
+    this.contentDurationUs = contentDurationUs;
   }
 
   /**
-   * Returns a deep copy of this instance.
+   * Returns the index of the ad group at or before {@code positionUs}, if that ad group is
+   * unplayed. Returns {@link C#INDEX_UNSET} if the ad group at or before {@code positionUs} has no
+   * ads remaining to be played, or if there is no such ad group.
+   *
+   * @param positionUs The position at or before which to find an ad group, in microseconds.
+   * @return The index of the ad group, or {@link C#INDEX_UNSET}.
    */
-  public AdPlaybackState copy() {
-    Uri[][] adUris = new Uri[adGroupTimesUs.length][];
-    for (int i = 0; i < this.adUris.length; i++) {
-      adUris[i] = Arrays.copyOf(this.adUris[i], this.adUris[i].length);
-    }
-    return new AdPlaybackState(Arrays.copyOf(adGroupTimesUs, adGroupCount),
-        Arrays.copyOf(adCounts, adGroupCount), Arrays.copyOf(adsLoadedCounts, adGroupCount),
-        Arrays.copyOf(adsPlayedCounts, adGroupCount), adUris, contentDurationUs,
-        adResumePositionUs);
+  public int getAdGroupIndexForPositionUs(long positionUs) {
+    // Use a linear search as the array elements may not be increasing due to TIME_END_OF_SOURCE.
+    // In practice we expect there to be few ad groups so the search shouldn't be expensive.
+    int index = adGroupTimesUs.length - 1;
+    while (index >= 0
+        && (adGroupTimesUs[index] == C.TIME_END_OF_SOURCE || adGroupTimesUs[index] > positionUs)) {
+      index--;
+    }
+    return index >= 0 && adGroups[index].hasUnplayedAds() ? index : C.INDEX_UNSET;
   }
 
   /**
-   * Sets the number of ads in the specified ad group.
+   * Returns the index of the next ad group after {@code positionUs} that has ads remaining to be
+   * played. Returns {@link C#INDEX_UNSET} if there is no such ad group.
+   *
+   * @param positionUs The position after which to find an ad group, in microseconds.
+   * @return The index of the ad group, or {@link C#INDEX_UNSET}.
    */
-  public void setAdCount(int adGroupIndex, int adCount) {
-    adCounts[adGroupIndex] = adCount;
+  public int getAdGroupIndexAfterPositionUs(long positionUs) {
+    // Use a linear search as the array elements may not be increasing due to TIME_END_OF_SOURCE.
+    // In practice we expect there to be few ad groups so the search shouldn't be expensive.
+    int index = 0;
+    while (index < adGroupTimesUs.length
+        && adGroupTimesUs[index] != C.TIME_END_OF_SOURCE
+        && (positionUs >= adGroupTimesUs[index] || !adGroups[index].hasUnplayedAds())) {
+      index++;
+    }
+    return index < adGroupTimesUs.length ? index : C.INDEX_UNSET;
   }
 
   /**
-   * Adds an ad to the specified ad group.
+   * Returns an instance with the number of ads in {@code adGroupIndex} resolved to {@code adCount}.
+   * The ad count must be greater than zero.
    */
-  public void addAdUri(int adGroupIndex, Uri uri) {
-    int adIndexInAdGroup = adUris[adGroupIndex].length;
-    adUris[adGroupIndex] = Arrays.copyOf(adUris[adGroupIndex], adIndexInAdGroup + 1);
-    adUris[adGroupIndex][adIndexInAdGroup] = uri;
-    adsLoadedCounts[adGroupIndex]++;
+  @CheckResult
+  public AdPlaybackState withAdCount(int adGroupIndex, int adCount) {
+    Assertions.checkArgument(adCount > 0);
+    if (adGroups[adGroupIndex].count == adCount) {
+      return this;
+    }
+    AdGroup[] adGroups = Arrays.copyOf(this.adGroups, this.adGroups.length);
+    adGroups[adGroupIndex] = this.adGroups[adGroupIndex].withAdCount(adCount);
+    return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
   }
 
-  /**
-   * Marks the last ad in the specified ad group as played.
-   */
-  public void playedAd(int adGroupIndex) {
-    adResumePositionUs = 0;
-    adsPlayedCounts[adGroupIndex]++;
+  /** Returns an instance with the specified ad URI. */
+  @CheckResult
+  public AdPlaybackState withAdUri(int adGroupIndex, int adIndexInAdGroup, Uri uri) {
+    AdGroup[] adGroups = Arrays.copyOf(this.adGroups, this.adGroups.length);
+    adGroups[adGroupIndex] = adGroups[adGroupIndex].withAdUri(uri, adIndexInAdGroup);
+    return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
+  }
+
+  /** Returns an instance with the specified ad marked as played. */
+  @CheckResult
+  public AdPlaybackState withPlayedAd(int adGroupIndex, int adIndexInAdGroup) {
+    AdGroup[] adGroups = Arrays.copyOf(this.adGroups, this.adGroups.length);
+    adGroups[adGroupIndex] = adGroups[adGroupIndex].withAdState(AD_STATE_PLAYED, adIndexInAdGroup);
+    return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
+  }
+
+  /** Returns an instance with the specified ad marked as having a load error. */
+  @CheckResult
+  public AdPlaybackState withAdLoadError(int adGroupIndex, int adIndexInAdGroup) {
+    AdGroup[] adGroups = Arrays.copyOf(this.adGroups, this.adGroups.length);
+    adGroups[adGroupIndex] = adGroups[adGroupIndex].withAdState(AD_STATE_ERROR, adIndexInAdGroup);
+    return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
   }
 
   /**
-   * Marks all ads in the specified ad group as played.
+   * Returns an instance with all ads in the specified ad group skipped (except for those already
+   * marked as played or in the error state).
    */
-  public void playedAdGroup(int adGroupIndex) {
-    adResumePositionUs = 0;
-    if (adCounts[adGroupIndex] == C.LENGTH_UNSET) {
-      adCounts[adGroupIndex] = 0;
+  @CheckResult
+  public AdPlaybackState withSkippedAdGroup(int adGroupIndex) {
+    AdGroup[] adGroups = Arrays.copyOf(this.adGroups, this.adGroups.length);
+    adGroups[adGroupIndex] = adGroups[adGroupIndex].withAllAdsSkipped();
+    return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
+  }
+
+  /** Returns an instance with the specified ad durations, in microseconds. */
+  @CheckResult
+  public AdPlaybackState withAdDurationsUs(long[][] adDurationUs) {
+    AdGroup[] adGroups = Arrays.copyOf(this.adGroups, this.adGroups.length);
+    for (int adGroupIndex = 0; adGroupIndex < adGroupCount; adGroupIndex++) {
+      adGroups[adGroupIndex] = adGroups[adGroupIndex].withAdDurationsUs(adDurationUs[adGroupIndex]);
     }
-    adsPlayedCounts[adGroupIndex] = adCounts[adGroupIndex];
+    return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
   }
 
-  /**
-   * Sets the position offset in the first unplayed ad at which to begin playback, in microseconds.
-   */
-  public void setAdResumePositionUs(long adResumePositionUs) {
-    this.adResumePositionUs = adResumePositionUs;
+  /** Returns an instance with the specified ad resume position, in microseconds. */
+  @CheckResult
+  public AdPlaybackState withAdResumePositionUs(long adResumePositionUs) {
+    if (this.adResumePositionUs == adResumePositionUs) {
+      return this;
+    } else {
+      return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
+    }
+  }
+
+  /** Returns an instance with the specified content duration, in microseconds. */
+  @CheckResult
+  public AdPlaybackState withContentDurationUs(long contentDurationUs) {
+    if (this.contentDurationUs == contentDurationUs) {
+      return this;
+    } else {
+      return new AdPlaybackState(adGroupTimesUs, adGroups, adResumePositionUs, contentDurationUs);
+    }
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
index 241750a21f..6295ca4229 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsLoader.java
@@ -16,27 +16,28 @@
 package com.google.android.exoplayer2.source.ads;
 
 import android.view.ViewGroup;
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import java.io.IOException;
 
 /**
  * Interface for loaders of ads, which can be used with {@link AdsMediaSource}.
- * <p>
- * Ad loaders notify the {@link AdsMediaSource} about events via {@link EventListener}. In
+ *
+ * <p>Ad loaders notify the {@link AdsMediaSource} about events via {@link EventListener}. In
  * particular, implementations must call {@link EventListener#onAdPlaybackState(AdPlaybackState)}
  * with a new copy of the current {@link AdPlaybackState} whenever further information about ads
  * becomes known (for example, when an ad media URI is available, or an ad has played to the end).
- * <p>
- * {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} will be called when the ads media
+ *
+ * <p>{@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} will be called when the ads media
  * source first initializes, at which point the loader can request ads. If the player enters the
  * background, {@link #detachPlayer()} will be called. Loaders should maintain any ad playback state
  * in preparation for a later call to {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)}. If
- * an ad is playing when the player is detached, store the current playback position via
- * {@link AdPlaybackState#setAdResumePositionUs(long)}.
- * <p>
- * If {@link EventListener#onAdPlaybackState(AdPlaybackState)} has been called, the implementation
- * of {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} should invoke the same listener to
- * provide the existing playback state to the new player.
+ * an ad is playing when the player is detached, update the ad playback state with the current
+ * playback position using {@link AdPlaybackState#withAdResumePositionUs(long)}.
+ *
+ * <p>If {@link EventListener#onAdPlaybackState(AdPlaybackState)} has been called, the
+ * implementation of {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)} should invoke the
+ * same listener to provide the existing playback state to the new player.
  */
 public interface AdsLoader {
 
@@ -53,11 +54,19 @@
     void onAdPlaybackState(AdPlaybackState adPlaybackState);
 
     /**
-     * Called when there was an error loading ads.
+     * Called when there was an error loading ads. The loader will skip the problematic ad(s).
+     *
+     * @param error The error.
+     */
+    void onAdLoadError(IOException error);
+
+    /**
+     * Called when an unexpected internal error is encountered while loading ads. The loader will
+     * skip all remaining ads, as the error is not recoverable.
      *
      * @param error The error.
      */
-    void onLoadError(IOException error);
+    void onInternalAdLoadError(RuntimeException error);
 
     /**
      * Called when the user clicks through an ad (for example, following a 'learn more' link).
@@ -71,6 +80,15 @@
 
   }
 
+  /**
+   * Sets the supported content types for ad media. Must be called before the first call to
+   * {@link #attachPlayer(ExoPlayer, EventListener, ViewGroup)}. Subsequent calls may be ignored.
+   *
+   * @param contentTypes The supported content types for ad media. Each element must be one of
+   *     {@link C#TYPE_DASH}, {@link C#TYPE_HLS}, {@link C#TYPE_SS} and {@link C#TYPE_OTHER}.
+   */
+  void setSupportedContentTypes(@C.ContentType int... contentTypes);
+
   /**
    * Attaches a player that will play ads loaded using this instance. Called on the main thread by
    * {@link AdsMediaSource}.
@@ -93,4 +111,13 @@
    */
   void release();
 
+  /**
+   * Notifies the ads loader that the player was not able to prepare media for a given ad.
+   * Implementations should update the ad playback state as the specified ad has failed to load.
+   *
+   * @param adGroupIndex The index of the ad group.
+   * @param adIndexInAdGroup The index of the ad in the ad group.
+   * @param exception The preparation error.
+   */
+  void handlePrepareError(int adGroupIndex, int adIndexInAdGroup, IOException exception);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
index 18aa8a63e7..64bab7ed96 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/AdsMediaSource.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source.ads;
 
+import android.net.Uri;
 import android.os.Handler;
 import android.os.Looper;
 import android.support.annotation.Nullable;
@@ -23,37 +24,70 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.extractor.DefaultExtractorsFactory;
+import com.google.android.exoplayer2.source.CompositeMediaSource;
+import com.google.android.exoplayer2.source.DeferredMediaPeriod;
 import com.google.android.exoplayer2.source.ExtractorMediaSource;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.MediaSourceEventListener;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
-/**
- * A {@link MediaSource} that inserts ads linearly with a provided content media source.
- */
-public final class AdsMediaSource implements MediaSource {
+/** A {@link MediaSource} that inserts ads linearly with a provided content media source. */
+public final class AdsMediaSource extends CompositeMediaSource<MediaPeriodId> {
 
-  /**
-   * Listener for events relating to ad loading.
-   */
-  public interface AdsListener {
+  /** Factory for creating {@link MediaSource}s to play ad media. */
+  public interface MediaSourceFactory {
+
+    /**
+     * Creates a new {@link MediaSource} for loading the ad media with the specified {@code uri}.
+     *
+     * @param uri The URI of the media or manifest to play.
+     * @param handler A handler for listener events. May be null if delivery of events is not
+     *     required.
+     * @param listener A listener for events. May be null if delivery of events is not required.
+     * @return The new media source.
+     */
+    MediaSource createMediaSource(
+        Uri uri, @Nullable Handler handler, @Nullable MediaSourceEventListener listener);
 
     /**
-     * Called if there was an error loading ads. The media source will load the content without ads
-     * if ads can't be loaded, so listen for this event if you need to implement additional handling
-     * (for example, stopping the player).
+     * Returns the content types supported by media sources created by this factory. Each element
+     * should be one of {@link C#TYPE_DASH}, {@link C#TYPE_SS}, {@link C#TYPE_HLS} or {@link
+     * C#TYPE_OTHER}.
+     *
+     * @return The content types supported by media sources created by this factory.
+     */
+    int[] getSupportedTypes();
+  }
+
+  /** Listener for ads media source events. */
+  public interface EventListener extends MediaSourceEventListener {
+
+    /**
+     * Called if there was an error loading one or more ads. The loader will skip the problematic
+     * ad(s).
      *
      * @param error The error.
      */
     void onAdLoadError(IOException error);
 
+    /**
+     * Called when an unexpected internal error is encountered while loading ads. The loader will
+     * skip all remaining ads, as the error is not recoverable.
+     *
+     * @param error The error.
+     */
+    void onInternalAdLoadError(RuntimeException error);
+
     /**
      * Called when the user clicks through an ad (for example, following a 'learn more' link).
      */
@@ -69,23 +103,17 @@
   private static final String TAG = "AdsMediaSource";
 
   private final MediaSource contentMediaSource;
-  private final DataSource.Factory dataSourceFactory;
+  private final MediaSourceFactory adMediaSourceFactory;
   private final AdsLoader adsLoader;
   private final ViewGroup adUiViewGroup;
+  @Nullable private final Handler eventHandler;
+  @Nullable private final EventListener eventListener;
   private final Handler mainHandler;
-  private final ComponentListener componentListener;
-  private final Map<MediaPeriod, MediaSource> adMediaSourceByMediaPeriod;
+  private final Map<MediaSource, List<DeferredMediaPeriod>> deferredMediaPeriodByAdMediaSource;
   private final Timeline.Period period;
-  @Nullable
-  private final Handler eventHandler;
-  @Nullable
-  private final AdsListener eventListener;
-
-  private Handler playerHandler;
-  private ExoPlayer player;
-  private volatile boolean released;
 
   // Accessed on the player thread.
+  private ComponentListener componentListener;
   private Timeline contentTimeline;
   private Object contentManifest;
   private AdPlaybackState adPlaybackState;
@@ -94,22 +122,31 @@
   private MediaSource.Listener listener;
 
   /**
-   * Constructs a new source that inserts ads linearly with the content specified by
-   * {@code contentMediaSource}.
+   * Constructs a new source that inserts ads linearly with the content specified by {@code
+   * contentMediaSource}. Ad media is loaded using {@link ExtractorMediaSource}.
    *
    * @param contentMediaSource The {@link MediaSource} providing the content to play.
    * @param dataSourceFactory Factory for data sources used to load ad media.
    * @param adsLoader The loader for ads.
    * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
    */
-  public AdsMediaSource(MediaSource contentMediaSource, DataSource.Factory dataSourceFactory,
-      AdsLoader adsLoader, ViewGroup adUiViewGroup) {
-    this(contentMediaSource, dataSourceFactory, adsLoader, adUiViewGroup, null, null);
+  public AdsMediaSource(
+      MediaSource contentMediaSource,
+      DataSource.Factory dataSourceFactory,
+      AdsLoader adsLoader,
+      ViewGroup adUiViewGroup) {
+    this(
+        contentMediaSource,
+        dataSourceFactory,
+        adsLoader,
+        adUiViewGroup,
+        /* eventHandler= */ null,
+        /* eventListener= */ null);
   }
 
   /**
-   * Constructs a new source that inserts ads linearly with the content specified by
-   * {@code contentMediaSource}.
+   * Constructs a new source that inserts ads linearly with the content specified by {@code
+   * contentMediaSource}. Ad media is loaded using {@link ExtractorMediaSource}.
    *
    * @param contentMediaSource The {@link MediaSource} providing the content to play.
    * @param dataSourceFactory Factory for data sources used to load ad media.
@@ -118,35 +155,62 @@ public AdsMediaSource(MediaSource contentMediaSource, DataSource.Factory dataSou
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
    */
-  public AdsMediaSource(MediaSource contentMediaSource, DataSource.Factory dataSourceFactory,
-      AdsLoader adsLoader, ViewGroup adUiViewGroup, @Nullable Handler eventHandler,
-      @Nullable AdsListener eventListener) {
+  public AdsMediaSource(
+      MediaSource contentMediaSource,
+      DataSource.Factory dataSourceFactory,
+      AdsLoader adsLoader,
+      ViewGroup adUiViewGroup,
+      @Nullable Handler eventHandler,
+      @Nullable EventListener eventListener) {
+    this(
+        contentMediaSource,
+        new ExtractorMediaSource.Factory(dataSourceFactory),
+        adsLoader,
+        adUiViewGroup,
+        eventHandler,
+        eventListener);
+  }
+
+  /**
+   * Constructs a new source that inserts ads linearly with the content specified by {@code
+   * contentMediaSource}.
+   *
+   * @param contentMediaSource The {@link MediaSource} providing the content to play.
+   * @param adMediaSourceFactory Factory for media sources used to load ad media.
+   * @param adsLoader The loader for ads.
+   * @param adUiViewGroup A {@link ViewGroup} on top of the player that will show any ad UI.
+   * @param eventHandler A handler for events. May be null if delivery of events is not required.
+   * @param eventListener A listener of events. May be null if delivery of events is not required.
+   */
+  public AdsMediaSource(
+      MediaSource contentMediaSource,
+      MediaSourceFactory adMediaSourceFactory,
+      AdsLoader adsLoader,
+      ViewGroup adUiViewGroup,
+      @Nullable Handler eventHandler,
+      @Nullable EventListener eventListener) {
     this.contentMediaSource = contentMediaSource;
-    this.dataSourceFactory = dataSourceFactory;
+    this.adMediaSourceFactory = adMediaSourceFactory;
     this.adsLoader = adsLoader;
     this.adUiViewGroup = adUiViewGroup;
     this.eventHandler = eventHandler;
     this.eventListener = eventListener;
     mainHandler = new Handler(Looper.getMainLooper());
-    componentListener = new ComponentListener();
-    adMediaSourceByMediaPeriod = new HashMap<>();
+    deferredMediaPeriodByAdMediaSource = new HashMap<>();
     period = new Timeline.Period();
     adGroupMediaSources = new MediaSource[0][];
     adDurationsUs = new long[0][];
+    adsLoader.setSupportedContentTypes(adMediaSourceFactory.getSupportedTypes());
   }
 
   @Override
   public void prepareSource(final ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    super.prepareSource(player, isTopLevelSource, listener);
     Assertions.checkArgument(isTopLevelSource);
+    final ComponentListener componentListener = new ComponentListener();
     this.listener = listener;
-    this.player = player;
-    playerHandler = new Handler();
-    contentMediaSource.prepareSource(player, false, new Listener() {
-      @Override
-      public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
-        AdsMediaSource.this.onContentSourceInfoRefreshed(timeline, manifest);
-      }
-    });
+    this.componentListener = componentListener;
+    prepareChildSource(new MediaPeriodId(/* periodIndex= */ 0), contentMediaSource);
     mainHandler.post(new Runnable() {
       @Override
       public void run() {
@@ -155,27 +219,15 @@ public void run() {
     });
   }
 
-  @Override
-  public void maybeThrowSourceInfoRefreshError() throws IOException {
-    contentMediaSource.maybeThrowSourceInfoRefreshError();
-    for (MediaSource[] mediaSources : adGroupMediaSources) {
-      for (MediaSource mediaSource : mediaSources) {
-        if (mediaSource != null) {
-          mediaSource.maybeThrowSourceInfoRefreshError();
-        }
-      }
-    }
-  }
-
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     if (adPlaybackState.adGroupCount > 0 && id.isAd()) {
-      final int adGroupIndex = id.adGroupIndex;
-      final int adIndexInAdGroup = id.adIndexInAdGroup;
+      int adGroupIndex = id.adGroupIndex;
+      int adIndexInAdGroup = id.adIndexInAdGroup;
       if (adGroupMediaSources[adGroupIndex].length <= adIndexInAdGroup) {
-        MediaSource adMediaSource = new ExtractorMediaSource(
-            adPlaybackState.adUris[id.adGroupIndex][id.adIndexInAdGroup], dataSourceFactory,
-            new DefaultExtractorsFactory(), mainHandler, componentListener);
+        Uri adUri = adPlaybackState.adGroups[id.adGroupIndex].uris[id.adIndexInAdGroup];
+        MediaSource adMediaSource =
+            adMediaSourceFactory.createMediaSource(adUri, eventHandler, eventListener);
         int oldAdCount = adGroupMediaSources[id.adGroupIndex].length;
         if (adIndexInAdGroup >= oldAdCount) {
           int adCount = adIndexInAdGroup + 1;
@@ -185,43 +237,56 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
           Arrays.fill(adDurationsUs[adGroupIndex], oldAdCount, adCount, C.TIME_UNSET);
         }
         adGroupMediaSources[adGroupIndex][adIndexInAdGroup] = adMediaSource;
-        adMediaSource.prepareSource(player, false, new Listener() {
-          @Override
-          public void onSourceInfoRefreshed(MediaSource source, Timeline timeline,
-              Object manifest) {
-            onAdSourceInfoRefreshed(adGroupIndex, adIndexInAdGroup, timeline);
-          }
-        });
+        deferredMediaPeriodByAdMediaSource.put(adMediaSource, new ArrayList<DeferredMediaPeriod>());
+        prepareChildSource(id, adMediaSource);
       }
       MediaSource mediaSource = adGroupMediaSources[adGroupIndex][adIndexInAdGroup];
-      MediaPeriod mediaPeriod = mediaSource.createPeriod(new MediaPeriodId(0), allocator);
-      adMediaSourceByMediaPeriod.put(mediaPeriod, mediaSource);
-      return mediaPeriod;
+      DeferredMediaPeriod deferredMediaPeriod =
+          new DeferredMediaPeriod(
+              mediaSource,
+              new MediaPeriodId(/* periodIndex= */ 0, id.windowSequenceNumber),
+              allocator);
+      deferredMediaPeriod.setPrepareErrorListener(
+          new AdPrepareErrorListener(adGroupIndex, adIndexInAdGroup));
+      List<DeferredMediaPeriod> mediaPeriods = deferredMediaPeriodByAdMediaSource.get(mediaSource);
+      if (mediaPeriods == null) {
+        deferredMediaPeriod.createPeriod();
+      } else {
+        // Keep track of the deferred media period so it can be populated with the real media period
+        // when the source's info becomes available.
+        mediaPeriods.add(deferredMediaPeriod);
+      }
+      return deferredMediaPeriod;
     } else {
-      return contentMediaSource.createPeriod(id, allocator);
+      DeferredMediaPeriod mediaPeriod = new DeferredMediaPeriod(contentMediaSource, id, allocator);
+      mediaPeriod.createPeriod();
+      return mediaPeriod;
     }
   }
 
   @Override
   public void releasePeriod(MediaPeriod mediaPeriod) {
-    if (adMediaSourceByMediaPeriod.containsKey(mediaPeriod)) {
-      adMediaSourceByMediaPeriod.remove(mediaPeriod).releasePeriod(mediaPeriod);
-    } else {
-      contentMediaSource.releasePeriod(mediaPeriod);
+    DeferredMediaPeriod deferredMediaPeriod = (DeferredMediaPeriod) mediaPeriod;
+    List<DeferredMediaPeriod> mediaPeriods =
+        deferredMediaPeriodByAdMediaSource.get(deferredMediaPeriod.mediaSource);
+    if (mediaPeriods != null) {
+      mediaPeriods.remove(deferredMediaPeriod);
     }
+    deferredMediaPeriod.releasePeriod();
   }
 
   @Override
   public void releaseSource() {
-    released = true;
-    contentMediaSource.releaseSource();
-    for (MediaSource[] mediaSources : adGroupMediaSources) {
-      for (MediaSource mediaSource : mediaSources) {
-        if (mediaSource != null) {
-          mediaSource.releaseSource();
-        }
-      }
-    }
+    super.releaseSource();
+    componentListener.release();
+    componentListener = null;
+    deferredMediaPeriodByAdMediaSource.clear();
+    contentTimeline = null;
+    contentManifest = null;
+    adPlaybackState = null;
+    adGroupMediaSources = new MediaSource[0][];
+    adDurationsUs = new long[0][];
+    listener = null;
     mainHandler.post(new Runnable() {
       @Override
       public void run() {
@@ -230,6 +295,21 @@ public void run() {
     });
   }
 
+  @Override
+  protected void onChildSourceInfoRefreshed(
+      MediaPeriodId mediaPeriodId,
+      MediaSource mediaSource,
+      Timeline timeline,
+      @Nullable Object manifest) {
+    if (mediaPeriodId.isAd()) {
+      int adGroupIndex = mediaPeriodId.adGroupIndex;
+      int adIndexInAdGroup = mediaPeriodId.adIndexInAdGroup;
+      onAdSourceInfoRefreshed(mediaSource, adGroupIndex, adIndexInAdGroup, timeline);
+    } else {
+      onContentSourceInfoRefreshed(timeline, manifest);
+    }
+  }
+
   // Internal methods.
 
   private void onAdPlaybackState(AdPlaybackState adPlaybackState) {
@@ -243,48 +323,56 @@ private void onAdPlaybackState(AdPlaybackState adPlaybackState) {
     maybeUpdateSourceInfo();
   }
 
-  private void onLoadError(final IOException error) {
-    Log.w(TAG, "Ad load error", error);
-    if (eventHandler != null && eventListener != null) {
-      eventHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          if (!released) {
-            eventListener.onAdLoadError(error);
-          }
-        }
-      });
-    }
-  }
-
   private void onContentSourceInfoRefreshed(Timeline timeline, Object manifest) {
     contentTimeline = timeline;
     contentManifest = manifest;
     maybeUpdateSourceInfo();
   }
 
-  private void onAdSourceInfoRefreshed(int adGroupIndex, int adIndexInAdGroup, Timeline timeline) {
+  private void onAdSourceInfoRefreshed(MediaSource mediaSource, int adGroupIndex,
+      int adIndexInAdGroup, Timeline timeline) {
     Assertions.checkArgument(timeline.getPeriodCount() == 1);
     adDurationsUs[adGroupIndex][adIndexInAdGroup] = timeline.getPeriod(0, period).getDurationUs();
+    if (deferredMediaPeriodByAdMediaSource.containsKey(mediaSource)) {
+      List<DeferredMediaPeriod> mediaPeriods = deferredMediaPeriodByAdMediaSource.get(mediaSource);
+      for (int i = 0; i < mediaPeriods.size(); i++) {
+        mediaPeriods.get(i).createPeriod();
+      }
+      deferredMediaPeriodByAdMediaSource.remove(mediaSource);
+    }
     maybeUpdateSourceInfo();
   }
 
   private void maybeUpdateSourceInfo() {
     if (adPlaybackState != null && contentTimeline != null) {
-      Timeline timeline = adPlaybackState.adGroupCount == 0 ? contentTimeline
-          : new SinglePeriodAdTimeline(contentTimeline, adPlaybackState.adGroupTimesUs,
-              adPlaybackState.adCounts, adPlaybackState.adsLoadedCounts,
-              adPlaybackState.adsPlayedCounts, adDurationsUs, adPlaybackState.adResumePositionUs,
-              adPlaybackState.contentDurationUs);
+      adPlaybackState = adPlaybackState.withAdDurationsUs(adDurationsUs);
+      Timeline timeline =
+          adPlaybackState.adGroupCount == 0
+              ? contentTimeline
+              : new SinglePeriodAdTimeline(contentTimeline, adPlaybackState);
       listener.onSourceInfoRefreshed(this, timeline, contentManifest);
     }
   }
 
-  /**
-   * Listener for component events. All methods are called on the main thread.
-   */
-  private final class ComponentListener implements AdsLoader.EventListener,
-      ExtractorMediaSource.EventListener {
+  /** Listener for component events. All methods are called on the main thread. */
+  private final class ComponentListener implements AdsLoader.EventListener {
+
+    private final Handler playerHandler;
+    private volatile boolean released;
+
+    /**
+     * Creates new listener which forwards ad playback states on the creating thread and all other
+     * events on the external event listener thread.
+     */
+    public ComponentListener() {
+      playerHandler = new Handler();
+    }
+
+    /** Releases the component listener. */
+    public void release() {
+      released = true;
+      playerHandler.removeCallbacksAndMessages(null);
+    }
 
     @Override
     public void onAdPlaybackState(final AdPlaybackState adPlaybackState) {
@@ -304,6 +392,9 @@ public void run() {
 
     @Override
     public void onAdClicked() {
+      if (released) {
+        return;
+      }
       if (eventHandler != null && eventListener != null) {
         eventHandler.post(new Runnable() {
           @Override
@@ -318,6 +409,9 @@ public void run() {
 
     @Override
     public void onAdTapped() {
+      if (released) {
+        return;
+      }
       if (eventHandler != null && eventListener != null) {
         eventHandler.post(new Runnable() {
           @Override
@@ -331,21 +425,63 @@ public void run() {
     }
 
     @Override
-    public void onLoadError(final IOException error) {
+    public void onAdLoadError(final IOException error) {
       if (released) {
         return;
       }
-      playerHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          if (released) {
-            return;
-          }
-          AdsMediaSource.this.onLoadError(error);
-        }
-      });
+      Log.w(TAG, "Ad load error", error);
+      if (eventHandler != null && eventListener != null) {
+        eventHandler.post(
+            new Runnable() {
+              @Override
+              public void run() {
+                if (!released) {
+                  eventListener.onAdLoadError(error);
+                }
+              }
+            });
+      }
     }
 
+    @Override
+    public void onInternalAdLoadError(final RuntimeException error) {
+      if (released) {
+        return;
+      }
+      Log.w(TAG, "Internal ad load error", error);
+      if (eventHandler != null && eventListener != null) {
+        eventHandler.post(
+            new Runnable() {
+              @Override
+              public void run() {
+                if (!released) {
+                  eventListener.onInternalAdLoadError(error);
+                }
+              }
+            });
+      }
+    }
   }
 
+  private final class AdPrepareErrorListener implements DeferredMediaPeriod.PrepareErrorListener {
+
+    private final int adGroupIndex;
+    private final int adIndexInAdGroup;
+
+    public AdPrepareErrorListener(int adGroupIndex, int adIndexInAdGroup) {
+      this.adGroupIndex = adGroupIndex;
+      this.adIndexInAdGroup = adIndexInAdGroup;
+    }
+
+    @Override
+    public void onPrepareError(final IOException exception) {
+      mainHandler.post(
+          new Runnable() {
+            @Override
+            public void run() {
+              adsLoader.handlePrepareError(adGroupIndex, adIndexInAdGroup, exception);
+            }
+          });
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
index 0a04c9ab4b..ec0d6cb2fe 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/ads/SinglePeriodAdTimeline.java
@@ -25,54 +25,32 @@
  */
 /* package */ final class SinglePeriodAdTimeline extends ForwardingTimeline {
 
-  private final long[] adGroupTimesUs;
-  private final int[] adCounts;
-  private final int[] adsLoadedCounts;
-  private final int[] adsPlayedCounts;
-  private final long[][] adDurationsUs;
-  private final long adResumePositionUs;
-  private final long contentDurationUs;
+  private final AdPlaybackState adPlaybackState;
 
   /**
-   * Creates a new timeline with a single period containing the specified ads.
+   * Creates a new timeline with a single period containing ads.
    *
    * @param contentTimeline The timeline of the content alongside which ads will be played. It must
    *     have one window and one period.
-   * @param adGroupTimesUs The times of ad groups relative to the start of the period, in
-   *     microseconds. A final element with the value {@link C#TIME_END_OF_SOURCE} indicates that
-   *     the period has a postroll ad.
-   * @param adCounts The number of ads in each ad group. An element may be {@link C#LENGTH_UNSET}
-   *     if the number of ads is not yet known.
-   * @param adsLoadedCounts The number of ads loaded so far in each ad group.
-   * @param adsPlayedCounts The number of ads played so far in each ad group.
-   * @param adDurationsUs The duration of each ad in each ad group, in microseconds. An element
-   *     may be {@link C#TIME_UNSET} if the duration is not yet known.
-   * @param adResumePositionUs The position offset in the earliest unplayed ad at which to begin
-   *     playback, in microseconds.
-   * @param contentDurationUs The content duration in microseconds, if known. {@link C#TIME_UNSET}
-   *     otherwise.
+   * @param adPlaybackState The state of the period's ads.
    */
-  public SinglePeriodAdTimeline(Timeline contentTimeline, long[] adGroupTimesUs, int[] adCounts,
-      int[] adsLoadedCounts, int[] adsPlayedCounts, long[][] adDurationsUs, long adResumePositionUs,
-      long contentDurationUs) {
+  public SinglePeriodAdTimeline(Timeline contentTimeline, AdPlaybackState adPlaybackState) {
     super(contentTimeline);
     Assertions.checkState(contentTimeline.getPeriodCount() == 1);
     Assertions.checkState(contentTimeline.getWindowCount() == 1);
-    this.adGroupTimesUs = adGroupTimesUs;
-    this.adCounts = adCounts;
-    this.adsLoadedCounts = adsLoadedCounts;
-    this.adsPlayedCounts = adsPlayedCounts;
-    this.adDurationsUs = adDurationsUs;
-    this.adResumePositionUs = adResumePositionUs;
-    this.contentDurationUs = contentDurationUs;
+    this.adPlaybackState = adPlaybackState;
   }
 
   @Override
   public Period getPeriod(int periodIndex, Period period, boolean setIds) {
     timeline.getPeriod(periodIndex, period, setIds);
-    period.set(period.id, period.uid, period.windowIndex, period.durationUs,
-        period.getPositionInWindowUs(), adGroupTimesUs, adCounts, adsLoadedCounts, adsPlayedCounts,
-        adDurationsUs, adResumePositionUs);
+    period.set(
+        period.id,
+        period.uid,
+        period.windowIndex,
+        period.durationUs,
+        period.getPositionInWindowUs(),
+        adPlaybackState);
     return period;
   }
 
@@ -81,7 +59,7 @@ public Window getWindow(int windowIndex, Window window, boolean setIds,
       long defaultPositionProjectionUs) {
     window = super.getWindow(windowIndex, window, setIds, defaultPositionProjectionUs);
     if (window.durationUs == C.TIME_UNSET) {
-      window.durationUs = contentDurationUs;
+      window.durationUs = adPlaybackState.contentDurationUs;
     }
     return window;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java
index 62c07ee248..c8ebc02434 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/BaseMediaChunk.java
@@ -37,9 +37,15 @@
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
    * @param chunkIndex The index of the chunk.
    */
-  public BaseMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
-      int chunkIndex) {
+  public BaseMediaChunk(
+      DataSource dataSource,
+      DataSpec dataSpec,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long startTimeUs,
+      long endTimeUs,
+      long chunkIndex) {
     super(dataSource, dataSpec, trackFormat, trackSelectionReason, trackSelectionData, startTimeUs,
         endTimeUs, chunkIndex);
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
index bb51ae074e..7096c84c5e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSampleStream.java
@@ -15,22 +15,24 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
+import android.support.annotation.Nullable;
 import android.util.Log;
-
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleQueue;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Collections;
-import java.util.LinkedList;
 import java.util.List;
 
 /**
@@ -40,10 +42,23 @@
 public class ChunkSampleStream<T extends ChunkSource> implements SampleStream, SequenceableLoader,
     Loader.Callback<Chunk>, Loader.ReleaseCallback {
 
+  /** A callback to be notified when a sample stream has finished being released. */
+  public interface ReleaseCallback<T extends ChunkSource> {
+
+    /**
+     * Called when the {@link ChunkSampleStream} has finished being released.
+     *
+     * @param chunkSampleStream The released sample stream.
+     */
+    void onSampleStreamReleased(ChunkSampleStream<T> chunkSampleStream);
+  }
+
   private static final String TAG = "ChunkSampleStream";
 
-  private final int primaryTrackType;
+  public final int primaryTrackType;
+
   private final int[] embeddedTrackTypes;
+  private final Format[] embeddedTrackFormats;
   private final boolean[] embeddedTracksSelected;
   private final T chunkSource;
   private final SequenceableLoader.Callback<ChunkSampleStream<T>> callback;
@@ -51,21 +66,24 @@
   private final int minLoadableRetryCount;
   private final Loader loader;
   private final ChunkHolder nextChunkHolder;
-  private final LinkedList<BaseMediaChunk> mediaChunks;
+  private final ArrayList<BaseMediaChunk> mediaChunks;
   private final List<BaseMediaChunk> readOnlyMediaChunks;
   private final SampleQueue primarySampleQueue;
   private final SampleQueue[] embeddedSampleQueues;
   private final BaseMediaChunkOutput mediaChunkOutput;
 
   private Format primaryDownstreamTrackFormat;
+  private @Nullable ReleaseCallback<T> releaseCallback;
   private long pendingResetPositionUs;
-  /* package */ long lastSeekPositionUs;
+  private long lastSeekPositionUs;
+  /* package */ long decodeOnlyUntilPositionUs;
   /* package */ boolean loadingFinished;
 
   /**
-   * @param primaryTrackType The type of the primary track. One of the {@link C}
-   *     {@code TRACK_TYPE_*} constants.
+   * @param primaryTrackType The type of the primary track. One of the {@link C} {@code
+   *     TRACK_TYPE_*} constants.
    * @param embeddedTrackTypes The types of any embedded tracks, or null.
+   * @param embeddedTrackFormats The formats of the embedded tracks, or null.
    * @param chunkSource A {@link ChunkSource} from which chunks to load are obtained.
    * @param callback An {@link Callback} for the stream.
    * @param allocator An {@link Allocator} from which allocations can be obtained.
@@ -74,18 +92,26 @@
    *     before propagating an error.
    * @param eventDispatcher A dispatcher to notify of events.
    */
-  public ChunkSampleStream(int primaryTrackType, int[] embeddedTrackTypes, T chunkSource,
-      Callback<ChunkSampleStream<T>> callback, Allocator allocator, long positionUs,
-      int minLoadableRetryCount, EventDispatcher eventDispatcher) {
+  public ChunkSampleStream(
+      int primaryTrackType,
+      int[] embeddedTrackTypes,
+      Format[] embeddedTrackFormats,
+      T chunkSource,
+      Callback<ChunkSampleStream<T>> callback,
+      Allocator allocator,
+      long positionUs,
+      int minLoadableRetryCount,
+      EventDispatcher eventDispatcher) {
     this.primaryTrackType = primaryTrackType;
     this.embeddedTrackTypes = embeddedTrackTypes;
+    this.embeddedTrackFormats = embeddedTrackFormats;
     this.chunkSource = chunkSource;
     this.callback = callback;
     this.eventDispatcher = eventDispatcher;
     this.minLoadableRetryCount = minLoadableRetryCount;
     loader = new Loader("Loader:ChunkSampleStream");
     nextChunkHolder = new ChunkHolder();
-    mediaChunks = new LinkedList<>();
+    mediaChunks = new ArrayList<>();
     readOnlyMediaChunks = Collections.unmodifiableList(mediaChunks);
 
     int embeddedTrackCount = embeddedTrackTypes == null ? 0 : embeddedTrackTypes.length;
@@ -110,20 +136,23 @@ public ChunkSampleStream(int primaryTrackType, int[] embeddedTrackTypes, T chunk
     lastSeekPositionUs = positionUs;
   }
 
-  // TODO: Generalize this method to also discard from the primary sample queue and stop discarding
-  // from this queue in readData and skipData. This will cause samples to be kept in the queue until
-  // they've been rendered, rather than being discarded as soon as they're read by the renderer.
-  // This will make in-buffer seeks more likely when seeking slightly forward from the current
-  // position. This change will need handling with care, in particular when considering removal of
-  // chunks from the front of the mediaChunks list.
   /**
-   * Discards buffered media for embedded tracks, up to the specified position.
+   * Discards buffered media up to the specified position.
    *
    * @param positionUs The position to discard up to, in microseconds.
+   * @param toKeyframe If true then for each track discards samples up to the keyframe before or at
+   *     the specified position, rather than any sample before or at that position.
    */
-  public void discardEmbeddedTracksTo(long positionUs) {
-    for (int i = 0; i < embeddedSampleQueues.length; i++) {
-      embeddedSampleQueues[i].discardTo(positionUs, true, embeddedTracksSelected[i]);
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
+    int oldFirstIndex = primarySampleQueue.getFirstIndex();
+    primarySampleQueue.discardTo(positionUs, toKeyframe, true);
+    int newFirstIndex = primarySampleQueue.getFirstIndex();
+    if (newFirstIndex > oldFirstIndex) {
+      long discardToUs = primarySampleQueue.getFirstTimestampUs();
+      for (int i = 0; i < embeddedSampleQueues.length; i++) {
+        embeddedSampleQueues[i].discardTo(discardToUs, toKeyframe, embeddedTracksSelected[i]);
+      }
+      discardDownstreamMediaChunks(newFirstIndex);
     }
   }
 
@@ -172,7 +201,7 @@ public long getBufferedPositionUs() {
       return pendingResetPositionUs;
     } else {
       long bufferedPositionUs = lastSeekPositionUs;
-      BaseMediaChunk lastMediaChunk = mediaChunks.getLast();
+      BaseMediaChunk lastMediaChunk = getLastMediaChunk();
       BaseMediaChunk lastCompletedMediaChunk = lastMediaChunk.isLoadCompleted() ? lastMediaChunk
           : mediaChunks.size() > 1 ? mediaChunks.get(mediaChunks.size() - 2) : null;
       if (lastCompletedMediaChunk != null) {
@@ -182,6 +211,18 @@ public long getBufferedPositionUs() {
     }
   }
 
+  /**
+   * Adjusts a seek position given the specified {@link SeekParameters}. Chunk boundaries are used
+   * as sync points.
+   *
+   * @param positionUs The seek position in microseconds.
+   * @param seekParameters Parameters that control how the seek is performed.
+   * @return The adjusted seek position, in microseconds.
+   */
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    return chunkSource.getAdjustedSeekPositionUs(positionUs, seekParameters);
+  }
+
   /**
    * Seeks to the specified position in microseconds.
    *
@@ -189,16 +230,49 @@ public long getBufferedPositionUs() {
    */
   public void seekToUs(long positionUs) {
     lastSeekPositionUs = positionUs;
-    // If we're not pending a reset, see if we can seek within the primary sample queue.
-    boolean seekInsideBuffer = !isPendingReset() && (primarySampleQueue.advanceTo(positionUs, true,
-        positionUs < getNextLoadPositionUs()) != SampleQueue.ADVANCE_FAILED);
+    primarySampleQueue.rewind();
+
+    // See if we can seek within the primary sample queue.
+    boolean seekInsideBuffer;
+    if (isPendingReset()) {
+      seekInsideBuffer = false;
+    } else {
+      // Detect whether the seek is to the start of a chunk that's at least partially buffered.
+      BaseMediaChunk seekToMediaChunk = null;
+      for (int i = 0; i < mediaChunks.size(); i++) {
+        BaseMediaChunk mediaChunk = mediaChunks.get(i);
+        long mediaChunkStartTimeUs = mediaChunk.startTimeUs;
+        if (mediaChunkStartTimeUs == positionUs) {
+          seekToMediaChunk = mediaChunk;
+          break;
+        } else if (mediaChunkStartTimeUs > positionUs) {
+          // We're not going to find a chunk with a matching start time.
+          break;
+        }
+      }
+      if (seekToMediaChunk != null) {
+        // When seeking to the start of a chunk we use the index of the first sample in the chunk
+        // rather than the seek position. This ensures we seek to the keyframe at the start of the
+        // chunk even if the sample timestamps are slightly offset from the chunk start times.
+        seekInsideBuffer =
+            primarySampleQueue.setReadPosition(seekToMediaChunk.getFirstSampleIndex(0));
+        decodeOnlyUntilPositionUs = Long.MIN_VALUE;
+      } else {
+        seekInsideBuffer =
+            primarySampleQueue.advanceTo(
+                    positionUs,
+                    /* toKeyframe= */ true,
+                    /* allowTimeBeyondBuffer= */ positionUs < getNextLoadPositionUs())
+                != SampleQueue.ADVANCE_FAILED;
+        decodeOnlyUntilPositionUs = lastSeekPositionUs;
+      }
+    }
+
     if (seekInsideBuffer) {
-      // We succeeded. Discard samples and corresponding chunks prior to the seek position.
-      discardDownstreamMediaChunks(primarySampleQueue.getReadIndex());
-      primarySampleQueue.discardToRead();
+      // We succeeded. Advance the embedded sample queues to the seek position.
       for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
         embeddedSampleQueue.rewind();
-        embeddedSampleQueue.discardTo(positionUs, true, false);
+        embeddedSampleQueue.advanceTo(positionUs, true, false);
       }
     } else {
       // We failed, and need to restart.
@@ -218,18 +292,31 @@ public void seekToUs(long positionUs) {
 
   /**
    * Releases the stream.
-   * <p>
-   * This method should be called when the stream is no longer required.
+   *
+   * <p>This method should be called when the stream is no longer required. Either this method or
+   * {@link #release(ReleaseCallback)} can be used to release this stream.
    */
   public void release() {
-    boolean releasedSynchronously = loader.release(this);
-    if (!releasedSynchronously) {
-      // Discard as much as we can synchronously.
-      primarySampleQueue.discardToEnd();
-      for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
-        embeddedSampleQueue.discardToEnd();
-      }
+    release(null);
+  }
+
+  /**
+   * Releases the stream.
+   *
+   * <p>This method should be called when the stream is no longer required. Either this method or
+   * {@link #release()} can be used to release this stream.
+   *
+   * @param callback An optional callback to be called on the loading thread once the loader has
+   *     been released.
+   */
+  public void release(@Nullable ReleaseCallback<T> callback) {
+    this.releaseCallback = callback;
+    // Discard as much as we can synchronously.
+    primarySampleQueue.discardToEnd();
+    for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
+      embeddedSampleQueue.discardToEnd();
     }
+    loader.release(this);
   }
 
   @Override
@@ -238,6 +325,9 @@ public void onLoaderReleased() {
     for (SampleQueue embeddedSampleQueue : embeddedSampleQueues) {
       embeddedSampleQueue.reset();
     }
+    if (releaseCallback != null) {
+      releaseCallback.onSampleStreamReleased(this);
+    }
   }
 
   // SampleStream implementation.
@@ -261,11 +351,11 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
     if (isPendingReset()) {
       return C.RESULT_NOTHING_READ;
     }
-    discardDownstreamMediaChunks(primarySampleQueue.getReadIndex());
-    int result = primarySampleQueue.read(formatHolder, buffer, formatRequired, loadingFinished,
-        lastSeekPositionUs);
+    int result =
+        primarySampleQueue.read(
+            formatHolder, buffer, formatRequired, loadingFinished, decodeOnlyUntilPositionUs);
     if (result == C.RESULT_BUFFER_READ) {
-      primarySampleQueue.discardToRead();
+      maybeNotifyPrimaryTrackFormatChanged(primarySampleQueue.getReadIndex(), 1);
     }
     return result;
   }
@@ -285,7 +375,7 @@ public int skipData(long positionUs) {
       }
     }
     if (skipCount > 0) {
-      primarySampleQueue.discardToRead();
+      maybeNotifyPrimaryTrackFormatChanged(primarySampleQueue.getReadIndex(), skipCount);
     }
     return skipCount;
   }
@@ -323,7 +413,9 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
       IOException error) {
     long bytesLoaded = loadable.bytesLoaded();
     boolean isMediaChunk = isMediaChunk(loadable);
-    boolean cancelable = bytesLoaded == 0 || !isMediaChunk || !haveReadFromLastMediaChunk();
+    int lastChunkIndex = mediaChunks.size() - 1;
+    boolean cancelable =
+        bytesLoaded == 0 || !isMediaChunk || !haveReadFromMediaChunk(lastChunkIndex);
     boolean canceled = false;
     if (chunkSource.onChunkLoadError(loadable, cancelable, error)) {
       if (!cancelable) {
@@ -331,12 +423,8 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
       } else {
         canceled = true;
         if (isMediaChunk) {
-          BaseMediaChunk removed = mediaChunks.removeLast();
+          BaseMediaChunk removed = discardUpstreamMediaChunksFromIndex(lastChunkIndex);
           Assertions.checkState(removed == loadable);
-          primarySampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex(0));
-          for (int i = 0; i < embeddedSampleQueues.length; i++) {
-            embeddedSampleQueues[i].discardUpstreamSamples(removed.getFirstSampleIndex(i + 1));
-          }
           if (mediaChunks.isEmpty()) {
             pendingResetPositionUs = lastSeekPositionUs;
           }
@@ -363,13 +451,14 @@ public boolean continueLoading(long positionUs) {
       return false;
     }
 
+    boolean pendingReset = isPendingReset();
     MediaChunk previousChunk;
     long loadPositionUs;
-    if (isPendingReset()) {
+    if (pendingReset) {
       previousChunk = null;
       loadPositionUs = pendingResetPositionUs;
     } else {
-      previousChunk = mediaChunks.getLast();
+      previousChunk = getLastMediaChunk();
       loadPositionUs = previousChunk.endTimeUs;
     }
     chunkSource.getNextChunk(previousChunk, positionUs, loadPositionUs, nextChunkHolder);
@@ -388,8 +477,13 @@ public boolean continueLoading(long positionUs) {
     }
 
     if (isMediaChunk(loadable)) {
-      pendingResetPositionUs = C.TIME_UNSET;
       BaseMediaChunk mediaChunk = (BaseMediaChunk) loadable;
+      if (pendingReset) {
+        boolean resetToMediaChunk = mediaChunk.startTimeUs == pendingResetPositionUs;
+        // Only enable setting of the decode only flag if we're not resetting to a chunk boundary.
+        decodeOnlyUntilPositionUs = resetToMediaChunk ? Long.MIN_VALUE : pendingResetPositionUs;
+        pendingResetPositionUs = C.TIME_UNSET;
+      }
       mediaChunk.init(mediaChunkOutput);
       mediaChunks.add(mediaChunk);
     }
@@ -405,38 +499,56 @@ public long getNextLoadPositionUs() {
     if (isPendingReset()) {
       return pendingResetPositionUs;
     } else {
-      return loadingFinished ? C.TIME_END_OF_SOURCE : mediaChunks.getLast().endTimeUs;
+      return loadingFinished ? C.TIME_END_OF_SOURCE : getLastMediaChunk().endTimeUs;
     }
   }
 
-  // Internal methods
+  @Override
+  public void reevaluateBuffer(long positionUs) {
+    if (loader.isLoading() || isPendingReset()) {
+      return;
+    }
 
-  // TODO[REFACTOR]: Call maybeDiscardUpstream for DASH and SmoothStreaming.
-  /**
-   * Discards media chunks from the back of the buffer if conditions have changed such that it's
-   * preferable to re-buffer the media at a different quality.
-   *
-   * @param positionUs The current playback position in microseconds.
-   */
-  private void maybeDiscardUpstream(long positionUs) {
-    int queueSize = chunkSource.getPreferredQueueSize(positionUs, readOnlyMediaChunks);
-    discardUpstreamMediaChunks(Math.max(1, queueSize));
+    int currentQueueSize = mediaChunks.size();
+    int preferredQueueSize = chunkSource.getPreferredQueueSize(positionUs, readOnlyMediaChunks);
+    if (currentQueueSize <= preferredQueueSize) {
+      return;
+    }
+
+    int newQueueSize = currentQueueSize;
+    for (int i = preferredQueueSize; i < currentQueueSize; i++) {
+      if (!haveReadFromMediaChunk(i)) {
+        newQueueSize = i;
+        break;
+      }
+    }
+    if (newQueueSize == currentQueueSize) {
+      return;
+    }
+
+    long endTimeUs = getLastMediaChunk().endTimeUs;
+    BaseMediaChunk firstRemovedChunk = discardUpstreamMediaChunksFromIndex(newQueueSize);
+    if (mediaChunks.isEmpty()) {
+      pendingResetPositionUs = lastSeekPositionUs;
+    }
+    loadingFinished = false;
+    eventDispatcher.upstreamDiscarded(primaryTrackType, firstRemovedChunk.startTimeUs, endTimeUs);
   }
 
+  // Internal methods
+
   private boolean isMediaChunk(Chunk chunk) {
     return chunk instanceof BaseMediaChunk;
   }
 
-  /**
-   * Returns whether samples have been read from {@code mediaChunks.getLast()}.
-   */
-  private boolean haveReadFromLastMediaChunk() {
-    BaseMediaChunk lastChunk = mediaChunks.getLast();
-    if (primarySampleQueue.getReadIndex() > lastChunk.getFirstSampleIndex(0)) {
+  /** Returns whether samples have been read from media chunk at given index. */
+  private boolean haveReadFromMediaChunk(int mediaChunkIndex) {
+    BaseMediaChunk mediaChunk = mediaChunks.get(mediaChunkIndex);
+    if (primarySampleQueue.getReadIndex() > mediaChunk.getFirstSampleIndex(0)) {
       return true;
     }
     for (int i = 0; i < embeddedSampleQueues.length; i++) {
-      if (embeddedSampleQueues[i].getReadIndex() > lastChunk.getFirstSampleIndex(i + 1)) {
+      if (embeddedSampleQueues[i].getReadIndex() > mediaChunk.getFirstSampleIndex(i + 1)) {
         return true;
       }
     }
@@ -447,47 +559,68 @@ private boolean haveReadFromLastMediaChunk() {
     return pendingResetPositionUs != C.TIME_UNSET;
   }
 
-  private void discardDownstreamMediaChunks(int primaryStreamReadIndex) {
-    if (!mediaChunks.isEmpty()) {
-      while (mediaChunks.size() > 1
-          && mediaChunks.get(1).getFirstSampleIndex(0) <= primaryStreamReadIndex) {
-        mediaChunks.removeFirst();
-      }
-      BaseMediaChunk currentChunk = mediaChunks.getFirst();
-      Format trackFormat = currentChunk.trackFormat;
-      if (!trackFormat.equals(primaryDownstreamTrackFormat)) {
-        eventDispatcher.downstreamFormatChanged(primaryTrackType, trackFormat,
-            currentChunk.trackSelectionReason, currentChunk.trackSelectionData,
-            currentChunk.startTimeUs);
+  private void discardDownstreamMediaChunks(int discardToPrimaryStreamIndex) {
+    int discardToMediaChunkIndex =
+        primaryStreamIndexToMediaChunkIndex(discardToPrimaryStreamIndex, /* minChunkIndex= */ 0);
+    if (discardToMediaChunkIndex > 0) {
+      Util.removeRange(mediaChunks, /* fromIndex= */ 0, /* toIndex= */ discardToMediaChunkIndex);
+    }
+  }
+
+  private void maybeNotifyPrimaryTrackFormatChanged(int toPrimaryStreamReadIndex, int readCount) {
+    int fromMediaChunkIndex = primaryStreamIndexToMediaChunkIndex(
+        toPrimaryStreamReadIndex - readCount, /* minChunkIndex= */ 0);
+    int toMediaChunkIndexInclusive = readCount == 1 ? fromMediaChunkIndex
+        : primaryStreamIndexToMediaChunkIndex(toPrimaryStreamReadIndex - 1,
+            /* minChunkIndex= */ fromMediaChunkIndex);
+    for (int i = fromMediaChunkIndex; i <= toMediaChunkIndexInclusive; i++) {
+      maybeNotifyPrimaryTrackFormatChanged(i);
+    }
+  }
+
+  private void maybeNotifyPrimaryTrackFormatChanged(int mediaChunkReadIndex) {
+    BaseMediaChunk currentChunk = mediaChunks.get(mediaChunkReadIndex);
+    Format trackFormat = currentChunk.trackFormat;
+    if (!trackFormat.equals(primaryDownstreamTrackFormat)) {
+      eventDispatcher.downstreamFormatChanged(primaryTrackType, trackFormat,
+          currentChunk.trackSelectionReason, currentChunk.trackSelectionData,
+          currentChunk.startTimeUs);
+    }
+    primaryDownstreamTrackFormat = trackFormat;
+  }
+
+  /**
+   * Returns media chunk index for primary stream sample index. May be -1 if the list of media
+   * chunks is empty or the requested index is less than the first index in the first media chunk.
+   */
+  private int primaryStreamIndexToMediaChunkIndex(int primaryStreamIndex, int minChunkIndex) {
+    for (int i = minChunkIndex + 1; i < mediaChunks.size(); i++) {
+      if (mediaChunks.get(i).getFirstSampleIndex(0) > primaryStreamIndex) {
+        return i - 1;
       }
-      primaryDownstreamTrackFormat = trackFormat;
     }
+    return mediaChunks.size() - 1;
+  }
+
+  private BaseMediaChunk getLastMediaChunk() {
+    return mediaChunks.get(mediaChunks.size() - 1);
   }
 
   /**
-   * Discard upstream media chunks until the queue length is equal to the length specified.
+   * Discard upstream media chunks from {@code chunkIndex} and corresponding samples from sample
+   * queues.
    *
-   * @param queueLength The desired length of the queue.
-   * @return Whether chunks were discarded.
+   * @param chunkIndex The index of the first chunk to discard.
+   * @return The chunk at given index.
    */
-  private boolean discardUpstreamMediaChunks(int queueLength) {
-    if (mediaChunks.size() <= queueLength) {
-      return false;
-    }
-    BaseMediaChunk removed;
-    long startTimeUs;
-    long endTimeUs = mediaChunks.getLast().endTimeUs;
-    do {
-      removed = mediaChunks.removeLast();
-      startTimeUs = removed.startTimeUs;
-    } while (mediaChunks.size() > queueLength);
-    primarySampleQueue.discardUpstreamSamples(removed.getFirstSampleIndex(0));
+  private BaseMediaChunk discardUpstreamMediaChunksFromIndex(int chunkIndex) {
+    BaseMediaChunk firstRemovedChunk = mediaChunks.get(chunkIndex);
+    Util.removeRange(mediaChunks, /* fromIndex= */ chunkIndex, /* toIndex= */ mediaChunks.size());
+    primarySampleQueue.discardUpstreamSamples(firstRemovedChunk.getFirstSampleIndex(0));
     for (int i = 0; i < embeddedSampleQueues.length; i++) {
-      embeddedSampleQueues[i].discardUpstreamSamples(removed.getFirstSampleIndex(i + 1));
+      embeddedSampleQueues[i].discardUpstreamSamples(firstRemovedChunk.getFirstSampleIndex(i + 1));
     }
-    loadingFinished = false;
-    eventDispatcher.upstreamDiscarded(primaryTrackType, startTimeUs, endTimeUs);
-    return true;
+    return firstRemovedChunk;
   }
 
   /**
@@ -500,6 +633,8 @@ private boolean discardUpstreamMediaChunks(int queueLength) {
     private final SampleQueue sampleQueue;
     private final int index;
 
+    private boolean formatNotificationSent;
+
     public EmbeddedSampleStream(ChunkSampleStream<T> parent, SampleQueue sampleQueue, int index) {
       this.parent = parent;
       this.sampleQueue = sampleQueue;
@@ -513,12 +648,19 @@ public boolean isReady() {
 
     @Override
     public int skipData(long positionUs) {
+      int skipCount;
       if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
-        return sampleQueue.advanceToEnd();
+        skipCount = sampleQueue.advanceToEnd();
       } else {
-        int skipCount = sampleQueue.advanceTo(positionUs, true, true);
-        return skipCount == SampleQueue.ADVANCE_FAILED ? 0 : skipCount;
+        skipCount = sampleQueue.advanceTo(positionUs, true, true);
+        if (skipCount == SampleQueue.ADVANCE_FAILED) {
+          skipCount = 0;
+        }
+      }
+      if (skipCount > 0) {
+        maybeNotifyTrackFormatChanged();
       }
+      return skipCount;
     }
 
     @Override
@@ -532,8 +674,13 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       if (isPendingReset()) {
         return C.RESULT_NOTHING_READ;
       }
-      return sampleQueue.read(formatHolder, buffer, formatRequired, loadingFinished,
-          lastSeekPositionUs);
+      int result =
+          sampleQueue.read(
+              formatHolder, buffer, formatRequired, loadingFinished, decodeOnlyUntilPositionUs);
+      if (result == C.RESULT_BUFFER_READ) {
+        maybeNotifyTrackFormatChanged();
+      }
+      return result;
     }
 
     public void release() {
@@ -541,6 +688,17 @@ public void release() {
       embeddedTracksSelected[index] = false;
     }
 
+    private void maybeNotifyTrackFormatChanged() {
+      if (!formatNotificationSent) {
+        eventDispatcher.downstreamFormatChanged(
+            embeddedTrackTypes[index],
+            embeddedTrackFormats[index],
+            C.SELECTION_REASON_UNKNOWN,
+            /* trackSelectionData= */ null,
+            lastSeekPositionUs);
+        formatNotificationSent = true;
+      }
+    }
   }
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java
index b04dc7cbdb..568461c206 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ChunkSource.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source.chunk;
 
+import com.google.android.exoplayer2.SeekParameters;
 import java.io.IOException;
 import java.util.List;
 
@@ -23,6 +24,16 @@
  */
 public interface ChunkSource {
 
+  /**
+   * Adjusts a seek position given the specified {@link SeekParameters}. Chunk boundaries are used
+   * as sync points.
+   *
+   * @param positionUs The seek position in microseconds.
+   * @param seekParameters Parameters that control how the seek is performed.
+   * @return The adjusted seek position, in microseconds.
+   */
+  long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters);
+
   /**
    * If the source is currently having difficulty providing chunks, then this method throws the
    * underlying error. Otherwise does nothing.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
index cc39c88fd0..b43c69b63a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/ContainerMediaChunk.java
@@ -53,9 +53,18 @@
    * @param sampleOffsetUs An offset to add to the sample timestamps parsed by the extractor.
    * @param extractorWrapper A wrapped extractor to use for parsing the data.
    */
-  public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
-      int chunkIndex, int chunkCount, long sampleOffsetUs, ChunkExtractorWrapper extractorWrapper) {
+  public ContainerMediaChunk(
+      DataSource dataSource,
+      DataSpec dataSpec,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long startTimeUs,
+      long endTimeUs,
+      long chunkIndex,
+      int chunkCount,
+      long sampleOffsetUs,
+      ChunkExtractorWrapper extractorWrapper) {
     super(dataSource, dataSpec, trackFormat, trackSelectionReason, trackSelectionData, startTimeUs,
         endTimeUs, chunkIndex);
     this.chunkCount = chunkCount;
@@ -64,7 +73,7 @@ public ContainerMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trac
   }
 
   @Override
-  public int getNextChunkIndex() {
+  public long getNextChunkIndex() {
     return chunkIndex + chunkCount;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunk.java
index 3a02884fff..d313a8cb81 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/MediaChunk.java
@@ -26,10 +26,8 @@
  */
 public abstract class MediaChunk extends Chunk {
 
-  /**
-   * The chunk index.
-   */
-  public final int chunkIndex;
+  /** The chunk index. */
+  public final long chunkIndex;
 
   /**
    * @param dataSource The source from which the data should be loaded.
@@ -41,19 +39,23 @@
    * @param endTimeUs The end time of the media contained by the chunk, in microseconds.
    * @param chunkIndex The index of the chunk.
    */
-  public MediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
-      int chunkIndex) {
+  public MediaChunk(
+      DataSource dataSource,
+      DataSpec dataSpec,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long startTimeUs,
+      long endTimeUs,
+      long chunkIndex) {
     super(dataSource, dataSpec, C.DATA_TYPE_MEDIA, trackFormat, trackSelectionReason,
         trackSelectionData, startTimeUs, endTimeUs);
     Assertions.checkNotNull(trackFormat);
     this.chunkIndex = chunkIndex;
   }
 
-  /**
-   * Returns the next chunk index.
-   */
-  public int getNextChunkIndex() {
+  /** Returns the next chunk index. */
+  public long getNextChunkIndex() {
     return chunkIndex + 1;
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
index 02cf7dfd55..87a90bc285 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/chunk/SingleSampleMediaChunk.java
@@ -50,9 +50,17 @@
    *     constants.
    * @param sampleFormat The {@link Format} of the sample in the chunk.
    */
-  public SingleSampleMediaChunk(DataSource dataSource, DataSpec dataSpec, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
-      int chunkIndex, int trackType, Format sampleFormat) {
+  public SingleSampleMediaChunk(
+      DataSource dataSource,
+      DataSpec dataSpec,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long startTimeUs,
+      long endTimeUs,
+      long chunkIndex,
+      int trackType,
+      Format sampleFormat) {
     super(dataSource, dataSpec, trackFormat, trackSelectionReason, trackSelectionData, startTimeUs,
         endTimeUs, chunkIndex);
     this.trackType = trackType;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
index 6955f775dd..997f750b61 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/SimpleSubtitleDecoder.java
@@ -57,6 +57,11 @@ protected final SubtitleOutputBuffer createOutputBuffer() {
     return new SimpleSubtitleOutputBuffer(this);
   }
 
+  @Override
+  protected final SubtitleDecoderException createUnexpectedDecodeException(Throwable error) {
+    return new SubtitleDecoderException("Unexpected decode error", error);
+  }
+
   @Override
   protected final void releaseOutputBuffer(SubtitleOutputBuffer buffer) {
     super.releaseOutputBuffer(buffer);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
index 6a9b83a015..139e403844 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java
@@ -19,6 +19,7 @@
 import com.google.android.exoplayer2.text.cea.Cea608Decoder;
 import com.google.android.exoplayer2.text.cea.Cea708Decoder;
 import com.google.android.exoplayer2.text.dvb.DvbDecoder;
+import com.google.android.exoplayer2.text.pgs.PgsDecoder;
 import com.google.android.exoplayer2.text.ssa.SsaDecoder;
 import com.google.android.exoplayer2.text.subrip.SubripDecoder;
 import com.google.android.exoplayer2.text.ttml.TtmlDecoder;
@@ -52,64 +53,69 @@
 
   /**
    * Default {@link SubtitleDecoderFactory} implementation.
-   * <p>
-   * The formats supported by this factory are:
+   *
+   * <p>The formats supported by this factory are:
+   *
    * <ul>
-   * <li>WebVTT ({@link WebvttDecoder})</li>
-   * <li>WebVTT (MP4) ({@link Mp4WebvttDecoder})</li>
-   * <li>TTML ({@link TtmlDecoder})</li>
-   * <li>SubRip ({@link SubripDecoder})</li>
-   * <li>SSA/ASS ({@link SsaDecoder})</li>
-   * <li>TX3G ({@link Tx3gDecoder})</li>
-   * <li>Cea608 ({@link Cea608Decoder})</li>
-   * <li>Cea708 ({@link Cea708Decoder})</li>
-   * <li>DVB ({@link DvbDecoder})</li>
+   *   <li>WebVTT ({@link WebvttDecoder})
+   *   <li>WebVTT (MP4) ({@link Mp4WebvttDecoder})
+   *   <li>TTML ({@link TtmlDecoder})
+   *   <li>SubRip ({@link SubripDecoder})
+   *   <li>SSA/ASS ({@link SsaDecoder})
+   *   <li>TX3G ({@link Tx3gDecoder})
+   *   <li>Cea608 ({@link Cea608Decoder})
+   *   <li>Cea708 ({@link Cea708Decoder})
+   *   <li>DVB ({@link DvbDecoder})
+   *   <li>PGS ({@link PgsDecoder})
    * </ul>
    */
-  SubtitleDecoderFactory DEFAULT = new SubtitleDecoderFactory() {
-
-    @Override
-    public boolean supportsFormat(Format format) {
-      String mimeType = format.sampleMimeType;
-      return MimeTypes.TEXT_VTT.equals(mimeType)
-          || MimeTypes.TEXT_SSA.equals(mimeType)
-          || MimeTypes.APPLICATION_TTML.equals(mimeType)
-          || MimeTypes.APPLICATION_MP4VTT.equals(mimeType)
-          || MimeTypes.APPLICATION_SUBRIP.equals(mimeType)
-          || MimeTypes.APPLICATION_TX3G.equals(mimeType)
-          || MimeTypes.APPLICATION_CEA608.equals(mimeType)
-          || MimeTypes.APPLICATION_MP4CEA608.equals(mimeType)
-          || MimeTypes.APPLICATION_CEA708.equals(mimeType)
-          || MimeTypes.APPLICATION_DVBSUBS.equals(mimeType);
-    }
-
-    @Override
-    public SubtitleDecoder createDecoder(Format format) {
-      switch (format.sampleMimeType) {
-        case MimeTypes.TEXT_VTT:
-          return new WebvttDecoder();
-        case MimeTypes.TEXT_SSA:
-          return new SsaDecoder(format.initializationData);
-        case MimeTypes.APPLICATION_MP4VTT:
-          return new Mp4WebvttDecoder();
-        case MimeTypes.APPLICATION_TTML:
-          return new TtmlDecoder();
-        case MimeTypes.APPLICATION_SUBRIP:
-          return new SubripDecoder();
-        case MimeTypes.APPLICATION_TX3G:
-          return new Tx3gDecoder(format.initializationData);
-        case MimeTypes.APPLICATION_CEA608:
-        case MimeTypes.APPLICATION_MP4CEA608:
-          return new Cea608Decoder(format.sampleMimeType, format.accessibilityChannel);
-        case MimeTypes.APPLICATION_CEA708:
-          return new Cea708Decoder(format.accessibilityChannel);
-        case MimeTypes.APPLICATION_DVBSUBS:
-          return new DvbDecoder(format.initializationData);
-        default:
-          throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
-      }
-    }
+  SubtitleDecoderFactory DEFAULT =
+      new SubtitleDecoderFactory() {
 
-  };
+        @Override
+        public boolean supportsFormat(Format format) {
+          String mimeType = format.sampleMimeType;
+          return MimeTypes.TEXT_VTT.equals(mimeType)
+              || MimeTypes.TEXT_SSA.equals(mimeType)
+              || MimeTypes.APPLICATION_TTML.equals(mimeType)
+              || MimeTypes.APPLICATION_MP4VTT.equals(mimeType)
+              || MimeTypes.APPLICATION_SUBRIP.equals(mimeType)
+              || MimeTypes.APPLICATION_TX3G.equals(mimeType)
+              || MimeTypes.APPLICATION_CEA608.equals(mimeType)
+              || MimeTypes.APPLICATION_MP4CEA608.equals(mimeType)
+              || MimeTypes.APPLICATION_CEA708.equals(mimeType)
+              || MimeTypes.APPLICATION_DVBSUBS.equals(mimeType)
+              || MimeTypes.APPLICATION_PGS.equals(mimeType);
+        }
 
+        @Override
+        public SubtitleDecoder createDecoder(Format format) {
+          switch (format.sampleMimeType) {
+            case MimeTypes.TEXT_VTT:
+              return new WebvttDecoder();
+            case MimeTypes.TEXT_SSA:
+              return new SsaDecoder(format.initializationData);
+            case MimeTypes.APPLICATION_MP4VTT:
+              return new Mp4WebvttDecoder();
+            case MimeTypes.APPLICATION_TTML:
+              return new TtmlDecoder();
+            case MimeTypes.APPLICATION_SUBRIP:
+              return new SubripDecoder();
+            case MimeTypes.APPLICATION_TX3G:
+              return new Tx3gDecoder(format.initializationData);
+            case MimeTypes.APPLICATION_CEA608:
+            case MimeTypes.APPLICATION_MP4CEA608:
+              return new Cea608Decoder(format.sampleMimeType, format.accessibilityChannel);
+            case MimeTypes.APPLICATION_CEA708:
+              return new Cea708Decoder(format.accessibilityChannel);
+            case MimeTypes.APPLICATION_DVBSUBS:
+              return new DvbDecoder(format.initializationData);
+            case MimeTypes.APPLICATION_PGS:
+              return new PgsDecoder();
+            default:
+              throw new IllegalArgumentException(
+                  "Attempted to create decoder for unsupported format");
+          }
+        }
+      };
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleInputBuffer.java b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleInputBuffer.java
index 4b3b61bddf..9866517a58 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleInputBuffer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/SubtitleInputBuffer.java
@@ -15,15 +15,11 @@
  */
 package com.google.android.exoplayer2.text;
 
-import android.support.annotation.NonNull;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 
-/**
- * A {@link DecoderInputBuffer} for a {@link SubtitleDecoder}.
- */
-public final class SubtitleInputBuffer extends DecoderInputBuffer
-    implements Comparable<SubtitleInputBuffer> {
+/** A {@link DecoderInputBuffer} for a {@link SubtitleDecoder}. */
+public class SubtitleInputBuffer extends DecoderInputBuffer {
 
   /**
    * An offset that must be added to the subtitle's event times after it's been decoded, or
@@ -35,16 +31,4 @@ public SubtitleInputBuffer() {
     super(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
   }
 
-  @Override
-  public int compareTo(@NonNull SubtitleInputBuffer other) {
-    if (isEndOfStream() != other.isEndOfStream()) {
-      return isEndOfStream() ? 1 : -1;
-    }
-    long delta = timeUs - other.timeUs;
-    if (delta == 0) {
-      return 0;
-    }
-    return delta > 0 ? 1 : -1;
-  }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
index e2c592be6b..f018e055fb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea608Decoder.java
@@ -33,7 +33,6 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.ArrayList;
-import java.util.LinkedList;
 import java.util.List;
 
 /**
@@ -185,7 +184,7 @@
   private final ParsableByteArray ccData;
   private final int packetLength;
   private final int selectedField;
-  private final LinkedList<CueBuilder> cueBuilders;
+  private final ArrayList<CueBuilder> cueBuilders;
 
   private CueBuilder currentCueBuilder;
   private List<Cue> cues;
@@ -200,7 +199,7 @@
 
   public Cea608Decoder(String mimeType, int accessibilityChannel) {
     ccData = new ParsableByteArray();
-    cueBuilders = new LinkedList<>();
+    cueBuilders = new ArrayList<>();
     currentCueBuilder = new CueBuilder(CC_MODE_UNKNOWN, DEFAULT_CAPTIONS_ROW_COUNT);
     packetLength = MimeTypes.APPLICATION_MP4CEA608.equals(mimeType) ? 2 : 3;
     switch (accessibilityChannel) {
@@ -230,8 +229,8 @@ public void flush() {
     cues = null;
     lastCues = null;
     setCaptionMode(CC_MODE_UNKNOWN);
+    setCaptionRowCount(DEFAULT_CAPTIONS_ROW_COUNT);
     resetCueBuilders();
-    captionRowCount = DEFAULT_CAPTIONS_ROW_COUNT;
     repeatableControlSet = false;
     repeatableControlCc1 = 0;
     repeatableControlCc2 = 0;
@@ -434,16 +433,16 @@ private void handlePreambleAddressCode(byte cc1, byte cc2) {
   private void handleMiscCode(byte cc2) {
     switch (cc2) {
       case CTRL_ROLL_UP_CAPTIONS_2_ROWS:
-        captionRowCount = 2;
         setCaptionMode(CC_MODE_ROLL_UP);
+        setCaptionRowCount(2);
         return;
       case CTRL_ROLL_UP_CAPTIONS_3_ROWS:
-        captionRowCount = 3;
         setCaptionMode(CC_MODE_ROLL_UP);
+        setCaptionRowCount(3);
         return;
       case CTRL_ROLL_UP_CAPTIONS_4_ROWS:
-        captionRowCount = 4;
         setCaptionMode(CC_MODE_ROLL_UP);
+        setCaptionRowCount(4);
         return;
       case CTRL_RESUME_CAPTION_LOADING:
         setCaptionMode(CC_MODE_POP_ON);
@@ -451,6 +450,9 @@ private void handleMiscCode(byte cc2) {
       case CTRL_RESUME_DIRECT_CAPTIONING:
         setCaptionMode(CC_MODE_PAINT_ON);
         return;
+      default:
+        // Fall through.
+        break;
     }
 
     if (captionMode == CC_MODE_UNKNOWN) {
@@ -484,6 +486,9 @@ private void handleMiscCode(byte cc2) {
       case CTRL_DELETE_TO_END_OF_ROW:
         // TODO: implement
         break;
+      default:
+        // Fall through.
+        break;
     }
   }
 
@@ -515,8 +520,13 @@ private void setCaptionMode(int captionMode) {
     }
   }
 
+  private void setCaptionRowCount(int captionRowCount) {
+    this.captionRowCount = captionRowCount;
+    currentCueBuilder.setCaptionRowCount(captionRowCount);
+  }
+
   private void resetCueBuilders() {
-    currentCueBuilder.reset(captionMode, captionRowCount);
+    currentCueBuilder.reset(captionMode);
     cueBuilders.clear();
     cueBuilders.add(currentCueBuilder);
   }
@@ -594,12 +604,14 @@ private static boolean isRepeatable(byte cc1) {
     public CueBuilder(int captionMode, int captionRowCount) {
       preambleStyles = new ArrayList<>();
       midrowStyles = new ArrayList<>();
-      rolledUpCaptions = new LinkedList<>();
+      rolledUpCaptions = new ArrayList<>();
       captionStringBuilder = new SpannableStringBuilder();
-      reset(captionMode, captionRowCount);
+      reset(captionMode);
+      setCaptionRowCount(captionRowCount);
     }
 
-    public void reset(int captionMode, int captionRowCount) {
+    public void reset(int captionMode) {
+      this.captionMode = captionMode;
       preambleStyles.clear();
       midrowStyles.clear();
       rolledUpCaptions.clear();
@@ -607,11 +619,13 @@ public void reset(int captionMode, int captionRowCount) {
       row = BASE_ROW;
       indent = 0;
       tabOffset = 0;
-      this.captionMode = captionMode;
-      this.captionRowCount = captionRowCount;
       underlineStartPosition = POSITION_UNSET;
     }
 
+    public void setCaptionRowCount(int captionRowCount) {
+      this.captionRowCount = captionRowCount;
+    }
+
     public boolean isEmpty() {
       return preambleStyles.isEmpty() && midrowStyles.isEmpty() && rolledUpCaptions.isEmpty()
           && captionStringBuilder.length() == 0;
@@ -726,8 +740,10 @@ public Cue build() {
       // The number of empty columns after the end of the text, in the same range.
       int endPadding = SCREEN_CHARWIDTH - startPadding - cueString.length();
       int startEndPaddingDelta = startPadding - endPadding;
-      if (captionMode == CC_MODE_POP_ON && Math.abs(startEndPaddingDelta) < 3) {
-        // Treat approximately centered pop-on captions are middle aligned.
+      if (captionMode == CC_MODE_POP_ON && (Math.abs(startEndPaddingDelta) < 3 || endPadding < 0)) {
+        // Treat approximately centered pop-on captions as middle aligned. We also treat captions
+        // that are wider than they should be in this way. See
+        // https://github.com/google/ExoPlayer/issues/3534.
         position = 0.5f;
         positionAnchor = Cue.ANCHOR_TYPE_MIDDLE;
       } else if (captionMode == CC_MODE_POP_ON && startEndPaddingDelta > 0) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
index 030f0cdbb0..6bdbebc73b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/Cea708Decoder.java
@@ -104,7 +104,7 @@
   private static final int COMMAND_DF1 = 0x99;  // DefineWindow 1 (+6 bytes)
   private static final int COMMAND_DF2 = 0x9A;  // DefineWindow 2 (+6 bytes)
   private static final int COMMAND_DF3 = 0x9B;  // DefineWindow 3 (+6 bytes)
-  private static final int COMMAND_DS4 = 0x9C;  // DefineWindow 4 (+6 bytes)
+  private static final int COMMAND_DF4 = 0x9C; // DefineWindow 4 (+6 bytes)
   private static final int COMMAND_DF5 = 0x9D;  // DefineWindow 5 (+6 bytes)
   private static final int COMMAND_DF6 = 0x9E;  // DefineWindow 6 (+6 bytes)
   private static final int COMMAND_DF7 = 0x9F;  // DefineWindow 7 (+6 bytes)
@@ -464,7 +464,7 @@ private void handleC1Command(int command) {
       case COMMAND_DF1:
       case COMMAND_DF2:
       case COMMAND_DF3:
-      case COMMAND_DS4:
+      case COMMAND_DF4:
       case COMMAND_DF5:
       case COMMAND_DF6:
       case COMMAND_DF7:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
index bb13a7d143..07a55f1a40 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.text.cea;
 
+import android.support.annotation.NonNull;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.text.Subtitle;
@@ -34,21 +35,22 @@
   private static final int NUM_INPUT_BUFFERS = 10;
   private static final int NUM_OUTPUT_BUFFERS = 2;
 
-  private final LinkedList<SubtitleInputBuffer> availableInputBuffers;
+  private final LinkedList<CeaInputBuffer> availableInputBuffers;
   private final LinkedList<SubtitleOutputBuffer> availableOutputBuffers;
-  private final PriorityQueue<SubtitleInputBuffer> queuedInputBuffers;
+  private final PriorityQueue<CeaInputBuffer> queuedInputBuffers;
 
-  private SubtitleInputBuffer dequeuedInputBuffer;
+  private CeaInputBuffer dequeuedInputBuffer;
   private long playbackPositionUs;
+  private long queuedInputBufferCount;
 
   public CeaDecoder() {
     availableInputBuffers = new LinkedList<>();
     for (int i = 0; i < NUM_INPUT_BUFFERS; i++) {
-      availableInputBuffers.add(new SubtitleInputBuffer());
+      availableInputBuffers.add(new CeaInputBuffer());
     }
     availableOutputBuffers = new LinkedList<>();
     for (int i = 0; i < NUM_OUTPUT_BUFFERS; i++) {
-      availableOutputBuffers.add(new CeaOutputBuffer(this));
+      availableOutputBuffers.add(new CeaOutputBuffer());
     }
     queuedInputBuffers = new PriorityQueue<>();
   }
@@ -77,9 +79,10 @@ public void queueInputBuffer(SubtitleInputBuffer inputBuffer) throws SubtitleDec
     if (inputBuffer.isDecodeOnly()) {
       // We can drop this buffer early (i.e. before it would be decoded) as the CEA formats allow
       // for decoding to begin mid-stream.
-      releaseInputBuffer(inputBuffer);
+      releaseInputBuffer(dequeuedInputBuffer);
     } else {
-      queuedInputBuffers.add(inputBuffer);
+      dequeuedInputBuffer.queuedInputBufferCount = queuedInputBufferCount++;
+      queuedInputBuffers.add(dequeuedInputBuffer);
     }
     dequeuedInputBuffer = null;
   }
@@ -94,7 +97,7 @@ public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderExceptio
     // be deferred until they would be applicable
     while (!queuedInputBuffers.isEmpty()
         && queuedInputBuffers.peek().timeUs <= playbackPositionUs) {
-      SubtitleInputBuffer inputBuffer = queuedInputBuffers.poll();
+      CeaInputBuffer inputBuffer = queuedInputBuffers.poll();
 
       // If the input buffer indicates we've reached the end of the stream, we can
       // return immediately with an output buffer propagating that
@@ -126,7 +129,7 @@ public SubtitleOutputBuffer dequeueOutputBuffer() throws SubtitleDecoderExceptio
     return null;
   }
 
-  private void releaseInputBuffer(SubtitleInputBuffer inputBuffer) {
+  private void releaseInputBuffer(CeaInputBuffer inputBuffer) {
     inputBuffer.clear();
     availableInputBuffers.add(inputBuffer);
   }
@@ -138,6 +141,7 @@ protected void releaseOutputBuffer(SubtitleOutputBuffer outputBuffer) {
 
   @Override
   public void flush() {
+    queuedInputBufferCount = 0;
     playbackPositionUs = 0;
     while (!queuedInputBuffers.isEmpty()) {
       releaseInputBuffer(queuedInputBuffers.poll());
@@ -169,4 +173,32 @@ public void release() {
    */
   protected abstract void decode(SubtitleInputBuffer inputBuffer);
 
+  private static final class CeaInputBuffer extends SubtitleInputBuffer
+      implements Comparable<CeaInputBuffer> {
+
+    private long queuedInputBufferCount;
+
+    @Override
+    public int compareTo(@NonNull CeaInputBuffer other) {
+      if (isEndOfStream() != other.isEndOfStream()) {
+        return isEndOfStream() ? 1 : -1;
+      }
+      long delta = timeUs - other.timeUs;
+      if (delta == 0) {
+        delta = queuedInputBufferCount - other.queuedInputBufferCount;
+        if (delta == 0) {
+          return 0;
+        }
+      }
+      return delta > 0 ? 1 : -1;
+    }
+  }
+
+  private final class CeaOutputBuffer extends SubtitleOutputBuffer {
+
+    @Override
+    public final void release() {
+      releaseOutputBuffer(this);
+    }
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
index ddb3804c3e..67271ee218 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/cea/CeaUtil.java
@@ -19,18 +19,19 @@
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
 
-/**
- * Utility methods for handling CEA-608/708 messages.
- */
+/** Utility methods for handling CEA-608/708 messages. Defined in A/53 Part 4:2009. */
 public final class CeaUtil {
 
   private static final String TAG = "CeaUtil";
 
   private static final int PAYLOAD_TYPE_CC = 4;
   private static final int COUNTRY_CODE = 0xB5;
-  private static final int PROVIDER_CODE = 0x31;
-  private static final int USER_ID = 0x47413934; // "GA94"
+  private static final int PROVIDER_CODE_ATSC = 0x31;
+  private static final int PROVIDER_CODE_DIRECTV = 0x2F;
+  private static final int USER_ID_GA94 = Util.getIntegerCodeForString("GA94");
+  private static final int USER_ID_DTG1 = Util.getIntegerCodeForString("DTG1");
   private static final int USER_DATA_TYPE_CODE = 0x3;
 
   /**
@@ -46,33 +47,49 @@ public static void consume(long presentationTimeUs, ParsableByteArray seiBuffer,
     while (seiBuffer.bytesLeft() > 1 /* last byte will be rbsp_trailing_bits */) {
       int payloadType = readNon255TerminatedValue(seiBuffer);
       int payloadSize = readNon255TerminatedValue(seiBuffer);
+      int nextPayloadPosition = seiBuffer.getPosition() + payloadSize;
       // Process the payload.
       if (payloadSize == -1 || payloadSize > seiBuffer.bytesLeft()) {
         // This might occur if we're trying to read an encrypted SEI NAL unit.
         Log.w(TAG, "Skipping remainder of malformed SEI NAL unit.");
-        seiBuffer.setPosition(seiBuffer.limit());
-      } else if (isSeiMessageCea608(payloadType, payloadSize, seiBuffer)) {
-        // Ignore country_code (1) + provider_code (2) + user_identifier (4)
-        // + user_data_type_code (1).
-        seiBuffer.skipBytes(8);
-        // Ignore first three bits: reserved (1) + process_cc_data_flag (1) + zero_bit (1).
-        int ccCount = seiBuffer.readUnsignedByte() & 0x1F;
-        // Ignore em_data (1)
-        seiBuffer.skipBytes(1);
-        // Each data packet consists of 24 bits: marker bits (5) + cc_valid (1) + cc_type (2)
-        // + cc_data_1 (8) + cc_data_2 (8).
-        int sampleLength = ccCount * 3;
-        int sampleStartPosition = seiBuffer.getPosition();
-        for (TrackOutput output : outputs) {
-          seiBuffer.setPosition(sampleStartPosition);
-          output.sampleData(seiBuffer, sampleLength);
-          output.sampleMetadata(presentationTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleLength, 0, null);
+        nextPayloadPosition = seiBuffer.limit();
+      } else if (payloadType == PAYLOAD_TYPE_CC && payloadSize >= 8) {
+        int countryCode = seiBuffer.readUnsignedByte();
+        int providerCode = seiBuffer.readUnsignedShort();
+        int userIdentifier = 0;
+        if (providerCode == PROVIDER_CODE_ATSC) {
+          userIdentifier = seiBuffer.readInt();
+        }
+        int userDataTypeCode = seiBuffer.readUnsignedByte();
+        if (providerCode == PROVIDER_CODE_DIRECTV) {
+          seiBuffer.skipBytes(1); // user_data_length.
+        }
+        boolean messageIsSupportedCeaCaption =
+            countryCode == COUNTRY_CODE
+                && (providerCode == PROVIDER_CODE_ATSC || providerCode == PROVIDER_CODE_DIRECTV)
+                && userDataTypeCode == USER_DATA_TYPE_CODE;
+        if (providerCode == PROVIDER_CODE_ATSC) {
+          messageIsSupportedCeaCaption &=
+              userIdentifier == USER_ID_GA94 || userIdentifier == USER_ID_DTG1;
+        }
+        if (messageIsSupportedCeaCaption) {
+          // Ignore first three bits: reserved (1) + process_cc_data_flag (1) + zero_bit (1).
+          int ccCount = seiBuffer.readUnsignedByte() & 0x1F;
+          // Ignore em_data (1)
+          seiBuffer.skipBytes(1);
+          // Each data packet consists of 24 bits: marker bits (5) + cc_valid (1) + cc_type (2)
+          // + cc_data_1 (8) + cc_data_2 (8).
+          int sampleLength = ccCount * 3;
+          int sampleStartPosition = seiBuffer.getPosition();
+          for (TrackOutput output : outputs) {
+            seiBuffer.setPosition(sampleStartPosition);
+            output.sampleData(seiBuffer, sampleLength);
+            output.sampleMetadata(
+                presentationTimeUs, C.BUFFER_FLAG_KEY_FRAME, sampleLength, 0, null);
+          }
         }
-        // Ignore trailing information in SEI, if any.
-        seiBuffer.skipBytes(payloadSize - (10 + ccCount * 3));
-      } else {
-        seiBuffer.skipBytes(payloadSize);
       }
+      seiBuffer.setPosition(nextPayloadPosition);
     }
   }
 
@@ -97,31 +114,6 @@ private static int readNon255TerminatedValue(ParsableByteArray buffer) {
     return value;
   }
 
-  /**
-   * Inspects an sei message to determine whether it contains CEA-608.
-   * <p>
-   * The position of {@code payload} is left unchanged.
-   *
-   * @param payloadType The payload type of the message.
-   * @param payloadLength The length of the payload.
-   * @param payload A {@link ParsableByteArray} containing the payload.
-   * @return Whether the sei message contains CEA-608.
-   */
-  private static boolean isSeiMessageCea608(int payloadType, int payloadLength,
-      ParsableByteArray payload) {
-    if (payloadType != PAYLOAD_TYPE_CC || payloadLength < 8) {
-      return false;
-    }
-    int startPosition = payload.getPosition();
-    int countryCode = payload.readUnsignedByte();
-    int providerCode = payload.readUnsignedShort();
-    int userIdentifier = payload.readInt();
-    int userDataTypeCode = payload.readUnsignedByte();
-    payload.setPosition(startPosition);
-    return countryCode == COUNTRY_CODE && providerCode == PROVIDER_CODE
-        && userIdentifier == USER_ID && userDataTypeCode == USER_DATA_TYPE_CODE;
-  }
-
   private CeaUtil() {}
 
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbDecoder.java
index dbdc0434a1..df5b19c052 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/dvb/DvbDecoder.java
@@ -19,9 +19,7 @@
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.List;
 
-/**
- * A {@link SimpleSubtitleDecoder} for DVB Subtitles.
- */
+/** A {@link SimpleSubtitleDecoder} for DVB subtitles. */
 public final class DvbDecoder extends SimpleSubtitleDecoder {
 
   private final DvbParser parser;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java
new file mode 100644
index 0000000000..6d60da7d81
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsDecoder.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.pgs;
+
+import android.graphics.Bitmap;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.SimpleSubtitleDecoder;
+import com.google.android.exoplayer2.text.Subtitle;
+import com.google.android.exoplayer2.text.SubtitleDecoderException;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import com.google.android.exoplayer2.util.Util;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+
+/** A {@link SimpleSubtitleDecoder} for PGS subtitles. */
+public final class PgsDecoder extends SimpleSubtitleDecoder {
+
+  private static final int SECTION_TYPE_PALETTE = 0x14;
+  private static final int SECTION_TYPE_BITMAP_PICTURE = 0x15;
+  private static final int SECTION_TYPE_IDENTIFIER = 0x16;
+  private static final int SECTION_TYPE_END = 0x80;
+
+  private final ParsableByteArray buffer;
+  private final CueBuilder cueBuilder;
+
+  public PgsDecoder() {
+    super("PgsDecoder");
+    buffer = new ParsableByteArray();
+    cueBuilder = new CueBuilder();
+  }
+
+  @Override
+  protected Subtitle decode(byte[] data, int size, boolean reset) throws SubtitleDecoderException {
+    buffer.reset(data, size);
+    cueBuilder.reset();
+    ArrayList<Cue> cues = new ArrayList<>();
+    while (buffer.bytesLeft() >= 3) {
+      Cue cue = readNextSection(buffer, cueBuilder);
+      if (cue != null) {
+        cues.add(cue);
+      }
+    }
+    return new PgsSubtitle(Collections.unmodifiableList(cues));
+  }
+
+  private static Cue readNextSection(ParsableByteArray buffer, CueBuilder cueBuilder) {
+    int limit = buffer.limit();
+    int sectionType = buffer.readUnsignedByte();
+    int sectionLength = buffer.readUnsignedShort();
+
+    int nextSectionPosition = buffer.getPosition() + sectionLength;
+    if (nextSectionPosition > limit) {
+      buffer.setPosition(limit);
+      return null;
+    }
+
+    Cue cue = null;
+    switch (sectionType) {
+      case SECTION_TYPE_PALETTE:
+        cueBuilder.parsePaletteSection(buffer, sectionLength);
+        break;
+      case SECTION_TYPE_BITMAP_PICTURE:
+        cueBuilder.parseBitmapSection(buffer, sectionLength);
+        break;
+      case SECTION_TYPE_IDENTIFIER:
+        cueBuilder.parseIdentifierSection(buffer, sectionLength);
+        break;
+      case SECTION_TYPE_END:
+        cue = cueBuilder.build();
+        cueBuilder.reset();
+        break;
+      default:
+        break;
+    }
+
+    buffer.setPosition(nextSectionPosition);
+    return cue;
+  }
+
+  private static final class CueBuilder {
+
+    private final ParsableByteArray bitmapData;
+    private final int[] colors;
+
+    private boolean colorsSet;
+    private int planeWidth;
+    private int planeHeight;
+    private int bitmapX;
+    private int bitmapY;
+    private int bitmapWidth;
+    private int bitmapHeight;
+
+    public CueBuilder() {
+      bitmapData = new ParsableByteArray();
+      colors = new int[256];
+    }
+
+    private void parsePaletteSection(ParsableByteArray buffer, int sectionLength) {
+      if ((sectionLength % 5) != 2) {
+        // Section must be two bytes followed by a whole number of (index, y, cb, cr, a) entries.
+        return;
+      }
+      buffer.skipBytes(2);
+
+      Arrays.fill(colors, 0);
+      int entryCount = sectionLength / 5;
+      for (int i = 0; i < entryCount; i++) {
+        int index = buffer.readUnsignedByte();
+        int y = buffer.readUnsignedByte();
+        int cr = buffer.readUnsignedByte();
+        int cb = buffer.readUnsignedByte();
+        int a = buffer.readUnsignedByte();
+        int r = (int) (y + (1.40200 * (cr - 128)));
+        int g = (int) (y - (0.34414 * (cb - 128)) - (0.71414 * (cr - 128)));
+        int b = (int) (y + (1.77200 * (cb - 128)));
+        colors[index] =
+            (a << 24)
+                | (Util.constrainValue(r, 0, 255) << 16)
+                | (Util.constrainValue(g, 0, 255) << 8)
+                | Util.constrainValue(b, 0, 255);
+      }
+      colorsSet = true;
+    }
+
+    private void parseBitmapSection(ParsableByteArray buffer, int sectionLength) {
+      if (sectionLength < 4) {
+        return;
+      }
+      buffer.skipBytes(3); // Id (2 bytes), version (1 byte).
+      boolean isBaseSection = (0x80 & buffer.readUnsignedByte()) != 0;
+      sectionLength -= 4;
+
+      if (isBaseSection) {
+        if (sectionLength < 7) {
+          return;
+        }
+        int totalLength = buffer.readUnsignedInt24();
+        if (totalLength < 4) {
+          return;
+        }
+        bitmapWidth = buffer.readUnsignedShort();
+        bitmapHeight = buffer.readUnsignedShort();
+        bitmapData.reset(totalLength - 4);
+        sectionLength -= 7;
+      }
+
+      int position = bitmapData.getPosition();
+      int limit = bitmapData.limit();
+      if (position < limit && sectionLength > 0) {
+        int bytesToRead = Math.min(sectionLength, limit - position);
+        buffer.readBytes(bitmapData.data, position, bytesToRead);
+        bitmapData.setPosition(position + bytesToRead);
+      }
+    }
+
+    private void parseIdentifierSection(ParsableByteArray buffer, int sectionLength) {
+      if (sectionLength < 19) {
+        return;
+      }
+      planeWidth = buffer.readUnsignedShort();
+      planeHeight = buffer.readUnsignedShort();
+      buffer.skipBytes(11);
+      bitmapX = buffer.readUnsignedShort();
+      bitmapY = buffer.readUnsignedShort();
+    }
+
+    public Cue build() {
+      if (planeWidth == 0
+          || planeHeight == 0
+          || bitmapWidth == 0
+          || bitmapHeight == 0
+          || bitmapData.limit() == 0
+          || bitmapData.getPosition() != bitmapData.limit()
+          || !colorsSet) {
+        return null;
+      }
+      // Build the bitmapData.
+      bitmapData.setPosition(0);
+      int[] argbBitmapData = new int[bitmapWidth * bitmapHeight];
+      int argbBitmapDataIndex = 0;
+      while (argbBitmapDataIndex < argbBitmapData.length) {
+        int colorIndex = bitmapData.readUnsignedByte();
+        if (colorIndex != 0) {
+          argbBitmapData[argbBitmapDataIndex++] = colors[colorIndex];
+        } else {
+          int switchBits = bitmapData.readUnsignedByte();
+          if (switchBits != 0) {
+            int runLength =
+                (switchBits & 0x40) == 0
+                    ? (switchBits & 0x3F)
+                    : (((switchBits & 0x3F) << 8) | bitmapData.readUnsignedByte());
+            int color = (switchBits & 0x80) == 0 ? 0 : colors[bitmapData.readUnsignedByte()];
+            Arrays.fill(
+                argbBitmapData, argbBitmapDataIndex, argbBitmapDataIndex + runLength, color);
+            argbBitmapDataIndex += runLength;
+          }
+        }
+      }
+      Bitmap bitmap =
+          Bitmap.createBitmap(argbBitmapData, bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
+      // Build the cue.
+      return new Cue(
+          bitmap,
+          (float) bitmapX / planeWidth,
+          Cue.ANCHOR_TYPE_START,
+          (float) bitmapY / planeHeight,
+          Cue.ANCHOR_TYPE_START,
+          (float) bitmapWidth / planeWidth,
+          (float) bitmapHeight / planeHeight);
+    }
+
+    public void reset() {
+      planeWidth = 0;
+      planeHeight = 0;
+      bitmapX = 0;
+      bitmapY = 0;
+      bitmapWidth = 0;
+      bitmapHeight = 0;
+      bitmapData.reset(0);
+      colorsSet = false;
+    }
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsSubtitle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsSubtitle.java
new file mode 100644
index 0000000000..9f9af6b6a4
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/pgs/PgsSubtitle.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.pgs;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.Subtitle;
+import java.util.List;
+
+/** A representation of a PGS subtitle. */
+/* package */ final class PgsSubtitle implements Subtitle {
+
+  private final List<Cue> cues;
+
+  public PgsSubtitle(List<Cue> cues) {
+    this.cues = cues;
+  }
+
+  @Override
+  public int getNextEventTimeIndex(long timeUs) {
+    return C.INDEX_UNSET;
+  }
+
+  @Override
+  public int getEventTimeCount() {
+    return 1;
+  }
+
+  @Override
+  public long getEventTime(int index) {
+    return 0;
+  }
+
+  @Override
+  public List<Cue> getCues(long timeUs) {
+    return cues;
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
index eec4a1269c..0cb6f66898 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/ssa/SsaDecoder.java
@@ -150,6 +150,12 @@ private void parseFormatLine(String formatLine) {
           break;
       }
     }
+    if (formatStartIndex == C.INDEX_UNSET
+        || formatEndIndex == C.INDEX_UNSET
+        || formatTextIndex == C.INDEX_UNSET) {
+      // Set to 0 so that parseDialogueLine skips lines until a complete format line is found.
+      formatKeyCount = 0;
+    }
   }
 
   /**
@@ -161,12 +167,17 @@ private void parseFormatLine(String formatLine) {
    */
   private void parseDialogueLine(String dialogueLine, List<Cue> cues, LongArray cueTimesUs) {
     if (formatKeyCount == 0) {
-      Log.w(TAG, "Skipping dialogue line before format: " + dialogueLine);
+      Log.w(TAG, "Skipping dialogue line before complete format: " + dialogueLine);
       return;
     }
 
     String[] lineValues = dialogueLine.substring(DIALOGUE_LINE_PREFIX.length())
         .split(",", formatKeyCount);
+    if (lineValues.length != formatKeyCount) {
+      Log.w(TAG, "Skipping dialogue line with fewer columns than format: " + dialogueLine);
+      return;
+    }
+
     long startTimeUs = SsaDecoder.parseTimecodeUs(lineValues[formatStartIndex]);
     if (startTimeUs == C.TIME_UNSET) {
       Log.w(TAG, "Skipping invalid timing: " + dialogueLine);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
index 10c17e2888..a78c5afa78 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCssStyle.java
@@ -31,10 +31,11 @@
  * @see <a href="https://w3c.github.io/webvtt/#applying-css-properties">W3C specification - Apply
  *     CSS properties</a>
  */
-/* package */ final class WebvttCssStyle {
+public final class WebvttCssStyle {
 
   public static final int UNSPECIFIED = -1;
 
+  /** Style flag enum */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef(flag = true, value = {UNSPECIFIED, STYLE_NORMAL, STYLE_BOLD, STYLE_ITALIC,
       STYLE_BOLD_ITALIC})
@@ -44,6 +45,7 @@
   public static final int STYLE_ITALIC = Typeface.ITALIC;
   public static final int STYLE_BOLD_ITALIC = Typeface.BOLD_ITALIC;
 
+  /** Font size unit enum */
   @Retention(RetentionPolicy.SOURCE)
   @IntDef({UNSPECIFIED, FONT_SIZE_UNIT_PIXEL, FONT_SIZE_UNIT_EM, FONT_SIZE_UNIT_PERCENT})
   public @interface FontSizeUnit {}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
index 295fdc656f..e16b231f7e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCue.java
@@ -23,7 +23,7 @@
 /**
  * A representation of a WebVTT cue.
  */
-/* package */ final class WebvttCue extends Cue {
+public final class WebvttCue extends Cue {
 
   public final long startTime;
   public final long endTime;
@@ -59,7 +59,7 @@ public boolean isNormalCue() {
    * Builder for WebVTT cues.
    */
   @SuppressWarnings("hiding")
-  public static final class Builder {
+  public static class Builder {
 
     private static final String TAG = "WebvttCueBuilder";
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
index 54af4dbf63..80ebecdc0e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParser.java
@@ -45,7 +45,7 @@
 /**
  * Parser for WebVTT cues. (https://w3c.github.io/webvtt/#cues)
  */
-/* package */ final class WebvttCueParser {
+public final class WebvttCueParser {
 
   public static final Pattern CUE_HEADER_PATTERN = Pattern
       .compile("^(\\S+)\\s+-->\\s+(\\S+)(.*)?$");
@@ -90,7 +90,7 @@ public WebvttCueParser() {
    * @param styles List of styles defined by the CSS style blocks preceeding the cues.
    * @return Whether a valid Cue was found.
    */
-  /* package */ boolean parseCue(ParsableByteArray webvttData, WebvttCue.Builder builder,
+  public boolean parseCue(ParsableByteArray webvttData, WebvttCue.Builder builder,
       List<WebvttCssStyle> styles) {
     String firstLine = webvttData.readLine();
     if (firstLine == null) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
index f9eddab286..973155c2e3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java
@@ -15,12 +15,13 @@
  */
 package com.google.android.exoplayer2.trackselection;
 
-import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.Util;
 import java.util.List;
 
 /**
@@ -41,17 +42,23 @@
     private final int minDurationToRetainAfterDiscardMs;
     private final float bandwidthFraction;
     private final float bufferedFractionToLiveEdgeForQualityIncrease;
+    private final long minTimeBetweenBufferReevaluationMs;
+    private final Clock clock;
 
     /**
      * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
      */
     public Factory(BandwidthMeter bandwidthMeter) {
-      this (bandwidthMeter, DEFAULT_MAX_INITIAL_BITRATE,
+      this(
+          bandwidthMeter,
+          DEFAULT_MAX_INITIAL_BITRATE,
           DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
           DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
           DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
           DEFAULT_BANDWIDTH_FRACTION,
-          DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE);
+          DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+          DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+          Clock.DEFAULT);
     }
 
     /**
@@ -73,37 +80,55 @@ public Factory(BandwidthMeter bandwidthMeter) {
     public Factory(BandwidthMeter bandwidthMeter, int maxInitialBitrate,
         int minDurationForQualityIncreaseMs, int maxDurationForQualityDecreaseMs,
         int minDurationToRetainAfterDiscardMs, float bandwidthFraction) {
-      this (bandwidthMeter, maxInitialBitrate, minDurationForQualityIncreaseMs,
-          maxDurationForQualityDecreaseMs, minDurationToRetainAfterDiscardMs,
-          bandwidthFraction, DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE);
+      this(
+          bandwidthMeter,
+          maxInitialBitrate,
+          minDurationForQualityIncreaseMs,
+          maxDurationForQualityDecreaseMs,
+          minDurationToRetainAfterDiscardMs,
+          bandwidthFraction,
+          DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+          DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+          Clock.DEFAULT);
     }
 
     /**
      * @param bandwidthMeter Provides an estimate of the currently available bandwidth.
-     * @param maxInitialBitrate The maximum bitrate in bits per second that should be assumed
-     *     when a bandwidth estimate is unavailable.
-     * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for
-     *     the selected track to switch to one of higher quality.
-     * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for
-     *     the selected track to switch to one of lower quality.
+     * @param maxInitialBitrate The maximum bitrate in bits per second that should be assumed when a
+     *     bandwidth estimate is unavailable.
+     * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for the
+     *     selected track to switch to one of higher quality.
+     * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for the
+     *     selected track to switch to one of lower quality.
      * @param minDurationToRetainAfterDiscardMs When switching to a track of significantly higher
      *     quality, the selection may indicate that media already buffered at the lower quality can
      *     be discarded to speed up the switch. This is the minimum duration of media that must be
      *     retained at the lower quality.
      * @param bandwidthFraction The fraction of the available bandwidth that the selection should
-     *     consider available for use. Setting to a value less than 1 is recommended to account
-     *     for inaccuracies in the bandwidth estimator.
-     * @param bufferedFractionToLiveEdgeForQualityIncrease For live streaming, the fraction of
-     *     the duration from current playback position to the live edge that has to be buffered
-     *     before the selected track can be switched to one of higher quality. This parameter is
-     *     only applied when the playback position is closer to the live edge than
-     *     {@code minDurationForQualityIncreaseMs}, which would otherwise prevent switching to a
-     *     higher quality from happening.
+     *     consider available for use. Setting to a value less than 1 is recommended to account for
+     *     inaccuracies in the bandwidth estimator.
+     * @param bufferedFractionToLiveEdgeForQualityIncrease For live streaming, the fraction of the
+     *     duration from current playback position to the live edge that has to be buffered before
+     *     the selected track can be switched to one of higher quality. This parameter is only
+     *     applied when the playback position is closer to the live edge than {@code
+     *     minDurationForQualityIncreaseMs}, which would otherwise prevent switching to a higher
+     *     quality from happening.
+     * @param minTimeBetweenBufferReevaluationMs The track selection may periodically reevaluate its
+     *     buffer and discard some chunks of lower quality to improve the playback quality if
+     *     network conditions have changed. This is the minimum duration between 2 consecutive
+     *     buffer reevaluation calls.
+     * @param clock A {@link Clock}.
      */
-    public Factory(BandwidthMeter bandwidthMeter, int maxInitialBitrate,
-        int minDurationForQualityIncreaseMs, int maxDurationForQualityDecreaseMs,
-        int minDurationToRetainAfterDiscardMs, float bandwidthFraction,
-        float bufferedFractionToLiveEdgeForQualityIncrease) {
+    public Factory(
+        BandwidthMeter bandwidthMeter,
+        int maxInitialBitrate,
+        int minDurationForQualityIncreaseMs,
+        int maxDurationForQualityDecreaseMs,
+        int minDurationToRetainAfterDiscardMs,
+        float bandwidthFraction,
+        float bufferedFractionToLiveEdgeForQualityIncrease,
+        long minTimeBetweenBufferReevaluationMs,
+        Clock clock) {
       this.bandwidthMeter = bandwidthMeter;
       this.maxInitialBitrate = maxInitialBitrate;
       this.minDurationForQualityIncreaseMs = minDurationForQualityIncreaseMs;
@@ -112,14 +137,24 @@ public Factory(BandwidthMeter bandwidthMeter, int maxInitialBitrate,
       this.bandwidthFraction = bandwidthFraction;
       this.bufferedFractionToLiveEdgeForQualityIncrease =
           bufferedFractionToLiveEdgeForQualityIncrease;
+      this.minTimeBetweenBufferReevaluationMs = minTimeBetweenBufferReevaluationMs;
+      this.clock = clock;
     }
 
     @Override
     public AdaptiveTrackSelection createTrackSelection(TrackGroup group, int... tracks) {
-      return new AdaptiveTrackSelection(group, tracks, bandwidthMeter, maxInitialBitrate,
-          minDurationForQualityIncreaseMs, maxDurationForQualityDecreaseMs,
-          minDurationToRetainAfterDiscardMs, bandwidthFraction,
-          bufferedFractionToLiveEdgeForQualityIncrease);
+      return new AdaptiveTrackSelection(
+          group,
+          tracks,
+          bandwidthMeter,
+          maxInitialBitrate,
+          minDurationForQualityIncreaseMs,
+          maxDurationForQualityDecreaseMs,
+          minDurationToRetainAfterDiscardMs,
+          bandwidthFraction,
+          bufferedFractionToLiveEdgeForQualityIncrease,
+          minTimeBetweenBufferReevaluationMs,
+          clock);
     }
 
   }
@@ -130,6 +165,7 @@ public AdaptiveTrackSelection createTrackSelection(TrackGroup group, int... trac
   public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;
   public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f;
   public static final float DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE = 0.75f;
+  public static final long DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS = 2000;
 
   private final BandwidthMeter bandwidthMeter;
   private final int maxInitialBitrate;
@@ -138,9 +174,13 @@ public AdaptiveTrackSelection createTrackSelection(TrackGroup group, int... trac
   private final long minDurationToRetainAfterDiscardUs;
   private final float bandwidthFraction;
   private final float bufferedFractionToLiveEdgeForQualityIncrease;
+  private final long minTimeBetweenBufferReevaluationMs;
+  private final Clock clock;
 
+  private float playbackSpeed;
   private int selectedIndex;
   private int reason;
+  private long lastBufferEvaluationMs;
 
   /**
    * @param group The {@link TrackGroup}.
@@ -150,12 +190,18 @@ public AdaptiveTrackSelection createTrackSelection(TrackGroup group, int... trac
    */
   public AdaptiveTrackSelection(TrackGroup group, int[] tracks,
       BandwidthMeter bandwidthMeter) {
-    this (group, tracks, bandwidthMeter, DEFAULT_MAX_INITIAL_BITRATE,
+    this(
+        group,
+        tracks,
+        bandwidthMeter,
+        DEFAULT_MAX_INITIAL_BITRATE,
         DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
         DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
         DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
         DEFAULT_BANDWIDTH_FRACTION,
-        DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE);
+        DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+        DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+        Clock.DEFAULT);
   }
 
   /**
@@ -170,23 +216,35 @@ public AdaptiveTrackSelection(TrackGroup group, int[] tracks,
    * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for the
    *     selected track to switch to one of lower quality.
    * @param minDurationToRetainAfterDiscardMs When switching to a track of significantly higher
-   *     quality, the selection may indicate that media already buffered at the lower quality can
-   *     be discarded to speed up the switch. This is the minimum duration of media that must be
+   *     quality, the selection may indicate that media already buffered at the lower quality can be
+   *     discarded to speed up the switch. This is the minimum duration of media that must be
    *     retained at the lower quality.
    * @param bandwidthFraction The fraction of the available bandwidth that the selection should
-   *     consider available for use. Setting to a value less than 1 is recommended to account
-   *     for inaccuracies in the bandwidth estimator.
-   * @param bufferedFractionToLiveEdgeForQualityIncrease For live streaming, the fraction of
-   *     the duration from current playback position to the live edge that has to be buffered
-   *     before the selected track can be switched to one of higher quality. This parameter is
-   *     only applied when the playback position is closer to the live edge than
-   *     {@code minDurationForQualityIncreaseMs}, which would otherwise prevent switching to a
-   *     higher quality from happening.
+   *     consider available for use. Setting to a value less than 1 is recommended to account for
+   *     inaccuracies in the bandwidth estimator.
+   * @param bufferedFractionToLiveEdgeForQualityIncrease For live streaming, the fraction of the
+   *     duration from current playback position to the live edge that has to be buffered before the
+   *     selected track can be switched to one of higher quality. This parameter is only applied
+   *     when the playback position is closer to the live edge than {@code
+   *     minDurationForQualityIncreaseMs}, which would otherwise prevent switching to a higher
+   *     quality from happening.
+   * @param minTimeBetweenBufferReevaluationMs The track selection may periodically reevaluate its
+   *     buffer and discard some chunks of lower quality to improve the playback quality if network
+   *     condition has changed. This is the minimum duration between 2 consecutive buffer
+   *     reevaluation calls.
    */
-  public AdaptiveTrackSelection(TrackGroup group, int[] tracks, BandwidthMeter bandwidthMeter,
-      int maxInitialBitrate, long minDurationForQualityIncreaseMs,
-      long maxDurationForQualityDecreaseMs, long minDurationToRetainAfterDiscardMs,
-      float bandwidthFraction, float bufferedFractionToLiveEdgeForQualityIncrease) {
+  public AdaptiveTrackSelection(
+      TrackGroup group,
+      int[] tracks,
+      BandwidthMeter bandwidthMeter,
+      int maxInitialBitrate,
+      long minDurationForQualityIncreaseMs,
+      long maxDurationForQualityDecreaseMs,
+      long minDurationToRetainAfterDiscardMs,
+      float bandwidthFraction,
+      float bufferedFractionToLiveEdgeForQualityIncrease,
+      long minTimeBetweenBufferReevaluationMs,
+      Clock clock) {
     super(group, tracks);
     this.bandwidthMeter = bandwidthMeter;
     this.maxInitialBitrate = maxInitialBitrate;
@@ -196,14 +254,28 @@ public AdaptiveTrackSelection(TrackGroup group, int[] tracks, BandwidthMeter ban
     this.bandwidthFraction = bandwidthFraction;
     this.bufferedFractionToLiveEdgeForQualityIncrease =
         bufferedFractionToLiveEdgeForQualityIncrease;
+    this.minTimeBetweenBufferReevaluationMs = minTimeBetweenBufferReevaluationMs;
+    this.clock = clock;
+    playbackSpeed = 1f;
     selectedIndex = determineIdealSelectedIndex(Long.MIN_VALUE);
     reason = C.SELECTION_REASON_INITIAL;
+    lastBufferEvaluationMs = C.TIME_UNSET;
+  }
+
+  @Override
+  public void enable() {
+    lastBufferEvaluationMs = C.TIME_UNSET;
+  }
+
+  @Override
+  public void onPlaybackSpeed(float playbackSpeed) {
+    this.playbackSpeed = playbackSpeed;
   }
 
   @Override
   public void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
       long availableDurationUs) {
-    long nowMs = SystemClock.elapsedRealtime();
+    long nowMs = clock.elapsedRealtime();
     // Stash the current selection, then make a new one.
     int currentSelectedIndex = selectedIndex;
     selectedIndex = determineIdealSelectedIndex(nowMs);
@@ -250,15 +322,25 @@ public Object getSelectionData() {
 
   @Override
   public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
+    long nowMs = clock.elapsedRealtime();
+    if (lastBufferEvaluationMs != C.TIME_UNSET
+        && nowMs - lastBufferEvaluationMs < minTimeBetweenBufferReevaluationMs) {
+      return queue.size();
+    }
+    lastBufferEvaluationMs = nowMs;
     if (queue.isEmpty()) {
       return 0;
     }
+
     int queueSize = queue.size();
-    long bufferedDurationUs = queue.get(queueSize - 1).endTimeUs - playbackPositionUs;
-    if (bufferedDurationUs < minDurationToRetainAfterDiscardUs) {
+    MediaChunk lastChunk = queue.get(queueSize - 1);
+    long playoutBufferedDurationBeforeLastChunkUs =
+        Util.getPlayoutDurationForMediaDuration(
+            lastChunk.startTimeUs - playbackPositionUs, playbackSpeed);
+    if (playoutBufferedDurationBeforeLastChunkUs < minDurationToRetainAfterDiscardUs) {
       return queueSize;
     }
-    int idealSelectedIndex = determineIdealSelectedIndex(SystemClock.elapsedRealtime());
+    int idealSelectedIndex = determineIdealSelectedIndex(nowMs);
     Format idealFormat = getFormat(idealSelectedIndex);
     // If the chunks contain video, discard from the first SD chunk beyond
     // minDurationToRetainAfterDiscardUs whose resolution and bitrate are both lower than the ideal
@@ -266,8 +348,10 @@ public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk>
     for (int i = 0; i < queueSize; i++) {
       MediaChunk chunk = queue.get(i);
       Format format = chunk.trackFormat;
-      long durationBeforeThisChunkUs = chunk.startTimeUs - playbackPositionUs;
-      if (durationBeforeThisChunkUs >= minDurationToRetainAfterDiscardUs
+      long mediaDurationBeforeThisChunkUs = chunk.startTimeUs - playbackPositionUs;
+      long playoutDurationBeforeThisChunkUs =
+          Util.getPlayoutDurationForMediaDuration(mediaDurationBeforeThisChunkUs, playbackSpeed);
+      if (playoutDurationBeforeThisChunkUs >= minDurationToRetainAfterDiscardUs
           && format.bitrate < idealFormat.bitrate
           && format.height != Format.NO_VALUE && format.height < 720
           && format.width != Format.NO_VALUE && format.width < 1280
@@ -281,8 +365,8 @@ public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk>
   /**
    * Computes the ideal selected index ignoring buffer health.
    *
-   * @param nowMs The current time in the timebase of {@link SystemClock#elapsedRealtime()}, or
-   *     {@link Long#MIN_VALUE} to ignore blacklisting.
+   * @param nowMs The current time in the timebase of {@link Clock#elapsedRealtime()}, or {@link
+   *     Long#MIN_VALUE} to ignore blacklisting.
    */
   private int determineIdealSelectedIndex(long nowMs) {
     long bitrateEstimate = bandwidthMeter.getBitrateEstimate();
@@ -292,7 +376,7 @@ private int determineIdealSelectedIndex(long nowMs) {
     for (int i = 0; i < length; i++) {
       if (nowMs == Long.MIN_VALUE || !isBlacklisted(i, nowMs)) {
         Format format = getFormat(i);
-        if (format.bitrate <= effectiveBitrate) {
+        if (Math.round(format.bitrate * playbackSpeed) <= effectiveBitrate) {
           return i;
         } else {
           lowestBitrateNonBlacklistedIndex = i;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
index 054ee7973f..9a58ac07aa 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/BaseTrackSelection.java
@@ -78,6 +78,16 @@ public BaseTrackSelection(TrackGroup group, int... tracks) {
     blacklistUntilTimes = new long[length];
   }
 
+  @Override
+  public void enable() {
+    // Do nothing.
+  }
+
+  @Override
+  public void disable() {
+    // Do nothing.
+  }
+
   @Override
   public final TrackGroup getTrackGroup() {
     return group;
@@ -128,6 +138,11 @@ public final int getSelectedIndexInTrackGroup() {
     return tracks[getSelectedIndex()];
   }
 
+  @Override
+  public void onPlaybackSpeed(float playbackSpeed) {
+    // Do nothing.
+  }
+
   @Override
   public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
     return queue.size();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
index c789caded4..509e86345e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.java
@@ -17,6 +17,7 @@
 
 import android.content.Context;
 import android.graphics.Point;
+import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -46,7 +47,7 @@
  * Parameters currentParameters = trackSelector.getParameters();
  * // Generate new parameters to prefer German audio and impose a maximum video size constraint.
  * Parameters newParameters = currentParameters
- *     .withPreferredAudioLanguage("de")
+ *     .withPreferredAudioLanguage("deu")
  *     .withMaxVideoSize(1024, 768);
  * // Set the new parameters on the selector.
  * trackSelector.setParameters(newParameters);}
@@ -75,308 +76,410 @@
 public class DefaultTrackSelector extends MappingTrackSelector {
 
   /**
-   * Constraint parameters for {@link DefaultTrackSelector}.
+   * A builder for {@link Parameters}.
    */
-  public static final class Parameters {
+  public static final class ParametersBuilder {
+
+    private String preferredAudioLanguage;
+    private String preferredTextLanguage;
+    private boolean selectUndeterminedTextLanguage;
+    private int disabledTextTrackSelectionFlags;
+    private boolean forceLowestBitrate;
+    private boolean allowMixedMimeAdaptiveness;
+    private boolean allowNonSeamlessAdaptiveness;
+    private int maxVideoWidth;
+    private int maxVideoHeight;
+    private int maxVideoBitrate;
+    private boolean exceedVideoConstraintsIfNecessary;
+    private boolean exceedRendererCapabilitiesIfNecessary;
+    private int viewportWidth;
+    private int viewportHeight;
+    private boolean viewportOrientationMayChange;
 
-    // Audio
     /**
-     * The preferred language for audio, as well as for forced text tracks as defined by RFC 5646.
-     * {@code null} selects the default track, or the first track if there's no default.
+     * Creates a builder obtaining the initial values from {@link Parameters#DEFAULT}.
      */
-    public final String preferredAudioLanguage;
+    public ParametersBuilder() {
+      this(Parameters.DEFAULT);
+    }
 
-    // Text
     /**
-     * The preferred language for text tracks as defined by RFC 5646. {@code null} selects the
-     * default track if there is one, or no track otherwise.
+     * @param initialValues The {@link Parameters} from which the initial values of the builder are
+     *     obtained.
      */
-    public final String preferredTextLanguage;
+    private ParametersBuilder(Parameters initialValues) {
+      preferredAudioLanguage = initialValues.preferredAudioLanguage;
+      preferredTextLanguage = initialValues.preferredTextLanguage;
+      selectUndeterminedTextLanguage = initialValues.selectUndeterminedTextLanguage;
+      disabledTextTrackSelectionFlags = initialValues.disabledTextTrackSelectionFlags;
+      forceLowestBitrate = initialValues.forceLowestBitrate;
+      allowMixedMimeAdaptiveness = initialValues.allowMixedMimeAdaptiveness;
+      allowNonSeamlessAdaptiveness = initialValues.allowNonSeamlessAdaptiveness;
+      maxVideoWidth = initialValues.maxVideoWidth;
+      maxVideoHeight = initialValues.maxVideoHeight;
+      maxVideoBitrate = initialValues.maxVideoBitrate;
+      exceedVideoConstraintsIfNecessary = initialValues.exceedVideoConstraintsIfNecessary;
+      exceedRendererCapabilitiesIfNecessary = initialValues.exceedRendererCapabilitiesIfNecessary;
+      viewportWidth = initialValues.viewportWidth;
+      viewportHeight = initialValues.viewportHeight;
+      viewportOrientationMayChange = initialValues.viewportOrientationMayChange;
+    }
 
-    // Video
-    /**
-     * Maximum allowed video width.
-     */
-    public final int maxVideoWidth;
-    /**
-     * Maximum allowed video height.
-     */
-    public final int maxVideoHeight;
-    /**
-     * Maximum video bitrate.
-     */
-    public final int maxVideoBitrate;
     /**
-     * Whether to exceed video constraints when no selection can be made otherwise.
+     * See {@link Parameters#preferredAudioLanguage}.
+     *
+     * @return This builder.
      */
-    public final boolean exceedVideoConstraintsIfNecessary;
+    public ParametersBuilder setPreferredAudioLanguage(String preferredAudioLanguage) {
+      this.preferredAudioLanguage = preferredAudioLanguage;
+      return this;
+    }
+
     /**
-     * Viewport width in pixels. Constrains video tracks selections for adaptive playbacks so that
-     * only tracks suitable for the viewport are selected.
+     * See {@link Parameters#preferredTextLanguage}.
+     *
+     * @return This builder.
      */
-    public final int viewportWidth;
+    public ParametersBuilder setPreferredTextLanguage(String preferredTextLanguage) {
+      this.preferredTextLanguage = preferredTextLanguage;
+      return this;
+    }
+
     /**
-     * Viewport height in pixels. Constrains video tracks selections for adaptive playbacks so that
-     * only tracks suitable for the viewport are selected.
+     * See {@link Parameters#selectUndeterminedTextLanguage}.
+     *
+     * @return This builder.
      */
-    public final int viewportHeight;
+    public ParametersBuilder setSelectUndeterminedTextLanguage(
+        boolean selectUndeterminedTextLanguage) {
+      this.selectUndeterminedTextLanguage = selectUndeterminedTextLanguage;
+      return this;
+    }
+
     /**
-     * Whether the viewport orientation may change during playback. Constrains video tracks
-     * selections for adaptive playbacks so that only tracks suitable for the viewport are selected.
+     * See {@link Parameters#disabledTextTrackSelectionFlags}.
+     *
+     * @return This builder.
      */
-    public final boolean viewportOrientationMayChange;
+    public ParametersBuilder setDisabledTextTrackSelectionFlags(
+        int disabledTextTrackSelectionFlags) {
+      this.disabledTextTrackSelectionFlags = disabledTextTrackSelectionFlags;
+      return this;
+    }
 
-    // General
     /**
-     * Whether to force selection of the single lowest bitrate audio and video tracks that comply
-     * with all other constraints.
+     * See {@link Parameters#forceLowestBitrate}.
+     *
+     * @return This builder.
      */
-    public final boolean forceLowestBitrate;
+    public ParametersBuilder setForceLowestBitrate(boolean forceLowestBitrate) {
+      this.forceLowestBitrate = forceLowestBitrate;
+      return this;
+    }
+
     /**
-     * Whether to allow adaptive selections containing mixed mime types.
+     * See {@link Parameters#allowMixedMimeAdaptiveness}.
+     *
+     * @return This builder.
      */
-    public final boolean allowMixedMimeAdaptiveness;
+    public ParametersBuilder setAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
+      this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
+      return this;
+    }
+
     /**
-     * Whether to allow adaptive selections where adaptation may not be completely seamless.
+     * See {@link Parameters#allowNonSeamlessAdaptiveness}.
+     *
+     * @return This builder.
      */
-    public final boolean allowNonSeamlessAdaptiveness;
+    public ParametersBuilder setAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
+      this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
+      return this;
+    }
+
     /**
-     * Whether to exceed renderer capabilities when no selection can be made otherwise.
+     * Equivalent to {@link #setMaxVideoSize setMaxVideoSize(1279, 719)}.
+     *
+     * @return This builder.
      */
-    public final boolean exceedRendererCapabilitiesIfNecessary;
+    public ParametersBuilder setMaxVideoSizeSd() {
+      return setMaxVideoSize(1279, 719);
+    }
 
     /**
-     * Default parameters. The default values are:
-     * <ul>
-     *   <li>No preferred audio language is set.</li>
-     *   <li>No preferred text language is set.</li>
-     *   <li>Lowest bitrate track selections are not forced.</li>
-     *   <li>Adaptation between different mime types is not allowed.</li>
-     *   <li>Non seamless adaptation is allowed.</li>
-     *   <li>No max limit for video width/height.</li>
-     *   <li>No max video bitrate.</li>
-     *   <li>Video constraints are exceeded if no supported selection can be made otherwise.</li>
-     *   <li>Renderer capabilities are exceeded if no supported selection can be made.</li>
-     *   <li>No viewport constraints are set.</li>
-     * </ul>
+     * Equivalent to {@link #setMaxVideoSize setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE)}.
+     *
+     * @return This builder.
      */
-    public Parameters() {
-      this(null, null, false, false, true, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE,
-          true, true, Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+    public ParametersBuilder clearVideoSizeConstraints() {
+      return setMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
     }
 
     /**
-     * @param preferredAudioLanguage See {@link #preferredAudioLanguage}
-     * @param preferredTextLanguage See {@link #preferredTextLanguage}
-     * @param forceLowestBitrate See {@link #forceLowestBitrate}.
-     * @param allowMixedMimeAdaptiveness See {@link #allowMixedMimeAdaptiveness}
-     * @param allowNonSeamlessAdaptiveness See {@link #allowNonSeamlessAdaptiveness}
-     * @param maxVideoWidth See {@link #maxVideoWidth}
-     * @param maxVideoHeight See {@link #maxVideoHeight}
-     * @param maxVideoBitrate See {@link #maxVideoBitrate}
-     * @param exceedVideoConstraintsIfNecessary See {@link #exceedVideoConstraintsIfNecessary}
-     * @param exceedRendererCapabilitiesIfNecessary See {@link #preferredTextLanguage}
-     * @param viewportWidth See {@link #viewportWidth}
-     * @param viewportHeight See {@link #viewportHeight}
-     * @param viewportOrientationMayChange See {@link #viewportOrientationMayChange}
+     * See {@link Parameters#maxVideoWidth} and {@link Parameters#maxVideoHeight}.
+     *
+     * @return This builder.
      */
-    public Parameters(String preferredAudioLanguage, String preferredTextLanguage,
-        boolean forceLowestBitrate, boolean allowMixedMimeAdaptiveness,
-        boolean allowNonSeamlessAdaptiveness, int maxVideoWidth, int maxVideoHeight,
-        int maxVideoBitrate, boolean exceedVideoConstraintsIfNecessary,
-        boolean exceedRendererCapabilitiesIfNecessary, int viewportWidth, int viewportHeight,
-        boolean viewportOrientationMayChange) {
-      this.preferredAudioLanguage = preferredAudioLanguage;
-      this.preferredTextLanguage = preferredTextLanguage;
-      this.forceLowestBitrate = forceLowestBitrate;
-      this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
-      this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
+    public ParametersBuilder setMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
       this.maxVideoWidth = maxVideoWidth;
       this.maxVideoHeight = maxVideoHeight;
-      this.maxVideoBitrate = maxVideoBitrate;
-      this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
-      this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
-      this.viewportWidth = viewportWidth;
-      this.viewportHeight = viewportHeight;
-      this.viewportOrientationMayChange = viewportOrientationMayChange;
+      return this;
     }
 
     /**
-     * Returns an instance with the provided {@link #preferredAudioLanguage}.
+     * See {@link Parameters#maxVideoBitrate}.
+     *
+     * @return This builder.
      */
-    public Parameters withPreferredAudioLanguage(String preferredAudioLanguage) {
-      preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
-      if (TextUtils.equals(preferredAudioLanguage, this.preferredAudioLanguage)) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
+    public ParametersBuilder setMaxVideoBitrate(int maxVideoBitrate) {
+      this.maxVideoBitrate = maxVideoBitrate;
+      return this;
     }
 
     /**
-     * Returns an instance with the provided {@link #preferredTextLanguage}.
+     * See {@link Parameters#exceedVideoConstraintsIfNecessary}.
+     *
+     * @return This builder.
      */
-    public Parameters withPreferredTextLanguage(String preferredTextLanguage) {
-      preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
-      if (TextUtils.equals(preferredTextLanguage, this.preferredTextLanguage)) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
+    public ParametersBuilder setExceedVideoConstraintsIfNecessary(
+        boolean exceedVideoConstraintsIfNecessary) {
+      this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
+      return this;
     }
 
     /**
-     * Returns an instance with the provided {@link #forceLowestBitrate}.
+     * See {@link Parameters#exceedRendererCapabilitiesIfNecessary}.
+     *
+     * @return This builder.
      */
-    public Parameters withForceLowestBitrate(boolean forceLowestBitrate) {
-      if (forceLowestBitrate == this.forceLowestBitrate) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
+    public ParametersBuilder setExceedRendererCapabilitiesIfNecessary(
+        boolean exceedRendererCapabilitiesIfNecessary) {
+      this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
+      return this;
     }
 
     /**
-     * Returns an instance with the provided {@link #allowMixedMimeAdaptiveness}.
+     * Equivalent to invoking {@link #setViewportSize} with the viewport size obtained from
+     * {@link Util#getPhysicalDisplaySize(Context)}.
+     *
+     * @param context The context to obtain the viewport size from.
+     * @param viewportOrientationMayChange See {@link #viewportOrientationMayChange}.
+     * @return This builder.
      */
-    public Parameters withAllowMixedMimeAdaptiveness(boolean allowMixedMimeAdaptiveness) {
-      if (allowMixedMimeAdaptiveness == this.allowMixedMimeAdaptiveness) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
+    public ParametersBuilder setViewportSizeToPhysicalDisplaySize(Context context,
+        boolean viewportOrientationMayChange) {
+      // Assume the viewport is fullscreen.
+      Point viewportSize = Util.getPhysicalDisplaySize(context);
+      return setViewportSize(viewportSize.x, viewportSize.y, viewportOrientationMayChange);
     }
 
     /**
-     * Returns an instance with the provided {@link #allowNonSeamlessAdaptiveness}.
+     * Equivalent to
+     * {@link #setViewportSize setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true)}.
+     *
+     * @return This builder.
      */
-    public Parameters withAllowNonSeamlessAdaptiveness(boolean allowNonSeamlessAdaptiveness) {
-      if (allowNonSeamlessAdaptiveness == this.allowNonSeamlessAdaptiveness) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
+    public ParametersBuilder clearViewportSizeConstraints() {
+      return setViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true);
     }
 
     /**
-     * Returns an instance with the provided {@link #maxVideoWidth} and {@link #maxVideoHeight}.
+     * See {@link Parameters#viewportWidth}, {@link Parameters#maxVideoHeight} and
+     * {@link Parameters#viewportOrientationMayChange}.
+     *
+     * @return This builder.
      */
-    public Parameters withMaxVideoSize(int maxVideoWidth, int maxVideoHeight) {
-      if (maxVideoWidth == this.maxVideoWidth && maxVideoHeight == this.maxVideoHeight) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
+    public ParametersBuilder setViewportSize(int viewportWidth, int viewportHeight,
+        boolean viewportOrientationMayChange) {
+      this.viewportWidth = viewportWidth;
+      this.viewportHeight = viewportHeight;
+      this.viewportOrientationMayChange = viewportOrientationMayChange;
+      return this;
     }
 
     /**
-     * Returns an instance with the provided {@link #maxVideoBitrate}.
+     * Builds a {@link Parameters} instance with the selected values.
      */
-    public Parameters withMaxVideoBitrate(int maxVideoBitrate) {
-      if (maxVideoBitrate == this.maxVideoBitrate) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
+    public Parameters build() {
+      return new Parameters(
+          preferredAudioLanguage,
+          preferredTextLanguage,
+          selectUndeterminedTextLanguage,
+          disabledTextTrackSelectionFlags,
+          forceLowestBitrate,
+          allowMixedMimeAdaptiveness,
+          allowNonSeamlessAdaptiveness,
+          maxVideoWidth,
+          maxVideoHeight,
+          maxVideoBitrate,
+          exceedVideoConstraintsIfNecessary,
+          exceedRendererCapabilitiesIfNecessary,
+          viewportWidth,
+          viewportHeight,
+          viewportOrientationMayChange);
     }
 
+  }
+
+  /**
+   * Constraint parameters for {@link DefaultTrackSelector}.
+   */
+  public static final class Parameters {
+
     /**
-     * Equivalent to {@code withMaxVideoSize(1279, 719)}.
+     * An instance with default values:
      *
-     * @return An instance with maximum standard definition as maximum video size.
+     * <ul>
+     *   <li>No preferred audio language.
+     *   <li>No preferred text language.
+     *   <li>Text tracks with undetermined language are not selected if no track with {@link
+     *       #preferredTextLanguage} is available.
+     *   <li>All selection flags are considered for text track selections.
+     *   <li>Lowest bitrate track selections are not forced.
+     *   <li>Adaptation between different mime types is not allowed.
+     *   <li>Non seamless adaptation is allowed.
+     *   <li>No max limit for video width/height.
+     *   <li>No max video bitrate.
+     *   <li>Video constraints are exceeded if no supported selection can be made otherwise.
+     *   <li>Renderer capabilities are exceeded if no supported selection can be made.
+     *   <li>No viewport constraints.
+     * </ul>
      */
-    public Parameters withMaxVideoSizeSd() {
-      return withMaxVideoSize(1279, 719);
-    }
+    public static final Parameters DEFAULT = new Parameters();
 
+    // Audio
     /**
-     * Equivalent to {@code withMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE)}.
-     *
-     * @return An instance without video size constraints.
+     * The preferred language for audio, as well as for forced text tracks, as an ISO 639-2/T tag.
+     * {@code null} selects the default track, or the first track if there's no default.
      */
-    public Parameters withoutVideoSizeConstraints() {
-      return withMaxVideoSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
-    }
+    public final String preferredAudioLanguage;
 
+    // Text
     /**
-     * Returns an instance with the provided {@link #exceedVideoConstraintsIfNecessary}.
+     * The preferred language for text tracks as an ISO 639-2/T tag. {@code null} selects the
+     * default track if there is one, or no track otherwise.
      */
-    public Parameters withExceedVideoConstraintsIfNecessary(
-        boolean exceedVideoConstraintsIfNecessary) {
-      if (exceedVideoConstraintsIfNecessary == this.exceedVideoConstraintsIfNecessary) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
-    }
-
+    public final String preferredTextLanguage;
     /**
-     * Returns an instance with the provided {@link #exceedRendererCapabilitiesIfNecessary}.
+     * Whether a text track with undetermined language should be selected if no track with
+     * {@link #preferredTextLanguage} is available, or if {@link #preferredTextLanguage} is unset.
      */
-    public Parameters withExceedRendererCapabilitiesIfNecessary(
-        boolean exceedRendererCapabilitiesIfNecessary) {
-      if (exceedRendererCapabilitiesIfNecessary == this.exceedRendererCapabilitiesIfNecessary) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
-    }
+    public final boolean selectUndeterminedTextLanguage;
+    /**
+     * Bitmask of selection flags that are disabled for text track selections. See {@link
+     * C.SelectionFlags}.
+     */
+    public final int disabledTextTrackSelectionFlags;
 
+    // Video
     /**
-     * Returns an instance with the provided {@link #viewportWidth}, {@link #viewportHeight} and
-     * {@link #viewportOrientationMayChange}.
+     * Maximum allowed video width.
      */
-    public Parameters withViewportSize(int viewportWidth, int viewportHeight,
-        boolean viewportOrientationMayChange) {
-      if (viewportWidth == this.viewportWidth && viewportHeight == this.viewportHeight
-          && viewportOrientationMayChange == this.viewportOrientationMayChange) {
-        return this;
-      }
-      return new Parameters(preferredAudioLanguage, preferredTextLanguage, forceLowestBitrate,
-          allowMixedMimeAdaptiveness, allowNonSeamlessAdaptiveness, maxVideoWidth, maxVideoHeight,
-          maxVideoBitrate, exceedVideoConstraintsIfNecessary, exceedRendererCapabilitiesIfNecessary,
-          viewportWidth, viewportHeight, viewportOrientationMayChange);
-    }
+    public final int maxVideoWidth;
+    /**
+     * Maximum allowed video height.
+     */
+    public final int maxVideoHeight;
+    /**
+     * Maximum video bitrate.
+     */
+    public final int maxVideoBitrate;
+    /**
+     * Whether to exceed video constraints when no selection can be made otherwise.
+     */
+    public final boolean exceedVideoConstraintsIfNecessary;
+    /**
+     * Viewport width in pixels. Constrains video tracks selections for adaptive playbacks so that
+     * only tracks suitable for the viewport are selected.
+     */
+    public final int viewportWidth;
+    /**
+     * Viewport height in pixels. Constrains video tracks selections for adaptive playbacks so that
+     * only tracks suitable for the viewport are selected.
+     */
+    public final int viewportHeight;
+    /**
+     * Whether the viewport orientation may change during playback. Constrains video tracks
+     * selections for adaptive playbacks so that only tracks suitable for the viewport are selected.
+     */
+    public final boolean viewportOrientationMayChange;
 
+    // General
     /**
-     * Returns an instance where the viewport size is obtained from the provided {@link Context}.
-     *
-     * @param context The context to obtain the viewport size from.
-     * @param viewportOrientationMayChange See {@link #viewportOrientationMayChange}.
-     * @return An instance where the viewport size is obtained from the provided {@link Context}.
+     * Whether to force selection of the single lowest bitrate audio and video tracks that comply
+     * with all other constraints.
+     */
+    public final boolean forceLowestBitrate;
+    /**
+     * Whether to allow adaptive selections containing mixed mime types.
+     */
+    public final boolean allowMixedMimeAdaptiveness;
+    /**
+     * Whether to allow adaptive selections where adaptation may not be completely seamless.
+     */
+    public final boolean allowNonSeamlessAdaptiveness;
+    /**
+     * Whether to exceed renderer capabilities when no selection can be made otherwise.
      */
-    public Parameters withViewportSizeFromContext(Context context,
+    public final boolean exceedRendererCapabilitiesIfNecessary;
+
+    private Parameters() {
+      this(
+          null,
+          null,
+          false,
+          0,
+          false,
+          false,
+          true,
+          Integer.MAX_VALUE,
+          Integer.MAX_VALUE,
+          Integer.MAX_VALUE,
+          true,
+          true,
+          Integer.MAX_VALUE,
+          Integer.MAX_VALUE,
+          true);
+    }
+
+    private Parameters(
+        String preferredAudioLanguage,
+        String preferredTextLanguage,
+        boolean selectUndeterminedTextLanguage,
+        int disabledTextTrackSelectionFlags,
+        boolean forceLowestBitrate,
+        boolean allowMixedMimeAdaptiveness,
+        boolean allowNonSeamlessAdaptiveness,
+        int maxVideoWidth,
+        int maxVideoHeight,
+        int maxVideoBitrate,
+        boolean exceedVideoConstraintsIfNecessary,
+        boolean exceedRendererCapabilitiesIfNecessary,
+        int viewportWidth,
+        int viewportHeight,
         boolean viewportOrientationMayChange) {
-      // Assume the viewport is fullscreen.
-      Point viewportSize = Util.getPhysicalDisplaySize(context);
-      return withViewportSize(viewportSize.x, viewportSize.y, viewportOrientationMayChange);
+      this.preferredAudioLanguage = Util.normalizeLanguageCode(preferredAudioLanguage);
+      this.preferredTextLanguage = Util.normalizeLanguageCode(preferredTextLanguage);
+      this.selectUndeterminedTextLanguage = selectUndeterminedTextLanguage;
+      this.disabledTextTrackSelectionFlags = disabledTextTrackSelectionFlags;
+      this.forceLowestBitrate = forceLowestBitrate;
+      this.allowMixedMimeAdaptiveness = allowMixedMimeAdaptiveness;
+      this.allowNonSeamlessAdaptiveness = allowNonSeamlessAdaptiveness;
+      this.maxVideoWidth = maxVideoWidth;
+      this.maxVideoHeight = maxVideoHeight;
+      this.maxVideoBitrate = maxVideoBitrate;
+      this.exceedVideoConstraintsIfNecessary = exceedVideoConstraintsIfNecessary;
+      this.exceedRendererCapabilitiesIfNecessary = exceedRendererCapabilitiesIfNecessary;
+      this.viewportWidth = viewportWidth;
+      this.viewportHeight = viewportHeight;
+      this.viewportOrientationMayChange = viewportOrientationMayChange;
     }
 
     /**
-     * Equivalent to {@code withViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true)}.
-     *
-     * @return An instance without viewport size constraints.
+     * Creates a new {@link ParametersBuilder}, copying the initial values from this instance.
      */
-    public Parameters withoutViewportSizeConstraints() {
-      return withViewportSize(Integer.MAX_VALUE, Integer.MAX_VALUE, true);
+    public ParametersBuilder buildUpon() {
+      return new ParametersBuilder(this);
     }
 
     @Override
@@ -388,14 +491,18 @@ public boolean equals(Object obj) {
         return false;
       }
       Parameters other = (Parameters) obj;
-      return forceLowestBitrate == other.forceLowestBitrate
+      return selectUndeterminedTextLanguage == other.selectUndeterminedTextLanguage
+          && disabledTextTrackSelectionFlags == other.disabledTextTrackSelectionFlags
+          && forceLowestBitrate == other.forceLowestBitrate
           && allowMixedMimeAdaptiveness == other.allowMixedMimeAdaptiveness
           && allowNonSeamlessAdaptiveness == other.allowNonSeamlessAdaptiveness
-          && maxVideoWidth == other.maxVideoWidth && maxVideoHeight == other.maxVideoHeight
+          && maxVideoWidth == other.maxVideoWidth
+          && maxVideoHeight == other.maxVideoHeight
           && exceedVideoConstraintsIfNecessary == other.exceedVideoConstraintsIfNecessary
           && exceedRendererCapabilitiesIfNecessary == other.exceedRendererCapabilitiesIfNecessary
           && viewportOrientationMayChange == other.viewportOrientationMayChange
-          && viewportWidth == other.viewportWidth && viewportHeight == other.viewportHeight
+          && viewportWidth == other.viewportWidth
+          && viewportHeight == other.viewportHeight
           && maxVideoBitrate == other.maxVideoBitrate
           && TextUtils.equals(preferredAudioLanguage, other.preferredAudioLanguage)
           && TextUtils.equals(preferredTextLanguage, other.preferredTextLanguage);
@@ -403,19 +510,21 @@ public boolean equals(Object obj) {
 
     @Override
     public int hashCode() {
-      int result = preferredAudioLanguage.hashCode();
-      result = 31 * result + preferredTextLanguage.hashCode();
+      int result = selectUndeterminedTextLanguage ? 1 : 0;
+      result = 31 * result + disabledTextTrackSelectionFlags;
       result = 31 * result + (forceLowestBitrate ? 1 : 0);
       result = 31 * result + (allowMixedMimeAdaptiveness ? 1 : 0);
       result = 31 * result + (allowNonSeamlessAdaptiveness ? 1 : 0);
       result = 31 * result + maxVideoWidth;
       result = 31 * result + maxVideoHeight;
-      result = 31 * result + maxVideoBitrate;
       result = 31 * result + (exceedVideoConstraintsIfNecessary ? 1 : 0);
       result = 31 * result + (exceedRendererCapabilitiesIfNecessary ? 1 : 0);
       result = 31 * result + (viewportOrientationMayChange ? 1 : 0);
       result = 31 * result + viewportWidth;
       result = 31 * result + viewportHeight;
+      result = 31 * result + maxVideoBitrate;
+      result = 31 * result + preferredAudioLanguage.hashCode();
+      result = 31 * result + preferredTextLanguage.hashCode();
       return result;
     }
 
@@ -459,7 +568,7 @@ public DefaultTrackSelector(BandwidthMeter bandwidthMeter) {
    */
   public DefaultTrackSelector(TrackSelection.Factory adaptiveTrackSelectionFactory) {
     this.adaptiveTrackSelectionFactory = adaptiveTrackSelectionFactory;
-    paramsReference = new AtomicReference<>(new Parameters());
+    paramsReference = new AtomicReference<>(Parameters.DEFAULT);
   }
 
   /**
@@ -849,7 +958,7 @@ private static boolean isSupportedAdaptiveAudioTrack(Format format, int formatSu
     return isSupported(formatSupport, false) && format.channelCount == configuration.channelCount
         && format.sampleRate == configuration.sampleRate
         && (configuration.mimeType == null
-            || TextUtils.equals(configuration.mimeType, format.sampleMimeType));
+        || TextUtils.equals(configuration.mimeType, format.sampleMimeType));
   }
 
   // Text track selection implementation.
@@ -877,20 +986,25 @@ protected TrackSelection selectTextTrack(TrackGroupArray groups, int[][] formatS
         if (isSupported(trackFormatSupport[trackIndex],
             params.exceedRendererCapabilitiesIfNecessary)) {
           Format format = trackGroup.getFormat(trackIndex);
-          boolean isDefault = (format.selectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
-          boolean isForced = (format.selectionFlags & C.SELECTION_FLAG_FORCED) != 0;
+          int maskedSelectionFlags =
+              format.selectionFlags & ~params.disabledTextTrackSelectionFlags;
+          boolean isDefault = (maskedSelectionFlags & C.SELECTION_FLAG_DEFAULT) != 0;
+          boolean isForced = (maskedSelectionFlags & C.SELECTION_FLAG_FORCED) != 0;
           int trackScore;
-          if (formatHasLanguage(format, params.preferredTextLanguage)) {
+          boolean preferredLanguageFound = formatHasLanguage(format, params.preferredTextLanguage);
+          if (preferredLanguageFound
+              || (params.selectUndeterminedTextLanguage && formatHasNoLanguage(format))) {
             if (isDefault) {
-              trackScore = 6;
+              trackScore = 8;
             } else if (!isForced) {
               // Prefer non-forced to forced if a preferred text language has been specified. Where
               // both are provided the non-forced track will usually contain the forced subtitles as
               // a subset.
-              trackScore = 5;
+              trackScore = 6;
             } else {
               trackScore = 4;
             }
+            trackScore += preferredLanguageFound ? 1 : 0;
           } else if (isDefault) {
             trackScore = 3;
           } else if (isForced) {
@@ -980,6 +1094,16 @@ protected static boolean isSupported(int formatSupport, boolean allowExceedsCapa
         && maskedSupport == RendererCapabilities.FORMAT_EXCEEDS_CAPABILITIES);
   }
 
+  /**
+   * Returns whether a {@link Format} does not define a language.
+   *
+   * @param format The {@link Format}.
+   * @return Whether the {@link Format} does not define a language.
+   */
+  protected static boolean formatHasNoLanguage(Format format) {
+    return TextUtils.isEmpty(format.language) || formatHasLanguage(format, C.LANGUAGE_UNDETERMINED);
+  }
+
   /**
    * Returns whether a {@link Format} specifies a particular language, or {@code false} if
    * {@code language} is null.
@@ -1093,11 +1217,11 @@ public AudioTrackScore(Format format, Parameters parameters, int formatSupport)
      * Compares the score of the current track format with another {@link AudioTrackScore}.
      *
      * @param other The other score to compare to.
-     * @return A positive integer if this score is better than the other. Zero if they are
-     *     equal. A negative integer if this score is worse than the other.
+     * @return A positive integer if this score is better than the other. Zero if they are equal. A
+     *     negative integer if this score is worse than the other.
      */
     @Override
-    public int compareTo(AudioTrackScore other) {
+    public int compareTo(@NonNull AudioTrackScore other) {
       if (this.withinRendererCapabilitiesScore != other.withinRendererCapabilitiesScore) {
         return compareInts(this.withinRendererCapabilitiesScore,
             other.withinRendererCapabilitiesScore);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
index ad02b6c775..55e6050622 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelection.java
@@ -47,6 +47,20 @@
 
   }
 
+  /**
+   * Enables the track selection.
+   * <p>
+   * This method may not be called when the track selection is already enabled.
+   */
+  void enable();
+
+  /**
+   * Disables this track selection.
+   * <p>
+   * This method may only be called when the track selection is already enabled.
+   */
+  void disable();
+
   /**
    * Returns the {@link TrackGroup} to which the selected tracks belong.
    */
@@ -122,8 +136,18 @@
 
   // Adaptation.
 
+  /**
+   * Called to notify the selection of the current playback speed. The playback speed may affect
+   * adaptive track selection.
+   *
+   * @param speed The playback speed.
+   */
+  void onPlaybackSpeed(float speed);
+
   /**
    * Updates the selected track.
+   * <p>
+   * This method may only be called when the selection is enabled.
    *
    * @param playbackPositionUs The current playback position in microseconds. If playback of the
    *     period to which this track selection belongs has not yet started, the value will be the
@@ -150,7 +174,7 @@ void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
    * An example of a case where a smaller value may be returned is if network conditions have
    * improved dramatically, allowing chunks to be discarded and re-buffered in a track of
    * significantly higher quality. Discarding chunks may allow faster switching to a higher quality
-   * track in this case.
+   * track in this case. This method may only be called when the selection is enabled.
    *
    * @param playbackPositionUs The current playback position in microseconds. If playback of the
    *     period to which this track selection belongs has not yet started, the value will be the
@@ -167,6 +191,8 @@ void updateSelectedTrack(long playbackPositionUs, long bufferedDurationUs,
    * period of time. Blacklisting will fail if all other tracks are currently blacklisted. If
    * blacklisting the currently selected track, note that it will remain selected until the next
    * call to {@link #updateSelectedTrack(long, long, long)}.
+   * <p>
+   * This method may only be called when the selection is enabled.
    *
    * @param index The index of the track in the selection.
    * @param blacklistDurationMs The duration of time for which the track should be blacklisted, in
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
index 801f5b9584..68adc32395 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/trackselection/TrackSelectorResult.java
@@ -74,7 +74,7 @@ public TrackSelectorResult(TrackGroupArray groups, boolean[] renderersEnabled,
    * @return Whether this result is equivalent to {@code other} for all renderers.
    */
   public boolean isEquivalent(TrackSelectorResult other) {
-    if (other == null) {
+    if (other == null || other.selections.length != selections.length) {
       return false;
     }
     for (int i = 0; i < selections.length; i++) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
index ab1542c7a6..a6b89a334d 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DataSpec.java
@@ -17,6 +17,7 @@
 
 import android.net.Uri;
 import android.support.annotation.IntDef;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import java.lang.annotation.Retention;
@@ -48,7 +49,8 @@
   public static final int FLAG_ALLOW_GZIP = 1 << 0;
 
   /**
-   * Permits content to be cached even if its length can not be resolved.
+   * Permits content to be cached even if its length can not be resolved. Typically this's the case
+   * for progressive live streams and when {@link #FLAG_ALLOW_GZIP} is used.
    */
   public static final int FLAG_ALLOW_CACHING_UNKNOWN_LENGTH = 1 << 1;
 
@@ -79,7 +81,7 @@
    * A key that uniquely identifies the original stream. Used for cache indexing. May be null if the
    * {@link DataSpec} is not intended to be used in conjunction with a cache.
    */
-  public final String key;
+  @Nullable public final String key;
   /**
    * Request flags. Currently {@link #FLAG_ALLOW_GZIP} and
    * {@link #FLAG_ALLOW_CACHING_UNKNOWN_LENGTH} are the only supported flags.
@@ -113,7 +115,7 @@ public DataSpec(Uri uri, @Flags int flags) {
    * @param length {@link #length}.
    * @param key {@link #key}.
    */
-  public DataSpec(Uri uri, long absoluteStreamPosition, long length, String key) {
+  public DataSpec(Uri uri, long absoluteStreamPosition, long length, @Nullable String key) {
     this(uri, absoluteStreamPosition, absoluteStreamPosition, length, key, 0);
   }
 
@@ -147,8 +149,8 @@ public DataSpec(Uri uri, long absoluteStreamPosition, long position, long length
   }
 
   /**
-   * Construct a {@link DataSpec} where {@link #position} may differ from
-   * {@link #absoluteStreamPosition}.
+   * Construct a {@link DataSpec} where {@link #position} may differ from {@link
+   * #absoluteStreamPosition}.
    *
    * @param uri {@link #uri}.
    * @param postBody {@link #postBody}.
@@ -158,8 +160,14 @@ public DataSpec(Uri uri, long absoluteStreamPosition, long position, long length
    * @param key {@link #key}.
    * @param flags {@link #flags}.
    */
-  public DataSpec(Uri uri, byte[] postBody, long absoluteStreamPosition, long position, long length,
-      String key, @Flags int flags) {
+  public DataSpec(
+      Uri uri,
+      byte[] postBody,
+      long absoluteStreamPosition,
+      long position,
+      long length,
+      @Nullable String key,
+      @Flags int flags) {
     Assertions.checkArgument(absoluteStreamPosition >= 0);
     Assertions.checkArgument(position >= 0);
     Assertions.checkArgument(length > 0 || length == C.LENGTH_UNSET);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
index 853b40f73f..b5469db72e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DefaultDataSource.java
@@ -21,24 +21,26 @@
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
 
 /**
  * A {@link DataSource} that supports multiple URI schemes. The supported schemes are:
  *
  * <ul>
- * <li>file: For fetching data from a local file (e.g. file:///path/to/media/media.mp4, or just
- *     /path/to/media/media.mp4 because the implementation assumes that a URI without a scheme is a
- *     local file URI).
- * <li>asset: For fetching data from an asset in the application's apk (e.g. asset:///media.mp4).
- * <li>content: For fetching data from a content URI (e.g. content://authority/path/123).
- * <li>rtmp: For fetching data over RTMP. Only supported if the project using ExoPlayer has an
- *     explicit dependency on ExoPlayer's RTMP extension.</li>
- * <li>data: For parsing data inlined in the URI as defined in RFC 2397.</li>
- * <li>http(s): For fetching data over HTTP and HTTPS (e.g. https://www.something.com/media.mp4), if
- *     constructed using {@link #DefaultDataSource(Context, TransferListener, String, boolean)}, or
- *     any other schemes supported by a base data source if constructed using
- *     {@link #DefaultDataSource(Context, TransferListener, DataSource)}.</li>
+ *   <li>file: For fetching data from a local file (e.g. file:///path/to/media/media.mp4, or just
+ *       /path/to/media/media.mp4 because the implementation assumes that a URI without a scheme is
+ *       a local file URI).
+ *   <li>asset: For fetching data from an asset in the application's apk (e.g. asset:///media.mp4).
+ *   <li>rawresource: For fetching data from a raw resource in the application's apk (e.g.
+ *       rawresource:///resourceId, where rawResourceId is the integer identifier of the raw
+ *       resource).
+ *   <li>content: For fetching data from a content URI (e.g. content://authority/path/123).
+ *   <li>rtmp: For fetching data over RTMP. Only supported if the project using ExoPlayer has an
+ *       explicit dependency on ExoPlayer's RTMP extension.
+ *   <li>data: For parsing data inlined in the URI as defined in RFC 2397.
+ *   <li>http(s): For fetching data over HTTP and HTTPS (e.g. https://www.something.com/media.mp4),
+ *       if constructed using {@link #DefaultDataSource(Context, TransferListener, String,
+ *       boolean)}, or any other schemes supported by a base data source if constructed using {@link
+ *       #DefaultDataSource(Context, TransferListener, DataSource)}.
  * </ul>
  */
 public final class DefaultDataSource implements DataSource {
@@ -48,6 +50,7 @@
   private static final String SCHEME_ASSET = "asset";
   private static final String SCHEME_CONTENT = "content";
   private static final String SCHEME_RTMP = "rtmp";
+  private static final String SCHEME_RAW = RawResourceDataSource.RAW_RESOURCE_SCHEME;
 
   private final Context context;
   private final TransferListener<? super DataSource> listener;
@@ -60,6 +63,7 @@
   private DataSource contentDataSource;
   private DataSource rtmpDataSource;
   private DataSource dataSchemeDataSource;
+  private DataSource rawResourceDataSource;
 
   private DataSource dataSource;
 
@@ -134,6 +138,8 @@ public long open(DataSpec dataSpec) throws IOException {
       dataSource = getRtmpDataSource();
     } else if (DataSchemeDataSource.SCHEME_DATA.equals(scheme)) {
       dataSource = getDataSchemeDataSource();
+    } else if (SCHEME_RAW.equals(scheme)) {
+      dataSource = getRawResourceDataSource();
     } else {
       dataSource = baseDataSource;
     }
@@ -186,18 +192,16 @@ private DataSource getContentDataSource() {
   private DataSource getRtmpDataSource() {
     if (rtmpDataSource == null) {
       try {
+        // LINT.IfChange
         Class<?> clazz = Class.forName("com.google.android.exoplayer2.ext.rtmp.RtmpDataSource");
-        rtmpDataSource = (DataSource) clazz.getDeclaredConstructor().newInstance();
+        rtmpDataSource = (DataSource) clazz.getConstructor().newInstance();
+        // LINT.ThenChange(../../../../../../../../proguard-rules.txt)
       } catch (ClassNotFoundException e) {
+        // Expected if the app was built without the RTMP extension.
         Log.w(TAG, "Attempting to play RTMP stream without depending on the RTMP extension");
-      } catch (InstantiationException e) {
-        Log.e(TAG, "Error instantiating RtmpDataSource", e);
-      } catch (IllegalAccessException e) {
-        Log.e(TAG, "Error instantiating RtmpDataSource", e);
-      } catch (NoSuchMethodException e) {
-        Log.e(TAG, "Error instantiating RtmpDataSource", e);
-      } catch (InvocationTargetException e) {
-        Log.e(TAG, "Error instantiating RtmpDataSource", e);
+      } catch (Exception e) {
+        // The RTMP extension is present, but instantiation failed.
+        throw new RuntimeException("Error instantiating RTMP extension", e);
       }
       if (rtmpDataSource == null) {
         rtmpDataSource = baseDataSource;
@@ -213,4 +217,10 @@ private DataSource getDataSchemeDataSource() {
     return dataSchemeDataSource;
   }
 
+  private DataSource getRawResourceDataSource() {
+    if (rawResourceDataSource == null) {
+      rawResourceDataSource = new RawResourceDataSource(context, listener);
+    }
+    return rawResourceDataSource;
+  }
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
index c20868ef00..fa3e14f1c9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/DummyDataSource.java
@@ -25,7 +25,7 @@
 
   public static final DummyDataSource INSTANCE = new DummyDataSource();
 
-  /** A factory that that produces {@link DummyDataSource}. */
+  /** A factory that produces {@link DummyDataSource}. */
   public static final Factory FACTORY = new Factory() {
     @Override
     public DataSource createDataSource() {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
index 9e495f42bf..a118f10784 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/Loader.java
@@ -20,6 +20,7 @@
 import android.os.Looper;
 import android.os.Message;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.TraceUtil;
@@ -197,25 +198,17 @@ public void release() {
    * Releases the {@link Loader}. This method should be called when the {@link Loader} is no longer
    * required.
    *
-   * @param callback A callback to be called when the release ends. Will be called synchronously
-   *     from this method if no load is in progress, or asynchronously once the load has been
-   *     canceled otherwise. May be null.
-   * @return True if {@code callback} was called synchronously. False if it will be called
-   *     asynchronously or if {@code callback} is null.
+   * @param callback An optional callback to be called on the loading thread once the loader has
+   *     been released.
    */
-  public boolean release(ReleaseCallback callback) {
-    boolean callbackInvoked = false;
+  public void release(@Nullable ReleaseCallback callback) {
     if (currentTask != null) {
       currentTask.cancel(true);
-      if (callback != null) {
-        downloadExecutorService.execute(new ReleaseTask(callback));
-      }
-    } else if (callback != null) {
-      callback.onLoaderReleased();
-      callbackInvoked = true;
+    }
+    if (callback != null) {
+      downloadExecutorService.execute(new ReleaseTask(callback));
     }
     downloadExecutorService.shutdown();
-    return callbackInvoked;
   }
 
   // LoaderErrorThrower implementation.
@@ -419,7 +412,7 @@ private long getRetryDelayMillis() {
 
   }
 
-  private static final class ReleaseTask extends Handler implements Runnable {
+  private static final class ReleaseTask implements Runnable {
 
     private final ReleaseCallback callback;
 
@@ -429,13 +422,6 @@ public ReleaseTask(ReleaseCallback callback) {
 
     @Override
     public void run() {
-      if (getLooper().getThread().isAlive()) {
-        sendEmptyMessage(0);
-      }
-    }
-
-    @Override
-    public void handleMessage(Message msg) {
       callback.onLoaderReleased();
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
index 308340b8b2..a9927f6e86 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/ParsingLoadable.java
@@ -72,7 +72,11 @@
    * @param parser Parses the object from the response.
    */
   public ParsingLoadable(DataSource dataSource, Uri uri, int type, Parser<? extends T> parser) {
-    this(dataSource, new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP), type, parser);
+    this(
+        dataSource,
+        new DataSpec(uri, DataSpec.FLAG_ALLOW_GZIP | DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH),
+        type,
+        parser);
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
index 0b7b85b8c3..1b58c7e095 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/RawResourceDataSource.java
@@ -58,7 +58,8 @@ public static Uri buildRawResourceUri(int rawResourceId) {
     return Uri.parse(RAW_RESOURCE_SCHEME + ":///" + rawResourceId);
   }
 
-  private static final String RAW_RESOURCE_SCHEME = "rawresource";
+  /** The scheme part of a raw resource URI. */
+  public static final String RAW_RESOURCE_SCHEME = "rawresource";
 
   private final Resources resources;
   private final TransferListener<? super RawResourceDataSource> listener;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
index 80ad698fa4..171aa0878a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/Cache.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import java.io.File;
 import java.io.IOException;
@@ -80,15 +81,16 @@ public CacheException(Throwable cause) {
 
   /**
    * Registers a listener to listen for changes to a given key.
-   * <p>
-   * No guarantees are made about the thread or threads on which the listener is called, but it is
-   * guaranteed that listener methods will be called in a serial fashion (i.e. one at a time) and in
-   * the same order as events occurred.
+   *
+   * <p>No guarantees are made about the thread or threads on which the listener is called, but it
+   * is guaranteed that listener methods will be called in a serial fashion (i.e. one at a time) and
+   * in the same order as events occurred.
    *
    * @param key The key to listen to.
    * @param listener The listener to add.
    * @return The current spans for the key.
    */
+  @NonNull
   NavigableSet<CacheSpan> addListener(String key, Listener listener);
 
   /**
@@ -103,9 +105,10 @@ public CacheException(Throwable cause) {
    * Returns the cached spans for a given cache key.
    *
    * @param key The key for which spans should be returned.
-   * @return The spans for the key. May be null if there are no such spans.
+   * @return The spans for the key.
    */
-  @Nullable NavigableSet<CacheSpan> getCachedSpans(String key);
+  @NonNull
+  NavigableSet<CacheSpan> getCachedSpans(String key);
 
   /**
    * Returns all keys in the cache.
@@ -124,23 +127,24 @@ public CacheException(Throwable cause) {
   /**
    * A caller should invoke this method when they require data from a given position for a given
    * key.
-   * <p>
-   * If there is a cache entry that overlaps the position, then the returned {@link CacheSpan}
+   *
+   * <p>If there is a cache entry that overlaps the position, then the returned {@link CacheSpan}
    * defines the file in which the data is stored. {@link CacheSpan#isCached} is true. The caller
    * may read from the cache file, but does not acquire any locks.
-   * <p>
-   * If there is no cache entry overlapping {@code offset}, then the returned {@link CacheSpan}
+   *
+   * <p>If there is no cache entry overlapping {@code offset}, then the returned {@link CacheSpan}
    * defines a hole in the cache starting at {@code position} into which the caller may write as it
    * obtains the data from some other source. The returned {@link CacheSpan} serves as a lock.
    * Whilst the caller holds the lock it may write data into the hole. It may split data into
-   * multiple files. When the caller has finished writing a file it should commit it to the cache
-   * by calling {@link #commitFile(File)}. When the caller has finished writing, it must release
-   * the lock by calling {@link #releaseHoleSpan}.
+   * multiple files. When the caller has finished writing a file it should commit it to the cache by
+   * calling {@link #commitFile(File)}. When the caller has finished writing, it must release the
+   * lock by calling {@link #releaseHoleSpan}.
    *
    * @param key The key of the data being requested.
    * @param position The position of the data being requested.
    * @return The {@link CacheSpan}.
    * @throws InterruptedException If the thread was interrupted.
+   * @throws CacheException If an error is encountered.
    */
   CacheSpan startReadWrite(String key, long position) throws InterruptedException, CacheException;
 
@@ -151,8 +155,10 @@ public CacheException(Throwable cause) {
    * @param key The key of the data being requested.
    * @param position The position of the data being requested.
    * @return The {@link CacheSpan}. Or null if the cache entry is locked.
+   * @throws CacheException If an error is encountered.
    */
-  @Nullable CacheSpan startReadWriteNonBlocking(String key, long position) throws CacheException;
+  @Nullable
+  CacheSpan startReadWriteNonBlocking(String key, long position) throws CacheException;
 
   /**
    * Obtains a cache file into which data can be written. Must only be called when holding a
@@ -163,14 +169,16 @@ public CacheException(Throwable cause) {
    * @param maxLength The maximum length of the data to be written. Used only to ensure that there
    *     is enough space in the cache.
    * @return The file into which data should be written.
+   * @throws CacheException If an error is encountered.
    */
   File startFile(String key, long position, long maxLength) throws CacheException;
 
   /**
-   * Commits a file into the cache. Must only be called when holding a corresponding hole
-   * {@link CacheSpan} obtained from {@link #startReadWrite(String, long)}
+   * Commits a file into the cache. Must only be called when holding a corresponding hole {@link
+   * CacheSpan} obtained from {@link #startReadWrite(String, long)}
    *
    * @param file A newly written cache file.
+   * @throws CacheException If an error is encountered.
    */
   void commitFile(File file) throws CacheException;
 
@@ -186,6 +194,7 @@ public CacheException(Throwable cause) {
    * Removes a cached {@link CacheSpan} from the cache, deleting the underlying file.
    *
    * @param span The {@link CacheSpan} to remove.
+   * @throws CacheException If an error is encountered.
    */
   void removeSpan(CacheSpan span) throws CacheException;
 
@@ -207,15 +216,16 @@ public CacheException(Throwable cause) {
    * @param key The cache key for the data.
    * @param position The starting position of the data.
    * @param length The maximum length of the data to be returned.
-   * @return the length of the cached or not cached data block length.
+   * @return The length of the cached or not cached data block length.
    */
-  long getCachedBytes(String key, long position, long length);
+  long getCachedLength(String key, long position, long length);
 
   /**
    * Sets the content length for the given key.
    *
    * @param key The cache key for the data.
    * @param length The length of the data.
+   * @throws CacheException If an error is encountered.
    */
   void setContentLength(String key, long length) throws CacheException;
 
@@ -224,7 +234,8 @@ public CacheException(Throwable cause) {
    * com.google.android.exoplayer2.C#LENGTH_UNSET} otherwise.
    *
    * @param key The cache key for the data.
+   * @return The content length for the given key if one set, or {@link
+   *     com.google.android.exoplayer2.C#LENGTH_UNSET} otherwise.
    */
   long getContentLength(String key);
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
index 33b1ca58b0..57f5a6ad93 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSink.java
@@ -29,10 +29,15 @@
 
 /**
  * Writes data into a cache.
+ *
+ * <p>If the {@link DataSpec} object used with {@link #open(DataSpec)} method call has the {@code
+ * length} field set to {@link C#LENGTH_UNSET} but {@link
+ * DataSpec#FLAG_ALLOW_CACHING_UNKNOWN_LENGTH} isn't set then {@link #write(byte[], int, int)} calls
+ * are ignored.
  */
 public final class CacheDataSink implements DataSink {
 
-  /** Default buffer size. */
+  /** Default buffer size in bytes. */
   public static final int DEFAULT_BUFFER_SIZE = 20480;
 
   private final Cache cache;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
index bb2a952b11..c0927eb7db 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSource.java
@@ -26,6 +26,7 @@
 import com.google.android.exoplayer2.upstream.FileDataSource;
 import com.google.android.exoplayer2.upstream.TeeDataSource;
 import com.google.android.exoplayer2.upstream.cache.Cache.CacheException;
+import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.lang.annotation.Retention;
@@ -35,6 +36,10 @@
  * A {@link DataSource} that reads and writes a {@link Cache}. Requests are fulfilled from the cache
  * when possible. When data is not cached it is requested from an upstream {@link DataSource} and
  * written into the cache.
+ *
+ * <p>By default requests whose length can not be resolved are not cached. This is to prevent
+ * caching of progressive live streams, which should usually not be cached. Caching of this kind of
+ * requests can be enabled per request with {@link DataSpec#FLAG_ALLOW_CACHING_UNKNOWN_LENGTH}.
  */
 public final class CacheDataSource implements DataSource {
 
@@ -67,7 +72,8 @@
   public static final int FLAG_IGNORE_CACHE_ON_ERROR = 1 << 1;
 
   /**
-   * A flag indicating that the cache should be bypassed for requests whose lengths are unset.
+   * A flag indicating that the cache should be bypassed for requests whose lengths are unset. This
+   * flag is provided for legacy reasons only.
    */
   public static final int FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS = 1 << 2;
 
@@ -86,6 +92,9 @@
 
   }
 
+  /** Minimum number of bytes to read before checking cache for availability. */
+  private static final long MIN_READ_BEFORE_CHECKING_CACHE = 100 * 1024;
+
   private final Cache cache;
   private final DataSource cacheReadDataSource;
   private final DataSource cacheWriteDataSource;
@@ -97,16 +106,17 @@
   private final boolean ignoreCacheForUnsetLengthRequests;
 
   private DataSource currentDataSource;
-  private boolean currentRequestUnbounded;
+  private boolean currentDataSpecLengthUnset;
   private Uri uri;
   private int flags;
   private String key;
   private long readPosition;
   private long bytesRemaining;
-  private CacheSpan lockedSpan;
+  private CacheSpan currentHoleSpan;
   private boolean seenCacheError;
   private boolean currentRequestIgnoresCache;
   private long totalCachedBytesRead;
+  private long checkCachePosition;
 
   /**
    * Constructs an instance with default {@link DataSource} and {@link DataSink} instances for
@@ -202,7 +212,7 @@ public long open(DataSpec dataSpec) throws IOException {
           }
         }
       }
-      openNextSource(true);
+      openNextSource(false);
       return bytesRemaining;
     } catch (IOException e) {
       handleBeforeThrow(e);
@@ -219,8 +229,11 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
       return C.RESULT_END_OF_INPUT;
     }
     try {
+      if (readPosition >= checkCachePosition) {
+        openNextSource(true);
+      }
       int bytesRead = currentDataSource.read(buffer, offset, readLength);
-      if (bytesRead >= 0) {
+      if (bytesRead != C.RESULT_END_OF_INPUT) {
         if (currentDataSource == cacheReadDataSource) {
           totalCachedBytesRead += bytesRead;
         }
@@ -228,22 +241,19 @@ public int read(byte[] buffer, int offset, int readLength) throws IOException {
         if (bytesRemaining != C.LENGTH_UNSET) {
           bytesRemaining -= bytesRead;
         }
-      } else {
-        if (currentRequestUnbounded) {
-          // We only do unbounded requests to upstream and only when we don't know the actual stream
-          // length. So we reached the end of stream.
-          setContentLength(readPosition);
-          bytesRemaining = 0;
-        }
+      } else if (currentDataSpecLengthUnset) {
+        setBytesRemaining(0);
+      } else if (bytesRemaining > 0 || bytesRemaining == C.LENGTH_UNSET) {
         closeCurrentSource();
-        if (bytesRemaining > 0 || bytesRemaining == C.LENGTH_UNSET) {
-          if (openNextSource(false)) {
-            return read(buffer, offset, readLength);
-          }
-        }
+        openNextSource(false);
+        return read(buffer, offset, readLength);
       }
       return bytesRead;
     } catch (IOException e) {
+      if (currentDataSpecLengthUnset && isCausedByPositionOutOfRange(e)) {
+        setBytesRemaining(0);
+        return C.RESULT_END_OF_INPUT;
+      }
       handleBeforeThrow(e);
       throw e;
     }
@@ -270,101 +280,124 @@ public void close() throws IOException {
    * Opens the next source. If the cache contains data spanning the current read position then
    * {@link #cacheReadDataSource} is opened to read from it. Else {@link #upstreamDataSource} is
    * opened to read from the upstream source and write into the cache.
-   * @param initial Whether it is the initial open call.
+   *
+   * <p>There must not be a currently open source when this method is called, except in the case
+   * that {@code checkCache} is true. If {@code checkCache} is true then there must be a currently
+   * open source, and it must be {@link #upstreamDataSource}. It will be closed and a new source
+   * opened if it's possible to switch to reading from or writing to the cache. If a switch isn't
+   * possible then the current source is left unchanged.
+   *
+   * @param checkCache If true tries to switch to reading from or writing to cache instead of
+   *     reading from {@link #upstreamDataSource}, which is the currently open source.
    */
-  private boolean openNextSource(boolean initial) throws IOException {
-    DataSpec dataSpec;
-    CacheSpan span;
+  private void openNextSource(boolean checkCache) throws IOException {
+    CacheSpan nextSpan;
     if (currentRequestIgnoresCache) {
-      span = null;
+      nextSpan = null;
     } else if (blockOnCache) {
       try {
-        span = cache.startReadWrite(key, readPosition);
+        nextSpan = cache.startReadWrite(key, readPosition);
       } catch (InterruptedException e) {
         throw new InterruptedIOException();
       }
     } else {
-      span = cache.startReadWriteNonBlocking(key, readPosition);
+      nextSpan = cache.startReadWriteNonBlocking(key, readPosition);
     }
 
-    if (span == null) {
+    DataSpec nextDataSpec;
+    DataSource nextDataSource;
+    if (nextSpan == null) {
       // The data is locked in the cache, or we're ignoring the cache. Bypass the cache and read
       // from upstream.
-      currentDataSource = upstreamDataSource;
-      dataSpec = new DataSpec(uri, readPosition, bytesRemaining, key, flags);
-    } else if (span.isCached) {
+      nextDataSource = upstreamDataSource;
+      nextDataSpec = new DataSpec(uri, readPosition, bytesRemaining, key, flags);
+    } else if (nextSpan.isCached) {
       // Data is cached, read from cache.
-      Uri fileUri = Uri.fromFile(span.file);
-      long filePosition = readPosition - span.position;
-      long length = span.length - filePosition;
+      Uri fileUri = Uri.fromFile(nextSpan.file);
+      long filePosition = readPosition - nextSpan.position;
+      long length = nextSpan.length - filePosition;
       if (bytesRemaining != C.LENGTH_UNSET) {
         length = Math.min(length, bytesRemaining);
       }
-      dataSpec = new DataSpec(fileUri, readPosition, filePosition, length, key, flags);
-      currentDataSource = cacheReadDataSource;
+      nextDataSpec = new DataSpec(fileUri, readPosition, filePosition, length, key, flags);
+      nextDataSource = cacheReadDataSource;
     } else {
       // Data is not cached, and data is not locked, read from upstream with cache backing.
       long length;
-      if (span.isOpenEnded()) {
+      if (nextSpan.isOpenEnded()) {
         length = bytesRemaining;
       } else {
-        length = span.length;
+        length = nextSpan.length;
         if (bytesRemaining != C.LENGTH_UNSET) {
           length = Math.min(length, bytesRemaining);
         }
       }
-      dataSpec = new DataSpec(uri, readPosition, length, key, flags);
+      nextDataSpec = new DataSpec(uri, readPosition, length, key, flags);
       if (cacheWriteDataSource != null) {
-        currentDataSource = cacheWriteDataSource;
-        lockedSpan = span;
+        nextDataSource = cacheWriteDataSource;
       } else {
-        currentDataSource = upstreamDataSource;
-        cache.releaseHoleSpan(span);
+        nextDataSource = upstreamDataSource;
+        cache.releaseHoleSpan(nextSpan);
+        nextSpan = null;
       }
     }
 
-    currentRequestUnbounded = dataSpec.length == C.LENGTH_UNSET;
-    boolean successful = false;
-    long currentBytesRemaining = 0;
-    try {
-      currentBytesRemaining = currentDataSource.open(dataSpec);
-      successful = true;
-    } catch (IOException e) {
-      // if this isn't the initial open call (we had read some bytes) and an unbounded range request
-      // failed because of POSITION_OUT_OF_RANGE then mute the exception. We are trying to find the
-      // end of the stream.
-      if (!initial && currentRequestUnbounded) {
-        Throwable cause = e;
-        while (cause != null) {
-          if (cause instanceof DataSourceException) {
-            int reason = ((DataSourceException) cause).reason;
-            if (reason == DataSourceException.POSITION_OUT_OF_RANGE) {
-              e = null;
-              break;
-            }
-          }
-          cause = cause.getCause();
-        }
+    checkCachePosition =
+        !currentRequestIgnoresCache && nextDataSource == upstreamDataSource
+            ? readPosition + MIN_READ_BEFORE_CHECKING_CACHE
+            : Long.MAX_VALUE;
+    if (checkCache) {
+      Assertions.checkState(currentDataSource == upstreamDataSource);
+      if (nextDataSource == upstreamDataSource) {
+        // Continue reading from upstream.
+        return;
       }
-      if (e != null) {
+      // We're switching to reading from or writing to the cache.
+      try {
+        closeCurrentSource();
+      } catch (Throwable e) {
+        if (nextSpan.isHoleSpan()) {
+          // Release the hole span before throwing, else we'll hold it forever.
+          cache.releaseHoleSpan(nextSpan);
+        }
         throw e;
       }
     }
 
-    // If we did an unbounded request (which means it's to upstream and
-    // bytesRemaining == C.LENGTH_UNSET) and got a resolved length from open() request
-    if (currentRequestUnbounded && currentBytesRemaining != C.LENGTH_UNSET) {
-      bytesRemaining = currentBytesRemaining;
-      setContentLength(dataSpec.position + bytesRemaining);
+    if (nextSpan != null && nextSpan.isHoleSpan()) {
+      currentHoleSpan = nextSpan;
+    }
+    currentDataSource = nextDataSource;
+    currentDataSpecLengthUnset = nextDataSpec.length == C.LENGTH_UNSET;
+    long resolvedLength = nextDataSource.open(nextDataSpec);
+    if (currentDataSpecLengthUnset && resolvedLength != C.LENGTH_UNSET) {
+      setBytesRemaining(resolvedLength);
     }
-    return successful;
   }
 
-  private void setContentLength(long length) throws IOException {
-    // If writing into cache
-    if (currentDataSource == cacheWriteDataSource) {
-      cache.setContentLength(key, length);
+  private static boolean isCausedByPositionOutOfRange(IOException e) {
+    Throwable cause = e;
+    while (cause != null) {
+      if (cause instanceof DataSourceException) {
+        int reason = ((DataSourceException) cause).reason;
+        if (reason == DataSourceException.POSITION_OUT_OF_RANGE) {
+          return true;
+        }
+      }
+      cause = cause.getCause();
     }
+    return false;
+  }
+
+  private void setBytesRemaining(long bytesRemaining) throws IOException {
+    this.bytesRemaining = bytesRemaining;
+    if (isWritingToCache()) {
+      cache.setContentLength(key, readPosition + bytesRemaining);
+    }
+  }
+
+  private boolean isWritingToCache() {
+    return currentDataSource == cacheWriteDataSource;
   }
 
   private void closeCurrentSource() throws IOException {
@@ -373,12 +406,12 @@ private void closeCurrentSource() throws IOException {
     }
     try {
       currentDataSource.close();
-      currentDataSource = null;
-      currentRequestUnbounded = false;
     } finally {
-      if (lockedSpan != null) {
-        cache.releaseHoleSpan(lockedSpan);
-        lockedSpan = null;
+      currentDataSource = null;
+      currentDataSpecLengthUnset = false;
+      if (currentHoleSpan != null) {
+        cache.releaseHoleSpan(currentHoleSpan);
+        currentHoleSpan = null;
       }
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
index cf2dedbe54..22150f8e78 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheUtil.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.upstream.cache;
 
 import android.net.Uri;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -88,8 +89,8 @@ public static void getCached(DataSpec dataSpec, Cache cache, CachingCounters cou
     counters.alreadyCachedBytes = 0;
     counters.newlyCachedBytes = 0;
     while (left != 0) {
-      long blockLength = cache.getCachedBytes(key, start,
-          left != C.LENGTH_UNSET ? left : Long.MAX_VALUE);
+      long blockLength =
+          cache.getCachedLength(key, start, left != C.LENGTH_UNSET ? left : Long.MAX_VALUE);
       if (blockLength > 0) {
         counters.alreadyCachedBytes += blockLength;
       } else {
@@ -110,12 +111,13 @@ public static void getCached(DataSpec dataSpec, Cache cache, CachingCounters cou
    * @param dataSpec Defines the data to be cached.
    * @param cache A {@link Cache} to store the data.
    * @param upstream A {@link DataSource} for reading data not in the cache.
-   * @param counters Counters to update during caching.
+   * @param counters If not null, updated during caching.
    * @throws IOException If an error occurs reading from the source.
    * @throws InterruptedException If the thread was interrupted.
    */
-  public static void cache(DataSpec dataSpec, Cache cache, DataSource upstream,
-      CachingCounters counters) throws IOException, InterruptedException {
+  public static void cache(
+      DataSpec dataSpec, Cache cache, DataSource upstream, @Nullable CachingCounters counters)
+      throws IOException, InterruptedException {
     cache(dataSpec, cache, new CacheDataSource(cache, upstream),
         new byte[DEFAULT_BUFFER_SIZE_BYTES], null, 0, counters, false);
   }
@@ -124,6 +126,12 @@ public static void cache(DataSpec dataSpec, Cache cache, DataSource upstream,
    * Caches the data defined by {@code dataSpec} while skipping already cached data. Caching stops
    * early if end of input is reached and {@code enableEOFException} is false.
    *
+   * <p>If a {@link PriorityTaskManager} is given, it's used to pause and resume caching depending
+   * on {@code priority} and the priority of other tasks registered to the PriorityTaskManager.
+   * Please note that it's the responsibility of the calling code to call {@link
+   * PriorityTaskManager#add} to register with the manager before calling this method, and to call
+   * {@link PriorityTaskManager#remove} afterwards to unregister.
+   *
    * @param dataSpec Defines the data to be cached.
    * @param cache A {@link Cache} to store the data.
    * @param dataSource A {@link CacheDataSource} that works on the {@code cache}.
@@ -131,15 +139,21 @@ public static void cache(DataSpec dataSpec, Cache cache, DataSource upstream,
    * @param priorityTaskManager If not null it's used to check whether it is allowed to proceed with
    *     caching.
    * @param priority The priority of this task. Used with {@code priorityTaskManager}.
-   * @param counters Counters to update during caching.
+   * @param counters If not null, updated during caching.
    * @param enableEOFException Whether to throw an {@link EOFException} if end of input has been
    *     reached unexpectedly.
    * @throws IOException If an error occurs reading from the source.
    * @throws InterruptedException If the thread was interrupted.
    */
-  public static void cache(DataSpec dataSpec, Cache cache, CacheDataSource dataSource,
-      byte[] buffer, PriorityTaskManager priorityTaskManager, int priority,
-      CachingCounters counters, boolean enableEOFException)
+  public static void cache(
+      DataSpec dataSpec,
+      Cache cache,
+      CacheDataSource dataSource,
+      byte[] buffer,
+      PriorityTaskManager priorityTaskManager,
+      int priority,
+      @Nullable CachingCounters counters,
+      boolean enableEOFException)
       throws IOException, InterruptedException {
     Assertions.checkNotNull(dataSource);
     Assertions.checkNotNull(buffer);
@@ -156,8 +170,8 @@ public static void cache(DataSpec dataSpec, Cache cache, CacheDataSource dataSou
     long start = dataSpec.absoluteStreamPosition;
     long left = dataSpec.length != C.LENGTH_UNSET ? dataSpec.length : cache.getContentLength(key);
     while (left != 0) {
-      long blockLength = cache.getCachedBytes(key, start,
-          left != C.LENGTH_UNSET ? left : Long.MAX_VALUE);
+      long blockLength =
+          cache.getCachedLength(key, start, left != C.LENGTH_UNSET ? left : Long.MAX_VALUE);
       if (blockLength > 0) {
         // Skip already cached data.
       } else {
@@ -245,9 +259,6 @@ private static long readAndDiscard(DataSpec dataSpec, long absoluteStreamPositio
   /** Removes all of the data in the {@code cache} pointed by the {@code key}. */
   public static void remove(Cache cache, String key) {
     NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(key);
-    if (cachedSpans == null) {
-      return;
-    }
     for (CacheSpan cachedSpan : cachedSpans) {
       try {
         cache.removeSpan(cachedSpan);
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
index fb59d23666..da7b4bfd60 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContent.java
@@ -28,22 +28,16 @@
  */
 /*package*/ final class CachedContent {
 
-  /**
-   * The cache file id that uniquely identifies the original stream.
-   */
+  /** The cache file id that uniquely identifies the original stream. */
   public final int id;
-  /**
-   * The cache key that uniquely identifies the original stream.
-   */
+  /** The cache key that uniquely identifies the original stream. */
   public final String key;
-  /**
-   * The cached spans of this content.
-   */
+  /** The cached spans of this content. */
   private final TreeSet<SimpleCacheSpan> cachedSpans;
-  /**
-   * The length of the original stream, or {@link C#LENGTH_UNSET} if the length is unknown.
-   */
+  /** The length of the original stream, or {@link C#LENGTH_UNSET} if the length is unknown. */
   private long length;
+  /** Whether the content is locked. */
+  private boolean locked;
 
   /**
    * Reads an instance from a {@link DataInputStream}.
@@ -91,6 +85,16 @@ public void setLength(long length) {
     this.length = length;
   }
 
+  /** Returns whether the content is locked. */
+  public boolean isLocked() {
+    return locked;
+  }
+
+  /** Sets the locked state of the content. */
+  public void setLocked(boolean locked) {
+    this.locked = locked;
+  }
+
   /** Adds the given {@link SimpleCacheSpan} which contains a part of the content. */
   public void addSpan(SimpleCacheSpan span) {
     cachedSpans.add(span);
@@ -125,7 +129,7 @@ public SimpleCacheSpan getSpan(long position) {
    * @param length The maximum length of the data to be returned.
    * @return the length of the cached or not cached data block length.
    */
-  public long getCachedBytes(long position, long length) {
+  public long getCachedBytesLength(long position, long length) {
     SimpleCacheSpan span = getSpan(position);
     if (span.isHoleSpan()) {
       // We don't have a span covering the start of the queried region.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
index 64144bc5ef..bd97ea8880 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedContentIndex.java
@@ -34,7 +34,6 @@
 import java.security.InvalidAlgorithmParameterException;
 import java.security.InvalidKeyException;
 import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Random;
@@ -140,7 +139,7 @@ public void store() throws CacheException {
    * @param key The cache key that uniquely identifies the original stream.
    * @return A new or existing CachedContent instance with the given key.
    */
-  public CachedContent add(String key) {
+  public CachedContent getOrAdd(String key) {
     CachedContent cachedContent = keyToContent.get(key);
     if (cachedContent == null) {
       cachedContent = addNew(key, C.LENGTH_UNSET);
@@ -166,7 +165,7 @@ public CachedContent get(String key) {
 
   /** Returns an existing or new id assigned to the given key. */
   public int assignIdForKey(String key) {
-    return add(key).id;
+    return getOrAdd(key).id;
   }
 
   /** Returns the key which has the given id assigned. */
@@ -174,30 +173,22 @@ public String getKeyForId(int id) {
     return idToKey.get(id);
   }
 
-  /**
-   * Removes {@link CachedContent} with the given key from index. It shouldn't contain any spans.
-   *
-   * @throws IllegalStateException If {@link CachedContent} isn't empty.
-   */
-  public void removeEmpty(String key) {
-    CachedContent cachedContent = keyToContent.remove(key);
-    if (cachedContent != null) {
-      Assertions.checkState(cachedContent.isEmpty());
+  /** Removes {@link CachedContent} with the given key from index if it's empty and not locked. */
+  public void maybeRemove(String key) {
+    CachedContent cachedContent = keyToContent.get(key);
+    if (cachedContent != null && cachedContent.isEmpty() && !cachedContent.isLocked()) {
+      keyToContent.remove(key);
       idToKey.remove(cachedContent.id);
       changed = true;
     }
   }
 
-  /** Removes empty {@link CachedContent} instances from index. */
+  /** Removes empty and not locked {@link CachedContent} instances from index. */
   public void removeEmpty() {
-    ArrayList<String> cachedContentToBeRemoved = new ArrayList<>();
-    for (CachedContent cachedContent : keyToContent.values()) {
-      if (cachedContent.isEmpty()) {
-        cachedContentToBeRemoved.add(cachedContent.key);
-      }
-    }
-    for (int i = 0; i < cachedContentToBeRemoved.size(); i++) {
-      removeEmpty(cachedContentToBeRemoved.get(i));
+    String[] keys = new String[keyToContent.size()];
+    keyToContent.keySet().toArray(keys);
+    for (String key : keys) {
+      maybeRemove(key);
     }
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
index 9559054f6d..9455aed11b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTracker.java
@@ -50,14 +50,12 @@ public CachedRegionTracker(Cache cache, String cacheKey, ChunkIndex chunkIndex)
 
     synchronized (this) {
       NavigableSet<CacheSpan> cacheSpans = cache.addListener(cacheKey, this);
-      if (cacheSpans != null) {
-        // Merge the spans into regions. mergeSpan is more efficient when merging from high to low,
-        // which is why a descending iterator is used here.
-        Iterator<CacheSpan> spanIterator = cacheSpans.descendingIterator();
-        while (spanIterator.hasNext()) {
-          CacheSpan span = spanIterator.next();
-          mergeSpan(span);
-        }
+      // Merge the spans into regions. mergeSpan is more efficient when merging from high to low,
+      // which is why a descending iterator is used here.
+      Iterator<CacheSpan> spanIterator = cacheSpans.descendingIterator();
+      while (spanIterator.hasNext()) {
+        CacheSpan span = spanIterator.next();
+        mergeSpan(span);
       }
     }
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
index 599474d6c3..f2679fee0c 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCache.java
@@ -36,7 +36,6 @@
 
   private final File cacheDir;
   private final CacheEvictor evictor;
-  private final HashMap<String, CacheSpan> lockedSpans;
   private final CachedContentIndex index;
   private final HashMap<String, ArrayList<Listener>> listeners;
   private long totalSpace = 0;
@@ -91,7 +90,6 @@ public SimpleCache(File cacheDir, CacheEvictor evictor, byte[] secretKey, boolea
   /*package*/ SimpleCache(File cacheDir, CacheEvictor evictor, CachedContentIndex index) {
     this.cacheDir = cacheDir;
     this.evictor = evictor;
-    this.lockedSpans = new HashMap<>();
     this.index = index;
     this.listeners = new HashMap<>();
     // Start cache initialization.
@@ -134,7 +132,8 @@ public synchronized void removeListener(String key, Listener listener) {
   @Override
   public synchronized NavigableSet<CacheSpan> getCachedSpans(String key) {
     CachedContent cachedContent = index.get(key);
-    return cachedContent == null || cachedContent.isEmpty() ? null
+    return cachedContent == null || cachedContent.isEmpty()
+        ? new TreeSet<CacheSpan>()
         : new TreeSet<CacheSpan>(cachedContent.getSpans());
   }
 
@@ -178,9 +177,10 @@ public synchronized SimpleCacheSpan startReadWriteNonBlocking(String key, long p
       return newCacheSpan;
     }
 
-    // Write case, lock available.
-    if (!lockedSpans.containsKey(key)) {
-      lockedSpans.put(key, cacheSpan);
+    CachedContent cachedContent = index.getOrAdd(key);
+    if (!cachedContent.isLocked()) {
+      // Write case, lock available.
+      cachedContent.setLocked(true);
       return cacheSpan;
     }
 
@@ -191,22 +191,26 @@ public synchronized SimpleCacheSpan startReadWriteNonBlocking(String key, long p
   @Override
   public synchronized File startFile(String key, long position, long maxLength)
       throws CacheException {
-    Assertions.checkState(lockedSpans.containsKey(key));
+    CachedContent cachedContent = index.get(key);
+    Assertions.checkNotNull(cachedContent);
+    Assertions.checkState(cachedContent.isLocked());
     if (!cacheDir.exists()) {
       // For some reason the cache directory doesn't exist. Make a best effort to create it.
       removeStaleSpansAndCachedContents();
       cacheDir.mkdirs();
     }
     evictor.onStartFile(this, key, position, maxLength);
-    return SimpleCacheSpan.getCacheFile(cacheDir, index.assignIdForKey(key), position,
-        System.currentTimeMillis());
+    return SimpleCacheSpan.getCacheFile(
+        cacheDir, cachedContent.id, position, System.currentTimeMillis());
   }
 
   @Override
   public synchronized void commitFile(File file) throws CacheException {
     SimpleCacheSpan span = SimpleCacheSpan.createCacheEntry(file, index);
     Assertions.checkState(span != null);
-    Assertions.checkState(lockedSpans.containsKey(span.key));
+    CachedContent cachedContent = index.get(span.key);
+    Assertions.checkNotNull(cachedContent);
+    Assertions.checkState(cachedContent.isLocked());
     // If the file doesn't exist, don't add it to the in-memory representation.
     if (!file.exists()) {
       return;
@@ -217,7 +221,7 @@ public synchronized void commitFile(File file) throws CacheException {
       return;
     }
     // Check if the span conflicts with the set content length
-    Long length = getContentLength(span.key);
+    Long length = cachedContent.getLength();
     if (length != C.LENGTH_UNSET) {
       Assertions.checkState((span.position + span.length) <= length);
     }
@@ -228,7 +232,11 @@ public synchronized void commitFile(File file) throws CacheException {
 
   @Override
   public synchronized void releaseHoleSpan(CacheSpan holeSpan) {
-    Assertions.checkState(holeSpan == lockedSpans.remove(holeSpan.key));
+    CachedContent cachedContent = index.get(holeSpan.key);
+    Assertions.checkNotNull(cachedContent);
+    Assertions.checkState(cachedContent.isLocked());
+    cachedContent.setLocked(false);
+    index.maybeRemove(cachedContent.key);
     notifyAll();
   }
 
@@ -304,7 +312,7 @@ private void initialize() {
    * @param span The span to be added.
    */
   private void addSpan(SimpleCacheSpan span) {
-    index.add(span.key).addSpan(span);
+    index.getOrAdd(span.key).addSpan(span);
     totalSpace += span.length;
     notifySpanAdded(span);
   }
@@ -316,8 +324,8 @@ private void removeSpan(CacheSpan span, boolean removeEmptyCachedContent) throws
     }
     totalSpace -= span.length;
     try {
-      if (removeEmptyCachedContent && cachedContent.isEmpty()) {
-        index.removeEmpty(cachedContent.key);
+      if (removeEmptyCachedContent) {
+        index.maybeRemove(cachedContent.key);
         index.store();
       }
     } finally {
@@ -384,13 +392,13 @@ private void notifySpanTouched(SimpleCacheSpan oldSpan, CacheSpan newSpan) {
   @Override
   public synchronized boolean isCached(String key, long position, long length) {
     CachedContent cachedContent = index.get(key);
-    return cachedContent != null && cachedContent.getCachedBytes(position, length) >= length;
+    return cachedContent != null && cachedContent.getCachedBytesLength(position, length) >= length;
   }
 
   @Override
-  public synchronized long getCachedBytes(String key, long position, long length) {
+  public synchronized long getCachedLength(String key, long position, long length) {
     CachedContent cachedContent = index.get(key);
-    return cachedContent != null ? cachedContent.getCachedBytes(position, length) : -length;
+    return cachedContent != null ? cachedContent.getCachedBytesLength(position, length) : -length;
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
index 8c5b7e26e7..e12d876ce1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheSpan.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
@@ -35,19 +36,50 @@
   private static final Pattern CACHE_FILE_PATTERN_V3 = Pattern.compile(
       "^(\\d+)\\.(\\d+)\\.(\\d+)\\.v3\\.exo$", Pattern.DOTALL);
 
-  public static File getCacheFile(File cacheDir, int id, long position,
-      long lastAccessTimestamp) {
+  /**
+   * Returns a new {@link File} instance from {@code cacheDir}, {@code id}, {@code position}, {@code
+   * lastAccessTimestamp}.
+   *
+   * @param cacheDir The parent abstract pathname.
+   * @param id The cache file id.
+   * @param position The position of the stored data in the original stream.
+   * @param lastAccessTimestamp The last access timestamp.
+   * @return The cache file.
+   */
+  public static File getCacheFile(File cacheDir, int id, long position, long lastAccessTimestamp) {
     return new File(cacheDir, id + "." + position + "." + lastAccessTimestamp + SUFFIX);
   }
 
+  /**
+   * Creates a lookup span.
+   *
+   * @param key The cache key.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @return The span.
+   */
   public static SimpleCacheSpan createLookup(String key, long position) {
     return new SimpleCacheSpan(key, position, C.LENGTH_UNSET, C.TIME_UNSET, null);
   }
 
+  /**
+   * Creates an open hole span.
+   *
+   * @param key The cache key.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @return The span.
+   */
   public static SimpleCacheSpan createOpenHole(String key, long position) {
     return new SimpleCacheSpan(key, position, C.LENGTH_UNSET, C.TIME_UNSET, null);
   }
 
+  /**
+   * Creates a closed hole span.
+   *
+   * @param key The cache key.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @param length The length of the {@link CacheSpan}.
+   * @return The span.
+   */
   public static SimpleCacheSpan createClosedHole(String key, long position, long length) {
     return new SimpleCacheSpan(key, position, length, C.TIME_UNSET, null);
   }
@@ -60,6 +92,7 @@ public static SimpleCacheSpan createClosedHole(String key, long position, long l
    * @return The span, or null if the file name is not correctly formatted, or if the id is not
    *     present in the content index.
    */
+  @Nullable
   public static SimpleCacheSpan createCacheEntry(File file, CachedContentIndex index) {
     String name = file.getName();
     if (!name.endsWith(SUFFIX)) {
@@ -81,6 +114,15 @@ public static SimpleCacheSpan createCacheEntry(File file, CachedContentIndex ind
         Long.parseLong(matcher.group(3)), file);
   }
 
+  /**
+   * Upgrades the cache file if it is created by an earlier version of {@link SimpleCache}.
+   *
+   * @param file The cache file.
+   * @param index Cached content index.
+   * @return Upgraded cache file or {@code null} if the file name is not correctly formatted or the
+   *     file can not be renamed.
+   */
+  @Nullable
   private static File upgradeFile(File file, CachedContentIndex index) {
     String key;
     String filename = file.getName();
@@ -106,8 +148,17 @@ private static File upgradeFile(File file, CachedContentIndex index) {
     return newCacheFile;
   }
 
-  private SimpleCacheSpan(String key, long position, long length, long lastAccessTimestamp,
-      File file) {
+  /**
+   * @param key The cache key.
+   * @param position The position of the {@link CacheSpan} in the original stream.
+   * @param length The length of the {@link CacheSpan}, or {@link C#LENGTH_UNSET} if this is an
+   *     open-ended hole.
+   * @param lastAccessTimestamp The last access timestamp, or {@link C#TIME_UNSET} if {@link
+   *     #isCached} is false.
+   * @param file The file corresponding to this {@link CacheSpan}, or null if it's a hole.
+   */
+  private SimpleCacheSpan(
+      String key, long position, long length, long lastAccessTimestamp, @Nullable File file) {
     super(key, position, length, lastAccessTimestamp, file);
   }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java
index 9619ed53ea..36fc3b1bf8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Clock.java
@@ -16,10 +16,12 @@
 package com.google.android.exoplayer2.util;
 
 import android.os.Handler;
+import android.os.Looper;
+import android.support.annotation.Nullable;
 
 /**
- * An interface through which system clocks can be read. The {@link #DEFAULT} implementation
- * must be used for all non-test cases.
+ * An interface through which system clocks can be read and {@link HandlerWrapper}s created. The
+ * {@link #DEFAULT} implementation must be used for all non-test cases.
  */
 public interface Clock {
 
@@ -28,24 +30,20 @@
    */
   Clock DEFAULT = new SystemClock();
 
-  /**
-   * @see android.os.SystemClock#elapsedRealtime()
-   */
+  /** @see android.os.SystemClock#elapsedRealtime() */
   long elapsedRealtime();
 
-  /**
-   * @see android.os.SystemClock#sleep(long)
-   */
+  /** @see android.os.SystemClock#uptimeMillis() */
+  long uptimeMillis();
+
+  /** @see android.os.SystemClock#sleep(long) */
   void sleep(long sleepTimeMs);
 
   /**
-   * Post a {@link Runnable} on a {@link Handler} thread with a delay measured by this clock.
-   * @see Handler#postDelayed(Runnable, long)
+   * Creates a {@link HandlerWrapper} using a specified looper and a specified callback for handling
+   * messages.
    *
-   * @param handler The {@link Handler} to post the {@code runnable} on.
-   * @param runnable A {@link Runnable} to be posted.
-   * @param delayMs The delay in milliseconds as measured by this clock.
+   * @see Handler#Handler(Looper, Handler.Callback)
    */
-  void postDelayed(Handler handler, Runnable runnable, long delayMs);
-
+  HandlerWrapper createHandler(Looper looper, @Nullable Handler.Callback callback);
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
index 262d120af8..058a5d6dd2 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ConditionVariable.java
@@ -60,18 +60,18 @@ public synchronized void block() throws InterruptedException {
   }
 
   /**
-   * Blocks until the condition is opened or until timeout milliseconds have passed.
+   * Blocks until the condition is opened or until {@code timeout} milliseconds have passed.
    *
    * @param timeout The maximum time to wait in milliseconds.
-   * @return true If the condition was opened, false if the call returns because of the timeout.
+   * @return True if the condition was opened, false if the call returns because of the timeout.
    * @throws InterruptedException If the thread is interrupted.
    */
   public synchronized boolean block(long timeout) throws InterruptedException {
-    long now = System.currentTimeMillis();
+    long now = android.os.SystemClock.elapsedRealtime();
     long end = now + timeout;
     while (!isOpen && now < end) {
       wait(end - now);
-      now = System.currentTimeMillis();
+      now = android.os.SystemClock.elapsedRealtime();
     }
     return isOpen;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ErrorMessageProvider.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ErrorMessageProvider.java
index 3d2c043a91..e2fe095d03 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ErrorMessageProvider.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ErrorMessageProvider.java
@@ -17,17 +17,15 @@
 
 import android.util.Pair;
 
-/**
- * Converts exceptions into error codes and user readable error messages.
- */
-public interface ErrorMessageProvider<T extends Exception> {
+/** Converts throwables into error codes and user readable error messages. */
+public interface ErrorMessageProvider<T extends Throwable> {
 
   /**
    * Returns a pair consisting of an error code and a user readable error message for the given
-   * exception.
+   * throwable.
    *
-   * @param exception The exception for which an error code and message should be generated.
+   * @param throwable The throwable for which an error code and message should be generated.
+   * @return A pair consisting of an error code and a user readable error message.
    */
-  Pair<Integer, String> getErrorMessage(T exception);
-
+  Pair<Integer, String> getErrorMessage(T throwable);
 }
diff --git a/demos/main/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
similarity index 88%
rename from demos/main/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
rename to library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
index 27a5c68e28..d95f387996 100644
--- a/demos/main/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/EventLogger.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.android.exoplayer2.demo;
+package com.google.android.exoplayer2.util;
 
 import android.os.SystemClock;
 import android.util.Log;
@@ -38,10 +38,11 @@
 import com.google.android.exoplayer2.metadata.id3.PrivFrame;
 import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
 import com.google.android.exoplayer2.metadata.id3.UrlLinkFrame;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
-import com.google.android.exoplayer2.source.ExtractorMediaSource;
+import com.google.android.exoplayer2.metadata.scte35.SpliceCommand;
+import com.google.android.exoplayer2.source.MediaSourceEventListener;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector.MappedTrackInfo;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
@@ -52,12 +53,15 @@
 import java.text.NumberFormat;
 import java.util.Locale;
 
-/**
- * Logs player events using {@link Log}.
- */
-/* package */ final class EventLogger implements Player.EventListener, MetadataOutput,
-    AudioRendererEventListener, VideoRendererEventListener, AdaptiveMediaSourceEventListener,
-    ExtractorMediaSource.EventListener, DefaultDrmSessionManager.EventListener {
+/** Logs events from {@link Player} and other core components using {@link Log}. */
+public class EventLogger
+    implements Player.EventListener,
+        MetadataOutput,
+        AudioRendererEventListener,
+        VideoRendererEventListener,
+        MediaSourceEventListener,
+        AdsMediaSource.EventListener,
+        DefaultDrmSessionManager.EventListener {
 
   private static final String TAG = "EventLogger";
   private static final int MAX_TIMELINE_ITEM_LINES = 3;
@@ -116,10 +120,12 @@ public void onPlaybackParametersChanged(PlaybackParameters playbackParameters) {
   }
 
   @Override
-  public void onTimelineChanged(Timeline timeline, Object manifest) {
+  public void onTimelineChanged(Timeline timeline, Object manifest,
+      @Player.TimelineChangeReason int reason) {
     int periodCount = timeline.getPeriodCount();
     int windowCount = timeline.getWindowCount();
-    Log.d(TAG, "sourceInfo [periodCount=" + periodCount + ", windowCount=" + windowCount);
+    Log.d(TAG, "timelineChanged [periodCount=" + periodCount + ", windowCount=" + windowCount
+        + ", reason=" + getTimelineChangeReasonString(reason));
     for (int i = 0; i < Math.min(periodCount, MAX_TIMELINE_ITEM_LINES); i++) {
       timeline.getPeriod(i, period);
       Log.d(TAG, "  " +  "period [" + getTimeString(period.getDurationMs()) + "]");
@@ -320,19 +326,19 @@ public void onDrmKeysLoaded() {
     Log.d(TAG, "drmKeysLoaded [" + getSessionTimeString() + "]");
   }
 
-  // ExtractorMediaSource.EventListener
-
-  @Override
-  public void onLoadError(IOException error) {
-    printInternalError("loadError", error);
-  }
-
-  // AdaptiveMediaSourceEventListener
+  // MediaSourceEventListener
 
   @Override
-  public void onLoadStarted(DataSpec dataSpec, int dataType, int trackType, Format trackFormat,
-      int trackSelectionReason, Object trackSelectionData, long mediaStartTimeMs,
-      long mediaEndTimeMs, long elapsedRealtimeMs) {
+  public void onLoadStarted(
+      DataSpec dataSpec,
+      int dataType,
+      int trackType,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long mediaStartTimeMs,
+      long mediaEndTimeMs,
+      long elapsedRealtimeMs) {
     // Do nothing.
   }
 
@@ -369,6 +375,28 @@ public void onDownstreamFormatChanged(int trackType, Format trackFormat, int tra
     // Do nothing.
   }
 
+  // AdsMediaSource.EventListener
+
+  @Override
+  public void onAdLoadError(IOException error) {
+    printInternalError("adLoadError", error);
+  }
+
+  @Override
+  public void onInternalAdLoadError(RuntimeException error) {
+    printInternalError("internalAdLoadError", error);
+  }
+
+  @Override
+  public void onAdClicked() {
+    // Do nothing.
+  }
+
+  @Override
+  public void onAdTapped() {
+    // Do nothing.
+  }
+
   // Internal methods
 
   private void printInternalError(String type, Exception e) {
@@ -407,6 +435,10 @@ private void printMetadata(Metadata metadata, String prefix) {
         EventMessage eventMessage = (EventMessage) entry;
         Log.d(TAG, prefix + String.format("EMSG: scheme=%s, id=%d, value=%s",
             eventMessage.schemeIdUri, eventMessage.id, eventMessage.value));
+      } else if (entry instanceof SpliceCommand) {
+        String description =
+            String.format("SCTE-35 splice command: type=%s.", entry.getClass().getSimpleName());
+        Log.d(TAG, prefix + description);
       }
     }
   }
@@ -467,6 +499,9 @@ private static String getAdaptiveSupportString(int trackCount, int adaptiveSuppo
     }
   }
 
+  // Suppressing reference equality warning because the track group stored in the track selection
+  // must point to the exact track group object to be considered part of it.
+  @SuppressWarnings("ReferenceEquality")
   private static String getTrackStatusString(TrackSelection selection, TrackGroup group,
       int trackIndex) {
     return getTrackStatusString(selection != null && selection.getTrackGroup() == group
@@ -498,10 +533,26 @@ private static String getDiscontinuityReasonString(@Player.DiscontinuityReason i
         return "SEEK";
       case Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT:
         return "SEEK_ADJUSTMENT";
+      case Player.DISCONTINUITY_REASON_AD_INSERTION:
+        return "AD_INSERTION";
       case Player.DISCONTINUITY_REASON_INTERNAL:
         return "INTERNAL";
       default:
         return "?";
     }
   }
+
+  private static String getTimelineChangeReasonString(@Player.TimelineChangeReason int reason) {
+    switch (reason) {
+      case Player.TIMELINE_CHANGE_REASON_PREPARED:
+        return "PREPARED";
+      case Player.TIMELINE_CHANGE_REASON_RESET:
+        return "RESET";
+      case Player.TIMELINE_CHANGE_REASON_DYNAMIC:
+        return "DYNAMIC";
+      default:
+        return "?";
+    }
+  }
+
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/HandlerWrapper.java b/library/core/src/main/java/com/google/android/exoplayer2/util/HandlerWrapper.java
new file mode 100644
index 0000000000..8f1a6544ca
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/HandlerWrapper.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+
+/**
+ * An interface to call through to a {@link Handler}. Instances must be created by calling {@link
+ * Clock#createHandler(Looper, Handler.Callback)} on {@link Clock#DEFAULT} for all non-test cases.
+ */
+public interface HandlerWrapper {
+
+  /** @see Handler#getLooper() */
+  Looper getLooper();
+
+  /** @see Handler#obtainMessage(int) */
+  Message obtainMessage(int what);
+
+  /** @see Handler#obtainMessage(int, Object) */
+  Message obtainMessage(int what, Object obj);
+
+  /** @see Handler#obtainMessage(int, int, int) */
+  Message obtainMessage(int what, int arg1, int arg2);
+
+  /** @see Handler#obtainMessage(int, int, int, Object) */
+  Message obtainMessage(int what, int arg1, int arg2, Object obj);
+
+  /** @see Handler#sendEmptyMessage(int) */
+  boolean sendEmptyMessage(int what);
+
+  /** @see Handler#sendEmptyMessageAtTime(int, long) */
+  boolean sendEmptyMessageAtTime(int what, long uptimeMs);
+
+  /** @see Handler#removeMessages(int) */
+  void removeMessages(int what);
+
+  /** @see Handler#removeCallbacksAndMessages(Object) */
+  void removeCallbacksAndMessages(Object token);
+
+  /** @see Handler#post(Runnable) */
+  boolean post(Runnable runnable);
+
+  /** @see Handler#postDelayed(Runnable, long) */
+  boolean postDelayed(Runnable runnable, long delayMs);
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
index 2daf16d3d2..041ee55cf1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.util;
 
+import android.support.annotation.Nullable;
 import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 
@@ -36,6 +37,7 @@
   public static final String VIDEO_VP8 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp8";
   public static final String VIDEO_VP9 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp9";
   public static final String VIDEO_MP4V = BASE_TYPE_VIDEO + "/mp4v-es";
+  public static final String VIDEO_MPEG = BASE_TYPE_VIDEO + "/mpeg";
   public static final String VIDEO_MPEG2 = BASE_TYPE_VIDEO + "/mpeg2";
   public static final String VIDEO_VC1 = BASE_TYPE_VIDEO + "/wvc1";
   public static final String VIDEO_UNKNOWN = BASE_TYPE_VIDEO + "/x-unknown";
@@ -51,6 +53,7 @@
   public static final String AUDIO_MLAW = BASE_TYPE_AUDIO + "/g711-mlaw";
   public static final String AUDIO_AC3 = BASE_TYPE_AUDIO + "/ac3";
   public static final String AUDIO_E_AC3 = BASE_TYPE_AUDIO + "/eac3";
+  public static final String AUDIO_E_AC3_JOC = BASE_TYPE_AUDIO + "/eac3-joc";
   public static final String AUDIO_TRUEHD = BASE_TYPE_AUDIO + "/true-hd";
   public static final String AUDIO_DTS = BASE_TYPE_AUDIO + "/vnd.dts";
   public static final String AUDIO_DTS_HD = BASE_TYPE_AUDIO + "/vnd.dts.hd";
@@ -69,7 +72,9 @@
 
   public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4";
   public static final String APPLICATION_WEBM = BASE_TYPE_APPLICATION + "/webm";
+  public static final String APPLICATION_MPD = BASE_TYPE_APPLICATION + "/dash+xml";
   public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
+  public static final String APPLICATION_SS = BASE_TYPE_APPLICATION + "/vnd.ms-sstr+xml";
   public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
   public static final String APPLICATION_CEA608 = BASE_TYPE_APPLICATION + "/cea-608";
   public static final String APPLICATION_CEA708 = BASE_TYPE_APPLICATION + "/cea-708";
@@ -190,11 +195,26 @@ public static String getMediaMimeType(String codec) {
     } else if (codec.startsWith("vp8") || codec.startsWith("vp08")) {
       return MimeTypes.VIDEO_VP8;
     } else if (codec.startsWith("mp4a")) {
-      return MimeTypes.AUDIO_AAC;
+      String mimeType = null;
+      if (codec.startsWith("mp4a.")) {
+        String objectTypeString = codec.substring(5); // remove the 'mp4a.' prefix
+        if (objectTypeString.length() >= 2) {
+          try {
+            String objectTypeHexString = Util.toUpperInvariant(objectTypeString.substring(0, 2));
+            int objectTypeInt = Integer.parseInt(objectTypeHexString, 16);
+            mimeType = getMimeTypeFromMp4ObjectType(objectTypeInt);
+          } catch (NumberFormatException ignored) {
+            // ignored
+          }
+        }
+      }
+      return mimeType == null ? MimeTypes.AUDIO_AAC : mimeType;
     } else if (codec.startsWith("ac-3") || codec.startsWith("dac3")) {
       return MimeTypes.AUDIO_AC3;
     } else if (codec.startsWith("ec-3") || codec.startsWith("dec3")) {
       return MimeTypes.AUDIO_E_AC3;
+    } else if (codec.startsWith("ec+3")) {
+      return MimeTypes.AUDIO_E_AC3_JOC;
     } else if (codec.startsWith("dtsc") || codec.startsWith("dtse")) {
       return MimeTypes.AUDIO_DTS;
     } else if (codec.startsWith("dtsh") || codec.startsWith("dtsl")) {
@@ -208,12 +228,56 @@ public static String getMediaMimeType(String codec) {
   }
 
   /**
-   * Returns the {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified mime type.
-   * {@link C#TRACK_TYPE_UNKNOWN} if the mime type is not known or the mapping cannot be
+   * Derives a mimeType from MP4 object type identifier, as defined in RFC 6381 and
+   * http://www.mp4ra.org/object.html.
+   *
+   * @param objectType The objectType identifier to derive.
+   * @return The mimeType, or null if it could not be derived.
+   */
+  @Nullable
+  public static String getMimeTypeFromMp4ObjectType(int objectType) {
+    switch (objectType) {
+      case 0x60:
+      case 0x61:
+        return MimeTypes.VIDEO_MPEG2;
+      case 0x20:
+        return MimeTypes.VIDEO_MP4V;
+      case 0x21:
+        return MimeTypes.VIDEO_H264;
+      case 0x23:
+        return MimeTypes.VIDEO_H265;
+      case 0x69:
+      case 0x6B:
+        return MimeTypes.AUDIO_MPEG;
+      case 0x40:
+      case 0x66:
+      case 0x67:
+      case 0x68:
+        return MimeTypes.AUDIO_AAC;
+      case 0xA5:
+        return MimeTypes.AUDIO_AC3;
+      case 0xA6:
+        return MimeTypes.AUDIO_E_AC3;
+      case 0xA9:
+      case 0xAC:
+        return MimeTypes.AUDIO_DTS;
+      case 0xAA:
+      case 0xAB:
+        return MimeTypes.AUDIO_DTS_HD;
+      case 0xAD:
+        return MimeTypes.AUDIO_OPUS;
+      default:
+        return null;
+    }
+  }
+
+  /**
+   * Returns the {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified MIME type.
+   * {@link C#TRACK_TYPE_UNKNOWN} if the MIME type is not known or the mapping cannot be
    * established.
    *
-   * @param mimeType The mimeType.
-   * @return The {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified mime type.
+   * @param mimeType The MIME type.
+   * @return The {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified MIME type.
    */
   public static int getTrackType(String mimeType) {
     if (TextUtils.isEmpty(mimeType)) {
@@ -239,6 +303,32 @@ public static int getTrackType(String mimeType) {
     }
   }
 
+  /**
+   * Returns the {@link C}{@code .ENCODING_*} constant that corresponds to specified MIME type, if
+   * it is an encoded (non-PCM) audio format, or {@link C#ENCODING_INVALID} otherwise.
+   *
+   * @param mimeType The MIME type.
+   * @return The {@link C}{@code .ENCODING_*} constant that corresponds to a specified MIME type, or
+   *     {@link C#ENCODING_INVALID}.
+   */
+  public static @C.Encoding int getEncoding(String mimeType) {
+    switch (mimeType) {
+      case MimeTypes.AUDIO_AC3:
+        return C.ENCODING_AC3;
+      case MimeTypes.AUDIO_E_AC3:
+      case MimeTypes.AUDIO_E_AC3_JOC:
+        return C.ENCODING_E_AC3;
+      case MimeTypes.AUDIO_DTS:
+        return C.ENCODING_DTS;
+      case MimeTypes.AUDIO_DTS_HD:
+        return C.ENCODING_DTS_HD;
+      case MimeTypes.AUDIO_TRUEHD:
+        return C.ENCODING_DOLBY_TRUEHD;
+      default:
+        return C.ENCODING_INVALID;
+    }
+  }
+
   /**
    * Equivalent to {@code getTrackType(getMediaMimeType(codec))}.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
index 19b303484f..fb5f9525e9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java
@@ -263,6 +263,40 @@ public void skipBytes(int length) {
     assertValidOffset();
   }
 
+  /**
+   * Overwrites {@code numBits} from this array using the {@code numBits} least significant bits
+   * from {@code value}. Bits are written in order from most significant to least significant. The
+   * read position is advanced by {@code numBits}.
+   *
+   * @param value The integer whose {@code numBits} least significant bits are written into {@link
+   *     #data}.
+   * @param numBits The number of bits to write.
+   */
+  public void putInt(int value, int numBits) {
+    int remainingBitsToRead = numBits;
+    if (numBits < 32) {
+      value &= (1 << numBits) - 1;
+    }
+    int firstByteReadSize = Math.min(8 - bitOffset, numBits);
+    int firstByteRightPaddingSize = 8 - bitOffset - firstByteReadSize;
+    int firstByteBitmask = (0xFF00 >> bitOffset) | ((1 << firstByteRightPaddingSize) - 1);
+    data[byteOffset] &= firstByteBitmask;
+    int firstByteInputBits = value >>> (numBits - firstByteReadSize);
+    data[byteOffset] |= firstByteInputBits << firstByteRightPaddingSize;
+    remainingBitsToRead -= firstByteReadSize;
+    int currentByteIndex = byteOffset + 1;
+    while (remainingBitsToRead > 8) {
+      data[currentByteIndex++] = (byte) (value >>> (remainingBitsToRead - 8));
+      remainingBitsToRead -= 8;
+    }
+    int lastByteRightPaddingSize = 8 - remainingBitsToRead;
+    data[currentByteIndex] &= (1 << lastByteRightPaddingSize) - 1;
+    int lastByteInput = value & ((1 << remainingBitsToRead) - 1);
+    data[currentByteIndex] |= lastByteInput << lastByteRightPaddingSize;
+    skipBits(numBits);
+    assertValidOffset();
+  }
+
   private void assertValidOffset() {
     // It is fine for position to be at the end of the array, but no further.
     Assertions.checkState(byteOffset >= 0
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java b/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java
index 96203bb99a..b1f53416fb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/StandaloneMediaClock.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer2.util;
 
-import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.PlaybackParameters;
 
@@ -25,16 +24,21 @@
  */
 public final class StandaloneMediaClock implements MediaClock {
 
+  private final Clock clock;
+
   private boolean started;
   private long baseUs;
   private long baseElapsedMs;
   private PlaybackParameters playbackParameters;
 
   /**
-   * Creates a new standalone media clock.
+   * Creates a new standalone media clock using the given {@link Clock} implementation.
+   *
+   * @param clock A {@link Clock}.
    */
-  public StandaloneMediaClock() {
-    playbackParameters = PlaybackParameters.DEFAULT;
+  public StandaloneMediaClock(Clock clock) {
+    this.clock = clock;
+    this.playbackParameters = PlaybackParameters.DEFAULT;
   }
 
   /**
@@ -42,7 +46,7 @@ public StandaloneMediaClock() {
    */
   public void start() {
     if (!started) {
-      baseElapsedMs = SystemClock.elapsedRealtime();
+      baseElapsedMs = clock.elapsedRealtime();
       started = true;
     }
   }
@@ -52,20 +56,20 @@ public void start() {
    */
   public void stop() {
     if (started) {
-      setPositionUs(getPositionUs());
+      resetPosition(getPositionUs());
       started = false;
     }
   }
 
   /**
-   * Sets the clock's position.
+   * Resets the clock's position.
    *
    * @param positionUs The position to set in microseconds.
    */
-  public void setPositionUs(long positionUs) {
+  public void resetPosition(long positionUs) {
     baseUs = positionUs;
     if (started) {
-      baseElapsedMs = SystemClock.elapsedRealtime();
+      baseElapsedMs = clock.elapsedRealtime();
     }
   }
 
@@ -73,11 +77,11 @@ public void setPositionUs(long positionUs) {
   public long getPositionUs() {
     long positionUs = baseUs;
     if (started) {
-      long elapsedSinceBaseMs = SystemClock.elapsedRealtime() - baseElapsedMs;
+      long elapsedSinceBaseMs = clock.elapsedRealtime() - baseElapsedMs;
       if (playbackParameters.speed == 1f) {
         positionUs += C.msToUs(elapsedSinceBaseMs);
       } else {
-        positionUs += playbackParameters.getSpeedAdjustedDurationUs(elapsedSinceBaseMs);
+        positionUs += playbackParameters.getMediaTimeUsForPlayoutTimeMs(elapsedSinceBaseMs);
       }
     }
     return positionUs;
@@ -87,7 +91,7 @@ public long getPositionUs() {
   public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
     // Store the current position as the new base, in case the playback speed has changed.
     if (started) {
-      setPositionUs(getPositionUs());
+      resetPosition(getPositionUs());
     }
     this.playbackParameters = playbackParameters;
     return playbackParameters;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java
index 272c3f43ec..72d3df46e1 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemClock.java
@@ -16,6 +16,9 @@
 package com.google.android.exoplayer2.util;
 
 import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.support.annotation.Nullable;
 
 /**
  * The standard implementation of {@link Clock}.
@@ -27,14 +30,18 @@ public long elapsedRealtime() {
     return android.os.SystemClock.elapsedRealtime();
   }
 
+  @Override
+  public long uptimeMillis() {
+    return android.os.SystemClock.uptimeMillis();
+  }
+
   @Override
   public void sleep(long sleepTimeMs) {
     android.os.SystemClock.sleep(sleepTimeMs);
   }
 
   @Override
-  public void postDelayed(Handler handler, Runnable runnable, long delayMs) {
-    handler.postDelayed(runnable, delayMs);
+  public HandlerWrapper createHandler(Looper looper, @Nullable Callback callback) {
+    return new SystemHandlerWrapper(new Handler(looper, callback));
   }
-
 }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/SystemHandlerWrapper.java b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemHandlerWrapper.java
new file mode 100644
index 0000000000..ee469a5b2a
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/SystemHandlerWrapper.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import android.os.Looper;
+import android.os.Message;
+
+/** The standard implementation of {@link HandlerWrapper}. */
+/* package */ final class SystemHandlerWrapper implements HandlerWrapper {
+
+  private final android.os.Handler handler;
+
+  public SystemHandlerWrapper(android.os.Handler handler) {
+    this.handler = handler;
+  }
+
+  @Override
+  public Looper getLooper() {
+    return handler.getLooper();
+  }
+
+  @Override
+  public Message obtainMessage(int what) {
+    return handler.obtainMessage(what);
+  }
+
+  @Override
+  public Message obtainMessage(int what, Object obj) {
+    return handler.obtainMessage(what, obj);
+  }
+
+  @Override
+  public Message obtainMessage(int what, int arg1, int arg2) {
+    return handler.obtainMessage(what, arg1, arg2);
+  }
+
+  @Override
+  public Message obtainMessage(int what, int arg1, int arg2, Object obj) {
+    return handler.obtainMessage(what, arg1, arg2, obj);
+  }
+
+  @Override
+  public boolean sendEmptyMessage(int what) {
+    return handler.sendEmptyMessage(what);
+  }
+
+  @Override
+  public boolean sendEmptyMessageAtTime(int what, long uptimeMs) {
+    return handler.sendEmptyMessageAtTime(what, uptimeMs);
+  }
+
+  @Override
+  public void removeMessages(int what) {
+    handler.removeMessages(what);
+  }
+
+  @Override
+  public void removeCallbacksAndMessages(Object token) {
+    handler.removeCallbacksAndMessages(token);
+  }
+
+  @Override
+  public boolean post(Runnable runnable) {
+    return handler.post(runnable);
+  }
+
+  @Override
+  public boolean postDelayed(Runnable runnable, long delayMs) {
+    return handler.postDelayed(runnable, delayMs);
+  }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
index a79ed38755..e01dcc6f3a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java
@@ -34,6 +34,7 @@
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.upstream.DataSource;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
@@ -50,7 +51,9 @@
 import java.util.GregorianCalendar;
 import java.util.List;
 import java.util.Locale;
+import java.util.MissingResourceException;
 import java.util.TimeZone;
+import java.util.UUID;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
@@ -191,6 +194,17 @@ public static boolean contains(Object[] items, Object item) {
     return false;
   }
 
+  /**
+   * Removes an indexed range from a List.
+   *
+   * @param list The List to remove the range from.
+   * @param fromIndex The first index to be removed (inclusive).
+   * @param toIndex The last index to be removed (exclusive).
+   */
+  public static <T> void removeRange(List<T> list, int fromIndex, int toIndex) {
+    list.subList(fromIndex, toIndex).clear();
+  }
+
   /**
    * Instantiates a new single threaded executor whose thread has the specified name.
    *
@@ -238,13 +252,18 @@ public static void closeQuietly(Closeable closeable) {
   }
 
   /**
-   * Returns a normalized RFC 5646 language code.
+   * Returns a normalized RFC 639-2/T code for {@code language}.
    *
-   * @param language A possibly non-normalized RFC 5646 language code.
-   * @return The normalized code, or null if the input was null.
+   * @param language A case-insensitive ISO 639 alpha-2 or alpha-3 language code.
+   * @return The all-lowercase normalized code, or null if the input was null, or
+   *     {@code language.toLowerCase()} if the language could not be normalized.
    */
   public static String normalizeLanguageCode(String language) {
-    return language == null ? null : new Locale(language).getLanguage();
+    try {
+      return language == null ? null : new Locale(language).getISO3Language();
+    } catch (MissingResourceException e) {
+      return toLowerInvariant(language);
+    }
   }
 
   /**
@@ -287,6 +306,16 @@ public static String toLowerInvariant(String text) {
     return text == null ? null : text.toLowerCase(Locale.US);
   }
 
+  /**
+   * Converts text to upper case using {@link Locale#US}.
+   *
+   * @param text The text to convert.
+   * @return The upper case text, or null if {@code text} is null.
+   */
+  public static String toUpperInvariant(String text) {
+    return text == null ? null : text.toUpperCase(Locale.US);
+  }
+
   /**
    * Divides a {@code numerator} by a {@code denominator}, returning the ceiled result.
    *
@@ -345,6 +374,40 @@ public static float constrainValue(float value, float min, float max) {
     return Math.max(min, Math.min(value, max));
   }
 
+  /**
+   * Returns the sum of two arguments, or a third argument if the result overflows.
+   *
+   * @param x The first value.
+   * @param y The second value.
+   * @param overflowResult The return value if {@code x + y} overflows.
+   * @return {@code x + y}, or {@code overflowResult} if the result overflows.
+   */
+  public static long addWithOverflowDefault(long x, long y, long overflowResult) {
+    long result = x + y;
+    // See Hacker's Delight 2-13 (H. Warren Jr).
+    if (((x ^ result) & (y ^ result)) < 0) {
+      return overflowResult;
+    }
+    return result;
+  }
+
+  /**
+   * Returns the difference between two arguments, or a third argument if the result overflows.
+   *
+   * @param x The first value.
+   * @param y The second value.
+   * @param overflowResult The return value if {@code x - y} overflows.
+   * @return {@code x - y}, or {@code overflowResult} if the result overflows.
+   */
+  public static long subtractWithOverflowDefault(long x, long y, long overflowResult) {
+    long result = x - y;
+    // See Hacker's Delight 2-13 (H. Warren Jr).
+    if (((x ^ y) & (x ^ result)) < 0) {
+      return overflowResult;
+    }
+    return result;
+  }
+
   /**
    * Returns the index of the largest element in {@code array} that is less than (or optionally
    * equal to) a specified {@code value}.
@@ -409,39 +472,6 @@ public static int binarySearchFloor(long[] array, long value, boolean inclusive,
     return stayInBounds ? Math.max(0, index) : index;
   }
 
-  /**
-   * Returns the index of the smallest element in {@code array} that is greater than (or optionally
-   * equal to) a specified {@code value}.
-   * <p>
-   * The search is performed using a binary search algorithm, so the array must be sorted. If
-   * the array contains multiple elements equal to {@code value} and {@code inclusive} is true, the
-   * index of the last one will be returned.
-   *
-   * @param array The array to search.
-   * @param value The value being searched for.
-   * @param inclusive If the value is present in the array, whether to return the corresponding
-   *     index. If false then the returned index corresponds to the smallest element strictly
-   *     greater than the value.
-   * @param stayInBounds If true, then {@code (a.length - 1)} will be returned in the case that the
-   *     value is greater than the largest element in the array. If false then {@code a.length} will
-   *     be returned.
-   * @return The index of the smallest element in {@code array} that is greater than (or optionally
-   *     equal to) {@code value}.
-   */
-  public static int binarySearchCeil(long[] array, long value, boolean inclusive,
-      boolean stayInBounds) {
-    int index = Arrays.binarySearch(array, value);
-    if (index < 0) {
-      index = ~index;
-    } else {
-      while ((++index) < array.length && array[index] == value) {}
-      if (inclusive) {
-        index--;
-      }
-    }
-    return stayInBounds ? Math.min(array.length - 1, index) : index;
-  }
-
   /**
    * Returns the index of the largest element in {@code list} that is less than (or optionally equal
    * to) a specified {@code value}.
@@ -475,6 +505,39 @@ public static int binarySearchCeil(long[] array, long value, boolean inclusive,
     return stayInBounds ? Math.max(0, index) : index;
   }
 
+  /**
+   * Returns the index of the smallest element in {@code array} that is greater than (or optionally
+   * equal to) a specified {@code value}.
+   *
+   * <p>The search is performed using a binary search algorithm, so the array must be sorted. If the
+   * array contains multiple elements equal to {@code value} and {@code inclusive} is true, the
+   * index of the last one will be returned.
+   *
+   * @param array The array to search.
+   * @param value The value being searched for.
+   * @param inclusive If the value is present in the array, whether to return the corresponding
+   *     index. If false then the returned index corresponds to the smallest element strictly
+   *     greater than the value.
+   * @param stayInBounds If true, then {@code (a.length - 1)} will be returned in the case that the
+   *     value is greater than the largest element in the array. If false then {@code a.length} will
+   *     be returned.
+   * @return The index of the smallest element in {@code array} that is greater than (or optionally
+   *     equal to) {@code value}.
+   */
+  public static int binarySearchCeil(
+      long[] array, long value, boolean inclusive, boolean stayInBounds) {
+    int index = Arrays.binarySearch(array, value);
+    if (index < 0) {
+      index = ~index;
+    } else {
+      while ((++index) < array.length && array[index] == value) {}
+      if (inclusive) {
+        index--;
+      }
+    }
+    return stayInBounds ? Math.min(array.length - 1, index) : index;
+  }
+
   /**
    * Returns the index of the smallest element in {@code list} that is greater than (or optionally
    * equal to) a specified value.
@@ -510,6 +573,18 @@ public static int binarySearchCeil(long[] array, long value, boolean inclusive,
     return stayInBounds ? Math.min(list.size() - 1, index) : index;
   }
 
+  /**
+   * Compares two long values and returns the same value as {@code Long.compare(long, long)}.
+   *
+   * @param left The left operand.
+   * @param right The right operand.
+   * @return 0, if left == right, a negative value if left &lt; right, or a positive value if left
+   *     &gt; right.
+   */
+  public static int compareLong(long left, long right) {
+    return left < right ? -1 : left == right ? 0 : 1;
+  }
+
   /**
    * Parses an xs:duration attribute value, returning the parsed duration in milliseconds.
    *
@@ -672,6 +747,71 @@ public static void scaleLargeTimestampsInPlace(long[] timestamps, long multiplie
     }
   }
 
+  /**
+   * Returns the duration of media that will elapse in {@code playoutDuration}.
+   *
+   * @param playoutDuration The duration to scale.
+   * @param speed The playback speed.
+   * @return The scaled duration, in the same units as {@code playoutDuration}.
+   */
+  public static long getMediaDurationForPlayoutDuration(long playoutDuration, float speed) {
+    if (speed == 1f) {
+      return playoutDuration;
+    }
+    return Math.round((double) playoutDuration * speed);
+  }
+
+  /**
+   * Returns the playout duration of {@code mediaDuration} of media.
+   *
+   * @param mediaDuration The duration to scale.
+   * @return The scaled duration, in the same units as {@code mediaDuration}.
+   */
+  public static long getPlayoutDurationForMediaDuration(long mediaDuration, float speed) {
+    if (speed == 1f) {
+      return mediaDuration;
+    }
+    return Math.round((double) mediaDuration / speed);
+  }
+
+  /**
+   * Resolves a seek given the requested seek position, a {@link SeekParameters} and two candidate
+   * sync points.
+   *
+   * @param positionUs The requested seek position, in microseocnds.
+   * @param seekParameters The {@link SeekParameters}.
+   * @param firstSyncUs The first candidate seek point, in micrseconds.
+   * @param secondSyncUs The second candidate seek point, in microseconds. May equal {@code
+   *     firstSyncUs} if there's only one candidate.
+   * @return The resolved seek position, in microseconds.
+   */
+  public static long resolveSeekPositionUs(
+      long positionUs, SeekParameters seekParameters, long firstSyncUs, long secondSyncUs) {
+    if (SeekParameters.EXACT.equals(seekParameters)) {
+      return positionUs;
+    }
+    long minPositionUs =
+        subtractWithOverflowDefault(positionUs, seekParameters.toleranceBeforeUs, Long.MIN_VALUE);
+    long maxPositionUs =
+        addWithOverflowDefault(positionUs, seekParameters.toleranceAfterUs, Long.MAX_VALUE);
+    boolean firstSyncPositionValid = minPositionUs <= firstSyncUs && firstSyncUs <= maxPositionUs;
+    boolean secondSyncPositionValid =
+        minPositionUs <= secondSyncUs && secondSyncUs <= maxPositionUs;
+    if (firstSyncPositionValid && secondSyncPositionValid) {
+      if (Math.abs(firstSyncUs - positionUs) <= Math.abs(secondSyncUs - positionUs)) {
+        return firstSyncUs;
+      } else {
+        return secondSyncUs;
+      }
+    } else if (firstSyncPositionValid) {
+      return firstSyncUs;
+    } else if (secondSyncPositionValid) {
+      return secondSyncUs;
+    } else {
+      return minPositionUs;
+    }
+  }
+
   /**
    * Converts a list of integers to a primitive array.
    *
@@ -760,6 +900,32 @@ public static String getUserAgent(Context context, String applicationName) {
         + ") " + ExoPlayerLibraryInfo.VERSION_SLASHY;
   }
 
+  /**
+   * Returns a copy of {@code codecs} without the codecs whose track type doesn't match
+   * {@code trackType}.
+   *
+   * @param codecs A codec sequence string, as defined in RFC 6381.
+   * @param trackType One of {@link C}{@code .TRACK_TYPE_*}.
+   * @return A copy of {@code codecs} without the codecs whose track type doesn't match
+   *     {@code trackType}.
+   */
+  public static String getCodecsOfType(String codecs, int trackType) {
+    if (TextUtils.isEmpty(codecs)) {
+      return null;
+    }
+    String[] codecArray = codecs.trim().split("(\\s*,\\s*)");
+    StringBuilder builder = new StringBuilder();
+    for (String codec : codecArray) {
+      if (trackType == MimeTypes.getTrackTypeOfCodec(codec)) {
+        if (builder.length() > 0) {
+          builder.append(",");
+        }
+        builder.append(codec);
+      }
+    }
+    return builder.length() > 0 ? builder.toString() : null;
+  }
+
   /**
    * Converts a sample bit depth to a corresponding PCM encoding constant.
    *
@@ -785,6 +951,16 @@ public static int getPcmEncoding(int bitDepth) {
     }
   }
 
+  /**
+   * Returns whether {@code encoding} is high resolution (&gt; 16-bit) integer PCM.
+   *
+   * @param encoding The encoding of the audio data.
+   * @return Whether the encoding is high resolution integer PCM.
+   */
+  public static boolean isEncodingHighResolutionIntegerPcm(@C.PcmEncoding int encoding) {
+    return encoding == C.ENCODING_PCM_24BIT || encoding == C.ENCODING_PCM_32BIT;
+  }
+
   /**
    * Returns the frame size for audio with {@code channelCount} channels in the specified encoding.
    *
@@ -801,6 +977,7 @@ public static int getPcmFrameSize(@C.PcmEncoding int pcmEncoding, int channelCou
       case C.ENCODING_PCM_24BIT:
         return channelCount * 3;
       case C.ENCODING_PCM_32BIT:
+      case C.ENCODING_PCM_FLOAT:
         return channelCount * 4;
       case C.ENCODING_INVALID:
       case Format.NO_VALUE:
@@ -888,6 +1065,30 @@ public static int getStreamTypeForAudioUsage(@C.AudioUsage int usage) {
     }
   }
 
+  /**
+   * Derives a DRM {@link UUID} from {@code drmScheme}.
+   *
+   * @param drmScheme A UUID string, or {@code "widevine"}, {@code "playready"} or {@code
+   *     "clearkey"}.
+   * @return The derived {@link UUID}, or {@code null} if one could not be derived.
+   */
+  public static UUID getDrmUuid(String drmScheme) {
+    switch (Util.toLowerInvariant(drmScheme)) {
+      case "widevine":
+        return C.WIDEVINE_UUID;
+      case "playready":
+        return C.PLAYREADY_UUID;
+      case "clearkey":
+        return C.CLEARKEY_UUID;
+      default:
+        try {
+          return UUID.fromString(drmScheme);
+        } catch (RuntimeException e) {
+          return null;
+        }
+    }
+  }
+
   /**
    * Makes a best guess to infer the type from a {@link Uri}.
    *
@@ -1143,7 +1344,11 @@ public static Point getPhysicalDisplaySize(Context context, Display display) {
       if ("Sony".equals(Util.MANUFACTURER) && Util.MODEL.startsWith("BRAVIA")
           && context.getPackageManager().hasSystemFeature("com.sony.dtv.hardware.panel.qfhd")) {
         return new Point(3840, 2160);
-      } else if ("NVIDIA".equals(Util.MANUFACTURER) && Util.MODEL.contains("SHIELD")) {
+      } else if (("NVIDIA".equals(Util.MANUFACTURER) && Util.MODEL.contains("SHIELD"))
+          || ("philips".equals(Util.toLowerInvariant(Util.MANUFACTURER))
+              && (Util.MODEL.startsWith("QM1")
+                  || Util.MODEL.equals("QV151E")
+                  || Util.MODEL.equals("TPM171E")))) {
         // Attempt to read sys.display-size.
         String sysDisplaySize = null;
         try {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java b/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java
index 7bdc43f85c..14e40f8605 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/ColorInfo.java
@@ -91,12 +91,10 @@ public boolean equals(Object obj) {
       return false;
     }
     ColorInfo other = (ColorInfo) obj;
-    if (colorSpace != other.colorSpace || colorRange != other.colorRange
-        || colorTransfer != other.colorTransfer
-        || !Arrays.equals(hdrStaticInfo, other.hdrStaticInfo)) {
-      return false;
-    }
-    return true;
+    return colorSpace == other.colorSpace
+        && colorRange == other.colorRange
+        && colorTransfer == other.colorTransfer
+        && Arrays.equals(hdrStaticInfo, other.hdrStaticInfo);
   }
 
   @Override
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java b/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
index 2d7a9dfd33..fc31a33097 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java
@@ -15,33 +15,6 @@
  */
 package com.google.android.exoplayer2.video;
 
-import static android.opengl.EGL14.EGL_ALPHA_SIZE;
-import static android.opengl.EGL14.EGL_BLUE_SIZE;
-import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
-import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
-import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
-import static android.opengl.EGL14.EGL_DEPTH_SIZE;
-import static android.opengl.EGL14.EGL_GREEN_SIZE;
-import static android.opengl.EGL14.EGL_HEIGHT;
-import static android.opengl.EGL14.EGL_NONE;
-import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
-import static android.opengl.EGL14.EGL_RED_SIZE;
-import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
-import static android.opengl.EGL14.EGL_SURFACE_TYPE;
-import static android.opengl.EGL14.EGL_TRUE;
-import static android.opengl.EGL14.EGL_WIDTH;
-import static android.opengl.EGL14.EGL_WINDOW_BIT;
-import static android.opengl.EGL14.eglChooseConfig;
-import static android.opengl.EGL14.eglCreateContext;
-import static android.opengl.EGL14.eglCreatePbufferSurface;
-import static android.opengl.EGL14.eglDestroyContext;
-import static android.opengl.EGL14.eglDestroySurface;
-import static android.opengl.EGL14.eglGetDisplay;
-import static android.opengl.EGL14.eglInitialize;
-import static android.opengl.EGL14.eglMakeCurrent;
-import static android.opengl.GLES20.glDeleteTextures;
-import static android.opengl.GLES20.glGenTextures;
-
 import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.pm.PackageManager;
@@ -52,14 +25,18 @@
 import android.opengl.EGLContext;
 import android.opengl.EGLDisplay;
 import android.opengl.EGLSurface;
+import android.opengl.GLES20;
 import android.os.Handler;
 import android.os.Handler.Callback;
 import android.os.HandlerThread;
 import android.os.Message;
+import android.support.annotation.IntDef;
 import android.util.Log;
 import android.view.Surface;
 import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.Util;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import javax.microedition.khronos.egl.EGL10;
 
 /**
@@ -70,16 +47,27 @@
 
   private static final String TAG = "DummySurface";
 
+  private static final String EXTENSION_PROTECTED_CONTENT = "EGL_EXT_protected_content";
+  private static final String EXTENSION_SURFACELESS_CONTEXT = "EGL_KHR_surfaceless_context";
+
   private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;
 
-  private static boolean secureSupported;
-  private static boolean secureSupportedInitialized;
+  @Retention(RetentionPolicy.SOURCE)
+  @IntDef({SECURE_MODE_NONE, SECURE_MODE_SURFACELESS_CONTEXT, SECURE_MODE_PROTECTED_PBUFFER})
+  private @interface SecureMode {}
+
+  private static final int SECURE_MODE_NONE = 0;
+  private static final int SECURE_MODE_SURFACELESS_CONTEXT = 1;
+  private static final int SECURE_MODE_PROTECTED_PBUFFER = 2;
 
   /**
    * Whether the surface is secure.
    */
   public final boolean secure;
 
+  private static @SecureMode int secureMode;
+  private static boolean secureModeInitialized;
+
   private final DummySurfaceThread thread;
   private boolean threadReleased;
 
@@ -90,11 +78,11 @@
    * @return Whether the device supports secure dummy surfaces.
    */
   public static synchronized boolean isSecureSupported(Context context) {
-    if (!secureSupportedInitialized) {
-      secureSupported = Util.SDK_INT >= 24 && enableSecureDummySurfaceV24(context);
-      secureSupportedInitialized = true;
+    if (!secureModeInitialized) {
+      secureMode = Util.SDK_INT < 24 ? SECURE_MODE_NONE : getSecureModeV24(context);
+      secureModeInitialized = true;
     }
-    return secureSupported;
+    return secureMode != SECURE_MODE_NONE;
   }
 
   /**
@@ -113,7 +101,7 @@ public static DummySurface newInstanceV17(Context context, boolean secure) {
     assertApiLevel17OrHigher();
     Assertions.checkState(!secure || isSecureSupported(context));
     DummySurfaceThread thread = new DummySurfaceThread();
-    return thread.init(secure);
+    return thread.init(secure ? secureMode : SECURE_MODE_NONE);
   }
 
   private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
@@ -143,30 +131,34 @@ private static void assertApiLevel17OrHigher() {
     }
   }
 
-  /**
-   * Returns whether use of secure dummy surfaces should be enabled.
-   *
-   * @param context Any {@link Context}.
-   */
   @TargetApi(24)
-  private static boolean enableSecureDummySurfaceV24(Context context) {
-    if (Util.SDK_INT < 26 && "samsung".equals(Util.MANUFACTURER)) {
+  private static @SecureMode int getSecureModeV24(Context context) {
+    if (Util.SDK_INT < 26 && ("samsung".equals(Util.MANUFACTURER) || "XT1650".equals(Util.MODEL))) {
       // Samsung devices running Nougat are known to be broken. See
       // https://github.com/google/ExoPlayer/issues/3373 and [Internal: b/37197802].
-      return false;
+      // Moto Z XT1650 is also affected. See
+      // https://github.com/google/ExoPlayer/issues/3215.
+      return SECURE_MODE_NONE;
     }
     if (Util.SDK_INT < 26 && !context.getPackageManager().hasSystemFeature(
         PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE)) {
       // Pre API level 26 devices were not well tested unless they supported VR mode.
-      return false;
+      return SECURE_MODE_NONE;
     }
-    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    EGLDisplay display = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);
     String eglExtensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
-    if (eglExtensions == null || !eglExtensions.contains("EGL_EXT_protected_content")) {
-      // EGL_EXT_protected_content is required to enable secure dummy surfaces.
-      return false;
+    if (eglExtensions == null) {
+      return SECURE_MODE_NONE;
     }
-    return true;
+    if (!eglExtensions.contains(EXTENSION_PROTECTED_CONTENT)) {
+      return SECURE_MODE_NONE;
+    }
+    // If we can't use surfaceless contexts, we use a protected 1 * 1 pixel buffer surface. This may
+    // require support for EXT_protected_surface, but in practice it works on some devices that
+    // don't have that extension. See also https://github.com/google/ExoPlayer/issues/3558.
+    return eglExtensions.contains(EXTENSION_SURFACELESS_CONTEXT)
+        ? SECURE_MODE_SURFACELESS_CONTEXT
+        : SECURE_MODE_PROTECTED_PBUFFER;
   }
 
   private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
@@ -192,12 +184,12 @@ public DummySurfaceThread() {
       textureIdHolder = new int[1];
     }
 
-    public DummySurface init(boolean secure) {
+    public DummySurface init(@SecureMode int secureMode) {
       start();
       handler = new Handler(getLooper(), this);
       boolean wasInterrupted = false;
       synchronized (this) {
-        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
+        handler.obtainMessage(MSG_INIT, secureMode, 0).sendToTarget();
         while (surface == null && initException == null && initError == null) {
           try {
             wait();
@@ -233,7 +225,7 @@ public boolean handleMessage(Message msg) {
       switch (msg.what) {
         case MSG_INIT:
           try {
-            initInternal(msg.arg1 != 0);
+            initInternal(/* secureMode= */ msg.arg1);
           } catch (RuntimeException e) {
             Log.e(TAG, "Failed to initialize dummy surface", e);
             initException = e;
@@ -263,85 +255,97 @@ public boolean handleMessage(Message msg) {
       }
     }
 
-    private void initInternal(boolean secure) {
-      display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    private void initInternal(@SecureMode int secureMode) {
+      display = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);
       Assertions.checkState(display != null, "eglGetDisplay failed");
 
       int[] version = new int[2];
-      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
+      boolean eglInitialized = EGL14.eglInitialize(display, version, 0, version, 1);
       Assertions.checkState(eglInitialized, "eglInitialize failed");
 
-      int[] eglAttributes = new int[] {
-          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
-          EGL_RED_SIZE, 8,
-          EGL_GREEN_SIZE, 8,
-          EGL_BLUE_SIZE, 8,
-          EGL_ALPHA_SIZE, 8,
-          EGL_DEPTH_SIZE, 0,
-          EGL_CONFIG_CAVEAT, EGL_NONE,
-          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
-          EGL_NONE
-      };
+      int[] eglAttributes =
+          new int[] {
+            EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,
+            EGL14.EGL_RED_SIZE, 8,
+            EGL14.EGL_GREEN_SIZE, 8,
+            EGL14.EGL_BLUE_SIZE, 8,
+            EGL14.EGL_ALPHA_SIZE, 8,
+            EGL14.EGL_DEPTH_SIZE, 0,
+            EGL14.EGL_CONFIG_CAVEAT, EGL14.EGL_NONE,
+            EGL14.EGL_SURFACE_TYPE, EGL14.EGL_WINDOW_BIT,
+            EGL14.EGL_NONE
+          };
       EGLConfig[] configs = new EGLConfig[1];
       int[] numConfigs = new int[1];
-      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
-          numConfigs, 0);
+      boolean eglChooseConfigSuccess =
+          EGL14.eglChooseConfig(display, eglAttributes, 0, configs, 0, 1, numConfigs, 0);
       Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
           "eglChooseConfig failed");
 
       EGLConfig config = configs[0];
       int[] glAttributes;
-      if (secure) {
-        glAttributes = new int[] {
-            EGL_CONTEXT_CLIENT_VERSION, 2,
-            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
-            EGL_NONE};
+      if (secureMode == SECURE_MODE_NONE) {
+        glAttributes = new int[] {EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL14.EGL_NONE};
       } else {
-        glAttributes = new int[] {
-            EGL_CONTEXT_CLIENT_VERSION, 2,
-            EGL_NONE};
+        glAttributes =
+            new int[] {
+              EGL14.EGL_CONTEXT_CLIENT_VERSION,
+              2,
+              EGL_PROTECTED_CONTENT_EXT,
+              EGL14.EGL_TRUE,
+              EGL14.EGL_NONE
+            };
       }
-      context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT, glAttributes,
-          0);
+      context =
+          EGL14.eglCreateContext(
+              display, config, android.opengl.EGL14.EGL_NO_CONTEXT, glAttributes, 0);
       Assertions.checkState(context != null, "eglCreateContext failed");
 
-      int[] pbufferAttributes;
-      if (secure) {
-        pbufferAttributes = new int[] {
-            EGL_WIDTH, 1,
-            EGL_HEIGHT, 1,
-            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
-            EGL_NONE};
+      EGLSurface surface;
+      if (secureMode == SECURE_MODE_SURFACELESS_CONTEXT) {
+        surface = EGL14.EGL_NO_SURFACE;
       } else {
-        pbufferAttributes = new int[] {
-            EGL_WIDTH, 1,
-            EGL_HEIGHT, 1,
-            EGL_NONE};
+        int[] pbufferAttributes;
+        if (secureMode == SECURE_MODE_PROTECTED_PBUFFER) {
+          pbufferAttributes =
+              new int[] {
+                EGL14.EGL_WIDTH,
+                1,
+                EGL14.EGL_HEIGHT,
+                1,
+                EGL_PROTECTED_CONTENT_EXT,
+                EGL14.EGL_TRUE,
+                EGL14.EGL_NONE
+              };
+        } else {
+          pbufferAttributes = new int[] {EGL14.EGL_WIDTH, 1, EGL14.EGL_HEIGHT, 1, EGL14.EGL_NONE};
+        }
+        pbuffer = EGL14.eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
+        Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");
+        surface = pbuffer;
       }
-      pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
-      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");
 
-      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
+      boolean eglMadeCurrent = EGL14.eglMakeCurrent(display, surface, surface, context);
       Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");
 
-      glGenTextures(1, textureIdHolder, 0);
+      GLES20.glGenTextures(1, textureIdHolder, 0);
       surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
       surfaceTexture.setOnFrameAvailableListener(this);
-      surface = new DummySurface(this, surfaceTexture, secure);
+      this.surface = new DummySurface(this, surfaceTexture, secureMode != SECURE_MODE_NONE);
     }
 
     private void releaseInternal() {
       try {
         if (surfaceTexture != null) {
           surfaceTexture.release();
-          glDeleteTextures(1, textureIdHolder, 0);
+          GLES20.glDeleteTextures(1, textureIdHolder, 0);
         }
       } finally {
         if (pbuffer != null) {
-          eglDestroySurface(display, pbuffer);
+          EGL14.eglDestroySurface(display, pbuffer);
         }
         if (context != null) {
-          eglDestroyContext(display, context);
+          EGL14.eglDestroyContext(display, context);
         }
         pbuffer = null;
         context = null;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index 41e3c970c4..1519bfdd2b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -32,7 +32,9 @@
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmSessionManager;
@@ -51,6 +53,18 @@
 
 /**
  * Decodes and renders video using {@link MediaCodec}.
+ *
+ * <p>This renderer accepts the following messages sent via {@link ExoPlayer#createMessage(Target)}
+ * on the playback thread:
+ *
+ * <ul>
+ *   <li>Message with type {@link C#MSG_SET_SURFACE} to set the output surface. The message payload
+ *       should be the target {@link Surface}, or null.
+ *   <li>Message with type {@link C#MSG_SET_SCALING_MODE} to set the video scaling mode. The message
+ *       payload should be one of the integer scaling modes in {@link C.VideoScalingMode}. Note that
+ *       the scaling mode only applies if the {@link Surface} targeted by this renderer is owned by
+ *       a {@link android.view.SurfaceView}.
+ * </ul>
  */
 @TargetApi(16)
 public class MediaCodecVideoRenderer extends MediaCodecRenderer {
@@ -86,12 +100,12 @@
   @C.VideoScalingMode
   private int scalingMode;
   private boolean renderedFirstFrame;
-  private boolean forceRenderFrame;
   private long joiningDeadlineMs;
   private long droppedFrameAccumulationStartTimeMs;
   private int droppedFrames;
   private int consecutiveDroppedFrameCount;
   private int buffersInCodecCount;
+  private long lastRenderTimeUs;
 
   private int pendingRotationDegrees;
   private float pendingPixelWidthHeightRatio;
@@ -300,6 +314,7 @@ protected void onStarted() {
     super.onStarted();
     droppedFrames = 0;
     droppedFrameAccumulationStartTimeMs = SystemClock.elapsedRealtime();
+    lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
   }
 
   @Override
@@ -352,7 +367,7 @@ private void setSurface(Surface surface) throws ExoPlaybackException {
         surface = dummySurface;
       } else {
         MediaCodecInfo codecInfo = getCodecInfo();
-        if (codecInfo != null && shouldUseDummySurface(codecInfo.secure)) {
+        if (codecInfo != null && shouldUseDummySurface(codecInfo)) {
           dummySurface = DummySurface.newInstanceV17(context, codecInfo.secure);
           surface = dummySurface;
         }
@@ -395,7 +410,7 @@ private void setSurface(Surface surface) throws ExoPlaybackException {
 
   @Override
   protected boolean shouldInitCodec(MediaCodecInfo codecInfo) {
-    return surface != null || shouldUseDummySurface(codecInfo.secure);
+    return surface != null || shouldUseDummySurface(codecInfo);
   }
 
   @Override
@@ -405,7 +420,7 @@ protected void configureCodec(MediaCodecInfo codecInfo, MediaCodec codec, Format
     MediaFormat mediaFormat = getMediaFormat(format, codecMaxValues, deviceNeedsAutoFrcWorkaround,
         tunnelingAudioSessionId);
     if (surface == null) {
-      Assertions.checkState(shouldUseDummySurface(codecInfo.secure));
+      Assertions.checkState(shouldUseDummySurface(codecInfo));
       if (dummySurface == null) {
         dummySurface = DummySurface.newInstanceV17(context, codecInfo.secure);
       }
@@ -424,7 +439,6 @@ protected void releaseCodec() {
       super.releaseCodec();
     } finally {
       buffersInCodecCount = 0;
-      forceRenderFrame = false;
       if (dummySurface != null) {
         if (surface == dummySurface) {
           surface = null;
@@ -440,7 +454,6 @@ protected void releaseCodec() {
   protected void flushCodec() throws ExoPlaybackException {
     super.flushCodec();
     buffersInCodecCount = 0;
-    forceRenderFrame = false;
   }
 
   @Override
@@ -532,15 +545,17 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
     if (surface == dummySurface) {
       // Skip frames in sync with playback, so we'll be at the right frame if the mode changes.
       if (isBufferLate(earlyUs)) {
-        forceRenderFrame = false;
         skipOutputBuffer(codec, bufferIndex, presentationTimeUs);
         return true;
       }
       return false;
     }
 
-    if (!renderedFirstFrame || forceRenderFrame) {
-      forceRenderFrame = false;
+    long elapsedRealtimeNowUs = SystemClock.elapsedRealtime() * 1000;
+    boolean isStarted = getState() == STATE_STARTED;
+    if (!renderedFirstFrame
+        || (isStarted
+            && shouldForceRenderOutputBuffer(earlyUs, elapsedRealtimeNowUs - lastRenderTimeUs))) {
       if (Util.SDK_INT >= 21) {
         renderOutputBufferV21(codec, bufferIndex, presentationTimeUs, System.nanoTime());
       } else {
@@ -549,13 +564,13 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
       return true;
     }
 
-    if (getState() != STATE_STARTED) {
+    if (!isStarted) {
       return false;
     }
 
     // Fine-grained adjustment of earlyUs based on the elapsed time since the start of the current
     // iteration of the rendering loop.
-    long elapsedSinceStartOfLoopUs = (SystemClock.elapsedRealtime() * 1000) - elapsedRealtimeUs;
+    long elapsedSinceStartOfLoopUs = elapsedRealtimeNowUs - elapsedRealtimeUs;
     earlyUs -= elapsedSinceStartOfLoopUs;
 
     // Compute the buffer's desired release time in nanoseconds.
@@ -569,7 +584,6 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
 
     if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs)
         && maybeDropBuffersToKeyframe(codec, bufferIndex, presentationTimeUs, positionUs)) {
-      forceRenderFrame = true;
       return false;
     } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs)) {
       dropOutputBuffer(codec, bufferIndex, presentationTimeUs);
@@ -593,6 +607,7 @@ protected boolean processOutputBuffer(long positionUs, long elapsedRealtimeUs, M
             Thread.sleep((earlyUs - 10000) / 1000);
           } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
+            return false;
           }
         }
         renderOutputBuffer(codec, bufferIndex, presentationTimeUs);
@@ -640,6 +655,19 @@ protected boolean shouldDropBuffersToKeyframe(long earlyUs, long elapsedRealtime
     return isBufferVeryLate(earlyUs);
   }
 
+  /**
+   * Returns whether to force rendering an output buffer.
+   *
+   * @param earlyUs The time until the current buffer should be presented in microseconds. A
+   *     negative value indicates that the buffer is late.
+   * @param elapsedSinceLastRenderUs The elapsed time since the last output buffer was rendered, in
+   *     microseconds.
+   * @return Returns whether to force rendering an output buffer.
+   */
+  protected boolean shouldForceRenderOutputBuffer(long earlyUs, long elapsedSinceLastRenderUs) {
+    return isBufferLate(earlyUs) && elapsedSinceLastRenderUs > 100000;
+  }
+
   /**
    * Skips the output buffer with the specified index.
    *
@@ -724,6 +752,7 @@ protected void renderOutputBuffer(MediaCodec codec, int index, long presentation
     TraceUtil.beginSection("releaseOutputBuffer");
     codec.releaseOutputBuffer(index, true);
     TraceUtil.endSection();
+    lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
     maybeNotifyRenderedFirstFrame();
@@ -739,20 +768,23 @@ protected void renderOutputBuffer(MediaCodec codec, int index, long presentation
    * @param releaseTimeNs The wallclock time at which the frame should be displayed, in nanoseconds.
    */
   @TargetApi(21)
-  protected void renderOutputBufferV21(MediaCodec codec, int index, long presentationTimeUs,
-      long releaseTimeNs) {
+  protected void renderOutputBufferV21(
+      MediaCodec codec, int index, long presentationTimeUs, long releaseTimeNs) {
     maybeNotifyVideoSizeChanged();
     TraceUtil.beginSection("releaseOutputBuffer");
     codec.releaseOutputBuffer(index, releaseTimeNs);
     TraceUtil.endSection();
+    lastRenderTimeUs = SystemClock.elapsedRealtime() * 1000;
     decoderCounters.renderedOutputBufferCount++;
     consecutiveDroppedFrameCount = 0;
     maybeNotifyRenderedFirstFrame();
   }
 
-  private boolean shouldUseDummySurface(boolean codecIsSecure) {
-    return Util.SDK_INT >= 23 && !tunneling
-        && (!codecIsSecure || DummySurface.isSecureSupported(context));
+  private boolean shouldUseDummySurface(MediaCodecInfo codecInfo) {
+    return Util.SDK_INT >= 23
+        && !tunneling
+        && !codecNeedsSetOutputSurfaceWorkaround(codecInfo.name)
+        && (!codecInfo.secure || DummySurface.isSecureSupported(context));
   }
 
   private void setJoiningDeadlineMs() {
@@ -906,19 +938,15 @@ protected CodecMaxValues getCodecMaxValues(MediaCodecInfo codecInfo, Format form
   @SuppressLint("InlinedApi")
   protected MediaFormat getMediaFormat(Format format, CodecMaxValues codecMaxValues,
       boolean deviceNeedsAutoFrcWorkaround, int tunnelingAudioSessionId) {
-    MediaFormat frameworkMediaFormat = format.getFrameworkMediaFormatV16();
-    // Set the maximum adaptive video dimensions.
+    MediaFormat frameworkMediaFormat = getMediaFormatForPlayback(format);
     frameworkMediaFormat.setInteger(MediaFormat.KEY_MAX_WIDTH, codecMaxValues.width);
     frameworkMediaFormat.setInteger(MediaFormat.KEY_MAX_HEIGHT, codecMaxValues.height);
-    // Set the maximum input size.
     if (codecMaxValues.inputSize != Format.NO_VALUE) {
       frameworkMediaFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, codecMaxValues.inputSize);
     }
-    // Set FRC workaround.
     if (deviceNeedsAutoFrcWorkaround) {
       frameworkMediaFormat.setInteger("auto-frc", 0);
     }
-    // Configure tunneling if enabled.
     if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {
       configureTunnelingV21(frameworkMediaFormat, tunnelingAudioSessionId);
     }
@@ -1072,13 +1100,27 @@ private static boolean deviceNeedsAutoFrcWorkaround() {
    */
   private static boolean codecNeedsSetOutputSurfaceWorkaround(String name) {
     // Work around https://github.com/google/ExoPlayer/issues/3236,
-    // https://github.com/google/ExoPlayer/issues/3355 and
-    // https://github.com/google/ExoPlayer/issues/3439.
-    return (("deb".equals(Util.DEVICE) || "flo".equals(Util.DEVICE))
-        && "OMX.qcom.video.decoder.avc".equals(name))
-        || (("tcl_eu".equals(Util.DEVICE) || "SVP-DTV15".equals(Util.DEVICE)
-        || "BRAVIA_ATV2".equals(Util.DEVICE))
-        && "OMX.MTK.VIDEO.DECODER.AVC".equals(name));
+    // https://github.com/google/ExoPlayer/issues/3355,
+    // https://github.com/google/ExoPlayer/issues/3439,
+    // https://github.com/google/ExoPlayer/issues/3724,
+    // https://github.com/google/ExoPlayer/issues/3835 and
+    // https://github.com/google/ExoPlayer/issues/4006.
+    return (("deb".equals(Util.DEVICE) // Nexus 7 (2013)
+                || "flo".equals(Util.DEVICE) // Nexus 7 (2013)
+                || "mido".equals(Util.DEVICE) // Redmi Note 4
+                || "santoni".equals(Util.DEVICE)) // Redmi 4X
+            && "OMX.qcom.video.decoder.avc".equals(name))
+        || (("tcl_eu".equals(Util.DEVICE) // TCL Percee TV
+                || "SVP-DTV15".equals(Util.DEVICE) // Sony Bravia 4K 2015
+                || "BRAVIA_ATV2".equals(Util.DEVICE) // Sony Bravia 4K GB
+                || Util.DEVICE.startsWith("panell_") // Motorola Moto C Plus
+                || "F3311".equals(Util.DEVICE) // Sony Xperia E5
+                || "M5c".equals(Util.DEVICE) // Meizu M5C
+                || "A7010a48".equals(Util.DEVICE)) // Lenovo K4 Note
+            && "OMX.MTK.VIDEO.DECODER.AVC".equals(name))
+        || (("ALE-L21".equals(Util.MODEL) // Huawei P8 Lite
+                || "CAM-L21".equals(Util.MODEL)) // Huawei Y6II
+            && "OMX.k3.video.decoder.avc".equals(name));
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/VideoListener.java b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoListener.java
new file mode 100644
index 0000000000..ab09e0bbc2
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/VideoListener.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.video;
+
+/** A listener for metadata corresponding to video being rendered. */
+public interface VideoListener {
+
+  /**
+   * Called each time there's a change in the size of the video being rendered.
+   *
+   * @param width The video width in pixels.
+   * @param height The video height in pixels.
+   * @param unappliedRotationDegrees For videos that require a rotation, this is the clockwise
+   *     rotation in degrees that the application should apply for the video for it to be rendered
+   *     in the correct orientation. This value will always be zero on API levels 21 and above,
+   *     since the renderer will apply all necessary rotations internally. On earlier API levels
+   *     this is not possible. Applications that use {@link android.view.TextureView} can apply the
+   *     rotation by calling {@link android.view.TextureView#setTransform}. Applications that do not
+   *     expect to encounter rotated videos can safely ignore this parameter.
+   * @param pixelWidthHeightRatio The width to height ratio of each pixel. For the normal case of
+   *     square pixels this will be equal to 1.0. Different values are indicative of anamorphic
+   *     content.
+   */
+  void onVideoSizeChanged(
+      int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio);
+
+  /**
+   * Called when a frame is rendered for the first time since setting the surface, and when a frame
+   * is rendered for the first time since a video track was selected.
+   */
+  void onRenderedFirstFrame();
+}
diff --git a/library/core/src/test/AndroidManifest.xml b/library/core/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..660c33c636
--- /dev/null
+++ b/library/core/src/test/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.android.exoplayer2.core.test">
+
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
+
+</manifest>
diff --git a/library/core/src/test/assets/binary/1024_incrementing_bytes.mp3 b/library/core/src/test/assets/binary/1024_incrementing_bytes.mp3
new file mode 100644
index 0000000000..c8b49c8cd5
Binary files /dev/null and b/library/core/src/test/assets/binary/1024_incrementing_bytes.mp3 differ
diff --git a/library/core/src/androidTest/assets/flv/sample.flv b/library/core/src/test/assets/flv/sample.flv
similarity index 100%
rename from library/core/src/androidTest/assets/flv/sample.flv
rename to library/core/src/test/assets/flv/sample.flv
diff --git a/library/core/src/androidTest/assets/flv/sample.flv.0.dump b/library/core/src/test/assets/flv/sample.flv.0.dump
similarity index 98%
rename from library/core/src/androidTest/assets/flv/sample.flv.0.dump
rename to library/core/src/test/assets/flv/sample.flv.0.dump
index b4129ecb88..f4502749f5 100644
--- a/library/core/src/androidTest/assets/flv/sample.flv.0.dump
+++ b/library/core/src/test/assets/flv/sample.flv.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = 1136000
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 2
 track 8:
   format:
@@ -26,6 +26,7 @@ track 8:
     drmInitData = -
     initializationData:
       data = length 2, hash 5F7
+  total output bytes = 9529
   sample count = 45
   sample 0:
     time = 112000
@@ -231,6 +232,7 @@ track 9:
     initializationData:
       data = length 30, hash F6F3D010
       data = length 10, hash 7A0D0F2B
+  total output bytes = 89502
   sample count = 30
   sample 0:
     time = 67000
diff --git a/library/core/src/androidTest/assets/mkv/sample.mkv b/library/core/src/test/assets/mkv/sample.mkv
similarity index 100%
rename from library/core/src/androidTest/assets/mkv/sample.mkv
rename to library/core/src/test/assets/mkv/sample.mkv
diff --git a/library/core/src/androidTest/assets/mkv/sample.mkv.0.dump b/library/core/src/test/assets/mkv/sample.mkv.0.dump
similarity index 98%
rename from library/core/src/androidTest/assets/mkv/sample.mkv.0.dump
rename to library/core/src/test/assets/mkv/sample.mkv.0.dump
index 34bad9b82a..009ff55c23 100644
--- a/library/core/src/androidTest/assets/mkv/sample.mkv.0.dump
+++ b/library/core/src/test/assets/mkv/sample.mkv.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1072000
-  getPosition(0) = 5576
+  getPosition(0) = [[timeUs=67000, position=5576]]
 numberOfTracks = 2
 track 1:
   format:
@@ -27,6 +27,7 @@ track 1:
     initializationData:
       data = length 30, hash F6F3D010
       data = length 10, hash 7A0D0F2B
+  total output bytes = 89502
   sample count = 30
   sample 0:
     time = 67000
@@ -170,6 +171,7 @@ track 2:
     language = und
     drmInitData = -
     initializationData:
+  total output bytes = 12120
   sample count = 29
   sample 0:
     time = 129000
diff --git a/library/core/src/androidTest/assets/mkv/sample.mkv.1.dump b/library/core/src/test/assets/mkv/sample.mkv.1.dump
similarity index 97%
rename from library/core/src/androidTest/assets/mkv/sample.mkv.1.dump
rename to library/core/src/test/assets/mkv/sample.mkv.1.dump
index 546c934eff..91396e81b8 100644
--- a/library/core/src/androidTest/assets/mkv/sample.mkv.1.dump
+++ b/library/core/src/test/assets/mkv/sample.mkv.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1072000
-  getPosition(0) = 5576
+  getPosition(0) = [[timeUs=67000, position=5576]]
 numberOfTracks = 2
 track 1:
   format:
@@ -27,6 +27,7 @@ track 1:
     initializationData:
       data = length 30, hash F6F3D010
       data = length 10, hash 7A0D0F2B
+  total output bytes = 30995
   sample count = 22
   sample 0:
     time = 334000
@@ -138,6 +139,7 @@ track 2:
     language = und
     drmInitData = -
     initializationData:
+  total output bytes = 8778
   sample count = 21
   sample 0:
     time = 408000
diff --git a/library/core/src/androidTest/assets/mkv/sample.mkv.2.dump b/library/core/src/test/assets/mkv/sample.mkv.2.dump
similarity index 96%
rename from library/core/src/androidTest/assets/mkv/sample.mkv.2.dump
rename to library/core/src/test/assets/mkv/sample.mkv.2.dump
index ec84908172..5c56dcc8af 100644
--- a/library/core/src/androidTest/assets/mkv/sample.mkv.2.dump
+++ b/library/core/src/test/assets/mkv/sample.mkv.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1072000
-  getPosition(0) = 5576
+  getPosition(0) = [[timeUs=67000, position=5576]]
 numberOfTracks = 2
 track 1:
   format:
@@ -27,6 +27,7 @@ track 1:
     initializationData:
       data = length 30, hash F6F3D010
       data = length 10, hash 7A0D0F2B
+  total output bytes = 10158
   sample count = 11
   sample 0:
     time = 700000
@@ -94,6 +95,7 @@ track 2:
     language = und
     drmInitData = -
     initializationData:
+  total output bytes = 4180
   sample count = 10
   sample 0:
     time = 791000
diff --git a/library/core/src/androidTest/assets/mkv/sample.mkv.3.dump b/library/core/src/test/assets/mkv/sample.mkv.3.dump
similarity index 93%
rename from library/core/src/androidTest/assets/mkv/sample.mkv.3.dump
rename to library/core/src/test/assets/mkv/sample.mkv.3.dump
index ac8d9a2c1c..cf5a0199fc 100644
--- a/library/core/src/androidTest/assets/mkv/sample.mkv.3.dump
+++ b/library/core/src/test/assets/mkv/sample.mkv.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1072000
-  getPosition(0) = 5576
+  getPosition(0) = [[timeUs=67000, position=5576]]
 numberOfTracks = 2
 track 1:
   format:
@@ -27,6 +27,7 @@ track 1:
     initializationData:
       data = length 30, hash F6F3D010
       data = length 10, hash 7A0D0F2B
+  total output bytes = 0
   sample count = 0
 track 2:
   format:
@@ -50,6 +51,7 @@ track 2:
     language = und
     drmInitData = -
     initializationData:
+  total output bytes = 1254
   sample count = 3
   sample 0:
     time = 1035000
diff --git a/library/core/src/androidTest/assets/mkv/subsample_encrypted_altref.webm b/library/core/src/test/assets/mkv/subsample_encrypted_altref.webm
similarity index 100%
rename from library/core/src/androidTest/assets/mkv/subsample_encrypted_altref.webm
rename to library/core/src/test/assets/mkv/subsample_encrypted_altref.webm
diff --git a/library/core/src/androidTest/assets/mkv/subsample_encrypted_altref.webm.0.dump b/library/core/src/test/assets/mkv/subsample_encrypted_altref.webm.0.dump
similarity index 91%
rename from library/core/src/androidTest/assets/mkv/subsample_encrypted_altref.webm.0.dump
rename to library/core/src/test/assets/mkv/subsample_encrypted_altref.webm.0.dump
index f533e14c3f..62a270eb9e 100644
--- a/library/core/src/androidTest/assets/mkv/subsample_encrypted_altref.webm.0.dump
+++ b/library/core/src/test/assets/mkv/subsample_encrypted_altref.webm.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = 1000
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 1:
   format:
@@ -25,6 +25,7 @@ track 1:
     language = null
     drmInitData = 1305012705
     initializationData:
+  total output bytes = 39
   sample count = 1
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/mkv/subsample_encrypted_noaltref.webm b/library/core/src/test/assets/mkv/subsample_encrypted_noaltref.webm
similarity index 100%
rename from library/core/src/androidTest/assets/mkv/subsample_encrypted_noaltref.webm
rename to library/core/src/test/assets/mkv/subsample_encrypted_noaltref.webm
diff --git a/library/core/src/androidTest/assets/mkv/subsample_encrypted_noaltref.webm.0.dump b/library/core/src/test/assets/mkv/subsample_encrypted_noaltref.webm.0.dump
similarity index 91%
rename from library/core/src/androidTest/assets/mkv/subsample_encrypted_noaltref.webm.0.dump
rename to library/core/src/test/assets/mkv/subsample_encrypted_noaltref.webm.0.dump
index d84c549dea..43e5eed5d1 100644
--- a/library/core/src/androidTest/assets/mkv/subsample_encrypted_noaltref.webm.0.dump
+++ b/library/core/src/test/assets/mkv/subsample_encrypted_noaltref.webm.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = 1000
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 1:
   format:
@@ -25,6 +25,7 @@ track 1:
     language = null
     drmInitData = 1305012705
     initializationData:
+  total output bytes = 24
   sample count = 1
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/mp3/bear.mp3 b/library/core/src/test/assets/mp3/bear.mp3
similarity index 100%
rename from library/core/src/androidTest/assets/mp3/bear.mp3
rename to library/core/src/test/assets/mp3/bear.mp3
diff --git a/library/core/src/androidTest/assets/mp3/bear.mp3.0.dump b/library/core/src/test/assets/mp3/bear.mp3.0.dump
similarity index 99%
rename from library/core/src/androidTest/assets/mp3/bear.mp3.0.dump
rename to library/core/src/test/assets/mp3/bear.mp3.0.dump
index b66d263c84..b12a68a60b 100644
--- a/library/core/src/androidTest/assets/mp3/bear.mp3.0.dump
+++ b/library/core/src/test/assets/mp3/bear.mp3.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2784000
-  getPosition(0) = 201
+  getPosition(0) = [[timeUs=0, position=201]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,6 +25,7 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 44544
   sample count = 116
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/mp3/bear.mp3.1.dump b/library/core/src/test/assets/mp3/bear.mp3.1.dump
similarity index 77%
rename from library/core/src/androidTest/assets/mp3/bear.mp3.1.dump
rename to library/core/src/test/assets/mp3/bear.mp3.1.dump
index 2e0b21050c..abf5b10415 100644
--- a/library/core/src/androidTest/assets/mp3/bear.mp3.1.dump
+++ b/library/core/src/test/assets/mp3/bear.mp3.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2784000
-  getPosition(0) = 201
+  getPosition(0) = [[timeUs=0, position=201]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,309 +25,314 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
-  sample count = 76
+  total output bytes = 29568
+  sample count = 77
   sample 0:
-    time = 945782
+    time = 928568
     flags = 1
-    data = length 384, hash 14EF6AFD
+    data = length 384, hash F7E344F4
   sample 1:
-    time = 969782
+    time = 952568
     flags = 1
-    data = length 384, hash 61C9B92C
+    data = length 384, hash 14EF6AFD
   sample 2:
-    time = 993782
+    time = 976568
     flags = 1
-    data = length 384, hash ABE1368
+    data = length 384, hash 61C9B92C
   sample 3:
-    time = 1017782
+    time = 1000568
     flags = 1
-    data = length 384, hash 6A3B8547
+    data = length 384, hash ABE1368
   sample 4:
-    time = 1041782
+    time = 1024568
     flags = 1
-    data = length 384, hash 30E905FA
+    data = length 384, hash 6A3B8547
   sample 5:
-    time = 1065782
+    time = 1048568
     flags = 1
-    data = length 384, hash 21A267CD
+    data = length 384, hash 30E905FA
   sample 6:
-    time = 1089782
+    time = 1072568
     flags = 1
-    data = length 384, hash D96A2651
+    data = length 384, hash 21A267CD
   sample 7:
-    time = 1113782
+    time = 1096568
     flags = 1
-    data = length 384, hash 72340177
+    data = length 384, hash D96A2651
   sample 8:
-    time = 1137782
+    time = 1120568
     flags = 1
-    data = length 384, hash 9345E744
+    data = length 384, hash 72340177
   sample 9:
-    time = 1161782
+    time = 1144568
     flags = 1
-    data = length 384, hash FDE39E3A
+    data = length 384, hash 9345E744
   sample 10:
-    time = 1185782
+    time = 1168568
     flags = 1
-    data = length 384, hash F0B7465
+    data = length 384, hash FDE39E3A
   sample 11:
-    time = 1209782
+    time = 1192568
     flags = 1
-    data = length 384, hash 3693AB86
+    data = length 384, hash F0B7465
   sample 12:
-    time = 1233782
+    time = 1216568
     flags = 1
-    data = length 384, hash F39719B1
+    data = length 384, hash 3693AB86
   sample 13:
-    time = 1257782
+    time = 1240568
     flags = 1
-    data = length 384, hash DA3958DC
+    data = length 384, hash F39719B1
   sample 14:
-    time = 1281782
+    time = 1264568
     flags = 1
-    data = length 384, hash FDC7599F
+    data = length 384, hash DA3958DC
   sample 15:
-    time = 1305782
+    time = 1288568
     flags = 1
-    data = length 384, hash AEFF8471
+    data = length 384, hash FDC7599F
   sample 16:
-    time = 1329782
+    time = 1312568
     flags = 1
-    data = length 384, hash 89C92C19
+    data = length 384, hash AEFF8471
   sample 17:
-    time = 1353782
+    time = 1336568
     flags = 1
-    data = length 384, hash 5C786A4B
+    data = length 384, hash 89C92C19
   sample 18:
-    time = 1377782
+    time = 1360568
     flags = 1
-    data = length 384, hash 5ACA8B
+    data = length 384, hash 5C786A4B
   sample 19:
-    time = 1401782
+    time = 1384568
     flags = 1
-    data = length 384, hash 7755974C
+    data = length 384, hash 5ACA8B
   sample 20:
-    time = 1425782
+    time = 1408568
     flags = 1
-    data = length 384, hash 3934B73C
+    data = length 384, hash 7755974C
   sample 21:
-    time = 1449782
+    time = 1432568
     flags = 1
-    data = length 384, hash DDD70A2F
+    data = length 384, hash 3934B73C
   sample 22:
-    time = 1473782
+    time = 1456568
     flags = 1
-    data = length 384, hash 8FACE2EF
+    data = length 384, hash DDD70A2F
   sample 23:
-    time = 1497782
+    time = 1480568
     flags = 1
-    data = length 384, hash 4A602591
+    data = length 384, hash 8FACE2EF
   sample 24:
-    time = 1521782
+    time = 1504568
     flags = 1
-    data = length 384, hash D019AA2D
+    data = length 384, hash 4A602591
   sample 25:
-    time = 1545782
+    time = 1528568
     flags = 1
-    data = length 384, hash 8A680B9D
+    data = length 384, hash D019AA2D
   sample 26:
-    time = 1569782
+    time = 1552568
     flags = 1
-    data = length 384, hash B655C959
+    data = length 384, hash 8A680B9D
   sample 27:
-    time = 1593782
+    time = 1576568
     flags = 1
-    data = length 384, hash 2168336B
+    data = length 384, hash B655C959
   sample 28:
-    time = 1617782
+    time = 1600568
     flags = 1
-    data = length 384, hash D77F6D31
+    data = length 384, hash 2168336B
   sample 29:
-    time = 1641782
+    time = 1624568
     flags = 1
-    data = length 384, hash 524B4B2F
+    data = length 384, hash D77F6D31
   sample 30:
-    time = 1665782
+    time = 1648568
     flags = 1
-    data = length 384, hash 4752DDFC
+    data = length 384, hash 524B4B2F
   sample 31:
-    time = 1689782
+    time = 1672568
     flags = 1
-    data = length 384, hash E786727F
+    data = length 384, hash 4752DDFC
   sample 32:
-    time = 1713782
+    time = 1696568
     flags = 1
-    data = length 384, hash 5DA6FB8C
+    data = length 384, hash E786727F
   sample 33:
-    time = 1737782
+    time = 1720568
     flags = 1
-    data = length 384, hash 92F24269
+    data = length 384, hash 5DA6FB8C
   sample 34:
-    time = 1761782
+    time = 1744568
     flags = 1
-    data = length 384, hash CD0A3BA1
+    data = length 384, hash 92F24269
   sample 35:
-    time = 1785782
+    time = 1768568
     flags = 1
-    data = length 384, hash 7D00409F
+    data = length 384, hash CD0A3BA1
   sample 36:
-    time = 1809782
+    time = 1792568
     flags = 1
-    data = length 384, hash D7ADB5FA
+    data = length 384, hash 7D00409F
   sample 37:
-    time = 1833782
+    time = 1816568
     flags = 1
-    data = length 384, hash 4A140209
+    data = length 384, hash D7ADB5FA
   sample 38:
-    time = 1857782
+    time = 1840568
     flags = 1
-    data = length 384, hash E801184A
+    data = length 384, hash 4A140209
   sample 39:
-    time = 1881782
+    time = 1864568
     flags = 1
-    data = length 384, hash 53C6CF9C
+    data = length 384, hash E801184A
   sample 40:
-    time = 1905782
+    time = 1888568
     flags = 1
-    data = length 384, hash 19A8D99F
+    data = length 384, hash 53C6CF9C
   sample 41:
-    time = 1929782
+    time = 1912568
     flags = 1
-    data = length 384, hash E47EB43F
+    data = length 384, hash 19A8D99F
   sample 42:
-    time = 1953782
+    time = 1936568
     flags = 1
-    data = length 384, hash 4EA329E7
+    data = length 384, hash E47EB43F
   sample 43:
-    time = 1977782
+    time = 1960568
     flags = 1
-    data = length 384, hash 1CCAAE62
+    data = length 384, hash 4EA329E7
   sample 44:
-    time = 2001782
+    time = 1984568
     flags = 1
-    data = length 384, hash ED3F8C66
+    data = length 384, hash 1CCAAE62
   sample 45:
-    time = 2025782
+    time = 2008568
     flags = 1
-    data = length 384, hash D3D646B6
+    data = length 384, hash ED3F8C66
   sample 46:
-    time = 2049782
+    time = 2032568
     flags = 1
-    data = length 384, hash 68CD1574
+    data = length 384, hash D3D646B6
   sample 47:
-    time = 2073782
+    time = 2056568
     flags = 1
-    data = length 384, hash 8CEAB382
+    data = length 384, hash 68CD1574
   sample 48:
-    time = 2097782
+    time = 2080568
     flags = 1
-    data = length 384, hash D54B1C48
+    data = length 384, hash 8CEAB382
   sample 49:
-    time = 2121782
+    time = 2104568
     flags = 1
-    data = length 384, hash FFE2EE90
+    data = length 384, hash D54B1C48
   sample 50:
-    time = 2145782
+    time = 2128568
     flags = 1
-    data = length 384, hash BFE8A673
+    data = length 384, hash FFE2EE90
   sample 51:
-    time = 2169782
+    time = 2152568
     flags = 1
-    data = length 384, hash 978B1C92
+    data = length 384, hash BFE8A673
   sample 52:
-    time = 2193782
+    time = 2176568
     flags = 1
-    data = length 384, hash 810CC71E
+    data = length 384, hash 978B1C92
   sample 53:
-    time = 2217782
+    time = 2200568
     flags = 1
-    data = length 384, hash 44FE42D9
+    data = length 384, hash 810CC71E
   sample 54:
-    time = 2241782
+    time = 2224568
     flags = 1
-    data = length 384, hash 2F5BB02C
+    data = length 384, hash 44FE42D9
   sample 55:
-    time = 2265782
+    time = 2248568
     flags = 1
-    data = length 384, hash 77DDB90
+    data = length 384, hash 2F5BB02C
   sample 56:
-    time = 2289782
+    time = 2272568
     flags = 1
-    data = length 384, hash 24FB5EDA
+    data = length 384, hash 77DDB90
   sample 57:
-    time = 2313782
+    time = 2296568
     flags = 1
-    data = length 384, hash E73203C6
+    data = length 384, hash 24FB5EDA
   sample 58:
-    time = 2337782
+    time = 2320568
     flags = 1
-    data = length 384, hash 14B525F1
+    data = length 384, hash E73203C6
   sample 59:
-    time = 2361782
+    time = 2344568
     flags = 1
-    data = length 384, hash 5E0F4E2E
+    data = length 384, hash 14B525F1
   sample 60:
-    time = 2385782
+    time = 2368568
     flags = 1
-    data = length 384, hash 67EE4E31
+    data = length 384, hash 5E0F4E2E
   sample 61:
-    time = 2409782
+    time = 2392568
     flags = 1
-    data = length 384, hash 2E04EC4C
+    data = length 384, hash 67EE4E31
   sample 62:
-    time = 2433782
+    time = 2416568
     flags = 1
-    data = length 384, hash 852CABA7
+    data = length 384, hash 2E04EC4C
   sample 63:
-    time = 2457782
+    time = 2440568
     flags = 1
-    data = length 384, hash 19928903
+    data = length 384, hash 852CABA7
   sample 64:
-    time = 2481782
+    time = 2464568
     flags = 1
-    data = length 384, hash 5DA42021
+    data = length 384, hash 19928903
   sample 65:
-    time = 2505782
+    time = 2488568
     flags = 1
-    data = length 384, hash 45B20B7C
+    data = length 384, hash 5DA42021
   sample 66:
-    time = 2529782
+    time = 2512568
     flags = 1
-    data = length 384, hash D108A215
+    data = length 384, hash 45B20B7C
   sample 67:
-    time = 2553782
+    time = 2536568
     flags = 1
-    data = length 384, hash BD25DB7C
+    data = length 384, hash D108A215
   sample 68:
-    time = 2577782
+    time = 2560568
     flags = 1
-    data = length 384, hash DA7F9861
+    data = length 384, hash BD25DB7C
   sample 69:
-    time = 2601782
+    time = 2584568
     flags = 1
-    data = length 384, hash CCD576F
+    data = length 384, hash DA7F9861
   sample 70:
-    time = 2625782
+    time = 2608568
     flags = 1
-    data = length 384, hash 405C1EB5
+    data = length 384, hash CCD576F
   sample 71:
-    time = 2649782
+    time = 2632568
     flags = 1
-    data = length 384, hash 6640B74E
+    data = length 384, hash 405C1EB5
   sample 72:
-    time = 2673782
+    time = 2656568
     flags = 1
-    data = length 384, hash B4E5937A
+    data = length 384, hash 6640B74E
   sample 73:
-    time = 2697782
+    time = 2680568
     flags = 1
-    data = length 384, hash CEE17733
+    data = length 384, hash B4E5937A
   sample 74:
-    time = 2721782
+    time = 2704568
     flags = 1
-    data = length 384, hash 2A0DA733
+    data = length 384, hash CEE17733
   sample 75:
-    time = 2745782
+    time = 2728568
+    flags = 1
+    data = length 384, hash 2A0DA733
+  sample 76:
+    time = 2752568
     flags = 1
     data = length 384, hash 97F4129B
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/mp3/bear.mp3.2.dump b/library/core/src/test/assets/mp3/bear.mp3.2.dump
similarity index 79%
rename from library/core/src/androidTest/assets/mp3/bear.mp3.2.dump
rename to library/core/src/test/assets/mp3/bear.mp3.2.dump
index b3cb117cb2..813f61b7fc 100644
--- a/library/core/src/androidTest/assets/mp3/bear.mp3.2.dump
+++ b/library/core/src/test/assets/mp3/bear.mp3.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2784000
-  getPosition(0) = 201
+  getPosition(0) = [[timeUs=0, position=201]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,157 +25,158 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 14592
   sample count = 38
   sample 0:
-    time = 1858196
+    time = 1871586
     flags = 1
     data = length 384, hash E801184A
   sample 1:
-    time = 1882196
+    time = 1895586
     flags = 1
     data = length 384, hash 53C6CF9C
   sample 2:
-    time = 1906196
+    time = 1919586
     flags = 1
     data = length 384, hash 19A8D99F
   sample 3:
-    time = 1930196
+    time = 1943586
     flags = 1
     data = length 384, hash E47EB43F
   sample 4:
-    time = 1954196
+    time = 1967586
     flags = 1
     data = length 384, hash 4EA329E7
   sample 5:
-    time = 1978196
+    time = 1991586
     flags = 1
     data = length 384, hash 1CCAAE62
   sample 6:
-    time = 2002196
+    time = 2015586
     flags = 1
     data = length 384, hash ED3F8C66
   sample 7:
-    time = 2026196
+    time = 2039586
     flags = 1
     data = length 384, hash D3D646B6
   sample 8:
-    time = 2050196
+    time = 2063586
     flags = 1
     data = length 384, hash 68CD1574
   sample 9:
-    time = 2074196
+    time = 2087586
     flags = 1
     data = length 384, hash 8CEAB382
   sample 10:
-    time = 2098196
+    time = 2111586
     flags = 1
     data = length 384, hash D54B1C48
   sample 11:
-    time = 2122196
+    time = 2135586
     flags = 1
     data = length 384, hash FFE2EE90
   sample 12:
-    time = 2146196
+    time = 2159586
     flags = 1
     data = length 384, hash BFE8A673
   sample 13:
-    time = 2170196
+    time = 2183586
     flags = 1
     data = length 384, hash 978B1C92
   sample 14:
-    time = 2194196
+    time = 2207586
     flags = 1
     data = length 384, hash 810CC71E
   sample 15:
-    time = 2218196
+    time = 2231586
     flags = 1
     data = length 384, hash 44FE42D9
   sample 16:
-    time = 2242196
+    time = 2255586
     flags = 1
     data = length 384, hash 2F5BB02C
   sample 17:
-    time = 2266196
+    time = 2279586
     flags = 1
     data = length 384, hash 77DDB90
   sample 18:
-    time = 2290196
+    time = 2303586
     flags = 1
     data = length 384, hash 24FB5EDA
   sample 19:
-    time = 2314196
+    time = 2327586
     flags = 1
     data = length 384, hash E73203C6
   sample 20:
-    time = 2338196
+    time = 2351586
     flags = 1
     data = length 384, hash 14B525F1
   sample 21:
-    time = 2362196
+    time = 2375586
     flags = 1
     data = length 384, hash 5E0F4E2E
   sample 22:
-    time = 2386196
+    time = 2399586
     flags = 1
     data = length 384, hash 67EE4E31
   sample 23:
-    time = 2410196
+    time = 2423586
     flags = 1
     data = length 384, hash 2E04EC4C
   sample 24:
-    time = 2434196
+    time = 2447586
     flags = 1
     data = length 384, hash 852CABA7
   sample 25:
-    time = 2458196
+    time = 2471586
     flags = 1
     data = length 384, hash 19928903
   sample 26:
-    time = 2482196
+    time = 2495586
     flags = 1
     data = length 384, hash 5DA42021
   sample 27:
-    time = 2506196
+    time = 2519586
     flags = 1
     data = length 384, hash 45B20B7C
   sample 28:
-    time = 2530196
+    time = 2543586
     flags = 1
     data = length 384, hash D108A215
   sample 29:
-    time = 2554196
+    time = 2567586
     flags = 1
     data = length 384, hash BD25DB7C
   sample 30:
-    time = 2578196
+    time = 2591586
     flags = 1
     data = length 384, hash DA7F9861
   sample 31:
-    time = 2602196
+    time = 2615586
     flags = 1
     data = length 384, hash CCD576F
   sample 32:
-    time = 2626196
+    time = 2639586
     flags = 1
     data = length 384, hash 405C1EB5
   sample 33:
-    time = 2650196
+    time = 2663586
     flags = 1
     data = length 384, hash 6640B74E
   sample 34:
-    time = 2674196
+    time = 2687586
     flags = 1
     data = length 384, hash B4E5937A
   sample 35:
-    time = 2698196
+    time = 2711586
     flags = 1
     data = length 384, hash CEE17733
   sample 36:
-    time = 2722196
+    time = 2735586
     flags = 1
     data = length 384, hash 2A0DA733
   sample 37:
-    time = 2746196
+    time = 2759586
     flags = 1
     data = length 384, hash 97F4129B
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/mp3/bear.mp3.3.dump b/library/core/src/test/assets/mp3/bear.mp3.3.dump
similarity index 89%
rename from library/core/src/androidTest/assets/mp3/bear.mp3.3.dump
rename to library/core/src/test/assets/mp3/bear.mp3.3.dump
index a2387eb887..9a0207bd53 100644
--- a/library/core/src/androidTest/assets/mp3/bear.mp3.3.dump
+++ b/library/core/src/test/assets/mp3/bear.mp3.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2784000
-  getPosition(0) = 201
+  getPosition(0) = [[timeUs=0, position=201]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,5 +25,6 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 0
   sample count = 0
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3 b/library/core/src/test/assets/mp3/play-trimmed.mp3
similarity index 100%
rename from library/core/src/androidTest/assets/mp3/play-trimmed.mp3
rename to library/core/src/test/assets/mp3/play-trimmed.mp3
diff --git a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.0.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
similarity index 90%
rename from library/core/src/androidTest/assets/mp3/play-trimmed.mp3.0.dump
rename to library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
index 37a04215ee..435360dfed 100644
--- a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.0.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 26125
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,6 +25,7 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 418
   sample count = 1
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.1.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
similarity index 77%
rename from library/core/src/androidTest/assets/mp3/play-trimmed.mp3.1.dump
rename to library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
index 0b6516ccdb..435360dfed 100644
--- a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.1.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 26125
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,5 +25,10 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
-  sample count = 0
+  total output bytes = 418
+  sample count = 1
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 418, hash B819987
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.2.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
similarity index 77%
rename from library/core/src/androidTest/assets/mp3/play-trimmed.mp3.2.dump
rename to library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
index 0b6516ccdb..435360dfed 100644
--- a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.2.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 26125
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,5 +25,10 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
-  sample count = 0
+  total output bytes = 418
+  sample count = 1
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 418, hash B819987
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.3.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
similarity index 77%
rename from library/core/src/androidTest/assets/mp3/play-trimmed.mp3.3.dump
rename to library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
index 0b6516ccdb..435360dfed 100644
--- a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.3.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 26125
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,5 +25,10 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
-  sample count = 0
+  total output bytes = 418
+  sample count = 1
+  sample 0:
+    time = 0
+    flags = 1
+    data = length 418, hash B819987
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.unklen.dump b/library/core/src/test/assets/mp3/play-trimmed.mp3.unklen.dump
similarity index 90%
rename from library/core/src/androidTest/assets/mp3/play-trimmed.mp3.unklen.dump
rename to library/core/src/test/assets/mp3/play-trimmed.mp3.unklen.dump
index b75aefd91b..6b49619b50 100644
--- a/library/core/src/androidTest/assets/mp3/play-trimmed.mp3.unklen.dump
+++ b/library/core/src/test/assets/mp3/play-trimmed.mp3.unklen.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,6 +25,7 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 418
   sample count = 1
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/mp4/sample.mp4 b/library/core/src/test/assets/mp4/sample.mp4
similarity index 100%
rename from library/core/src/androidTest/assets/mp4/sample.mp4
rename to library/core/src/test/assets/mp4/sample.mp4
diff --git a/library/core/src/androidTest/assets/mp4/sample.mp4.0.dump b/library/core/src/test/assets/mp4/sample.mp4.0.dump
similarity index 98%
rename from library/core/src/androidTest/assets/mp4/sample.mp4.0.dump
rename to library/core/src/test/assets/mp4/sample.mp4.0.dump
index be0a16681c..77708b16df 100644
--- a/library/core/src/androidTest/assets/mp4/sample.mp4.0.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1024000
-  getPosition(0) = 48
+  getPosition(0) = [[timeUs=0, position=48]]
 numberOfTracks = 2
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 29, hash 4746B5D9
       data = length 10, hash 7A0D0F2B
+  total output bytes = 89876
   sample count = 30
   sample 0:
     time = 0
@@ -171,6 +172,7 @@ track 1:
     drmInitData = -
     initializationData:
       data = length 2, hash 5F7
+  total output bytes = 9529
   sample count = 45
   sample 0:
     time = 44000
diff --git a/library/core/src/androidTest/assets/mp4/sample.mp4.1.dump b/library/core/src/test/assets/mp4/sample.mp4.1.dump
similarity index 98%
rename from library/core/src/androidTest/assets/mp4/sample.mp4.1.dump
rename to library/core/src/test/assets/mp4/sample.mp4.1.dump
index a759e4250a..30ed21ef98 100644
--- a/library/core/src/androidTest/assets/mp4/sample.mp4.1.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1024000
-  getPosition(0) = 48
+  getPosition(0) = [[timeUs=0, position=48]]
 numberOfTracks = 2
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 29, hash 4746B5D9
       data = length 10, hash 7A0D0F2B
+  total output bytes = 89876
   sample count = 30
   sample 0:
     time = 0
@@ -171,6 +172,7 @@ track 1:
     drmInitData = -
     initializationData:
       data = length 2, hash 5F7
+  total output bytes = 7464
   sample count = 33
   sample 0:
     time = 322639
diff --git a/library/core/src/androidTest/assets/mp4/sample.mp4.2.dump b/library/core/src/test/assets/mp4/sample.mp4.2.dump
similarity index 98%
rename from library/core/src/androidTest/assets/mp4/sample.mp4.2.dump
rename to library/core/src/test/assets/mp4/sample.mp4.2.dump
index 59ee715255..640d92722c 100644
--- a/library/core/src/androidTest/assets/mp4/sample.mp4.2.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1024000
-  getPosition(0) = 48
+  getPosition(0) = [[timeUs=0, position=48]]
 numberOfTracks = 2
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 29, hash 4746B5D9
       data = length 10, hash 7A0D0F2B
+  total output bytes = 89876
   sample count = 30
   sample 0:
     time = 0
@@ -171,6 +172,7 @@ track 1:
     drmInitData = -
     initializationData:
       data = length 2, hash 5F7
+  total output bytes = 4019
   sample count = 18
   sample 0:
     time = 670938
diff --git a/library/core/src/androidTest/assets/mp4/sample.mp4.3.dump b/library/core/src/test/assets/mp4/sample.mp4.3.dump
similarity index 97%
rename from library/core/src/androidTest/assets/mp4/sample.mp4.3.dump
rename to library/core/src/test/assets/mp4/sample.mp4.3.dump
index a81a4189d9..b4fd4a0b02 100644
--- a/library/core/src/androidTest/assets/mp4/sample.mp4.3.dump
+++ b/library/core/src/test/assets/mp4/sample.mp4.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1024000
-  getPosition(0) = 48
+  getPosition(0) = [[timeUs=0, position=48]]
 numberOfTracks = 2
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 29, hash 4746B5D9
       data = length 10, hash 7A0D0F2B
+  total output bytes = 89876
   sample count = 30
   sample 0:
     time = 0
@@ -171,6 +172,7 @@ track 1:
     drmInitData = -
     initializationData:
       data = length 2, hash 5F7
+  total output bytes = 470
   sample count = 3
   sample 0:
     time = 1019238
diff --git a/library/core/src/androidTest/assets/mp4/sample_fragmented.mp4 b/library/core/src/test/assets/mp4/sample_fragmented.mp4
similarity index 100%
rename from library/core/src/androidTest/assets/mp4/sample_fragmented.mp4
rename to library/core/src/test/assets/mp4/sample_fragmented.mp4
diff --git a/library/core/src/androidTest/assets/mp4/sample_fragmented.mp4.0.dump b/library/core/src/test/assets/mp4/sample_fragmented.mp4.0.dump
similarity index 98%
rename from library/core/src/androidTest/assets/mp4/sample_fragmented.mp4.0.dump
rename to library/core/src/test/assets/mp4/sample_fragmented.mp4.0.dump
index bf822d9db4..ec2cb7b8ce 100644
--- a/library/core/src/androidTest/assets/mp4/sample_fragmented.mp4.0.dump
+++ b/library/core/src/test/assets/mp4/sample_fragmented.mp4.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=1828]]
 numberOfTracks = 2
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 29, hash 4746B5D9
       data = length 10, hash 7A0D0F2B
+  total output bytes = 85933
   sample count = 30
   sample 0:
     time = 66000
@@ -171,6 +172,7 @@ track 1:
     drmInitData = -
     initializationData:
       data = length 5, hash 2B7623A
+  total output bytes = 18257
   sample count = 46
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/mp4/sample_fragmented_sei.mp4 b/library/core/src/test/assets/mp4/sample_fragmented_sei.mp4
similarity index 100%
rename from library/core/src/androidTest/assets/mp4/sample_fragmented_sei.mp4
rename to library/core/src/test/assets/mp4/sample_fragmented_sei.mp4
diff --git a/library/core/src/androidTest/assets/mp4/sample_fragmented_sei.mp4.0.dump b/library/core/src/test/assets/mp4/sample_fragmented_sei.mp4.0.dump
similarity index 98%
rename from library/core/src/androidTest/assets/mp4/sample_fragmented_sei.mp4.0.dump
rename to library/core/src/test/assets/mp4/sample_fragmented_sei.mp4.0.dump
index 9d3755b23b..ae012055fe 100644
--- a/library/core/src/androidTest/assets/mp4/sample_fragmented_sei.mp4.0.dump
+++ b/library/core/src/test/assets/mp4/sample_fragmented_sei.mp4.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=1828]]
 numberOfTracks = 3
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 29, hash 4746B5D9
       data = length 10, hash 7A0D0F2B
+  total output bytes = 85933
   sample count = 30
   sample 0:
     time = 66000
@@ -171,6 +172,7 @@ track 1:
     drmInitData = -
     initializationData:
       data = length 5, hash 2B7623A
+  total output bytes = 18257
   sample count = 46
   sample 0:
     time = 0
@@ -378,5 +380,6 @@ track 3:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 0
   sample count = 0
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/ogg/bear.opus b/library/core/src/test/assets/ogg/bear.opus
similarity index 100%
rename from library/core/src/androidTest/assets/ogg/bear.opus
rename to library/core/src/test/assets/ogg/bear.opus
diff --git a/library/core/src/androidTest/assets/ogg/bear.opus.0.dump b/library/core/src/test/assets/ogg/bear.opus.0.dump
similarity index 99%
rename from library/core/src/androidTest/assets/ogg/bear.opus.0.dump
rename to library/core/src/test/assets/ogg/bear.opus.0.dump
index 8033ce8089..643972b836 100644
--- a/library/core/src/androidTest/assets/ogg/bear.opus.0.dump
+++ b/library/core/src/test/assets/ogg/bear.opus.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2747500
-  getPosition(0) = 125
+  getPosition(0) = [[timeUs=0, position=125]]
 numberOfTracks = 1
 track 0:
   format:
@@ -28,6 +28,7 @@ track 0:
       data = length 19, hash BFE794DB
       data = length 8, hash CA22068C
       data = length 8, hash 79C07075
+  total output bytes = 25541
   sample count = 275
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/ogg/bear.opus.1.dump b/library/core/src/test/assets/ogg/bear.opus.1.dump
similarity index 99%
rename from library/core/src/androidTest/assets/ogg/bear.opus.1.dump
rename to library/core/src/test/assets/ogg/bear.opus.1.dump
index f9aceae68a..8df1563d90 100644
--- a/library/core/src/androidTest/assets/ogg/bear.opus.1.dump
+++ b/library/core/src/test/assets/ogg/bear.opus.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2747500
-  getPosition(0) = 125
+  getPosition(0) = [[timeUs=0, position=125]]
 numberOfTracks = 1
 track 0:
   format:
@@ -28,6 +28,7 @@ track 0:
       data = length 19, hash BFE794DB
       data = length 8, hash CA22068C
       data = length 8, hash 79C07075
+  total output bytes = 17031
   sample count = 184
   sample 0:
     time = 910000
diff --git a/library/core/src/androidTest/assets/ogg/bear.opus.2.dump b/library/core/src/test/assets/ogg/bear.opus.2.dump
similarity index 99%
rename from library/core/src/androidTest/assets/ogg/bear.opus.2.dump
rename to library/core/src/test/assets/ogg/bear.opus.2.dump
index f2f07f3e2f..bed4c46d9c 100644
--- a/library/core/src/androidTest/assets/ogg/bear.opus.2.dump
+++ b/library/core/src/test/assets/ogg/bear.opus.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2747500
-  getPosition(0) = 125
+  getPosition(0) = [[timeUs=0, position=125]]
 numberOfTracks = 1
 track 0:
   format:
@@ -28,6 +28,7 @@ track 0:
       data = length 19, hash BFE794DB
       data = length 8, hash CA22068C
       data = length 8, hash 79C07075
+  total output bytes = 8698
   sample count = 92
   sample 0:
     time = 1830000
diff --git a/library/core/src/androidTest/assets/ogg/bear.opus.3.dump b/library/core/src/test/assets/ogg/bear.opus.3.dump
similarity index 91%
rename from library/core/src/androidTest/assets/ogg/bear.opus.3.dump
rename to library/core/src/test/assets/ogg/bear.opus.3.dump
index 905055797c..8a9c99250e 100644
--- a/library/core/src/androidTest/assets/ogg/bear.opus.3.dump
+++ b/library/core/src/test/assets/ogg/bear.opus.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2747500
-  getPosition(0) = 125
+  getPosition(0) = [[timeUs=0, position=125]]
 numberOfTracks = 1
 track 0:
   format:
@@ -28,6 +28,7 @@ track 0:
       data = length 19, hash BFE794DB
       data = length 8, hash CA22068C
       data = length 8, hash 79C07075
+  total output bytes = 126
   sample count = 1
   sample 0:
     time = 2741000
diff --git a/library/core/src/androidTest/assets/ogg/bear.opus.unklen.dump b/library/core/src/test/assets/ogg/bear.opus.unklen.dump
similarity index 99%
rename from library/core/src/androidTest/assets/ogg/bear.opus.unklen.dump
rename to library/core/src/test/assets/ogg/bear.opus.unklen.dump
index cd29da3e27..5d2c84b047 100644
--- a/library/core/src/androidTest/assets/ogg/bear.opus.unklen.dump
+++ b/library/core/src/test/assets/ogg/bear.opus.unklen.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -28,6 +28,7 @@ track 0:
       data = length 19, hash BFE794DB
       data = length 8, hash CA22068C
       data = length 8, hash 79C07075
+  total output bytes = 25541
   sample count = 275
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac.ogg b/library/core/src/test/assets/ogg/bear_flac.ogg
similarity index 100%
rename from library/core/src/androidTest/assets/ogg/bear_flac.ogg
rename to library/core/src/test/assets/ogg/bear_flac.ogg
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.0.dump b/library/core/src/test/assets/ogg/bear_flac.ogg.0.dump
similarity index 97%
rename from library/core/src/androidTest/assets/ogg/bear_flac.ogg.0.dump
rename to library/core/src/test/assets/ogg/bear_flac.ogg.0.dump
index 5ba8cc29ae..ff22bb2d3e 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.0.dump
+++ b/library/core/src/test/assets/ogg/bear_flac.ogg.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8457
+  getPosition(0) = [[timeUs=0, position=8457]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 164431
   sample count = 33
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.1.dump b/library/core/src/test/assets/ogg/bear_flac.ogg.1.dump
similarity index 97%
rename from library/core/src/androidTest/assets/ogg/bear_flac.ogg.1.dump
rename to library/core/src/test/assets/ogg/bear_flac.ogg.1.dump
index f698fd28cf..50110149fd 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.1.dump
+++ b/library/core/src/test/assets/ogg/bear_flac.ogg.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8457
+  getPosition(0) = [[timeUs=0, position=8457]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 113666
   sample count = 23
   sample 0:
     time = 853333
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.2.dump b/library/core/src/test/assets/ogg/bear_flac.ogg.2.dump
similarity index 95%
rename from library/core/src/androidTest/assets/ogg/bear_flac.ogg.2.dump
rename to library/core/src/test/assets/ogg/bear_flac.ogg.2.dump
index 8d803d0bac..483ae36721 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.2.dump
+++ b/library/core/src/test/assets/ogg/bear_flac.ogg.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8457
+  getPosition(0) = [[timeUs=0, position=8457]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 55652
   sample count = 12
   sample 0:
     time = 1792000
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.3.dump b/library/core/src/test/assets/ogg/bear_flac.ogg.3.dump
similarity index 90%
rename from library/core/src/androidTest/assets/ogg/bear_flac.ogg.3.dump
rename to library/core/src/test/assets/ogg/bear_flac.ogg.3.dump
index 09f6267270..a47407e63d 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.3.dump
+++ b/library/core/src/test/assets/ogg/bear_flac.ogg.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8457
+  getPosition(0) = [[timeUs=0, position=8457]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 445
   sample count = 1
   sample 0:
     time = 2730666
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.unklen.dump b/library/core/src/test/assets/ogg/bear_flac.ogg.unklen.dump
similarity index 97%
rename from library/core/src/androidTest/assets/ogg/bear_flac.ogg.unklen.dump
rename to library/core/src/test/assets/ogg/bear_flac.ogg.unklen.dump
index 5ba8cc29ae..ff22bb2d3e 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac.ogg.unklen.dump
+++ b/library/core/src/test/assets/ogg/bear_flac.ogg.unklen.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8457
+  getPosition(0) = [[timeUs=0, position=8457]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 164431
   sample count = 33
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg
similarity index 100%
rename from library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg
rename to library/core/src/test/assets/ogg/bear_flac_noseektable.ogg
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.0.dump b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.0.dump
similarity index 97%
rename from library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.0.dump
rename to library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.0.dump
index 73e537f8c8..32f350efcb 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.0.dump
+++ b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8407
+  getPosition(0) = [[timeUs=0, position=8407]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 164431
   sample count = 33
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.1.dump b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.1.dump
similarity index 97%
rename from library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.1.dump
rename to library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.1.dump
index 3b7dc3fd1e..3082e8faca 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.1.dump
+++ b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8407
+  getPosition(0) = [[timeUs=0, position=8407]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 113666
   sample count = 23
   sample 0:
     time = 853333
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.2.dump b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.2.dump
similarity index 95%
rename from library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.2.dump
rename to library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.2.dump
index b6a6741fcc..b574409f70 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.2.dump
+++ b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8407
+  getPosition(0) = [[timeUs=0, position=8407]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 55652
   sample count = 12
   sample 0:
     time = 1792000
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.3.dump b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.3.dump
similarity index 90%
rename from library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.3.dump
rename to library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.3.dump
index 738002f7ef..f411596b44 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.3.dump
+++ b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 8407
+  getPosition(0) = [[timeUs=0, position=8407]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 445
   sample count = 1
   sample 0:
     time = 2730666
diff --git a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.unklen.dump b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.unklen.dump
similarity index 97%
rename from library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.unklen.dump
rename to library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.unklen.dump
index a237fd0dfc..bdfe90277d 100644
--- a/library/core/src/androidTest/assets/ogg/bear_flac_noseektable.ogg.unklen.dump
+++ b/library/core/src/test/assets/ogg/bear_flac_noseektable.ogg.unklen.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 42, hash 83F6895
+  total output bytes = 164431
   sample count = 33
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg b/library/core/src/test/assets/ogg/bear_vorbis.ogg
similarity index 100%
rename from library/core/src/androidTest/assets/ogg/bear_vorbis.ogg
rename to library/core/src/test/assets/ogg/bear_vorbis.ogg
diff --git a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.0.dump b/library/core/src/test/assets/ogg/bear_vorbis.ogg.0.dump
similarity index 99%
rename from library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.0.dump
rename to library/core/src/test/assets/ogg/bear_vorbis.ogg.0.dump
index 8e2c5125a3..dd129ce9dc 100644
--- a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.0.dump
+++ b/library/core/src/test/assets/ogg/bear_vorbis.ogg.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 3995
+  getPosition(0) = [[timeUs=0, position=3995]]
 numberOfTracks = 1
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 30, hash 9A8FF207
       data = length 3832, hash 8A406249
+  total output bytes = 26873
   sample count = 180
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.1.dump b/library/core/src/test/assets/ogg/bear_vorbis.ogg.1.dump
similarity index 99%
rename from library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.1.dump
rename to library/core/src/test/assets/ogg/bear_vorbis.ogg.1.dump
index aa25303ac3..4fb8a74d92 100644
--- a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.1.dump
+++ b/library/core/src/test/assets/ogg/bear_vorbis.ogg.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 3995
+  getPosition(0) = [[timeUs=0, position=3995]]
 numberOfTracks = 1
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 30, hash 9A8FF207
       data = length 3832, hash 8A406249
+  total output bytes = 17598
   sample count = 109
   sample 0:
     time = 896000
diff --git a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.2.dump b/library/core/src/test/assets/ogg/bear_vorbis.ogg.2.dump
similarity index 98%
rename from library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.2.dump
rename to library/core/src/test/assets/ogg/bear_vorbis.ogg.2.dump
index 58969058fa..fad8f33d77 100644
--- a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.2.dump
+++ b/library/core/src/test/assets/ogg/bear_vorbis.ogg.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 3995
+  getPosition(0) = [[timeUs=0, position=3995]]
 numberOfTracks = 1
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 30, hash 9A8FF207
       data = length 3832, hash 8A406249
+  total output bytes = 8658
   sample count = 49
   sample 0:
     time = 1821333
diff --git a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.3.dump b/library/core/src/test/assets/ogg/bear_vorbis.ogg.3.dump
similarity index 90%
rename from library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.3.dump
rename to library/core/src/test/assets/ogg/bear_vorbis.ogg.3.dump
index 4c789a8431..49dca02220 100644
--- a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.3.dump
+++ b/library/core/src/test/assets/ogg/bear_vorbis.ogg.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 2741000
-  getPosition(0) = 3995
+  getPosition(0) = [[timeUs=0, position=3995]]
 numberOfTracks = 1
 track 0:
   format:
@@ -27,5 +27,6 @@ track 0:
     initializationData:
       data = length 30, hash 9A8FF207
       data = length 3832, hash 8A406249
+  total output bytes = 0
   sample count = 0
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.unklen.dump b/library/core/src/test/assets/ogg/bear_vorbis.ogg.unklen.dump
similarity index 99%
rename from library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.unklen.dump
rename to library/core/src/test/assets/ogg/bear_vorbis.ogg.unklen.dump
index 2f163572bf..756be42854 100644
--- a/library/core/src/androidTest/assets/ogg/bear_vorbis.ogg.unklen.dump
+++ b/library/core/src/test/assets/ogg/bear_vorbis.ogg.unklen.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -27,6 +27,7 @@ track 0:
     initializationData:
       data = length 30, hash 9A8FF207
       data = length 3832, hash 8A406249
+  total output bytes = 26873
   sample count = 180
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/rawcc/sample.rawcc b/library/core/src/test/assets/rawcc/sample.rawcc
similarity index 100%
rename from library/core/src/androidTest/assets/rawcc/sample.rawcc
rename to library/core/src/test/assets/rawcc/sample.rawcc
diff --git a/library/core/src/androidTest/assets/rawcc/sample.rawcc.0.dump b/library/core/src/test/assets/rawcc/sample.rawcc.0.dump
similarity index 99%
rename from library/core/src/androidTest/assets/rawcc/sample.rawcc.0.dump
rename to library/core/src/test/assets/rawcc/sample.rawcc.0.dump
index 3e84813162..130be06ceb 100644
--- a/library/core/src/androidTest/assets/rawcc/sample.rawcc.0.dump
+++ b/library/core/src/test/assets/rawcc/sample.rawcc.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,6 +25,7 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 978
   sample count = 150
   sample 0:
     time = 37657512133
diff --git a/library/core/src/androidTest/assets/ssa/empty b/library/core/src/test/assets/ssa/empty
similarity index 100%
rename from library/core/src/androidTest/assets/ssa/empty
rename to library/core/src/test/assets/ssa/empty
diff --git a/library/core/src/androidTest/assets/ssa/invalid_timecodes b/library/core/src/test/assets/ssa/invalid_timecodes
similarity index 96%
rename from library/core/src/androidTest/assets/ssa/invalid_timecodes
rename to library/core/src/test/assets/ssa/invalid_timecodes
index 89f3bb3f1c..10ebfc3109 100644
--- a/library/core/src/androidTest/assets/ssa/invalid_timecodes
+++ b/library/core/src/test/assets/ssa/invalid_timecodes
@@ -9,4 +9,4 @@ Style: Default,Open Sans Semibold,36,&H00FFFFFF,&H000000FF,&H00020713,&H00000000
 Format: Layer, Start, End, Style, Name, Text
 Dialogue: 0,Invalid,0:00:01.23,Default,Olly,This is the first subtitle{ignored}.
 Dialogue: 0,0:00:02.34,Invalid,Default,Olly,This is the second subtitle \nwith a newline \Nand another.
-Dialogue: 0,0:00:04:56,0:00:08:90,Default,Olly,This is the third subtitle, with a comma.
\ No newline at end of file
+Dialogue: 0,0:00:04:56,0:00:08:90,Default,Olly,This is the third subtitle, with a comma.
diff --git a/library/core/src/androidTest/assets/ssa/no_end_timecodes b/library/core/src/test/assets/ssa/no_end_timecodes
similarity index 96%
rename from library/core/src/androidTest/assets/ssa/no_end_timecodes
rename to library/core/src/test/assets/ssa/no_end_timecodes
index c2c57ac64e..b949179533 100644
--- a/library/core/src/androidTest/assets/ssa/no_end_timecodes
+++ b/library/core/src/test/assets/ssa/no_end_timecodes
@@ -9,4 +9,4 @@ Style: Default,Open Sans Semibold,36,&H00FFFFFF,&H000000FF,&H00020713,&H00000000
 Format: Layer, Start, End, Style, Name, Text
 Dialogue: 0,0:00:00.00,          ,Default,Olly,This is the first subtitle.
 Dialogue: 0,0:00:02.34,          ,Default,Olly,This is the second subtitle \nwith a newline \Nand another.
-Dialogue: 0,0:00:04.56,          ,Default,Olly,This is the third subtitle, with a comma.
\ No newline at end of file
+Dialogue: 0,0:00:04.56,          ,Default,Olly,This is the third subtitle, with a comma.
diff --git a/library/core/src/androidTest/assets/ssa/typical b/library/core/src/test/assets/ssa/typical
similarity index 96%
rename from library/core/src/androidTest/assets/ssa/typical
rename to library/core/src/test/assets/ssa/typical
index 8a49099c5c..4542af1217 100644
--- a/library/core/src/androidTest/assets/ssa/typical
+++ b/library/core/src/test/assets/ssa/typical
@@ -9,4 +9,4 @@ Style: Default,Open Sans Semibold,36,&H00FFFFFF,&H000000FF,&H00020713,&H00000000
 Format: Layer, Start, End, Style, Name, Text
 Dialogue: 0,0:00:00.00,0:00:01.23,Default,Olly,This is the first subtitle{ignored}.
 Dialogue: 0,0:00:02.34,0:00:03.45,Default,Olly,This is the second subtitle \nwith a newline \Nand another.
-Dialogue: 0,0:00:04:56,0:00:08:90,Default,Olly,This is the third subtitle, with a comma.
\ No newline at end of file
+Dialogue: 0,0:00:04:56,0:00:08:90,Default,Olly,This is the third subtitle, with a comma.
diff --git a/library/core/src/androidTest/assets/ssa/typical_dialogue b/library/core/src/test/assets/ssa/typical_dialogue
similarity index 91%
rename from library/core/src/androidTest/assets/ssa/typical_dialogue
rename to library/core/src/test/assets/ssa/typical_dialogue
index 5cdab5a84b..987b02ddb1 100644
--- a/library/core/src/androidTest/assets/ssa/typical_dialogue
+++ b/library/core/src/test/assets/ssa/typical_dialogue
@@ -1,3 +1,3 @@
 Dialogue: 0,0:00:00.00,0:00:01.23,Default,Olly,This is the first subtitle{ignored}.
 Dialogue: 0,0:00:02.34,0:00:03.45,Default,Olly,This is the second subtitle \nwith a newline \Nand another.
-Dialogue: 0,0:00:04:56,0:00:08:90,Default,Olly,This is the third subtitle, with a comma.
\ No newline at end of file
+Dialogue: 0,0:00:04:56,0:00:08:90,Default,Olly,This is the third subtitle, with a comma.
diff --git a/library/core/src/test/assets/ssa/typical_format b/library/core/src/test/assets/ssa/typical_format
new file mode 100644
index 0000000000..330cb28b48
--- /dev/null
+++ b/library/core/src/test/assets/ssa/typical_format
@@ -0,0 +1 @@
+Format: Layer, Start, End, Style, Name, Text
diff --git a/library/core/src/androidTest/assets/ssa/typical_header b/library/core/src/test/assets/ssa/typical_header
similarity index 85%
rename from library/core/src/androidTest/assets/ssa/typical_header
rename to library/core/src/test/assets/ssa/typical_header
index 3e96bcf14e..636545500f 100644
--- a/library/core/src/androidTest/assets/ssa/typical_header
+++ b/library/core/src/test/assets/ssa/typical_header
@@ -3,4 +3,4 @@ Title: SomeTitle
 
 [V4+ Styles]
 Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
-Style: Default,Open Sans Semibold,36,&H00FFFFFF,&H000000FF,&H00020713,&H00000000,-1,0,0,0,100,100,0,0,1,1.7,0,2,0,0,28,1
\ No newline at end of file
+Style: Default,Open Sans Semibold,36,&H00FFFFFF,&H000000FF,&H00020713,&H00000000,-1,0,0,0,100,100,0,0,1,1.7,0,2,0,0,28,1
diff --git a/library/core/src/androidTest/assets/subrip/empty b/library/core/src/test/assets/subrip/empty
similarity index 100%
rename from library/core/src/androidTest/assets/subrip/empty
rename to library/core/src/test/assets/subrip/empty
diff --git a/library/core/src/androidTest/assets/subrip/no_end_timecodes b/library/core/src/test/assets/subrip/no_end_timecodes
similarity index 87%
rename from library/core/src/androidTest/assets/subrip/no_end_timecodes
rename to library/core/src/test/assets/subrip/no_end_timecodes
index 0a856c6994..df2c44b956 100644
--- a/library/core/src/androidTest/assets/subrip/no_end_timecodes
+++ b/library/core/src/test/assets/subrip/no_end_timecodes
@@ -8,4 +8,4 @@ We interpret it to mean that a subtitle extends to the start of the next one.
 
 3
 00:00:03,456 -->
-Or to the end of the media.
\ No newline at end of file
+Or to the end of the media.
diff --git a/library/core/src/androidTest/assets/subrip/typical b/library/core/src/test/assets/subrip/typical
similarity index 87%
rename from library/core/src/androidTest/assets/subrip/typical
rename to library/core/src/test/assets/subrip/typical
index 1c8ce4dd43..1331f75651 100644
--- a/library/core/src/androidTest/assets/subrip/typical
+++ b/library/core/src/test/assets/subrip/typical
@@ -9,4 +9,4 @@ Second subtitle with second line.
 
 3
 00:00:04,567 --> 00:00:08,901
-This is the third subtitle.
\ No newline at end of file
+This is the third subtitle.
diff --git a/library/core/src/androidTest/assets/subrip/typical_extra_blank_line b/library/core/src/test/assets/subrip/typical_extra_blank_line
similarity index 87%
rename from library/core/src/androidTest/assets/subrip/typical_extra_blank_line
rename to library/core/src/test/assets/subrip/typical_extra_blank_line
index 83508dd733..f5882a1d68 100644
--- a/library/core/src/androidTest/assets/subrip/typical_extra_blank_line
+++ b/library/core/src/test/assets/subrip/typical_extra_blank_line
@@ -10,4 +10,4 @@ Second subtitle with second line.
 
 3
 00:00:04,567 --> 00:00:08,901
-This is the third subtitle.
\ No newline at end of file
+This is the third subtitle.
diff --git a/library/core/src/androidTest/assets/subrip/typical_missing_sequence b/library/core/src/test/assets/subrip/typical_missing_sequence
similarity index 86%
rename from library/core/src/androidTest/assets/subrip/typical_missing_sequence
rename to library/core/src/test/assets/subrip/typical_missing_sequence
index 9318ba3239..56d49ac63c 100644
--- a/library/core/src/androidTest/assets/subrip/typical_missing_sequence
+++ b/library/core/src/test/assets/subrip/typical_missing_sequence
@@ -8,4 +8,4 @@ Second subtitle with second line.
 
 3
 00:00:04,567 --> 00:00:08,901
-This is the third subtitle.
\ No newline at end of file
+This is the third subtitle.
diff --git a/library/core/src/androidTest/assets/subrip/typical_missing_timecode b/library/core/src/test/assets/subrip/typical_missing_timecode
similarity index 85%
rename from library/core/src/androidTest/assets/subrip/typical_missing_timecode
rename to library/core/src/test/assets/subrip/typical_missing_timecode
index b9c999ada9..2c6fe69b6f 100644
--- a/library/core/src/androidTest/assets/subrip/typical_missing_timecode
+++ b/library/core/src/test/assets/subrip/typical_missing_timecode
@@ -8,4 +8,4 @@ Second subtitle with second line.
 
 3
 00:00:04,567 --> 00:00:08,901
-This is the third subtitle.
\ No newline at end of file
+This is the third subtitle.
diff --git a/library/core/src/androidTest/assets/subrip/typical_negative_timestamps b/library/core/src/test/assets/subrip/typical_negative_timestamps
similarity index 100%
rename from library/core/src/androidTest/assets/subrip/typical_negative_timestamps
rename to library/core/src/test/assets/subrip/typical_negative_timestamps
diff --git a/library/core/src/androidTest/assets/subrip/typical_unexpected_end b/library/core/src/test/assets/subrip/typical_unexpected_end
similarity index 98%
rename from library/core/src/androidTest/assets/subrip/typical_unexpected_end
rename to library/core/src/test/assets/subrip/typical_unexpected_end
index 8e2949b8db..91e82b1174 100644
--- a/library/core/src/androidTest/assets/subrip/typical_unexpected_end
+++ b/library/core/src/test/assets/subrip/typical_unexpected_end
@@ -7,4 +7,4 @@ This is the first subtitle.
 This is the second subtitle.
 Second subtitle with second line.
 
-3
\ No newline at end of file
+3
diff --git a/library/core/src/androidTest/assets/subrip/typical_with_byte_order_mark b/library/core/src/test/assets/subrip/typical_with_byte_order_mark
similarity index 87%
rename from library/core/src/androidTest/assets/subrip/typical_with_byte_order_mark
rename to library/core/src/test/assets/subrip/typical_with_byte_order_mark
index 9601c99bfb..4f5b32f4d7 100644
--- a/library/core/src/androidTest/assets/subrip/typical_with_byte_order_mark
+++ b/library/core/src/test/assets/subrip/typical_with_byte_order_mark
@@ -9,4 +9,4 @@ Second subtitle with second line.
 
 3
 00:00:04,567 --> 00:00:08,901
-This is the third subtitle.
\ No newline at end of file
+This is the third subtitle.
diff --git a/library/core/src/androidTest/assets/ts/sample.ac3 b/library/core/src/test/assets/ts/sample.ac3
similarity index 100%
rename from library/core/src/androidTest/assets/ts/sample.ac3
rename to library/core/src/test/assets/ts/sample.ac3
diff --git a/library/core/src/androidTest/assets/ts/sample.ac3.0.dump b/library/core/src/test/assets/ts/sample.ac3.0.dump
similarity index 94%
rename from library/core/src/androidTest/assets/ts/sample.ac3.0.dump
rename to library/core/src/test/assets/ts/sample.ac3.0.dump
index 1b6c77efb6..46028638fe 100644
--- a/library/core/src/androidTest/assets/ts/sample.ac3.0.dump
+++ b/library/core/src/test/assets/ts/sample.ac3.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,6 +25,7 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 13281
   sample count = 8
   sample 0:
     time = 0
diff --git a/library/core/src/androidTest/assets/ts/sample.adts b/library/core/src/test/assets/ts/sample.adts
similarity index 100%
rename from library/core/src/androidTest/assets/ts/sample.adts
rename to library/core/src/test/assets/ts/sample.adts
diff --git a/library/core/src/androidTest/assets/ts/sample.adts.0.dump b/library/core/src/test/assets/ts/sample.adts.0.dump
similarity index 99%
rename from library/core/src/androidTest/assets/ts/sample.adts.0.dump
rename to library/core/src/test/assets/ts/sample.adts.0.dump
index 0a7427d3f1..132859a00e 100644
--- a/library/core/src/androidTest/assets/ts/sample.adts.0.dump
+++ b/library/core/src/test/assets/ts/sample.adts.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 2
 track 0:
   format:
@@ -26,6 +26,7 @@ track 0:
     drmInitData = -
     initializationData:
       data = length 2, hash 5F7
+  total output bytes = 30797
   sample count = 144
   sample 0:
     time = 0
@@ -625,5 +626,6 @@ track 1:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 0
   sample count = 0
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/ts/sample.ps b/library/core/src/test/assets/ts/sample.ps
similarity index 100%
rename from library/core/src/androidTest/assets/ts/sample.ps
rename to library/core/src/test/assets/ts/sample.ps
diff --git a/library/core/src/androidTest/assets/ts/sample.ps.0.dump b/library/core/src/test/assets/ts/sample.ps.0.dump
similarity index 94%
rename from library/core/src/androidTest/assets/ts/sample.ps.0.dump
rename to library/core/src/test/assets/ts/sample.ps.0.dump
index 98f3c6a85a..e833201692 100644
--- a/library/core/src/androidTest/assets/ts/sample.ps.0.dump
+++ b/library/core/src/test/assets/ts/sample.ps.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 2
 track 192:
   format:
@@ -25,6 +25,7 @@ track 192:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 1671
   sample count = 4
   sample 0:
     time = 29088
@@ -65,6 +66,7 @@ track 224:
     drmInitData = -
     initializationData:
       data = length 22, hash 743CC6F8
+  total output bytes = 44056
   sample count = 2
   sample 0:
     time = 40000
diff --git a/library/core/src/androidTest/assets/ts/sample.ts b/library/core/src/test/assets/ts/sample.ts
similarity index 100%
rename from library/core/src/androidTest/assets/ts/sample.ts
rename to library/core/src/test/assets/ts/sample.ts
diff --git a/library/core/src/androidTest/assets/ts/sample.ts.0.dump b/library/core/src/test/assets/ts/sample.ts.0.dump
similarity index 94%
rename from library/core/src/androidTest/assets/ts/sample.ts.0.dump
rename to library/core/src/test/assets/ts/sample.ts.0.dump
index 91e48b1722..39b1565289 100644
--- a/library/core/src/androidTest/assets/ts/sample.ts.0.dump
+++ b/library/core/src/test/assets/ts/sample.ts.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = false
   duration = UNSET TIME
-  getPosition(0) = 0
+  getPosition(0) = [[timeUs=0, position=0]]
 numberOfTracks = 2
 track 256:
   format:
@@ -26,6 +26,7 @@ track 256:
     drmInitData = -
     initializationData:
       data = length 22, hash CE183139
+  total output bytes = 45026
   sample count = 2
   sample 0:
     time = 33366
@@ -57,6 +58,7 @@ track 257:
     language = und
     drmInitData = -
     initializationData:
+  total output bytes = 5015
   sample count = 4
   sample 0:
     time = 22455
diff --git a/library/core/src/androidTest/assets/ts/sample_with_sdt.ts b/library/core/src/test/assets/ts/sample_with_sdt.ts
similarity index 100%
rename from library/core/src/androidTest/assets/ts/sample_with_sdt.ts
rename to library/core/src/test/assets/ts/sample_with_sdt.ts
diff --git a/library/core/src/androidTest/assets/ttml/chain_multiple_styles.xml b/library/core/src/test/assets/ttml/chain_multiple_styles.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/chain_multiple_styles.xml
rename to library/core/src/test/assets/ttml/chain_multiple_styles.xml
diff --git a/library/core/src/androidTest/assets/ttml/font_size.xml b/library/core/src/test/assets/ttml/font_size.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/font_size.xml
rename to library/core/src/test/assets/ttml/font_size.xml
diff --git a/library/core/src/androidTest/assets/ttml/font_size_empty.xml b/library/core/src/test/assets/ttml/font_size_empty.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/font_size_empty.xml
rename to library/core/src/test/assets/ttml/font_size_empty.xml
diff --git a/library/core/src/androidTest/assets/ttml/font_size_invalid.xml b/library/core/src/test/assets/ttml/font_size_invalid.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/font_size_invalid.xml
rename to library/core/src/test/assets/ttml/font_size_invalid.xml
diff --git a/library/core/src/androidTest/assets/ttml/font_size_no_unit.xml b/library/core/src/test/assets/ttml/font_size_no_unit.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/font_size_no_unit.xml
rename to library/core/src/test/assets/ttml/font_size_no_unit.xml
diff --git a/library/core/src/androidTest/assets/ttml/frame_rate.xml b/library/core/src/test/assets/ttml/frame_rate.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/frame_rate.xml
rename to library/core/src/test/assets/ttml/frame_rate.xml
diff --git a/library/core/src/androidTest/assets/ttml/inherit_and_override_style.xml b/library/core/src/test/assets/ttml/inherit_and_override_style.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/inherit_and_override_style.xml
rename to library/core/src/test/assets/ttml/inherit_and_override_style.xml
diff --git a/library/core/src/androidTest/assets/ttml/inherit_global_and_parent.xml b/library/core/src/test/assets/ttml/inherit_global_and_parent.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/inherit_global_and_parent.xml
rename to library/core/src/test/assets/ttml/inherit_global_and_parent.xml
diff --git a/library/core/src/androidTest/assets/ttml/inherit_multiple_styles.xml b/library/core/src/test/assets/ttml/inherit_multiple_styles.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/inherit_multiple_styles.xml
rename to library/core/src/test/assets/ttml/inherit_multiple_styles.xml
diff --git a/library/core/src/androidTest/assets/ttml/inherit_style.xml b/library/core/src/test/assets/ttml/inherit_style.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/inherit_style.xml
rename to library/core/src/test/assets/ttml/inherit_style.xml
diff --git a/library/core/src/androidTest/assets/ttml/inline_style_attributes.xml b/library/core/src/test/assets/ttml/inline_style_attributes.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/inline_style_attributes.xml
rename to library/core/src/test/assets/ttml/inline_style_attributes.xml
diff --git a/library/core/src/androidTest/assets/ttml/multiple_regions.xml b/library/core/src/test/assets/ttml/multiple_regions.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/multiple_regions.xml
rename to library/core/src/test/assets/ttml/multiple_regions.xml
diff --git a/library/core/src/androidTest/assets/ttml/no_underline_linethrough.xml b/library/core/src/test/assets/ttml/no_underline_linethrough.xml
similarity index 100%
rename from library/core/src/androidTest/assets/ttml/no_underline_linethrough.xml
rename to library/core/src/test/assets/ttml/no_underline_linethrough.xml
diff --git a/library/core/src/androidTest/assets/tx3g/initialization b/library/core/src/test/assets/tx3g/initialization
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/initialization
rename to library/core/src/test/assets/tx3g/initialization
diff --git a/library/core/src/androidTest/assets/tx3g/initialization_all_defaults b/library/core/src/test/assets/tx3g/initialization_all_defaults
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/initialization_all_defaults
rename to library/core/src/test/assets/tx3g/initialization_all_defaults
diff --git a/library/core/src/androidTest/assets/tx3g/no_subtitle b/library/core/src/test/assets/tx3g/no_subtitle
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/no_subtitle
rename to library/core/src/test/assets/tx3g/no_subtitle
diff --git a/library/core/src/androidTest/assets/tx3g/sample_just_text b/library/core/src/test/assets/tx3g/sample_just_text
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/sample_just_text
rename to library/core/src/test/assets/tx3g/sample_just_text
diff --git a/library/core/src/androidTest/assets/tx3g/sample_utf16_be_no_styl b/library/core/src/test/assets/tx3g/sample_utf16_be_no_styl
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/sample_utf16_be_no_styl
rename to library/core/src/test/assets/tx3g/sample_utf16_be_no_styl
diff --git a/library/core/src/androidTest/assets/tx3g/sample_utf16_le_no_styl b/library/core/src/test/assets/tx3g/sample_utf16_le_no_styl
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/sample_utf16_le_no_styl
rename to library/core/src/test/assets/tx3g/sample_utf16_le_no_styl
diff --git a/library/core/src/androidTest/assets/tx3g/sample_with_multiple_styl b/library/core/src/test/assets/tx3g/sample_with_multiple_styl
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/sample_with_multiple_styl
rename to library/core/src/test/assets/tx3g/sample_with_multiple_styl
diff --git a/library/core/src/androidTest/assets/tx3g/sample_with_other_extension b/library/core/src/test/assets/tx3g/sample_with_other_extension
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/sample_with_other_extension
rename to library/core/src/test/assets/tx3g/sample_with_other_extension
diff --git a/library/core/src/androidTest/assets/tx3g/sample_with_styl b/library/core/src/test/assets/tx3g/sample_with_styl
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/sample_with_styl
rename to library/core/src/test/assets/tx3g/sample_with_styl
diff --git a/library/core/src/androidTest/assets/tx3g/sample_with_styl_all_defaults b/library/core/src/test/assets/tx3g/sample_with_styl_all_defaults
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/sample_with_styl_all_defaults
rename to library/core/src/test/assets/tx3g/sample_with_styl_all_defaults
diff --git a/library/core/src/androidTest/assets/tx3g/sample_with_tbox b/library/core/src/test/assets/tx3g/sample_with_tbox
similarity index 100%
rename from library/core/src/androidTest/assets/tx3g/sample_with_tbox
rename to library/core/src/test/assets/tx3g/sample_with_tbox
diff --git a/library/core/src/androidTest/assets/wav/sample.wav b/library/core/src/test/assets/wav/sample.wav
similarity index 100%
rename from library/core/src/androidTest/assets/wav/sample.wav
rename to library/core/src/test/assets/wav/sample.wav
diff --git a/library/core/src/androidTest/assets/wav/sample.wav.0.dump b/library/core/src/test/assets/wav/sample.wav.0.dump
similarity index 86%
rename from library/core/src/androidTest/assets/wav/sample.wav.0.dump
rename to library/core/src/test/assets/wav/sample.wav.0.dump
index 9ad01284b7..32f9d495d2 100644
--- a/library/core/src/androidTest/assets/wav/sample.wav.0.dump
+++ b/library/core/src/test/assets/wav/sample.wav.0.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1000000
-  getPosition(0) = 78
+  getPosition(0) = [[timeUs=0, position=78]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,17 +25,18 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 88200
   sample count = 3
   sample 0:
-    time = 884
+    time = 0
     flags = 1
     data = length 32768, hash 9A8CEEBA
   sample 1:
-    time = 372403
+    time = 371519
     flags = 1
     data = length 32768, hash C1717317
   sample 2:
-    time = 743922
+    time = 743038
     flags = 1
     data = length 22664, hash 819F5F62
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/wav/sample.wav.1.dump b/library/core/src/test/assets/wav/sample.wav.1.dump
similarity index 86%
rename from library/core/src/androidTest/assets/wav/sample.wav.1.dump
rename to library/core/src/test/assets/wav/sample.wav.1.dump
index ca98cc5cf5..d4758e65b5 100644
--- a/library/core/src/androidTest/assets/wav/sample.wav.1.dump
+++ b/library/core/src/test/assets/wav/sample.wav.1.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1000000
-  getPosition(0) = 78
+  getPosition(0) = [[timeUs=0, position=78]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,13 +25,14 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 58802
   sample count = 2
   sample 0:
-    time = 334195
+    time = 333310
     flags = 1
     data = length 32768, hash 42D6E860
   sample 1:
-    time = 705714
+    time = 704829
     flags = 1
     data = length 26034, hash 62692C38
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/wav/sample.wav.2.dump b/library/core/src/test/assets/wav/sample.wav.2.dump
similarity index 87%
rename from library/core/src/androidTest/assets/wav/sample.wav.2.dump
rename to library/core/src/test/assets/wav/sample.wav.2.dump
index da212b220a..ea33c62423 100644
--- a/library/core/src/androidTest/assets/wav/sample.wav.2.dump
+++ b/library/core/src/test/assets/wav/sample.wav.2.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1000000
-  getPosition(0) = 78
+  getPosition(0) = [[timeUs=0, position=78]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,9 +25,10 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 29402
   sample count = 1
   sample 0:
-    time = 667528
+    time = 666643
     flags = 1
     data = length 29402, hash 4241604E
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/wav/sample.wav.3.dump b/library/core/src/test/assets/wav/sample.wav.3.dump
similarity index 88%
rename from library/core/src/androidTest/assets/wav/sample.wav.3.dump
rename to library/core/src/test/assets/wav/sample.wav.3.dump
index 3275ba6ef5..de0d8f22d0 100644
--- a/library/core/src/androidTest/assets/wav/sample.wav.3.dump
+++ b/library/core/src/test/assets/wav/sample.wav.3.dump
@@ -1,7 +1,7 @@
 seekMap:
   isSeekable = true
   duration = 1000000
-  getPosition(0) = 78
+  getPosition(0) = [[timeUs=0, position=78]]
 numberOfTracks = 1
 track 0:
   format:
@@ -25,9 +25,10 @@ track 0:
     language = null
     drmInitData = -
     initializationData:
+  total output bytes = 2
   sample count = 1
   sample 0:
-    time = 1000861
+    time = 999977
     flags = 1
     data = length 2, hash 116
 tracksEnded = true
diff --git a/library/core/src/androidTest/assets/webm/vorbis_codec_private b/library/core/src/test/assets/webm/vorbis_codec_private
similarity index 100%
rename from library/core/src/androidTest/assets/webm/vorbis_codec_private
rename to library/core/src/test/assets/webm/vorbis_codec_private
diff --git a/library/core/src/androidTest/assets/webvtt/empty b/library/core/src/test/assets/webvtt/empty
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/empty
rename to library/core/src/test/assets/webvtt/empty
diff --git a/library/core/src/androidTest/assets/webvtt/typical b/library/core/src/test/assets/webvtt/typical
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/typical
rename to library/core/src/test/assets/webvtt/typical
diff --git a/library/core/src/androidTest/assets/webvtt/typical_with_bad_timestamps b/library/core/src/test/assets/webvtt/typical_with_bad_timestamps
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/typical_with_bad_timestamps
rename to library/core/src/test/assets/webvtt/typical_with_bad_timestamps
diff --git a/library/core/src/androidTest/assets/webvtt/typical_with_comments b/library/core/src/test/assets/webvtt/typical_with_comments
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/typical_with_comments
rename to library/core/src/test/assets/webvtt/typical_with_comments
diff --git a/library/core/src/androidTest/assets/webvtt/typical_with_identifiers b/library/core/src/test/assets/webvtt/typical_with_identifiers
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/typical_with_identifiers
rename to library/core/src/test/assets/webvtt/typical_with_identifiers
diff --git a/library/core/src/androidTest/assets/webvtt/with_bad_cue_header b/library/core/src/test/assets/webvtt/with_bad_cue_header
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/with_bad_cue_header
rename to library/core/src/test/assets/webvtt/with_bad_cue_header
diff --git a/library/core/src/androidTest/assets/webvtt/with_css_complex_selectors b/library/core/src/test/assets/webvtt/with_css_complex_selectors
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/with_css_complex_selectors
rename to library/core/src/test/assets/webvtt/with_css_complex_selectors
diff --git a/library/core/src/androidTest/assets/webvtt/with_css_styles b/library/core/src/test/assets/webvtt/with_css_styles
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/with_css_styles
rename to library/core/src/test/assets/webvtt/with_css_styles
diff --git a/library/core/src/androidTest/assets/webvtt/with_positioning b/library/core/src/test/assets/webvtt/with_positioning
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/with_positioning
rename to library/core/src/test/assets/webvtt/with_positioning
diff --git a/library/core/src/androidTest/assets/webvtt/with_tags b/library/core/src/test/assets/webvtt/with_tags
similarity index 100%
rename from library/core/src/androidTest/assets/webvtt/with_tags
rename to library/core/src/test/assets/webvtt/with_tags
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/CTest.java b/library/core/src/test/java/com/google/android/exoplayer2/CTest.java
index ff4756f5ed..f56510f654 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/CTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/CTest.java
@@ -22,13 +22,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link C}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class CTest {
 
   @SuppressLint("InlinedApi")
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/DefaultMediaClockTest.java b/library/core/src/test/java/com/google/android/exoplayer2/DefaultMediaClockTest.java
new file mode 100644
index 0000000000..ece22dc02a
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/DefaultMediaClockTest.java
@@ -0,0 +1,446 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import com.google.android.exoplayer2.DefaultMediaClock.PlaybackParameterListener;
+import com.google.android.exoplayer2.testutil.FakeClock;
+import com.google.android.exoplayer2.testutil.FakeMediaClockRenderer;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.RobolectricTestRunner;
+
+/**
+ * Unit test for {@link DefaultMediaClock}.
+ */
+@RunWith(RobolectricTestRunner.class)
+public class DefaultMediaClockTest {
+
+  private static final long TEST_POSITION_US = 123456789012345678L;
+  private static final long SLEEP_TIME_MS = 1_000;
+  private static final PlaybackParameters TEST_PLAYBACK_PARAMETERS =
+      new PlaybackParameters(2.0f, 1.0f);
+
+  @Mock private PlaybackParameterListener listener;
+  private FakeClock fakeClock;
+  private DefaultMediaClock mediaClock;
+
+  @Before
+  public void initMediaClockWithFakeClock() {
+    initMocks(this);
+    fakeClock = new FakeClock(0);
+    mediaClock = new DefaultMediaClock(listener, fakeClock);
+  }
+
+  @Test
+  public void standaloneResetPosition_getPositionShouldReturnSameValue() throws Exception {
+    mediaClock.resetPosition(TEST_POSITION_US);
+    assertThat(mediaClock.syncAndGetPositionUs()).isEqualTo(TEST_POSITION_US);
+  }
+
+  @Test
+  public void standaloneGetAndResetPosition_shouldNotTriggerCallback() throws Exception {
+    mediaClock.resetPosition(TEST_POSITION_US);
+    mediaClock.syncAndGetPositionUs();
+    verifyNoMoreInteractions(listener);
+  }
+
+  @Test
+  public void standaloneClock_shouldNotAutoStart() throws Exception {
+    assertClockIsStopped();
+  }
+
+  @Test
+  public void standaloneResetPosition_shouldNotStartClock() throws Exception {
+    mediaClock.resetPosition(TEST_POSITION_US);
+    assertClockIsStopped();
+  }
+
+  @Test
+  public void standaloneStart_shouldStartClock() throws Exception {
+    mediaClock.start();
+    assertClockIsRunning();
+  }
+
+  @Test
+  public void standaloneStop_shouldKeepClockStopped() throws Exception {
+    mediaClock.stop();
+    assertClockIsStopped();
+  }
+
+  @Test
+  public void standaloneStartAndStop_shouldStopClock() throws Exception {
+    mediaClock.start();
+    mediaClock.stop();
+    assertClockIsStopped();
+  }
+
+  @Test
+  public void standaloneStartStopStart_shouldRestartClock() throws Exception {
+    mediaClock.start();
+    mediaClock.stop();
+    mediaClock.start();
+    assertClockIsRunning();
+  }
+
+  @Test
+  public void standaloneStartAndStop_shouldNotTriggerCallback() throws Exception {
+    mediaClock.start();
+    mediaClock.stop();
+    verifyNoMoreInteractions(listener);
+  }
+
+  @Test
+  public void standaloneGetPlaybackParameters_initializedWithDefaultPlaybackParameters() {
+    assertThat(mediaClock.getPlaybackParameters()).isEqualTo(PlaybackParameters.DEFAULT);
+  }
+
+  @Test
+  public void standaloneSetPlaybackParameters_getPlaybackParametersShouldReturnSameValue() {
+    PlaybackParameters parameters = mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    assertThat(parameters).isEqualTo(TEST_PLAYBACK_PARAMETERS);
+    assertThat(mediaClock.getPlaybackParameters()).isEqualTo(TEST_PLAYBACK_PARAMETERS);
+  }
+
+  @Test
+  public void standaloneSetPlaybackParameters_shouldTriggerCallback() {
+    mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    verify(listener).onPlaybackParametersChanged(TEST_PLAYBACK_PARAMETERS);
+  }
+
+  @Test
+  public void standaloneSetPlaybackParameters_shouldApplyNewPlaybackSpeed() {
+    mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    mediaClock.start();
+    // Asserts that clock is running with speed declared in getPlaybackParameters().
+    assertClockIsRunning();
+  }
+
+  @Test
+  public void standaloneSetOtherPlaybackParameters_getPlaybackParametersShouldReturnSameValue() {
+    mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    PlaybackParameters parameters = mediaClock.setPlaybackParameters(PlaybackParameters.DEFAULT);
+    assertThat(parameters).isEqualTo(PlaybackParameters.DEFAULT);
+    assertThat(mediaClock.getPlaybackParameters()).isEqualTo(PlaybackParameters.DEFAULT);
+  }
+
+  @Test
+  public void standaloneSetOtherPlaybackParameters_shouldTriggerCallbackAgain() {
+    mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    mediaClock.setPlaybackParameters(PlaybackParameters.DEFAULT);
+    verify(listener).onPlaybackParametersChanged(PlaybackParameters.DEFAULT);
+  }
+
+  @Test
+  public void standaloneSetSamePlaybackParametersAgain_shouldTriggerCallbackAgain() {
+    mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    verify(listener, times(2)).onPlaybackParametersChanged(TEST_PLAYBACK_PARAMETERS);
+  }
+
+  @Test
+  public void enableRendererMediaClock_shouldOverwriteRendererPlaybackParametersIfPossible()
+      throws ExoPlaybackException {
+    FakeMediaClockRenderer mediaClockRenderer =
+        new MediaClockRenderer(TEST_PLAYBACK_PARAMETERS, /* playbackParametersAreMutable= */ true);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    assertThat(mediaClock.getPlaybackParameters()).isEqualTo(PlaybackParameters.DEFAULT);
+    verifyNoMoreInteractions(listener);
+  }
+
+  @Test
+  public void enableRendererMediaClockWithFixedParameters_usesRendererPlaybackParameters()
+      throws ExoPlaybackException {
+    FakeMediaClockRenderer mediaClockRenderer =
+        new MediaClockRenderer(TEST_PLAYBACK_PARAMETERS, /* playbackParametersAreMutable= */ false);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    assertThat(mediaClock.getPlaybackParameters()).isEqualTo(TEST_PLAYBACK_PARAMETERS);
+  }
+
+  @Test
+  public void enableRendererMediaClockWithFixedParameters_shouldTriggerCallback()
+      throws ExoPlaybackException {
+    FakeMediaClockRenderer mediaClockRenderer =
+        new MediaClockRenderer(TEST_PLAYBACK_PARAMETERS, /* playbackParametersAreMutable= */ false);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    verify(listener).onPlaybackParametersChanged(TEST_PLAYBACK_PARAMETERS);
+  }
+
+  @Test
+  public void enableRendererMediaClockWithFixedButSamePlaybackParameters_shouldNotTriggerCallback()
+      throws ExoPlaybackException {
+    FakeMediaClockRenderer mediaClockRenderer = new MediaClockRenderer(PlaybackParameters.DEFAULT,
+        /* playbackParametersAreMutable= */ false);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    verifyNoMoreInteractions(listener);
+  }
+
+  @Test
+  public void disableRendererMediaClock_shouldKeepPlaybackParameters()
+      throws ExoPlaybackException {
+    FakeMediaClockRenderer mediaClockRenderer =
+        new MediaClockRenderer(TEST_PLAYBACK_PARAMETERS, /* playbackParametersAreMutable= */ false);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    mediaClock.onRendererDisabled(mediaClockRenderer);
+    assertThat(mediaClock.getPlaybackParameters()).isEqualTo(TEST_PLAYBACK_PARAMETERS);
+  }
+
+  @Test
+  public void rendererClockSetPlaybackParameters_getPlaybackParametersShouldReturnSameValue()
+      throws ExoPlaybackException {
+    FakeMediaClockRenderer mediaClockRenderer = new MediaClockRenderer(PlaybackParameters.DEFAULT,
+        /* playbackParametersAreMutable= */ true);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    PlaybackParameters parameters = mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    assertThat(parameters).isEqualTo(TEST_PLAYBACK_PARAMETERS);
+    assertThat(mediaClock.getPlaybackParameters()).isEqualTo(TEST_PLAYBACK_PARAMETERS);
+  }
+
+  @Test
+  public void rendererClockSetPlaybackParameters_shouldTriggerCallback()
+      throws ExoPlaybackException {
+    FakeMediaClockRenderer mediaClockRenderer = new MediaClockRenderer(PlaybackParameters.DEFAULT,
+        /* playbackParametersAreMutable= */ true);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    verify(listener).onPlaybackParametersChanged(TEST_PLAYBACK_PARAMETERS);
+  }
+
+  @Test
+  public void rendererClockSetPlaybackParametersOverwrite_getParametersShouldReturnSameValue()
+      throws ExoPlaybackException {
+    FakeMediaClockRenderer mediaClockRenderer = new MediaClockRenderer(PlaybackParameters.DEFAULT,
+        /* playbackParametersAreMutable= */ false);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    PlaybackParameters parameters = mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    assertThat(parameters).isEqualTo(PlaybackParameters.DEFAULT);
+    assertThat(mediaClock.getPlaybackParameters()).isEqualTo(PlaybackParameters.DEFAULT);
+  }
+
+  @Test
+  public void rendererClockSetPlaybackParametersOverwrite_shouldTriggerCallback()
+      throws ExoPlaybackException {
+    FakeMediaClockRenderer mediaClockRenderer = new MediaClockRenderer(PlaybackParameters.DEFAULT,
+        /* playbackParametersAreMutable= */ false);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    mediaClock.setPlaybackParameters(TEST_PLAYBACK_PARAMETERS);
+    verify(listener).onPlaybackParametersChanged(PlaybackParameters.DEFAULT);
+  }
+
+  @Test
+  public void enableRendererMediaClock_usesRendererClockPosition() throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer = new MediaClockRenderer();
+    mediaClock.start();
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    mediaClockRenderer.positionUs = TEST_POSITION_US;
+    assertThat(mediaClock.syncAndGetPositionUs()).isEqualTo(TEST_POSITION_US);
+    // We're not advancing the renderer media clock. Thus, the clock should appear to be stopped.
+    assertClockIsStopped();
+  }
+
+  @Test
+  public void resetPositionWhileUsingRendererMediaClock_shouldHaveNoEffect()
+      throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer = new MediaClockRenderer();
+    mediaClock.start();
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    mediaClockRenderer.positionUs = TEST_POSITION_US;
+    assertThat(mediaClock.syncAndGetPositionUs()).isEqualTo(TEST_POSITION_US);
+    mediaClock.resetPosition(0);
+    assertThat(mediaClock.syncAndGetPositionUs()).isEqualTo(TEST_POSITION_US);
+  }
+
+  @Test
+  public void disableRendererMediaClock_standaloneShouldBeSynced() throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer = new MediaClockRenderer();
+    mediaClock.start();
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    mediaClockRenderer.positionUs = TEST_POSITION_US;
+    mediaClock.syncAndGetPositionUs();
+    mediaClock.onRendererDisabled(mediaClockRenderer);
+    fakeClock.advanceTime(SLEEP_TIME_MS);
+    assertThat(mediaClock.syncAndGetPositionUs())
+        .isEqualTo(TEST_POSITION_US + C.msToUs(SLEEP_TIME_MS));
+    assertClockIsRunning();
+  }
+
+  @Test
+  public void getPositionWithPlaybackParameterChange_shouldTriggerCallback()
+      throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer = new MediaClockRenderer(PlaybackParameters.DEFAULT,
+            /* playbackParametersAreMutable= */ true);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    // Silently change playback parameters of renderer clock.
+    mediaClockRenderer.playbackParameters = TEST_PLAYBACK_PARAMETERS;
+    mediaClock.syncAndGetPositionUs();
+    verify(listener).onPlaybackParametersChanged(TEST_PLAYBACK_PARAMETERS);
+  }
+
+  @Test
+  public void rendererNotReady_shouldStillUseRendererClock() throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer = new MediaClockRenderer(/* isReady= */ false,
+        /* isEnded= */ false, /* hasReadStreamToEnd= */ false);
+    mediaClock.start();
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    // We're not advancing the renderer media clock. Thus, the clock should appear to be stopped.
+    assertClockIsStopped();
+  }
+
+  @Test
+  public void rendererNotReadyAndReadStreamToEnd_shouldFallbackToStandaloneClock()
+      throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer = new MediaClockRenderer(/* isReady= */ false,
+        /* isEnded= */ false, /* hasReadStreamToEnd= */ true);
+    mediaClock.start();
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    assertClockIsRunning();
+  }
+
+  @Test
+  public void rendererEnded_shouldFallbackToStandaloneClock()
+      throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer = new MediaClockRenderer(/* isReady= */ true,
+        /* isEnded= */ true, /* hasReadStreamToEnd= */ true);
+    mediaClock.start();
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    assertClockIsRunning();
+  }
+
+  @Test
+  public void staleDisableRendererClock_shouldNotThrow()
+      throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer = new MediaClockRenderer();
+    mediaClockRenderer.positionUs = TEST_POSITION_US;
+    mediaClock.onRendererDisabled(mediaClockRenderer);
+    assertThat(mediaClock.syncAndGetPositionUs()).isEqualTo(C.msToUs(fakeClock.elapsedRealtime()));
+  }
+
+  @Test
+  public void enableSameRendererClockTwice_shouldNotThrow()
+      throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer = new MediaClockRenderer();
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    mediaClock.onRendererEnabled(mediaClockRenderer);
+    mediaClockRenderer.positionUs = TEST_POSITION_US;
+    assertThat(mediaClock.syncAndGetPositionUs()).isEqualTo(TEST_POSITION_US);
+  }
+
+  @Test
+  public void enableOtherRendererClock_shouldThrow()
+      throws ExoPlaybackException {
+    MediaClockRenderer mediaClockRenderer1 = new MediaClockRenderer();
+    MediaClockRenderer mediaClockRenderer2 = new MediaClockRenderer();
+    mediaClockRenderer1.positionUs = TEST_POSITION_US;
+    mediaClock.onRendererEnabled(mediaClockRenderer1);
+    try {
+      mediaClock.onRendererEnabled(mediaClockRenderer2);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected.
+    }
+    assertThat(mediaClock.syncAndGetPositionUs()).isEqualTo(TEST_POSITION_US);
+  }
+
+  private void assertClockIsRunning() {
+    long clockStartUs = mediaClock.syncAndGetPositionUs();
+    fakeClock.advanceTime(SLEEP_TIME_MS);
+    assertThat(mediaClock.syncAndGetPositionUs()).isEqualTo(clockStartUs
+        + mediaClock.getPlaybackParameters().getMediaTimeUsForPlayoutTimeMs(SLEEP_TIME_MS));
+  }
+
+  private void assertClockIsStopped() {
+    long positionAtStartUs = mediaClock.syncAndGetPositionUs();
+    fakeClock.advanceTime(SLEEP_TIME_MS);
+    assertThat(mediaClock.syncAndGetPositionUs()).isEqualTo(positionAtStartUs);
+  }
+
+  @SuppressWarnings("HidingField")
+  private static class MediaClockRenderer extends FakeMediaClockRenderer {
+
+    private final boolean playbackParametersAreMutable;
+    private final boolean isReady;
+    private final boolean isEnded;
+
+    public PlaybackParameters playbackParameters;
+    public long positionUs;
+
+    public MediaClockRenderer() throws ExoPlaybackException {
+      this(PlaybackParameters.DEFAULT, false, true, false, false);
+    }
+
+    public MediaClockRenderer(PlaybackParameters playbackParameters,
+        boolean playbackParametersAreMutable)
+        throws ExoPlaybackException {
+      this(playbackParameters, playbackParametersAreMutable, true, false, false);
+    }
+
+    public MediaClockRenderer(boolean isReady, boolean isEnded, boolean hasReadStreamToEnd)
+        throws ExoPlaybackException {
+      this(PlaybackParameters.DEFAULT, false, isReady, isEnded, hasReadStreamToEnd);
+    }
+
+    private MediaClockRenderer(PlaybackParameters playbackParameters,
+        boolean playbackParametersAreMutable, boolean isReady, boolean isEnded,
+        boolean hasReadStreamToEnd)
+        throws ExoPlaybackException {
+      this.playbackParameters = playbackParameters;
+      this.playbackParametersAreMutable = playbackParametersAreMutable;
+      this.isReady = isReady;
+      this.isEnded = isEnded;
+      this.positionUs = TEST_POSITION_US;
+      if (!hasReadStreamToEnd) {
+        resetPosition(0);
+      }
+    }
+
+    @Override
+    public long getPositionUs() {
+      return positionUs;
+    }
+
+    @Override
+    public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
+      if (playbackParametersAreMutable) {
+        this.playbackParameters = playbackParameters;
+      }
+      return this.playbackParameters;
+    }
+
+    @Override
+    public PlaybackParameters getPlaybackParameters() {
+      return playbackParameters;
+    }
+
+    @Override
+    public boolean isReady() {
+      return isReady;
+    }
+
+    @Override
+    public boolean isEnded() {
+      return isEnded;
+    }
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
new file mode 100644
index 0000000000..b1ddcdb207
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/ExoPlayerTest.java
@@ -0,0 +1,1949 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.view.Surface;
+import com.google.android.exoplayer2.Player.DefaultEventListener;
+import com.google.android.exoplayer2.Player.EventListener;
+import com.google.android.exoplayer2.Timeline.Window;
+import com.google.android.exoplayer2.source.ConcatenatingMediaSource;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.ads.AdPlaybackState;
+import com.google.android.exoplayer2.testutil.ActionSchedule;
+import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerRunnable;
+import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerTarget;
+import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner;
+import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner.Builder;
+import com.google.android.exoplayer2.testutil.FakeMediaClockRenderer;
+import com.google.android.exoplayer2.testutil.FakeMediaPeriod;
+import com.google.android.exoplayer2.testutil.FakeMediaSource;
+import com.google.android.exoplayer2.testutil.FakeRenderer;
+import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
+import com.google.android.exoplayer2.testutil.FakeTimeline;
+import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
+import com.google.android.exoplayer2.testutil.FakeTrackSelection;
+import com.google.android.exoplayer2.testutil.FakeTrackSelector;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.upstream.Allocator;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/** Unit test for {@link ExoPlayer}. */
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public final class ExoPlayerTest {
+
+  /**
+   * For tests that rely on the player transitioning to the ended state, the duration in
+   * milliseconds after starting the player before the test will time out. This is to catch cases
+   * where the player under test is not making progress, in which case the test should fail.
+   */
+  private static final int TIMEOUT_MS = 10000;
+
+  /**
+   * Tests playback of a source that exposes an empty timeline. Playback is expected to end without
+   * error.
+   */
+  @Test
+  public void testPlayEmptyTimeline() throws Exception {
+    Timeline timeline = Timeline.EMPTY;
+    FakeRenderer renderer = new FakeRenderer();
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setTimeline(timeline)
+            .setRenderers(renderer)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertNoPositionDiscontinuities();
+    testRunner.assertTimelinesEqual(timeline);
+    assertThat(renderer.formatReadCount).isEqualTo(0);
+    assertThat(renderer.sampleBufferReadCount).isEqualTo(0);
+    assertThat(renderer.isEnded).isFalse();
+  }
+
+  /** Tests playback of a source that exposes a single period. */
+  @Test
+  public void testPlaySinglePeriodTimeline() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    Object manifest = new Object();
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setTimeline(timeline)
+            .setManifest(manifest)
+            .setRenderers(renderer)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertNoPositionDiscontinuities();
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertManifestsEqual(manifest);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertTrackGroupsEqual(new TrackGroupArray(new TrackGroup(Builder.VIDEO_FORMAT)));
+    assertThat(renderer.formatReadCount).isEqualTo(1);
+    assertThat(renderer.sampleBufferReadCount).isEqualTo(1);
+    assertThat(renderer.isEnded).isTrue();
+  }
+
+  /** Tests playback of a source that exposes three periods. */
+  @Test
+  public void testPlayMultiPeriodTimeline() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 3);
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setTimeline(timeline)
+            .setRenderers(renderer)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityReasonsEqual(
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+    assertThat(renderer.formatReadCount).isEqualTo(3);
+    assertThat(renderer.sampleBufferReadCount).isEqualTo(3);
+    assertThat(renderer.isEnded).isTrue();
+  }
+
+  /** Tests playback of periods with very short duration. */
+  @Test
+  public void testPlayShortDurationPeriods() throws Exception {
+    // TimelineWindowDefinition.DEFAULT_WINDOW_DURATION_US / 100 = 1000 us per period.
+    Timeline timeline =
+        new FakeTimeline(new TimelineWindowDefinition(/* periodCount= */ 100, /* id= */ 0));
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setTimeline(timeline)
+            .setRenderers(renderer)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    Integer[] expectedReasons = new Integer[99];
+    Arrays.fill(expectedReasons, Player.DISCONTINUITY_REASON_PERIOD_TRANSITION);
+    testRunner.assertPositionDiscontinuityReasonsEqual(expectedReasons);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+    assertThat(renderer.formatReadCount).isEqualTo(100);
+    assertThat(renderer.sampleBufferReadCount).isEqualTo(100);
+    assertThat(renderer.isEnded).isTrue();
+  }
+
+  /**
+   * Tests that the player does not unnecessarily reset renderers when playing a multi-period
+   * source.
+   */
+  @Test
+  public void testReadAheadToEndDoesNotResetRenderer() throws Exception {
+    // Use sufficiently short periods to ensure the player attempts to read all at once.
+    TimelineWindowDefinition windowDefinition =
+        new TimelineWindowDefinition(
+            /* isSeekable= */ false, /* isDynamic= */ false, /* durationUs= */ 100_000);
+    Timeline timeline = new FakeTimeline(windowDefinition, windowDefinition, windowDefinition);
+    final FakeRenderer videoRenderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    FakeMediaClockRenderer audioRenderer =
+        new FakeMediaClockRenderer(Builder.AUDIO_FORMAT) {
+
+          @Override
+          public long getPositionUs() {
+            // Simulate the playback position lagging behind the reading position: the renderer
+            // media clock position will be the start of the timeline until the stream is set to be
+            // final, at which point it jumps to the end of the timeline allowing the playing period
+            // to advance.
+            // TODO: Avoid hard-coding ExoPlayerImplInternal.RENDERER_TIMESTAMP_OFFSET_US.
+            return isCurrentStreamFinal() ? 60000030 : 60000000;
+          }
+
+          @Override
+          public PlaybackParameters setPlaybackParameters(PlaybackParameters playbackParameters) {
+            return PlaybackParameters.DEFAULT;
+          }
+
+          @Override
+          public PlaybackParameters getPlaybackParameters() {
+            return PlaybackParameters.DEFAULT;
+          }
+
+          @Override
+          public boolean isEnded() {
+            return videoRenderer.isEnded();
+          }
+        };
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setTimeline(timeline)
+            .setRenderers(videoRenderer, audioRenderer)
+            .setSupportedFormats(Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityReasonsEqual(
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION);
+    testRunner.assertTimelinesEqual(timeline);
+    assertThat(audioRenderer.positionResetCount).isEqualTo(1);
+    assertThat(videoRenderer.isEnded).isTrue();
+    assertThat(audioRenderer.isEnded).isTrue();
+  }
+
+  @Test
+  public void testRepreparationGivesFreshSourceInfo() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    Object firstSourceManifest = new Object();
+    MediaSource firstSource =
+        new FakeMediaSource(timeline, firstSourceManifest, Builder.VIDEO_FORMAT);
+    final CountDownLatch queuedSourceInfoCountDownLatch = new CountDownLatch(1);
+    final CountDownLatch completePreparationCountDownLatch = new CountDownLatch(1);
+    MediaSource secondSource =
+        new FakeMediaSource(timeline, new Object(), Builder.VIDEO_FORMAT) {
+          @Override
+          public synchronized void prepareSource(
+              ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+            super.prepareSource(player, isTopLevelSource, listener);
+            // We've queued a source info refresh on the playback thread's event queue. Allow the
+            // test thread to prepare the player with the third source, and block this thread (the
+            // playback thread) until the test thread's call to prepare() has returned.
+            queuedSourceInfoCountDownLatch.countDown();
+            try {
+              completePreparationCountDownLatch.await();
+            } catch (InterruptedException e) {
+              throw new IllegalStateException(e);
+            }
+          }
+        };
+    Object thirdSourceManifest = new Object();
+    MediaSource thirdSource =
+        new FakeMediaSource(timeline, thirdSourceManifest, Builder.VIDEO_FORMAT);
+
+    // Prepare the player with a source with the first manifest and a non-empty timeline. Prepare
+    // the player again with a source and a new manifest, which will never be exposed. Allow the
+    // test thread to prepare the player with a third source, and block the playback thread until
+    // the test thread's call to prepare() has returned.
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testRepreparation")
+            .waitForTimelineChanged(timeline)
+            .prepareSource(secondSource)
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    try {
+                      queuedSourceInfoCountDownLatch.await();
+                    } catch (InterruptedException e) {
+                      // Ignore.
+                    }
+                  }
+                })
+            .prepareSource(thirdSource)
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    completePreparationCountDownLatch.countDown();
+                  }
+                })
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new Builder()
+            .setMediaSource(firstSource)
+            .setRenderers(renderer)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertNoPositionDiscontinuities();
+    // The first source's preparation completed with a non-empty timeline. When the player was
+    // re-prepared with the second source, it immediately exposed an empty timeline, but the source
+    // info refresh from the second source was suppressed as we re-prepared with the third source.
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, timeline);
+    testRunner.assertManifestsEqual(firstSourceManifest, null, thirdSourceManifest);
+    testRunner.assertTimelineChangeReasonsEqual(
+        Player.TIMELINE_CHANGE_REASON_PREPARED,
+        Player.TIMELINE_CHANGE_REASON_RESET,
+        Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertTrackGroupsEqual(new TrackGroupArray(new TrackGroup(Builder.VIDEO_FORMAT)));
+    assertThat(renderer.isEnded).isTrue();
+  }
+
+  @Test
+  public void testRepeatModeChanges() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 3);
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testRepeatMode")
+            .pause()
+            .waitForTimelineChanged(timeline)
+            .playUntilStartOfWindow(/* windowIndex= */ 1)
+            .setRepeatMode(Player.REPEAT_MODE_ONE)
+            .playUntilStartOfWindow(/* windowIndex= */ 1)
+            .setRepeatMode(Player.REPEAT_MODE_OFF)
+            .playUntilStartOfWindow(/* windowIndex= */ 2)
+            .setRepeatMode(Player.REPEAT_MODE_ONE)
+            .playUntilStartOfWindow(/* windowIndex= */ 2)
+            .setRepeatMode(Player.REPEAT_MODE_ALL)
+            .playUntilStartOfWindow(/* windowIndex= */ 0)
+            .setRepeatMode(Player.REPEAT_MODE_ONE)
+            .playUntilStartOfWindow(/* windowIndex= */ 0)
+            .playUntilStartOfWindow(/* windowIndex= */ 0)
+            .setRepeatMode(Player.REPEAT_MODE_OFF)
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setRenderers(renderer)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPlayedPeriodIndices(0, 1, 1, 2, 2, 0, 0, 0, 1, 2);
+    testRunner.assertPositionDiscontinuityReasonsEqual(
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+    assertThat(renderer.isEnded).isTrue();
+  }
+
+  @Test
+  public void testShuffleModeEnabledChanges() throws Exception {
+    Timeline fakeTimeline = new FakeTimeline(/* windowCount= */ 1);
+    MediaSource[] fakeMediaSources = {
+      new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
+      new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
+      new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT)
+    };
+    ConcatenatingMediaSource mediaSource =
+        new ConcatenatingMediaSource(false, new FakeShuffleOrder(3), fakeMediaSources);
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testShuffleModeEnabled")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .setRepeatMode(Player.REPEAT_MODE_ALL)
+            .playUntilStartOfWindow(/* windowIndex= */ 1)
+            .setShuffleModeEnabled(true)
+            .playUntilStartOfWindow(/* windowIndex= */ 1)
+            .setShuffleModeEnabled(false)
+            .setRepeatMode(Player.REPEAT_MODE_OFF)
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .setRenderers(renderer)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPlayedPeriodIndices(0, 1, 0, 2, 1, 2);
+    testRunner.assertPositionDiscontinuityReasonsEqual(
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION);
+    assertThat(renderer.isEnded).isTrue();
+  }
+
+  @Test
+  public void testAdGroupWithLoadErrorIsSkipped() throws Exception {
+    AdPlaybackState initialAdPlaybackState =
+        FakeTimeline.createAdPlaybackState(
+            /* adsPerAdGroup= */ 1, /* adGroupTimesUs= */ 5 * C.MICROS_PER_SECOND);
+    Timeline fakeTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* periodCount= */ 1,
+                /* id= */ 0,
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                /* durationUs= */ C.MICROS_PER_SECOND,
+                initialAdPlaybackState));
+    AdPlaybackState errorAdPlaybackState = initialAdPlaybackState.withAdLoadError(0, 0);
+    final Timeline adErrorTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* periodCount= */ 1,
+                /* id= */ 0,
+                /* isSeekable= */ true,
+                /* isDynamic= */ false,
+                /* durationUs= */ C.MICROS_PER_SECOND,
+                errorAdPlaybackState));
+    final FakeMediaSource fakeMediaSource =
+        new FakeMediaSource(fakeTimeline, /* manifest= */ null, Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testAdGroupWithLoadErrorIsSkipped")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    fakeMediaSource.setNewSourceInfo(adErrorTimeline, null);
+                  }
+                })
+            .waitForTimelineChanged(adErrorTimeline)
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(fakeMediaSource)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    // There is still one discontinuity from content to content for the failed ad insertion.
+    testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_AD_INSERTION);
+  }
+
+  @Test
+  public void testPeriodHoldersReleasedAfterSeekWithRepeatModeAll() throws Exception {
+    FakeRenderer renderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testPeriodHoldersReleased")
+            .setRepeatMode(Player.REPEAT_MODE_ALL)
+            .waitForPositionDiscontinuity()
+            .seek(0) // Seek with repeat mode set to Player.REPEAT_MODE_ALL.
+            .waitForPositionDiscontinuity()
+            .setRepeatMode(Player.REPEAT_MODE_OFF) // Turn off repeat so that playback can finish.
+            .build();
+    new Builder()
+        .setRenderers(renderer)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(renderer.isEnded).isTrue();
+  }
+
+  @Test
+  public void testSeekProcessedCallback() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 2);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSeekProcessedCallback")
+            // Initial seek. Expect immediate seek processed.
+            .pause()
+            .seek(5)
+            .waitForSeekProcessed()
+            // Multiple overlapping seeks while the player is still preparing. Expect only one seek
+            // processed.
+            .seek(2)
+            .seek(10)
+            // Wait until media source prepared and re-seek to same position. Expect a seek
+            // processed while still being in STATE_READY.
+            .waitForPlaybackState(Player.STATE_READY)
+            .seek(10)
+            // Start playback and wait until playback reaches second window.
+            .play()
+            .waitForPositionDiscontinuity()
+            // Seek twice in concession, expecting the first seek to be replaced (and thus except
+            // only on seek processed callback).
+            .seek(5)
+            .seek(60)
+            .build();
+    final List<Integer> playbackStatesWhenSeekProcessed = new ArrayList<>();
+    EventListener eventListener =
+        new DefaultEventListener() {
+          private int currentPlaybackState = Player.STATE_IDLE;
+
+          @Override
+          public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+            currentPlaybackState = playbackState;
+          }
+
+          @Override
+          public void onSeekProcessed() {
+            playbackStatesWhenSeekProcessed.add(currentPlaybackState);
+          }
+        };
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setEventListener(eventListener)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityReasonsEqual(
+        Player.DISCONTINUITY_REASON_SEEK,
+        Player.DISCONTINUITY_REASON_SEEK,
+        Player.DISCONTINUITY_REASON_SEEK,
+        Player.DISCONTINUITY_REASON_SEEK,
+        Player.DISCONTINUITY_REASON_PERIOD_TRANSITION,
+        Player.DISCONTINUITY_REASON_SEEK,
+        Player.DISCONTINUITY_REASON_SEEK);
+    assertThat(playbackStatesWhenSeekProcessed)
+        .containsExactly(
+            Player.STATE_BUFFERING,
+            Player.STATE_BUFFERING,
+            Player.STATE_READY,
+            Player.STATE_BUFFERING)
+        .inOrder();
+  }
+
+  @Test
+  public void testSeekProcessedCalledWithIllegalSeekPosition() throws Exception {
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSeekProcessedCalledWithIllegalSeekPosition")
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            // Cause an illegal seek exception by seeking to an invalid position while the media
+            // source is still being prepared and the player doesn't immediately know it will fail.
+            // Because the media source prepares immediately, the exception will be thrown when the
+            // player processed the seek.
+            .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .build();
+    final boolean[] onSeekProcessedCalled = new boolean[1];
+    EventListener listener =
+        new DefaultEventListener() {
+          @Override
+          public void onSeekProcessed() {
+            onSeekProcessedCalled[0] = true;
+          }
+        };
+    ExoPlayerTestRunner testRunner =
+        new Builder().setActionSchedule(actionSchedule).setEventListener(listener).build();
+    try {
+      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    assertThat(onSeekProcessedCalled[0]).isTrue();
+  }
+
+  @Test
+  public void testSeekDiscontinuity() throws Exception {
+    FakeTimeline timeline = new FakeTimeline(1);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSeekDiscontinuity").seek(10).build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
+  }
+
+  @Test
+  public void testSeekDiscontinuityWithAdjustment() throws Exception {
+    FakeTimeline timeline = new FakeTimeline(1);
+    FakeMediaSource mediaSource =
+        new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT) {
+          @Override
+          protected FakeMediaPeriod createFakeMediaPeriod(
+              MediaPeriodId id, TrackGroupArray trackGroupArray, Allocator allocator) {
+            FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray);
+            mediaPeriod.setSeekToUsOffset(10);
+            return mediaPeriod;
+          }
+        };
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSeekDiscontinuityAdjust")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .seek(10)
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityReasonsEqual(
+        Player.DISCONTINUITY_REASON_SEEK, Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT);
+  }
+
+  @Test
+  public void testInternalDiscontinuityAtNewPosition() throws Exception {
+    FakeTimeline timeline = new FakeTimeline(1);
+    FakeMediaSource mediaSource =
+        new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT) {
+          @Override
+          protected FakeMediaPeriod createFakeMediaPeriod(
+              MediaPeriodId id, TrackGroupArray trackGroupArray, Allocator allocator) {
+            FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray);
+            mediaPeriod.setDiscontinuityPositionUs(10);
+            return mediaPeriod;
+          }
+        };
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_INTERNAL);
+  }
+
+  @Test
+  public void testInternalDiscontinuityAtInitialPosition() throws Exception {
+    FakeTimeline timeline = new FakeTimeline(1);
+    FakeMediaSource mediaSource =
+        new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT) {
+          @Override
+          protected FakeMediaPeriod createFakeMediaPeriod(
+              MediaPeriodId id, TrackGroupArray trackGroupArray, Allocator allocator) {
+            FakeMediaPeriod mediaPeriod = new FakeMediaPeriod(trackGroupArray);
+            mediaPeriod.setDiscontinuityPositionUs(0);
+            return mediaPeriod;
+          }
+        };
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    // If the position is unchanged we do not expect the discontinuity to be reported externally.
+    testRunner.assertNoPositionDiscontinuities();
+  }
+
+  @Test
+  public void testAllActivatedTrackSelectionAreReleasedForSinglePeriod() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    MediaSource mediaSource =
+        new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT);
+    FakeRenderer videoRenderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    FakeRenderer audioRenderer = new FakeRenderer(Builder.AUDIO_FORMAT);
+    FakeTrackSelector trackSelector = new FakeTrackSelector();
+
+    new Builder()
+        .setMediaSource(mediaSource)
+        .setRenderers(videoRenderer, audioRenderer)
+        .setTrackSelector(trackSelector)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    List<FakeTrackSelection> createdTrackSelections = trackSelector.getSelectedTrackSelections();
+    int numSelectionsEnabled = 0;
+    // Assert that all tracks selection are disabled at the end of the playback.
+    for (FakeTrackSelection trackSelection : createdTrackSelections) {
+      assertThat(trackSelection.isEnabled).isFalse();
+      numSelectionsEnabled += trackSelection.enableCount;
+    }
+    // There are 2 renderers, and track selections are made once (1 period).
+    // Track selections are not reused, so there are 2 track selections made.
+    assertThat(createdTrackSelections).hasSize(2);
+    // There should be 2 track selections enabled in total.
+    assertThat(numSelectionsEnabled).isEqualTo(2);
+  }
+
+  @Test
+  public void testAllActivatedTrackSelectionAreReleasedForMultiPeriods() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 2);
+    MediaSource mediaSource =
+        new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT);
+    FakeRenderer videoRenderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    FakeRenderer audioRenderer = new FakeRenderer(Builder.AUDIO_FORMAT);
+    FakeTrackSelector trackSelector = new FakeTrackSelector();
+
+    new Builder()
+        .setMediaSource(mediaSource)
+        .setRenderers(videoRenderer, audioRenderer)
+        .setTrackSelector(trackSelector)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    List<FakeTrackSelection> createdTrackSelections = trackSelector.getSelectedTrackSelections();
+    int numSelectionsEnabled = 0;
+    // Assert that all tracks selection are disabled at the end of the playback.
+    for (FakeTrackSelection trackSelection : createdTrackSelections) {
+      assertThat(trackSelection.isEnabled).isFalse();
+      numSelectionsEnabled += trackSelection.enableCount;
+    }
+    // There are 2 renderers, and track selections are made twice (2 periods).
+    // Track selections are not reused, so there are 4 track selections made.
+    assertThat(createdTrackSelections).hasSize(4);
+    // There should be 4 track selections enabled in total.
+    assertThat(numSelectionsEnabled).isEqualTo(4);
+  }
+
+  @Test
+  public void testAllActivatedTrackSelectionAreReleasedWhenTrackSelectionsAreRemade()
+      throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    MediaSource mediaSource =
+        new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT);
+    FakeRenderer videoRenderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    FakeRenderer audioRenderer = new FakeRenderer(Builder.AUDIO_FORMAT);
+    final FakeTrackSelector trackSelector = new FakeTrackSelector();
+    ActionSchedule disableTrackAction =
+        new ActionSchedule.Builder("testChangeTrackSelection")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    trackSelector.setRendererDisabled(0, true);
+                  }
+                })
+            .play()
+            .build();
+
+    new Builder()
+        .setMediaSource(mediaSource)
+        .setRenderers(videoRenderer, audioRenderer)
+        .setTrackSelector(trackSelector)
+        .setActionSchedule(disableTrackAction)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    List<FakeTrackSelection> createdTrackSelections = trackSelector.getSelectedTrackSelections();
+    int numSelectionsEnabled = 0;
+    // Assert that all tracks selection are disabled at the end of the playback.
+    for (FakeTrackSelection trackSelection : createdTrackSelections) {
+      assertThat(trackSelection.isEnabled).isFalse();
+      numSelectionsEnabled += trackSelection.enableCount;
+    }
+    // There are 2 renderers, and track selections are made twice.
+    // Track selections are not reused, so there are 4 track selections made.
+    assertThat(createdTrackSelections).hasSize(4);
+    // Initially there are 2 track selections enabled.
+    // The second time one renderer is disabled, so only 1 track selection should be enabled.
+    assertThat(numSelectionsEnabled).isEqualTo(3);
+  }
+
+  @Test
+  public void testAllActivatedTrackSelectionAreReleasedWhenTrackSelectionsAreUsed()
+      throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    MediaSource mediaSource =
+        new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT, Builder.AUDIO_FORMAT);
+    FakeRenderer videoRenderer = new FakeRenderer(Builder.VIDEO_FORMAT);
+    FakeRenderer audioRenderer = new FakeRenderer(Builder.AUDIO_FORMAT);
+    final FakeTrackSelector trackSelector = new FakeTrackSelector(/* reuse track selection */ true);
+    ActionSchedule disableTrackAction =
+        new ActionSchedule.Builder("testReuseTrackSelection")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    trackSelector.setRendererDisabled(0, true);
+                  }
+                })
+            .play()
+            .build();
+
+    new Builder()
+        .setMediaSource(mediaSource)
+        .setRenderers(videoRenderer, audioRenderer)
+        .setTrackSelector(trackSelector)
+        .setActionSchedule(disableTrackAction)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+
+    List<FakeTrackSelection> createdTrackSelections = trackSelector.getSelectedTrackSelections();
+    int numSelectionsEnabled = 0;
+    // Assert that all tracks selection are disabled at the end of the playback.
+    for (FakeTrackSelection trackSelection : createdTrackSelections) {
+      assertThat(trackSelection.isEnabled).isFalse();
+      numSelectionsEnabled += trackSelection.enableCount;
+    }
+    // There are 2 renderers, and track selections are made twice.
+    // TrackSelections are reused, so there are only 2 track selections made for 2 renderers.
+    assertThat(createdTrackSelections).hasSize(2);
+    // Initially there are 2 track selections enabled.
+    // The second time one renderer is disabled, so only 1 track selection should be enabled.
+    assertThat(numSelectionsEnabled).isEqualTo(3);
+  }
+
+  @Test
+  public void testDynamicTimelineChangeReason() throws Exception {
+    Timeline timeline1 = new FakeTimeline(new TimelineWindowDefinition(false, false, 100000));
+    final Timeline timeline2 = new FakeTimeline(new TimelineWindowDefinition(false, false, 20000));
+    final FakeMediaSource mediaSource = new FakeMediaSource(timeline1, null, Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testDynamicTimelineChangeReason")
+            .pause()
+            .waitForTimelineChanged(timeline1)
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    mediaSource.setNewSourceInfo(timeline2, null);
+                  }
+                })
+            .waitForTimelineChanged(timeline2)
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertTimelinesEqual(timeline1, timeline2);
+    testRunner.assertTimelineChangeReasonsEqual(
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_DYNAMIC);
+  }
+
+  @Test
+  public void testRepreparationWithPositionResetAndShufflingUsesFirstPeriod() throws Exception {
+    Timeline fakeTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                /* isSeekable= */ true, /* isDynamic= */ false, /* durationUs= */ 100000));
+    ConcatenatingMediaSource firstMediaSource =
+        new ConcatenatingMediaSource(
+            /* isAtomic= */ false,
+            new FakeShuffleOrder(/* length= */ 2),
+            new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
+            new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT));
+    ConcatenatingMediaSource secondMediaSource =
+        new ConcatenatingMediaSource(
+            /* isAtomic= */ false,
+            new FakeShuffleOrder(/* length= */ 2),
+            new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
+            new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT));
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testRepreparationWithShuffle")
+            // Wait for first preparation and enable shuffling. Plays period 0.
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .setShuffleModeEnabled(true)
+            // Reprepare with second media source (keeping state, but with position reset).
+            // Plays period 1 and 0 because of the reversed fake shuffle order.
+            .prepareSource(secondMediaSource, /* resetPosition= */ true, /* resetState= */ false)
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(firstMediaSource)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPlayedPeriodIndices(0, 1, 0);
+  }
+
+  @Test
+  public void testSetPlaybackParametersBeforePreparationCompletesSucceeds() throws Exception {
+    // Test that no exception is thrown when playback parameters are updated between creating a
+    // period and preparation of the period completing.
+    final CountDownLatch createPeriodCalledCountDownLatch = new CountDownLatch(1);
+    final FakeMediaPeriod[] fakeMediaPeriodHolder = new FakeMediaPeriod[1];
+    MediaSource mediaSource =
+        new FakeMediaSource(new FakeTimeline(/* windowCount= */ 1), null, Builder.VIDEO_FORMAT) {
+          @Override
+          protected FakeMediaPeriod createFakeMediaPeriod(
+              MediaPeriodId id, TrackGroupArray trackGroupArray, Allocator allocator) {
+            // Defer completing preparation of the period until playback parameters have been set.
+            fakeMediaPeriodHolder[0] =
+                new FakeMediaPeriod(trackGroupArray, /* deferOnPrepared= */ true);
+            createPeriodCalledCountDownLatch.countDown();
+            return fakeMediaPeriodHolder[0];
+          }
+        };
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSetPlaybackParametersBeforePreparationCompletesSucceeds")
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            // Block until createPeriod has been called on the fake media source.
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    try {
+                      createPeriodCalledCountDownLatch.await();
+                    } catch (InterruptedException e) {
+                      throw new IllegalStateException(e);
+                    }
+                  }
+                })
+            // Set playback parameters (while the fake media period is not yet prepared).
+            .setPlaybackParameters(new PlaybackParameters(2f, 2f))
+            // Complete preparation of the fake media period.
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    fakeMediaPeriodHolder[0].setPreparationComplete();
+                  }
+                })
+            .build();
+    new ExoPlayerTestRunner.Builder()
+        .setMediaSource(mediaSource)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+  }
+
+  @Test
+  public void testStopDoesNotResetPosition() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    final long[] positionHolder = new long[1];
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testStopDoesNotResetPosition")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 50)
+            .stop()
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    positionHolder[0] = player.getCurrentPosition();
+                  }
+                })
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilActionScheduleFinished(TIMEOUT_MS)
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertNoPositionDiscontinuities();
+    assertThat(positionHolder[0]).isAtLeast(50L);
+  }
+
+  @Test
+  public void testStopWithoutResetDoesNotResetPosition() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    final long[] positionHolder = new long[1];
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testStopWithoutResetDoesNotReset")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 50)
+            .stop(/* reset= */ false)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    positionHolder[0] = player.getCurrentPosition();
+                  }
+                })
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilActionScheduleFinished(TIMEOUT_MS)
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertNoPositionDiscontinuities();
+    assertThat(positionHolder[0]).isAtLeast(50L);
+  }
+
+  @Test
+  public void testStopWithResetDoesResetPosition() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    final long[] positionHolder = new long[1];
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testStopWithResetDoesReset")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 50)
+            .stop(/* reset= */ true)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    positionHolder[0] = player.getCurrentPosition();
+                  }
+                })
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilActionScheduleFinished(TIMEOUT_MS)
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY);
+    testRunner.assertTimelineChangeReasonsEqual(
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_RESET);
+    testRunner.assertNoPositionDiscontinuities();
+    assertThat(positionHolder[0]).isEqualTo(0);
+  }
+
+  @Test
+  public void testStopWithoutResetReleasesMediaSource() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    final FakeMediaSource mediaSource =
+        new FakeMediaSource(timeline, /* manifest= */ null, Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testStopReleasesMediaSource")
+            .waitForPlaybackState(Player.STATE_READY)
+            .stop(/* reset= */ false)
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilActionScheduleFinished(TIMEOUT_MS);
+    mediaSource.assertReleased();
+    testRunner.blockUntilEnded(TIMEOUT_MS);
+  }
+
+  @Test
+  public void testStopWithResetReleasesMediaSource() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    final FakeMediaSource mediaSource =
+        new FakeMediaSource(timeline, /* manifest= */ null, Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testStopReleasesMediaSource")
+            .waitForPlaybackState(Player.STATE_READY)
+            .stop(/* reset= */ true)
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilActionScheduleFinished(TIMEOUT_MS);
+    mediaSource.assertReleased();
+    testRunner.blockUntilEnded(TIMEOUT_MS);
+  }
+
+  @Test
+  public void testRepreparationDoesNotResetAfterStopWithReset() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    MediaSource secondSource = new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testRepreparationAfterStop")
+            .waitForPlaybackState(Player.STATE_READY)
+            .stop(/* reset= */ true)
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .prepareSource(secondSource)
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .setExpectedPlayerEndedCount(2)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, timeline);
+    testRunner.assertTimelineChangeReasonsEqual(
+        Player.TIMELINE_CHANGE_REASON_PREPARED,
+        Player.TIMELINE_CHANGE_REASON_RESET,
+        Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertNoPositionDiscontinuities();
+  }
+
+  @Test
+  public void testSeekBeforeRepreparationPossibleAfterStopWithReset() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    Timeline secondTimeline = new FakeTimeline(/* windowCount= */ 2);
+    MediaSource secondSource = new FakeMediaSource(secondTimeline, null, Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSeekAfterStopWithReset")
+            .waitForPlaybackState(Player.STATE_READY)
+            .stop(/* reset= */ true)
+            .waitForPlaybackState(Player.STATE_IDLE)
+            // If we were still using the first timeline, this would throw.
+            .seek(/* windowIndex= */ 1, /* positionMs= */ 0)
+            .prepareSource(secondSource, /* resetPosition= */ false, /* resetState= */ true)
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .setExpectedPlayerEndedCount(2)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertTimelinesEqual(timeline, Timeline.EMPTY, secondTimeline);
+    testRunner.assertTimelineChangeReasonsEqual(
+        Player.TIMELINE_CHANGE_REASON_PREPARED,
+        Player.TIMELINE_CHANGE_REASON_RESET,
+        Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
+    testRunner.assertPlayedPeriodIndices(0, 1);
+  }
+
+  @Test
+  public void testStopDuringPreparationOverwritesPreparation() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testStopOverwritesPrepare")
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .seek(0)
+            .stop(true)
+            .waitForSeekProcessed()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilActionScheduleFinished(TIMEOUT_MS)
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertTimelinesEqual(Timeline.EMPTY);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
+  }
+
+  @Test
+  public void testStopAndSeekAfterStopDoesNotResetTimeline() throws Exception {
+    // Combining additional stop and seek after initial stop in one test to get the seek processed
+    // callback which ensures that all operations have been processed by the player.
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testStopTwice")
+            .waitForPlaybackState(Player.STATE_READY)
+            .stop(false)
+            .stop(false)
+            .seek(0)
+            .waitForSeekProcessed()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilActionScheduleFinished(TIMEOUT_MS)
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
+  }
+
+  @Test
+  public void testReprepareAfterPlaybackError() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testReprepareAfterPlaybackError")
+            .waitForPlaybackState(Player.STATE_READY)
+            .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .prepareSource(
+                new FakeMediaSource(timeline, /* manifest= */ null),
+                /* resetPosition= */ true,
+                /* resetState= */ false)
+            .waitForPlaybackState(Player.STATE_READY)
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build();
+    try {
+      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    testRunner.assertTimelinesEqual(timeline, timeline);
+    testRunner.assertTimelineChangeReasonsEqual(
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_PREPARED);
+  }
+
+  @Test
+  public void testSeekAndReprepareAfterPlaybackError() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    final long[] positionHolder = new long[2];
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testReprepareAfterPlaybackError")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .seek(/* positionMs= */ 50)
+            .waitForSeekProcessed()
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    positionHolder[0] = player.getCurrentPosition();
+                  }
+                })
+            .prepareSource(
+                new FakeMediaSource(timeline, /* manifest= */ null),
+                /* resetPosition= */ false,
+                /* resetState= */ false)
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    positionHolder[1] = player.getCurrentPosition();
+                  }
+                })
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build();
+    try {
+      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    testRunner.assertTimelinesEqual(timeline, timeline);
+    testRunner.assertTimelineChangeReasonsEqual(
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_PREPARED);
+    testRunner.assertPositionDiscontinuityReasonsEqual(Player.DISCONTINUITY_REASON_SEEK);
+    assertThat(positionHolder[0]).isEqualTo(50);
+    assertThat(positionHolder[1]).isEqualTo(50);
+  }
+
+  @Test
+  public void testPlaybackErrorDuringSourceInfoRefreshStillUpdatesTimeline() throws Exception {
+    final Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    final FakeMediaSource mediaSource =
+        new FakeMediaSource(/* timeline= */ null, /* manifest= */ null);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testPlaybackErrorDuringSourceInfoRefreshStillUpdatesTimeline")
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            // Cause an internal exception by seeking to an invalid position while the media source
+            // is still being prepared. The error will be thrown while the player handles the new
+            // source info.
+            .seek(/* windowIndex= */ 100, /* positionMs= */ 0)
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    mediaSource.setNewSourceInfo(timeline, /* newManifest= */ null);
+                  }
+                })
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .setActionSchedule(actionSchedule)
+            .build();
+    try {
+      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    testRunner.assertTimelinesEqual(timeline);
+    testRunner.assertTimelineChangeReasonsEqual(Player.TIMELINE_CHANGE_REASON_PREPARED);
+  }
+
+  @Test
+  public void testPlaybackErrorAndReprepareDoesNotResetPosition() throws Exception {
+    final Timeline timeline = new FakeTimeline(/* windowCount= */ 2);
+    final long[] positionHolder = new long[3];
+    final int[] windowIndexHolder = new int[3];
+    final FakeMediaSource secondMediaSource =
+        new FakeMediaSource(/* timeline= */ null, /* manifest= */ null);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testPlaybackErrorDoesNotResetPosition")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .playUntilPosition(/* windowIndex= */ 1, /* positionMs= */ 500)
+            .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    // Position while in error state
+                    positionHolder[0] = player.getCurrentPosition();
+                    windowIndexHolder[0] = player.getCurrentWindowIndex();
+                  }
+                })
+            .prepareSource(secondMediaSource, /* resetPosition= */ false, /* resetState= */ false)
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    // Position while repreparing.
+                    positionHolder[1] = player.getCurrentPosition();
+                    windowIndexHolder[1] = player.getCurrentWindowIndex();
+                    secondMediaSource.setNewSourceInfo(timeline, /* newManifest= */ null);
+                  }
+                })
+            .waitForPlaybackState(Player.STATE_READY)
+            .executeRunnable(
+                new PlayerRunnable() {
+                  @Override
+                  public void run(SimpleExoPlayer player) {
+                    // Position after repreparation finished.
+                    positionHolder[2] = player.getCurrentPosition();
+                    windowIndexHolder[2] = player.getCurrentWindowIndex();
+                  }
+                })
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build();
+    try {
+      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    assertThat(positionHolder[0]).isAtLeast(500L);
+    assertThat(positionHolder[1]).isEqualTo(positionHolder[0]);
+    assertThat(positionHolder[2]).isEqualTo(positionHolder[0]);
+    assertThat(windowIndexHolder[0]).isEqualTo(1);
+    assertThat(windowIndexHolder[1]).isEqualTo(1);
+    assertThat(windowIndexHolder[2]).isEqualTo(1);
+  }
+
+  @Test
+  public void testPlaybackErrorTwiceStillKeepsTimeline() throws Exception {
+    final Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    final FakeMediaSource mediaSource2 =
+        new FakeMediaSource(/* timeline= */ null, /* manifest= */ null);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testPlaybackErrorDoesNotResetPosition")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .prepareSource(mediaSource2, /* resetPosition= */ false, /* resetState= */ false)
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .throwPlaybackException(ExoPlaybackException.createForSource(new IOException()))
+            .waitForPlaybackState(Player.STATE_IDLE)
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setTimeline(timeline)
+            .setActionSchedule(actionSchedule)
+            .build();
+    try {
+      testRunner.start().blockUntilActionScheduleFinished(TIMEOUT_MS).blockUntilEnded(TIMEOUT_MS);
+      fail();
+    } catch (ExoPlaybackException e) {
+      // Expected exception.
+    }
+    testRunner.assertTimelinesEqual(timeline, timeline);
+    testRunner.assertTimelineChangeReasonsEqual(
+        Player.TIMELINE_CHANGE_REASON_PREPARED, Player.TIMELINE_CHANGE_REASON_PREPARED);
+  }
+
+  @Test
+  public void testSendMessagesDuringPreparation() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(target, /* positionMs= */ 50)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testSendMessagesAfterPreparation() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForTimelineChanged(timeline)
+            .sendMessage(target, /* positionMs= */ 50)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testMultipleSendMessages() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target50 = new PositionGrabbingMessageTarget();
+    PositionGrabbingMessageTarget target80 = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(target80, /* positionMs= */ 80)
+            .sendMessage(target50, /* positionMs= */ 50)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target50.positionMs >= 50).isTrue();
+    assertThat(target80.positionMs >= 80).isTrue();
+    assertThat(target80.positionMs).isAtLeast(target50.positionMs);
+  }
+
+  @Test
+  public void testMultipleSendMessagesAtSameTime() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target1 = new PositionGrabbingMessageTarget();
+    PositionGrabbingMessageTarget target2 = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(target1, /* positionMs= */ 50)
+            .sendMessage(target2, /* positionMs= */ 50)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target1.positionMs >= 50).isTrue();
+    assertThat(target2.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testSendMessagesMultiPeriodResolution() throws Exception {
+    Timeline timeline =
+        new FakeTimeline(new TimelineWindowDefinition(/* periodCount= */ 10, /* id= */ 0));
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(target, /* positionMs= */ 50)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testSendMessagesAtStartAndEndOfPeriod() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 2);
+    PositionGrabbingMessageTarget targetStartFirstPeriod = new PositionGrabbingMessageTarget();
+    PositionGrabbingMessageTarget targetEndMiddlePeriod = new PositionGrabbingMessageTarget();
+    PositionGrabbingMessageTarget targetStartMiddlePeriod = new PositionGrabbingMessageTarget();
+    PositionGrabbingMessageTarget targetEndLastPeriod = new PositionGrabbingMessageTarget();
+    long duration1Ms = timeline.getWindow(0, new Window()).getDurationMs();
+    long duration2Ms = timeline.getWindow(1, new Window()).getDurationMs();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(targetStartFirstPeriod, /* windowIndex= */ 0, /* positionMs= */ 0)
+            .sendMessage(targetEndMiddlePeriod, /* windowIndex= */ 0, /* positionMs= */ duration1Ms)
+            .sendMessage(targetStartMiddlePeriod, /* windowIndex= */ 1, /* positionMs= */ 0)
+            .sendMessage(targetEndLastPeriod, /* windowIndex= */ 1, /* positionMs= */ duration2Ms)
+            .play()
+            // Add additional prepare at end and wait until it's processed to ensure that
+            // messages sent at end of playback are received before test ends.
+            .waitForPlaybackState(Player.STATE_ENDED)
+            .prepareSource(
+                new FakeMediaSource(timeline, null),
+                /* resetPosition= */ false,
+                /* resetState= */ true)
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .waitForPlaybackState(Player.STATE_ENDED)
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilActionScheduleFinished(TIMEOUT_MS)
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(targetStartFirstPeriod.windowIndex).isEqualTo(0);
+    assertThat(targetStartFirstPeriod.positionMs).isAtLeast(0L);
+    assertThat(targetEndMiddlePeriod.windowIndex).isEqualTo(0);
+    assertThat(targetEndMiddlePeriod.positionMs).isAtLeast(duration1Ms);
+    assertThat(targetStartMiddlePeriod.windowIndex).isEqualTo(1);
+    assertThat(targetStartMiddlePeriod.positionMs).isAtLeast(0L);
+    assertThat(targetEndLastPeriod.windowIndex).isEqualTo(1);
+    assertThat(targetEndLastPeriod.positionMs).isAtLeast(duration2Ms);
+  }
+
+  @Test
+  public void testSendMessagesSeekOnDeliveryTimeDuringPreparation() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(target, /* positionMs= */ 50)
+            .seek(/* positionMs= */ 50)
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testSendMessagesSeekOnDeliveryTimeAfterPreparation() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(target, /* positionMs= */ 50)
+            .waitForTimelineChanged(timeline)
+            .seek(/* positionMs= */ 50)
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testSendMessagesSeekAfterDeliveryTimeDuringPreparation() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(target, /* positionMs= */ 50)
+            .seek(/* positionMs= */ 51)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.positionMs).isEqualTo(C.POSITION_UNSET);
+  }
+
+  @Test
+  public void testSendMessagesSeekAfterDeliveryTimeAfterPreparation() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .sendMessage(target, /* positionMs= */ 50)
+            .waitForTimelineChanged(timeline)
+            .seek(/* positionMs= */ 51)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.positionMs).isEqualTo(C.POSITION_UNSET);
+  }
+
+  @Test
+  public void testSendMessagesRepeatDoesNotRepost() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(target, /* positionMs= */ 50)
+            .setRepeatMode(Player.REPEAT_MODE_ALL)
+            .play()
+            .waitForPositionDiscontinuity()
+            .setRepeatMode(Player.REPEAT_MODE_OFF)
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.messageCount).isEqualTo(1);
+    assertThat(target.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testSendMessagesRepeatWithoutDeletingDoesRepost() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 1);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(
+                target,
+                /* windowIndex= */ 0,
+                /* positionMs= */ 50,
+                /* deleteAfterDelivery= */ false)
+            .setRepeatMode(Player.REPEAT_MODE_ALL)
+            .playUntilPosition(/* windowIndex= */ 0, /* positionMs= */ 1)
+            .playUntilStartOfWindow(/* windowIndex= */ 0)
+            .setRepeatMode(Player.REPEAT_MODE_OFF)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.messageCount).isEqualTo(2);
+    assertThat(target.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testSendMessagesMoveCurrentWindowIndex() throws Exception {
+    Timeline timeline =
+        new FakeTimeline(new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 0));
+    final Timeline secondTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 1),
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 0));
+    final FakeMediaSource mediaSource = new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForTimelineChanged(timeline)
+            .sendMessage(target, /* positionMs= */ 50)
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    mediaSource.setNewSourceInfo(secondTimeline, null);
+                  }
+                })
+            .waitForTimelineChanged(secondTimeline)
+            .play()
+            .build();
+    new Builder()
+        .setMediaSource(mediaSource)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.windowIndex).isEqualTo(1);
+  }
+
+  @Test
+  public void testSendMessagesMultiWindowDuringPreparation() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 3);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_BUFFERING)
+            .sendMessage(target, /* windowIndex = */ 2, /* positionMs= */ 50)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.windowIndex).isEqualTo(2);
+    assertThat(target.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testSendMessagesMultiWindowAfterPreparation() throws Exception {
+    Timeline timeline = new FakeTimeline(/* windowCount= */ 3);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForTimelineChanged(timeline)
+            .sendMessage(target, /* windowIndex = */ 2, /* positionMs= */ 50)
+            .play()
+            .build();
+    new Builder()
+        .setTimeline(timeline)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.windowIndex).isEqualTo(2);
+    assertThat(target.positionMs >= 50).isTrue();
+  }
+
+  @Test
+  public void testSendMessagesMoveWindowIndex() throws Exception {
+    Timeline timeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 0),
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 1));
+    final Timeline secondTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 1),
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 0));
+    final FakeMediaSource mediaSource = new FakeMediaSource(timeline, null, Builder.VIDEO_FORMAT);
+    PositionGrabbingMessageTarget target = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForTimelineChanged(timeline)
+            .sendMessage(target, /* windowIndex = */ 1, /* positionMs= */ 50)
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    mediaSource.setNewSourceInfo(secondTimeline, null);
+                  }
+                })
+            .waitForTimelineChanged(secondTimeline)
+            .seek(/* windowIndex= */ 0, /* positionMs= */ 0)
+            .play()
+            .build();
+    new Builder()
+        .setMediaSource(mediaSource)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target.positionMs >= 50).isTrue();
+    assertThat(target.windowIndex).isEqualTo(0);
+  }
+
+  @Test
+  public void testSendMessagesNonLinearPeriodOrder() throws Exception {
+    Timeline fakeTimeline = new FakeTimeline(/* windowCount= */ 1);
+    MediaSource[] fakeMediaSources = {
+      new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
+      new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT),
+      new FakeMediaSource(fakeTimeline, null, Builder.VIDEO_FORMAT)
+    };
+    ConcatenatingMediaSource mediaSource =
+        new ConcatenatingMediaSource(false, new FakeShuffleOrder(3), fakeMediaSources);
+    PositionGrabbingMessageTarget target1 = new PositionGrabbingMessageTarget();
+    PositionGrabbingMessageTarget target2 = new PositionGrabbingMessageTarget();
+    PositionGrabbingMessageTarget target3 = new PositionGrabbingMessageTarget();
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testSendMessages")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            .sendMessage(target1, /* windowIndex = */ 0, /* positionMs= */ 50)
+            .sendMessage(target2, /* windowIndex = */ 1, /* positionMs= */ 50)
+            .sendMessage(target3, /* windowIndex = */ 2, /* positionMs= */ 50)
+            .setShuffleModeEnabled(true)
+            .seek(/* windowIndex= */ 2, /* positionMs= */ 0)
+            .play()
+            .build();
+    new ExoPlayerTestRunner.Builder()
+        .setMediaSource(mediaSource)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(target1.windowIndex).isEqualTo(0);
+    assertThat(target2.windowIndex).isEqualTo(1);
+    assertThat(target3.windowIndex).isEqualTo(2);
+  }
+
+  @Test
+  public void testSetAndSwitchSurface() throws Exception {
+    final List<Integer> rendererMessages = new ArrayList<>();
+    Renderer videoRenderer =
+        new FakeRenderer(Builder.VIDEO_FORMAT) {
+          @Override
+          public void handleMessage(int what, Object object) throws ExoPlaybackException {
+            super.handleMessage(what, object);
+            rendererMessages.add(what);
+          }
+        };
+    ActionSchedule actionSchedule =
+        addSurfaceSwitch(new ActionSchedule.Builder("testSetAndSwitchSurface")).build();
+    new ExoPlayerTestRunner.Builder()
+        .setRenderers(videoRenderer)
+        .setActionSchedule(actionSchedule)
+        .build()
+        .start()
+        .blockUntilActionScheduleFinished(TIMEOUT_MS)
+        .blockUntilEnded(TIMEOUT_MS);
+    assertThat(Collections.frequency(rendererMessages, C.MSG_SET_SURFACE)).isEqualTo(2);
+  }
+
+  @Test
+  public void testSwitchSurfaceOnEndedState() throws Exception {
+    ActionSchedule.Builder scheduleBuilder =
+        new ActionSchedule.Builder("testSwitchSurfaceOnEndedState")
+            .waitForPlaybackState(Player.STATE_ENDED);
+    ActionSchedule waitForEndedAndSwitchSchedule = addSurfaceSwitch(scheduleBuilder).build();
+    new ExoPlayerTestRunner.Builder()
+        .setTimeline(Timeline.EMPTY)
+        .setActionSchedule(waitForEndedAndSwitchSchedule)
+        .build()
+        .start()
+        .blockUntilActionScheduleFinished(TIMEOUT_MS)
+        .blockUntilEnded(TIMEOUT_MS);
+  }
+
+  @Test
+  public void testTimelineUpdateDropsPrebufferedPeriods() throws Exception {
+    Timeline timeline1 =
+        new FakeTimeline(
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 1),
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 2));
+    final Timeline timeline2 =
+        new FakeTimeline(
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 1),
+            new TimelineWindowDefinition(/* periodCount= */ 1, /* id= */ 3));
+    final FakeMediaSource mediaSource =
+        new FakeMediaSource(timeline1, /* manifest= */ null, Builder.VIDEO_FORMAT);
+    ActionSchedule actionSchedule =
+        new ActionSchedule.Builder("testTimelineUpdateDropsPeriods")
+            .pause()
+            .waitForPlaybackState(Player.STATE_READY)
+            // Ensure next period is pre-buffered by playing until end of first period.
+            .playUntilPosition(
+                /* windowIndex= */ 0,
+                /* positionMs= */ C.usToMs(TimelineWindowDefinition.DEFAULT_WINDOW_DURATION_US))
+            .executeRunnable(
+                new Runnable() {
+                  @Override
+                  public void run() {
+                    mediaSource.setNewSourceInfo(timeline2, /* newManifest= */ null);
+                  }
+                })
+            .waitForTimelineChanged(timeline2)
+            .play()
+            .build();
+    ExoPlayerTestRunner testRunner =
+        new ExoPlayerTestRunner.Builder()
+            .setMediaSource(mediaSource)
+            .setActionSchedule(actionSchedule)
+            .build()
+            .start()
+            .blockUntilEnded(TIMEOUT_MS);
+    testRunner.assertPlayedPeriodIndices(0, 1);
+    // Assert that the second period was re-created from the new timeline.
+    assertThat(mediaSource.getCreatedMediaPeriods())
+        .containsExactly(
+            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0),
+            new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 1),
+            new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 2))
+        .inOrder();
+  }
+
+  // Internal methods.
+
+  private static ActionSchedule.Builder addSurfaceSwitch(ActionSchedule.Builder builder) {
+    final Surface surface1 = new Surface(null);
+    final Surface surface2 = new Surface(null);
+    return builder
+        .executeRunnable(
+            new PlayerRunnable() {
+              @Override
+              public void run(SimpleExoPlayer player) {
+                player.setVideoSurface(surface1);
+              }
+            })
+        .executeRunnable(
+            new PlayerRunnable() {
+              @Override
+              public void run(SimpleExoPlayer player) {
+                player.setVideoSurface(surface2);
+              }
+            });
+  }
+
+  // Internal classes.
+
+  private static final class PositionGrabbingMessageTarget extends PlayerTarget {
+
+    public int windowIndex;
+    public long positionMs;
+    public int messageCount;
+
+    public PositionGrabbingMessageTarget() {
+      windowIndex = C.INDEX_UNSET;
+      positionMs = C.POSITION_UNSET;
+    }
+
+    @Override
+    public void handleMessage(SimpleExoPlayer player, int messageType, Object message) {
+      windowIndex = player.getCurrentWindowIndex();
+      positionMs = player.getCurrentPosition();
+      messageCount++;
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java b/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
index 33e1a673bd..eb51485a36 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/FormatTest.java
@@ -39,13 +39,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link Format}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class FormatTest {
 
   private static final List<byte[]> INIT_DATA;
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/TimelineTest.java b/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java
similarity index 83%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/TimelineTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java
index f5c33843a1..b5457555ab 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/TimelineTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/TimelineTest.java
@@ -18,23 +18,26 @@
 import com.google.android.exoplayer2.testutil.FakeTimeline;
 import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
 import com.google.android.exoplayer2.testutil.TimelineAsserts;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link Timeline}.
- */
-public class TimelineTest extends TestCase {
+/** Unit test for {@link Timeline}. */
+@RunWith(RobolectricTestRunner.class)
+public class TimelineTest {
 
+  @Test
   public void testEmptyTimeline() {
     TimelineAsserts.assertEmpty(Timeline.EMPTY);
   }
 
+  @Test
   public void testSinglePeriodTimeline() {
     Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(1, 111));
     TimelineAsserts.assertWindowIds(timeline, 111);
     TimelineAsserts.assertPeriodCounts(timeline, 1);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET);
     TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0);
     TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 0);
     TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET);
@@ -42,12 +45,13 @@ public void testSinglePeriodTimeline() {
     TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 0);
   }
 
+  @Test
   public void testMultiPeriodTimeline() {
     Timeline timeline = new FakeTimeline(new TimelineWindowDefinition(5, 111));
     TimelineAsserts.assertWindowIds(timeline, 111);
     TimelineAsserts.assertPeriodCounts(timeline, 5);
-    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_OFF, false,
-        C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET);
     TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0);
     TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 0);
     TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java
index 346b94e5f4..9d5533e8ab 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRendererTest.java
@@ -46,7 +46,6 @@
  * Unit test for {@link SimpleDecoderAudioRenderer}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class SimpleDecoderAudioRendererTest {
 
   private static final Format FORMAT = Format.createSampleFormat(null, MimeTypes.AUDIO_RAW, 0);
@@ -90,8 +89,13 @@ public void testSupportsFormatAtApi21() {
 
   @Test
   public void testImmediatelyReadEndOfStreamPlaysAudioSinkToEndOfStream() throws Exception {
-    audioRenderer.enable(RendererConfiguration.DEFAULT, new Format[] {FORMAT},
-        new FakeSampleStream(FORMAT), 0, false, 0);
+    audioRenderer.enable(
+        RendererConfiguration.DEFAULT,
+        new Format[] {FORMAT},
+        new FakeSampleStream(FORMAT, false),
+        0,
+        false,
+        0);
     audioRenderer.setCurrentStreamFinal();
     when(mockAudioSink.isEnded()).thenReturn(true);
     while (!audioRenderer.isEnded()) {
@@ -116,7 +120,7 @@ public String getName() {
 
     @Override
     protected DecoderInputBuffer createInputBuffer() {
-      return new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
+      return new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DIRECT);
     }
 
     @Override
@@ -124,6 +128,11 @@ protected SimpleOutputBuffer createOutputBuffer() {
       return new SimpleOutputBuffer(this);
     }
 
+    @Override
+    protected AudioDecoderException createUnexpectedDecodeException(Throwable error) {
+      return new AudioDecoderException("Unexpected decode error", error);
+    }
+
     @Override
     protected AudioDecoderException decode(DecoderInputBuffer inputBuffer,
         SimpleOutputBuffer outputBuffer, boolean reset) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java
index a4f02f8257..d060ba3f16 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/audio/SonicAudioProcessorTest.java
@@ -23,13 +23,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link SonicAudioProcessor}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class SonicAudioProcessorTest {
 
   private SonicAudioProcessor sonicAudioProcessor;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java
index 01ab9ea9aa..c84ca6182c 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/drm/ClearKeyUtilTest.java
@@ -19,7 +19,6 @@
 
 import com.google.android.exoplayer2.C;
 import java.nio.charset.Charset;
-import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -32,7 +31,7 @@
 @RunWith(RobolectricTestRunner.class)
 public final class ClearKeyUtilTest {
 
-  @Config(sdk = 26, manifest = Config.NONE)
+  @Config(sdk = 26)
   @Test
   public void testAdjustResponseDataV26() {
     byte[] data = ("{\"keys\":[{"
@@ -47,10 +46,10 @@ public void testAdjustResponseDataV26() {
         + "\"kid\":\"ab\\/cde+f\"}],"
         + "\"type\":\"abc_def-"
         + "\"}").getBytes(Charset.forName(C.UTF8_NAME));
-    assertThat(Arrays.equals(expected, ClearKeyUtil.adjustResponseData(data))).isTrue();
+    assertThat(ClearKeyUtil.adjustResponseData(data)).isEqualTo(expected);
   }
 
-  @Config(sdk = 26, manifest = Config.NONE)
+  @Config(sdk = 26)
   @Test
   public void testAdjustRequestDataV26() {
     byte[] data = "{\"kids\":[\"abc+def/\",\"ab+cde/f\"],\"type\":\"abc+def/\"}"
@@ -58,7 +57,7 @@ public void testAdjustRequestDataV26() {
     // We expect "+" and "/" to be replaced with "-" and "_" respectively, for "kids".
     byte[] expected = "{\"kids\":[\"abc-def_\",\"ab-cde_f\"],\"type\":\"abc+def/\"}"
         .getBytes(Charset.forName(C.UTF8_NAME));
-    assertThat(Arrays.equals(expected, ClearKeyUtil.adjustRequestData(data))).isTrue();
+    assertThat(ClearKeyUtil.adjustRequestData(data)).isEqualTo(expected);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java b/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
index 9fc6e801d3..2b3bdd6a2f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/drm/DrmInitDataTest.java
@@ -30,13 +30,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link DrmInitData}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class DrmInitDataTest {
 
   private static final SchemeData DATA_1 = new SchemeData(WIDEVINE_UUID, VIDEO_MP4,
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java b/library/core/src/test/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
similarity index 65%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
index 22ae57932b..6f62b7fcfc 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/drm/OfflineLicenseHelperTest.java
@@ -15,41 +15,49 @@
  */
 package com.google.android.exoplayer2.drm;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.when;
 
-import android.test.InstrumentationTestCase;
-import android.test.MoreAsserts;
 import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
 import java.util.HashMap;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
-/**
- * Tests {@link OfflineLicenseHelper}.
- */
-public class OfflineLicenseHelperTest extends InstrumentationTestCase {
+/** Tests {@link OfflineLicenseHelper}. */
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public class OfflineLicenseHelperTest {
 
   private OfflineLicenseHelper<?> offlineLicenseHelper;
   @Mock private MediaDrmCallback mediaDrmCallback;
   @Mock private ExoMediaDrm<ExoMediaCrypto> mediaDrm;
 
-  @Override
-  protected void setUp() throws Exception {
-    setUpMockito(this);
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
     when(mediaDrm.openSession()).thenReturn(new byte[] {1, 2, 3});
-    offlineLicenseHelper = new OfflineLicenseHelper<>(C.WIDEVINE_UUID, mediaDrm, mediaDrmCallback,
-        null);
+    offlineLicenseHelper =
+        new OfflineLicenseHelper<>(C.WIDEVINE_UUID, mediaDrm, mediaDrmCallback, null);
   }
 
-  @Override
-  protected void tearDown() throws Exception {
+  @After
+  public void tearDown() throws Exception {
     offlineLicenseHelper.release();
     offlineLicenseHelper = null;
   }
 
+  @Test
   public void testDownloadRenewReleaseKey() throws Exception {
     setStubLicenseAndPlaybackDurationValues(1000, 200);
 
@@ -70,6 +78,7 @@ public void testDownloadRenewReleaseKey() throws Exception {
     offlineLicenseHelper.releaseLicense(offlineLicenseKeySetId2);
   }
 
+  @Test
   public void testDownloadLicenseFailsIfNullInitData() throws Exception {
     try {
       offlineLicenseHelper.downloadLicense(null);
@@ -79,22 +88,25 @@ public void testDownloadLicenseFailsIfNullInitData() throws Exception {
     }
   }
 
+  @Test
   public void testDownloadLicenseFailsIfNoKeySetIdIsReturned() throws Exception {
     setStubLicenseAndPlaybackDurationValues(1000, 200);
 
     byte[] offlineLicenseKeySetId = offlineLicenseHelper.downloadLicense(newDrmInitData());
 
-    assertNull(offlineLicenseKeySetId);
+    assertThat(offlineLicenseKeySetId).isNull();
   }
 
+  @Test
   public void testDownloadLicenseDoesNotFailIfDurationNotAvailable() throws Exception {
     setDefaultStubKeySetId();
 
     byte[] offlineLicenseKeySetId = offlineLicenseHelper.downloadLicense(newDrmInitData());
 
-    assertNotNull(offlineLicenseKeySetId);
+    assertThat(offlineLicenseKeySetId).isNotNull();
   }
 
+  @Test
   public void testGetLicenseDurationRemainingSec() throws Exception {
     long licenseDuration = 1000;
     int playbackDuration = 200;
@@ -103,13 +115,14 @@ public void testGetLicenseDurationRemainingSec() throws Exception {
 
     byte[] offlineLicenseKeySetId = offlineLicenseHelper.downloadLicense(newDrmInitData());
 
-    Pair<Long, Long> licenseDurationRemainingSec = offlineLicenseHelper
-        .getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+    Pair<Long, Long> licenseDurationRemainingSec =
+        offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId);
 
-    assertEquals(licenseDuration, (long) licenseDurationRemainingSec.first);
-    assertEquals(playbackDuration, (long) licenseDurationRemainingSec.second);
+    assertThat(licenseDurationRemainingSec.first).isEqualTo(licenseDuration);
+    assertThat(licenseDurationRemainingSec.second).isEqualTo(playbackDuration);
   }
 
+  @Test
   public void testGetLicenseDurationRemainingSecExpiredLicense() throws Exception {
     long licenseDuration = 0;
     int playbackDuration = 0;
@@ -118,11 +131,11 @@ public void testGetLicenseDurationRemainingSecExpiredLicense() throws Exception
 
     byte[] offlineLicenseKeySetId = offlineLicenseHelper.downloadLicense(newDrmInitData());
 
-    Pair<Long, Long> licenseDurationRemainingSec = offlineLicenseHelper
-        .getLicenseDurationRemainingSec(offlineLicenseKeySetId);
+    Pair<Long, Long> licenseDurationRemainingSec =
+        offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId);
 
-    assertEquals(licenseDuration, (long) licenseDurationRemainingSec.first);
-    assertEquals(playbackDuration, (long) licenseDurationRemainingSec.second);
+    assertThat(licenseDurationRemainingSec.first).isEqualTo(licenseDuration);
+    assertThat(licenseDurationRemainingSec.second).isEqualTo(playbackDuration);
   }
 
   private void setDefaultStubKeySetId()
@@ -137,33 +150,22 @@ private void setStubKeySetId(byte[] keySetId)
 
   private static void assertOfflineLicenseKeySetIdEqual(
       byte[] expectedKeySetId, byte[] actualKeySetId) throws Exception {
-    assertNotNull(actualKeySetId);
-    MoreAsserts.assertEquals(expectedKeySetId, actualKeySetId);
+    assertThat(actualKeySetId).isNotNull();
+    assertThat(actualKeySetId).isEqualTo(expectedKeySetId);
   }
 
-  private void setStubLicenseAndPlaybackDurationValues(long licenseDuration,
-      long playbackDuration) {
+  private void setStubLicenseAndPlaybackDurationValues(
+      long licenseDuration, long playbackDuration) {
     HashMap<String, String> keyStatus = new HashMap<>();
-    keyStatus.put(WidevineUtil.PROPERTY_LICENSE_DURATION_REMAINING,
-        String.valueOf(licenseDuration));
-    keyStatus.put(WidevineUtil.PROPERTY_PLAYBACK_DURATION_REMAINING,
-        String.valueOf(playbackDuration));
+    keyStatus.put(
+        WidevineUtil.PROPERTY_LICENSE_DURATION_REMAINING, String.valueOf(licenseDuration));
+    keyStatus.put(
+        WidevineUtil.PROPERTY_PLAYBACK_DURATION_REMAINING, String.valueOf(playbackDuration));
     when(mediaDrm.queryKeyStatus(any(byte[].class))).thenReturn(keyStatus);
   }
 
   private static DrmInitData newDrmInitData() {
-    return new DrmInitData(new SchemeData(C.WIDEVINE_UUID, "mimeType",
-        new byte[] {1, 4, 7, 0, 3, 6}));
-  }
-
-  /**
-   * Sets up Mockito for an instrumentation test.
-   */
-  private static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
-    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
-    System.setProperty("dexmaker.dexcache",
-        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
-    MockitoAnnotations.initMocks(instrumentationTestCase);
+    return new DrmInitData(
+        new SchemeData(C.WIDEVINE_UUID, "mimeType", new byte[] {1, 4, 7, 0, 3, 6}));
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
index 8e27c4f7ca..a96dfaf2f8 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/DefaultExtractorInputTest.java
@@ -31,13 +31,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link DefaultExtractorInput}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class DefaultExtractorInputTest {
 
   private static final String TEST_URI = "http://www.google.com";
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
index fc31a7be73..3271e1ddf6 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ExtractorTest.java
@@ -21,13 +21,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link Extractor}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ExtractorTest {
 
   @Test
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
similarity index 67%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
index fc8d181eac..5a093988dd 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/flv/FlvExtractorTest.java
@@ -15,23 +15,26 @@
  */
 package com.google.android.exoplayer2.extractor.flv;
 
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link FlvExtractor}.
- */
-public final class FlvExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link FlvExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class FlvExtractorTest {
 
+  @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new FlvExtractor();
-      }
-    }, "flv/sample.flv", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new FlvExtractor();
+          }
+        },
+        "flv/sample.flv");
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
index 708ffde080..e44da0404b 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/DefaultEbmlReaderTest.java
@@ -27,13 +27,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests {@link DefaultEbmlReader}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class DefaultEbmlReaderTest {
 
   @Test
@@ -91,6 +89,14 @@ public void testStringElement() throws IOException, InterruptedException {
     assertEvents(input, expected.events);
   }
 
+  @Test
+  public void testStringElementWithZeroPadding() throws IOException, InterruptedException {
+    ExtractorInput input = createTestInput(0x42, 0x82, 0x86, 0x41, 0x62, 0x63, 0x00, 0x00, 0x00);
+    TestOutput expected = new TestOutput();
+    expected.stringElement(TestOutput.ID_DOC_TYPE, "Abc");
+    assertEvents(input, expected.events);
+  }
+
   @Test
   public void testStringElementEmpty() throws IOException, InterruptedException {
     ExtractorInput input = createTestInput(0x42, 0x82, 0x80);
@@ -142,10 +148,7 @@ private static void assertEvents(ExtractorInput input, List<String> expectedEven
     // Check that we really did get to the end of input.
     assertThat(input.readFully(new byte[1], 0, 1, true)).isFalse();
 
-    assertThat(output.events).hasSize(expectedEvents.size());
-    for (int i = 0; i < expectedEvents.size(); i++) {
-      assertThat(output.events.get(i)).isEqualTo(expectedEvents.get(i));
-    }
+    assertThat(output.events).containsExactlyElementsIn(expectedEvents).inOrder();
   }
 
   /**
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
similarity index 53%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
index 624a5ccb7e..4a0f87a80a 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java
@@ -15,41 +15,50 @@
  */
 package com.google.android.exoplayer2.extractor.mkv;
 
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link MatroskaExtractor}.
- */
-public final class MatroskaExtractorTest extends InstrumentationTestCase {
+/** Tests for {@link MatroskaExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class MatroskaExtractorTest {
 
+  @Test
   public void testMkvSample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new MatroskaExtractor();
-      }
-    }, "mkv/sample.mkv", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new MatroskaExtractor();
+          }
+        },
+        "mkv/sample.mkv");
   }
 
+  @Test
   public void testWebmSubsampleEncryption() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new MatroskaExtractor();
-      }
-    }, "mkv/subsample_encrypted_noaltref.webm", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new MatroskaExtractor();
+          }
+        },
+        "mkv/subsample_encrypted_noaltref.webm");
   }
 
+  @Test
   public void testWebmSubsampleEncryptionWithAltrefFrames() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new MatroskaExtractor();
-      }
-    }, "mkv/subsample_encrypted_altref.webm", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new MatroskaExtractor();
+          }
+        },
+        "mkv/subsample_encrypted_altref.webm");
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
index bda93db812..a13a185b3e 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mkv/VarintReaderTest.java
@@ -29,13 +29,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link VarintReader}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class VarintReaderTest {
 
   private static final byte MAX_BYTE = (byte) 0xFF;
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
similarity index 59%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
index 0f98624d69..b977766a1c 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/Mp3ExtractorTest.java
@@ -15,32 +15,38 @@
  */
 package com.google.android.exoplayer2.extractor.mp3;
 
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link Mp3Extractor}.
- */
-public final class Mp3ExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link Mp3Extractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class Mp3ExtractorTest {
 
+  @Test
   public void testMp3Sample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new Mp3Extractor();
-      }
-    }, "mp3/bear.mp3", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new Mp3Extractor();
+          }
+        },
+        "mp3/bear.mp3");
   }
 
+  @Test
   public void testTrimmedMp3Sample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new Mp3Extractor();
-      }
-    }, "mp3/play-trimmed.mp3", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new Mp3Extractor();
+          }
+        },
+        "mp3/play-trimmed.mp3");
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
index b43949b7c2..6df40b5dcc 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp3/XingSeekerTest.java
@@ -19,19 +19,19 @@
 
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.MpegAudioHeader;
+import com.google.android.exoplayer2.extractor.SeekMap.SeekPoints;
+import com.google.android.exoplayer2.extractor.SeekPoint;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import com.google.android.exoplayer2.util.Util;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link XingSeeker}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class XingSeekerTest {
 
   // Xing header/payload from http://storage.googleapis.com/exoplayer-test-media-0/play.mp3.
@@ -43,17 +43,17 @@
   private static final int XING_FRAME_POSITION = 157;
 
   /**
-   * Size of the audio stream, encoded in {@link #XING_FRAME_PAYLOAD}.
+   * Data size, as encoded in {@link #XING_FRAME_PAYLOAD}.
    */
-  private static final int STREAM_SIZE_BYTES = 948505;
+  private static final int DATA_SIZE_BYTES = 948505;
   /**
    * Duration of the audio stream in microseconds, encoded in {@link #XING_FRAME_PAYLOAD}.
    */
   private static final int STREAM_DURATION_US = 59271836;
   /**
-   * The length of the file in bytes.
+   * The length of the stream in bytes.
    */
-  private static final int INPUT_LENGTH = 948662;
+  private static final int STREAM_LENGTH = XING_FRAME_POSITION + DATA_SIZE_BYTES;
 
   private XingSeeker seeker;
   private XingSeeker seekerWithInputLength;
@@ -63,10 +63,10 @@
   public void setUp() throws Exception {
     MpegAudioHeader xingFrameHeader = new MpegAudioHeader();
     MpegAudioHeader.populateHeader(XING_FRAME_HEADER_DATA, xingFrameHeader);
-    seeker = XingSeeker.create(xingFrameHeader, new ParsableByteArray(XING_FRAME_PAYLOAD),
-        XING_FRAME_POSITION, C.LENGTH_UNSET);
-    seekerWithInputLength = XingSeeker.create(xingFrameHeader,
-        new ParsableByteArray(XING_FRAME_PAYLOAD), XING_FRAME_POSITION, INPUT_LENGTH);
+    seeker = XingSeeker.create(C.LENGTH_UNSET, XING_FRAME_POSITION, xingFrameHeader,
+        new ParsableByteArray(XING_FRAME_PAYLOAD));
+    seekerWithInputLength = XingSeeker.create(STREAM_LENGTH,
+        XING_FRAME_POSITION, xingFrameHeader, new ParsableByteArray(XING_FRAME_PAYLOAD));
     xingFrameSize = xingFrameHeader.frameSize;
   }
 
@@ -84,35 +84,47 @@ public void testGetTimeUsAtFirstAudioFrame() {
 
   @Test
   public void testGetTimeUsAtEndOfStream() {
-    assertThat(seeker.getTimeUs(XING_FRAME_POSITION + xingFrameSize + STREAM_SIZE_BYTES))
+    assertThat(seeker.getTimeUs(STREAM_LENGTH))
         .isEqualTo(STREAM_DURATION_US);
     assertThat(
-        seekerWithInputLength.getTimeUs(XING_FRAME_POSITION + xingFrameSize + STREAM_SIZE_BYTES))
+        seekerWithInputLength.getTimeUs(STREAM_LENGTH))
         .isEqualTo(STREAM_DURATION_US);
   }
 
   @Test
-  public void testGetPositionAtStartOfStream() {
-    assertThat(seeker.getPosition(0)).isEqualTo(XING_FRAME_POSITION + xingFrameSize);
-    assertThat(seekerWithInputLength.getPosition(0)).isEqualTo(XING_FRAME_POSITION + xingFrameSize);
+  public void testGetSeekPointsAtStartOfStream() {
+    SeekPoints seekPoints = seeker.getSeekPoints(0);
+    SeekPoint seekPoint = seekPoints.first;
+    assertThat(seekPoint).isEqualTo(seekPoints.second);
+    assertThat(seekPoint.timeUs).isEqualTo(0);
+    assertThat(seekPoint.position).isEqualTo(XING_FRAME_POSITION + xingFrameSize);
   }
 
   @Test
-  public void testGetPositionAtEndOfStream() {
-    assertThat(seeker.getPosition(STREAM_DURATION_US))
-        .isEqualTo(XING_FRAME_POSITION + STREAM_SIZE_BYTES - 1);
-    assertThat(seekerWithInputLength.getPosition(STREAM_DURATION_US))
-        .isEqualTo(XING_FRAME_POSITION + STREAM_SIZE_BYTES - 1);
+  public void testGetSeekPointsAtEndOfStream() {
+    SeekPoints seekPoints = seeker.getSeekPoints(STREAM_DURATION_US);
+    SeekPoint seekPoint = seekPoints.first;
+    assertThat(seekPoint).isEqualTo(seekPoints.second);
+    assertThat(seekPoint.timeUs).isEqualTo(STREAM_DURATION_US);
+    assertThat(seekPoint.position).isEqualTo(STREAM_LENGTH - 1);
   }
 
   @Test
   public void testGetTimeForAllPositions() {
-    for (int offset = xingFrameSize; offset < STREAM_SIZE_BYTES; offset++) {
+    for (int offset = xingFrameSize; offset < DATA_SIZE_BYTES; offset++) {
       int position = XING_FRAME_POSITION + offset;
+      // Test seeker.
       long timeUs = seeker.getTimeUs(position);
-      assertThat(seeker.getPosition(timeUs)).isEqualTo(position);
+      SeekPoints seekPoints = seeker.getSeekPoints(timeUs);
+      SeekPoint seekPoint = seekPoints.first;
+      assertThat(seekPoint).isEqualTo(seekPoints.second);
+      assertThat(seekPoint.position).isEqualTo(position);
+      // Test seekerWithInputLength.
       timeUs = seekerWithInputLength.getTimeUs(position);
-      assertThat(seekerWithInputLength.getPosition(timeUs)).isEqualTo(position);
+      seekPoints = seekerWithInputLength.getSeekPoints(timeUs);
+      seekPoint = seekPoints.first;
+      assertThat(seekPoint).isEqualTo(seekPoints.second);
+      assertThat(seekPoint.position).isEqualTo(position);
     }
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
index b0c37ee452..9c7f0e8acc 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/AtomParsersTest.java
@@ -22,13 +22,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link AtomParsers}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class AtomParsersTest {
 
   private static final String ATOM_HEADER = "000000000000000000000000";
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
similarity index 55%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
index c9364aa605..f5b0f48592 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4ExtractorTest.java
@@ -15,39 +15,43 @@
  */
 package com.google.android.exoplayer2.extractor.mp4;
 
-import android.test.InstrumentationTestCase;
+import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link FragmentedMp4Extractor}.
- */
-public final class FragmentedMp4ExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link FragmentedMp4Extractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class FragmentedMp4ExtractorTest {
 
+  @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(getExtractorFactory(), "mp4/sample_fragmented.mp4",
-        getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        getExtractorFactory(Collections.<Format>emptyList()), "mp4/sample_fragmented.mp4");
   }
 
+  @Test
   public void testSampleWithSeiPayloadParsing() throws Exception {
     // Enabling the CEA-608 track enables SEI payload parsing.
-    ExtractorAsserts.assertBehavior(
-        getExtractorFactory(FragmentedMp4Extractor.FLAG_ENABLE_CEA608_TRACK),
-        "mp4/sample_fragmented_sei.mp4", getInstrumentation());
+    ExtractorFactory extractorFactory =
+        getExtractorFactory(
+            Collections.singletonList(
+                Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608, 0, null)));
+    ExtractorAsserts.assertBehavior(extractorFactory, "mp4/sample_fragmented_sei.mp4");
   }
 
-  private static ExtractorFactory getExtractorFactory() {
-    return getExtractorFactory(0);
-  }
-
-  private static ExtractorFactory getExtractorFactory(final int flags) {
+  private static ExtractorFactory getExtractorFactory(final List<Format> closedCaptionFormats) {
     return new ExtractorFactory() {
       @Override
       public Extractor create() {
-        return new FragmentedMp4Extractor(flags, null);
+        return new FragmentedMp4Extractor(0, null, null, null, closedCaptionFormats);
       }
     };
   }
-
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
similarity index 69%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
index 5e327e5502..f1812a69c4 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/Mp4ExtractorTest.java
@@ -16,24 +16,27 @@
 package com.google.android.exoplayer2.extractor.mp4;
 
 import android.annotation.TargetApi;
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link Mp4Extractor}.
- */
+/** Tests for {@link Mp4Extractor}. */
 @TargetApi(16)
-public final class Mp4ExtractorTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+public final class Mp4ExtractorTest {
 
+  @Test
   public void testMp4Sample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new Mp4Extractor();
-      }
-    }, "mp4/sample.mp4", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new Mp4Extractor();
+          }
+        },
+        "mp4/sample.mp4");
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java
index 4d7931cc02..d7a13ab061 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/mp4/PsshAtomUtilTest.java
@@ -27,13 +27,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link PsshAtomUtil}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class PsshAtomUtilTest {
 
   @Test
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
similarity index 63%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
index cb1751d43b..993bb86b48 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerTest.java
@@ -15,18 +15,24 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+import static org.junit.Assert.fail;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.io.IOException;
 import java.util.Random;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link DefaultOggSeeker}.
- */
-public final class DefaultOggSeekerTest extends TestCase {
+/** Unit test for {@link DefaultOggSeeker}. */
+@RunWith(RobolectricTestRunner.class)
+public final class DefaultOggSeekerTest {
 
+  @Test
   public void testSetupWithUnsetEndPositionFails() {
     try {
       new DefaultOggSeeker(0, C.LENGTH_UNSET, new TestStreamReader(), 1, 1);
@@ -36,6 +42,7 @@ public void testSetupWithUnsetEndPositionFails() {
     }
   }
 
+  @Test
   public void testSeeking() throws IOException, InterruptedException {
     Random random = new Random(0);
     for (int i = 0; i < 100; i++) {
@@ -47,8 +54,13 @@ private void testSeeking(Random random) throws IOException, InterruptedException
     OggTestFile testFile = OggTestFile.generate(random, 1000);
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(testFile.data).build();
     TestStreamReader streamReader = new TestStreamReader();
-    DefaultOggSeeker oggSeeker = new DefaultOggSeeker(0, testFile.data.length, streamReader,
-        testFile.firstPayloadPageSize, testFile.firstPayloadPageGranulePosition);
+    DefaultOggSeeker oggSeeker =
+        new DefaultOggSeeker(
+            0,
+            testFile.data.length,
+            streamReader,
+            testFile.firstPayloadPageSize,
+            testFile.firstPayloadPageGranulePosition);
     OggPageHeader pageHeader = new OggPageHeader();
 
     while (true) {
@@ -60,28 +72,33 @@ private void testSeeking(Random random) throws IOException, InterruptedException
     }
 
     // Test granule 0 from file start
-    assertEquals(0, seekTo(input, oggSeeker, 0, 0));
-    assertEquals(0, input.getPosition());
+    assertThat(seekTo(input, oggSeeker, 0, 0)).isEqualTo(0);
+    assertThat(input.getPosition()).isEqualTo(0);
 
     // Test granule 0 from file end
-    assertEquals(0, seekTo(input, oggSeeker, 0, testFile.data.length - 1));
-    assertEquals(0, input.getPosition());
+    assertThat(seekTo(input, oggSeeker, 0, testFile.data.length - 1)).isEqualTo(0);
+    assertThat(input.getPosition()).isEqualTo(0);
 
     { // Test last granule
       long currentGranule = seekTo(input, oggSeeker, testFile.lastGranule, 0);
       long position = testFile.data.length;
-      assertTrue((testFile.lastGranule > currentGranule && position > input.getPosition())
-          || (testFile.lastGranule == currentGranule && position == input.getPosition()));
+      assertThat(
+              (testFile.lastGranule > currentGranule && position > input.getPosition())
+                  || (testFile.lastGranule == currentGranule && position == input.getPosition()))
+          .isTrue();
     }
 
     { // Test exact granule
       input.setPosition(testFile.data.length / 2);
       oggSeeker.skipToNextPage(input);
-      assertTrue(pageHeader.populate(input, true));
+      assertThat(pageHeader.populate(input, true)).isTrue();
       long position = input.getPosition() + pageHeader.headerSize + pageHeader.bodySize;
       long currentGranule = seekTo(input, oggSeeker, pageHeader.granulePosition, 0);
-      assertTrue((pageHeader.granulePosition > currentGranule && position > input.getPosition())
-          || (pageHeader.granulePosition == currentGranule && position == input.getPosition()));
+      assertThat(
+              (pageHeader.granulePosition > currentGranule && position > input.getPosition())
+                  || (pageHeader.granulePosition == currentGranule
+                      && position == input.getPosition()))
+          .isTrue();
     }
 
     for (int i = 0; i < 100; i += 1) {
@@ -91,16 +108,17 @@ private void testSeeking(Random random) throws IOException, InterruptedException
       long currentGranule = seekTo(input, oggSeeker, targetGranule, initialPosition);
       long currentPosition = input.getPosition();
 
-      assertTrue("getNextSeekPosition() didn't leave input on a page start.",
-          pageHeader.populate(input, true));
+      assertWithMessage("getNextSeekPosition() didn't leave input on a page start.")
+          .that(pageHeader.populate(input, true))
+          .isTrue();
 
       if (currentGranule == 0) {
-        assertEquals(0, currentPosition);
+        assertThat(currentPosition).isEqualTo(0);
       } else {
         int previousPageStart = testFile.findPreviousPageStart(currentPosition);
         input.setPosition(previousPageStart);
-        assertTrue(pageHeader.populate(input, true));
-        assertEquals(pageHeader.granulePosition, currentGranule);
+        assertThat(pageHeader.populate(input, true)).isTrue();
+        assertThat(currentGranule).isEqualTo(pageHeader.granulePosition);
       }
 
       input.setPosition((int) currentPosition);
@@ -110,14 +128,19 @@ private void testSeeking(Random random) throws IOException, InterruptedException
       long granuleDiff = currentGranule - targetGranule;
       if ((granuleDiff > DefaultOggSeeker.MATCH_RANGE || granuleDiff < 0)
           && positionDiff > DefaultOggSeeker.MATCH_BYTE_RANGE) {
-        fail("granuleDiff (" + granuleDiff + ") or positionDiff (" + positionDiff
-            + ") is more than allowed.");
+        fail(
+            "granuleDiff ("
+                + granuleDiff
+                + ") or positionDiff ("
+                + positionDiff
+                + ") is more than allowed.");
       }
     }
   }
 
-  private long seekTo(FakeExtractorInput input, DefaultOggSeeker oggSeeker, long targetGranule,
-      int initialPosition) throws IOException, InterruptedException {
+  private long seekTo(
+      FakeExtractorInput input, DefaultOggSeeker oggSeeker, long targetGranule, int initialPosition)
+      throws IOException, InterruptedException {
     long nextSeekPosition = initialPosition;
     int count = 0;
     oggSeeker.resetSeeking();
@@ -141,8 +164,8 @@ protected long preparePayload(ParsableByteArray packet) {
     }
 
     @Override
-    protected boolean readHeaders(ParsableByteArray packet, long position,
-        SetupData setupData) throws IOException, InterruptedException {
+    protected boolean readHeaders(ParsableByteArray packet, long position, SetupData setupData)
+        throws IOException, InterruptedException {
       return false;
     }
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
index a3f7e9a548..be771ac3b9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/DefaultOggSeekerUtilMethodsTest.java
@@ -28,13 +28,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link DefaultOggSeeker} utility methods.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class DefaultOggSeekerUtilMethodsTest {
 
   private final Random random = new Random(0);
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
similarity index 53%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
index b1ebdf3261..20808f73f2 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggExtractorTest.java
@@ -15,7 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
-import android.test.InstrumentationTestCase;
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
@@ -23,84 +24,100 @@
 import com.google.android.exoplayer2.testutil.OggTestData;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link OggExtractor}.
- */
-public final class OggExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link OggExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class OggExtractorTest {
 
-  private static final ExtractorFactory OGG_EXTRACTOR_FACTORY = new ExtractorFactory() {
-    @Override
-    public Extractor create() {
-      return new OggExtractor();
-    }
-  };
+  private static final ExtractorFactory OGG_EXTRACTOR_FACTORY =
+      new ExtractorFactory() {
+        @Override
+        public Extractor create() {
+          return new OggExtractor();
+        }
+      };
 
+  @Test
   public void testOpus() throws Exception {
-    ExtractorAsserts.assertBehavior(OGG_EXTRACTOR_FACTORY, "ogg/bear.opus", getInstrumentation());
+    ExtractorAsserts.assertBehavior(OGG_EXTRACTOR_FACTORY, "ogg/bear.opus");
   }
 
+  @Test
   public void testFlac() throws Exception {
-    ExtractorAsserts.assertBehavior(OGG_EXTRACTOR_FACTORY, "ogg/bear_flac.ogg",
-        getInstrumentation());
+    ExtractorAsserts.assertBehavior(OGG_EXTRACTOR_FACTORY, "ogg/bear_flac.ogg");
   }
 
+  @Test
   public void testFlacNoSeektable() throws Exception {
-    ExtractorAsserts.assertBehavior(OGG_EXTRACTOR_FACTORY, "ogg/bear_flac_noseektable.ogg",
-        getInstrumentation());
+    ExtractorAsserts.assertBehavior(OGG_EXTRACTOR_FACTORY, "ogg/bear_flac_noseektable.ogg");
   }
 
+  @Test
   public void testVorbis() throws Exception {
-    ExtractorAsserts.assertBehavior(OGG_EXTRACTOR_FACTORY, "ogg/bear_vorbis.ogg",
-        getInstrumentation());
+    ExtractorAsserts.assertBehavior(OGG_EXTRACTOR_FACTORY, "ogg/bear_vorbis.ogg");
   }
 
+  @Test
   public void testSniffVorbis() throws Exception {
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x02, 0, 1000, 1),
-        TestUtil.createByteArray(7),  // Laces
-        new byte[] {0x01, 'v', 'o', 'r', 'b', 'i', 's'});
-    assertTrue(sniff(data));
+    byte[] data =
+        TestUtil.joinByteArrays(
+            OggTestData.buildOggHeader(0x02, 0, 1000, 1),
+            TestUtil.createByteArray(7), // Laces
+            new byte[] {0x01, 'v', 'o', 'r', 'b', 'i', 's'});
+    assertThat(sniff(data)).isTrue();
   }
 
+  @Test
   public void testSniffFlac() throws Exception {
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x02, 0, 1000, 1),
-        TestUtil.createByteArray(5),  // Laces
-        new byte[] {0x7F, 'F', 'L', 'A', 'C'});
-    assertTrue(sniff(data));
+    byte[] data =
+        TestUtil.joinByteArrays(
+            OggTestData.buildOggHeader(0x02, 0, 1000, 1),
+            TestUtil.createByteArray(5), // Laces
+            new byte[] {0x7F, 'F', 'L', 'A', 'C'});
+    assertThat(sniff(data)).isTrue();
   }
 
+  @Test
   public void testSniffFailsOpusFile() throws Exception {
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x02, 0, 1000, 0x00),
-        new byte[] {'O', 'p', 'u', 's'});
-    assertFalse(sniff(data));
+    byte[] data =
+        TestUtil.joinByteArrays(
+            OggTestData.buildOggHeader(0x02, 0, 1000, 0x00), new byte[] {'O', 'p', 'u', 's'});
+    assertThat(sniff(data)).isFalse();
   }
 
+  @Test
   public void testSniffFailsInvalidOggHeader() throws Exception {
     byte[] data = OggTestData.buildOggHeader(0x00, 0, 1000, 0x00);
-    assertFalse(sniff(data));
+    assertThat(sniff(data)).isFalse();
   }
 
+  @Test
   public void testSniffInvalidHeader() throws Exception {
-    byte[] data = TestUtil.joinByteArrays(
-        OggTestData.buildOggHeader(0x02, 0, 1000, 1),
-        TestUtil.createByteArray(7),  // Laces
-        new byte[] {0x7F, 'X', 'o', 'r', 'b', 'i', 's'});
-    assertFalse(sniff(data));
+    byte[] data =
+        TestUtil.joinByteArrays(
+            OggTestData.buildOggHeader(0x02, 0, 1000, 1),
+            TestUtil.createByteArray(7), // Laces
+            new byte[] {0x7F, 'X', 'o', 'r', 'b', 'i', 's'});
+    assertThat(sniff(data)).isFalse();
   }
 
+  @Test
   public void testSniffFailsEOF() throws Exception {
     byte[] data = OggTestData.buildOggHeader(0x02, 0, 1000, 0x00);
-    assertFalse(sniff(data));
+    assertThat(sniff(data)).isFalse();
   }
 
   private boolean sniff(byte[] data) throws InterruptedException, IOException {
-    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data)
-        .setSimulateIOErrors(true).setSimulateUnknownLength(true).setSimulatePartialReads(true)
-        .build();
+    FakeExtractorInput input =
+        new FakeExtractorInput.Builder()
+            .setData(data)
+            .setSimulateIOErrors(true)
+            .setSimulateUnknownLength(true)
+            .setSimulatePartialReads(true)
+            .build();
     return TestUtil.sniffTestData(OGG_EXTRACTOR_FACTORY.create(), input);
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
new file mode 100644
index 0000000000..e9af630f83
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPacketTest.java
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.extractor.ogg;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.testutil.FakeExtractorInput;
+import com.google.android.exoplayer2.testutil.OggTestData;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Unit test for {@link OggPacket}. */
+@RunWith(RobolectricTestRunner.class)
+public final class OggPacketTest {
+
+  private static final String TEST_FILE = "ogg/bear.opus";
+
+  private Random random;
+  private OggPacket oggPacket;
+
+  @Before
+  public void setUp() throws Exception {
+    random = new Random(0);
+    oggPacket = new OggPacket();
+  }
+
+  @Test
+  public void testReadPacketsWithEmptyPage() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(8, random);
+    byte[] secondPacket = TestUtil.buildTestData(272, random);
+    byte[] thirdPacket = TestUtil.buildTestData(256, random);
+    byte[] fourthPacket = TestUtil.buildTestData(271, random);
+
+    FakeExtractorInput input =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                // First page with a single packet.
+                OggTestData.buildOggHeader(0x02, 0, 1000, 0x01),
+                TestUtil.createByteArray(0x08), // Laces
+                firstPacket,
+                // Second page with a single packet.
+                OggTestData.buildOggHeader(0x00, 16, 1001, 0x02),
+                TestUtil.createByteArray(0xFF, 0x11), // Laces
+                secondPacket,
+                // Third page with zero packets.
+                OggTestData.buildOggHeader(0x00, 16, 1002, 0x00),
+                // Fourth page with two packets.
+                OggTestData.buildOggHeader(0x04, 128, 1003, 0x04),
+                TestUtil.createByteArray(0xFF, 0x01, 0xFF, 0x10), // Laces
+                thirdPacket,
+                fourthPacket),
+            true);
+
+    assertReadPacket(input, firstPacket);
+    assertThat((oggPacket.getPageHeader().type & 0x02) == 0x02).isTrue();
+    assertThat((oggPacket.getPageHeader().type & 0x04) == 0x04).isFalse();
+    assertThat(oggPacket.getPageHeader().type).isEqualTo(0x02);
+    assertThat(oggPacket.getPageHeader().headerSize).isEqualTo(27 + 1);
+    assertThat(oggPacket.getPageHeader().bodySize).isEqualTo(8);
+    assertThat(oggPacket.getPageHeader().revision).isEqualTo(0x00);
+    assertThat(oggPacket.getPageHeader().pageSegmentCount).isEqualTo(1);
+    assertThat(oggPacket.getPageHeader().pageSequenceNumber).isEqualTo(1000);
+    assertThat(oggPacket.getPageHeader().streamSerialNumber).isEqualTo(4096);
+    assertThat(oggPacket.getPageHeader().granulePosition).isEqualTo(0);
+
+    assertReadPacket(input, secondPacket);
+    assertThat((oggPacket.getPageHeader().type & 0x02) == 0x02).isFalse();
+    assertThat((oggPacket.getPageHeader().type & 0x04) == 0x04).isFalse();
+    assertThat(oggPacket.getPageHeader().type).isEqualTo(0);
+    assertThat(oggPacket.getPageHeader().headerSize).isEqualTo(27 + 2);
+    assertThat(oggPacket.getPageHeader().bodySize).isEqualTo(255 + 17);
+    assertThat(oggPacket.getPageHeader().pageSegmentCount).isEqualTo(2);
+    assertThat(oggPacket.getPageHeader().pageSequenceNumber).isEqualTo(1001);
+    assertThat(oggPacket.getPageHeader().granulePosition).isEqualTo(16);
+
+    assertReadPacket(input, thirdPacket);
+    assertThat((oggPacket.getPageHeader().type & 0x02) == 0x02).isFalse();
+    assertThat((oggPacket.getPageHeader().type & 0x04) == 0x04).isTrue();
+    assertThat(oggPacket.getPageHeader().type).isEqualTo(4);
+    assertThat(oggPacket.getPageHeader().headerSize).isEqualTo(27 + 4);
+    assertThat(oggPacket.getPageHeader().bodySize).isEqualTo(255 + 1 + 255 + 16);
+    assertThat(oggPacket.getPageHeader().pageSegmentCount).isEqualTo(4);
+    // Page 1002 is empty, so current page is 1003.
+    assertThat(oggPacket.getPageHeader().pageSequenceNumber).isEqualTo(1003);
+    assertThat(oggPacket.getPageHeader().granulePosition).isEqualTo(128);
+
+    assertReadPacket(input, fourthPacket);
+
+    assertReadEof(input);
+  }
+
+  @Test
+  public void testReadPacketWithZeroSizeTerminator() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(255, random);
+    byte[] secondPacket = TestUtil.buildTestData(8, random);
+
+    FakeExtractorInput input =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                OggTestData.buildOggHeader(0x06, 0, 1000, 0x04),
+                TestUtil.createByteArray(0xFF, 0x00, 0x00, 0x08), // Laces.
+                firstPacket,
+                secondPacket),
+            true);
+
+    assertReadPacket(input, firstPacket);
+    assertReadPacket(input, secondPacket);
+    assertReadEof(input);
+  }
+
+  @Test
+  public void testReadContinuedPacketOverTwoPages() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(518);
+
+    FakeExtractorInput input =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                // First page.
+                OggTestData.buildOggHeader(0x02, 0, 1000, 0x02),
+                TestUtil.createByteArray(0xFF, 0xFF), // Laces.
+                Arrays.copyOf(firstPacket, 510),
+                // Second page (continued packet).
+                OggTestData.buildOggHeader(0x05, 10, 1001, 0x01),
+                TestUtil.createByteArray(0x08), // Laces.
+                Arrays.copyOfRange(firstPacket, 510, 510 + 8)),
+            true);
+
+    assertReadPacket(input, firstPacket);
+    assertThat((oggPacket.getPageHeader().type & 0x04) == 0x04).isTrue();
+    assertThat((oggPacket.getPageHeader().type & 0x02) == 0x02).isFalse();
+    assertThat(oggPacket.getPageHeader().pageSequenceNumber).isEqualTo(1001);
+
+    assertReadEof(input);
+  }
+
+  @Test
+  public void testReadContinuedPacketOverFourPages() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(1028);
+
+    FakeExtractorInput input =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                // First page.
+                OggTestData.buildOggHeader(0x02, 0, 1000, 0x02),
+                TestUtil.createByteArray(0xFF, 0xFF), // Laces.
+                Arrays.copyOf(firstPacket, 510),
+                // Second page (continued packet).
+                OggTestData.buildOggHeader(0x01, 10, 1001, 0x01),
+                TestUtil.createByteArray(0xFF), // Laces.
+                Arrays.copyOfRange(firstPacket, 510, 510 + 255),
+                // Third page (continued packet).
+                OggTestData.buildOggHeader(0x01, 10, 1002, 0x01),
+                TestUtil.createByteArray(0xFF), // Laces.
+                Arrays.copyOfRange(firstPacket, 510 + 255, 510 + 255 + 255),
+                // Fourth page (continued packet).
+                OggTestData.buildOggHeader(0x05, 10, 1003, 0x01),
+                TestUtil.createByteArray(0x08), // Laces.
+                Arrays.copyOfRange(firstPacket, 510 + 255 + 255, 510 + 255 + 255 + 8)),
+            true);
+
+    assertReadPacket(input, firstPacket);
+    assertThat((oggPacket.getPageHeader().type & 0x04) == 0x04).isTrue();
+    assertThat((oggPacket.getPageHeader().type & 0x02) == 0x02).isFalse();
+    assertThat(oggPacket.getPageHeader().pageSequenceNumber).isEqualTo(1003);
+
+    assertReadEof(input);
+  }
+
+  @Test
+  public void testReadDiscardContinuedPacketAtStart() throws Exception {
+    byte[] pageBody = TestUtil.buildTestData(256 + 8);
+
+    FakeExtractorInput input =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                // Page with a continued packet at start.
+                OggTestData.buildOggHeader(0x01, 10, 1001, 0x03),
+                TestUtil.createByteArray(255, 1, 8), // Laces.
+                pageBody),
+            true);
+
+    // Expect the first partial packet to be discarded.
+    assertReadPacket(input, Arrays.copyOfRange(pageBody, 256, 256 + 8));
+    assertReadEof(input);
+  }
+
+  @Test
+  public void testReadZeroSizedPacketsAtEndOfStream() throws Exception {
+    byte[] firstPacket = TestUtil.buildTestData(8, random);
+    byte[] secondPacket = TestUtil.buildTestData(8, random);
+    byte[] thirdPacket = TestUtil.buildTestData(8, random);
+
+    FakeExtractorInput input =
+        OggTestData.createInput(
+            TestUtil.joinByteArrays(
+                OggTestData.buildOggHeader(0x02, 0, 1000, 0x01),
+                TestUtil.createByteArray(0x08), // Laces.
+                firstPacket,
+                OggTestData.buildOggHeader(0x04, 0, 1001, 0x03),
+                TestUtil.createByteArray(0x08, 0x00, 0x00), // Laces.
+                secondPacket,
+                OggTestData.buildOggHeader(0x04, 0, 1002, 0x03),
+                TestUtil.createByteArray(0x08, 0x00, 0x00), // Laces.
+                thirdPacket),
+            true);
+
+    assertReadPacket(input, firstPacket);
+    assertReadPacket(input, secondPacket);
+    assertReadPacket(input, thirdPacket);
+    assertReadEof(input);
+  }
+
+  @Test
+  public void testParseRealFile() throws IOException, InterruptedException {
+    byte[] data = TestUtil.getByteArray(RuntimeEnvironment.application, TEST_FILE);
+    FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data).build();
+    int packetCounter = 0;
+    while (readPacket(input)) {
+      packetCounter++;
+    }
+    assertThat(packetCounter).isEqualTo(277);
+  }
+
+  private void assertReadPacket(FakeExtractorInput extractorInput, byte[] expected)
+      throws IOException, InterruptedException {
+    assertThat(readPacket(extractorInput)).isTrue();
+    ParsableByteArray payload = oggPacket.getPayload();
+    assertThat(Arrays.copyOf(payload.data, payload.limit())).isEqualTo(expected);
+  }
+
+  private void assertReadEof(FakeExtractorInput extractorInput)
+      throws IOException, InterruptedException {
+    assertThat(readPacket(extractorInput)).isFalse();
+  }
+
+  private boolean readPacket(FakeExtractorInput input) throws InterruptedException, IOException {
+    while (true) {
+      try {
+        return oggPacket.populate(input);
+      } catch (FakeExtractorInput.SimulatedIOException e) {
+        // Ignore.
+      }
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
index c8bcffde3c..930d067d2b 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggPageHeaderTest.java
@@ -25,13 +25,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link OggPageHeader}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class OggPageHeaderTest {
 
   @Test
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
similarity index 90%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
index 6d839a8355..e5512dda36 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/OggTestFile.java
@@ -15,15 +15,14 @@
  */
 package com.google.android.exoplayer2.extractor.ogg;
 
+import static org.junit.Assert.fail;
+
 import com.google.android.exoplayer2.testutil.OggTestData;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.util.ArrayList;
 import java.util.Random;
-import junit.framework.Assert;
 
-/**
- * Generates test data.
- */
+/** Generates test data. */
 /* package */ final class OggTestFile {
 
   private static final int MAX_PACKET_LENGTH = 2048;
@@ -37,8 +36,13 @@
   public final int firstPayloadPageSize;
   public final long firstPayloadPageGranulePosition;
 
-  private OggTestFile(byte[] data, long lastGranule, int packetCount, int pageCount,
-      int firstPayloadPageSize, long firstPayloadPageGranulePosition) {
+  private OggTestFile(
+      byte[] data,
+      long lastGranule,
+      int packetCount,
+      int pageCount,
+      int firstPayloadPageSize,
+      long firstPayloadPageGranulePosition) {
     this.data = data;
     this.lastGranule = lastGranule;
     this.packetCount = packetCount;
@@ -109,7 +113,12 @@ public static OggTestFile generate(Random random, int pageCount) {
       System.arraycopy(data, 0, file, position, data.length);
       position += data.length;
     }
-    return new OggTestFile(file, granule, packetCount, pageCount, firstPayloadPageSize,
+    return new OggTestFile(
+        file,
+        granule,
+        packetCount,
+        pageCount,
+        firstPayloadPageSize,
         firstPayloadPageGranulePosition);
   }
 
@@ -119,8 +128,7 @@ public int findPreviousPageStart(long position) {
         return i;
       }
     }
-    Assert.fail();
+    fail();
     return -1;
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
index 08b9b12a18..eca94f076e 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java
@@ -21,13 +21,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link VorbisBitArray}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class VorbisBitArrayTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
index 20a76e83e0..f0361c5395 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisReaderTest.java
@@ -29,13 +29,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link VorbisReader}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class VorbisReaderTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
index bdc573f218..5b395771fc 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ogg/VorbisUtilTest.java
@@ -26,13 +26,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link VorbisUtil}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class VorbisUtilTest {
 
   @Test
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
similarity index 69%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
index 18050f48a3..9632577e82 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/rawcc/RawCcExtractorTest.java
@@ -16,29 +16,38 @@
 package com.google.android.exoplayer2.extractor.rawcc;
 
 import android.annotation.TargetApi;
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
 import com.google.android.exoplayer2.util.MimeTypes;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Tests for {@link RawCcExtractor}.
- */
+/** Tests for {@link RawCcExtractor}. */
 @TargetApi(16)
-public final class RawCcExtractorTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+public final class RawCcExtractorTest {
 
+  @Test
   public void testRawCcSample() throws Exception {
     ExtractorAsserts.assertBehavior(
         new ExtractorFactory() {
           @Override
           public Extractor create() {
             return new RawCcExtractor(
-                Format.createTextContainerFormat(null, null, MimeTypes.APPLICATION_CEA608,
-                    "cea608", Format.NO_VALUE, 0, null, 1));
+                Format.createTextContainerFormat(
+                    null,
+                    null,
+                    MimeTypes.APPLICATION_CEA608,
+                    "cea608",
+                    Format.NO_VALUE,
+                    0,
+                    null,
+                    1));
           }
-        }, "rawcc/sample.rawcc", getInstrumentation());
+        },
+        "rawcc/sample.rawcc");
   }
-
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
similarity index 67%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
index 31633361db..ec7afeeeab 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/Ac3ExtractorTest.java
@@ -15,23 +15,26 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link Ac3Extractor}.
- */
-public final class Ac3ExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link Ac3Extractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class Ac3ExtractorTest {
 
+  @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new Ac3Extractor();
-      }
-    }, "ts/sample.ac3", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new Ac3Extractor();
+          }
+        },
+        "ts/sample.ac3");
   }
-
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
similarity index 67%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
index 9eb65d2091..048a23cd67 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsExtractorTest.java
@@ -15,23 +15,26 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link AdtsExtractor}.
- */
-public final class AdtsExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link AdtsExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class AdtsExtractorTest {
 
+  @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new AdtsExtractor();
-      }
-    }, "ts/sample.adts", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new AdtsExtractor();
+          }
+        },
+        "ts/sample.adts");
   }
-
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
similarity index 69%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
index 6a31250e15..1098ba7563 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/AdtsReaderTest.java
@@ -23,41 +23,39 @@
 import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.util.ParsableByteArray;
 import java.util.Arrays;
-import junit.framework.TestCase;
-
-/**
- * Test for {@link AdtsReader}.
- */
-public class AdtsReaderTest extends TestCase {
-
-  public static final byte[] ID3_DATA_1 = TestUtil.createByteArray(
-      0x49, 0x44, 0x33, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x54, 0x58,
-      0x58, 0x58, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x03, 0x00, 0x20, 0x2a,
-      0x2a, 0x2a, 0x20, 0x54, 0x48, 0x49, 0x53, 0x20, 0x49, 0x53, 0x20, 0x54,
-      0x69, 0x6d, 0x65, 0x64, 0x20, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74,
-      0x61, 0x20, 0x40, 0x20, 0x2d, 0x2d, 0x20, 0x30, 0x30, 0x3a, 0x30, 0x30,
-      0x3a, 0x30, 0x30, 0x2e, 0x30, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x00);
-
-  public static final byte[] ID3_DATA_2 = TestUtil.createByteArray(
-      0x49,
-      0x44, 0x33, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x50, 0x52, 0x49,
-      0x56, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
-      0x70, 0x70, 0x6c, 0x65, 0x2e, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69,
-      0x6e, 0x67, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74,
-      0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
-      0x61, 0x6d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xbb, 0xa0);
-
-  public static final byte[] ADTS_HEADER = TestUtil.createByteArray(
-      0xff, 0xf1, 0x50, 0x80, 0x01, 0xdf, 0xfc);
-
-  public static final byte[] ADTS_CONTENT = TestUtil.createByteArray(
-      0x20, 0x00, 0x20, 0x00, 0x00, 0x80, 0x0e);
-
-  private static final byte[] TEST_DATA = TestUtil.joinByteArrays(
-      ID3_DATA_1,
-      ID3_DATA_2,
-      ADTS_HEADER,
-      ADTS_CONTENT);
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Test for {@link AdtsReader}. */
+@RunWith(RobolectricTestRunner.class)
+public class AdtsReaderTest {
+
+  public static final byte[] ID3_DATA_1 =
+      TestUtil.createByteArray(
+          0x49, 0x44, 0x33, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x54, 0x58, 0x58, 0x58, 0x00,
+          0x00, 0x00, 0x33, 0x00, 0x00, 0x03, 0x00, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x54, 0x48, 0x49,
+          0x53, 0x20, 0x49, 0x53, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x64, 0x20, 0x4d, 0x65, 0x74, 0x61,
+          0x44, 0x61, 0x74, 0x61, 0x20, 0x40, 0x20, 0x2d, 0x2d, 0x20, 0x30, 0x30, 0x3a, 0x30, 0x30,
+          0x3a, 0x30, 0x30, 0x2e, 0x30, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x00);
+
+  public static final byte[] ID3_DATA_2 =
+      TestUtil.createByteArray(
+          0x49, 0x44, 0x33, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x50, 0x52, 0x49, 0x56, 0x00,
+          0x00, 0x00, 0x35, 0x00, 0x00, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x70, 0x70, 0x6c, 0x65, 0x2e,
+          0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x2e, 0x74, 0x72, 0x61, 0x6e, 0x73,
+          0x70, 0x6f, 0x72, 0x74, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x54, 0x69, 0x6d, 0x65, 0x73,
+          0x74, 0x61, 0x6d, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0xbb, 0xa0);
+
+  public static final byte[] ADTS_HEADER =
+      TestUtil.createByteArray(0xff, 0xf1, 0x50, 0x80, 0x01, 0xdf, 0xfc);
+
+  public static final byte[] ADTS_CONTENT =
+      TestUtil.createByteArray(0x20, 0x00, 0x20, 0x00, 0x00, 0x80, 0x0e);
+
+  private static final byte[] TEST_DATA =
+      TestUtil.joinByteArrays(ID3_DATA_1, ID3_DATA_2, ADTS_HEADER, ADTS_CONTENT);
 
   private static final long ADTS_SAMPLE_DURATION = 23219L;
 
@@ -67,8 +65,8 @@
   private ParsableByteArray data;
   private boolean firstFeed;
 
-  @Override
-  protected void setUp() throws Exception {
+  @Before
+  public void setUp() throws Exception {
     FakeExtractorOutput fakeExtractorOutput = new FakeExtractorOutput();
     adtsOutput = fakeExtractorOutput.track(0, C.TRACK_TYPE_AUDIO);
     id3Output = fakeExtractorOutput.track(1, C.TRACK_TYPE_METADATA);
@@ -79,6 +77,7 @@ protected void setUp() throws Exception {
     firstFeed = true;
   }
 
+  @Test
   public void testSkipToNextSample() throws Exception {
     for (int i = 1; i <= ID3_DATA_1.length + ID3_DATA_2.length; i++) {
       data.setPosition(i);
@@ -89,50 +88,60 @@ public void testSkipToNextSample() throws Exception {
     }
   }
 
+  @Test
   public void testSkipToNextSampleResetsState() throws Exception {
-    data = new ParsableByteArray(TestUtil.joinByteArrays(
-        ADTS_HEADER,
-        ADTS_CONTENT,
-        // Adts sample missing the first sync byte
-        Arrays.copyOfRange(ADTS_HEADER, 1, ADTS_HEADER.length),
-        ADTS_CONTENT));
+    data =
+        new ParsableByteArray(
+            TestUtil.joinByteArrays(
+                ADTS_HEADER,
+                ADTS_CONTENT,
+                // Adts sample missing the first sync byte
+                Arrays.copyOfRange(ADTS_HEADER, 1, ADTS_HEADER.length),
+                ADTS_CONTENT));
     feed();
     assertSampleCounts(0, 1);
     adtsOutput.assertSample(0, ADTS_CONTENT, 0, C.BUFFER_FLAG_KEY_FRAME, null);
   }
 
+  @Test
   public void testNoData() throws Exception {
     feedLimited(0);
     assertSampleCounts(0, 0);
   }
 
+  @Test
   public void testNotEnoughDataForIdentifier() throws Exception {
     feedLimited(3 - 1);
     assertSampleCounts(0, 0);
   }
 
+  @Test
   public void testNotEnoughDataForHeader() throws Exception {
     feedLimited(10 - 1);
     assertSampleCounts(0, 0);
   }
 
+  @Test
   public void testNotEnoughDataForWholeId3Packet() throws Exception {
     feedLimited(ID3_DATA_1.length - 1);
     assertSampleCounts(0, 0);
   }
 
+  @Test
   public void testConsumeWholeId3Packet() throws Exception {
     feedLimited(ID3_DATA_1.length);
     assertSampleCounts(1, 0);
     id3Output.assertSample(0, ID3_DATA_1, 0, C.BUFFER_FLAG_KEY_FRAME, null);
   }
 
+  @Test
   public void testMultiId3Packet() throws Exception {
     feedLimited(ID3_DATA_1.length + ID3_DATA_2.length - 1);
     assertSampleCounts(1, 0);
     id3Output.assertSample(0, ID3_DATA_1, 0, C.BUFFER_FLAG_KEY_FRAME, null);
   }
 
+  @Test
   public void testMultiId3PacketConsumed() throws Exception {
     feedLimited(ID3_DATA_1.length + ID3_DATA_2.length);
     assertSampleCounts(2, 0);
@@ -140,6 +149,7 @@ public void testMultiId3PacketConsumed() throws Exception {
     id3Output.assertSample(1, ID3_DATA_2, 0, C.BUFFER_FLAG_KEY_FRAME, null);
   }
 
+  @Test
   public void testMultiPacketConsumed() throws Exception {
     for (int i = 0; i < 10; i++) {
       data.setPosition(0);
@@ -155,6 +165,7 @@ public void testMultiPacketConsumed() throws Exception {
     }
   }
 
+  @Test
   public void testAdtsDataOnly() throws ParserException {
     data.setPosition(ID3_DATA_1.length + ID3_DATA_2.length);
     feed();
@@ -184,6 +195,4 @@ private void assertSampleCounts(int id3SampleCount, int adtsSampleCount) {
     id3Output.assertSampleCount(id3SampleCount);
     adtsOutput.assertSampleCount(adtsSampleCount);
   }
-
 }
-
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
similarity index 67%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
index 78ef05a769..798f1ce5e3 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/PsExtractorTest.java
@@ -15,23 +15,26 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link PsExtractor}.
- */
-public final class PsExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link PsExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class PsExtractorTest {
 
+  @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new PsExtractor();
-      }
-    }, "ts/sample.ps", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new PsExtractor();
+          }
+        },
+        "ts/sample.ps");
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
index 56668d5124..713d986d21 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/SectionReaderTest.java
@@ -30,13 +30,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link SectionReader}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class SectionReaderTest {
 
   private byte[] packetPayload;
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
similarity index 70%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
index b6eddb5112..8394ed81a5 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/ts/TsExtractorTest.java
@@ -15,7 +15,8 @@
  */
 package com.google.android.exoplayer2.extractor.ts;
 
-import android.test.InstrumentationTestCase;
+import static com.google.common.truth.Truth.assertThat;
+
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
@@ -35,27 +36,34 @@
 import com.google.android.exoplayer2.util.TimestampAdjuster;
 import java.io.ByteArrayOutputStream;
 import java.util.Random;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit test for {@link TsExtractor}.
- */
-public final class TsExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link TsExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class TsExtractorTest {
 
   private static final int TS_PACKET_SIZE = 188;
   private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
 
+  @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new TsExtractor();
-      }
-    }, "ts/sample.ts", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new TsExtractor();
+          }
+        },
+        "ts/sample.ts");
   }
 
+  @Test
   public void testIncompleteSample() throws Exception {
     Random random = new Random(0);
-    byte[] fileData = TestUtil.getByteArray(getInstrumentation(), "ts/sample.ts");
+    byte[] fileData = TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample.ts");
     ByteArrayOutputStream out = new ByteArrayOutputStream(fileData.length * 2);
     writeJunkData(out, random.nextInt(TS_PACKET_SIZE - 1) + 1);
     out.write(fileData, 0, TS_PACKET_SIZE * 5);
@@ -67,23 +75,30 @@ public void testIncompleteSample() throws Exception {
     writeJunkData(out, random.nextInt(TS_PACKET_SIZE - 1) + 1);
     fileData = out.toByteArray();
 
-    ExtractorAsserts.assertOutput(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new TsExtractor();
-      }
-    }, "ts/sample.ts", fileData, getInstrumentation());
+    ExtractorAsserts.assertOutput(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new TsExtractor();
+          }
+        },
+        "ts/sample.ts",
+        fileData,
+        RuntimeEnvironment.application);
   }
 
+  @Test
   public void testCustomPesReader() throws Exception {
     CustomTsPayloadReaderFactory factory = new CustomTsPayloadReaderFactory(true, false);
-    TsExtractor tsExtractor = new TsExtractor(TsExtractor.MODE_MULTI_PMT, new TimestampAdjuster(0),
-        factory);
-    FakeExtractorInput input = new FakeExtractorInput.Builder()
-        .setData(TestUtil.getByteArray(getInstrumentation(), "ts/sample.ts"))
-        .setSimulateIOErrors(false)
-        .setSimulateUnknownLength(false)
-        .setSimulatePartialReads(false).build();
+    TsExtractor tsExtractor =
+        new TsExtractor(TsExtractor.MODE_MULTI_PMT, new TimestampAdjuster(0), factory);
+    FakeExtractorInput input =
+        new FakeExtractorInput.Builder()
+            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample.ts"))
+            .setSimulateIOErrors(false)
+            .setSimulateUnknownLength(false)
+            .setSimulatePartialReads(false)
+            .build();
     FakeExtractorOutput output = new FakeExtractorOutput();
     tsExtractor.init(output);
     PositionHolder seekPositionHolder = new PositionHolder();
@@ -92,30 +107,32 @@ public void testCustomPesReader() throws Exception {
       readResult = tsExtractor.read(input, seekPositionHolder);
     }
     CustomEsReader reader = factory.esReader;
-    assertEquals(2, reader.packetsRead);
+    assertThat(reader.packetsRead).isEqualTo(2);
     TrackOutput trackOutput = reader.getTrackOutput();
-    assertTrue(trackOutput == output.trackOutputs.get(257 /* PID of audio track. */));
-    assertEquals(
-        Format.createTextSampleFormat("1/257", "mime", null, 0, 0, "und", null, 0),
-        ((FakeTrackOutput) trackOutput).format);
+    assertThat(trackOutput == output.trackOutputs.get(257 /* PID of audio track. */)).isTrue();
+    assertThat(((FakeTrackOutput) trackOutput).format)
+        .isEqualTo(Format.createTextSampleFormat("1/257", "mime", null, 0, 0, "und", null, 0));
   }
 
+  @Test
   public void testCustomInitialSectionReader() throws Exception {
     CustomTsPayloadReaderFactory factory = new CustomTsPayloadReaderFactory(false, true);
-    TsExtractor tsExtractor = new TsExtractor(TsExtractor.MODE_MULTI_PMT, new TimestampAdjuster(0),
-        factory);
-    FakeExtractorInput input = new FakeExtractorInput.Builder()
-        .setData(TestUtil.getByteArray(getInstrumentation(), "ts/sample_with_sdt.ts"))
-        .setSimulateIOErrors(false)
-        .setSimulateUnknownLength(false)
-        .setSimulatePartialReads(false).build();
+    TsExtractor tsExtractor =
+        new TsExtractor(TsExtractor.MODE_MULTI_PMT, new TimestampAdjuster(0), factory);
+    FakeExtractorInput input =
+        new FakeExtractorInput.Builder()
+            .setData(TestUtil.getByteArray(RuntimeEnvironment.application, "ts/sample_with_sdt.ts"))
+            .setSimulateIOErrors(false)
+            .setSimulateUnknownLength(false)
+            .setSimulatePartialReads(false)
+            .build();
     tsExtractor.init(new FakeExtractorOutput());
     PositionHolder seekPositionHolder = new PositionHolder();
     int readResult = Extractor.RESULT_CONTINUE;
     while (readResult != Extractor.RESULT_END_OF_INPUT) {
       readResult = tsExtractor.read(input, seekPositionHolder);
     }
-    assertEquals(1, factory.sdtReader.consumedSdts);
+    assertThat(factory.sdtReader.consumedSdts).isEqualTo(1);
   }
 
   private static void writeJunkData(ByteArrayOutputStream out, int length) {
@@ -145,7 +162,7 @@ public CustomTsPayloadReaderFactory(boolean provideCustomEsReader, boolean provi
     @Override
     public SparseArray<TsPayloadReader> createInitialPayloadReaders() {
       if (provideSdtReader) {
-        assertNull(sdtReader);
+        assertThat(sdtReader).isNull();
         SparseArray<TsPayloadReader> mapping = new SparseArray<>();
         sdtReader = new SdtSectionReader();
         mapping.put(17, new SectionReader(sdtReader));
@@ -164,7 +181,6 @@ public TsPayloadReader createPayloadReader(int streamType, EsInfo esInfo) {
         return defaultFactory.createPayloadReader(streamType, esInfo);
       }
     }
-
   }
 
   private static final class CustomEsReader implements ElementaryStreamReader {
@@ -178,24 +194,22 @@ public CustomEsReader(String language) {
     }
 
     @Override
-    public void seek() {
-    }
+    public void seek() {}
 
     @Override
     public void createTracks(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
       idGenerator.generateNewId();
       output = extractorOutput.track(idGenerator.getTrackId(), C.TRACK_TYPE_UNKNOWN);
-      output.format(Format.createTextSampleFormat(idGenerator.getFormatId(), "mime", null, 0, 0,
-          language, null, 0));
+      output.format(
+          Format.createTextSampleFormat(
+              idGenerator.getFormatId(), "mime", null, 0, 0, language, null, 0));
     }
 
     @Override
-    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {
-    }
+    public void packetStarted(long pesTimeUs, boolean dataAlignmentIndicator) {}
 
     @Override
-    public void consume(ParsableByteArray data) {
-    }
+    public void consume(ParsableByteArray data) {}
 
     @Override
     public void packetFinished() {
@@ -205,7 +219,6 @@ public void packetFinished() {
     public TrackOutput getTrackOutput() {
       return output;
     }
-
   }
 
   private static final class SdtSectionReader implements SectionPayloadReader {
@@ -213,7 +226,9 @@ public TrackOutput getTrackOutput() {
     private int consumedSdts;
 
     @Override
-    public void init(TimestampAdjuster timestampAdjuster, ExtractorOutput extractorOutput,
+    public void init(
+        TimestampAdjuster timestampAdjuster,
+        ExtractorOutput extractorOutput,
         TrackIdGenerator idGenerator) {
       // Do nothing.
     }
@@ -226,28 +241,26 @@ public void consume(ParsableByteArray sectionData) {
       // original_network_id(16), reserved_future_use(8)
       sectionData.skipBytes(11);
       // Start of the service loop.
-      assertEquals(0x5566 /* arbitrary service id */, sectionData.readUnsignedShort());
+      assertThat(sectionData.readUnsignedShort()).isEqualTo(0x5566 /* arbitrary service id */);
       // reserved_future_use(6), EIT_schedule_flag(1), EIT_present_following_flag(1)
       sectionData.skipBytes(1);
       // Assert there is only one service.
       // Remove running_status(3), free_CA_mode(1) from the descriptors_loop_length with the mask.
-      assertEquals(sectionData.readUnsignedShort() & 0xFFF, sectionData.bytesLeft());
+      assertThat(sectionData.readUnsignedShort() & 0xFFF).isEqualTo(sectionData.bytesLeft());
       while (sectionData.bytesLeft() > 0) {
         int descriptorTag = sectionData.readUnsignedByte();
         int descriptorLength = sectionData.readUnsignedByte();
         if (descriptorTag == 72 /* service descriptor */) {
-          assertEquals(1, sectionData.readUnsignedByte()); // Service type: Digital TV.
+          assertThat(sectionData.readUnsignedByte()).isEqualTo(1); // Service type: Digital TV.
           int serviceProviderNameLength = sectionData.readUnsignedByte();
-          assertEquals("Some provider", sectionData.readString(serviceProviderNameLength));
+          assertThat(sectionData.readString(serviceProviderNameLength)).isEqualTo("Some provider");
           int serviceNameLength = sectionData.readUnsignedByte();
-          assertEquals("Some Channel", sectionData.readString(serviceNameLength));
+          assertThat(sectionData.readString(serviceNameLength)).isEqualTo("Some Channel");
         } else {
           sectionData.skipBytes(descriptorLength);
         }
       }
       consumedSdts++;
     }
-
   }
-
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
similarity index 67%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
index 36c05aa72e..e75525bb1e 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/extractor/wav/WavExtractorTest.java
@@ -15,23 +15,26 @@
  */
 package com.google.android.exoplayer2.extractor.wav;
 
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts;
 import com.google.android.exoplayer2.testutil.ExtractorAsserts.ExtractorFactory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link WavExtractor}.
- */
-public final class WavExtractorTest extends InstrumentationTestCase {
+/** Unit test for {@link WavExtractor}. */
+@RunWith(RobolectricTestRunner.class)
+public final class WavExtractorTest {
 
+  @Test
   public void testSample() throws Exception {
-    ExtractorAsserts.assertBehavior(new ExtractorFactory() {
-      @Override
-      public Extractor create() {
-        return new WavExtractor();
-      }
-    }, "wav/sample.wav", getInstrumentation());
+    ExtractorAsserts.assertBehavior(
+        new ExtractorFactory() {
+          @Override
+          public Extractor create() {
+            return new WavExtractor();
+          }
+        },
+        "wav/sample.wav");
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
index 1ce0ccb93d..c6558e3fc9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageDecoderTest.java
@@ -23,13 +23,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link EventMessageDecoder}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class EventMessageDecoderTest {
 
   @Test
@@ -38,7 +36,7 @@ public void testDecodeEventMessage() {
         117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
         49, 50, 51, 0, // value = "123"
         0, 0, -69, -128, // timescale = 48000
-        0, 0, 0, 0, // presentation_time_delta (ignored) = 0
+        0, 0, -69, -128, // presentation_time_delta = 48000
         0, 2, 50, -128, // event_duration = 144000
         0, 15, 67, -45, // id = 1000403
         0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
@@ -53,6 +51,7 @@ public void testDecodeEventMessage() {
     assertThat(eventMessage.durationMs).isEqualTo(3000);
     assertThat(eventMessage.id).isEqualTo(1000403);
     assertThat(eventMessage.messageData).isEqualTo(new byte[]{0, 1, 2, 3, 4});
+    assertThat(eventMessage.presentationTimeUs).isEqualTo(1000000);
   }
 
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java
new file mode 100644
index 0000000000..7195548fbf
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageEncoderTest.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.metadata.emsg;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/**
+ * Unit test for {@link EventMessageEncoder}.
+ */
+@RunWith(RobolectricTestRunner.class)
+public final class EventMessageEncoderTest {
+
+  @Test
+  public void testEncodeEventStream() throws IOException {
+    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
+        new byte[] {0, 1, 2, 3, 4}, 1000000);
+    byte[] expectedEmsgBody = new byte[] {
+        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+        49, 50, 51, 0, // value = "123"
+        0, 0, -69, -128, // timescale = 48000
+        0, 0, -69, -128, // presentation_time_delta = 48000
+        0, 2, 50, -128, // event_duration = 144000
+        0, 15, 67, -45, // id = 1000403
+        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
+    byte[] encodedByteArray = new EventMessageEncoder().encode(eventMessage, 48000);
+    assertThat(encodedByteArray).isEqualTo(expectedEmsgBody);
+  }
+
+  @Test
+  public void testEncodeDecodeEventStream() throws IOException {
+    EventMessage expectedEmsg = new EventMessage("urn:test", "123", 3000, 1000403,
+        new byte[] {0, 1, 2, 3, 4}, 1000000);
+    byte[] encodedByteArray = new EventMessageEncoder().encode(expectedEmsg, 48000);
+    MetadataInputBuffer buffer = new MetadataInputBuffer();
+    buffer.data = ByteBuffer.allocate(encodedByteArray.length).put(encodedByteArray);
+
+    EventMessageDecoder decoder = new EventMessageDecoder();
+    Metadata metadata = decoder.decode(buffer);
+    assertThat(metadata.length()).isEqualTo(1);
+    assertThat(metadata.get(0)).isEqualTo(expectedEmsg);
+  }
+
+  @Test
+  public void testEncodeEventStreamMultipleTimesWorkingCorrectly() throws IOException {
+    EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
+        new byte[] {0, 1, 2, 3, 4}, 1000000);
+    byte[] expectedEmsgBody = new byte[] {
+        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+        49, 50, 51, 0, // value = "123"
+        0, 0, -69, -128, // timescale = 48000
+        0, 0, -69, -128, // presentation_time_delta = 48000
+        0, 2, 50, -128, // event_duration = 144000
+        0, 15, 67, -45, // id = 1000403
+        0, 1, 2, 3, 4}; // message_data = {0, 1, 2, 3, 4}
+    EventMessage eventMessage1 = new EventMessage("urn:test", "123", 3000, 1000402,
+        new byte[] {4, 3, 2, 1, 0}, 1000000);
+    byte[] expectedEmsgBody1 = new byte[] {
+        117, 114, 110, 58, 116, 101, 115, 116, 0, // scheme_id_uri = "urn:test"
+        49, 50, 51, 0, // value = "123"
+        0, 0, -69, -128, // timescale = 48000
+        0, 0, -69, -128, // presentation_time_delta = 48000
+        0, 2, 50, -128, // event_duration = 144000
+        0, 15, 67, -46, // id = 1000402
+        4, 3, 2, 1, 0}; // message_data = {4, 3, 2, 1, 0}
+    EventMessageEncoder eventMessageEncoder = new EventMessageEncoder();
+    byte[] encodedByteArray = eventMessageEncoder.encode(eventMessage, 48000);
+    assertThat(encodedByteArray).isEqualTo(expectedEmsgBody);
+    byte[] encodedByteArray1 = eventMessageEncoder.encode(eventMessage1, 48000);
+    assertThat(encodedByteArray1).isEqualTo(expectedEmsgBody1);
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
index b48a071d0d..30e1cd6c1f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/emsg/EventMessageTest.java
@@ -21,19 +21,17 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link EventMessage}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class EventMessageTest {
 
   @Test
   public void testEventMessageParcelable() {
     EventMessage eventMessage = new EventMessage("urn:test", "123", 3000, 1000403,
-        new byte[] {0, 1, 2, 3, 4});
+        new byte[] {0, 1, 2, 3, 4}, 1000);
     // Write to parcel.
     Parcel parcel = Parcel.obtain();
     eventMessage.writeToParcel(parcel, 0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
index a42b71731a..714f77a752 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterFrameTest.java
@@ -21,13 +21,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link ChapterFrame}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ChapterFrameTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
index 9636b04e51..98a99a4219 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/ChapterTocFrameTest.java
@@ -21,13 +21,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link ChapterTocFrame}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ChapterTocFrameTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
index 06ce330146..4e7ae0eec0 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/id3/Id3DecoderTest.java
@@ -25,13 +25,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link Id3Decoder}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class Id3DecoderTest {
 
   private static final byte[] TAG_HEADER = new byte[] {73, 68, 51, 4, 0, 0, 0, 0, 0, 0};
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
index 8cd90c7a64..2afe80bb0a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/metadata/scte35/SpliceInfoDecoderTest.java
@@ -28,13 +28,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link SpliceInfoDecoder}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class SpliceInfoDecoderTest {
 
   private SpliceInfoDecoder decoder;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
new file mode 100644
index 0000000000..a4aa3eb938
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ClippingMediaSourceTest.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Timeline.Period;
+import com.google.android.exoplayer2.Timeline.Window;
+import com.google.android.exoplayer2.source.ClippingMediaSource.IllegalClippingException;
+import com.google.android.exoplayer2.testutil.FakeMediaSource;
+import com.google.android.exoplayer2.testutil.FakeTimeline;
+import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
+import com.google.android.exoplayer2.testutil.MediaSourceTestRunner;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.testutil.TimelineAsserts;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/** Unit tests for {@link ClippingMediaSource}. */
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public final class ClippingMediaSourceTest {
+
+  private static final long TEST_PERIOD_DURATION_US = 1000000;
+  private static final long TEST_CLIP_AMOUNT_US = 300000;
+
+  private Window window;
+  private Period period;
+
+  @Before
+  public void setUp() throws Exception {
+    window = new Timeline.Window();
+    period = new Timeline.Period();
+  }
+
+  @Test
+  public void testNoClipping() throws IOException {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true, false);
+
+    Timeline clippedTimeline = getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
+
+    assertThat(clippedTimeline.getWindowCount()).isEqualTo(1);
+    assertThat(clippedTimeline.getPeriodCount()).isEqualTo(1);
+    assertThat(clippedTimeline.getWindow(0, window).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US);
+    assertThat(clippedTimeline.getPeriod(0, period).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US);
+  }
+
+  @Test
+  public void testClippingUnseekableWindowThrows() throws IOException {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), false, false);
+
+    // If the unseekable window isn't clipped, clipping succeeds.
+    getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US);
+    try {
+      // If the unseekable window is clipped, clipping fails.
+      getClippedTimeline(timeline, 1, TEST_PERIOD_DURATION_US);
+      fail("Expected clipping to fail.");
+    } catch (IllegalClippingException e) {
+      assertThat(e.reason).isEqualTo(IllegalClippingException.REASON_NOT_SEEKABLE_TO_START);
+    }
+  }
+
+  @Test
+  public void testClippingStart() throws IOException {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true, false);
+
+    Timeline clippedTimeline =
+        getClippedTimeline(timeline, TEST_CLIP_AMOUNT_US, TEST_PERIOD_DURATION_US);
+    assertThat(clippedTimeline.getWindow(0, window).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
+    assertThat(clippedTimeline.getPeriod(0, period).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
+  }
+
+  @Test
+  public void testClippingEnd() throws IOException {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true, false);
+
+    Timeline clippedTimeline =
+        getClippedTimeline(timeline, 0, TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
+    assertThat(clippedTimeline.getWindow(0, window).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
+    assertThat(clippedTimeline.getPeriod(0, period).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
+  }
+
+  @Test
+  public void testClippingStartAndEndInitial() throws IOException {
+    // Timeline that's dynamic and not seekable. A child source might report such a timeline prior
+    // to it having loaded sufficient data to establish its duration and seekability. Such timelines
+    // should not result in clipping failure.
+    Timeline timeline =
+        new SinglePeriodTimeline(C.TIME_UNSET, /* isSeekable= */ false, /* isDynamic= */ true);
+
+    Timeline clippedTimeline =
+        getClippedTimeline(
+            timeline, TEST_CLIP_AMOUNT_US, TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 2);
+    assertThat(clippedTimeline.getWindow(0, window).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3);
+    assertThat(clippedTimeline.getPeriod(0, period).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3);
+  }
+
+  @Test
+  public void testClippingStartAndEnd() throws IOException {
+    Timeline timeline = new SinglePeriodTimeline(C.msToUs(TEST_PERIOD_DURATION_US), true, false);
+
+    Timeline clippedTimeline =
+        getClippedTimeline(
+            timeline, TEST_CLIP_AMOUNT_US, TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 2);
+    assertThat(clippedTimeline.getWindow(0, window).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3);
+    assertThat(clippedTimeline.getPeriod(0, period).getDurationUs())
+        .isEqualTo(TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US * 3);
+  }
+
+  @Test
+  public void testWindowAndPeriodIndices() throws IOException {
+    Timeline timeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(1, 111, true, false, TEST_PERIOD_DURATION_US));
+    Timeline clippedTimeline =
+        getClippedTimeline(
+            timeline, TEST_CLIP_AMOUNT_US, TEST_PERIOD_DURATION_US - TEST_CLIP_AMOUNT_US);
+    TimelineAsserts.assertWindowIds(clippedTimeline, 111);
+    TimelineAsserts.assertPeriodCounts(clippedTimeline, 1);
+    TimelineAsserts.assertPreviousWindowIndices(
+        clippedTimeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_ONE, false, 0);
+    TimelineAsserts.assertPreviousWindowIndices(clippedTimeline, Player.REPEAT_MODE_ALL, false, 0);
+    TimelineAsserts.assertNextWindowIndices(
+        clippedTimeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_ONE, false, 0);
+    TimelineAsserts.assertNextWindowIndices(clippedTimeline, Player.REPEAT_MODE_ALL, false, 0);
+  }
+
+  /**
+   * Wraps the specified timeline in a {@link ClippingMediaSource} and returns the clipped timeline.
+   */
+  private static Timeline getClippedTimeline(Timeline timeline, long startMs, long endMs)
+      throws IOException {
+    FakeMediaSource fakeMediaSource = new FakeMediaSource(timeline, null);
+    ClippingMediaSource mediaSource = new ClippingMediaSource(fakeMediaSource, startMs, endMs);
+    MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);
+    try {
+      Timeline clippedTimeline = testRunner.prepareSource();
+      testRunner.releaseSource();
+      fakeMediaSource.assertReleased();
+      return clippedTimeline;
+    } finally {
+      testRunner.release();
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
index e3ac104754..82d7f21852 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/CompositeSequenceableLoaderTest.java
@@ -21,13 +21,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link CompositeSequenceableLoader}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class CompositeSequenceableLoaderTest {
 
   /**
@@ -265,6 +263,11 @@ public boolean continueLoading(long positionUs) {
       return loaded;
     }
 
+    @Override
+    public void reevaluateBuffer(long positionUs) {
+      // Do nothing.
+    }
+
     private void setNextChunkDurationUs(int nextChunkDurationUs) {
       this.nextChunkDurationUs = nextChunkDurationUs;
     }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
new file mode 100644
index 0000000000..465e08b5d2
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ConcatenatingMediaSourceTest.java
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.testutil.FakeMediaSource;
+import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
+import com.google.android.exoplayer2.testutil.FakeTimeline;
+import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
+import com.google.android.exoplayer2.testutil.MediaSourceTestRunner;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.testutil.TimelineAsserts;
+import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/** Unit tests for {@link ConcatenatingMediaSource}. */
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public final class ConcatenatingMediaSourceTest {
+
+  @Test
+  public void testEmptyConcatenation() throws IOException {
+    for (boolean atomic : new boolean[] {false, true}) {
+      Timeline timeline = getConcatenatedTimeline(atomic);
+      TimelineAsserts.assertEmpty(timeline);
+
+      timeline = getConcatenatedTimeline(atomic, Timeline.EMPTY);
+      TimelineAsserts.assertEmpty(timeline);
+
+      timeline = getConcatenatedTimeline(atomic, Timeline.EMPTY, Timeline.EMPTY, Timeline.EMPTY);
+      TimelineAsserts.assertEmpty(timeline);
+    }
+  }
+
+  @Test
+  public void testSingleMediaSource() throws IOException {
+    Timeline timeline = getConcatenatedTimeline(false, createFakeTimeline(3, 111));
+    TimelineAsserts.assertWindowIds(timeline, 111);
+    TimelineAsserts.assertPeriodCounts(timeline, 3);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, C.INDEX_UNSET);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
+      TimelineAsserts.assertNextWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
+    }
+
+    timeline = getConcatenatedTimeline(true, createFakeTimeline(3, 111));
+    TimelineAsserts.assertWindowIds(timeline, 111);
+    TimelineAsserts.assertPeriodCounts(timeline, 3);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, C.INDEX_UNSET);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
+      TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
+      TimelineAsserts.assertNextWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 0);
+    }
+  }
+
+  @Test
+  public void testMultipleMediaSources() throws IOException {
+    Timeline[] timelines = {
+      createFakeTimeline(3, 111), createFakeTimeline(1, 222), createFakeTimeline(3, 333)
+    };
+    Timeline timeline = getConcatenatedTimeline(false, timelines);
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 3, 1, 3);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
+    assertThat(timeline.getFirstWindowIndex(false)).isEqualTo(0);
+    assertThat(timeline.getLastWindowIndex(false)).isEqualTo(2);
+    assertThat(timeline.getFirstWindowIndex(true)).isEqualTo(2);
+    assertThat(timeline.getLastWindowIndex(true)).isEqualTo(0);
+
+    timeline = getConcatenatedTimeline(true, timelines);
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 3, 1, 3);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, C.INDEX_UNSET, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ONE, shuffled, 2, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ALL, shuffled, 2, 0, 1);
+      TimelineAsserts.assertNextWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, 1, 2, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 1, 2, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
+      assertThat(timeline.getFirstWindowIndex(shuffled)).isEqualTo(0);
+      assertThat(timeline.getLastWindowIndex(shuffled)).isEqualTo(2);
+    }
+  }
+
+  @Test
+  public void testNestedMediaSources() throws IOException {
+    Timeline timeline =
+        getConcatenatedTimeline(
+            false,
+            getConcatenatedTimeline(false, createFakeTimeline(1, 111), createFakeTimeline(1, 222)),
+            getConcatenatedTimeline(true, createFakeTimeline(1, 333), createFakeTimeline(1, 444)));
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333, 444);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1, 1);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 3, 2);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ALL, false, 3, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, 1, 2, 3, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 3, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 3, 0);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, 1, 3, C.INDEX_UNSET, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 3, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 3, 0, 2);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, C.INDEX_UNSET, 0, 3, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 3, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 3, 1);
+  }
+
+  @Test
+  public void testEmptyTimelineMediaSources() throws IOException {
+    // Empty timelines in the front, back, and the middle (single and multiple in a row).
+    Timeline[] timelines = {
+      Timeline.EMPTY,
+      createFakeTimeline(1, 111),
+      Timeline.EMPTY,
+      Timeline.EMPTY,
+      createFakeTimeline(2, 222),
+      Timeline.EMPTY,
+      createFakeTimeline(3, 333),
+      Timeline.EMPTY
+    };
+    Timeline timeline = getConcatenatedTimeline(false, timelines);
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
+    assertThat(timeline.getFirstWindowIndex(false)).isEqualTo(0);
+    assertThat(timeline.getLastWindowIndex(false)).isEqualTo(2);
+    assertThat(timeline.getFirstWindowIndex(true)).isEqualTo(2);
+    assertThat(timeline.getLastWindowIndex(true)).isEqualTo(0);
+
+    timeline = getConcatenatedTimeline(true, timelines);
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, C.INDEX_UNSET, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ONE, shuffled, 2, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ALL, shuffled, 2, 0, 1);
+      TimelineAsserts.assertNextWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, 1, 2, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 1, 2, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
+      assertThat(timeline.getFirstWindowIndex(shuffled)).isEqualTo(0);
+      assertThat(timeline.getLastWindowIndex(shuffled)).isEqualTo(2);
+    }
+  }
+
+  @Test
+  public void testPeriodCreationWithAds() throws IOException, InterruptedException {
+    // Create media source with ad child source.
+    Timeline timelineContentOnly =
+        new FakeTimeline(
+            new TimelineWindowDefinition(2, 111, true, false, 10 * C.MICROS_PER_SECOND));
+    Timeline timelineWithAds =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                2,
+                222,
+                true,
+                false,
+                10 * C.MICROS_PER_SECOND,
+                FakeTimeline.createAdPlaybackState(
+                    /* adsPerAdGroup= */ 1, /* adGroupTimesUs= */ 0)));
+    FakeMediaSource mediaSourceContentOnly = new FakeMediaSource(timelineContentOnly, null);
+    FakeMediaSource mediaSourceWithAds = new FakeMediaSource(timelineWithAds, null);
+    ConcatenatingMediaSource mediaSource =
+        new ConcatenatingMediaSource(mediaSourceContentOnly, mediaSourceWithAds);
+
+    MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);
+    try {
+      Timeline timeline = testRunner.prepareSource();
+      TimelineAsserts.assertAdGroupCounts(timeline, 0, 0, 1, 1);
+
+      // Create all periods and assert period creation of child media sources has been called.
+      testRunner.assertPrepareAndReleaseAllPeriods();
+      mediaSourceContentOnly.assertMediaPeriodCreated(
+          new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+      mediaSourceContentOnly.assertMediaPeriodCreated(
+          new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 0));
+      mediaSourceWithAds.assertMediaPeriodCreated(
+          new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 1));
+      mediaSourceWithAds.assertMediaPeriodCreated(
+          new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 1));
+      mediaSourceWithAds.assertMediaPeriodCreated(
+          new MediaPeriodId(
+              /* periodIndex= */ 0,
+              /* adGroupIndex= */ 0,
+              /* adIndexInAdGroup= */ 0,
+              /* windowSequenceNumber= */ 1));
+      mediaSourceWithAds.assertMediaPeriodCreated(
+          new MediaPeriodId(
+              /* periodIndex= */ 1,
+              /* adGroupIndex= */ 0,
+              /* adIndexInAdGroup= */ 0,
+              /* windowSequenceNumber= */ 1));
+    } finally {
+      testRunner.release();
+    }
+  }
+
+  /**
+   * Wraps the specified timelines in a {@link ConcatenatingMediaSource} and returns the
+   * concatenated timeline.
+   */
+  private static Timeline getConcatenatedTimeline(boolean isRepeatOneAtomic, Timeline... timelines)
+      throws IOException {
+    FakeMediaSource[] mediaSources = new FakeMediaSource[timelines.length];
+    for (int i = 0; i < timelines.length; i++) {
+      mediaSources[i] = new FakeMediaSource(timelines[i], null);
+    }
+    ConcatenatingMediaSource mediaSource =
+        new ConcatenatingMediaSource(
+            isRepeatOneAtomic, new FakeShuffleOrder(mediaSources.length), mediaSources);
+    MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);
+    try {
+      Timeline timeline = testRunner.prepareSource();
+      testRunner.releaseSource();
+      for (int i = 0; i < mediaSources.length; i++) {
+        mediaSources[i].assertReleased();
+      }
+      return timeline;
+    } finally {
+      testRunner.release();
+    }
+  }
+
+  private static FakeTimeline createFakeTimeline(int periodCount, int windowId) {
+    return new FakeTimeline(new TimelineWindowDefinition(periodCount, windowId));
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java
new file mode 100644
index 0000000000..24f1ddd5ed
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/DynamicConcatenatingMediaSourceTest.java
@@ -0,0 +1,867 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.verify;
+
+import android.os.ConditionVariable;
+import android.os.Handler;
+import android.os.HandlerThread;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.testutil.FakeMediaSource;
+import com.google.android.exoplayer2.testutil.FakeShuffleOrder;
+import com.google.android.exoplayer2.testutil.FakeTimeline;
+import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
+import com.google.android.exoplayer2.testutil.MediaSourceTestRunner;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.testutil.TimelineAsserts;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.CountDownLatch;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mockito;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/** Unit tests for {@link DynamicConcatenatingMediaSource} */
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public final class DynamicConcatenatingMediaSourceTest {
+
+  private DynamicConcatenatingMediaSource mediaSource;
+  private MediaSourceTestRunner testRunner;
+
+  @Before
+  public void setUp() throws Exception {
+    mediaSource =
+        new DynamicConcatenatingMediaSource(/* isAtomic= */ false, new FakeShuffleOrder(0));
+    testRunner = new MediaSourceTestRunner(mediaSource, null);
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    testRunner.release();
+  }
+
+  @Test
+  public void testPlaylistChangesAfterPreparation() throws IOException, InterruptedException {
+    Timeline timeline = testRunner.prepareSource();
+    TimelineAsserts.assertEmpty(timeline);
+
+    FakeMediaSource[] childSources = createMediaSources(7);
+
+    // Add first source.
+    mediaSource.addMediaSource(childSources[0]);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 1);
+    TimelineAsserts.assertWindowIds(timeline, 111);
+
+    // Add at front of queue.
+    mediaSource.addMediaSource(0, childSources[1]);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 2, 1);
+    TimelineAsserts.assertWindowIds(timeline, 222, 111);
+
+    // Add at back of queue.
+    mediaSource.addMediaSource(childSources[2]);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 2, 1, 3);
+    TimelineAsserts.assertWindowIds(timeline, 222, 111, 333);
+
+    // Add in the middle.
+    mediaSource.addMediaSource(1, childSources[3]);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 1, 3);
+    TimelineAsserts.assertWindowIds(timeline, 222, 444, 111, 333);
+
+    // Add bulk.
+    mediaSource.addMediaSources(
+        3, Arrays.<MediaSource>asList(childSources[4], childSources[5], childSources[6]));
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 1, 5, 6, 7, 3);
+    TimelineAsserts.assertWindowIds(timeline, 222, 444, 111, 555, 666, 777, 333);
+
+    // Move sources.
+    mediaSource.moveMediaSource(2, 3);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 5, 1, 6, 7, 3);
+    TimelineAsserts.assertWindowIds(timeline, 222, 444, 555, 111, 666, 777, 333);
+    mediaSource.moveMediaSource(3, 2);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 1, 5, 6, 7, 3);
+    TimelineAsserts.assertWindowIds(timeline, 222, 444, 111, 555, 666, 777, 333);
+    mediaSource.moveMediaSource(0, 6);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 4, 1, 5, 6, 7, 3, 2);
+    TimelineAsserts.assertWindowIds(timeline, 444, 111, 555, 666, 777, 333, 222);
+    mediaSource.moveMediaSource(6, 0);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 2, 4, 1, 5, 6, 7, 3);
+    TimelineAsserts.assertWindowIds(timeline, 222, 444, 111, 555, 666, 777, 333);
+
+    // Remove in the middle.
+    mediaSource.removeMediaSource(3);
+    testRunner.assertTimelineChangeBlocking();
+    mediaSource.removeMediaSource(3);
+    testRunner.assertTimelineChangeBlocking();
+    mediaSource.removeMediaSource(3);
+    testRunner.assertTimelineChangeBlocking();
+    mediaSource.removeMediaSource(1);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 2, 1, 3);
+    TimelineAsserts.assertWindowIds(timeline, 222, 111, 333);
+    for (int i = 3; i <= 6; i++) {
+      childSources[i].assertReleased();
+    }
+
+    // Assert correct next and previous indices behavior after some insertions and removals.
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
+    assertThat(timeline.getFirstWindowIndex(false)).isEqualTo(0);
+    assertThat(timeline.getLastWindowIndex(false)).isEqualTo(timeline.getWindowCount() - 1);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
+    assertThat(timeline.getFirstWindowIndex(true)).isEqualTo(timeline.getWindowCount() - 1);
+    assertThat(timeline.getLastWindowIndex(true)).isEqualTo(0);
+
+    // Assert all periods can be prepared.
+    testRunner.assertPrepareAndReleaseAllPeriods();
+
+    // Remove at front of queue.
+    mediaSource.removeMediaSource(0);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 3);
+    TimelineAsserts.assertWindowIds(timeline, 111, 333);
+    childSources[1].assertReleased();
+
+    // Remove at back of queue.
+    mediaSource.removeMediaSource(1);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 1);
+    TimelineAsserts.assertWindowIds(timeline, 111);
+    childSources[2].assertReleased();
+
+    // Remove last source.
+    mediaSource.removeMediaSource(0);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertEmpty(timeline);
+    childSources[3].assertReleased();
+  }
+
+  @Test
+  public void testPlaylistChangesBeforePreparation() throws IOException, InterruptedException {
+    FakeMediaSource[] childSources = createMediaSources(4);
+    mediaSource.addMediaSource(childSources[0]);
+    mediaSource.addMediaSource(childSources[1]);
+    mediaSource.addMediaSource(0, childSources[2]);
+    mediaSource.moveMediaSource(0, 2);
+    mediaSource.removeMediaSource(0);
+    mediaSource.moveMediaSource(1, 0);
+    mediaSource.addMediaSource(1, childSources[3]);
+    testRunner.assertNoTimelineChange();
+
+    Timeline timeline = testRunner.prepareSource();
+    TimelineAsserts.assertPeriodCounts(timeline, 3, 4, 2);
+    TimelineAsserts.assertWindowIds(timeline, 333, 444, 222);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, 1, 2, C.INDEX_UNSET);
+
+    testRunner.assertPrepareAndReleaseAllPeriods();
+    mediaSource.releaseSource();
+    for (int i = 1; i < 4; i++) {
+      childSources[i].assertReleased();
+    }
+  }
+
+  @Test
+  public void testPlaylistWithLazyMediaSource() throws IOException, InterruptedException {
+    // Create some normal (immediately preparing) sources and some lazy sources whose timeline
+    // updates need to be triggered.
+    FakeMediaSource[] fastSources = createMediaSources(2);
+    final FakeMediaSource[] lazySources = new FakeMediaSource[4];
+    for (int i = 0; i < 4; i++) {
+      lazySources[i] = new FakeMediaSource(null, null);
+    }
+
+    // Add lazy sources and normal sources before preparation. Also remove one lazy source again
+    // before preparation to check it doesn't throw or change the result.
+    mediaSource.addMediaSource(lazySources[0]);
+    mediaSource.addMediaSource(0, fastSources[0]);
+    mediaSource.removeMediaSource(1);
+    mediaSource.addMediaSource(1, lazySources[1]);
+    testRunner.assertNoTimelineChange();
+
+    // Prepare and assert that the timeline contains all information for normal sources while having
+    // placeholder information for lazy sources.
+    Timeline timeline = testRunner.prepareSource();
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 1);
+    TimelineAsserts.assertWindowIds(timeline, 111, null);
+    TimelineAsserts.assertWindowIsDynamic(timeline, false, true);
+
+    // Trigger source info refresh for lazy source and check that the timeline now contains all
+    // information for all windows.
+    testRunner.runOnPlaybackThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            lazySources[1].setNewSourceInfo(createFakeTimeline(8), null);
+          }
+        });
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 9);
+    TimelineAsserts.assertWindowIds(timeline, 111, 999);
+    TimelineAsserts.assertWindowIsDynamic(timeline, false, false);
+    testRunner.assertPrepareAndReleaseAllPeriods();
+
+    // Add further lazy and normal sources after preparation. Also remove one lazy source again to
+    // check it doesn't throw or change the result.
+    mediaSource.addMediaSource(1, lazySources[2]);
+    testRunner.assertTimelineChangeBlocking();
+    mediaSource.addMediaSource(2, fastSources[1]);
+    testRunner.assertTimelineChangeBlocking();
+    mediaSource.addMediaSource(0, lazySources[3]);
+    testRunner.assertTimelineChangeBlocking();
+    mediaSource.removeMediaSource(2);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 2, 9);
+    TimelineAsserts.assertWindowIds(timeline, null, 111, 222, 999);
+    TimelineAsserts.assertWindowIsDynamic(timeline, true, false, false, false);
+
+    // Create a period from an unprepared lazy media source and assert Callback.onPrepared is not
+    // called yet.
+    MediaPeriod lazyPeriod =
+        testRunner.createPeriod(
+            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+    CountDownLatch preparedCondition = testRunner.preparePeriod(lazyPeriod, 0);
+    assertThat(preparedCondition.getCount()).isEqualTo(1);
+
+    // Assert that a second period can also be created and released without problems.
+    MediaPeriod secondLazyPeriod =
+        testRunner.createPeriod(
+            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+    testRunner.releasePeriod(secondLazyPeriod);
+
+    // Trigger source info refresh for lazy media source. Assert that now all information is
+    // available again and the previously created period now also finished preparing.
+    testRunner.runOnPlaybackThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            lazySources[3].setNewSourceInfo(createFakeTimeline(7), null);
+          }
+        });
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 8, 1, 2, 9);
+    TimelineAsserts.assertWindowIds(timeline, 888, 111, 222, 999);
+    TimelineAsserts.assertWindowIsDynamic(timeline, false, false, false, false);
+    assertThat(preparedCondition.getCount()).isEqualTo(0);
+
+    // Release the period and source.
+    testRunner.releasePeriod(lazyPeriod);
+    testRunner.releaseSource();
+
+    // Assert all sources were fully released.
+    for (FakeMediaSource fastSource : fastSources) {
+      fastSource.assertReleased();
+    }
+    for (FakeMediaSource lazySource : lazySources) {
+      lazySource.assertReleased();
+    }
+  }
+
+  @Test
+  public void testEmptyTimelineMediaSource() throws IOException, InterruptedException {
+    Timeline timeline = testRunner.prepareSource();
+    TimelineAsserts.assertEmpty(timeline);
+
+    mediaSource.addMediaSource(new FakeMediaSource(Timeline.EMPTY, null));
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertEmpty(timeline);
+
+    mediaSource.addMediaSources(
+        Arrays.asList(
+            new MediaSource[] {
+              new FakeMediaSource(Timeline.EMPTY, null), new FakeMediaSource(Timeline.EMPTY, null),
+              new FakeMediaSource(Timeline.EMPTY, null), new FakeMediaSource(Timeline.EMPTY, null),
+              new FakeMediaSource(Timeline.EMPTY, null), new FakeMediaSource(Timeline.EMPTY, null)
+            }));
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertEmpty(timeline);
+
+    // Insert non-empty media source to leave empty sources at the start, the end, and the middle
+    // (with single and multiple empty sources in a row).
+    MediaSource[] mediaSources = createMediaSources(3);
+    mediaSource.addMediaSource(1, mediaSources[0]);
+    testRunner.assertTimelineChangeBlocking();
+    mediaSource.addMediaSource(4, mediaSources[1]);
+    testRunner.assertTimelineChangeBlocking();
+    mediaSource.addMediaSource(6, mediaSources[2]);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 2, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, false, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, false, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, false, 1, 2, 0);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 1, 2, 0);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, true, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, true, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, true, 2, 0, 1);
+    assertThat(timeline.getFirstWindowIndex(false)).isEqualTo(0);
+    assertThat(timeline.getLastWindowIndex(false)).isEqualTo(2);
+    assertThat(timeline.getFirstWindowIndex(true)).isEqualTo(2);
+    assertThat(timeline.getLastWindowIndex(true)).isEqualTo(0);
+    testRunner.assertPrepareAndReleaseAllPeriods();
+  }
+
+  @Test
+  public void testDynamicChangeOfEmptyTimelines() throws IOException {
+    FakeMediaSource[] childSources =
+        new FakeMediaSource[] {
+          new FakeMediaSource(Timeline.EMPTY, /* manifest= */ null),
+          new FakeMediaSource(Timeline.EMPTY, /* manifest= */ null),
+          new FakeMediaSource(Timeline.EMPTY, /* manifest= */ null),
+        };
+    Timeline nonEmptyTimeline = new FakeTimeline(/* windowCount = */ 1);
+
+    mediaSource.addMediaSources(Arrays.<MediaSource>asList(childSources));
+    Timeline timeline = testRunner.prepareSource();
+    TimelineAsserts.assertEmpty(timeline);
+
+    childSources[0].setNewSourceInfo(nonEmptyTimeline, /* newManifest== */ null);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 1);
+
+    childSources[2].setNewSourceInfo(nonEmptyTimeline, /* newManifest== */ null);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 1);
+
+    childSources[1].setNewSourceInfo(nonEmptyTimeline, /* newManifest== */ null);
+    timeline = testRunner.assertTimelineChangeBlocking();
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1);
+  }
+
+  @Test
+  public void testIllegalArguments() {
+    MediaSource validSource = new FakeMediaSource(createFakeTimeline(1), null);
+
+    // Null sources.
+    try {
+      mediaSource.addMediaSource(null);
+      fail("Null mediaSource not allowed.");
+    } catch (NullPointerException e) {
+      // Expected.
+    }
+
+    MediaSource[] mediaSources = {validSource, null};
+    try {
+      mediaSource.addMediaSources(Arrays.asList(mediaSources));
+      fail("Null mediaSource not allowed.");
+    } catch (NullPointerException e) {
+      // Expected.
+    }
+
+    // Duplicate sources.
+    mediaSource.addMediaSource(validSource);
+    try {
+      mediaSource.addMediaSource(validSource);
+      fail("Duplicate mediaSource not allowed.");
+    } catch (IllegalArgumentException e) {
+      // Expected.
+    }
+
+    mediaSources =
+        new MediaSource[] {new FakeMediaSource(createFakeTimeline(2), null), validSource};
+    try {
+      mediaSource.addMediaSources(Arrays.asList(mediaSources));
+      fail("Duplicate mediaSource not allowed.");
+    } catch (IllegalArgumentException e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void testCustomCallbackBeforePreparationAddSingle() {
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSource(createFakeMediaSource(), runnable);
+    verify(runnable).run();
+  }
+
+  @Test
+  public void testCustomCallbackBeforePreparationAddMultiple() {
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSources(
+        Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+        runnable);
+    verify(runnable).run();
+  }
+
+  @Test
+  public void testCustomCallbackBeforePreparationAddSingleWithIndex() {
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), runnable);
+    verify(runnable).run();
+  }
+
+  @Test
+  public void testCustomCallbackBeforePreparationAddMultipleWithIndex() {
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSources(
+        /* index */ 0,
+        Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+        runnable);
+    verify(runnable).run();
+  }
+
+  @Test
+  public void testCustomCallbackBeforePreparationRemove() {
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSource(createFakeMediaSource());
+    mediaSource.removeMediaSource(/* index */ 0, runnable);
+    verify(runnable).run();
+  }
+
+  @Test
+  public void testCustomCallbackBeforePreparationMove() {
+    Runnable runnable = Mockito.mock(Runnable.class);
+
+    mediaSource.addMediaSources(
+        Arrays.asList(new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}));
+    mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, runnable);
+    verify(runnable).run();
+  }
+
+  @Test
+  public void testCustomCallbackAfterPreparationAddSingle() throws IOException {
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    try {
+      testRunner.prepareSource();
+      final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
+      dummyMainThread.runOnMainThread(
+          new Runnable() {
+            @Override
+            public void run() {
+              mediaSource.addMediaSource(createFakeMediaSource(), timelineGrabber);
+            }
+          });
+      Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
+      assertThat(timeline.getWindowCount()).isEqualTo(1);
+    } finally {
+      dummyMainThread.release();
+    }
+  }
+
+  @Test
+  public void testCustomCallbackAfterPreparationAddMultiple() throws IOException {
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    try {
+      testRunner.prepareSource();
+      final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
+      dummyMainThread.runOnMainThread(
+          new Runnable() {
+            @Override
+            public void run() {
+              mediaSource.addMediaSources(
+                  Arrays.asList(
+                      new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+                  timelineGrabber);
+            }
+          });
+      Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
+      assertThat(timeline.getWindowCount()).isEqualTo(2);
+    } finally {
+      dummyMainThread.release();
+    }
+  }
+
+  @Test
+  public void testCustomCallbackAfterPreparationAddSingleWithIndex() throws IOException {
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    try {
+      testRunner.prepareSource();
+      final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
+      dummyMainThread.runOnMainThread(
+          new Runnable() {
+            @Override
+            public void run() {
+              mediaSource.addMediaSource(/* index */ 0, createFakeMediaSource(), timelineGrabber);
+            }
+          });
+      Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
+      assertThat(timeline.getWindowCount()).isEqualTo(1);
+    } finally {
+      dummyMainThread.release();
+    }
+  }
+
+  @Test
+  public void testCustomCallbackAfterPreparationAddMultipleWithIndex() throws IOException {
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    try {
+      testRunner.prepareSource();
+      final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
+      dummyMainThread.runOnMainThread(
+          new Runnable() {
+            @Override
+            public void run() {
+              mediaSource.addMediaSources(
+                  /* index */ 0,
+                  Arrays.asList(
+                      new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}),
+                  timelineGrabber);
+            }
+          });
+      Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
+      assertThat(timeline.getWindowCount()).isEqualTo(2);
+    } finally {
+      dummyMainThread.release();
+    }
+  }
+
+  @Test
+  public void testCustomCallbackAfterPreparationRemove() throws IOException {
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    try {
+      testRunner.prepareSource();
+      dummyMainThread.runOnMainThread(
+          new Runnable() {
+            @Override
+            public void run() {
+              mediaSource.addMediaSource(createFakeMediaSource());
+            }
+          });
+      testRunner.assertTimelineChangeBlocking();
+
+      final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
+      dummyMainThread.runOnMainThread(
+          new Runnable() {
+            @Override
+            public void run() {
+              mediaSource.removeMediaSource(/* index */ 0, timelineGrabber);
+            }
+          });
+      Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
+      assertThat(timeline.getWindowCount()).isEqualTo(0);
+    } finally {
+      dummyMainThread.release();
+    }
+  }
+
+  @Test
+  public void testCustomCallbackAfterPreparationMove() throws IOException {
+    DummyMainThread dummyMainThread = new DummyMainThread();
+    try {
+      testRunner.prepareSource();
+      dummyMainThread.runOnMainThread(
+          new Runnable() {
+            @Override
+            public void run() {
+              mediaSource.addMediaSources(
+                  Arrays.asList(
+                      new MediaSource[] {createFakeMediaSource(), createFakeMediaSource()}));
+            }
+          });
+      testRunner.assertTimelineChangeBlocking();
+
+      final TimelineGrabber timelineGrabber = new TimelineGrabber(testRunner);
+      dummyMainThread.runOnMainThread(
+          new Runnable() {
+            @Override
+            public void run() {
+              mediaSource.moveMediaSource(/* fromIndex */ 1, /* toIndex */ 0, timelineGrabber);
+            }
+          });
+      Timeline timeline = timelineGrabber.assertTimelineChangeBlocking();
+      assertThat(timeline.getWindowCount()).isEqualTo(2);
+    } finally {
+      dummyMainThread.release();
+    }
+  }
+
+  @Test
+  public void testPeriodCreationWithAds() throws IOException, InterruptedException {
+    // Create dynamic media source with ad child source.
+    Timeline timelineContentOnly =
+        new FakeTimeline(
+            new TimelineWindowDefinition(2, 111, true, false, 10 * C.MICROS_PER_SECOND));
+    Timeline timelineWithAds =
+        new FakeTimeline(
+            new TimelineWindowDefinition(
+                2,
+                222,
+                true,
+                false,
+                10 * C.MICROS_PER_SECOND,
+                FakeTimeline.createAdPlaybackState(
+                    /* adsPerAdGroup= */ 1, /* adGroupTimesUs= */ 0)));
+    FakeMediaSource mediaSourceContentOnly = new FakeMediaSource(timelineContentOnly, null);
+    FakeMediaSource mediaSourceWithAds = new FakeMediaSource(timelineWithAds, null);
+    mediaSource.addMediaSource(mediaSourceContentOnly);
+    mediaSource.addMediaSource(mediaSourceWithAds);
+
+    Timeline timeline = testRunner.prepareSource();
+
+    // Assert the timeline contains ad groups.
+    TimelineAsserts.assertAdGroupCounts(timeline, 0, 0, 1, 1);
+
+    // Create all periods and assert period creation of child media sources has been called.
+    testRunner.assertPrepareAndReleaseAllPeriods();
+    mediaSourceContentOnly.assertMediaPeriodCreated(
+        new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+    mediaSourceContentOnly.assertMediaPeriodCreated(
+        new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 0));
+    mediaSourceWithAds.assertMediaPeriodCreated(
+        new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 1));
+    mediaSourceWithAds.assertMediaPeriodCreated(
+        new MediaPeriodId(/* periodIndex= */ 1, /* windowSequenceNumber= */ 1));
+    mediaSourceWithAds.assertMediaPeriodCreated(
+        new MediaPeriodId(
+            /* periodIndex= */ 0,
+            /* adGroupIndex= */ 0,
+            /* adIndexInAdGroup= */ 0,
+            /* windowSequenceNumber= */ 1));
+    mediaSourceWithAds.assertMediaPeriodCreated(
+        new MediaPeriodId(
+            /* periodIndex= */ 1,
+            /* adGroupIndex= */ 0,
+            /* adIndexInAdGroup= */ 0,
+            /* windowSequenceNumber= */ 1));
+  }
+
+  @Test
+  public void testAtomicTimelineWindowOrder() throws IOException {
+    // Release default test runner with non-atomic media source and replace with new test runner.
+    testRunner.release();
+    DynamicConcatenatingMediaSource mediaSource =
+        new DynamicConcatenatingMediaSource(/* isAtomic= */ true, new FakeShuffleOrder(0));
+    testRunner = new MediaSourceTestRunner(mediaSource, null);
+    mediaSource.addMediaSources(Arrays.<MediaSource>asList(createMediaSources(3)));
+    Timeline timeline = testRunner.prepareSource();
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, /* shuffleModeEnabled= */ false, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, /* shuffleModeEnabled= */ true, C.INDEX_UNSET, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ONE, /* shuffleModeEnabled= */ false, 2, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ONE, /* shuffleModeEnabled= */ true, 2, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ALL, /* shuffleModeEnabled= */ false, 2, 0, 1);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ALL, /* shuffleModeEnabled= */ true, 2, 0, 1);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, /* shuffleModeEnabled= */ false, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, /* shuffleModeEnabled= */ true, 1, 2, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_ONE, /* shuffleModeEnabled= */ false, 1, 2, 0);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_ONE, /* shuffleModeEnabled= */ true, 1, 2, 0);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_ALL, /* shuffleModeEnabled= */ false, 1, 2, 0);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_ALL, /* shuffleModeEnabled= */ true, 1, 2, 0);
+    assertThat(timeline.getFirstWindowIndex(/* shuffleModeEnabled= */ false)).isEqualTo(0);
+    assertThat(timeline.getFirstWindowIndex(/* shuffleModeEnabled= */ true)).isEqualTo(0);
+    assertThat(timeline.getLastWindowIndex(/* shuffleModeEnabled= */ false)).isEqualTo(2);
+    assertThat(timeline.getLastWindowIndex(/* shuffleModeEnabled= */ true)).isEqualTo(2);
+  }
+
+  @Test
+  public void testNestedTimeline() throws IOException {
+    DynamicConcatenatingMediaSource nestedSource1 =
+        new DynamicConcatenatingMediaSource(/* isAtomic= */ false, new FakeShuffleOrder(0));
+    DynamicConcatenatingMediaSource nestedSource2 =
+        new DynamicConcatenatingMediaSource(/* isAtomic= */ true, new FakeShuffleOrder(0));
+    mediaSource.addMediaSource(nestedSource1);
+    mediaSource.addMediaSource(nestedSource2);
+    testRunner.prepareSource();
+    FakeMediaSource[] childSources = createMediaSources(4);
+    nestedSource1.addMediaSource(childSources[0]);
+    testRunner.assertTimelineChangeBlocking();
+    nestedSource1.addMediaSource(childSources[1]);
+    testRunner.assertTimelineChangeBlocking();
+    nestedSource2.addMediaSource(childSources[2]);
+    testRunner.assertTimelineChangeBlocking();
+    nestedSource2.addMediaSource(childSources[3]);
+    Timeline timeline = testRunner.assertTimelineChangeBlocking();
+
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333, 444);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 2, 3, 4);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, /* shuffleModeEnabled= */ false, C.INDEX_UNSET, 0, 1, 2);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ONE, /* shuffleModeEnabled= */ false, 0, 1, 3, 2);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ALL, /* shuffleModeEnabled= */ false, 3, 0, 1, 2);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, /* shuffleModeEnabled= */ false, 1, 2, 3, C.INDEX_UNSET);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_ONE, /* shuffleModeEnabled= */ false, 0, 1, 3, 2);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_ALL, /* shuffleModeEnabled= */ false, 1, 2, 3, 0);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, /* shuffleModeEnabled= */ true, 1, 3, C.INDEX_UNSET, 2);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ONE, /* shuffleModeEnabled= */ true, 0, 1, 3, 2);
+    TimelineAsserts.assertPreviousWindowIndices(
+        timeline, Player.REPEAT_MODE_ALL, /* shuffleModeEnabled= */ true, 1, 3, 0, 2);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_OFF, /* shuffleModeEnabled= */ true, C.INDEX_UNSET, 0, 3, 1);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_ONE, /* shuffleModeEnabled= */ true, 0, 1, 3, 2);
+    TimelineAsserts.assertNextWindowIndices(
+        timeline, Player.REPEAT_MODE_ALL, /* shuffleModeEnabled= */ true, 2, 0, 3, 1);
+  }
+
+  @Test
+  public void testRemoveChildSourceWithActiveMediaPeriod() throws IOException {
+    FakeMediaSource childSource = createFakeMediaSource();
+    mediaSource.addMediaSource(childSource);
+    testRunner.prepareSource();
+    MediaPeriod mediaPeriod =
+        testRunner.createPeriod(
+            new MediaPeriodId(/* periodIndex= */ 0, /* windowSequenceNumber= */ 0));
+    mediaSource.removeMediaSource(/* index= */ 0);
+    testRunner.assertTimelineChangeBlocking();
+    testRunner.releasePeriod(mediaPeriod);
+    childSource.assertReleased();
+    testRunner.releaseSource();
+  }
+
+  private static FakeMediaSource[] createMediaSources(int count) {
+    FakeMediaSource[] sources = new FakeMediaSource[count];
+    for (int i = 0; i < count; i++) {
+      sources[i] = new FakeMediaSource(createFakeTimeline(i), null);
+    }
+    return sources;
+  }
+
+  private static FakeMediaSource createFakeMediaSource() {
+    return new FakeMediaSource(createFakeTimeline(/* index */ 0), null);
+  }
+
+  private static FakeTimeline createFakeTimeline(int index) {
+    return new FakeTimeline(new TimelineWindowDefinition(index + 1, (index + 1) * 111));
+  }
+
+  private static final class DummyMainThread {
+
+    private final HandlerThread thread;
+    private final Handler handler;
+
+    private DummyMainThread() {
+      thread = new HandlerThread("DummyMainThread");
+      thread.start();
+      handler = new Handler(thread.getLooper());
+    }
+
+    /**
+     * Runs the provided {@link Runnable} on the main thread, blocking until execution completes.
+     *
+     * @param runnable The {@link Runnable} to run.
+     */
+    public void runOnMainThread(final Runnable runnable) {
+      final ConditionVariable finishedCondition = new ConditionVariable();
+      handler.post(
+          new Runnable() {
+            @Override
+            public void run() {
+              runnable.run();
+              finishedCondition.open();
+            }
+          });
+      assertThat(finishedCondition.block(MediaSourceTestRunner.TIMEOUT_MS)).isTrue();
+    }
+
+    public void release() {
+      thread.quit();
+    }
+  }
+
+  private static final class TimelineGrabber implements Runnable {
+
+    private final MediaSourceTestRunner testRunner;
+    private final ConditionVariable finishedCondition;
+
+    private Timeline timeline;
+    private AssertionError error;
+
+    public TimelineGrabber(MediaSourceTestRunner testRunner) {
+      this.testRunner = testRunner;
+      finishedCondition = new ConditionVariable();
+    }
+
+    @Override
+    public void run() {
+      try {
+        timeline = testRunner.assertTimelineChange();
+      } catch (AssertionError e) {
+        error = e;
+      }
+      finishedCondition.open();
+    }
+
+    public Timeline assertTimelineChangeBlocking() {
+      assertThat(finishedCondition.block(MediaSourceTestRunner.TIMEOUT_MS)).isTrue();
+      if (error != null) {
+        throw error;
+      }
+      return timeline;
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
new file mode 100644
index 0000000000..6aa710aff4
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/LoopingMediaSourceTest.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.testutil.FakeMediaSource;
+import com.google.android.exoplayer2.testutil.FakeTimeline;
+import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
+import com.google.android.exoplayer2.testutil.MediaSourceTestRunner;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import com.google.android.exoplayer2.testutil.TimelineAsserts;
+import java.io.IOException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/** Unit tests for {@link LoopingMediaSource}. */
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public class LoopingMediaSourceTest {
+
+  private FakeTimeline multiWindowTimeline;
+
+  @Before
+  public void setUp() throws Exception {
+    multiWindowTimeline =
+        new FakeTimeline(
+            new TimelineWindowDefinition(1, 111),
+            new TimelineWindowDefinition(1, 222),
+            new TimelineWindowDefinition(1, 333));
+  }
+
+  @Test
+  public void testSingleLoop() throws IOException {
+    Timeline timeline = getLoopingTimeline(multiWindowTimeline, 1);
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, C.INDEX_UNSET, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ALL, shuffled, 2, 0, 1);
+      TimelineAsserts.assertNextWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, 1, 2, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
+    }
+  }
+
+  @Test
+  public void testMultiLoop() throws IOException {
+    Timeline timeline = getLoopingTimeline(multiWindowTimeline, 3);
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333, 111, 222, 333, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1, 1, 1, 1, 1, 1, 1);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, C.INDEX_UNSET, 0, 1, 2, 3, 4, 5, 6, 7, 8);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2, 3, 4, 5, 6, 7, 8);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ALL, shuffled, 8, 0, 1, 2, 3, 4, 5, 6, 7);
+      TimelineAsserts.assertNextWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, 1, 2, 3, 4, 5, 6, 7, 8, C.INDEX_UNSET);
+      TimelineAsserts.assertNextWindowIndices(
+          timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2, 3, 4, 5, 6, 7, 8);
+      TimelineAsserts.assertNextWindowIndices(
+          timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 3, 4, 5, 6, 7, 8, 0);
+    }
+  }
+
+  @Test
+  public void testInfiniteLoop() throws IOException {
+    Timeline timeline = getLoopingTimeline(multiWindowTimeline, Integer.MAX_VALUE);
+    TimelineAsserts.assertWindowIds(timeline, 111, 222, 333);
+    TimelineAsserts.assertPeriodCounts(timeline, 1, 1, 1);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_OFF, shuffled, 2, 0, 1);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2);
+      TimelineAsserts.assertPreviousWindowIndices(
+          timeline, Player.REPEAT_MODE_ALL, shuffled, 2, 0, 1);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_OFF, shuffled, 1, 2, 0);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ONE, shuffled, 0, 1, 2);
+      TimelineAsserts.assertNextWindowIndices(timeline, Player.REPEAT_MODE_ALL, shuffled, 1, 2, 0);
+    }
+  }
+
+  @Test
+  public void testEmptyTimelineLoop() throws IOException {
+    Timeline timeline = getLoopingTimeline(Timeline.EMPTY, 1);
+    TimelineAsserts.assertEmpty(timeline);
+
+    timeline = getLoopingTimeline(Timeline.EMPTY, 3);
+    TimelineAsserts.assertEmpty(timeline);
+
+    timeline = getLoopingTimeline(Timeline.EMPTY, Integer.MAX_VALUE);
+    TimelineAsserts.assertEmpty(timeline);
+  }
+
+  /**
+   * Wraps the specified timeline in a {@link LoopingMediaSource} and returns the looping timeline.
+   */
+  private static Timeline getLoopingTimeline(Timeline timeline, int loopCount) throws IOException {
+    FakeMediaSource fakeMediaSource = new FakeMediaSource(timeline, null);
+    LoopingMediaSource mediaSource = new LoopingMediaSource(fakeMediaSource, loopCount);
+    MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);
+    try {
+      Timeline loopingTimeline = testRunner.prepareSource();
+      testRunner.releaseSource();
+      fakeMediaSource.assertReleased();
+      return loopingTimeline;
+    } finally {
+      testRunner.release();
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java
new file mode 100644
index 0000000000..839492f196
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/MergingMediaSourceTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MergingMediaSource.IllegalMergeException;
+import com.google.android.exoplayer2.testutil.FakeMediaSource;
+import com.google.android.exoplayer2.testutil.FakeTimeline;
+import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
+import com.google.android.exoplayer2.testutil.MediaSourceTestRunner;
+import com.google.android.exoplayer2.testutil.RobolectricUtil;
+import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/** Unit tests for {@link MergingMediaSource}. */
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public class MergingMediaSourceTest {
+
+  @Test
+  public void testMergingDynamicTimelines() throws IOException {
+    FakeTimeline firstTimeline =
+        new FakeTimeline(new TimelineWindowDefinition(true, true, C.TIME_UNSET));
+    FakeTimeline secondTimeline =
+        new FakeTimeline(new TimelineWindowDefinition(true, true, C.TIME_UNSET));
+    testMergingMediaSourcePrepare(firstTimeline, secondTimeline);
+  }
+
+  @Test
+  public void testMergingStaticTimelines() throws IOException {
+    FakeTimeline firstTimeline = new FakeTimeline(new TimelineWindowDefinition(true, false, 20));
+    FakeTimeline secondTimeline = new FakeTimeline(new TimelineWindowDefinition(true, false, 10));
+    testMergingMediaSourcePrepare(firstTimeline, secondTimeline);
+  }
+
+  @Test
+  public void testMergingTimelinesWithDifferentPeriodCounts() throws IOException {
+    FakeTimeline firstTimeline = new FakeTimeline(new TimelineWindowDefinition(1, null));
+    FakeTimeline secondTimeline = new FakeTimeline(new TimelineWindowDefinition(2, null));
+    try {
+      testMergingMediaSourcePrepare(firstTimeline, secondTimeline);
+      fail("Expected merging to fail.");
+    } catch (IllegalMergeException e) {
+      assertThat(e.reason).isEqualTo(IllegalMergeException.REASON_PERIOD_COUNT_MISMATCH);
+    }
+  }
+
+  /**
+   * Wraps the specified timelines in a {@link MergingMediaSource}, prepares it and checks that it
+   * forwards the first of the wrapped timelines.
+   */
+  private static void testMergingMediaSourcePrepare(Timeline... timelines) throws IOException {
+    FakeMediaSource[] mediaSources = new FakeMediaSource[timelines.length];
+    for (int i = 0; i < timelines.length; i++) {
+      mediaSources[i] = new FakeMediaSource(timelines[i], null);
+    }
+    MergingMediaSource mediaSource = new MergingMediaSource(mediaSources);
+    MediaSourceTestRunner testRunner = new MediaSourceTestRunner(mediaSource, null);
+    try {
+      Timeline timeline = testRunner.prepareSource();
+      // The merged timeline should always be the one from the first child.
+      assertThat(timeline).isEqualTo(timelines[0]);
+      testRunner.releaseSource();
+      for (int i = 0; i < mediaSources.length; i++) {
+        mediaSources[i].assertReleased();
+      }
+    } finally {
+      testRunner.release();
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
index 49983fae30..4d6b6dd72d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/SampleQueueTest.java
@@ -36,13 +36,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Test for {@link SampleQueue}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class SampleQueueTest {
 
   private static final int ALLOCATION_SIZE = 16;
@@ -215,12 +213,14 @@ public void testReadMultiSamplesTwice() {
   public void testReadMultiWithRewind() {
     writeTestData();
     assertReadTestData();
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(0);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertAllocationCount(10);
     // Rewind.
     sampleQueue.rewind();
     assertAllocationCount(10);
     // Read again.
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(0);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(0);
     assertReadTestData();
   }
@@ -230,11 +230,14 @@ public void testRewindAfterDiscard() {
     writeTestData();
     assertReadTestData();
     sampleQueue.discardToRead();
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(8);
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertAllocationCount(0);
     // Rewind.
     sampleQueue.rewind();
     assertAllocationCount(0);
     // Can't read again.
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(8);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertReadEndOfStream(false);
   }
@@ -332,6 +335,7 @@ public void testDiscardToEnd() {
     writeTestData();
     // Should discard everything.
     sampleQueue.discardToEnd();
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(8);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertAllocationCount(0);
     // We should still be able to read the upstream format.
@@ -346,28 +350,39 @@ public void testDiscardToStopAtReadPosition() {
     writeTestData();
     // Shouldn't discard anything.
     sampleQueue.discardTo(LAST_SAMPLE_TIMESTAMP, false, true);
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(0);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(0);
     assertAllocationCount(10);
     // Read the first sample.
     assertReadTestData(null, 0, 1);
     // Shouldn't discard anything.
     sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1] - 1, false, true);
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(0);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(10);
     // Should discard the read sample.
     sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1], false, true);
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(1);
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(9);
     // Shouldn't discard anything.
     sampleQueue.discardTo(LAST_SAMPLE_TIMESTAMP, false, true);
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(1);
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(9);
     // Should be able to read the remaining samples.
     assertReadTestData(TEST_FORMAT_1, 1, 7);
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(1);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     // Should discard up to the second last sample
     sampleQueue.discardTo(LAST_SAMPLE_TIMESTAMP - 1, false, true);
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(6);
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertAllocationCount(3);
     // Should discard up the last sample
     sampleQueue.discardTo(LAST_SAMPLE_TIMESTAMP, false, true);
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(7);
+    assertThat(sampleQueue.getReadIndex()).isEqualTo(8);
     assertAllocationCount(1);
   }
 
@@ -376,10 +391,12 @@ public void testDiscardToDontStopAtReadPosition() {
     writeTestData();
     // Shouldn't discard anything.
     sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1] - 1, false, false);
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(0);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(0);
     assertAllocationCount(10);
     // Should discard the first sample.
     sampleQueue.discardTo(TEST_SAMPLE_TIMESTAMPS[1], false, false);
+    assertThat(sampleQueue.getFirstIndex()).isEqualTo(1);
     assertThat(sampleQueue.getReadIndex()).isEqualTo(1);
     assertAllocationCount(9);
     // Should be able to read the remaining samples.
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
index 1229e47883..e15c8f0aaa 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ShuffleOrderTest.java
@@ -24,13 +24,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link ShuffleOrder}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ShuffleOrderTest {
 
   public static final long RANDOM_SEED = 1234567890L;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
new file mode 100644
index 0000000000..2627052cc5
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/SinglePeriodTimelineTest.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.util.Pair;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Timeline.Period;
+import com.google.android.exoplayer2.Timeline.Window;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/**
+ * Unit test for {@link SinglePeriodTimeline}.
+ */
+@RunWith(RobolectricTestRunner.class)
+public final class SinglePeriodTimelineTest {
+
+  private Window window;
+  private Period period;
+
+  @Before
+  public void setUp() throws Exception {
+    window = new Window();
+    period = new Period();
+  }
+
+  @Test
+  public void testGetPeriodPositionDynamicWindowUnknownDuration() {
+    SinglePeriodTimeline timeline = new SinglePeriodTimeline(C.TIME_UNSET, false, true);
+    // Should return null with any positive position projection.
+    Pair<Integer, Long> position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, 1);
+    assertThat(position).isNull();
+    // Should return (0, 0) without a position projection.
+    position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, 0);
+    assertThat(position.first).isEqualTo(0);
+    assertThat(position.second).isEqualTo(0);
+  }
+
+  @Test
+  public void testGetPeriodPositionDynamicWindowKnownDuration() {
+    long windowDurationUs = 1000;
+    SinglePeriodTimeline timeline = new SinglePeriodTimeline(windowDurationUs, windowDurationUs, 0,
+        0, false, true);
+    // Should return null with a positive position projection beyond window duration.
+    Pair<Integer, Long> position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET,
+        windowDurationUs + 1);
+    assertThat(position).isNull();
+    // Should return (0, duration) with a projection equal to window duration.
+    position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, windowDurationUs);
+    assertThat(position.first).isEqualTo(0);
+    assertThat(position.second).isEqualTo(windowDurationUs);
+    // Should return (0, 0) without a position projection.
+    position = timeline.getPeriodPosition(window, period, 0, C.TIME_UNSET, 0);
+    assertThat(position.first).isEqualTo(0);
+    assertThat(position.second).isEqualTo(0);
+  }
+
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java b/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java
new file mode 100644
index 0000000000..a8cc04473d
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/source/ads/AdPlaybackStateTest.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.ads;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link AdPlaybackState}. */
+@RunWith(RobolectricTestRunner.class)
+public final class AdPlaybackStateTest {
+
+  private static final long[] TEST_AD_GROUP_TMES_US = new long[] {0, C.msToUs(10_000)};
+  private static final Uri TEST_URI = Uri.EMPTY;
+
+  private AdPlaybackState state;
+
+  @Before
+  public void setUp() {
+    state = new AdPlaybackState(TEST_AD_GROUP_TMES_US);
+  }
+
+  @Test
+  public void testSetAdCount() {
+    assertThat(state.adGroups[0].count).isEqualTo(C.LENGTH_UNSET);
+    state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 1);
+    assertThat(state.adGroups[0].count).isEqualTo(1);
+  }
+
+  @Test
+  public void testSetAdUriBeforeAdCount() {
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 1, TEST_URI);
+    state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 2);
+
+    assertThat(state.adGroups[0].uris[0]).isNull();
+    assertThat(state.adGroups[0].states[0]).isEqualTo(AdPlaybackState.AD_STATE_UNAVAILABLE);
+    assertThat(state.adGroups[0].uris[1]).isSameAs(TEST_URI);
+    assertThat(state.adGroups[0].states[1]).isEqualTo(AdPlaybackState.AD_STATE_AVAILABLE);
+  }
+
+  @Test
+  public void testSetAdErrorBeforeAdCount() {
+    state = state.withAdLoadError(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0);
+    state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 2);
+
+    assertThat(state.adGroups[0].uris[0]).isNull();
+    assertThat(state.adGroups[0].states[0]).isEqualTo(AdPlaybackState.AD_STATE_ERROR);
+    assertThat(state.adGroups[0].states[1]).isEqualTo(AdPlaybackState.AD_STATE_UNAVAILABLE);
+  }
+
+  @Test
+  public void testGetFirstAdIndexToPlayIsZero() {
+    state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 3);
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0, TEST_URI);
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 2, TEST_URI);
+
+    assertThat(state.adGroups[0].getFirstAdIndexToPlay()).isEqualTo(0);
+  }
+
+  @Test
+  public void testGetFirstAdIndexToPlaySkipsPlayedAd() {
+    state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 3);
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0, TEST_URI);
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 2, TEST_URI);
+
+    state = state.withPlayedAd(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0);
+
+    assertThat(state.adGroups[0].getFirstAdIndexToPlay()).isEqualTo(1);
+    assertThat(state.adGroups[0].states[1]).isEqualTo(AdPlaybackState.AD_STATE_UNAVAILABLE);
+    assertThat(state.adGroups[0].states[2]).isEqualTo(AdPlaybackState.AD_STATE_AVAILABLE);
+  }
+
+  @Test
+  public void testGetFirstAdIndexToPlaySkipsErrorAds() {
+    state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 3);
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0, TEST_URI);
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 2, TEST_URI);
+
+    state = state.withPlayedAd(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0);
+    state = state.withAdLoadError(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 1);
+
+    assertThat(state.adGroups[0].getFirstAdIndexToPlay()).isEqualTo(2);
+  }
+
+  @Test
+  public void testGetNextAdIndexToPlaySkipsErrorAds() {
+    state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 3);
+    state = state.withAdUri(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 1, TEST_URI);
+
+    state = state.withAdLoadError(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 1);
+
+    assertThat(state.adGroups[0].getNextAdIndexToPlay(0)).isEqualTo(2);
+  }
+
+  @Test
+  public void testSetAdStateTwiceThrows() {
+    state = state.withAdCount(/* adGroupIndex= */ 0, /* adCount= */ 1);
+    state = state.withPlayedAd(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0);
+    try {
+      state.withAdLoadError(/* adGroupIndex= */ 0, /* adIndexInAdGroup= */ 0);
+      fail();
+    } catch (Exception e) {
+      // Expected.
+    }
+  }
+
+  @Test
+  public void testSkipAllWithoutAdCount() {
+    state = state.withSkippedAdGroup(0);
+    state = state.withSkippedAdGroup(1);
+    assertThat(state.adGroups[0].count).isEqualTo(0);
+    assertThat(state.adGroups[1].count).isEqualTo(0);
+  }
+}
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java
similarity index 50%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java
index 9ed4d79307..746066cb35 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ssa/SsaDecoderTest.java
@@ -15,15 +15,19 @@
  */
 package com.google.android.exoplayer2.text.ssa;
 
-import android.test.InstrumentationTestCase;
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
 import java.util.ArrayList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit test for {@link SsaDecoder}.
- */
-public final class SsaDecoderTest extends InstrumentationTestCase {
+/** Unit test for {@link SsaDecoder}. */
+@RunWith(RobolectricTestRunner.class)
+public final class SsaDecoderTest {
 
   private static final String EMPTY = "ssa/empty";
   private static final String TYPICAL = "ssa/typical";
@@ -33,91 +37,95 @@
   private static final String INVALID_TIMECODES = "ssa/invalid_timecodes";
   private static final String NO_END_TIMECODES = "ssa/no_end_timecodes";
 
+  @Test
   public void testDecodeEmpty() throws IOException {
     SsaDecoder decoder = new SsaDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), EMPTY);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, EMPTY);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(0, subtitle.getEventTimeCount());
-    assertTrue(subtitle.getCues(0).isEmpty());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(0);
+    assertThat(subtitle.getCues(0).isEmpty()).isTrue();
   }
 
+  @Test
   public void testDecodeTypical() throws IOException {
     SsaDecoder decoder = new SsaDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(6, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue2(subtitle, 2);
     assertTypicalCue3(subtitle, 4);
   }
 
+  @Test
   public void testDecodeTypicalWithInitializationData() throws IOException {
-    byte[] headerBytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_HEADER_ONLY);
-    byte[] formatBytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_FORMAT_ONLY);
+    byte[] headerBytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_HEADER_ONLY);
+    byte[] formatBytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_FORMAT_ONLY);
     ArrayList<byte[]> initializationData = new ArrayList<>();
     initializationData.add(formatBytes);
     initializationData.add(headerBytes);
     SsaDecoder decoder = new SsaDecoder(initializationData);
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_DIALOGUE_ONLY);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_DIALOGUE_ONLY);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(6, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue2(subtitle, 2);
     assertTypicalCue3(subtitle, 4);
   }
 
+  @Test
   public void testDecodeInvalidTimecodes() throws IOException {
     // Parsing should succeed, parsing the third cue only.
     SsaDecoder decoder = new SsaDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), INVALID_TIMECODES);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, INVALID_TIMECODES);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(2, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(2);
     assertTypicalCue3(subtitle, 0);
   }
 
+  @Test
   public void testDecodeNoEndTimecodes() throws IOException {
     SsaDecoder decoder = new SsaDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), NO_END_TIMECODES);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, NO_END_TIMECODES);
     SsaSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(3, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(3);
 
-    assertEquals(0, subtitle.getEventTime(0));
-    assertEquals("This is the first subtitle.",
-        subtitle.getCues(subtitle.getEventTime(0)).get(0).text.toString());
+    assertThat(subtitle.getEventTime(0)).isEqualTo(0);
+    assertThat(subtitle.getCues(subtitle.getEventTime(0)).get(0).text.toString())
+        .isEqualTo("This is the first subtitle.");
 
-    assertEquals(2340000, subtitle.getEventTime(1));
-    assertEquals("This is the second subtitle \nwith a newline \nand another.",
-        subtitle.getCues(subtitle.getEventTime(1)).get(0).text.toString());
+    assertThat(subtitle.getEventTime(1)).isEqualTo(2340000);
+    assertThat(subtitle.getCues(subtitle.getEventTime(1)).get(0).text.toString())
+        .isEqualTo("This is the second subtitle \nwith a newline \nand another.");
 
-    assertEquals(4560000, subtitle.getEventTime(2));
-    assertEquals("This is the third subtitle, with a comma.",
-        subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString());
+    assertThat(subtitle.getEventTime(2)).isEqualTo(4560000);
+    assertThat(subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString())
+        .isEqualTo("This is the third subtitle, with a comma.");
   }
 
   private static void assertTypicalCue1(SsaSubtitle subtitle, int eventIndex) {
-    assertEquals(0, subtitle.getEventTime(eventIndex));
-    assertEquals("This is the first subtitle.",
-        subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString());
-    assertEquals(1230000, subtitle.getEventTime(eventIndex + 1));
+    assertThat(subtitle.getEventTime(eventIndex)).isEqualTo(0);
+    assertThat(subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString())
+        .isEqualTo("This is the first subtitle.");
+    assertThat(subtitle.getEventTime(eventIndex + 1)).isEqualTo(1230000);
   }
 
   private static void assertTypicalCue2(SsaSubtitle subtitle, int eventIndex) {
-    assertEquals(2340000, subtitle.getEventTime(eventIndex));
-    assertEquals("This is the second subtitle \nwith a newline \nand another.",
-        subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString());
-    assertEquals(3450000, subtitle.getEventTime(eventIndex + 1));
+    assertThat(subtitle.getEventTime(eventIndex)).isEqualTo(2340000);
+    assertThat(subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString())
+        .isEqualTo("This is the second subtitle \nwith a newline \nand another.");
+    assertThat(subtitle.getEventTime(eventIndex + 1)).isEqualTo(3450000);
   }
 
   private static void assertTypicalCue3(SsaSubtitle subtitle, int eventIndex) {
-    assertEquals(4560000, subtitle.getEventTime(eventIndex));
-    assertEquals("This is the third subtitle, with a comma.",
-        subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString());
-    assertEquals(8900000, subtitle.getEventTime(eventIndex + 1));
+    assertThat(subtitle.getEventTime(eventIndex)).isEqualTo(4560000);
+    assertThat(subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString())
+        .isEqualTo("This is the third subtitle, with a comma.");
+    assertThat(subtitle.getEventTime(eventIndex + 1)).isEqualTo(8900000);
   }
-
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
similarity index 56%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
index 744634edda..e9abaca075 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/subrip/SubripDecoderTest.java
@@ -15,14 +15,18 @@
  */
 package com.google.android.exoplayer2.text.subrip;
 
-import android.test.InstrumentationTestCase;
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit test for {@link SubripDecoder}.
- */
-public final class SubripDecoderTest extends InstrumentationTestCase {
+/** Unit test for {@link SubripDecoder}. */
+@RunWith(RobolectricTestRunner.class)
+public final class SubripDecoderTest {
 
   private static final String EMPTY_FILE = "subrip/empty";
   private static final String TYPICAL_FILE = "subrip/typical";
@@ -34,130 +38,140 @@
   private static final String TYPICAL_UNEXPECTED_END = "subrip/typical_unexpected_end";
   private static final String NO_END_TIMECODES_FILE = "subrip/no_end_timecodes";
 
+  @Test
   public void testDecodeEmpty() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), EMPTY_FILE);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, EMPTY_FILE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(0, subtitle.getEventTimeCount());
-    assertTrue(subtitle.getCues(0).isEmpty());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(0);
+    assertThat(subtitle.getCues(0).isEmpty()).isTrue();
   }
 
+  @Test
   public void testDecodeTypical() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_FILE);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_FILE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(6, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue2(subtitle, 2);
     assertTypicalCue3(subtitle, 4);
   }
 
+  @Test
   public void testDecodeTypicalWithByteOrderMark() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_WITH_BYTE_ORDER_MARK);
+    byte[] bytes =
+        TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_WITH_BYTE_ORDER_MARK);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(6, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue2(subtitle, 2);
     assertTypicalCue3(subtitle, 4);
   }
 
+  @Test
   public void testDecodeTypicalExtraBlankLine() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_EXTRA_BLANK_LINE);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_EXTRA_BLANK_LINE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(6, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue2(subtitle, 2);
     assertTypicalCue3(subtitle, 4);
   }
 
+  @Test
   public void testDecodeTypicalMissingTimecode() throws IOException {
     // Parsing should succeed, parsing the first and third cues only.
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_MISSING_TIMECODE);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_MISSING_TIMECODE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(4, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue3(subtitle, 2);
   }
 
+  @Test
   public void testDecodeTypicalMissingSequence() throws IOException {
     // Parsing should succeed, parsing the first and third cues only.
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_MISSING_SEQUENCE);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_MISSING_SEQUENCE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(4, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue3(subtitle, 2);
   }
 
+  @Test
   public void testDecodeTypicalNegativeTimestamps() throws IOException {
     // Parsing should succeed, parsing the third cue only.
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_NEGATIVE_TIMESTAMPS);
+    byte[] bytes =
+        TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_NEGATIVE_TIMESTAMPS);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(2, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(2);
     assertTypicalCue3(subtitle, 0);
   }
 
+  @Test
   public void testDecodeTypicalUnexpectedEnd() throws IOException {
     // Parsing should succeed, parsing the first and second cues only.
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_UNEXPECTED_END);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, TYPICAL_UNEXPECTED_END);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(4, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
     assertTypicalCue1(subtitle, 0);
     assertTypicalCue2(subtitle, 2);
   }
 
+  @Test
   public void testDecodeNoEndTimecodes() throws IOException {
     SubripDecoder decoder = new SubripDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), NO_END_TIMECODES_FILE);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, NO_END_TIMECODES_FILE);
     SubripSubtitle subtitle = decoder.decode(bytes, bytes.length, false);
 
-    assertEquals(3, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(3);
 
-    assertEquals(0, subtitle.getEventTime(0));
-    assertEquals("SubRip doesn't technically allow missing end timecodes.",
-        subtitle.getCues(subtitle.getEventTime(0)).get(0).text.toString());
+    assertThat(subtitle.getEventTime(0)).isEqualTo(0);
+    assertThat(subtitle.getCues(subtitle.getEventTime(0)).get(0).text.toString())
+        .isEqualTo("SubRip doesn't technically allow missing end timecodes.");
 
-    assertEquals(2345000, subtitle.getEventTime(1));
-    assertEquals("We interpret it to mean that a subtitle extends to the start of the next one.",
-        subtitle.getCues(subtitle.getEventTime(1)).get(0).text.toString());
+    assertThat(subtitle.getEventTime(1)).isEqualTo(2345000);
+    assertThat(subtitle.getCues(subtitle.getEventTime(1)).get(0).text.toString())
+        .isEqualTo("We interpret it to mean that a subtitle extends to the start of the next one.");
 
-    assertEquals(3456000, subtitle.getEventTime(2));
-    assertEquals("Or to the end of the media.",
-        subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString());
+    assertThat(subtitle.getEventTime(2)).isEqualTo(3456000);
+    assertThat(subtitle.getCues(subtitle.getEventTime(2)).get(0).text.toString())
+        .isEqualTo("Or to the end of the media.");
   }
 
   private static void assertTypicalCue1(SubripSubtitle subtitle, int eventIndex) {
-    assertEquals(0, subtitle.getEventTime(eventIndex));
-    assertEquals("This is the first subtitle.",
-        subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString());
-    assertEquals(1234000, subtitle.getEventTime(eventIndex + 1));
+    assertThat(subtitle.getEventTime(eventIndex)).isEqualTo(0);
+    assertThat(subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString())
+        .isEqualTo("This is the first subtitle.");
+    assertThat(subtitle.getEventTime(eventIndex + 1)).isEqualTo(1234000);
   }
 
   private static void assertTypicalCue2(SubripSubtitle subtitle, int eventIndex) {
-    assertEquals(2345000, subtitle.getEventTime(eventIndex));
-    assertEquals("This is the second subtitle.\nSecond subtitle with second line.",
-        subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString());
-    assertEquals(3456000, subtitle.getEventTime(eventIndex + 1));
+    assertThat(subtitle.getEventTime(eventIndex)).isEqualTo(2345000);
+    assertThat(subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString())
+        .isEqualTo("This is the second subtitle.\nSecond subtitle with second line.");
+    assertThat(subtitle.getEventTime(eventIndex + 1)).isEqualTo(3456000);
   }
 
   private static void assertTypicalCue3(SubripSubtitle subtitle, int eventIndex) {
-    assertEquals(4567000, subtitle.getEventTime(eventIndex));
-    assertEquals("This is the third subtitle.",
-        subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString());
-    assertEquals(8901000, subtitle.getEventTime(eventIndex + 1));
+    assertThat(subtitle.getEventTime(eventIndex)).isEqualTo(4567000);
+    assertThat(subtitle.getCues(subtitle.getEventTime(eventIndex)).get(0).text.toString())
+        .isEqualTo("This is the third subtitle.");
+    assertThat(subtitle.getEventTime(eventIndex + 1)).isEqualTo(8901000);
   }
-
 }
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
similarity index 50%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
index 492cf036b4..fdf454e5df 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlDecoderTest.java
@@ -15,7 +15,9 @@
  */
 package com.google.android.exoplayer2.text.ttml;
 
-import android.test.InstrumentationTestCase;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
 import android.text.Layout;
 import android.text.Spannable;
 import android.text.SpannableStringBuilder;
@@ -35,11 +37,14 @@
 import java.io.IOException;
 import java.util.List;
 import java.util.Map;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit test for {@link TtmlDecoder}.
- */
-public final class TtmlDecoderTest extends InstrumentationTestCase {
+/** Unit test for {@link TtmlDecoder}. */
+@RunWith(RobolectricTestRunner.class)
+public final class TtmlDecoderTest {
 
   private static final String INLINE_ATTRIBUTES_TTML_FILE = "ttml/inline_style_attributes.xml";
   private static final String INHERIT_STYLE_TTML_FILE = "ttml/inherit_style.xml";
@@ -59,339 +64,459 @@
   private static final String FONT_SIZE_EMPTY_TTML_FILE = "ttml/font_size_empty.xml";
   private static final String FRAME_RATE_TTML_FILE = "ttml/frame_rate.xml";
 
+  @Test
   public void testInlineAttributes() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INLINE_ATTRIBUTES_TTML_FILE);
-    assertEquals(4, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
 
     TtmlNode root = subtitle.getRoot();
 
     TtmlNode body = queryChildrenForTag(root, TtmlNode.TAG_BODY, 0);
     TtmlNode firstDiv = queryChildrenForTag(body, TtmlNode.TAG_DIV, 0);
     TtmlStyle firstPStyle = queryChildrenForTag(firstDiv, TtmlNode.TAG_P, 0).style;
-    assertEquals(ColorParser.parseTtmlColor("yellow"), firstPStyle.getFontColor());
-    assertEquals(ColorParser.parseTtmlColor("blue"), firstPStyle.getBackgroundColor());
-    assertEquals("serif", firstPStyle.getFontFamily());
-    assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, firstPStyle.getStyle());
-    assertTrue(firstPStyle.isUnderline());
+    assertThat(firstPStyle.getFontColor()).isEqualTo(ColorParser.parseTtmlColor("yellow"));
+    assertThat(firstPStyle.getBackgroundColor()).isEqualTo(ColorParser.parseTtmlColor("blue"));
+    assertThat(firstPStyle.getFontFamily()).isEqualTo("serif");
+    assertThat(firstPStyle.getStyle()).isEqualTo(TtmlStyle.STYLE_BOLD_ITALIC);
+    assertThat(firstPStyle.isUnderline()).isTrue();
   }
 
+  @Test
   public void testInheritInlineAttributes() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INLINE_ATTRIBUTES_TTML_FILE);
-    assertEquals(4, subtitle.getEventTimeCount());
-    assertSpans(subtitle, 20, "text 2", "sansSerif", TtmlStyle.STYLE_ITALIC,
-        0xFF00FFFF, ColorParser.parseTtmlColor("lime"), false, true, null);
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+    assertSpans(
+        subtitle,
+        20,
+        "text 2",
+        "sansSerif",
+        TtmlStyle.STYLE_ITALIC,
+        0xFF00FFFF,
+        ColorParser.parseTtmlColor("lime"),
+        false,
+        true,
+        null);
   }
 
   /**
-   * Regression test for devices on JellyBean where some named colors are not correctly defined
-   * on framework level. Tests that <i>lime</i> resolves to <code>#FF00FF00</code> not
-   * <code>#00FF00</code>.
+   * Regression test for devices on JellyBean where some named colors are not correctly defined on
+   * framework level. Tests that <i>lime</i> resolves to <code>#FF00FF00</code> not <code>#00FF00
+   * </code>.
    *
-   * @see <a href="https://github.com/android/platform_frameworks_base/blob/jb-mr2-release/graphics/java/android/graphics/Color.java#L414">
-   *     JellyBean Color</a>
-   *     <a href="https://github.com/android/platform_frameworks_base/blob/kitkat-mr2.2-release/graphics/java/android/graphics/Color.java#L414">
+   * @see <a
+   *     href="https://github.com/android/platform_frameworks_base/blob/jb-mr2-release/graphics/java/android/graphics/Color.java#L414">
+   *     JellyBean Color</a> <a
+   *     href="https://github.com/android/platform_frameworks_base/blob/kitkat-mr2.2-release/graphics/java/android/graphics/Color.java#L414">
    *     Kitkat Color</a>
    * @throws IOException thrown if reading subtitle file fails.
    */
+  @Test
   public void testLime() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INLINE_ATTRIBUTES_TTML_FILE);
-    assertEquals(4, subtitle.getEventTimeCount());
-    assertSpans(subtitle, 20, "text 2", "sansSerif", TtmlStyle.STYLE_ITALIC, 0xFF00FFFF, 0xFF00FF00,
-        false, true, null);
-  }
-
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+    assertSpans(
+        subtitle,
+        20,
+        "text 2",
+        "sansSerif",
+        TtmlStyle.STYLE_ITALIC,
+        0xFF00FFFF,
+        0xFF00FF00,
+        false,
+        true,
+        null);
+  }
+
+  @Test
   public void testInheritGlobalStyle() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_STYLE_TTML_FILE);
-    assertEquals(2, subtitle.getEventTimeCount());
-    assertSpans(subtitle, 10, "text 1", "serif", TtmlStyle.STYLE_BOLD_ITALIC, 0xFF0000FF,
-        0xFFFFFF00, true, false, null);
-  }
-
-  public void testInheritGlobalStyleOverriddenByInlineAttributes() throws IOException,
-      SubtitleDecoderException {
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(2);
+    assertSpans(
+        subtitle,
+        10,
+        "text 1",
+        "serif",
+        TtmlStyle.STYLE_BOLD_ITALIC,
+        0xFF0000FF,
+        0xFFFFFF00,
+        true,
+        false,
+        null);
+  }
+
+  @Test
+  public void testInheritGlobalStyleOverriddenByInlineAttributes()
+      throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_STYLE_OVERRIDE_TTML_FILE);
-    assertEquals(4, subtitle.getEventTimeCount());
-
-    assertSpans(subtitle, 10, "text 1", "serif", TtmlStyle.STYLE_BOLD_ITALIC, 0xFF0000FF,
-        0xFFFFFF00, true, false, null);
-    assertSpans(subtitle, 20, "text 2", "sansSerif", TtmlStyle.STYLE_ITALIC, 0xFFFF0000, 0xFFFFFF00,
-        true, false, null);
-  }
-
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+
+    assertSpans(
+        subtitle,
+        10,
+        "text 1",
+        "serif",
+        TtmlStyle.STYLE_BOLD_ITALIC,
+        0xFF0000FF,
+        0xFFFFFF00,
+        true,
+        false,
+        null);
+    assertSpans(
+        subtitle,
+        20,
+        "text 2",
+        "sansSerif",
+        TtmlStyle.STYLE_ITALIC,
+        0xFFFF0000,
+        0xFFFFFF00,
+        true,
+        false,
+        null);
+  }
+
+  @Test
   public void testInheritGlobalAndParent() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_GLOBAL_AND_PARENT_TTML_FILE);
-    assertEquals(4, subtitle.getEventTimeCount());
-
-    assertSpans(subtitle, 10, "text 1", "sansSerif", TtmlStyle.STYLE_NORMAL, 0xFFFF0000,
-        ColorParser.parseTtmlColor("lime"), false, true, Layout.Alignment.ALIGN_CENTER);
-    assertSpans(subtitle, 20, "text 2", "serif", TtmlStyle.STYLE_BOLD_ITALIC, 0xFF0000FF,
-        0xFFFFFF00, true, true, Layout.Alignment.ALIGN_CENTER);
-  }
-
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+
+    assertSpans(
+        subtitle,
+        10,
+        "text 1",
+        "sansSerif",
+        TtmlStyle.STYLE_NORMAL,
+        0xFFFF0000,
+        ColorParser.parseTtmlColor("lime"),
+        false,
+        true,
+        Layout.Alignment.ALIGN_CENTER);
+    assertSpans(
+        subtitle,
+        20,
+        "text 2",
+        "serif",
+        TtmlStyle.STYLE_BOLD_ITALIC,
+        0xFF0000FF,
+        0xFFFFFF00,
+        true,
+        true,
+        Layout.Alignment.ALIGN_CENTER);
+  }
+
+  @Test
   public void testInheritMultipleStyles() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_MULTIPLE_STYLES_TTML_FILE);
-    assertEquals(12, subtitle.getEventTimeCount());
-    assertSpans(subtitle, 10, "text 1", "sansSerif", TtmlStyle.STYLE_BOLD_ITALIC, 0xFF0000FF,
-        0xFFFFFF00, false, true, null);
-  }
-
-  public void testInheritMultipleStylesWithoutLocalAttributes() throws IOException,
-      SubtitleDecoderException {
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(12);
+    assertSpans(
+        subtitle,
+        10,
+        "text 1",
+        "sansSerif",
+        TtmlStyle.STYLE_BOLD_ITALIC,
+        0xFF0000FF,
+        0xFFFFFF00,
+        false,
+        true,
+        null);
+  }
+
+  @Test
+  public void testInheritMultipleStylesWithoutLocalAttributes()
+      throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_MULTIPLE_STYLES_TTML_FILE);
-    assertEquals(12, subtitle.getEventTimeCount());
-    assertSpans(subtitle, 20, "text 2", "sansSerif", TtmlStyle.STYLE_BOLD_ITALIC, 0xFF0000FF,
-        0xFF000000, false, true, null);
-  }
-
-  public void testMergeMultipleStylesWithParentStyle() throws IOException,
-      SubtitleDecoderException {
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(12);
+    assertSpans(
+        subtitle,
+        20,
+        "text 2",
+        "sansSerif",
+        TtmlStyle.STYLE_BOLD_ITALIC,
+        0xFF0000FF,
+        0xFF000000,
+        false,
+        true,
+        null);
+  }
+
+  @Test
+  public void testMergeMultipleStylesWithParentStyle()
+      throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_MULTIPLE_STYLES_TTML_FILE);
-    assertEquals(12, subtitle.getEventTimeCount());
-    assertSpans(subtitle, 30, "text 2.5", "sansSerifInline", TtmlStyle.STYLE_ITALIC, 0xFFFF0000,
-        0xFFFFFF00, true, true, null);
-  }
-
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(12);
+    assertSpans(
+        subtitle,
+        30,
+        "text 2.5",
+        "sansSerifInline",
+        TtmlStyle.STYLE_ITALIC,
+        0xFFFF0000,
+        0xFFFFFF00,
+        true,
+        true,
+        null);
+  }
+
+  @Test
   public void testMultipleRegions() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(MULTIPLE_REGIONS_TTML_FILE);
     List<Cue> output = subtitle.getCues(1000000);
-    assertEquals(2, output.size());
+    assertThat(output).hasSize(2);
     Cue ttmlCue = output.get(0);
-    assertEquals("lorem", ttmlCue.text.toString());
-    assertEquals(10f / 100f, ttmlCue.position);
-    assertEquals(10f / 100f, ttmlCue.line);
-    assertEquals(20f / 100f, ttmlCue.size);
+    assertThat(ttmlCue.text.toString()).isEqualTo("lorem");
+    assertThat(ttmlCue.position).isEqualTo(10f / 100f);
+    assertThat(ttmlCue.line).isEqualTo(10f / 100f);
+    assertThat(ttmlCue.size).isEqualTo(20f / 100f);
 
     ttmlCue = output.get(1);
-    assertEquals("amet", ttmlCue.text.toString());
-    assertEquals(60f / 100f, ttmlCue.position);
-    assertEquals(10f / 100f, ttmlCue.line);
-    assertEquals(20f / 100f, ttmlCue.size);
+    assertThat(ttmlCue.text.toString()).isEqualTo("amet");
+    assertThat(ttmlCue.position).isEqualTo(60f / 100f);
+    assertThat(ttmlCue.line).isEqualTo(10f / 100f);
+    assertThat(ttmlCue.size).isEqualTo(20f / 100f);
 
     output = subtitle.getCues(5000000);
-    assertEquals(1, output.size());
+    assertThat(output).hasSize(1);
     ttmlCue = output.get(0);
-    assertEquals("ipsum", ttmlCue.text.toString());
-    assertEquals(40f / 100f, ttmlCue.position);
-    assertEquals(40f / 100f, ttmlCue.line);
-    assertEquals(20f / 100f, ttmlCue.size);
+    assertThat(ttmlCue.text.toString()).isEqualTo("ipsum");
+    assertThat(ttmlCue.position).isEqualTo(40f / 100f);
+    assertThat(ttmlCue.line).isEqualTo(40f / 100f);
+    assertThat(ttmlCue.size).isEqualTo(20f / 100f);
 
     output = subtitle.getCues(9000000);
-    assertEquals(1, output.size());
+    assertThat(output).hasSize(1);
     ttmlCue = output.get(0);
-    assertEquals("dolor", ttmlCue.text.toString());
-    assertEquals(Cue.DIMEN_UNSET, ttmlCue.position);
-    assertEquals(Cue.DIMEN_UNSET, ttmlCue.line);
-    assertEquals(Cue.DIMEN_UNSET, ttmlCue.size);
+    assertThat(ttmlCue.text.toString()).isEqualTo("dolor");
+    assertThat(ttmlCue.position).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(ttmlCue.line).isEqualTo(Cue.DIMEN_UNSET);
+    assertThat(ttmlCue.size).isEqualTo(Cue.DIMEN_UNSET);
     // TODO: Should be as below, once https://github.com/google/ExoPlayer/issues/2953 is fixed.
     // assertEquals(10f / 100f, ttmlCue.position);
     // assertEquals(80f / 100f, ttmlCue.line);
     // assertEquals(1f, ttmlCue.size);
 
     output = subtitle.getCues(21000000);
-    assertEquals(1, output.size());
+    assertThat(output).hasSize(1);
     ttmlCue = output.get(0);
-    assertEquals("She first said this", ttmlCue.text.toString());
-    assertEquals(45f / 100f, ttmlCue.position);
-    assertEquals(45f / 100f, ttmlCue.line);
-    assertEquals(35f / 100f, ttmlCue.size);
+    assertThat(ttmlCue.text.toString()).isEqualTo("She first said this");
+    assertThat(ttmlCue.position).isEqualTo(45f / 100f);
+    assertThat(ttmlCue.line).isEqualTo(45f / 100f);
+    assertThat(ttmlCue.size).isEqualTo(35f / 100f);
     output = subtitle.getCues(25000000);
     ttmlCue = output.get(0);
-    assertEquals("She first said this\nThen this", ttmlCue.text.toString());
+    assertThat(ttmlCue.text.toString()).isEqualTo("She first said this\nThen this");
     output = subtitle.getCues(29000000);
-    assertEquals(1, output.size());
+    assertThat(output).hasSize(1);
     ttmlCue = output.get(0);
-    assertEquals("She first said this\nThen this\nFinally this", ttmlCue.text.toString());
-    assertEquals(45f / 100f, ttmlCue.position);
-    assertEquals(45f / 100f, ttmlCue.line);
+    assertThat(ttmlCue.text.toString()).isEqualTo("She first said this\nThen this\nFinally this");
+    assertThat(ttmlCue.position).isEqualTo(45f / 100f);
+    assertThat(ttmlCue.line).isEqualTo(45f / 100f);
   }
 
+  @Test
   public void testEmptyStyleAttribute() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_MULTIPLE_STYLES_TTML_FILE);
-    assertEquals(12, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(12);
 
     TtmlNode root = subtitle.getRoot();
     TtmlNode body = queryChildrenForTag(root, TtmlNode.TAG_BODY, 0);
     TtmlNode fourthDiv = queryChildrenForTag(body, TtmlNode.TAG_DIV, 3);
 
-    assertNull(queryChildrenForTag(fourthDiv, TtmlNode.TAG_P, 0).getStyleIds());
+    assertThat(queryChildrenForTag(fourthDiv, TtmlNode.TAG_P, 0).getStyleIds()).isNull();
   }
 
+  @Test
   public void testNonexistingStyleId() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_MULTIPLE_STYLES_TTML_FILE);
-    assertEquals(12, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(12);
 
     TtmlNode root = subtitle.getRoot();
     TtmlNode body = queryChildrenForTag(root, TtmlNode.TAG_BODY, 0);
     TtmlNode fifthDiv = queryChildrenForTag(body, TtmlNode.TAG_DIV, 4);
 
-    assertEquals(1, queryChildrenForTag(fifthDiv, TtmlNode.TAG_P, 0).getStyleIds().length);
+    assertThat(queryChildrenForTag(fifthDiv, TtmlNode.TAG_P, 0).getStyleIds()).hasLength(1);
   }
 
-  public void testNonExistingAndExistingStyleIdWithRedundantSpaces() throws IOException,
-      SubtitleDecoderException {
+  @Test
+  public void testNonExistingAndExistingStyleIdWithRedundantSpaces()
+      throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(INHERIT_MULTIPLE_STYLES_TTML_FILE);
-    assertEquals(12, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(12);
 
     TtmlNode root = subtitle.getRoot();
     TtmlNode body = queryChildrenForTag(root, TtmlNode.TAG_BODY, 0);
     TtmlNode sixthDiv = queryChildrenForTag(body, TtmlNode.TAG_DIV, 5);
 
     String[] styleIds = queryChildrenForTag(sixthDiv, TtmlNode.TAG_P, 0).getStyleIds();
-    assertEquals(2, styleIds.length);
+    assertThat(styleIds).hasLength(2);
   }
 
+  @Test
   public void testMultipleChaining() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(CHAIN_MULTIPLE_STYLES_TTML_FILE);
-    assertEquals(2, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(2);
 
     Map<String, TtmlStyle> globalStyles = subtitle.getGlobalStyles();
 
     TtmlStyle style = globalStyles.get("s2");
-    assertEquals("serif", style.getFontFamily());
-    assertEquals(0xFFFF0000, style.getBackgroundColor());
-    assertEquals(0xFF000000, style.getFontColor());
-    assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, style.getStyle());
-    assertTrue(style.isLinethrough());
+    assertThat(style.getFontFamily()).isEqualTo("serif");
+    assertThat(style.getBackgroundColor()).isEqualTo(0xFFFF0000);
+    assertThat(style.getFontColor()).isEqualTo(0xFF000000);
+    assertThat(style.getStyle()).isEqualTo(TtmlStyle.STYLE_BOLD_ITALIC);
+    assertThat(style.isLinethrough()).isTrue();
 
     style = globalStyles.get("s3");
     // only difference: color must be RED
-    assertEquals(0xFFFF0000, style.getFontColor());
-    assertEquals("serif", style.getFontFamily());
-    assertEquals(0xFFFF0000, style.getBackgroundColor());
-    assertEquals(TtmlStyle.STYLE_BOLD_ITALIC, style.getStyle());
-    assertTrue(style.isLinethrough());
+    assertThat(style.getFontColor()).isEqualTo(0xFFFF0000);
+    assertThat(style.getFontFamily()).isEqualTo("serif");
+    assertThat(style.getBackgroundColor()).isEqualTo(0xFFFF0000);
+    assertThat(style.getStyle()).isEqualTo(TtmlStyle.STYLE_BOLD_ITALIC);
+    assertThat(style.isLinethrough()).isTrue();
   }
 
+  @Test
   public void testNoUnderline() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(NO_UNDERLINE_LINETHROUGH_TTML_FILE);
-    assertEquals(4, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
 
     TtmlNode root = subtitle.getRoot();
     TtmlNode body = queryChildrenForTag(root, TtmlNode.TAG_BODY, 0);
     TtmlNode div = queryChildrenForTag(body, TtmlNode.TAG_DIV, 0);
 
     TtmlStyle style = queryChildrenForTag(div, TtmlNode.TAG_P, 0).style;
-    assertFalse("noUnderline from inline attribute expected", style.isUnderline());
+    assertWithMessage("noUnderline from inline attribute expected")
+        .that(style.isUnderline())
+        .isFalse();
   }
 
+  @Test
   public void testNoLinethrough() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(NO_UNDERLINE_LINETHROUGH_TTML_FILE);
-    assertEquals(4, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
 
     TtmlNode root = subtitle.getRoot();
     TtmlNode body = queryChildrenForTag(root, TtmlNode.TAG_BODY, 0);
     TtmlNode div = queryChildrenForTag(body, TtmlNode.TAG_DIV, 1);
 
     TtmlStyle style = queryChildrenForTag(div, TtmlNode.TAG_P, 0).style;
-    assertFalse("noLineThrough from inline attribute expected in second pNode",
-        style.isLinethrough());
+    assertWithMessage("noLineThrough from inline attribute expected in second pNode")
+        .that(style.isLinethrough())
+        .isFalse();
   }
 
+  @Test
   public void testFontSizeSpans() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(FONT_SIZE_TTML_FILE);
-    assertEquals(10, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(10);
 
     List<Cue> cues = subtitle.getCues(10 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("text 1", String.valueOf(spannable));
+    assertThat(String.valueOf(spannable)).isEqualTo("text 1");
     assertAbsoluteFontSize(spannable, 32);
 
     cues = subtitle.getCues(20 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("text 2", String.valueOf(cues.get(0).text));
+    assertThat(String.valueOf(cues.get(0).text)).isEqualTo("text 2");
     assertRelativeFontSize(spannable, 2.2f);
 
     cues = subtitle.getCues(30 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("text 3", String.valueOf(cues.get(0).text));
+    assertThat(String.valueOf(cues.get(0).text)).isEqualTo("text 3");
     assertRelativeFontSize(spannable, 1.5f);
 
     cues = subtitle.getCues(40 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("two values", String.valueOf(cues.get(0).text));
+    assertThat(String.valueOf(cues.get(0).text)).isEqualTo("two values");
     assertAbsoluteFontSize(spannable, 16);
 
     cues = subtitle.getCues(50 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("leading dot", String.valueOf(cues.get(0).text));
+    assertThat(String.valueOf(cues.get(0).text)).isEqualTo("leading dot");
     assertRelativeFontSize(spannable, 0.5f);
   }
 
+  @Test
   public void testFontSizeWithMissingUnitIsIgnored() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(FONT_SIZE_MISSING_UNIT_TTML_FILE);
-    assertEquals(2, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(2);
     List<Cue> cues = subtitle.getCues(10 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("no unit", String.valueOf(spannable));
-    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
-    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
+    assertThat(String.valueOf(spannable)).isEqualTo("no unit");
+    assertThat(spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class)).hasLength(0);
+    assertThat(spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class)).hasLength(0);
   }
 
+  @Test
   public void testFontSizeWithInvalidValueIsIgnored() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(FONT_SIZE_INVALID_TTML_FILE);
-    assertEquals(6, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(6);
 
     List<Cue> cues = subtitle.getCues(10 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("invalid", String.valueOf(spannable));
-    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
-    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
-
+    assertThat(String.valueOf(spannable)).isEqualTo("invalid");
+    assertThat(spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class)).hasLength(0);
+    assertThat(spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class)).hasLength(0);
 
     cues = subtitle.getCues(20 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("invalid", String.valueOf(spannable));
-    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
-    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
-
+    assertThat(String.valueOf(spannable)).isEqualTo("invalid");
+    assertThat(spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class)).hasLength(0);
+    assertThat(spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class)).hasLength(0);
 
     cues = subtitle.getCues(30 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("invalid dot", String.valueOf(spannable));
-    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
-    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
+    assertThat(String.valueOf(spannable)).isEqualTo("invalid dot");
+    assertThat(spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class)).hasLength(0);
+    assertThat(spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class)).hasLength(0);
   }
 
+  @Test
   public void testFontSizeWithEmptyValueIsIgnored() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(FONT_SIZE_EMPTY_TTML_FILE);
-    assertEquals(2, subtitle.getEventTimeCount());
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(2);
     List<Cue> cues = subtitle.getCues(10 * 1000000);
-    assertEquals(1, cues.size());
+    assertThat(cues).hasSize(1);
     SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
-    assertEquals("empty", String.valueOf(spannable));
-    assertEquals(0, spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class).length);
-    assertEquals(0, spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class).length);
+    assertThat(String.valueOf(spannable)).isEqualTo("empty");
+    assertThat(spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class)).hasLength(0);
+    assertThat(spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class)).hasLength(0);
   }
 
+  @Test
   public void testFrameRate() throws IOException, SubtitleDecoderException {
     TtmlSubtitle subtitle = getSubtitle(FRAME_RATE_TTML_FILE);
-    assertEquals(4, subtitle.getEventTimeCount());
-    assertEquals(1_000_000, subtitle.getEventTime(0));
-    assertEquals(1_010_000, subtitle.getEventTime(1));
-    assertEquals(1_001_000_000, subtitle.getEventTime(2), 1000);
-    assertEquals(2_002_000_000, subtitle.getEventTime(3), 2000);
-  }
-
-  private void assertSpans(TtmlSubtitle subtitle, int second,
-      String text, String font, int fontStyle,
-      int backgroundColor, int color, boolean isUnderline,
-      boolean isLinethrough, Layout.Alignment alignment) {
-
-    long timeUs = second * 1000000;
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+    assertThat(subtitle.getEventTime(0)).isEqualTo(1_000_000);
+    assertThat(subtitle.getEventTime(1)).isEqualTo(1_010_000);
+    assertThat((double) subtitle.getEventTime(2)).isWithin(1000).of(1_001_000_000);
+    assertThat((double) subtitle.getEventTime(3)).isWithin(2000).of(2_002_000_000);
+  }
+
+  private void assertSpans(
+      TtmlSubtitle subtitle,
+      int second,
+      String text,
+      String font,
+      int fontStyle,
+      int backgroundColor,
+      int color,
+      boolean isUnderline,
+      boolean isLinethrough,
+      Layout.Alignment alignment) {
+
+    long timeUs = second * 1000000L;
     List<Cue> cues = subtitle.getCues(timeUs);
 
-    assertEquals(1, cues.size());
-    assertEquals(text, String.valueOf(cues.get(0).text));
-    assertEquals("single cue expected for timeUs: " + timeUs, 1, cues.size());
+    assertThat(cues).hasSize(1);
+    assertThat(String.valueOf(cues.get(0).text)).isEqualTo(text);
+    assertWithMessage("single cue expected for timeUs: " + timeUs).that(cues.size()).isEqualTo(1);
     SpannableStringBuilder spannable = (SpannableStringBuilder) cues.get(0).text;
 
     assertFont(spannable, font);
@@ -405,69 +530,71 @@ private void assertSpans(TtmlSubtitle subtitle, int second,
   }
 
   private void assertAbsoluteFontSize(Spannable spannable, int absoluteFontSize) {
-    AbsoluteSizeSpan[] absoluteSizeSpans = spannable.getSpans(0, spannable.length(),
-        AbsoluteSizeSpan.class);
-    assertEquals(1, absoluteSizeSpans.length);
-    assertEquals(absoluteFontSize, absoluteSizeSpans[0].getSize());
+    AbsoluteSizeSpan[] absoluteSizeSpans =
+        spannable.getSpans(0, spannable.length(), AbsoluteSizeSpan.class);
+    assertThat(absoluteSizeSpans).hasLength(1);
+    assertThat(absoluteSizeSpans[0].getSize()).isEqualTo(absoluteFontSize);
   }
 
   private void assertRelativeFontSize(Spannable spannable, float relativeFontSize) {
-    RelativeSizeSpan[] relativeSizeSpans = spannable.getSpans(0, spannable.length(),
-        RelativeSizeSpan.class);
-    assertEquals(1, relativeSizeSpans.length);
-    assertEquals(relativeFontSize, relativeSizeSpans[0].getSizeChange());
+    RelativeSizeSpan[] relativeSizeSpans =
+        spannable.getSpans(0, spannable.length(), RelativeSizeSpan.class);
+    assertThat(relativeSizeSpans).hasLength(1);
+    assertThat(relativeSizeSpans[0].getSizeChange()).isEqualTo(relativeFontSize);
   }
 
   private void assertFont(Spannable spannable, String font) {
     TypefaceSpan[] typefaceSpans = spannable.getSpans(0, spannable.length(), TypefaceSpan.class);
-    assertEquals(font, typefaceSpans[typefaceSpans.length - 1].getFamily());
+    assertThat(typefaceSpans[typefaceSpans.length - 1].getFamily()).isEqualTo(font);
   }
 
   private void assertStyle(Spannable spannable, int fontStyle) {
     StyleSpan[] styleSpans = spannable.getSpans(0, spannable.length(), StyleSpan.class);
-    assertEquals(fontStyle, styleSpans[styleSpans.length - 1].getStyle());
+    assertThat(styleSpans[styleSpans.length - 1].getStyle()).isEqualTo(fontStyle);
   }
 
   private void assertUnderline(Spannable spannable, boolean isUnderline) {
     UnderlineSpan[] underlineSpans = spannable.getSpans(0, spannable.length(), UnderlineSpan.class);
-    assertEquals(isUnderline ? "must be underlined" : "must not be underlined",
-        isUnderline ? 1 : 0, underlineSpans.length);
+    assertWithMessage(isUnderline ? "must be underlined" : "must not be underlined")
+        .that(underlineSpans)
+        .hasLength(isUnderline ? 1 : 0);
   }
 
   private void assertStrikethrough(Spannable spannable, boolean isStrikethrough) {
-    StrikethroughSpan[] striketroughSpans = spannable.getSpans(0, spannable.length(),
-        StrikethroughSpan.class);
-    assertEquals(isStrikethrough ? "must be strikethrough" : "must not be strikethrough",
-        isStrikethrough ? 1 : 0, striketroughSpans.length);
+    StrikethroughSpan[] striketroughSpans =
+        spannable.getSpans(0, spannable.length(), StrikethroughSpan.class);
+    assertWithMessage(isStrikethrough ? "must be strikethrough" : "must not be strikethrough")
+        .that(striketroughSpans)
+        .hasLength(isStrikethrough ? 1 : 0);
   }
 
   private void assertBackground(Spannable spannable, int backgroundColor) {
     BackgroundColorSpan[] backgroundColorSpans =
         spannable.getSpans(0, spannable.length(), BackgroundColorSpan.class);
     if (backgroundColor != 0) {
-      assertEquals(backgroundColor, backgroundColorSpans[backgroundColorSpans.length - 1]
-          .getBackgroundColor());
+      assertThat(backgroundColorSpans[backgroundColorSpans.length - 1].getBackgroundColor())
+          .isEqualTo(backgroundColor);
     } else {
-      assertEquals(0, backgroundColorSpans.length);
+      assertThat(backgroundColorSpans).hasLength(0);
     }
   }
 
   private void assertForeground(Spannable spannable, int foregroundColor) {
     ForegroundColorSpan[] foregroundColorSpans =
         spannable.getSpans(0, spannable.length(), ForegroundColorSpan.class);
-    assertEquals(foregroundColor,
-        foregroundColorSpans[foregroundColorSpans.length - 1].getForegroundColor());
+    assertThat(foregroundColorSpans[foregroundColorSpans.length - 1].getForegroundColor())
+        .isEqualTo(foregroundColor);
   }
 
   private void assertAlignment(Spannable spannable, Layout.Alignment alignment) {
     if (alignment != null) {
       AlignmentSpan.Standard[] alignmentSpans =
           spannable.getSpans(0, spannable.length(), AlignmentSpan.Standard.class);
-      assertEquals(1, alignmentSpans.length);
-      assertEquals(alignment, alignmentSpans[0].getAlignment());
+      assertThat(alignmentSpans).hasLength(1);
+      assertThat(alignmentSpans[0].getAlignment()).isEqualTo(alignment);
     } else {
-      assertEquals(0, spannable.getSpans
-          (0, spannable.length(), AlignmentSpan.Standard.class).length);
+      assertThat(spannable.getSpans(0, spannable.length(), AlignmentSpan.Standard.class))
+          .hasLength(0);
     }
   }
 
@@ -485,8 +612,7 @@ private TtmlNode queryChildrenForTag(TtmlNode node, String tag, int pos) {
 
   private TtmlSubtitle getSubtitle(String file) throws IOException, SubtitleDecoderException {
     TtmlDecoder ttmlDecoder = new TtmlDecoder();
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), file);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, file);
     return ttmlDecoder.decode(bytes, bytes.length, false);
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
index 557611c4ea..536ddbabbc 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlRenderUtilTest.java
@@ -29,13 +29,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link TtmlRenderUtil}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class TtmlRenderUtilTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
index 4c35e259ff..aa46584f54 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/ttml/TtmlStyleTest.java
@@ -30,11 +30,9 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /** Unit test for {@link TtmlStyle}. */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class TtmlStyleTest {
 
   private static final String FONT_FAMILY = "serif";
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
similarity index 63%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
index 0b24d0f275..c0fa52f74b 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/tx3g/Tx3gDecoderTest.java
@@ -15,9 +15,11 @@
  */
 package com.google.android.exoplayer2.text.tx3g;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import android.graphics.Color;
 import android.graphics.Typeface;
-import android.test.InstrumentationTestCase;
 import android.text.SpannedString;
 import android.text.style.ForegroundColorSpan;
 import android.text.style.StyleSpan;
@@ -30,11 +32,14 @@
 import com.google.android.exoplayer2.text.SubtitleDecoderException;
 import java.io.IOException;
 import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit test for {@link Tx3gDecoder}.
- */
-public final class Tx3gDecoderTest extends InstrumentationTestCase {
+/** Unit test for {@link Tx3gDecoder}. */
+@RunWith(RobolectricTestRunner.class)
+public final class Tx3gDecoderTest {
 
   private static final String NO_SUBTITLE = "tx3g/no_subtitle";
   private static final String SAMPLE_JUST_TEXT = "tx3g/sample_just_text";
@@ -48,156 +53,170 @@
   private static final String INITIALIZATION = "tx3g/initialization";
   private static final String INITIALIZATION_ALL_DEFAULTS = "tx3g/initialization_all_defaults";
 
+  @Test
   public void testDecodeNoSubtitle() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), NO_SUBTITLE);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, NO_SUBTITLE);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
-    assertTrue(subtitle.getCues(0).isEmpty());
+    assertThat(subtitle.getCues(0)).isEmpty();
   }
 
+  @Test
   public void testDecodeJustText() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_JUST_TEXT);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_JUST_TEXT);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("CC Test", text.toString());
-    assertEquals(0, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("CC Test");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(0);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);
   }
 
+  @Test
   public void testDecodeWithStyl() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_WITH_STYL);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("CC Test", text.toString());
-    assertEquals(3, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("CC Test");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(3);
     StyleSpan styleSpan = findSpan(text, 0, 6, StyleSpan.class);
-    assertEquals(Typeface.BOLD_ITALIC, styleSpan.getStyle());
+    assertThat(styleSpan.getStyle()).isEqualTo(Typeface.BOLD_ITALIC);
     findSpan(text, 0, 6, UnderlineSpan.class);
     ForegroundColorSpan colorSpan = findSpan(text, 0, 6, ForegroundColorSpan.class);
-    assertEquals(Color.GREEN, colorSpan.getForegroundColor());
+    assertThat(colorSpan.getForegroundColor()).isEqualTo(Color.GREEN);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);
   }
 
+  @Test
   public void testDecodeWithStylAllDefaults() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_WITH_STYL_ALL_DEFAULTS);
+    byte[] bytes =
+        TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL_ALL_DEFAULTS);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("CC Test", text.toString());
-    assertEquals(0, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("CC Test");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(0);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);
   }
 
+  @Test
   public void testDecodeUtf16BeNoStyl() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_UTF16_BE_NO_STYL);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_UTF16_BE_NO_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("你好", text.toString());
-    assertEquals(0, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("你好");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(0);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);
   }
 
+  @Test
   public void testDecodeUtf16LeNoStyl() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_UTF16_LE_NO_STYL);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_UTF16_LE_NO_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("你好", text.toString());
-    assertEquals(0, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("你好");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(0);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);
   }
 
+  @Test
   public void testDecodeWithMultipleStyl() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_WITH_MULTIPLE_STYL);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_MULTIPLE_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("Line 2\nLine 3", text.toString());
-    assertEquals(4, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("Line 2\nLine 3");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(4);
     StyleSpan styleSpan = findSpan(text, 0, 5, StyleSpan.class);
-    assertEquals(Typeface.ITALIC, styleSpan.getStyle());
+    assertThat(styleSpan.getStyle()).isEqualTo(Typeface.ITALIC);
     findSpan(text, 7, 12, UnderlineSpan.class);
     ForegroundColorSpan colorSpan = findSpan(text, 0, 5, ForegroundColorSpan.class);
-    assertEquals(Color.GREEN, colorSpan.getForegroundColor());
+    assertThat(colorSpan.getForegroundColor()).isEqualTo(Color.GREEN);
     colorSpan = findSpan(text, 7, 12, ForegroundColorSpan.class);
-    assertEquals(Color.GREEN, colorSpan.getForegroundColor());
+    assertThat(colorSpan.getForegroundColor()).isEqualTo(Color.GREEN);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);
   }
 
+  @Test
   public void testDecodeWithOtherExtension() throws IOException, SubtitleDecoderException {
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.<byte[]>emptyList());
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_WITH_OTHER_EXTENSION);
+    byte[] bytes =
+        TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_OTHER_EXTENSION);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("CC Test", text.toString());
-    assertEquals(2, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("CC Test");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(2);
     StyleSpan styleSpan = findSpan(text, 0, 6, StyleSpan.class);
-    assertEquals(Typeface.BOLD, styleSpan.getStyle());
+    assertThat(styleSpan.getStyle()).isEqualTo(Typeface.BOLD);
     ForegroundColorSpan colorSpan = findSpan(text, 0, 6, ForegroundColorSpan.class);
-    assertEquals(Color.GREEN, colorSpan.getForegroundColor());
+    assertThat(colorSpan.getForegroundColor()).isEqualTo(Color.GREEN);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);
   }
 
+  @Test
   public void testInitializationDecodeWithStyl() throws IOException, SubtitleDecoderException {
-    byte[] initBytes = TestUtil.getByteArray(getInstrumentation(), INITIALIZATION);
+    byte[] initBytes = TestUtil.getByteArray(RuntimeEnvironment.application, INITIALIZATION);
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.singletonList(initBytes));
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_WITH_STYL);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("CC Test", text.toString());
-    assertEquals(5, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("CC Test");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(5);
     StyleSpan styleSpan = findSpan(text, 0, text.length(), StyleSpan.class);
-    assertEquals(Typeface.BOLD_ITALIC, styleSpan.getStyle());
+    assertThat(styleSpan.getStyle()).isEqualTo(Typeface.BOLD_ITALIC);
     findSpan(text, 0, text.length(), UnderlineSpan.class);
     TypefaceSpan typefaceSpan = findSpan(text, 0, text.length(), TypefaceSpan.class);
-    assertEquals(C.SERIF_NAME, typefaceSpan.getFamily());
+    assertThat(typefaceSpan.getFamily()).isEqualTo(C.SERIF_NAME);
     ForegroundColorSpan colorSpan = findSpan(text, 0, text.length(), ForegroundColorSpan.class);
-    assertEquals(Color.RED, colorSpan.getForegroundColor());
+    assertThat(colorSpan.getForegroundColor()).isEqualTo(Color.RED);
     colorSpan = findSpan(text, 0, 6, ForegroundColorSpan.class);
-    assertEquals(Color.GREEN, colorSpan.getForegroundColor());
+    assertThat(colorSpan.getForegroundColor()).isEqualTo(Color.GREEN);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.1f);
   }
 
+  @Test
   public void testInitializationDecodeWithTbox() throws IOException, SubtitleDecoderException {
-    byte[] initBytes = TestUtil.getByteArray(getInstrumentation(), INITIALIZATION);
+    byte[] initBytes = TestUtil.getByteArray(RuntimeEnvironment.application, INITIALIZATION);
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.singletonList(initBytes));
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_WITH_TBOX);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_TBOX);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("CC Test", text.toString());
-    assertEquals(4, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("CC Test");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(4);
     StyleSpan styleSpan = findSpan(text, 0, text.length(), StyleSpan.class);
-    assertEquals(Typeface.BOLD_ITALIC, styleSpan.getStyle());
+    assertThat(styleSpan.getStyle()).isEqualTo(Typeface.BOLD_ITALIC);
     findSpan(text, 0, text.length(), UnderlineSpan.class);
     TypefaceSpan typefaceSpan = findSpan(text, 0, text.length(), TypefaceSpan.class);
-    assertEquals(C.SERIF_NAME, typefaceSpan.getFamily());
+    assertThat(typefaceSpan.getFamily()).isEqualTo(C.SERIF_NAME);
     ForegroundColorSpan colorSpan = findSpan(text, 0, text.length(), ForegroundColorSpan.class);
-    assertEquals(Color.RED, colorSpan.getForegroundColor());
+    assertThat(colorSpan.getForegroundColor()).isEqualTo(Color.RED);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.1875f);
   }
 
-  public void testInitializationAllDefaultsDecodeWithStyl() throws IOException,
-      SubtitleDecoderException {
-    byte[] initBytes = TestUtil.getByteArray(getInstrumentation(), INITIALIZATION_ALL_DEFAULTS);
+  @Test
+  public void testInitializationAllDefaultsDecodeWithStyl()
+      throws IOException, SubtitleDecoderException {
+    byte[] initBytes =
+        TestUtil.getByteArray(RuntimeEnvironment.application, INITIALIZATION_ALL_DEFAULTS);
     Tx3gDecoder decoder = new Tx3gDecoder(Collections.singletonList(initBytes));
-    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), SAMPLE_WITH_STYL);
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, SAMPLE_WITH_STYL);
     Subtitle subtitle = decoder.decode(bytes, bytes.length, false);
     SpannedString text = new SpannedString(subtitle.getCues(0).get(0).text);
-    assertEquals("CC Test", text.toString());
-    assertEquals(3, text.getSpans(0, text.length(), Object.class).length);
+    assertThat(text.toString()).isEqualTo("CC Test");
+    assertThat(text.getSpans(0, text.length(), Object.class)).hasLength(3);
     StyleSpan styleSpan = findSpan(text, 0, 6, StyleSpan.class);
-    assertEquals(Typeface.BOLD_ITALIC, styleSpan.getStyle());
+    assertThat(styleSpan.getStyle()).isEqualTo(Typeface.BOLD_ITALIC);
     findSpan(text, 0, 6, UnderlineSpan.class);
     ForegroundColorSpan colorSpan = findSpan(text, 0, 6, ForegroundColorSpan.class);
-    assertEquals(Color.GREEN, colorSpan.getForegroundColor());
+    assertThat(colorSpan.getForegroundColor()).isEqualTo(Color.GREEN);
     assertFractionalLinePosition(subtitle.getCues(0).get(0), 0.85f);
   }
 
-  private static <T> T findSpan(SpannedString testObject, int expectedStart, int expectedEnd,
-      Class<T> expectedType) {
+  private static <T> T findSpan(
+      SpannedString testObject, int expectedStart, int expectedEnd, Class<T> expectedType) {
     T[] spans = testObject.getSpans(0, testObject.length(), expectedType);
     for (T span : spans) {
       if (testObject.getSpanStart(span) == expectedStart
@@ -210,9 +229,8 @@ public void testInitializationAllDefaultsDecodeWithStyl() throws IOException,
   }
 
   private static void assertFractionalLinePosition(Cue cue, float expectedFraction) {
-    assertEquals(Cue.LINE_TYPE_FRACTION, cue.lineType);
-    assertEquals(Cue.ANCHOR_TYPE_START, cue.lineAnchor);
-    assertTrue(Math.abs(expectedFraction - cue.line) < 1e-6);
+    assertThat(cue.lineType).isEqualTo(Cue.LINE_TYPE_FRACTION);
+    assertThat(cue.lineAnchor).isEqualTo(Cue.ANCHOR_TYPE_START);
+    assertThat(Math.abs(expectedFraction - cue.line) < 1e-6).isTrue();
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
index 6ade85be28..b81c0c68c3 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/CssParserTest.java
@@ -24,13 +24,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link CssParser}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class CssParserTest {
 
   private CssParser parser;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
index 8937007990..f0c426ea65 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/Mp4WebvttDecoderTest.java
@@ -25,13 +25,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link Mp4WebvttDecoder}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class Mp4WebvttDecoderTest {
 
   private static final byte[] SINGLE_CUE_SAMPLE = {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
index 2a6e461627..b89eb47618 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttCueParserTest.java
@@ -27,13 +27,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link WebvttCueParser}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class WebvttCueParserTest {
 
   @Test
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
new file mode 100644
index 0000000000..eec985ef5b
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttDecoderTest.java
@@ -0,0 +1,344 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.text.webvtt;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.graphics.Typeface;
+import android.text.Layout.Alignment;
+import android.text.Spanned;
+import android.text.style.BackgroundColorSpan;
+import android.text.style.ForegroundColorSpan;
+import android.text.style.StyleSpan;
+import android.text.style.TypefaceSpan;
+import android.text.style.UnderlineSpan;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.SubtitleDecoderException;
+import java.io.IOException;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Unit test for {@link WebvttDecoder}. */
+@RunWith(RobolectricTestRunner.class)
+public class WebvttDecoderTest {
+
+  private static final String TYPICAL_FILE = "webvtt/typical";
+  private static final String TYPICAL_WITH_BAD_TIMESTAMPS = "webvtt/typical_with_bad_timestamps";
+  private static final String TYPICAL_WITH_IDS_FILE = "webvtt/typical_with_identifiers";
+  private static final String TYPICAL_WITH_COMMENTS_FILE = "webvtt/typical_with_comments";
+  private static final String WITH_POSITIONING_FILE = "webvtt/with_positioning";
+  private static final String WITH_BAD_CUE_HEADER_FILE = "webvtt/with_bad_cue_header";
+  private static final String WITH_TAGS_FILE = "webvtt/with_tags";
+  private static final String WITH_CSS_STYLES = "webvtt/with_css_styles";
+  private static final String WITH_CSS_COMPLEX_SELECTORS = "webvtt/with_css_complex_selectors";
+  private static final String EMPTY_FILE = "webvtt/empty";
+
+  @Test
+  public void testDecodeEmpty() throws IOException {
+    WebvttDecoder decoder = new WebvttDecoder();
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, EMPTY_FILE);
+    try {
+      decoder.decode(bytes, bytes.length, false);
+      fail();
+    } catch (SubtitleDecoderException expected) {
+      // Do nothing.
+    }
+  }
+
+  @Test
+  public void testDecodeTypical() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_FILE);
+
+    // Test event count.
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+
+    // Test cues.
+    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
+    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+  }
+
+  @Test
+  public void testDecodeTypicalWithBadTimestamps() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_WITH_BAD_TIMESTAMPS);
+
+    // Test event count.
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+
+    // Test cues.
+    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
+    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+  }
+
+  @Test
+  public void testDecodeTypicalWithIds() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_WITH_IDS_FILE);
+
+    // Test event count.
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+
+    // Test cues.
+    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
+    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+  }
+
+  @Test
+  public void testDecodeTypicalWithComments() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(TYPICAL_WITH_COMMENTS_FILE);
+
+    // test event count
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+
+    // test cues
+    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
+    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+  }
+
+  @Test
+  public void testDecodeWithTags() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_TAGS_FILE);
+
+    // Test event count.
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(8);
+
+    // Test cues.
+    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
+    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+    assertCue(subtitle, 4, 4000000, 5000000, "This is the third subtitle.");
+    assertCue(subtitle, 6, 6000000, 7000000, "This is the <fourth> &subtitle.");
+  }
+
+  @Test
+  public void testDecodeWithPositioning() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_POSITIONING_FILE);
+    // Test event count.
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(12);
+    // Test cues.
+    assertCue(
+        subtitle,
+        0,
+        0,
+        1234000,
+        "This is the first subtitle.",
+        Alignment.ALIGN_NORMAL,
+        Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET,
+        Cue.TYPE_UNSET,
+        0.1f,
+        Cue.ANCHOR_TYPE_START,
+        0.35f);
+    assertCue(
+        subtitle,
+        2,
+        2345000,
+        3456000,
+        "This is the second subtitle.",
+        Alignment.ALIGN_OPPOSITE,
+        Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET,
+        Cue.TYPE_UNSET,
+        Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET,
+        0.35f);
+    assertCue(
+        subtitle,
+        4,
+        4000000,
+        5000000,
+        "This is the third subtitle.",
+        Alignment.ALIGN_CENTER,
+        0.45f,
+        Cue.LINE_TYPE_FRACTION,
+        Cue.ANCHOR_TYPE_END,
+        Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET,
+        0.35f);
+    assertCue(
+        subtitle,
+        6,
+        6000000,
+        7000000,
+        "This is the fourth subtitle.",
+        Alignment.ALIGN_CENTER,
+        -11f,
+        Cue.LINE_TYPE_NUMBER,
+        Cue.TYPE_UNSET,
+        Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET,
+        Cue.DIMEN_UNSET);
+    assertCue(
+        subtitle,
+        8,
+        7000000,
+        8000000,
+        "This is the fifth subtitle.",
+        Alignment.ALIGN_OPPOSITE,
+        Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET,
+        Cue.TYPE_UNSET,
+        0.1f,
+        Cue.ANCHOR_TYPE_END,
+        0.1f);
+    assertCue(
+        subtitle,
+        10,
+        10000000,
+        11000000,
+        "This is the sixth subtitle.",
+        Alignment.ALIGN_CENTER,
+        0.45f,
+        Cue.LINE_TYPE_FRACTION,
+        Cue.ANCHOR_TYPE_END,
+        Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET,
+        0.35f);
+  }
+
+  @Test
+  public void testDecodeWithBadCueHeader() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_BAD_CUE_HEADER_FILE);
+
+    // Test event count.
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(4);
+
+    // Test cues.
+    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
+    assertCue(subtitle, 2, 4000000, 5000000, "This is the third subtitle.");
+  }
+
+  @Test
+  public void testWebvttWithCssStyle() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_CSS_STYLES);
+
+    // Test event count.
+    assertThat(subtitle.getEventTimeCount()).isEqualTo(8);
+
+    // Test cues.
+    assertCue(subtitle, 0, 0, 1234000, "This is the first subtitle.");
+    assertCue(subtitle, 2, 2345000, 3456000, "This is the second subtitle.");
+
+    Spanned s1 = getUniqueSpanTextAt(subtitle, 0);
+    Spanned s2 = getUniqueSpanTextAt(subtitle, 2345000);
+    Spanned s3 = getUniqueSpanTextAt(subtitle, 20000000);
+    Spanned s4 = getUniqueSpanTextAt(subtitle, 25000000);
+    assertThat(s1.getSpans(0, s1.length(), ForegroundColorSpan.class)).hasLength(1);
+    assertThat(s1.getSpans(0, s1.length(), BackgroundColorSpan.class)).hasLength(1);
+    assertThat(s2.getSpans(0, s2.length(), ForegroundColorSpan.class)).hasLength(2);
+    assertThat(s3.getSpans(10, s3.length(), UnderlineSpan.class)).hasLength(1);
+    assertThat(s4.getSpans(0, 16, BackgroundColorSpan.class)).hasLength(2);
+    assertThat(s4.getSpans(17, s4.length(), StyleSpan.class)).hasLength(1);
+    assertThat(s4.getSpans(17, s4.length(), StyleSpan.class)[0].getStyle())
+        .isEqualTo(Typeface.BOLD);
+  }
+
+  @Test
+  public void testWithComplexCssSelectors() throws IOException, SubtitleDecoderException {
+    WebvttSubtitle subtitle = getSubtitleForTestAsset(WITH_CSS_COMPLEX_SELECTORS);
+    Spanned text = getUniqueSpanTextAt(subtitle, 0);
+    assertThat(text.getSpans(30, text.length(), ForegroundColorSpan.class)).hasLength(1);
+    assertThat(text.getSpans(30, text.length(), ForegroundColorSpan.class)[0].getForegroundColor())
+        .isEqualTo(0xFFEE82EE);
+    assertThat(text.getSpans(30, text.length(), TypefaceSpan.class)).hasLength(1);
+    assertThat(text.getSpans(30, text.length(), TypefaceSpan.class)[0].getFamily())
+        .isEqualTo("courier");
+
+    text = getUniqueSpanTextAt(subtitle, 2000000);
+    assertThat(text.getSpans(5, text.length(), TypefaceSpan.class)).hasLength(1);
+    assertThat(text.getSpans(5, text.length(), TypefaceSpan.class)[0].getFamily())
+        .isEqualTo("courier");
+
+    text = getUniqueSpanTextAt(subtitle, 2500000);
+    assertThat(text.getSpans(5, text.length(), StyleSpan.class)).hasLength(1);
+    assertThat(text.getSpans(5, text.length(), StyleSpan.class)[0].getStyle())
+        .isEqualTo(Typeface.BOLD);
+    assertThat(text.getSpans(5, text.length(), TypefaceSpan.class)).hasLength(1);
+    assertThat(text.getSpans(5, text.length(), TypefaceSpan.class)[0].getFamily())
+        .isEqualTo("courier");
+
+    text = getUniqueSpanTextAt(subtitle, 4000000);
+    assertThat(text.getSpans(6, 22, StyleSpan.class)).hasLength(0);
+    assertThat(text.getSpans(30, text.length(), StyleSpan.class)).hasLength(1);
+    assertThat(text.getSpans(30, text.length(), StyleSpan.class)[0].getStyle())
+        .isEqualTo(Typeface.BOLD);
+
+    text = getUniqueSpanTextAt(subtitle, 5000000);
+    assertThat(text.getSpans(9, 17, StyleSpan.class)).hasLength(0);
+    assertThat(text.getSpans(19, text.length(), StyleSpan.class)).hasLength(1);
+    assertThat(text.getSpans(19, text.length(), StyleSpan.class)[0].getStyle())
+        .isEqualTo(Typeface.ITALIC);
+  }
+
+  private WebvttSubtitle getSubtitleForTestAsset(String asset)
+      throws IOException, SubtitleDecoderException {
+    WebvttDecoder decoder = new WebvttDecoder();
+    byte[] bytes = TestUtil.getByteArray(RuntimeEnvironment.application, asset);
+    return decoder.decode(bytes, bytes.length, false);
+  }
+
+  private Spanned getUniqueSpanTextAt(WebvttSubtitle sub, long timeUs) {
+    return (Spanned) sub.getCues(timeUs).get(0).text;
+  }
+
+  private static void assertCue(
+      WebvttSubtitle subtitle, int eventTimeIndex, long startTimeUs, int endTimeUs, String text) {
+    assertCue(
+        subtitle,
+        eventTimeIndex,
+        startTimeUs,
+        endTimeUs,
+        text,
+        null,
+        Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET,
+        Cue.TYPE_UNSET,
+        Cue.DIMEN_UNSET,
+        Cue.TYPE_UNSET,
+        Cue.DIMEN_UNSET);
+  }
+
+  private static void assertCue(
+      WebvttSubtitle subtitle,
+      int eventTimeIndex,
+      long startTimeUs,
+      int endTimeUs,
+      String text,
+      Alignment textAlignment,
+      float line,
+      int lineType,
+      int lineAnchor,
+      float position,
+      int positionAnchor,
+      float size) {
+    assertThat(subtitle.getEventTime(eventTimeIndex)).isEqualTo(startTimeUs);
+    assertThat(subtitle.getEventTime(eventTimeIndex + 1)).isEqualTo(endTimeUs);
+    List<Cue> cues = subtitle.getCues(subtitle.getEventTime(eventTimeIndex));
+    assertThat(cues).hasSize(1);
+    // Assert cue properties.
+    Cue cue = cues.get(0);
+    assertThat(cue.text.toString()).isEqualTo(text);
+    assertThat(cue.textAlignment).isEqualTo(textAlignment);
+    assertThat(cue.line).isEqualTo(line);
+    assertThat(cue.lineType).isEqualTo(lineType);
+    assertThat(cue.lineAnchor).isEqualTo(lineAnchor);
+    assertThat(cue.position).isEqualTo(position);
+    assertThat(cue.positionAnchor).isEqualTo(positionAnchor);
+    assertThat(cue.size).isEqualTo(size);
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
index c3c30e44a8..3074f28b64 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/text/webvtt/WebvttSubtitleTest.java
@@ -26,13 +26,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for {@link WebvttSubtitle}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class WebvttSubtitleTest {
 
   private static final String FIRST_SUBTITLE_STRING = "This is the first subtitle.";
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
new file mode 100644
index 0000000000..956174f43b
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelectionTest.java
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.trackselection;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.when;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.testutil.FakeClock;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DefaultHttpDataSource;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link AdaptiveTrackSelection}. */
+@RunWith(RobolectricTestRunner.class)
+public final class AdaptiveTrackSelectionTest {
+
+  @Mock private BandwidthMeter mockBandwidthMeter;
+  private FakeClock fakeClock;
+
+  private AdaptiveTrackSelection adaptiveTrackSelection;
+
+  @Before
+  public void setUp() {
+    initMocks(this);
+    fakeClock = new FakeClock(0);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(BandwidthMeter.NO_ESTIMATE);
+  }
+
+  @Test
+  public void testSelectInitialIndexUseMaxInitialBitrateIfNoBandwidthEstimate() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    adaptiveTrackSelection = adaptiveTrackSelection(trackGroup, /* initialBitrate= */ 1000);
+
+    assertThat(adaptiveTrackSelection.getSelectedFormat()).isEqualTo(format2);
+    assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_INITIAL);
+  }
+
+  @Test
+  public void testSelectInitialIndexUseBandwidthEstimateIfAvailable() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(500L);
+
+    adaptiveTrackSelection = adaptiveTrackSelection(trackGroup, /* initialBitrate= */ 1000);
+
+    assertThat(adaptiveTrackSelection.getSelectedFormat()).isEqualTo(format1);
+    assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_INITIAL);
+  }
+
+  @Test
+  public void testUpdateSelectedTrackDoNotSwitchUpIfNotBufferedEnough() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    // initially bandwidth meter does not have any estimation. The second measurement onward returns
+    // 2000L, which prompts the track selection to switch up if possible.
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(BandwidthMeter.NO_ESTIMATE, 2000L);
+
+    adaptiveTrackSelection =
+        adaptiveTrackSelectionWithMinDurationForQualityIncreaseMs(
+            trackGroup, /* initialBitrate= */ 1000, /* minDurationForQualityIncreaseMs= */ 10_000);
+
+    adaptiveTrackSelection.updateSelectedTrack(
+        /* playbackPositionUs= */ 0,
+        /* bufferedDurationUs= */ 9_999_000,
+        /* availableDurationUs= */ C.TIME_UNSET);
+
+    // When bandwidth estimation is updated to 2000L, we can switch up to use a higher bitrate
+    // format. However, since we only buffered 9_999_000 us, which is smaller than
+    // minDurationForQualityIncreaseMs, we should defer switch up.
+    assertThat(adaptiveTrackSelection.getSelectedFormat()).isEqualTo(format2);
+    assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_INITIAL);
+  }
+
+  @Test
+  public void testUpdateSelectedTrackSwitchUpIfBufferedEnough() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    // initially bandwidth meter does not have any estimation. The second measurement onward returns
+    // 2000L, which prompts the track selection to switch up if possible.
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(BandwidthMeter.NO_ESTIMATE, 2000L);
+
+    adaptiveTrackSelection =
+        adaptiveTrackSelectionWithMinDurationForQualityIncreaseMs(
+            trackGroup, /* initialBitrate= */ 1000, /* minDurationForQualityIncreaseMs= */ 10_000);
+
+    adaptiveTrackSelection.updateSelectedTrack(
+        /* playbackPositionUs= */ 0,
+        /* bufferedDurationUs= */ 10_000_000,
+        /* availableDurationUs= */ C.TIME_UNSET);
+
+    // When bandwidth estimation is updated to 2000L, we can switch up to use a higher bitrate
+    // format. When we have buffered enough (10_000_000 us, which is equal to
+    // minDurationForQualityIncreaseMs), we should switch up now.
+    assertThat(adaptiveTrackSelection.getSelectedFormat()).isEqualTo(format3);
+    assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
+  }
+
+  @Test
+  public void testUpdateSelectedTrackDoNotSwitchDownIfBufferedEnough() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    // initially bandwidth meter does not have any estimation. The second measurement onward returns
+    // 500L, which prompts the track selection to switch down if necessary.
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(BandwidthMeter.NO_ESTIMATE, 500L);
+
+    adaptiveTrackSelection =
+        adaptiveTrackSelectionWithMaxDurationForQualityDecreaseMs(
+            trackGroup, /* initialBitrate= */ 1000, /* maxDurationForQualityDecreaseMs= */ 25_000);
+
+    adaptiveTrackSelection.updateSelectedTrack(
+        /* playbackPositionUs= */ 0,
+        /* bufferedDurationUs= */ 25_000_000,
+        /* availableDurationUs= */ C.TIME_UNSET);
+
+    // When bandwidth estimation is updated to 500L, we should switch down to use a lower bitrate
+    // format. However, since we have enough buffer at higher quality (25_000_000 us, which is equal
+    // to maxDurationForQualityDecreaseMs), we should defer switch down.
+    assertThat(adaptiveTrackSelection.getSelectedFormat()).isEqualTo(format2);
+    assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_INITIAL);
+  }
+
+  @Test
+  public void testUpdateSelectedTrackSwitchDownIfNotBufferedEnough() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    // initially bandwidth meter does not have any estimation. The second measurement onward returns
+    // 500L, which prompts the track selection to switch down if necessary.
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(BandwidthMeter.NO_ESTIMATE, 500L);
+
+    adaptiveTrackSelection =
+        adaptiveTrackSelectionWithMaxDurationForQualityDecreaseMs(
+            trackGroup, /* initialBitrate= */ 1000, /* maxDurationForQualityDecreaseMs= */ 25_000);
+
+    adaptiveTrackSelection.updateSelectedTrack(
+        /* playbackPositionUs= */ 0,
+        /* bufferedDurationUs= */ 24_999_000,
+        /* availableDurationUs= */ C.TIME_UNSET);
+
+    // When bandwidth estimation is updated to 500L, we should switch down to use a lower bitrate
+    // format. When we don't have enough buffer at higher quality (24_999_000 us is smaller than
+    // maxDurationForQualityDecreaseMs), we should switch down now.
+    assertThat(adaptiveTrackSelection.getSelectedFormat()).isEqualTo(format1);
+    assertThat(adaptiveTrackSelection.getSelectionReason()).isEqualTo(C.SELECTION_REASON_ADAPTIVE);
+  }
+
+  @Test
+  public void testEvaluateQueueSizeReturnQueueSizeIfBandwidthIsNotImproved() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    FakeMediaChunk chunk1 =
+        new FakeMediaChunk(format1, /* startTimeUs= */ 0, /* endTimeUs= */ 10_000_000);
+    FakeMediaChunk chunk2 =
+        new FakeMediaChunk(format1, /* startTimeUs= */ 10_000_000, /* endTimeUs= */ 20_000_000);
+    FakeMediaChunk chunk3 =
+        new FakeMediaChunk(format1, /* startTimeUs= */ 20_000_000, /* endTimeUs= */ 30_000_000);
+    List<FakeMediaChunk> queue = new ArrayList<>();
+    queue.add(chunk1);
+    queue.add(chunk2);
+    queue.add(chunk3);
+
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(500L);
+    adaptiveTrackSelection = adaptiveTrackSelection(trackGroup, /* initialBitrate= */ 1000);
+
+    int size = adaptiveTrackSelection.evaluateQueueSize(0, queue);
+    assertThat(size).isEqualTo(3);
+  }
+
+  @Test
+  public void testEvaluateQueueSizeDoNotReevaluateUntilAfterMinTimeBetweenBufferReevaluation() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    FakeMediaChunk chunk1 =
+        new FakeMediaChunk(format1, /* startTimeUs= */ 0, /* endTimeUs= */ 10_000_000);
+    FakeMediaChunk chunk2 =
+        new FakeMediaChunk(format1, /* startTimeUs= */ 10_000_000, /* endTimeUs= */ 20_000_000);
+    FakeMediaChunk chunk3 =
+        new FakeMediaChunk(format1, /* startTimeUs= */ 20_000_000, /* endTimeUs= */ 30_000_000);
+    List<FakeMediaChunk> queue = new ArrayList<>();
+    queue.add(chunk1);
+    queue.add(chunk2);
+    queue.add(chunk3);
+
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(500L);
+    adaptiveTrackSelection =
+        adaptiveTrackSelectionWithMinTimeBetweenBufferReevaluationMs(
+            trackGroup,
+            /* initialBitrate= */ 1000,
+            /* durationToRetainAfterDiscardMs= */ 15_000,
+            /* minTimeBetweenBufferReevaluationMs= */ 2000);
+
+    int initialQueueSize = adaptiveTrackSelection.evaluateQueueSize(0, queue);
+
+    fakeClock.advanceTime(1999);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(1000L);
+
+    // When bandwidth estimation is updated, we can discard chunks at the end of the queue now.
+    // However, since min duration between buffer reevaluation = 2000, we will not reevaluate
+    // queue size if time now is only 1999 ms after last buffer reevaluation.
+    int newSize = adaptiveTrackSelection.evaluateQueueSize(0, queue);
+    assertThat(newSize).isEqualTo(initialQueueSize);
+  }
+
+  @Test
+  public void testEvaluateQueueSizeRetainMoreThanMinimumDurationAfterDiscard() {
+    Format format1 = videoFormat(/* bitrate= */ 500, /* width= */ 320, /* height= */ 240);
+    Format format2 = videoFormat(/* bitrate= */ 1000, /* width= */ 640, /* height= */ 480);
+    Format format3 = videoFormat(/* bitrate= */ 2000, /* width= */ 960, /* height= */ 720);
+    TrackGroup trackGroup = new TrackGroup(format1, format2, format3);
+
+    FakeMediaChunk chunk1 =
+        new FakeMediaChunk(format1, /* startTimeUs= */ 0, /* endTimeUs= */ 10_000_000);
+    FakeMediaChunk chunk2 =
+        new FakeMediaChunk(format1, /* startTimeUs= */ 10_000_000, /* endTimeUs= */ 20_000_000);
+    FakeMediaChunk chunk3 =
+        new FakeMediaChunk(format1, /* startTimeUs= */ 20_000_000, /* endTimeUs= */ 30_000_000);
+    List<FakeMediaChunk> queue = new ArrayList<>();
+    queue.add(chunk1);
+    queue.add(chunk2);
+    queue.add(chunk3);
+
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(500L);
+    adaptiveTrackSelection =
+        adaptiveTrackSelectionWithMinTimeBetweenBufferReevaluationMs(
+            trackGroup,
+            /* initialBitrate= */ 1000,
+            /* durationToRetainAfterDiscardMs= */ 15_000,
+            /* minTimeBetweenBufferReevaluationMs= */ 2000);
+
+    int initialQueueSize = adaptiveTrackSelection.evaluateQueueSize(0, queue);
+    assertThat(initialQueueSize).isEqualTo(3);
+
+    fakeClock.advanceTime(2000);
+    when(mockBandwidthMeter.getBitrateEstimate()).thenReturn(1000L);
+
+    // When bandwidth estimation is updated and time has advanced enough, we can discard chunks at
+    // the end of the queue now.
+    // However, since duration to retain after discard = 15 000 ms, we need to retain at least the
+    // first 2 chunks
+    int newSize = adaptiveTrackSelection.evaluateQueueSize(0, queue);
+    assertThat(newSize).isEqualTo(2);
+  }
+
+  private AdaptiveTrackSelection adaptiveTrackSelection(TrackGroup trackGroup, int initialBitrate) {
+    return new AdaptiveTrackSelection(
+        trackGroup,
+        selectedAllTracksInGroup(trackGroup),
+        mockBandwidthMeter,
+        initialBitrate,
+        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+        AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
+        /* bandwidthFraction= */ 1.0f,
+        AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+        AdaptiveTrackSelection.DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+        fakeClock);
+  }
+
+  private AdaptiveTrackSelection adaptiveTrackSelectionWithMinDurationForQualityIncreaseMs(
+      TrackGroup trackGroup, int initialBitrate, long minDurationForQualityIncreaseMs) {
+    return new AdaptiveTrackSelection(
+        trackGroup,
+        selectedAllTracksInGroup(trackGroup),
+        mockBandwidthMeter,
+        initialBitrate,
+        minDurationForQualityIncreaseMs,
+        AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
+        /* bandwidthFraction= */ 1.0f,
+        AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+        AdaptiveTrackSelection.DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+        fakeClock);
+  }
+
+  private AdaptiveTrackSelection adaptiveTrackSelectionWithMaxDurationForQualityDecreaseMs(
+      TrackGroup trackGroup, int initialBitrate, long maxDurationForQualityDecreaseMs) {
+    return new AdaptiveTrackSelection(
+        trackGroup,
+        selectedAllTracksInGroup(trackGroup),
+        mockBandwidthMeter,
+        initialBitrate,
+        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+        maxDurationForQualityDecreaseMs,
+        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,
+        /* bandwidthFraction= */ 1.0f,
+        AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+        AdaptiveTrackSelection.DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,
+        fakeClock);
+  }
+
+  private AdaptiveTrackSelection adaptiveTrackSelectionWithMinTimeBetweenBufferReevaluationMs(
+      TrackGroup trackGroup,
+      int initialBitrate,
+      long durationToRetainAfterDiscardMs,
+      long minTimeBetweenBufferReevaluationMs) {
+    return new AdaptiveTrackSelection(
+        trackGroup,
+        selectedAllTracksInGroup(trackGroup),
+        mockBandwidthMeter,
+        initialBitrate,
+        AdaptiveTrackSelection.DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,
+        AdaptiveTrackSelection.DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,
+        durationToRetainAfterDiscardMs,
+        /* bandwidth fraction= */ 1.0f,
+        AdaptiveTrackSelection.DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,
+        minTimeBetweenBufferReevaluationMs,
+        fakeClock);
+  }
+
+  private int[] selectedAllTracksInGroup(TrackGroup trackGroup) {
+    int[] listIndices = new int[trackGroup.length];
+    for (int i = 0; i < trackGroup.length; i++) {
+      listIndices[i] = i;
+    }
+    return listIndices;
+  }
+
+  private static Format videoFormat(int bitrate, int width, int height) {
+    return Format.createVideoSampleFormat(
+        /* id= */ null,
+        /* sampleMimeType= */ MimeTypes.VIDEO_H264,
+        /* codecs= */ null,
+        /* bitrate= */ bitrate,
+        /* maxInputSize= */ Format.NO_VALUE,
+        /* width= */ width,
+        /* height= */ height,
+        /* frameRate= */ Format.NO_VALUE,
+        /* initializationData= */ null,
+        /* drmInitData= */ null);
+  }
+
+  private static final class FakeMediaChunk extends MediaChunk {
+
+    private static final DataSource DATA_SOURCE = new DefaultHttpDataSource("TEST_AGENT", null);
+
+    public FakeMediaChunk(Format trackFormat, long startTimeUs, long endTimeUs) {
+      super(
+          DATA_SOURCE,
+          new DataSpec(Uri.EMPTY),
+          trackFormat,
+          C.SELECTION_REASON_ADAPTIVE,
+          null,
+          startTimeUs,
+          endTimeUs,
+          0);
+    }
+
+    @Override
+    public void cancelLoad() {
+      // Do nothing.
+    }
+
+    @Override
+    public boolean isLoadCanceled() {
+      return false;
+    }
+
+    @Override
+    public void load() throws IOException, InterruptedException {
+      // Do nothing.
+    }
+
+    @Override
+    public boolean isLoadCompleted() {
+      return true;
+    }
+
+    @Override
+    public long bytesLoaded() {
+      return 0;
+    }
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
index a0e499139c..4b2a3a5ad6 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/DefaultTrackSelectorTest.java
@@ -15,6 +15,7 @@
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.Parameters;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector.ParametersBuilder;
 import com.google.android.exoplayer2.trackselection.TrackSelector.InvalidationListener;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.HashMap;
@@ -24,18 +25,17 @@
 import org.junit.runner.RunWith;
 import org.mockito.Mock;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link DefaultTrackSelector}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class DefaultTrackSelectorTest {
 
-  private static final Parameters DEFAULT_PARAMETERS = new Parameters();
   private static final RendererCapabilities ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES =
       new FakeRendererCapabilities(C.TRACK_TYPE_AUDIO);
+  private static final RendererCapabilities ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES =
+      new FakeRendererCapabilities(C.TRACK_TYPE_TEXT);
   private static final RendererCapabilities ALL_AUDIO_FORMAT_EXCEEDED_RENDERER_CAPABILITIES =
       new FakeRendererCapabilities(C.TRACK_TYPE_AUDIO, FORMAT_EXCEEDS_CAPABILITIES);
 
@@ -59,7 +59,6 @@ public void setUp() {
   public void testSetParameterWithDefaultParametersDoesNotNotifyInvalidationListener()
       throws Exception {
     trackSelector.init(invalidationListener);
-    trackSelector.setParameters(DEFAULT_PARAMETERS);
 
     verify(invalidationListener, never()).onTrackSelectionsInvalidated();
   }
@@ -71,7 +70,7 @@ public void testSetParameterWithDefaultParametersDoesNotNotifyInvalidationListen
   @Test
   public void testSetParameterWithNonDefaultParameterNotifyInvalidationListener()
       throws Exception {
-    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
+    Parameters parameters = new ParametersBuilder().setPreferredAudioLanguage("eng").build();
     trackSelector.init(invalidationListener);
     trackSelector.setParameters(parameters);
 
@@ -86,10 +85,10 @@ public void testSetParameterWithNonDefaultParameterNotifyInvalidationListener()
   @Test
   public void testSetParameterWithSameParametersDoesNotNotifyInvalidationListenerAgain()
       throws Exception {
-    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
+    ParametersBuilder builder = new ParametersBuilder().setPreferredAudioLanguage("eng");
     trackSelector.init(invalidationListener);
-    trackSelector.setParameters(parameters);
-    trackSelector.setParameters(parameters);
+    trackSelector.setParameters(builder.build());
+    trackSelector.setParameters(builder.build());
 
     verify(invalidationListener, times(1)).onTrackSelectionsInvalidated();
   }
@@ -120,15 +119,14 @@ public void testSelectTracksSelectTrackWithSelectionFlag() throws Exception {
   @Test
   public void testSelectTracksSelectPreferredAudioLanguage()
       throws Exception {
-    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
-    trackSelector.setParameters(parameters);
+    trackSelector.setParameters(new ParametersBuilder().setPreferredAudioLanguage("eng").build());
 
     Format frAudioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 2, 44100, null, null, 0, "fr");
+            Format.NO_VALUE, 2, 44100, null, null, 0, "fra");
     Format enAudioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 2, 44100, null, null, 0, "en");
+            Format.NO_VALUE, 2, 44100, null, null, 0, "eng");
 
     TrackSelectorResult result = trackSelector.selectTracks(
         new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
@@ -144,19 +142,18 @@ public void testSelectTracksSelectPreferredAudioLanguage()
   @Test
   public void testSelectTracksSelectPreferredAudioLanguageOverSelectionFlag()
       throws Exception {
-    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
-    trackSelector.setParameters(parameters);
+    trackSelector.setParameters(new ParametersBuilder().setPreferredAudioLanguage("eng").build());
 
     Format frAudioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, "fr");
+            Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, "fra");
     Format enAudioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
-            Format.NO_VALUE, 2, 44100, null, null, 0, "en");
+            Format.NO_VALUE, 2, 44100, null, null, 0, "eng");
 
     TrackSelectorResult result = trackSelector.selectTracks(
         new RendererCapabilities[] {ALL_AUDIO_FORMAT_SUPPORTED_RENDERER_CAPABILITIES},
-        singleTrackGroup(frAudioFormat, enAudioFormat));
+        wrapFormats(frAudioFormat, enAudioFormat));
 
     assertThat(result.selections.get(0).getSelectedFormat()).isEqualTo(enAudioFormat);
   }
@@ -166,8 +163,7 @@ public void testSelectTracksSelectPreferredAudioLanguageOverSelectionFlag()
    * track that exceed renderer's capabilities.
    */
   @Test
-  public void testSelectTracksPreferTrackWithinCapabilities()
-      throws Exception {
+  public void testSelectTracksPreferTrackWithinCapabilities() throws Exception {
     Format supportedFormat =
         Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
             Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
@@ -195,7 +191,6 @@ public void testSelectTracksPreferTrackWithinCapabilities()
   @Test
   public void testSelectTracksWithNoTrackWithinCapabilitiesSelectExceededCapabilityTrack()
       throws Exception {
-
     Format audioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
             Format.NO_VALUE, 2, 44100, null, null, 0, null);
@@ -214,8 +209,8 @@ public void testSelectTracksWithNoTrackWithinCapabilitiesSelectExceededCapabilit
   @Test
   public void testSelectTracksWithNoTrackWithinCapabilitiesAndSetByParamsReturnNoSelection()
       throws Exception {
-    Parameters parameters = DEFAULT_PARAMETERS.withExceedRendererCapabilitiesIfNecessary(false);
-    trackSelector.setParameters(parameters);
+    trackSelector.setParameters(
+        new ParametersBuilder().setExceedRendererCapabilitiesIfNecessary(false).build());
 
     Format audioFormat =
         Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
@@ -262,15 +257,14 @@ public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlag()
   @Test
   public void testSelectTracksPreferTrackWithinCapabilitiesOverPreferredLanguage()
       throws Exception {
-    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
-    trackSelector.setParameters(parameters);
+    trackSelector.setParameters(new ParametersBuilder().setPreferredAudioLanguage("eng").build());
 
     Format supportedFrFormat =
         Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
-            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "fr");
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "fra");
     Format exceededEnFormat =
         Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null,
-            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "en");
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "eng");
 
     Map<String, Integer> mappedCapabilities = new HashMap<>();
     mappedCapabilities.put(exceededEnFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
@@ -293,15 +287,14 @@ public void testSelectTracksPreferTrackWithinCapabilitiesOverPreferredLanguage()
   @Test
   public void testSelectTracksPreferTrackWithinCapabilitiesOverSelectionFlagAndPreferredLanguage()
       throws Exception {
-    Parameters parameters = DEFAULT_PARAMETERS.withPreferredAudioLanguage("en");
-    trackSelector.setParameters(parameters);
+    trackSelector.setParameters(new ParametersBuilder().setPreferredAudioLanguage("eng").build());
 
     Format supportedFrFormat =
         Format.createAudioSampleFormat("supportedFormat", MimeTypes.AUDIO_AAC, null,
-            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "fr");
+            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, "fra");
     Format exceededDefaultSelectionEnFormat =
-        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null,
-            Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, "en");
+        Format.createAudioSampleFormat("exceededFormat", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
+            Format.NO_VALUE, 2, 44100, null, null, C.SELECTION_FLAG_DEFAULT, "eng");
 
     Map<String, Integer> mappedCapabilities = new HashMap<>();
     mappedCapabilities.put(exceededDefaultSelectionEnFormat.id, FORMAT_EXCEEDS_CAPABILITIES);
@@ -534,6 +527,188 @@ public void testSelectTracksExceedingCapabilitiesPreferLowerSampleRateBeforeBitr
         .isEqualTo(lowerSampleRateHigherBitrateFormat);
   }
 
+  /** Tests text track selection flags. */
+  @Test
+  public void testsTextTrackSelectionFlags() throws ExoPlaybackException {
+    Format forcedOnly =
+        Format.createTextContainerFormat(
+            "forcedOnly",
+            null,
+            MimeTypes.TEXT_VTT,
+            null,
+            Format.NO_VALUE,
+            C.SELECTION_FLAG_FORCED,
+            "eng");
+    Format forcedDefault =
+        Format.createTextContainerFormat(
+            "forcedDefault",
+            null,
+            MimeTypes.TEXT_VTT,
+            null,
+            Format.NO_VALUE,
+            C.SELECTION_FLAG_FORCED | C.SELECTION_FLAG_DEFAULT,
+            "eng");
+    Format defaultOnly =
+        Format.createTextContainerFormat(
+            "defaultOnly",
+            null,
+            MimeTypes.TEXT_VTT,
+            null,
+            Format.NO_VALUE,
+            C.SELECTION_FLAG_DEFAULT,
+            "eng");
+    Format forcedOnlySpanish =
+        Format.createTextContainerFormat(
+            "forcedOnlySpanish",
+            null,
+            MimeTypes.TEXT_VTT,
+            null,
+            Format.NO_VALUE,
+            C.SELECTION_FLAG_FORCED,
+            "spa");
+    Format noFlag =
+        Format.createTextContainerFormat(
+            "noFlag", null, MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, "eng");
+
+    RendererCapabilities[] textRendererCapabilities =
+        new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES};
+
+    TrackSelectorResult result;
+
+    // There is no text language preference, the first track flagged as default should be selected.
+    result =
+        trackSelector.selectTracks(
+            textRendererCapabilities, wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedDefault);
+
+    // Ditto.
+    result =
+        trackSelector.selectTracks(
+            textRendererCapabilities, wrapFormats(forcedOnly, noFlag, defaultOnly));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(defaultOnly);
+
+    // With no language preference and no text track flagged as default, the first forced should be
+    // selected.
+    result = trackSelector.selectTracks(textRendererCapabilities, wrapFormats(forcedOnly, noFlag));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedOnly);
+
+    trackSelector.setParameters(
+        Parameters.DEFAULT
+            .buildUpon()
+            .setDisabledTextTrackSelectionFlags(C.SELECTION_FLAG_DEFAULT)
+            .build());
+
+    // Default flags are disabled, so the first track flagged as forced should be selected.
+    result =
+        trackSelector.selectTracks(
+            textRendererCapabilities, wrapFormats(defaultOnly, noFlag, forcedOnly, forcedDefault));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedOnly);
+
+    trackSelector.setParameters(
+        trackSelector.getParameters().buildUpon().setPreferredAudioLanguage("spa").build());
+
+    // Default flags are disabled, but there is a text track flagged as forced whose language
+    // matches the preferred audio language.
+    result =
+        trackSelector.selectTracks(
+            textRendererCapabilities,
+            wrapFormats(forcedDefault, forcedOnly, defaultOnly, noFlag, forcedOnlySpanish));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedOnlySpanish);
+
+    trackSelector.setParameters(
+        trackSelector
+            .getParameters()
+            .buildUpon()
+            .setDisabledTextTrackSelectionFlags(C.SELECTION_FLAG_DEFAULT | C.SELECTION_FLAG_FORCED)
+            .build());
+
+    // All selection flags are disabled and there is no language preference, so nothing should be
+    // selected.
+    result =
+        trackSelector.selectTracks(
+            textRendererCapabilities, wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag));
+    assertThat(result.selections.get(0)).isNull();
+
+    trackSelector.setParameters(
+        Parameters.DEFAULT.buildUpon().setPreferredTextLanguage("eng").build());
+
+    // There is a preferred language, so the first language-matching track flagged as default should
+    // be selected.
+    result =
+        trackSelector.selectTracks(
+            textRendererCapabilities, wrapFormats(forcedOnly, forcedDefault, defaultOnly, noFlag));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(forcedDefault);
+
+    trackSelector.setParameters(
+        trackSelector
+            .getParameters()
+            .buildUpon()
+            .setDisabledTextTrackSelectionFlags(C.SELECTION_FLAG_DEFAULT)
+            .build());
+
+    // Same as above, but the default flag is disabled. If multiple tracks match the preferred
+    // language, those not flagged as forced are preferred, as they likely include the contents of
+    // forced subtitles.
+    result =
+        trackSelector.selectTracks(
+            textRendererCapabilities, wrapFormats(noFlag, forcedOnly, forcedDefault, defaultOnly));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(noFlag);
+  }
+
+  /**
+   * Tests that the default track selector will select a text track with undetermined language if no
+   * text track with the preferred language is available but
+   * {@link Parameters#selectUndeterminedTextLanguage} is true.
+   */
+  @Test
+  public void testSelectUndeterminedTextLanguageAsFallback() throws ExoPlaybackException{
+    Format spanish = Format.createTextContainerFormat("spanish", null,
+        MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, "spa");
+    Format german = Format.createTextContainerFormat("german", null,
+        MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, "de");
+    Format undeterminedUnd = Format.createTextContainerFormat("undeterminedUnd", null,
+        MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, "und");
+    Format undeterminedNull = Format.createTextContainerFormat("undeterminedNull", null,
+        MimeTypes.TEXT_VTT, null, Format.NO_VALUE, 0, null);
+
+    RendererCapabilities[] textRendererCapabilites =
+        new RendererCapabilities[] {ALL_TEXT_FORMAT_SUPPORTED_RENDERER_CAPABILITIES};
+
+    TrackSelectorResult result;
+
+    result = trackSelector.selectTracks(textRendererCapabilites,
+        wrapFormats(spanish, german, undeterminedUnd, undeterminedNull));
+    assertThat(result.selections.get(0)).isNull();
+
+    trackSelector.setParameters(
+        new ParametersBuilder().setSelectUndeterminedTextLanguage(true).build());
+    result = trackSelector.selectTracks(textRendererCapabilites,
+        wrapFormats(spanish, german, undeterminedUnd, undeterminedNull));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(undeterminedUnd);
+
+    ParametersBuilder builder = new ParametersBuilder().setPreferredTextLanguage("spa");
+    trackSelector.setParameters(builder.build());
+    result = trackSelector.selectTracks(textRendererCapabilites,
+        wrapFormats(spanish, german, undeterminedUnd, undeterminedNull));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(spanish);
+
+    result = trackSelector.selectTracks(textRendererCapabilites,
+        wrapFormats(german, undeterminedUnd, undeterminedNull));
+    assertThat(result.selections.get(0)).isNull();
+
+    trackSelector.setParameters(builder.setSelectUndeterminedTextLanguage(true).build());
+    result = trackSelector.selectTracks(textRendererCapabilites,
+        wrapFormats(german, undeterminedUnd, undeterminedNull));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(undeterminedUnd);
+
+    result = trackSelector.selectTracks(textRendererCapabilites,
+        wrapFormats(german, undeterminedNull));
+    assertThat(result.selections.get(0).getFormat(0)).isSameAs(undeterminedNull);
+
+    result = trackSelector.selectTracks(textRendererCapabilites, wrapFormats(german));
+    assertThat(result.selections.get(0)).isNull();
+  }
+
   /**
    * Tests that track selector will select audio tracks with lower bitrate when {@link Parameters}
    * indicate lowest bitrate preference, even when tracks are within capabilities.
@@ -541,8 +716,7 @@ public void testSelectTracksExceedingCapabilitiesPreferLowerSampleRateBeforeBitr
   @Test
   public void testSelectTracksWithinCapabilitiesAndForceLowestBitrateSelectLowerBitrate()
       throws Exception {
-    Parameters parameters = DEFAULT_PARAMETERS.withForceLowestBitrate(true);
-    trackSelector.setParameters(parameters);
+    trackSelector.setParameters(new ParametersBuilder().setForceLowestBitrate(true).build());
 
     Format lowerBitrateFormat =
         Format.createAudioSampleFormat("audioFormat", MimeTypes.AUDIO_AAC, null, 15000,
@@ -562,6 +736,14 @@ private static TrackGroupArray singleTrackGroup(Format... formats) {
     return new TrackGroupArray(new TrackGroup(formats));
   }
 
+  private static TrackGroupArray wrapFormats(Format... formats) {
+    TrackGroup[] trackGroups = new TrackGroup[formats.length];
+    for (int i = 0; i < trackGroups.length; i++) {
+      trackGroups[i] = new TrackGroup(formats[i]);
+    }
+    return new TrackGroupArray(trackGroups);
+  }
+
   /**
    * A {@link RendererCapabilities} that advertises support for all formats of a given type using
    * a provided support value. For any format that does not have the given track type,
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
index b9ea0087c7..b80110365c 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java
@@ -30,13 +30,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link MappingTrackSelector}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class MappingTrackSelectorTest {
 
   private static final RendererCapabilities VIDEO_CAPABILITIES =
diff --git a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
similarity index 58%
rename from library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
rename to library/core/src/test/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
index d582d25ab1..7ffc14d51f 100644
--- a/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java
@@ -16,28 +16,37 @@
 package com.google.android.exoplayer2.upstream;
 
 import android.net.Uri;
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.testutil.TestUtil;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit tests for {@link AssetDataSource}.
- */
-public final class AssetDataSourceTest extends InstrumentationTestCase {
+/** Unit tests for {@link AssetDataSource}. */
+@RunWith(RobolectricTestRunner.class)
+public final class AssetDataSourceTest {
 
   private static final String DATA_PATH = "binary/1024_incrementing_bytes.mp3";
 
+  @Test
   public void testReadFileUri() throws Exception {
-    AssetDataSource dataSource = new AssetDataSource(getInstrumentation().getContext());
+    AssetDataSource dataSource = new AssetDataSource(RuntimeEnvironment.application);
     DataSpec dataSpec = new DataSpec(Uri.parse("file:///android_asset/" + DATA_PATH));
-    TestUtil.assertDataSourceContent(dataSource, dataSpec,
-        TestUtil.getByteArray(getInstrumentation(), DATA_PATH), true);
+    TestUtil.assertDataSourceContent(
+        dataSource,
+        dataSpec,
+        TestUtil.getByteArray(RuntimeEnvironment.application, DATA_PATH),
+        true);
   }
 
+  @Test
   public void testReadAssetUri() throws Exception {
-    AssetDataSource dataSource = new AssetDataSource(getInstrumentation().getContext());
+    AssetDataSource dataSource = new AssetDataSource(RuntimeEnvironment.application);
     DataSpec dataSpec = new DataSpec(Uri.parse("asset:///" + DATA_PATH));
-    TestUtil.assertDataSourceContent(dataSource, dataSpec,
-        TestUtil.getByteArray(getInstrumentation(), DATA_PATH), true);
+    TestUtil.assertDataSourceContent(
+        dataSource,
+        dataSpec,
+        TestUtil.getByteArray(RuntimeEnvironment.application, DATA_PATH),
+        true);
   }
-
 }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
index a72d060287..f04f01bd5f 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/ByteArrayDataSourceTest.java
@@ -23,13 +23,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link ByteArrayDataSource}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ByteArrayDataSourceTest {
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
index 85c4341232..49f865e2b5 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSchemeDataSourceTest.java
@@ -27,13 +27,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link DataSchemeDataSource}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class DataSchemeDataSourceTest {
 
   private DataSource schemeDataDataSource;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
index 8cd6c23fb1..f47cfc4469 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/DataSourceInputStreamTest.java
@@ -25,13 +25,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link DataSourceInputStream}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class DataSourceInputStreamTest {
 
   private static final byte[] TEST_DATA = TestUtil.buildTestData(16);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java
index aa98ad3179..9304dc6dc3 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheAsserts.java
@@ -21,17 +21,22 @@
 import android.net.Uri;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
+import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSourceInputStream;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.DummyDataSource;
-import java.io.ByteArrayOutputStream;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 
 /** Assertion methods for {@link com.google.android.exoplayer2.upstream.cache.Cache}. */
 /* package */ final class CacheAsserts {
 
-  /** Asserts that the cache content is equal to the data in the {@code fakeDataSet}. */
+  /**
+   * Asserts that the cache content is equal to the data in the {@code fakeDataSet}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
+   */
   public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
     ArrayList<FakeData> allData = fakeDataSet.getAllData();
     Uri[] uris = new Uri[allData.size()];
@@ -43,6 +48,8 @@ public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws
 
   /**
    * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
    */
   public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
       throws IOException {
@@ -55,6 +62,8 @@ public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String
 
   /**
    * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
    */
   public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
       throws IOException {
@@ -67,7 +76,11 @@ public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri...
     assertThat(cache.getCacheSpace()).isEqualTo(totalLength);
   }
 
-  /** Asserts that the cache contains the given subset of data in the {@code fakeDataSet}. */
+  /**
+   * Asserts that the cache contains the given subset of data in the {@code fakeDataSet}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
+   */
   public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
       throws IOException {
     for (Uri uri : uris) {
@@ -75,33 +88,45 @@ public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri...
     }
   }
 
-  /** Asserts that the cache contains the given data for {@code uriString}. */
+  /**
+   * Asserts that the cache contains the given data for {@code uriString} or not.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
+   */
   public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
-    CacheDataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
-    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource,
-        new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
+    DataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
+    DataSpec dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
+    String messageToPrepend = "Cached data doesn't match expected for '" + uri + "'";
+    assertReadData(dataSource, dataSpec, expected, messageToPrepend);
+  }
+
+  /**
+   * Asserts that the read data from {@code dataSource} specified by {@code dataSpec} is equal to
+   * {@code expected} or not.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
+   */
+  public static void assertReadData(
+      DataSource dataSource, DataSpec dataSpec, byte[] expected, String messageToPrepend)
+      throws IOException {
+    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource, dataSpec);
+    byte[] bytes = null;
     try {
-      inputStream.open();
-      byte[] buffer = new byte[1024];
-      int bytesRead;
-      while ((bytesRead = inputStream.read(buffer)) != -1) {
-        outputStream.write(buffer, 0, bytesRead);
-      }
+      bytes = Util.toByteArray(inputStream);
     } catch (IOException e) {
       // Ignore
     } finally {
       inputStream.close();
     }
-    assertWithMessage("Cached data doesn't match expected for '" + uri + "'")
-        .that(outputStream.toByteArray()).isEqualTo(expected);
+    assertWithMessage(messageToPrepend).that(bytes).isEqualTo(expected);
   }
 
   /** Asserts that there is no cache content for the given {@code uriStrings}. */
   public static void assertDataNotCached(Cache cache, String... uriStrings) {
     for (String uriString : uriStrings) {
       assertWithMessage("There is cached data for '" + uriString + "'")
-          .that(cache.getCachedSpans(CacheUtil.generateKey(Uri.parse(uriString)))).isNull();
+          .that(cache.getCachedSpans(CacheUtil.generateKey(Uri.parse(uriString))))
+          .isEmpty();
     }
   }
 
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
index e92f072dc2..09be138abe 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest.java
@@ -15,50 +15,47 @@
  */
 package com.google.android.exoplayer2.upstream.cache;
 
-import static android.net.Uri.EMPTY;
-import static com.google.android.exoplayer2.C.LENGTH_UNSET;
 import static com.google.android.exoplayer2.upstream.cache.CacheAsserts.assertCacheEmpty;
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
-import static java.util.Arrays.copyOf;
-import static java.util.Arrays.copyOfRange;
 import static org.junit.Assert.fail;
 
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
 import com.google.android.exoplayer2.testutil.FakeDataSource;
+import com.google.android.exoplayer2.testutil.TestUtil;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.FileDataSource;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
 import java.io.IOException;
+import java.util.Arrays;
+import java.util.NavigableSet;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link CacheDataSource}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class CacheDataSourceTest {
 
   private static final byte[] TEST_DATA = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   private static final int MAX_CACHE_FILE_SIZE = 3;
-  private static final String KEY_1 = "key 1";
-  private static final String KEY_2 = "key 2";
 
+  private Uri testDataUri;
+  private String testDataKey;
   private File tempFolder;
   private SimpleCache cache;
 
   @Before
   public void setUp() throws Exception {
+    testDataUri = Uri.parse("test_data");
+    testDataKey = CacheUtil.generateKey(testDataUri);
     tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
   }
@@ -95,10 +92,8 @@ public void testCacheAndReadUnknownLength() throws Exception {
     assertCacheAndRead(false, true);
   }
 
-  // Disabled test as we don't support caching of definitely unknown length content
-  @Ignore
   @Test
-  public void disabledTestCacheAndReadUnboundedRequestUnknownLength() throws Exception {
+  public void testCacheAndReadUnboundedRequestUnknownLength() throws Exception {
     assertCacheAndRead(true, true);
   }
 
@@ -116,7 +111,7 @@ public void testUnsatisfiableRange() throws Exception {
     // If the user try to access off range then it should throw an IOException
     try {
       cacheDataSource = createCacheDataSource(false, false);
-      cacheDataSource.open(new DataSpec(Uri.EMPTY, TEST_DATA.length, 5, KEY_1));
+      cacheDataSource.open(new DataSpec(testDataUri, TEST_DATA.length, 5, testDataKey));
       fail();
     } catch (IOException e) {
       // success
@@ -128,7 +123,7 @@ public void testContentLengthEdgeCases() throws Exception {
     // Read partial at EOS but don't cross it so length is unknown
     CacheDataSource cacheDataSource = createCacheDataSource(false, true);
     assertReadData(cacheDataSource, true, TEST_DATA.length - 2, 2);
-    assertThat(cache.getContentLength(KEY_1)).isEqualTo(LENGTH_UNSET);
+    assertThat(cache.getContentLength(testDataKey)).isEqualTo(C.LENGTH_UNSET);
 
     // Now do an unbounded request for whole data. This will cause a bounded request from upstream.
     // End of data from upstream shouldn't be mixed up with EOS and cause length set wrong.
@@ -136,19 +131,50 @@ public void testContentLengthEdgeCases() throws Exception {
     assertReadDataContentLength(cacheDataSource, true, true);
 
     // Now the length set correctly do an unbounded request with offset
-    assertThat(cacheDataSource.open(new DataSpec(EMPTY, TEST_DATA.length - 2,
-        LENGTH_UNSET, KEY_1))).isEqualTo(2);
+    assertThat(
+            cacheDataSource.open(
+                new DataSpec(testDataUri, TEST_DATA.length - 2, C.LENGTH_UNSET, testDataKey)))
+        .isEqualTo(2);
 
     // An unbounded request with offset for not cached content
-    assertThat(cacheDataSource.open(new DataSpec(EMPTY, TEST_DATA.length - 2,
-        LENGTH_UNSET, KEY_2))).isEqualTo(LENGTH_UNSET);
+    assertThat(
+            cacheDataSource.open(
+                new DataSpec(
+                    Uri.parse("notCachedUri"), TEST_DATA.length - 2, C.LENGTH_UNSET, null)))
+        .isEqualTo(C.LENGTH_UNSET);
+  }
+
+  @Test
+  public void testUnknownLengthContentReadInOneConnectionAndLengthIsResolved() throws Exception {
+    FakeDataSource upstream = new FakeDataSource();
+    upstream
+        .getDataSet()
+        .newData(testDataUri)
+        .appendReadData(TEST_DATA)
+        .setSimulateUnknownLength(true);
+    CacheDataSource cacheDataSource = new CacheDataSource(cache, upstream, 0);
+
+    int flags = DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH;
+    cacheDataSource.open(new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey, flags));
+    TestUtil.readToEnd(cacheDataSource);
+    cacheDataSource.close();
+
+    assertThat(upstream.getAndClearOpenedDataSpecs()).hasLength(1);
+    assertThat(cache.getContentLength(testDataKey)).isEqualTo(TEST_DATA.length);
   }
 
   @Test
   public void testIgnoreCacheForUnsetLengthRequests() throws Exception {
-    CacheDataSource cacheDataSource = createCacheDataSource(false, true,
-        CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
-    assertReadData(cacheDataSource, true, 0, C.LENGTH_UNSET);
+    FakeDataSource upstream = new FakeDataSource();
+    upstream.getDataSet().setData(testDataUri, TEST_DATA);
+    CacheDataSource cacheDataSource =
+        new CacheDataSource(
+            cache, upstream, CacheDataSource.FLAG_IGNORE_CACHE_FOR_UNSET_LENGTH_REQUESTS);
+
+    cacheDataSource.open(new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey));
+    TestUtil.readToEnd(cacheDataSource);
+    cacheDataSource.close();
+
     assertThat(cache.getKeys()).isEmpty();
   }
 
@@ -159,6 +185,168 @@ public void testReadOnlyCache() throws Exception {
     assertCacheEmpty(cache);
   }
 
+  @Test
+  public void testSwitchToCacheSourceWithReadOnlyCacheDataSource() throws Exception {
+    // Create a fake data source with a 1 MB default data.
+    FakeDataSource upstream = new FakeDataSource();
+    FakeData fakeData = upstream.getDataSet().newDefaultData().appendReadData(1024 * 1024 - 1);
+    // Insert an action just before the end of the data to fail the test if reading from upstream
+    // reaches end of the data.
+    fakeData
+        .appendReadAction(
+            new Runnable() {
+              @Override
+              public void run() {
+                fail("Read from upstream shouldn't reach to the end of the data.");
+              }
+            })
+        .appendReadData(1);
+    // Create cache read-only CacheDataSource.
+    CacheDataSource cacheDataSource =
+        new CacheDataSource(cache, upstream, new FileDataSource(), null, 0, null);
+
+    // Open source and read some data from upstream as the data hasn't cached yet.
+    DataSpec dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey);
+    cacheDataSource.open(dataSpec);
+    byte[] buffer = new byte[1024];
+    cacheDataSource.read(buffer, 0, buffer.length);
+
+    // Cache the data.
+    // Although we use another FakeDataSource instance, it shouldn't matter.
+    FakeDataSource upstream2 =
+        new FakeDataSource(
+            new FakeDataSource()
+                .getDataSet()
+                .newDefaultData()
+                .appendReadData(1024 * 1024)
+                .endData());
+    CacheUtil.cache(dataSpec, cache, upstream2, null);
+
+    // Read the rest of the data.
+    TestUtil.readToEnd(cacheDataSource);
+    cacheDataSource.close();
+  }
+
+  @Test
+  public void testSwitchToCacheSourceWithNonBlockingCacheDataSource() throws Exception {
+    // Create a fake data source with a 1 MB default data.
+    FakeDataSource upstream = new FakeDataSource();
+    FakeData fakeData = upstream.getDataSet().newDefaultData().appendReadData(1024 * 1024 - 1);
+    // Insert an action just before the end of the data to fail the test if reading from upstream
+    // reaches end of the data.
+    fakeData
+        .appendReadAction(
+            new Runnable() {
+              @Override
+              public void run() {
+                fail("Read from upstream shouldn't reach to the end of the data.");
+              }
+            })
+        .appendReadData(1);
+
+    // Lock the content on the cache.
+    SimpleCacheSpan cacheSpan = cache.startReadWriteNonBlocking(testDataKey, 0);
+    assertThat(cacheSpan).isNotNull();
+    assertThat(cacheSpan.isHoleSpan()).isTrue();
+
+    // Create non blocking CacheDataSource.
+    CacheDataSource cacheDataSource = new CacheDataSource(cache, upstream, 0);
+
+    // Open source and read some data from upstream without writing to cache as the data is locked.
+    DataSpec dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey);
+    cacheDataSource.open(dataSpec);
+    byte[] buffer = new byte[1024];
+    cacheDataSource.read(buffer, 0, buffer.length);
+
+    // Unlock the span.
+    cache.releaseHoleSpan(cacheSpan);
+    assertCacheEmpty(cache);
+
+    // Cache the data.
+    // Although we use another FakeDataSource instance, it shouldn't matter.
+    FakeDataSource upstream2 =
+        new FakeDataSource(
+            new FakeDataSource()
+                .getDataSet()
+                .newDefaultData()
+                .appendReadData(1024 * 1024)
+                .endData());
+    CacheUtil.cache(dataSpec, cache, upstream2, null);
+
+    // Read the rest of the data.
+    TestUtil.readToEnd(cacheDataSource);
+    cacheDataSource.close();
+  }
+
+  @Test
+  public void testDeleteCachedWhileReadingFromUpstreamWithReadOnlyCacheDataSourceDoesNotCrash()
+      throws Exception {
+    // Create a fake data source with a 1 KB default data.
+    FakeDataSource upstream = new FakeDataSource();
+    upstream.getDataSet().newDefaultData().appendReadData(1024).endData();
+
+    // Cache the latter half of the data.
+    DataSpec dataSpec = new DataSpec(testDataUri, 512, C.LENGTH_UNSET, testDataKey);
+    CacheUtil.cache(dataSpec, cache, upstream, null);
+
+    // Create cache read-only CacheDataSource.
+    CacheDataSource cacheDataSource =
+        new CacheDataSource(cache, upstream, new FileDataSource(), null, 0, null);
+
+    // Open source and read some data from upstream as the data hasn't cached yet.
+    dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey);
+    cacheDataSource.open(dataSpec);
+    TestUtil.readExactly(cacheDataSource, 100);
+
+    // Delete cached data.
+    CacheUtil.remove(cache, testDataKey);
+    assertCacheEmpty(cache);
+
+    // Read the rest of the data.
+    TestUtil.readToEnd(cacheDataSource);
+    cacheDataSource.close();
+  }
+
+  @Test
+  public void testDeleteCachedWhileReadingFromUpstreamWithBlockingCacheDataSourceDoesNotBlock()
+      throws Exception {
+    // Create a fake data source with a 1 KB default data.
+    FakeDataSource upstream = new FakeDataSource();
+    int dataLength = 1024;
+    upstream.getDataSet().newDefaultData().appendReadData(dataLength).endData();
+
+    // Cache the latter half of the data.
+    int halfDataLength = 512;
+    DataSpec dataSpec = new DataSpec(testDataUri, halfDataLength, C.LENGTH_UNSET, testDataKey);
+    CacheUtil.cache(dataSpec, cache, upstream, null);
+
+    // Create blocking CacheDataSource.
+    CacheDataSource cacheDataSource =
+        new CacheDataSource(cache, upstream, CacheDataSource.FLAG_BLOCK_ON_CACHE);
+
+    dataSpec = new DataSpec(testDataUri, 0, C.LENGTH_UNSET, testDataKey);
+    cacheDataSource.open(dataSpec);
+
+    // Read the first half from upstream as it hasn't cached yet.
+    TestUtil.readExactly(cacheDataSource, halfDataLength);
+
+    // Delete the cached latter half.
+    NavigableSet<CacheSpan> cachedSpans = cache.getCachedSpans(testDataKey);
+    for (CacheSpan cachedSpan : cachedSpans) {
+      if (cachedSpan.position >= halfDataLength) {
+        try {
+          cache.removeSpan(cachedSpan);
+        } catch (Cache.CacheException e) {
+          // do nothing
+        }
+      }
+    }
+
+    // Read the rest of the data.
+    TestUtil.readToEnd(cacheDataSource);
+    cacheDataSource.close();
+  }
+
   private void assertCacheAndRead(boolean unboundedRequest, boolean simulateUnknownLength)
       throws IOException {
     // Read all data from upstream and write to cache
@@ -179,8 +367,8 @@ private void assertReadDataContentLength(CacheDataSource cacheDataSource,
       boolean unboundedRequest, boolean unknownLength) throws IOException {
     int length = unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length;
     assertReadData(cacheDataSource, unknownLength, 0, length);
-    assertWithMessage("When the range specified, CacheDataSource doesn't reach EOS so shouldn't "
-        + "cache content length").that(cache.getContentLength(KEY_1))
+    // If !unboundedRequest, CacheDataSource doesn't reach EOS so shouldn't cache content length
+    assertThat(cache.getContentLength(testDataKey))
         .isEqualTo(!unboundedRequest ? C.LENGTH_UNSET : TEST_DATA.length);
   }
 
@@ -190,23 +378,15 @@ private void assertReadData(CacheDataSource cacheDataSource, boolean unknownLeng
     if (length != C.LENGTH_UNSET) {
       testDataLength = Math.min(testDataLength, length);
     }
-    assertThat(cacheDataSource.open(new DataSpec(EMPTY, position, length, KEY_1)))
-        .isEqualTo(unknownLength ? length : testDataLength);
-
-    byte[] buffer = new byte[100];
-    int totalBytesRead = 0;
-    while (true) {
-      int read = cacheDataSource.read(buffer, totalBytesRead, buffer.length - totalBytesRead);
-      if (read == C.RESULT_END_OF_INPUT) {
-        break;
-      }
-      totalBytesRead += read;
-    }
-    assertThat(totalBytesRead).isEqualTo(testDataLength);
-    assertThat(copyOf(buffer, totalBytesRead))
-        .isEqualTo(copyOfRange(TEST_DATA, position, position + testDataLength));
-
+    DataSpec dataSpec =
+        new DataSpec(
+            testDataUri, position, length, testDataKey, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
+    assertThat(cacheDataSource.open(dataSpec)).isEqualTo(unknownLength ? length : testDataLength);
     cacheDataSource.close();
+
+    byte[] expected = Arrays.copyOfRange(TEST_DATA, position, position + testDataLength);
+    CacheAsserts.assertReadData(
+        cacheDataSource, dataSpec, expected, "Cached data doesn't match the original data");
   }
 
   private CacheDataSource createCacheDataSource(boolean setReadException,
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
index 3b8276c731..1e6febd8a9 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceTest2.java
@@ -39,13 +39,11 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
 
 /**
  * Additional tests for {@link CacheDataSource}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class CacheDataSourceTest2 {
 
   private static final String EXO_CACHE_DIR = "exo";
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
index c8231ec4ac..7237ecd50d 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CacheUtilTest.java
@@ -44,13 +44,11 @@
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests {@link CacheUtil}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class CacheUtilTest {
 
   /**
@@ -72,7 +70,7 @@ private void init() {
     }
 
     @Override
-    public long getCachedBytes(String key, long position, long length) {
+    public long getCachedLength(String key, long position, long length) {
       for (int i = 0; i < spansAndGaps.length; i++) {
         int spanOrGap = spansAndGaps[i];
         if (position < spanOrGap) {
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
new file mode 100644
index 0000000000..50f9cd2ae8
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/CachedRegionTrackerTest.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.upstream.cache;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyString;
+import static org.mockito.Mockito.when;
+
+import com.google.android.exoplayer2.extractor.ChunkIndex;
+import com.google.android.exoplayer2.util.Util;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.TreeSet;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Tests for {@link CachedRegionTracker}. */
+@RunWith(RobolectricTestRunner.class)
+public final class CachedRegionTrackerTest {
+
+  private static final String CACHE_KEY = "abc";
+  private static final long MS_IN_US = 1000;
+
+  // 5 chunks, each 20 bytes long and 100 ms long.
+  private static final ChunkIndex CHUNK_INDEX =
+      new ChunkIndex(
+          new int[] {20, 20, 20, 20, 20},
+          new long[] {100, 120, 140, 160, 180},
+          new long[] {
+            100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US, 100 * MS_IN_US
+          },
+          new long[] {0, 100 * MS_IN_US, 200 * MS_IN_US, 300 * MS_IN_US, 400 * MS_IN_US});
+
+  @Mock private Cache cache;
+  private CachedRegionTracker tracker;
+
+  private CachedContentIndex index;
+  private File cacheDir;
+
+  @Before
+  public void setUp() throws Exception {
+    MockitoAnnotations.initMocks(this);
+    when(cache.addListener(anyString(), any(Cache.Listener.class)))
+        .thenReturn(new TreeSet<CacheSpan>());
+    tracker = new CachedRegionTracker(cache, CACHE_KEY, CHUNK_INDEX);
+    cacheDir = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
+    index = new CachedContentIndex(cacheDir);
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    Util.recursiveDelete(cacheDir);
+  }
+
+  @Test
+  public void testGetRegion_noSpansInCache() {
+    assertThat(tracker.getRegionEndTimeMs(100)).isEqualTo(CachedRegionTracker.NOT_CACHED);
+    assertThat(tracker.getRegionEndTimeMs(150)).isEqualTo(CachedRegionTracker.NOT_CACHED);
+  }
+
+  @Test
+  public void testGetRegion_fullyCached() throws Exception {
+    tracker.onSpanAdded(cache, newCacheSpan(100, 100));
+
+    assertThat(tracker.getRegionEndTimeMs(101)).isEqualTo(CachedRegionTracker.CACHED_TO_END);
+    assertThat(tracker.getRegionEndTimeMs(121)).isEqualTo(CachedRegionTracker.CACHED_TO_END);
+  }
+
+  @Test
+  public void testGetRegion_partiallyCached() throws Exception {
+    tracker.onSpanAdded(cache, newCacheSpan(100, 40));
+
+    assertThat(tracker.getRegionEndTimeMs(101)).isEqualTo(200);
+    assertThat(tracker.getRegionEndTimeMs(121)).isEqualTo(200);
+  }
+
+  @Test
+  public void testGetRegion_multipleSpanAddsJoinedCorrectly() throws Exception {
+    tracker.onSpanAdded(cache, newCacheSpan(100, 20));
+    tracker.onSpanAdded(cache, newCacheSpan(120, 20));
+
+    assertThat(tracker.getRegionEndTimeMs(101)).isEqualTo(200);
+    assertThat(tracker.getRegionEndTimeMs(121)).isEqualTo(200);
+  }
+
+  @Test
+  public void testGetRegion_fullyCachedThenPartiallyRemoved() throws Exception {
+    // Start with the full stream in cache.
+    tracker.onSpanAdded(cache, newCacheSpan(100, 100));
+
+    // Remove the middle bit.
+    tracker.onSpanRemoved(cache, newCacheSpan(140, 40));
+
+    assertThat(tracker.getRegionEndTimeMs(101)).isEqualTo(200);
+    assertThat(tracker.getRegionEndTimeMs(121)).isEqualTo(200);
+
+    assertThat(tracker.getRegionEndTimeMs(181)).isEqualTo(CachedRegionTracker.CACHED_TO_END);
+  }
+
+  @Test
+  public void testGetRegion_subchunkEstimation() throws Exception {
+    tracker.onSpanAdded(cache, newCacheSpan(100, 10));
+
+    assertThat(tracker.getRegionEndTimeMs(101)).isEqualTo(50);
+    assertThat(tracker.getRegionEndTimeMs(111)).isEqualTo(CachedRegionTracker.NOT_CACHED);
+  }
+
+  private CacheSpan newCacheSpan(int position, int length) throws IOException {
+    int id = index.assignIdForKey(CACHE_KEY);
+    File cacheFile = createCacheSpanFile(cacheDir, id, position, length, 0);
+    return SimpleCacheSpan.createCacheEntry(cacheFile, index);
+  }
+
+  public static File createCacheSpanFile(
+      File cacheDir, int id, long offset, int length, long lastAccessTimestamp) throws IOException {
+    File cacheFile = SimpleCacheSpan.getCacheFile(cacheDir, id, offset, lastAccessTimestamp);
+    createTestFile(cacheFile, length);
+    return cacheFile;
+  }
+
+  private static void createTestFile(File file, int length) throws IOException {
+    FileOutputStream output = new FileOutputStream(file);
+    for (int i = 0; i < length; i++) {
+      output.write(i);
+    }
+    output.close();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
index 6f7f567ae7..84327e1091 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/LeastRecentlyUsedCacheEvictorTest.java
@@ -21,13 +21,11 @@
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link LeastRecentlyUsedCacheEvictor}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class LeastRecentlyUsedCacheEvictorTest {
 
   @Before
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
index d5894895b1..89ace34edc 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/cache/SimpleCacheTest.java
@@ -41,13 +41,11 @@
 import org.mockito.stubbing.Answer;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link SimpleCache}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class SimpleCacheTest {
 
   private static final String KEY_1 = "key1";
@@ -75,20 +73,17 @@ public void testCommittingOneFile() throws Exception {
 
     assertThat(simpleCache.startReadWriteNonBlocking(KEY_1, 0)).isNull();
 
-    assertThat(simpleCache.getKeys()).isEmpty();
     NavigableSet<CacheSpan> cachedSpans = simpleCache.getCachedSpans(KEY_1);
-    assertThat(cachedSpans == null || cachedSpans.isEmpty()).isTrue();
+    assertThat(cachedSpans.isEmpty()).isTrue();
     assertThat(simpleCache.getCacheSpace()).isEqualTo(0);
     assertThat(cacheDir.listFiles()).hasLength(0);
 
     addCache(simpleCache, KEY_1, 0, 15);
 
     Set<String> cachedKeys = simpleCache.getKeys();
-    assertThat(cachedKeys).hasSize(1);
-    assertThat(cachedKeys.contains(KEY_1)).isTrue();
+    assertThat(cachedKeys).containsExactly(KEY_1);
     cachedSpans = simpleCache.getCachedSpans(KEY_1);
-    assertThat(cachedSpans).hasSize(1);
-    assertThat(cachedSpans.contains(cacheSpan1)).isTrue();
+    assertThat(cachedSpans).contains(cacheSpan1);
     assertThat(simpleCache.getCacheSpace()).isEqualTo(15);
 
     simpleCache.releaseHoleSpan(cacheSpan1);
@@ -218,36 +213,36 @@ public void testEncryptedIndexLostKey() throws Exception {
   }
 
   @Test
-  public void testGetCachedBytes() throws Exception {
+  public void testGetCachedLength() throws Exception {
     SimpleCache simpleCache = getSimpleCache();
     CacheSpan cacheSpan = simpleCache.startReadWrite(KEY_1, 0);
 
     // No cached bytes, returns -'length'
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(-100);
+    assertThat(simpleCache.getCachedLength(KEY_1, 0, 100)).isEqualTo(-100);
 
     // Position value doesn't affect the return value
-    assertThat(simpleCache.getCachedBytes(KEY_1, 20, 100)).isEqualTo(-100);
+    assertThat(simpleCache.getCachedLength(KEY_1, 20, 100)).isEqualTo(-100);
 
     addCache(simpleCache, KEY_1, 0, 15);
 
     // Returns the length of a single span
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(15);
+    assertThat(simpleCache.getCachedLength(KEY_1, 0, 100)).isEqualTo(15);
 
     // Value is capped by the 'length'
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 10)).isEqualTo(10);
+    assertThat(simpleCache.getCachedLength(KEY_1, 0, 10)).isEqualTo(10);
 
     addCache(simpleCache, KEY_1, 15, 35);
 
     // Returns the length of two adjacent spans
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(50);
+    assertThat(simpleCache.getCachedLength(KEY_1, 0, 100)).isEqualTo(50);
 
     addCache(simpleCache, KEY_1, 60, 10);
 
     // Not adjacent span doesn't affect return value
-    assertThat(simpleCache.getCachedBytes(KEY_1, 0, 100)).isEqualTo(50);
+    assertThat(simpleCache.getCachedLength(KEY_1, 0, 100)).isEqualTo(50);
 
     // Returns length of hole up to the next cached span
-    assertThat(simpleCache.getCachedBytes(KEY_1, 55, 100)).isEqualTo(-5);
+    assertThat(simpleCache.getCachedLength(KEY_1, 55, 100)).isEqualTo(-5);
 
     simpleCache.releaseHoleSpan(cacheSpan);
   }
@@ -283,7 +278,7 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
 
     // Although store() has failed, it should remove the first span and add the new one.
     NavigableSet<CacheSpan> cachedSpans = simpleCache.getCachedSpans(KEY_1);
-    assertThat(cachedSpans).isNotNull();
+    assertThat(cachedSpans).isNotEmpty();
     assertThat(cachedSpans).hasSize(1);
     assertThat(cachedSpans.pollFirst().position).isEqualTo(15);
   }
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java b/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
index 833a7e10c1..40b626a7db 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/upstream/crypto/AesFlushingCipherTest.java
@@ -26,13 +26,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link AesFlushingCipher}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class AesFlushingCipherTest {
 
   private static final int DATA_LENGTH = 65536;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java
index dcf3d31eb3..4d80a9647e 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/AtomicFileTest.java
@@ -27,13 +27,11 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests {@link AtomicFile}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class AtomicFileTest {
 
   private File tempFolder;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
index 13b126090c..af596c35f3 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ColorParserTest.java
@@ -27,13 +27,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit test for <code>ColorParser</code>.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ColorParserTest {
 
   // Negative tests.
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/MimeTypesTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/MimeTypesTest.java
new file mode 100644
index 0000000000..c607e92055
--- /dev/null
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/MimeTypesTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.util;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link MimeTypes}. */
+@RunWith(RobolectricTestRunner.class)
+public final class MimeTypesTest {
+
+  @Test
+  public void testGetMediaMimeType_fromValidCodecs_returnsCorrectMimeType() {
+    assertThat(MimeTypes.getMediaMimeType("avc1")).isEqualTo(MimeTypes.VIDEO_H264);
+    assertThat(MimeTypes.getMediaMimeType("avc1.42E01E")).isEqualTo(MimeTypes.VIDEO_H264);
+    assertThat(MimeTypes.getMediaMimeType("avc1.42E01F")).isEqualTo(MimeTypes.VIDEO_H264);
+    assertThat(MimeTypes.getMediaMimeType("avc1.4D401F")).isEqualTo(MimeTypes.VIDEO_H264);
+    assertThat(MimeTypes.getMediaMimeType("avc1.4D4028")).isEqualTo(MimeTypes.VIDEO_H264);
+    assertThat(MimeTypes.getMediaMimeType("avc1.640028")).isEqualTo(MimeTypes.VIDEO_H264);
+    assertThat(MimeTypes.getMediaMimeType("avc1.640029")).isEqualTo(MimeTypes.VIDEO_H264);
+    assertThat(MimeTypes.getMediaMimeType("avc3")).isEqualTo(MimeTypes.VIDEO_H264);
+    assertThat(MimeTypes.getMediaMimeType("hev1")).isEqualTo(MimeTypes.VIDEO_H265);
+    assertThat(MimeTypes.getMediaMimeType("hvc1")).isEqualTo(MimeTypes.VIDEO_H265);
+    assertThat(MimeTypes.getMediaMimeType("vp08")).isEqualTo(MimeTypes.VIDEO_VP8);
+    assertThat(MimeTypes.getMediaMimeType("vp8")).isEqualTo(MimeTypes.VIDEO_VP8);
+    assertThat(MimeTypes.getMediaMimeType("vp09")).isEqualTo(MimeTypes.VIDEO_VP9);
+    assertThat(MimeTypes.getMediaMimeType("vp9")).isEqualTo(MimeTypes.VIDEO_VP9);
+
+    assertThat(MimeTypes.getMediaMimeType("ac-3")).isEqualTo(MimeTypes.AUDIO_AC3);
+    assertThat(MimeTypes.getMediaMimeType("dac3")).isEqualTo(MimeTypes.AUDIO_AC3);
+    assertThat(MimeTypes.getMediaMimeType("dec3")).isEqualTo(MimeTypes.AUDIO_E_AC3);
+    assertThat(MimeTypes.getMediaMimeType("ec-3")).isEqualTo(MimeTypes.AUDIO_E_AC3);
+    assertThat(MimeTypes.getMediaMimeType("ec+3")).isEqualTo(MimeTypes.AUDIO_E_AC3_JOC);
+    assertThat(MimeTypes.getMediaMimeType("dtsc")).isEqualTo(MimeTypes.AUDIO_DTS);
+    assertThat(MimeTypes.getMediaMimeType("dtse")).isEqualTo(MimeTypes.AUDIO_DTS);
+    assertThat(MimeTypes.getMediaMimeType("dtsh")).isEqualTo(MimeTypes.AUDIO_DTS_HD);
+    assertThat(MimeTypes.getMediaMimeType("dtsl")).isEqualTo(MimeTypes.AUDIO_DTS_HD);
+    assertThat(MimeTypes.getMediaMimeType("opus")).isEqualTo(MimeTypes.AUDIO_OPUS);
+    assertThat(MimeTypes.getMediaMimeType("vorbis")).isEqualTo(MimeTypes.AUDIO_VORBIS);
+    assertThat(MimeTypes.getMediaMimeType("mp4a")).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.40.02")).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.40.05")).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.40.2")).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.40.5")).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.40.29")).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.66")).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.67")).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.68")).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.69")).isEqualTo(MimeTypes.AUDIO_MPEG);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.6B")).isEqualTo(MimeTypes.AUDIO_MPEG);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.a5")).isEqualTo(MimeTypes.AUDIO_AC3);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.A5")).isEqualTo(MimeTypes.AUDIO_AC3);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.a6")).isEqualTo(MimeTypes.AUDIO_E_AC3);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.A6")).isEqualTo(MimeTypes.AUDIO_E_AC3);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.A9")).isEqualTo(MimeTypes.AUDIO_DTS);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.AC")).isEqualTo(MimeTypes.AUDIO_DTS);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.AA")).isEqualTo(MimeTypes.AUDIO_DTS_HD);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.AB")).isEqualTo(MimeTypes.AUDIO_DTS_HD);
+    assertThat(MimeTypes.getMediaMimeType("mp4a.AD")).isEqualTo(MimeTypes.AUDIO_OPUS);
+  }
+
+  @Test
+  public void testGetMimeTypeFromMp4ObjectType_forValidObjectType_returnsCorrectMimeType() {
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x60)).isEqualTo(MimeTypes.VIDEO_MPEG2);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x61)).isEqualTo(MimeTypes.VIDEO_MPEG2);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x20)).isEqualTo(MimeTypes.VIDEO_MP4V);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x21)).isEqualTo(MimeTypes.VIDEO_H264);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x23)).isEqualTo(MimeTypes.VIDEO_H265);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x6B)).isEqualTo(MimeTypes.AUDIO_MPEG);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x40)).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x66)).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x67)).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x68)).isEqualTo(MimeTypes.AUDIO_AAC);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0xA5)).isEqualTo(MimeTypes.AUDIO_AC3);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0xA6)).isEqualTo(MimeTypes.AUDIO_E_AC3);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0xA9)).isEqualTo(MimeTypes.AUDIO_DTS);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0xAC)).isEqualTo(MimeTypes.AUDIO_DTS);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0xAA)).isEqualTo(MimeTypes.AUDIO_DTS_HD);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0xAB)).isEqualTo(MimeTypes.AUDIO_DTS_HD);
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0xAD)).isEqualTo(MimeTypes.AUDIO_OPUS);
+  }
+
+  @Test
+  public void testGetMimeTypeFromMp4ObjectType_forInvalidObjectType_returnsNull() {
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0)).isNull();
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x600)).isNull();
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(0x01)).isNull();
+    assertThat(MimeTypes.getMimeTypeFromMp4ObjectType(-1)).isNull();
+  }
+}
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
index ee77664cce..473e5a8b05 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/NalUnitUtilTest.java
@@ -23,13 +23,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link NalUnitUtil}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class NalUnitUtilTest {
 
   private static final int TEST_PARTIAL_NAL_POSITION = 4;
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
index 0d864f407f..438643b933 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java
@@ -21,13 +21,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link ParsableBitArray}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ParsableBitArrayTest {
 
   private static final byte[] TEST_DATA = new byte[] {0x3C, (byte) 0xD2, (byte) 0x5F, (byte) 0x01,
@@ -171,6 +169,73 @@ public void testByteAlignFromByteAligned() {
     assertReadBitsToEnd(16);
   }
 
+  @Test
+  public void testPutBitsWithinByte() {
+    ParsableBitArray output = new ParsableBitArray(new byte[4]);
+    output.skipBits(1);
+
+    output.putInt(0x3F, 5);
+
+    output.setPosition(0);
+    assertThat(output.readBits(8)).isEqualTo(0x1F << 2); // Check that only 5 bits are modified.
+  }
+
+  @Test
+  public void testPutBitsAcrossTwoBytes() {
+    ParsableBitArray output = new ParsableBitArray(new byte[4]);
+    output.setPosition(12);
+
+    output.putInt(0xFF, 8);
+    output.setPosition(8);
+
+    assertThat(output.readBits(16)).isEqualTo(0x0FF0);
+  }
+
+  @Test
+  public void testPutBitsAcrossMultipleBytes() {
+    ParsableBitArray output = new ParsableBitArray(new byte[8]);
+    output.setPosition(31); // Writing starts at 31 to test the 30th bit is not modified.
+
+    output.putInt(0xFF146098, 30); // Write only 30 to test the 61st bit is not modified.
+
+    output.setPosition(30);
+    assertThat(output.readBits(32)).isEqualTo(0x3F146098 << 1);
+  }
+
+  @Test
+  public void testPut32Bits() {
+    ParsableBitArray output = new ParsableBitArray(new byte[5]);
+    output.setPosition(4);
+
+    output.putInt(0xFF146098, 32);
+
+    output.setPosition(4);
+    assertThat(output.readBits(32)).isEqualTo(0xFF146098);
+  }
+
+  @Test
+  public void testPutFullBytes() {
+    ParsableBitArray output = new ParsableBitArray(new byte[2]);
+
+    output.putInt(0x81, 8);
+
+    output.setPosition(0);
+    assertThat(output.readBits(8)).isEqualTo(0x81);
+  }
+
+  @Test
+  public void testNoOverwriting() {
+    ParsableBitArray output =
+        new ParsableBitArray(
+            new byte[] {(byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff});
+    output.setPosition(1);
+
+    output.putInt(0, 30);
+
+    output.setPosition(0);
+    assertThat(output.readBits(32)).isEqualTo(0x80000001);
+  }
+
   private void assertReadBitsToEnd(int expectedStartPosition) {
     int position = testArray.getPosition();
     assertThat(position).isEqualTo(expectedStartPosition);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
index 947a692647..701f532d6a 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableByteArrayTest.java
@@ -17,20 +17,18 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static java.nio.charset.Charset.forName;
-import static junit.framework.TestCase.fail;
+import static org.junit.Assert.fail;
 
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link ParsableByteArray}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ParsableByteArrayTest {
 
   private static final byte[] TEST_DATA =
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
index a3f38abcdb..210c42cfa5 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java
@@ -22,13 +22,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests for {@link ParsableNalUnitBitArray}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ParsableNalUnitBitArrayTest {
 
   private static final byte[] NO_ESCAPING_TEST_DATA = createByteArray(0, 3, 0, 1, 3, 0, 0);
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
index 8e384bbb10..6c921f0288 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/ReusableBufferedOutputStreamTest.java
@@ -21,13 +21,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Tests {@link ReusableBufferedOutputStream}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class ReusableBufferedOutputStreamTest {
 
   private static final byte[] TEST_DATA_1 = "test data 1".getBytes();
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java
index 52e7a722fb..a52867e1b2 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/UriUtilTest.java
@@ -21,13 +21,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link UriUtil}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public final class UriUtilTest {
 
   /**
diff --git a/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
index 1afe380483..cdd5d1a696 100644
--- a/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
+++ b/library/core/src/test/java/com/google/android/exoplayer2/util/UtilTest.java
@@ -18,6 +18,7 @@
 import static com.google.android.exoplayer2.util.Util.binarySearchCeil;
 import static com.google.android.exoplayer2.util.Util.binarySearchFloor;
 import static com.google.android.exoplayer2.util.Util.escapeFileName;
+import static com.google.android.exoplayer2.util.Util.getCodecsOfType;
 import static com.google.android.exoplayer2.util.Util.parseXsDateTime;
 import static com.google.android.exoplayer2.util.Util.parseXsDuration;
 import static com.google.android.exoplayer2.util.Util.unescapeFileName;
@@ -31,15 +32,49 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 /**
  * Unit tests for {@link Util}.
  */
 @RunWith(RobolectricTestRunner.class)
-@Config(sdk = Config.TARGET_SDK, manifest = Config.NONE)
 public class UtilTest {
 
+  @Test
+  public void testAddWithOverflowDefault() {
+    long res = Util.addWithOverflowDefault(5, 10, /* overflowResult= */ 0);
+    assertThat(res).isEqualTo(15);
+
+    res = Util.addWithOverflowDefault(Long.MAX_VALUE - 1, 1, /* overflowResult= */ 12345);
+    assertThat(res).isEqualTo(Long.MAX_VALUE);
+
+    res = Util.addWithOverflowDefault(Long.MIN_VALUE + 1, -1, /* overflowResult= */ 12345);
+    assertThat(res).isEqualTo(Long.MIN_VALUE);
+
+    res = Util.addWithOverflowDefault(Long.MAX_VALUE, 1, /* overflowResult= */ 12345);
+    assertThat(res).isEqualTo(12345);
+
+    res = Util.addWithOverflowDefault(Long.MIN_VALUE, -1, /* overflowResult= */ 12345);
+    assertThat(res).isEqualTo(12345);
+  }
+
+  @Test
+  public void testSubtrackWithOverflowDefault() {
+    long res = Util.subtractWithOverflowDefault(5, 10, /* overflowResult= */ 0);
+    assertThat(res).isEqualTo(-5);
+
+    res = Util.subtractWithOverflowDefault(Long.MIN_VALUE + 1, 1, /* overflowResult= */ 12345);
+    assertThat(res).isEqualTo(Long.MIN_VALUE);
+
+    res = Util.subtractWithOverflowDefault(Long.MAX_VALUE - 1, -1, /* overflowResult= */ 12345);
+    assertThat(res).isEqualTo(Long.MAX_VALUE);
+
+    res = Util.subtractWithOverflowDefault(Long.MIN_VALUE, 1, /* overflowResult= */ 12345);
+    assertThat(res).isEqualTo(12345);
+
+    res = Util.subtractWithOverflowDefault(Long.MAX_VALUE, -1, /* overflowResult= */ 12345);
+    assertThat(res).isEqualTo(12345);
+  }
+
   @Test
   public void testInferContentType() {
     assertThat(Util.inferContentType("http://a.b/c.ism")).isEqualTo(C.TYPE_SS);
@@ -181,6 +216,18 @@ public void testParseXsDateTime() throws Exception {
     assertThat(parseXsDateTime("2014-09-19T13:18:55.000-800")).isEqualTo(1411161535000L);
   }
 
+  @Test
+  public void testGetCodecsOfType() {
+    assertThat(getCodecsOfType(null, C.TRACK_TYPE_VIDEO)).isNull();
+    assertThat(getCodecsOfType("avc1.64001e,vp9.63.1", C.TRACK_TYPE_AUDIO)).isNull();
+    assertThat(getCodecsOfType(" vp9.63.1, ec-3 ", C.TRACK_TYPE_AUDIO)).isEqualTo("ec-3");
+    assertThat(getCodecsOfType("avc1.61e, vp9.63.1, ec-3 ", C.TRACK_TYPE_VIDEO))
+        .isEqualTo("avc1.61e,vp9.63.1");
+    assertThat(getCodecsOfType("avc1.61e, vp9.63.1, ec-3 ", C.TRACK_TYPE_VIDEO))
+        .isEqualTo("avc1.61e,vp9.63.1");
+    assertThat(getCodecsOfType("invalidCodec1, invalidCodec2 ", C.TRACK_TYPE_AUDIO)).isNull();
+  }
+
   @Test
   public void testUnescapeInvalidFileName() {
     assertThat(Util.unescapeFileName("%a")).isNull();
diff --git a/library/core/src/test/resources/robolectric.properties b/library/core/src/test/resources/robolectric.properties
new file mode 100644
index 0000000000..2f3210368e
--- /dev/null
+++ b/library/core/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+manifest=src/test/AndroidManifest.xml
diff --git a/library/dash/build.gradle b/library/dash/build.gradle
index 99441a2849..d2692eb7d9 100644
--- a/library/dash/build.gradle
+++ b/library/dash/build.gradle
@@ -33,17 +33,9 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile 'com.android.support:support-annotations:' + supportLibraryVersion
-    androidTestCompile project(modulePrefix + 'testutils')
-    androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
-    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
-    androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
-    testCompile project(modulePrefix + 'testutils')
-    testCompile 'com.google.truth:truth:' + truthVersion
-    testCompile 'junit:junit:' + junitVersion
-    testCompile 'org.mockito:mockito-core:' + mockitoVersion
-    testCompile 'org.robolectric:robolectric:' + robolectricVersion
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
 ext {
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/MockitoUtil.java b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/MockitoUtil.java
deleted file mode 100644
index e7cd9baf59..0000000000
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/MockitoUtil.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash;
-
-import android.test.InstrumentationTestCase;
-import org.mockito.MockitoAnnotations;
-
-/**
- * Utility for setting up Mockito for instrumentation tests.
- */
-public final class MockitoUtil {
-
-  /**
-   * Sets up Mockito for an instrumentation test.
-   */
-  public static void setUpMockito(InstrumentationTestCase instrumentationTestCase) {
-    // Workaround for https://code.google.com/p/dexmaker/issues/detail?id=2.
-    System.setProperty("dexmaker.dexcache",
-        instrumentationTestCase.getInstrumentation().getTargetContext().getCacheDir().getPath());
-    MockitoAnnotations.initMocks(instrumentationTestCase);
-  }
-
-  private MockitoUtil() {}
-
-}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
deleted file mode 100644
index 3ce4b37ec6..0000000000
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash.manifest;
-
-import android.net.Uri;
-import android.test.InstrumentationTestCase;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.testutil.TestUtil;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Unit tests for {@link DashManifestParser}.
- */
-public class DashManifestParserTest extends InstrumentationTestCase {
-
-  private static final String SAMPLE_MPD_1 = "sample_mpd_1";
-  private static final String SAMPLE_MPD_2_UNKNOWN_MIME_TYPE = "sample_mpd_2_unknown_mime_type";
-  private static final String SAMPLE_MPD_3_SEGMENT_TEMPLATE = "sample_mpd_3_segment_template";
-
-  /**
-   * Simple test to ensure the sample manifests parse without any exceptions being thrown.
-   */
-  public void testParseMediaPresentationDescription() throws IOException {
-    DashManifestParser parser = new DashManifestParser();
-    parser.parse(Uri.parse("https://example.com/test.mpd"),
-        TestUtil.getInputStream(getInstrumentation(), SAMPLE_MPD_1));
-    parser.parse(Uri.parse("https://example.com/test.mpd"),
-        TestUtil.getInputStream(getInstrumentation(), SAMPLE_MPD_2_UNKNOWN_MIME_TYPE));
-  }
-
-  public void testParseMediaPresentationDescriptionWithSegmentTemplate() throws IOException {
-    DashManifestParser parser = new DashManifestParser();
-    DashManifest mpd = parser.parse(Uri.parse("https://example.com/test.mpd"),
-        TestUtil.getInputStream(getInstrumentation(), SAMPLE_MPD_3_SEGMENT_TEMPLATE));
-
-    assertEquals(1, mpd.getPeriodCount());
-
-    Period period = mpd.getPeriod(0);
-    assertNotNull(period);
-    assertEquals(2, period.adaptationSets.size());
-
-    for (AdaptationSet adaptationSet : period.adaptationSets) {
-      assertNotNull(adaptationSet);
-      for (Representation representation : adaptationSet.representations) {
-        if (representation instanceof Representation.MultiSegmentRepresentation) {
-          Representation.MultiSegmentRepresentation multiSegmentRepresentation =
-              (Representation.MultiSegmentRepresentation) representation;
-          int firstSegmentIndex = multiSegmentRepresentation.getFirstSegmentNum();
-          RangedUri uri = multiSegmentRepresentation.getSegmentUrl(firstSegmentIndex);
-          assertTrue(uri.resolveUriString(representation.baseUrl).contains(
-              "redirector.googlevideo.com"));
-        }
-      }
-    }
-  }
-
-  public void testParseCea608AccessibilityChannel() {
-    assertEquals(1, DashManifestParser.parseCea608AccessibilityChannel(
-        buildCea608AccessibilityDescriptors("CC1=eng")));
-    assertEquals(2, DashManifestParser.parseCea608AccessibilityChannel(
-        buildCea608AccessibilityDescriptors("CC2=eng")));
-    assertEquals(3, DashManifestParser.parseCea608AccessibilityChannel(
-        buildCea608AccessibilityDescriptors("CC3=eng")));
-    assertEquals(4, DashManifestParser.parseCea608AccessibilityChannel(
-        buildCea608AccessibilityDescriptors("CC4=eng")));
-
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
-        buildCea608AccessibilityDescriptors(null)));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
-        buildCea608AccessibilityDescriptors("")));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
-        buildCea608AccessibilityDescriptors("CC0=eng")));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
-        buildCea608AccessibilityDescriptors("CC5=eng")));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea608AccessibilityChannel(
-        buildCea608AccessibilityDescriptors("Wrong format")));
-  }
-
-  public void testParseCea708AccessibilityChannel() {
-    assertEquals(1, DashManifestParser.parseCea708AccessibilityChannel(
-        buildCea708AccessibilityDescriptors("1=lang:eng")));
-    assertEquals(2, DashManifestParser.parseCea708AccessibilityChannel(
-        buildCea708AccessibilityDescriptors("2=lang:eng")));
-    assertEquals(3, DashManifestParser.parseCea708AccessibilityChannel(
-        buildCea708AccessibilityDescriptors("3=lang:eng")));
-    assertEquals(62, DashManifestParser.parseCea708AccessibilityChannel(
-        buildCea708AccessibilityDescriptors("62=lang:eng")));
-    assertEquals(63, DashManifestParser.parseCea708AccessibilityChannel(
-        buildCea708AccessibilityDescriptors("63=lang:eng")));
-
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
-        buildCea708AccessibilityDescriptors(null)));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
-        buildCea708AccessibilityDescriptors("")));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
-            buildCea708AccessibilityDescriptors("0=lang:eng")));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
-            buildCea708AccessibilityDescriptors("64=lang:eng")));
-    assertEquals(Format.NO_VALUE, DashManifestParser.parseCea708AccessibilityChannel(
-            buildCea708AccessibilityDescriptors("Wrong format")));
-  }
-
-  private static List<Descriptor> buildCea608AccessibilityDescriptors(String value) {
-    return Collections.singletonList(new Descriptor("urn:scte:dash:cc:cea-608:2015", value, null));
-  }
-
-  private static List<Descriptor> buildCea708AccessibilityDescriptors(String value) {
-    return Collections.singletonList(new Descriptor("urn:scte:dash:cc:cea-708:2015", value, null));
-  }
-
-}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
deleted file mode 100644
index 7d77ae82d9..0000000000
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash.manifest;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import junit.framework.TestCase;
-
-/**
- * Unit tests for {@link DashManifest}.
- */
-public class DashManifestTest extends TestCase {
-
-  private static final UtcTimingElement DUMMY_UTC_TIMING = new UtcTimingElement("", "");
-  private static final SingleSegmentBase DUMMY_SEGMENT_BASE = new SingleSegmentBase();
-  private static final Format DUMMY_FORMAT = Format.createSampleFormat("", "", 0);
-
-  public void testCopy() throws Exception {
-    Representation[][][] representations = newRepresentations(3, 2, 3);
-    DashManifest sourceManifest = newDashManifest(10,
-        newPeriod("1", 1,
-            newAdaptationSet(2, representations[0][0]),
-            newAdaptationSet(3, representations[0][1])),
-        newPeriod("4", 4,
-            newAdaptationSet(5, representations[1][0]),
-            newAdaptationSet(6, representations[1][1])),
-        newPeriod("7", 7,
-            newAdaptationSet(8, representations[2][0]),
-            newAdaptationSet(9, representations[2][1])));
-
-    List<RepresentationKey> keys = Arrays.asList(
-        new RepresentationKey(0, 0, 0),
-        new RepresentationKey(0, 0, 1),
-        new RepresentationKey(0, 1, 2),
-
-        new RepresentationKey(1, 0, 1),
-        new RepresentationKey(1, 1, 0),
-        new RepresentationKey(1, 1, 2),
-
-        new RepresentationKey(2, 0, 1),
-        new RepresentationKey(2, 0, 2),
-        new RepresentationKey(2, 1, 0));
-    // Keys don't need to be in any particular order
-    Collections.shuffle(keys, new Random(0));
-
-    DashManifest copyManifest = sourceManifest.copy(keys);
-
-    DashManifest expectedManifest = newDashManifest(10,
-        newPeriod("1", 1,
-            newAdaptationSet(2, representations[0][0][0], representations[0][0][1]),
-            newAdaptationSet(3, representations[0][1][2])),
-        newPeriod("4", 4,
-            newAdaptationSet(5, representations[1][0][1]),
-            newAdaptationSet(6, representations[1][1][0], representations[1][1][2])),
-        newPeriod("7", 7,
-            newAdaptationSet(8, representations[2][0][1], representations[2][0][2]),
-            newAdaptationSet(9, representations[2][1][0])));
-    assertManifestEquals(expectedManifest, copyManifest);
-  }
-
-  public void testCopySameAdaptationIndexButDifferentPeriod() throws Exception {
-    Representation[][][] representations = newRepresentations(2, 1, 1);
-    DashManifest sourceManifest = newDashManifest(10,
-        newPeriod("1", 1,
-            newAdaptationSet(2, representations[0][0])),
-        newPeriod("4", 4,
-            newAdaptationSet(5, representations[1][0])));
-
-    DashManifest copyManifest = sourceManifest.copy(Arrays.asList(
-        new RepresentationKey(0, 0, 0),
-        new RepresentationKey(1, 0, 0)));
-
-    DashManifest expectedManifest = newDashManifest(10,
-        newPeriod("1", 1,
-            newAdaptationSet(2, representations[0][0])),
-        newPeriod("4", 4,
-            newAdaptationSet(5, representations[1][0])));
-    assertManifestEquals(expectedManifest, copyManifest);
-  }
-
-  public void testCopySkipPeriod() throws Exception {
-    Representation[][][] representations = newRepresentations(3, 2, 3);
-    DashManifest sourceManifest = newDashManifest(10,
-        newPeriod("1", 1,
-            newAdaptationSet(2, representations[0][0]),
-            newAdaptationSet(3, representations[0][1])),
-        newPeriod("4", 4,
-            newAdaptationSet(5, representations[1][0]),
-            newAdaptationSet(6, representations[1][1])),
-        newPeriod("7", 7,
-            newAdaptationSet(8, representations[2][0]),
-            newAdaptationSet(9, representations[2][1])));
-
-    DashManifest copyManifest = sourceManifest.copy(Arrays.asList(
-        new RepresentationKey(0, 0, 0),
-        new RepresentationKey(0, 0, 1),
-        new RepresentationKey(0, 1, 2),
-
-        new RepresentationKey(2, 0, 1),
-        new RepresentationKey(2, 0, 2),
-        new RepresentationKey(2, 1, 0)));
-
-    DashManifest expectedManifest = newDashManifest(7,
-        newPeriod("1", 1,
-            newAdaptationSet(2, representations[0][0][0], representations[0][0][1]),
-            newAdaptationSet(3, representations[0][1][2])),
-        newPeriod("7", 4,
-            newAdaptationSet(8, representations[2][0][1], representations[2][0][2]),
-            newAdaptationSet(9, representations[2][1][0])));
-    assertManifestEquals(expectedManifest, copyManifest);
-  }
-
-  private static void assertManifestEquals(DashManifest expected, DashManifest actual) {
-    assertEquals(expected.availabilityStartTime, actual.availabilityStartTime);
-    assertEquals(expected.duration, actual.duration);
-    assertEquals(expected.minBufferTime, actual.minBufferTime);
-    assertEquals(expected.dynamic, actual.dynamic);
-    assertEquals(expected.minUpdatePeriod, actual.minUpdatePeriod);
-    assertEquals(expected.timeShiftBufferDepth, actual.timeShiftBufferDepth);
-    assertEquals(expected.suggestedPresentationDelay, actual.suggestedPresentationDelay);
-    assertEquals(expected.utcTiming, actual.utcTiming);
-    assertEquals(expected.location, actual.location);
-    assertEquals(expected.getPeriodCount(), actual.getPeriodCount());
-    for (int i = 0; i < expected.getPeriodCount(); i++) {
-      Period expectedPeriod = expected.getPeriod(i);
-      Period actualPeriod = actual.getPeriod(i);
-      assertEquals(expectedPeriod.id, actualPeriod.id);
-      assertEquals(expectedPeriod.startMs, actualPeriod.startMs);
-      List<AdaptationSet> expectedAdaptationSets = expectedPeriod.adaptationSets;
-      List<AdaptationSet> actualAdaptationSets = actualPeriod.adaptationSets;
-      assertEquals(expectedAdaptationSets.size(), actualAdaptationSets.size());
-      for (int j = 0; j < expectedAdaptationSets.size(); j++) {
-        AdaptationSet expectedAdaptationSet = expectedAdaptationSets.get(j);
-        AdaptationSet actualAdaptationSet = actualAdaptationSets.get(j);
-        assertEquals(expectedAdaptationSet.id, actualAdaptationSet.id);
-        assertEquals(expectedAdaptationSet.type, actualAdaptationSet.type);
-        assertEquals(expectedAdaptationSet.accessibilityDescriptors,
-            actualAdaptationSet.accessibilityDescriptors);
-        assertEquals(expectedAdaptationSet.representations, actualAdaptationSet.representations);
-      }
-    }
-  }
-
-  private static Representation[][][] newRepresentations(int periodCount, int adaptationSetCounts,
-      int representationCounts) {
-    Representation[][][] representations = new Representation[periodCount][][];
-    for (int i = 0; i < periodCount; i++) {
-      representations[i] = new Representation[adaptationSetCounts][];
-      for (int j = 0; j < adaptationSetCounts; j++) {
-        representations[i][j] = new Representation[representationCounts];
-        for (int k = 0; k < representationCounts; k++) {
-          representations[i][j][k] = newRepresentation();
-        }
-      }
-    }
-    return representations;
-  }
-
-  private static Representation newRepresentation() {
-    return Representation.newInstance("", 0, DUMMY_FORMAT, "", DUMMY_SEGMENT_BASE);
-  }
-
-  private static DashManifest newDashManifest(int duration, Period... periods) {
-    return new DashManifest(0, duration, 1, false, 2, 3, 4, DUMMY_UTC_TIMING, Uri.EMPTY,
-        Arrays.asList(periods));
-  }
-
-  private static Period newPeriod(String id, int startMs, AdaptationSet... adaptationSets) {
-    return new Period(id, startMs, Arrays.asList(adaptationSets));
-  }
-
-  private static AdaptationSet newAdaptationSet(int seed, Representation... representations) {
-    return new AdaptationSet(++seed, ++seed, Arrays.asList(representations), null, null);
-  }
-
-}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
deleted file mode 100644
index 5d10aba1ae..0000000000
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash.manifest;
-
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
-import com.google.android.exoplayer2.util.MimeTypes;
-import junit.framework.TestCase;
-
-/**
- * Unit test for {@link Representation}.
- */
-public class RepresentationTest extends TestCase {
-
-  public void testGetCacheKey() {
-    String uri = "http://www.google.com";
-    SegmentBase base = new SingleSegmentBase(new RangedUri(null, 0, 1), 1, 0, 1, 1);
-    Format format = Format.createVideoContainerFormat("0", MimeTypes.APPLICATION_MP4, null,
-        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null, 0);
-    Representation representation = Representation.newInstance("test_stream_1", 3, format, uri,
-        base);
-    assertEquals("test_stream_1.0.3", representation.getCacheKey());
-
-    format = Format.createVideoContainerFormat("150", MimeTypes.APPLICATION_MP4, null,
-        MimeTypes.VIDEO_H264, 2500000, 1920, 1080, Format.NO_VALUE, null, 0);
-    representation = Representation.newInstance("test_stream_1", Representation.REVISION_ID_DEFAULT,
-        format, uri, base);
-    assertEquals("test_stream_1.150.-1", representation.getCacheKey());
-  }
-
-}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java b/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java
deleted file mode 100644
index 50752c8a72..0000000000
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.dash.offline;
-
-import android.net.Uri;
-
-/**
- * Data for DASH downloading tests.
- */
-/* package */ interface DashDownloadTestData {
-
-  Uri TEST_MPD_URI = Uri.parse("test.mpd");
-
-  byte[] TEST_MPD =
-      ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
-          + "<MPD xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" type=\"static\" "
-          + "    mediaPresentationDuration=\"PT31S\">\n"
-          + "    <Period duration=\"PT16S\" >\n"
-          + "        <AdaptationSet>\n"
-          + "            <SegmentList>\n"
-          + "                <SegmentTimeline>\n"
-          + "                    <S d=\"5\" />\n"
-          + "                    <S d=\"5\" />\n"
-          + "                    <S d=\"5\" />\n"
-          + "                </SegmentTimeline>\n"
-          + "            </SegmentList>\n"
-          + "            <Representation>\n"
-          + "                <SegmentList>\n"
-          // Bounded range data
-          + "                    <Initialization range=\"0-9\" sourceURL=\"audio_init_data\" />\n"
-          // Unbounded range data
-          + "                    <SegmentURL media=\"audio_segment_1\" />\n"
-          + "                    <SegmentURL media=\"audio_segment_2\" />\n"
-          + "                    <SegmentURL media=\"audio_segment_3\" />\n"
-          + "                </SegmentList>\n"
-          + "            </Representation>\n"
-          + "        </AdaptationSet>\n"
-          + "        <AdaptationSet>\n"
-          // This segment list has a 1 second offset to make sure the progressive download order
-          + "            <SegmentList>\n"
-          + "                <SegmentTimeline>\n"
-          + "                    <S t=\"1\" d=\"5\" />\n" // 1s offset
-          + "                    <S d=\"5\" />\n"
-          + "                    <S d=\"5\" />\n"
-          + "                </SegmentTimeline>\n"
-          + "            </SegmentList>\n"
-          + "            <Representation>\n"
-          + "                <SegmentList>\n"
-          + "                    <SegmentURL media=\"text_segment_1\" />\n"
-          + "                    <SegmentURL media=\"text_segment_2\" />\n"
-          + "                    <SegmentURL media=\"text_segment_3\" />\n"
-          + "                </SegmentList>\n"
-          + "            </Representation>\n"
-          + "        </AdaptationSet>\n"
-          + "    </Period>\n"
-          + "    <Period>\n"
-          + "        <SegmentList>\n"
-          + "            <SegmentTimeline>\n"
-          + "                <S d=\"5\" />\n"
-          + "                <S d=\"5\" />\n"
-          + "                <S d=\"5\" />\n"
-          + "            </SegmentTimeline>\n"
-          + "        </SegmentList>\n"
-          + "        <AdaptationSet>\n"
-          + "            <Representation>\n"
-          + "                <SegmentList>\n"
-          + "                    <SegmentURL media=\"period_2_segment_1\" />\n"
-          + "                    <SegmentURL media=\"period_2_segment_2\" />\n"
-          + "                    <SegmentURL media=\"period_2_segment_3\" />\n"
-          + "                </SegmentList>\n"
-          + "            </Representation>\n"
-          + "        </AdaptationSet>\n"
-          + "    </Period>\n"
-          + "</MPD>").getBytes();
-
-  byte[] TEST_MPD_NO_INDEX =
-      ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
-          + "<MPD xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" type=\"dynamic\">\n"
-          + "    <Period start=\"PT6462826.784S\" >\n"
-          + "        <AdaptationSet>\n"
-          + "            <Representation>\n"
-          + "                <SegmentBase indexRange='0-10'/>\n"
-          + "            </Representation>\n"
-          + "        </AdaptationSet>\n"
-          + "    </Period>\n"
-          + "</MPD>").getBytes();
-}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
index 4e25c0e333..31c32e6100 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashChunkSource.java
@@ -15,7 +15,10 @@
  */
 package com.google.android.exoplayer2.source.dash;
 
+import android.os.SystemClock;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.source.chunk.ChunkSource;
+import com.google.android.exoplayer2.source.dash.PlayerEmsgHandler.PlayerTrackEmsgHandler;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
@@ -25,15 +28,41 @@
  */
 public interface DashChunkSource extends ChunkSource {
 
+  /** Factory for {@link DashChunkSource}s. */
   interface Factory {
 
-    DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
-        DashManifest manifest, int periodIndex, int[] adaptationSetIndices,
-        TrackSelection trackSelection, int type, long elapsedRealtimeOffsetMs,
-        boolean enableEventMessageTrack, boolean enableCea608Track);
-
+    /**
+     * @param manifestLoaderErrorThrower Throws errors affecting loading of manifests.
+     * @param manifest The initial manifest.
+     * @param periodIndex The index of the corresponding period in the manifest.
+     * @param adaptationSetIndices The indices of the corresponding adaptation sets in the period.
+     * @param trackSelection The track selection.
+     * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference between
+     *     server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds,
+     *     specified as the server's unix time minus the local elapsed time. If unknown, set to 0.
+     * @param enableEventMessageTrack Whether the chunks generated by the source may output an event
+     *     message track.
+     * @param enableCea608Track Whether the chunks generated by the source may output a CEA-608
+     *     track.
+     * @return The created {@link DashChunkSource}.
+     */
+    DashChunkSource createDashChunkSource(
+        LoaderErrorThrower manifestLoaderErrorThrower,
+        DashManifest manifest,
+        int periodIndex,
+        int[] adaptationSetIndices,
+        TrackSelection trackSelection,
+        int type,
+        long elapsedRealtimeOffsetMs,
+        boolean enableEventMessageTrack,
+        boolean enableCea608Track,
+        @Nullable PlayerTrackEmsgHandler playerEmsgHandler);
   }
 
+  /**
+   * Updates the manifest.
+   *
+   * @param newManifest The new manifest.
+   */
   void updateManifest(DashManifest newManifest, int periodIndex);
-
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashManifestStaleException.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashManifestStaleException.java
new file mode 100644
index 0000000000..7d946cb105
--- /dev/null
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashManifestStaleException.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash;
+
+import java.io.IOException;
+
+/** Thrown when a live playback's manifest is stale and a new manifest could not be loaded. */
+public final class DashManifestStaleException extends IOException {}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
index 35f3c2e129..00baf15228 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaPeriod.java
@@ -15,39 +15,48 @@
  */
 package com.google.android.exoplayer2.source.dash;
 
+import android.support.annotation.IntDef;
 import android.util.Pair;
+import android.util.SparseArray;
 import android.util.SparseIntArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
-import com.google.android.exoplayer2.source.CompositeSequenceableLoader;
+import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.EmptySampleStream;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.chunk.ChunkSampleStream;
 import com.google.android.exoplayer2.source.chunk.ChunkSampleStream.EmbeddedSampleStream;
+import com.google.android.exoplayer2.source.dash.PlayerEmsgHandler.PlayerEmsgCallback;
+import com.google.android.exoplayer2.source.dash.PlayerEmsgHandler.PlayerTrackEmsgHandler;
 import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.Descriptor;
+import com.google.android.exoplayer2.source.dash.manifest.EventStream;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
 import com.google.android.exoplayer2.source.dash.manifest.Representation;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
+import java.util.IdentityHashMap;
 import java.util.List;
 
-/**
- * A DASH {@link MediaPeriod}.
- */
-/* package */ final class DashMediaPeriod implements MediaPeriod,
-    SequenceableLoader.Callback<ChunkSampleStream<DashChunkSource>> {
+/** A DASH {@link MediaPeriod}. */
+/* package */ final class DashMediaPeriod
+    implements MediaPeriod,
+        SequenceableLoader.Callback<ChunkSampleStream<DashChunkSource>>,
+        ChunkSampleStream.ReleaseCallback<DashChunkSource> {
 
   /* package */ final int id;
   private final DashChunkSource.Factory chunkSourceFactory;
@@ -58,17 +67,31 @@
   private final Allocator allocator;
   private final TrackGroupArray trackGroups;
   private final TrackGroupInfo[] trackGroupInfos;
+  private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
+  private final PlayerEmsgHandler playerEmsgHandler;
+  private final IdentityHashMap<ChunkSampleStream<DashChunkSource>, PlayerTrackEmsgHandler>
+      trackEmsgHandlerBySampleStream;
 
   private Callback callback;
   private ChunkSampleStream<DashChunkSource>[] sampleStreams;
-  private CompositeSequenceableLoader sequenceableLoader;
+  private EventSampleStream[] eventSampleStreams;
+  private SequenceableLoader compositeSequenceableLoader;
   private DashManifest manifest;
   private int periodIndex;
-
-  public DashMediaPeriod(int id, DashManifest manifest, int periodIndex,
-      DashChunkSource.Factory chunkSourceFactory,  int minLoadableRetryCount,
-      EventDispatcher eventDispatcher, long elapsedRealtimeOffset,
-      LoaderErrorThrower manifestLoaderErrorThrower, Allocator allocator) {
+  private List<EventStream> eventStreams;
+
+  public DashMediaPeriod(
+      int id,
+      DashManifest manifest,
+      int periodIndex,
+      DashChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount,
+      EventDispatcher eventDispatcher,
+      long elapsedRealtimeOffset,
+      LoaderErrorThrower manifestLoaderErrorThrower,
+      Allocator allocator,
+      CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
+      PlayerEmsgCallback playerEmsgCallback) {
     this.id = id;
     this.manifest = manifest;
     this.periodIndex = periodIndex;
@@ -78,31 +101,67 @@ public DashMediaPeriod(int id, DashManifest manifest, int periodIndex,
     this.elapsedRealtimeOffset = elapsedRealtimeOffset;
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.allocator = allocator;
+    this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
+    playerEmsgHandler = new PlayerEmsgHandler(manifest, playerEmsgCallback, allocator);
     sampleStreams = newSampleStreamArray(0);
-    sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
-    Pair<TrackGroupArray, TrackGroupInfo[]> result =
-        buildTrackGroups(manifest.getPeriod(periodIndex).adaptationSets);
+    eventSampleStreams = new EventSampleStream[0];
+    trackEmsgHandlerBySampleStream = new IdentityHashMap<>();
+    compositeSequenceableLoader =
+        compositeSequenceableLoaderFactory.createCompositeSequenceableLoader(sampleStreams);
+    Period period = manifest.getPeriod(periodIndex);
+    eventStreams = period.eventStreams;
+    Pair<TrackGroupArray, TrackGroupInfo[]> result = buildTrackGroups(period.adaptationSets,
+        eventStreams);
     trackGroups = result.first;
     trackGroupInfos = result.second;
   }
 
+  /**
+   * Updates the {@link DashManifest} and the index of this period in the manifest.
+   *
+   * @param manifest The updated manifest.
+   * @param periodIndex the new index of this period in the updated manifest.
+   */
   public void updateManifest(DashManifest manifest, int periodIndex) {
     this.manifest = manifest;
     this.periodIndex = periodIndex;
+    playerEmsgHandler.updateManifest(manifest);
     if (sampleStreams != null) {
       for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {
         sampleStream.getChunkSource().updateManifest(manifest, periodIndex);
       }
       callback.onContinueLoadingRequested(this);
     }
+    eventStreams = manifest.getPeriod(periodIndex).eventStreams;
+    for (EventSampleStream eventSampleStream : eventSampleStreams) {
+      for (EventStream eventStream : eventStreams) {
+        if (eventStream.id().equals(eventSampleStream.eventStreamId())) {
+          eventSampleStream.updateEventStream(eventStream, manifest.dynamic);
+          break;
+        }
+      }
+    }
   }
 
   public void release() {
+    playerEmsgHandler.release();
     for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {
-      sampleStream.release();
+      sampleStream.release(this);
+    }
+  }
+
+  // ChunkSampleStream.ReleaseCallback implementation.
+
+  @Override
+  public synchronized void onSampleStreamReleased(ChunkSampleStream<DashChunkSource> stream) {
+    PlayerTrackEmsgHandler trackEmsgHandler = trackEmsgHandlerBySampleStream.remove(stream);
+    if (trackEmsgHandler != null) {
+      trackEmsgHandler.release();
     }
   }
 
+  // MediaPeriod implementation.
+
   @Override
   public void prepare(Callback callback, long positionUs) {
     this.callback = callback;
@@ -122,24 +181,51 @@ public TrackGroupArray getTrackGroups() {
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-    HashMap<Integer, ChunkSampleStream<DashChunkSource>> primarySampleStreams = new HashMap<>();
-    // First pass for primary tracks.
+    SparseArray<ChunkSampleStream<DashChunkSource>> primarySampleStreams = new SparseArray<>();
+    List<EventSampleStream> eventSampleStreamList = new ArrayList<>();
+
+    selectPrimarySampleStreams(selections, mayRetainStreamFlags, streams, streamResetFlags,
+        positionUs, primarySampleStreams);
+    selectEventSampleStreams(selections, mayRetainStreamFlags, streams,
+        streamResetFlags, eventSampleStreamList);
+    selectEmbeddedSampleStreams(selections, mayRetainStreamFlags, streams, streamResetFlags,
+        positionUs, primarySampleStreams);
+
+    sampleStreams = newSampleStreamArray(primarySampleStreams.size());
+    for (int i = 0; i < sampleStreams.length; i++) {
+      sampleStreams[i] = primarySampleStreams.valueAt(i);
+    }
+    eventSampleStreams = new EventSampleStream[eventSampleStreamList.size()];
+    eventSampleStreamList.toArray(eventSampleStreams);
+    compositeSequenceableLoader =
+        compositeSequenceableLoaderFactory.createCompositeSequenceableLoader(sampleStreams);
+    return positionUs;
+  }
+
+  private void selectPrimarySampleStreams(
+      TrackSelection[] selections,
+      boolean[] mayRetainStreamFlags,
+      SampleStream[] streams,
+      boolean[] streamResetFlags,
+      long positionUs,
+      SparseArray<ChunkSampleStream<DashChunkSource>> primarySampleStreams) {
     for (int i = 0; i < selections.length; i++) {
       if (streams[i] instanceof ChunkSampleStream) {
         @SuppressWarnings("unchecked")
         ChunkSampleStream<DashChunkSource> stream = (ChunkSampleStream<DashChunkSource>) streams[i];
         if (selections[i] == null || !mayRetainStreamFlags[i]) {
-          stream.release();
+          stream.release(this);
           streams[i] = null;
         } else {
           int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
           primarySampleStreams.put(trackGroupIndex, stream);
         }
       }
+
       if (streams[i] == null && selections[i] != null) {
         int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
         TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
-        if (trackGroupInfo.isPrimary) {
+        if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_PRIMARY) {
           ChunkSampleStream<DashChunkSource> stream = buildSampleStream(trackGroupInfo,
               selections[i], positionUs);
           primarySampleStreams.put(trackGroupIndex, stream);
@@ -148,7 +234,43 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
         }
       }
     }
-    // Second pass for embedded tracks.
+  }
+
+  private void selectEventSampleStreams(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
+      SampleStream[] streams, boolean[] streamResetFlags,
+      List<EventSampleStream> eventSampleStreamsList) {
+    for (int i = 0; i < selections.length; i++) {
+      if (streams[i] instanceof EventSampleStream) {
+        EventSampleStream stream = (EventSampleStream) streams[i];
+        if (selections[i] == null || !mayRetainStreamFlags[i]) {
+          streams[i] = null;
+        } else {
+          eventSampleStreamsList.add(stream);
+        }
+      }
+
+      if (streams[i] == null && selections[i] != null) {
+        int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
+        TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
+        if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_MANIFEST_EVENTS) {
+          EventStream eventStream = eventStreams.get(trackGroupInfo.eventStreamGroupIndex);
+          Format format = selections[i].getTrackGroup().getFormat(0);
+          EventSampleStream stream = new EventSampleStream(eventStream, format, manifest.dynamic);
+          streams[i] = stream;
+          streamResetFlags[i] = true;
+          eventSampleStreamsList.add(stream);
+        }
+      }
+    }
+  }
+
+  private void selectEmbeddedSampleStreams(
+      TrackSelection[] selections,
+      boolean[] mayRetainStreamFlags,
+      SampleStream[] streams,
+      boolean[] streamResetFlags,
+      long positionUs,
+      SparseArray<ChunkSampleStream<DashChunkSource>> primarySampleStreams) {
     for (int i = 0; i < selections.length; i++) {
       if ((streams[i] instanceof EmbeddedSampleStream || streams[i] instanceof EmptySampleStream)
           && (selections[i] == null || !mayRetainStreamFlags[i])) {
@@ -161,7 +283,7 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
       if (selections[i] != null) {
         int trackGroupIndex = trackGroups.indexOf(selections[i].getTrackGroup());
         TrackGroupInfo trackGroupInfo = trackGroupInfos[trackGroupIndex];
-        if (!trackGroupInfo.isPrimary) {
+        if (trackGroupInfo.trackGroupCategory == TrackGroupInfo.CATEGORY_EMBEDDED) {
           ChunkSampleStream<?> primaryStream = primarySampleStreams.get(
               trackGroupInfo.primaryTrackGroupIndex);
           SampleStream stream = streams[i];
@@ -177,27 +299,28 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
         }
       }
     }
-    sampleStreams = newSampleStreamArray(primarySampleStreams.size());
-    primarySampleStreams.values().toArray(sampleStreams);
-    sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
-    return positionUs;
   }
 
   @Override
-  public void discardBuffer(long positionUs) {
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
     for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {
-      sampleStream.discardEmbeddedTracksTo(positionUs);
+      sampleStream.discardBuffer(positionUs, toKeyframe);
     }
   }
 
+  @Override
+  public void reevaluateBuffer(long positionUs) {
+    compositeSequenceableLoader.reevaluateBuffer(positionUs);
+  }
+
   @Override
   public boolean continueLoading(long positionUs) {
-    return sequenceableLoader.continueLoading(positionUs);
+    return compositeSequenceableLoader.continueLoading(positionUs);
   }
 
   @Override
   public long getNextLoadPositionUs() {
-    return sequenceableLoader.getNextLoadPositionUs();
+    return compositeSequenceableLoader.getNextLoadPositionUs();
   }
 
   @Override
@@ -207,7 +330,7 @@ public long readDiscontinuity() {
 
   @Override
   public long getBufferedPositionUs() {
-    return sequenceableLoader.getBufferedPositionUs();
+    return compositeSequenceableLoader.getBufferedPositionUs();
   }
 
   @Override
@@ -215,6 +338,19 @@ public long seekToUs(long positionUs) {
     for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {
       sampleStream.seekToUs(positionUs);
     }
+    for (EventSampleStream sampleStream : eventSampleStreams) {
+      sampleStream.seekToUs(positionUs);
+    }
+    return positionUs;
+  }
+
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    for (ChunkSampleStream<DashChunkSource> sampleStream : sampleStreams) {
+      if (sampleStream.primaryTrackType == C.TRACK_TYPE_VIDEO) {
+        return sampleStream.getAdjustedSeekPositionUs(positionUs, seekParameters);
+      }
+    }
     return positionUs;
   }
 
@@ -228,62 +364,25 @@ public void onContinueLoadingRequested(ChunkSampleStream<DashChunkSource> sample
   // Internal methods.
 
   private static Pair<TrackGroupArray, TrackGroupInfo[]> buildTrackGroups(
-      List<AdaptationSet> adaptationSets) {
+      List<AdaptationSet> adaptationSets, List<EventStream> eventStreams) {
     int[][] groupedAdaptationSetIndices = getGroupedAdaptationSetIndices(adaptationSets);
 
     int primaryGroupCount = groupedAdaptationSetIndices.length;
     boolean[] primaryGroupHasEventMessageTrackFlags = new boolean[primaryGroupCount];
     boolean[] primaryGroupHasCea608TrackFlags = new boolean[primaryGroupCount];
-    int totalGroupCount = primaryGroupCount;
-    for (int i = 0; i < primaryGroupCount; i++) {
-      if (hasEventMessageTrack(adaptationSets, groupedAdaptationSetIndices[i])) {
-        primaryGroupHasEventMessageTrackFlags[i] = true;
-        totalGroupCount++;
-      }
-      if (hasCea608Track(adaptationSets, groupedAdaptationSetIndices[i])) {
-        primaryGroupHasCea608TrackFlags[i] = true;
-        totalGroupCount++;
-      }
-    }
+    int totalEmbeddedTrackGroupCount = identifyEmbeddedTracks(primaryGroupCount, adaptationSets,
+        groupedAdaptationSetIndices, primaryGroupHasEventMessageTrackFlags,
+        primaryGroupHasCea608TrackFlags);
 
+    int totalGroupCount = primaryGroupCount + totalEmbeddedTrackGroupCount + eventStreams.size();
     TrackGroup[] trackGroups = new TrackGroup[totalGroupCount];
     TrackGroupInfo[] trackGroupInfos = new TrackGroupInfo[totalGroupCount];
 
-    int trackGroupCount = 0;
-    for (int i = 0; i < primaryGroupCount; i++) {
-      int[] adaptationSetIndices = groupedAdaptationSetIndices[i];
-      List<Representation> representations = new ArrayList<>();
-      for (int adaptationSetIndex : adaptationSetIndices) {
-        representations.addAll(adaptationSets.get(adaptationSetIndex).representations);
-      }
-      Format[] formats = new Format[representations.size()];
-      for (int j = 0; j < formats.length; j++) {
-        formats[j] = representations.get(j).format;
-      }
+    int trackGroupCount = buildPrimaryAndEmbeddedTrackGroupInfos(adaptationSets,
+        groupedAdaptationSetIndices, primaryGroupCount, primaryGroupHasEventMessageTrackFlags,
+        primaryGroupHasCea608TrackFlags, trackGroups, trackGroupInfos);
 
-      AdaptationSet firstAdaptationSet = adaptationSets.get(adaptationSetIndices[0]);
-      int primaryTrackGroupIndex = trackGroupCount;
-      boolean hasEventMessageTrack = primaryGroupHasEventMessageTrackFlags[i];
-      boolean hasCea608Track = primaryGroupHasCea608TrackFlags[i];
-
-      trackGroups[trackGroupCount] = new TrackGroup(formats);
-      trackGroupInfos[trackGroupCount++] = new TrackGroupInfo(firstAdaptationSet.type,
-          adaptationSetIndices, primaryTrackGroupIndex, true, hasEventMessageTrack, hasCea608Track);
-      if (hasEventMessageTrack) {
-        Format format = Format.createSampleFormat(firstAdaptationSet.id + ":emsg",
-            MimeTypes.APPLICATION_EMSG, null, Format.NO_VALUE, null);
-        trackGroups[trackGroupCount] = new TrackGroup(format);
-        trackGroupInfos[trackGroupCount++] = new TrackGroupInfo(C.TRACK_TYPE_METADATA,
-            adaptationSetIndices, primaryTrackGroupIndex, false, false, false);
-      }
-      if (hasCea608Track) {
-        Format format = Format.createTextSampleFormat(firstAdaptationSet.id + ":cea608",
-            MimeTypes.APPLICATION_CEA608, 0, null);
-        trackGroups[trackGroupCount] = new TrackGroup(format);
-        trackGroupInfos[trackGroupCount++] = new TrackGroupInfo(C.TRACK_TYPE_TEXT,
-            adaptationSetIndices, primaryTrackGroupIndex, false, false, false);
-      }
-    }
+    buildManifestEventTrackGroupInfos(eventStreams, trackGroups, trackGroupInfos, trackGroupCount);
 
     return Pair.create(new TrackGroupArray(trackGroups), trackGroupInfos);
   }
@@ -326,28 +425,150 @@ public void onContinueLoadingRequested(ChunkSampleStream<DashChunkSource> sample
         ? Arrays.copyOf(groupedAdaptationSetIndices, groupCount) : groupedAdaptationSetIndices;
   }
 
+  /**
+   * Iterates through list of primary track groups and identifies embedded tracks.
+   * <p>
+   * @param primaryGroupCount The number of primary track groups.
+   * @param adaptationSets The list of {@link AdaptationSet} of the current DASH period.
+   * @param groupedAdaptationSetIndices The indices of {@link AdaptationSet} that belongs to
+   *     the same primary group, grouped in primary track groups order.
+   * @param primaryGroupHasEventMessageTrackFlags An output array containing boolean flag, each
+   *     indicates whether the corresponding primary track group contains an embedded event message
+   *     track.
+   * @param primaryGroupHasCea608TrackFlags An output array containing boolean flag, each
+   *     indicates whether the corresponding primary track group contains an embedded Cea608 track.
+   * @return Total number of embedded tracks.
+   */
+  private static int identifyEmbeddedTracks(int primaryGroupCount,
+      List<AdaptationSet> adaptationSets, int[][] groupedAdaptationSetIndices,
+      boolean[] primaryGroupHasEventMessageTrackFlags, boolean[] primaryGroupHasCea608TrackFlags) {
+    int numEmbeddedTrack = 0;
+    for (int i = 0; i < primaryGroupCount; i++) {
+      if (hasEventMessageTrack(adaptationSets, groupedAdaptationSetIndices[i])) {
+        primaryGroupHasEventMessageTrackFlags[i] = true;
+        numEmbeddedTrack++;
+      }
+      if (hasCea608Track(adaptationSets, groupedAdaptationSetIndices[i])) {
+        primaryGroupHasCea608TrackFlags[i] = true;
+        numEmbeddedTrack++;
+      }
+    }
+    return numEmbeddedTrack;
+  }
+
+  private static int buildPrimaryAndEmbeddedTrackGroupInfos(List<AdaptationSet> adaptationSets,
+      int[][] groupedAdaptationSetIndices, int primaryGroupCount,
+      boolean[] primaryGroupHasEventMessageTrackFlags, boolean[] primaryGroupHasCea608TrackFlags,
+      TrackGroup[] trackGroups, TrackGroupInfo[] trackGroupInfos) {
+    int trackGroupCount = 0;
+    for (int i = 0; i < primaryGroupCount; i++) {
+      int[] adaptationSetIndices = groupedAdaptationSetIndices[i];
+      List<Representation> representations = new ArrayList<>();
+      for (int adaptationSetIndex : adaptationSetIndices) {
+        representations.addAll(adaptationSets.get(adaptationSetIndex).representations);
+      }
+      Format[] formats = new Format[representations.size()];
+      for (int j = 0; j < formats.length; j++) {
+        formats[j] = representations.get(j).format;
+      }
+
+      AdaptationSet firstAdaptationSet = adaptationSets.get(adaptationSetIndices[0]);
+      int primaryTrackGroupIndex = trackGroupCount++;
+      int eventMessageTrackGroupIndex =
+          primaryGroupHasEventMessageTrackFlags[i] ? trackGroupCount++ : C.INDEX_UNSET;
+      int cea608TrackGroupIndex =
+          primaryGroupHasCea608TrackFlags[i] ? trackGroupCount++ : C.INDEX_UNSET;
+
+      trackGroups[primaryTrackGroupIndex] = new TrackGroup(formats);
+      trackGroupInfos[primaryTrackGroupIndex] =
+          TrackGroupInfo.primaryTrack(
+              firstAdaptationSet.type,
+              adaptationSetIndices,
+              primaryTrackGroupIndex,
+              eventMessageTrackGroupIndex,
+              cea608TrackGroupIndex);
+      if (eventMessageTrackGroupIndex != C.INDEX_UNSET) {
+        Format format = Format.createSampleFormat(firstAdaptationSet.id + ":emsg",
+            MimeTypes.APPLICATION_EMSG, null, Format.NO_VALUE, null);
+        trackGroups[eventMessageTrackGroupIndex] = new TrackGroup(format);
+        trackGroupInfos[eventMessageTrackGroupIndex] =
+            TrackGroupInfo.embeddedEmsgTrack(adaptationSetIndices, primaryTrackGroupIndex);
+      }
+      if (cea608TrackGroupIndex != C.INDEX_UNSET) {
+        Format format = Format.createTextSampleFormat(firstAdaptationSet.id + ":cea608",
+            MimeTypes.APPLICATION_CEA608, 0, null);
+        trackGroups[cea608TrackGroupIndex] = new TrackGroup(format);
+        trackGroupInfos[cea608TrackGroupIndex] =
+            TrackGroupInfo.embeddedCea608Track(adaptationSetIndices, primaryTrackGroupIndex);
+      }
+    }
+    return trackGroupCount;
+  }
+
+  private static void buildManifestEventTrackGroupInfos(List<EventStream> eventStreams,
+      TrackGroup[] trackGroups, TrackGroupInfo[] trackGroupInfos, int existingTrackGroupCount) {
+    for (int i = 0; i < eventStreams.size(); i++) {
+      EventStream eventStream = eventStreams.get(i);
+      Format format = Format.createSampleFormat(eventStream.id(), MimeTypes.APPLICATION_EMSG, null,
+          Format.NO_VALUE, null);
+      trackGroups[existingTrackGroupCount] = new TrackGroup(format);
+      trackGroupInfos[existingTrackGroupCount++] = TrackGroupInfo.mpdEventTrack(i);
+    }
+  }
+
   private ChunkSampleStream<DashChunkSource> buildSampleStream(TrackGroupInfo trackGroupInfo,
       TrackSelection selection, long positionUs) {
     int embeddedTrackCount = 0;
     int[] embeddedTrackTypes = new int[2];
-    boolean enableEventMessageTrack = trackGroupInfo.hasEmbeddedEventMessageTrack;
+    Format[] embeddedTrackFormats = new Format[2];
+    boolean enableEventMessageTrack =
+        trackGroupInfo.embeddedEventMessageTrackGroupIndex != C.INDEX_UNSET;
     if (enableEventMessageTrack) {
+      embeddedTrackFormats[embeddedTrackCount] =
+          trackGroups.get(trackGroupInfo.embeddedEventMessageTrackGroupIndex).getFormat(0);
       embeddedTrackTypes[embeddedTrackCount++] = C.TRACK_TYPE_METADATA;
     }
-    boolean enableCea608Track = trackGroupInfo.hasEmbeddedCea608Track;
+    boolean enableCea608Track = trackGroupInfo.embeddedCea608TrackGroupIndex != C.INDEX_UNSET;
     if (enableCea608Track) {
+      embeddedTrackFormats[embeddedTrackCount] =
+          trackGroups.get(trackGroupInfo.embeddedCea608TrackGroupIndex).getFormat(0);
       embeddedTrackTypes[embeddedTrackCount++] = C.TRACK_TYPE_TEXT;
     }
     if (embeddedTrackCount < embeddedTrackTypes.length) {
+      embeddedTrackFormats = Arrays.copyOf(embeddedTrackFormats, embeddedTrackCount);
       embeddedTrackTypes = Arrays.copyOf(embeddedTrackTypes, embeddedTrackCount);
     }
-    DashChunkSource chunkSource = chunkSourceFactory.createDashChunkSource(
-        manifestLoaderErrorThrower, manifest, periodIndex, trackGroupInfo.adaptationSetIndices,
-        selection, trackGroupInfo.trackType, elapsedRealtimeOffset, enableEventMessageTrack,
-        enableCea608Track);
-    ChunkSampleStream<DashChunkSource> stream = new ChunkSampleStream<>(trackGroupInfo.trackType,
-        embeddedTrackTypes, chunkSource, this, allocator, positionUs, minLoadableRetryCount,
-        eventDispatcher);
+    PlayerTrackEmsgHandler trackPlayerEmsgHandler =
+        manifest.dynamic && enableEventMessageTrack
+            ? playerEmsgHandler.newPlayerTrackEmsgHandler()
+            : null;
+    DashChunkSource chunkSource =
+        chunkSourceFactory.createDashChunkSource(
+            manifestLoaderErrorThrower,
+            manifest,
+            periodIndex,
+            trackGroupInfo.adaptationSetIndices,
+            selection,
+            trackGroupInfo.trackType,
+            elapsedRealtimeOffset,
+            enableEventMessageTrack,
+            enableCea608Track,
+            trackPlayerEmsgHandler);
+    ChunkSampleStream<DashChunkSource> stream =
+        new ChunkSampleStream<>(
+            trackGroupInfo.trackType,
+            embeddedTrackTypes,
+            embeddedTrackFormats,
+            chunkSource,
+            this,
+            allocator,
+            positionUs,
+            minLoadableRetryCount,
+            eventDispatcher);
+    synchronized (this) {
+      // The map is also accessed on the loading thread so synchronize access.
+      trackEmsgHandlerBySampleStream.put(stream, trackPlayerEmsgHandler);
+    }
     return stream;
   }
 
@@ -402,24 +623,105 @@ private static void releaseIfEmbeddedSampleStream(SampleStream sampleStream) {
 
   private static final class TrackGroupInfo {
 
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({CATEGORY_PRIMARY, CATEGORY_EMBEDDED, CATEGORY_MANIFEST_EVENTS})
+    public @interface TrackGroupCategory {}
+
+    /**
+     * A normal track group that has its samples drawn from the stream.
+     * For example: a video Track Group or an audio Track Group.
+     */
+    private static final int CATEGORY_PRIMARY = 0;
+
+    /**
+     * A track group whose samples are embedded within one of the primary streams. For example: an
+     * EMSG track has its sample embedded in emsg atoms in one of the primary streams.
+     */
+    private static final int CATEGORY_EMBEDDED = 1;
+
+    /**
+     * A track group that has its samples listed explicitly in the DASH manifest file.
+     * For example: an EventStream track has its sample (Events) included directly in the DASH
+     * manifest file.
+     */
+    private static final int CATEGORY_MANIFEST_EVENTS = 2;
+
     public final int[] adaptationSetIndices;
     public final int trackType;
-    public final boolean isPrimary;
+    public @TrackGroupCategory final int trackGroupCategory;
 
+    public final int eventStreamGroupIndex;
     public final int primaryTrackGroupIndex;
-    public final boolean hasEmbeddedEventMessageTrack;
-    public final boolean hasEmbeddedCea608Track;
+    public final int embeddedEventMessageTrackGroupIndex;
+    public final int embeddedCea608TrackGroupIndex;
+
+    public static TrackGroupInfo primaryTrack(
+        int trackType,
+        int[] adaptationSetIndices,
+        int primaryTrackGroupIndex,
+        int embeddedEventMessageTrackGroupIndex,
+        int embeddedCea608TrackGroupIndex) {
+      return new TrackGroupInfo(
+          trackType,
+          CATEGORY_PRIMARY,
+          adaptationSetIndices,
+          primaryTrackGroupIndex,
+          embeddedEventMessageTrackGroupIndex,
+          embeddedCea608TrackGroupIndex,
+          -1);
+    }
 
-    public TrackGroupInfo(int trackType, int[] adaptationSetIndices, int primaryTrackGroupIndex,
-        boolean isPrimary, boolean hasEmbeddedEventMessageTrack, boolean hasEmbeddedCea608Track) {
+    public static TrackGroupInfo embeddedEmsgTrack(int[] adaptationSetIndices,
+        int primaryTrackGroupIndex) {
+      return new TrackGroupInfo(
+          C.TRACK_TYPE_METADATA,
+          CATEGORY_EMBEDDED,
+          adaptationSetIndices,
+          primaryTrackGroupIndex,
+          C.INDEX_UNSET,
+          C.INDEX_UNSET,
+          -1);
+    }
+
+    public static TrackGroupInfo embeddedCea608Track(int[] adaptationSetIndices,
+        int primaryTrackGroupIndex) {
+      return new TrackGroupInfo(
+          C.TRACK_TYPE_TEXT,
+          CATEGORY_EMBEDDED,
+          adaptationSetIndices,
+          primaryTrackGroupIndex,
+          C.INDEX_UNSET,
+          C.INDEX_UNSET,
+          -1);
+    }
+
+    public static TrackGroupInfo mpdEventTrack(int eventStreamIndex) {
+      return new TrackGroupInfo(
+          C.TRACK_TYPE_METADATA,
+          CATEGORY_MANIFEST_EVENTS,
+          null,
+          -1,
+          C.INDEX_UNSET,
+          C.INDEX_UNSET,
+          eventStreamIndex);
+    }
+
+    private TrackGroupInfo(
+        int trackType,
+        @TrackGroupCategory int trackGroupCategory,
+        int[] adaptationSetIndices,
+        int primaryTrackGroupIndex,
+        int embeddedEventMessageTrackGroupIndex,
+        int embeddedCea608TrackGroupIndex,
+        int eventStreamGroupIndex) {
       this.trackType = trackType;
       this.adaptationSetIndices = adaptationSetIndices;
+      this.trackGroupCategory = trackGroupCategory;
       this.primaryTrackGroupIndex = primaryTrackGroupIndex;
-      this.isPrimary = isPrimary;
-      this.hasEmbeddedEventMessageTrack = hasEmbeddedEventMessageTrack;
-      this.hasEmbeddedCea608Track = hasEmbeddedCea608Track;
+      this.embeddedEventMessageTrackGroupIndex = embeddedEventMessageTrackGroupIndex;
+      this.embeddedCea608TrackGroupIndex = embeddedCea608TrackGroupIndex;
+      this.eventStreamGroupIndex = eventStreamGroupIndex;
     }
-
   }
 
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
index c529fcab4b..98783ac93e 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashMediaSource.java
@@ -18,6 +18,8 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.Log;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.C;
@@ -25,10 +27,15 @@
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
+import com.google.android.exoplayer2.source.DefaultCompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSourceEventListener;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.SequenceableLoader;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
+import com.google.android.exoplayer2.source.dash.PlayerEmsgHandler.PlayerEmsgCallback;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifestParser;
 import com.google.android.exoplayer2.source.dash.manifest.UtcTimingElement;
@@ -43,27 +50,200 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.nio.charset.Charset;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Locale;
 import java.util.TimeZone;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
-/**
- * A DASH {@link MediaSource}.
- */
+/** A DASH {@link MediaSource}. */
 public final class DashMediaSource implements MediaSource {
 
   static {
     ExoPlayerLibraryInfo.registerModule("goog.exo.dash");
   }
 
+  /** Factory for {@link DashMediaSource}s. */
+  public static final class Factory implements AdsMediaSource.MediaSourceFactory {
+
+    private final DashChunkSource.Factory chunkSourceFactory;
+    private final @Nullable DataSource.Factory manifestDataSourceFactory;
+
+    private @Nullable ParsingLoadable.Parser<? extends DashManifest> manifestParser;
+    private CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
+    private int minLoadableRetryCount;
+    private long livePresentationDelayMs;
+    private boolean isCreateCalled;
+
+    /**
+     * Creates a new factory for {@link DashMediaSource}s.
+     *
+     * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
+     * @param manifestDataSourceFactory A factory for {@link DataSource} instances that will be used
+     *     to load (and refresh) the manifest. May be {@code null} if the factory will only ever be
+     *     used to create create media sources with sideloaded manifests via {@link
+     *     #createMediaSource(DashManifest, Handler, MediaSourceEventListener)}.
+     */
+    public Factory(
+        DashChunkSource.Factory chunkSourceFactory,
+        @Nullable DataSource.Factory manifestDataSourceFactory) {
+      this.chunkSourceFactory = Assertions.checkNotNull(chunkSourceFactory);
+      this.manifestDataSourceFactory = manifestDataSourceFactory;
+      minLoadableRetryCount = DEFAULT_MIN_LOADABLE_RETRY_COUNT;
+      livePresentationDelayMs = DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS;
+      compositeSequenceableLoaderFactory = new DefaultCompositeSequenceableLoaderFactory();
+    }
+
+    /**
+     * Sets the minimum number of times to retry if a loading error occurs. The default value is
+     * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+     *
+     * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
+      Assertions.checkState(!isCreateCalled);
+      this.minLoadableRetryCount = minLoadableRetryCount;
+      return this;
+    }
+
+    /**
+     * Sets the duration in milliseconds by which the default start position should precede the end
+     * of the live window for live playbacks. The default value is {@link
+     * #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS}.
+     *
+     * @param livePresentationDelayMs For live playbacks, the duration in milliseconds by which the
+     *     default start position should precede the end of the live window. Use {@link
+     *     #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS} to use the value specified by the
+     *     manifest, if present.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setLivePresentationDelayMs(long livePresentationDelayMs) {
+      Assertions.checkState(!isCreateCalled);
+      this.livePresentationDelayMs = livePresentationDelayMs;
+      return this;
+    }
+
+    /**
+     * Sets the manifest parser to parse loaded manifest data when loading a manifest URI.
+     *
+     * @param manifestParser A parser for loaded manifest data.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setManifestParser(
+        ParsingLoadable.Parser<? extends DashManifest> manifestParser) {
+      Assertions.checkState(!isCreateCalled);
+      this.manifestParser = Assertions.checkNotNull(manifestParser);
+      return this;
+    }
+
+    /**
+     * Sets the factory to create composite {@link SequenceableLoader}s for when this media source
+     * loads data from multiple streams (video, audio etc...). The default is an instance of {@link
+     * DefaultCompositeSequenceableLoaderFactory}.
+     *
+     * @param compositeSequenceableLoaderFactory A factory to create composite {@link
+     *     SequenceableLoader}s for when this media source loads data from multiple streams (video,
+     *     audio etc...).
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setCompositeSequenceableLoaderFactory(
+        CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory) {
+      Assertions.checkState(!isCreateCalled);
+      this.compositeSequenceableLoaderFactory =
+          Assertions.checkNotNull(compositeSequenceableLoaderFactory);
+      return this;
+    }
+
+    /**
+     * Returns a new {@link DashMediaSource} using the current parameters and the specified
+     * sideloaded manifest.
+     *
+     * @param manifest The manifest. {@link DashManifest#dynamic} must be false.
+     * @param eventHandler A handler for events.
+     * @param eventListener A listener of events.
+     * @return The new {@link DashMediaSource}.
+     * @throws IllegalArgumentException If {@link DashManifest#dynamic} is true.
+     */
+    public DashMediaSource createMediaSource(
+        DashManifest manifest,
+        @Nullable Handler eventHandler,
+        @Nullable MediaSourceEventListener eventListener) {
+      Assertions.checkArgument(!manifest.dynamic);
+      isCreateCalled = true;
+      return new DashMediaSource(
+          manifest,
+          null,
+          null,
+          null,
+          chunkSourceFactory,
+          compositeSequenceableLoaderFactory,
+          minLoadableRetryCount,
+          livePresentationDelayMs,
+          eventHandler,
+          eventListener);
+    }
+
+    /**
+     * Returns a new {@link DashMediaSource} using the current parameters. Media source events will
+     * not be delivered.
+     *
+     * @param manifestUri The manifest {@link Uri}.
+     * @return The new {@link DashMediaSource}.
+     */
+    public DashMediaSource createMediaSource(Uri manifestUri) {
+      return createMediaSource(manifestUri, null, null);
+    }
+
+    /**
+     * Returns a new {@link DashMediaSource} using the current parameters.
+     *
+     * @param manifestUri The manifest {@link Uri}.
+     * @param eventHandler A handler for events.
+     * @param eventListener A listener of events.
+     * @return The new {@link DashMediaSource}.
+     */
+    @Override
+    public DashMediaSource createMediaSource(
+        Uri manifestUri,
+        @Nullable Handler eventHandler,
+        @Nullable MediaSourceEventListener eventListener) {
+      isCreateCalled = true;
+      if (manifestParser == null) {
+        manifestParser = new DashManifestParser();
+      }
+      return new DashMediaSource(
+          null,
+          Assertions.checkNotNull(manifestUri),
+          manifestDataSourceFactory,
+          manifestParser,
+          chunkSourceFactory,
+          compositeSequenceableLoaderFactory,
+          minLoadableRetryCount,
+          livePresentationDelayMs,
+          eventHandler,
+          eventListener);
+    }
+
+    @Override
+    public int[] getSupportedTypes() {
+      return new int[] {C.TYPE_DASH};
+    }
+  }
+
   /**
    * The default minimum number of times to retry loading data prior to failing.
    */
   public static final int DEFAULT_MIN_LOADABLE_RETRY_COUNT = 3;
   /**
    * A constant indicating that the presentation delay for live streams should be set to
-   * {@link DashManifest#suggestedPresentationDelay} if specified by the manifest, or
+   * {@link DashManifest#suggestedPresentationDelayMs} if specified by the manifest, or
    * {@link #DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS} otherwise. The presentation delay is the
    * duration by which the default start position precedes the end of the live window.
    */
@@ -90,6 +270,7 @@
   private final boolean sideloadedManifest;
   private final DataSource.Factory manifestDataSourceFactory;
   private final DashChunkSource.Factory chunkSourceFactory;
+  private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
   private final int minLoadableRetryCount;
   private final long livePresentationDelayMs;
   private final EventDispatcher eventDispatcher;
@@ -99,19 +280,28 @@
   private final SparseArray<DashMediaPeriod> periodsById;
   private final Runnable refreshManifestRunnable;
   private final Runnable simulateManifestRefreshRunnable;
+  private final PlayerEmsgCallback playerEmsgCallback;
+  private final LoaderErrorThrower manifestLoadErrorThrower;
 
   private Listener sourceListener;
   private DataSource dataSource;
   private Loader loader;
-  private LoaderErrorThrower loaderErrorThrower;
 
+  private IOException manifestFatalError;
+  private Handler handler;
+
+  private Uri initialManifestUri;
   private Uri manifestUri;
-  private long manifestLoadStartTimestamp;
-  private long manifestLoadEndTimestamp;
   private DashManifest manifest;
-  private Handler handler;
+  private boolean manifestLoadPending;
+  private long manifestLoadStartTimestampMs;
+  private long manifestLoadEndTimestampMs;
   private long elapsedRealtimeOffsetMs;
 
+  private int staleManifestReloadAttempt;
+  private long expiredManifestPublishTimeUs;
+  private boolean dynamicMediaPresentationEnded;
+
   private int firstPeriodId;
 
   /**
@@ -121,9 +311,14 @@
    * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public DashMediaSource(DashManifest manifest, DashChunkSource.Factory chunkSourceFactory,
-      Handler eventHandler, AdaptiveMediaSourceEventListener eventListener) {
+  @Deprecated
+  public DashMediaSource(
+      DashManifest manifest,
+      DashChunkSource.Factory chunkSourceFactory,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(manifest, chunkSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT, eventHandler,
         eventListener);
   }
@@ -136,11 +331,17 @@ public DashMediaSource(DashManifest manifest, DashChunkSource.Factory chunkSourc
    * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public DashMediaSource(DashManifest manifest, DashChunkSource.Factory chunkSourceFactory,
-      int minLoadableRetryCount, Handler eventHandler, AdaptiveMediaSourceEventListener
-      eventListener) {
-    this(manifest, null, null, null, chunkSourceFactory, minLoadableRetryCount,
+  @Deprecated
+  public DashMediaSource(
+      DashManifest manifest,
+      DashChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
+    this(manifest, null, null, null, chunkSourceFactory,
+        new DefaultCompositeSequenceableLoaderFactory(), minLoadableRetryCount,
         DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS, eventHandler, eventListener);
   }
 
@@ -154,10 +355,15 @@ public DashMediaSource(DashManifest manifest, DashChunkSource.Factory chunkSourc
    * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public DashMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
-      DashChunkSource.Factory chunkSourceFactory, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+  @Deprecated
+  public DashMediaSource(
+      Uri manifestUri,
+      DataSource.Factory manifestDataSourceFactory,
+      DashChunkSource.Factory chunkSourceFactory,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(manifestUri, manifestDataSourceFactory, chunkSourceFactory,
         DEFAULT_MIN_LOADABLE_RETRY_COUNT, DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS,
         eventHandler, eventListener);
@@ -173,16 +379,22 @@ public DashMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFac
    * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
    * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
    * @param livePresentationDelayMs For live playbacks, the duration in milliseconds by which the
-   *     default start position should precede the end of the live window. Use
-   *     {@link #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS} to use the value specified by
-   *     the manifest, if present.
+   *     default start position should precede the end of the live window. Use {@link
+   *     #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS} to use the value specified by the
+   *     manifest, if present.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public DashMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
-      DashChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
-      long livePresentationDelayMs, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+  @Deprecated
+  public DashMediaSource(
+      Uri manifestUri,
+      DataSource.Factory manifestDataSourceFactory,
+      DashChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount,
+      long livePresentationDelayMs,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(manifestUri, manifestDataSourceFactory, new DashManifestParser(), chunkSourceFactory,
         minLoadableRetryCount, livePresentationDelayMs, eventHandler, eventListener);
   }
@@ -198,27 +410,40 @@ public DashMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFac
    * @param chunkSourceFactory A factory for {@link DashChunkSource} instances.
    * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
    * @param livePresentationDelayMs For live playbacks, the duration in milliseconds by which the
-   *     default start position should precede the end of the live window. Use
-   *     {@link #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS} to use the value specified by
-   *     the manifest, if present.
+   *     default start position should precede the end of the live window. Use {@link
+   *     #DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS} to use the value specified by the
+   *     manifest, if present.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public DashMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
+  @Deprecated
+  public DashMediaSource(
+      Uri manifestUri,
+      DataSource.Factory manifestDataSourceFactory,
       ParsingLoadable.Parser<? extends DashManifest> manifestParser,
-      DashChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
-      long livePresentationDelayMs, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+      DashChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount,
+      long livePresentationDelayMs,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(null, manifestUri, manifestDataSourceFactory, manifestParser, chunkSourceFactory,
-        minLoadableRetryCount, livePresentationDelayMs, eventHandler, eventListener);
+        new DefaultCompositeSequenceableLoaderFactory(), minLoadableRetryCount,
+        livePresentationDelayMs, eventHandler, eventListener);
   }
 
-  private DashMediaSource(DashManifest manifest, Uri manifestUri,
+  private DashMediaSource(
+      DashManifest manifest,
+      Uri manifestUri,
       DataSource.Factory manifestDataSourceFactory,
       ParsingLoadable.Parser<? extends DashManifest> manifestParser,
-      DashChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
-      long livePresentationDelayMs, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+      DashChunkSource.Factory chunkSourceFactory,
+      CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
+      int minLoadableRetryCount,
+      long livePresentationDelayMs,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
+    this.initialManifestUri = manifestUri;
     this.manifest = manifest;
     this.manifestUri = manifestUri;
     this.manifestDataSourceFactory = manifestDataSourceFactory;
@@ -226,17 +451,22 @@ private DashMediaSource(DashManifest manifest, Uri manifestUri,
     this.chunkSourceFactory = chunkSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.livePresentationDelayMs = livePresentationDelayMs;
+    this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
     sideloadedManifest = manifest != null;
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     manifestUriLock = new Object();
     periodsById = new SparseArray<>();
+    playerEmsgCallback = new DefaultPlayerEmsgCallback();
+    expiredManifestPublishTimeUs = C.TIME_UNSET;
     if (sideloadedManifest) {
       Assertions.checkState(!manifest.dynamic);
       manifestCallback = null;
       refreshManifestRunnable = null;
       simulateManifestRefreshRunnable = null;
+      manifestLoadErrorThrower = new LoaderErrorThrower.Dummy();
     } else {
       manifestCallback = new ManifestCallback();
+      manifestLoadErrorThrower = new ManifestLoadErrorThrower();
       refreshManifestRunnable = new Runnable() {
         @Override
         public void run() {
@@ -260,6 +490,7 @@ public void run() {
   public void replaceManifestUri(Uri manifestUri) {
     synchronized (manifestUriLock) {
       this.manifestUri = manifestUri;
+      this.initialManifestUri = manifestUri;
     }
   }
 
@@ -269,12 +500,10 @@ public void replaceManifestUri(Uri manifestUri) {
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     sourceListener = listener;
     if (sideloadedManifest) {
-      loaderErrorThrower = new LoaderErrorThrower.Dummy();
       processManifest(false);
     } else {
       dataSource = manifestDataSourceFactory.createDataSource();
       loader = new Loader("Loader:DashMediaSource");
-      loaderErrorThrower = loader;
       handler = new Handler();
       startLoadingManifest();
     }
@@ -282,7 +511,7 @@ public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener l
 
   @Override
   public void maybeThrowSourceInfoRefreshError() throws IOException {
-    loaderErrorThrower.maybeThrowError();
+    manifestLoadErrorThrower.maybeThrowError();
   }
 
   @Override
@@ -290,9 +519,19 @@ public MediaPeriod createPeriod(MediaPeriodId periodId, Allocator allocator) {
     int periodIndex = periodId.periodIndex;
     EventDispatcher periodEventDispatcher = eventDispatcher.copyWithMediaTimeOffsetMs(
         manifest.getPeriod(periodIndex).startMs);
-    DashMediaPeriod mediaPeriod = new DashMediaPeriod(firstPeriodId + periodIndex, manifest,
-        periodIndex, chunkSourceFactory, minLoadableRetryCount, periodEventDispatcher,
-        elapsedRealtimeOffsetMs, loaderErrorThrower, allocator);
+    DashMediaPeriod mediaPeriod =
+        new DashMediaPeriod(
+            firstPeriodId + periodIndex,
+            manifest,
+            periodIndex,
+            chunkSourceFactory,
+            minLoadableRetryCount,
+            periodEventDispatcher,
+            elapsedRealtimeOffsetMs,
+            manifestLoadErrorThrower,
+            allocator,
+            compositeSequenceableLoaderFactory,
+            playerEmsgCallback);
     periodsById.put(mediaPeriod.id, mediaPeriod);
     return mediaPeriod;
   }
@@ -306,23 +545,47 @@ public void releasePeriod(MediaPeriod mediaPeriod) {
 
   @Override
   public void releaseSource() {
+    manifestLoadPending = false;
     dataSource = null;
-    loaderErrorThrower = null;
     if (loader != null) {
       loader.release();
       loader = null;
     }
-    manifestLoadStartTimestamp = 0;
-    manifestLoadEndTimestamp = 0;
-    manifest = null;
+    manifestLoadStartTimestampMs = 0;
+    manifestLoadEndTimestampMs = 0;
+    manifest = sideloadedManifest ? manifest : null;
+    manifestUri = initialManifestUri;
+    manifestFatalError = null;
     if (handler != null) {
       handler.removeCallbacksAndMessages(null);
       handler = null;
     }
     elapsedRealtimeOffsetMs = 0;
+    staleManifestReloadAttempt = 0;
+    expiredManifestPublishTimeUs = C.TIME_UNSET;
+    dynamicMediaPresentationEnded = false;
+    firstPeriodId = 0;
     periodsById.clear();
   }
 
+  // PlayerEmsgCallback callbacks.
+
+  /* package */ void onDashManifestRefreshRequested() {
+    handler.removeCallbacks(simulateManifestRefreshRunnable);
+    startLoadingManifest();
+  }
+
+  /* package */ void onDashLiveMediaPresentationEndSignalEncountered() {
+    this.dynamicMediaPresentationEnded = true;
+  }
+
+  /* package */ void onDashManifestPublishTimeExpired(long expiredManifestPublishTimeUs) {
+    if (this.expiredManifestPublishTimeUs == C.TIME_UNSET
+        || this.expiredManifestPublishTimeUs < expiredManifestPublishTimeUs) {
+      this.expiredManifestPublishTimeUs = expiredManifestPublishTimeUs;
+    }
+  }
+
   // Loadable callbacks.
 
   /* package */ void onManifestLoadCompleted(ParsingLoadable<DashManifest> loadable,
@@ -339,19 +602,48 @@ public void releaseSource() {
       removedPeriodCount++;
     }
 
-    // After discarding old periods, we should never have more periods than listed in the new
-    // manifest. That would mean that a previously announced period is no longer advertised. If
-    // this condition occurs, assume that we are hitting a manifest server that is out of sync and
-    // behind, discard this manifest, and try again later.
-    if (periodCount - removedPeriodCount > newManifest.getPeriodCount()) {
-      Log.w(TAG, "Out of sync manifest");
-      scheduleManifestRefresh();
-      return;
+    if (newManifest.dynamic) {
+      boolean isManifestStale = false;
+      if (periodCount - removedPeriodCount > newManifest.getPeriodCount()) {
+        // After discarding old periods, we should never have more periods than listed in the new
+        // manifest. That would mean that a previously announced period is no longer advertised. If
+        // this condition occurs, assume that we are hitting a manifest server that is out of sync
+        // and
+        // behind.
+        Log.w(TAG, "Loaded out of sync manifest");
+        isManifestStale = true;
+      } else if (dynamicMediaPresentationEnded
+          || newManifest.publishTimeMs <= expiredManifestPublishTimeUs) {
+        // If we receive a dynamic manifest that's older than expected (i.e. its publish time has
+        // expired, or it's dynamic and we know the presentation has ended), then this manifest is
+        // stale.
+        Log.w(
+            TAG,
+            "Loaded stale dynamic manifest: "
+                + newManifest.publishTimeMs
+                + ", "
+                + dynamicMediaPresentationEnded
+                + ", "
+                + expiredManifestPublishTimeUs);
+        isManifestStale = true;
+      }
+
+      if (isManifestStale) {
+        if (staleManifestReloadAttempt++ < minLoadableRetryCount) {
+          scheduleManifestRefresh(getManifestLoadRetryDelayMillis());
+        } else {
+          manifestFatalError = new DashManifestStaleException();
+        }
+        return;
+      }
+      staleManifestReloadAttempt = 0;
     }
 
+
     manifest = newManifest;
-    manifestLoadStartTimestamp = elapsedRealtimeMs - loadDurationMs;
-    manifestLoadEndTimestamp = elapsedRealtimeMs;
+    manifestLoadPending &= manifest.dynamic;
+    manifestLoadStartTimestampMs = elapsedRealtimeMs - loadDurationMs;
+    manifestLoadEndTimestampMs = elapsedRealtimeMs;
     if (manifest.location != null) {
       synchronized (manifestUriLock) {
         // This condition checks that replaceManifestUri wasn't called between the start and end of
@@ -405,15 +697,6 @@ public void releaseSource() {
 
   // Internal methods.
 
-  private void startLoadingManifest() {
-    Uri manifestUri;
-    synchronized (manifestUriLock) {
-      manifestUri = this.manifestUri;
-    }
-    startLoading(new ParsingLoadable<>(dataSource, manifestUri, C.DATA_TYPE_MANIFEST,
-        manifestParser), manifestCallback, minLoadableRetryCount);
-  }
-
   private void resolveUtcTimingElement(UtcTimingElement timingElement) {
     String scheme = timingElement.schemeIdUri;
     if (Util.areEqual(scheme, "urn:mpeg:dash:utc:direct:2014")
@@ -433,8 +716,8 @@ private void resolveUtcTimingElement(UtcTimingElement timingElement) {
 
   private void resolveUtcTimingElementDirect(UtcTimingElement timingElement) {
     try {
-      long utcTimestamp = Util.parseXsDateTime(timingElement.value);
-      onUtcTimestampResolved(utcTimestamp - manifestLoadEndTimestamp);
+      long utcTimestampMs = Util.parseXsDateTime(timingElement.value);
+      onUtcTimestampResolved(utcTimestampMs - manifestLoadEndTimestampMs);
     } catch (ParserException e) {
       onUtcTimestampResolutionError(e);
     }
@@ -480,12 +763,12 @@ private void processManifest(boolean scheduleRefresh) {
     if (manifest.dynamic && !lastPeriodSeekInfo.isIndexExplicit) {
       // The manifest describes an incomplete live stream. Update the start/end times to reflect the
       // live stream duration and the manifest's time shift buffer depth.
-      long liveStreamDurationUs = getNowUnixTimeUs() - C.msToUs(manifest.availabilityStartTime);
+      long liveStreamDurationUs = getNowUnixTimeUs() - C.msToUs(manifest.availabilityStartTimeMs);
       long liveStreamEndPositionInLastPeriodUs = liveStreamDurationUs
           - C.msToUs(manifest.getPeriod(lastPeriodIndex).startMs);
       currentEndTimeUs = Math.min(liveStreamEndPositionInLastPeriodUs, currentEndTimeUs);
-      if (manifest.timeShiftBufferDepth != C.TIME_UNSET) {
-        long timeShiftBufferDepthUs = C.msToUs(manifest.timeShiftBufferDepth);
+      if (manifest.timeShiftBufferDepthMs != C.TIME_UNSET) {
+        long timeShiftBufferDepthUs = C.msToUs(manifest.timeShiftBufferDepthMs);
         long offsetInPeriodUs = currentEndTimeUs - timeShiftBufferDepthUs;
         int periodIndex = lastPeriodIndex;
         while (offsetInPeriodUs < 0 && periodIndex > 0) {
@@ -509,8 +792,8 @@ private void processManifest(boolean scheduleRefresh) {
     if (manifest.dynamic) {
       long presentationDelayForManifestMs = livePresentationDelayMs;
       if (presentationDelayForManifestMs == DEFAULT_LIVE_PRESENTATION_DELAY_PREFER_MANIFEST_MS) {
-        presentationDelayForManifestMs = manifest.suggestedPresentationDelay != C.TIME_UNSET
-            ? manifest.suggestedPresentationDelay : DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS;
+        presentationDelayForManifestMs = manifest.suggestedPresentationDelayMs != C.TIME_UNSET
+            ? manifest.suggestedPresentationDelayMs : DEFAULT_LIVE_PRESENTATION_DELAY_FIXED_MS;
       }
       // Snap the default position to the start of the segment containing it.
       windowDefaultStartPositionUs = windowDurationUs - C.msToUs(presentationDelayForManifestMs);
@@ -522,9 +805,9 @@ private void processManifest(boolean scheduleRefresh) {
             windowDurationUs / 2);
       }
     }
-    long windowStartTimeMs = manifest.availabilityStartTime
+    long windowStartTimeMs = manifest.availabilityStartTimeMs
         + manifest.getPeriod(0).startMs + C.usToMs(currentStartTimeUs);
-    DashTimeline timeline = new DashTimeline(manifest.availabilityStartTime, windowStartTimeMs,
+    DashTimeline timeline = new DashTimeline(manifest.availabilityStartTimeMs, windowStartTimeMs,
         firstPeriodId, currentStartTimeUs, windowDurationUs, windowDefaultStartPositionUs,
         manifest);
     sourceListener.onSourceInfoRefreshed(this, timeline, manifest);
@@ -536,28 +819,49 @@ private void processManifest(boolean scheduleRefresh) {
       if (windowChangingImplicitly) {
         handler.postDelayed(simulateManifestRefreshRunnable, NOTIFY_MANIFEST_INTERVAL_MS);
       }
-      // Schedule an explicit refresh if needed.
-      if (scheduleRefresh) {
-        scheduleManifestRefresh();
+      if (manifestLoadPending) {
+        startLoadingManifest();
+      } else if (scheduleRefresh && manifest.dynamic) {
+        // Schedule an explicit refresh if needed.
+        long minUpdatePeriodMs = manifest.minUpdatePeriodMs;
+        if (minUpdatePeriodMs == 0) {
+          // TODO: This is a temporary hack to avoid constantly refreshing the MPD in cases where
+          // minimumUpdatePeriod is set to 0. In such cases we shouldn't refresh unless there is
+          // explicit signaling in the stream, according to:
+          // http://azure.microsoft.com/blog/2014/09/13/dash-live-streaming-with-azure-media-service
+          minUpdatePeriodMs = 5000;
+        }
+        long nextLoadTimestampMs = manifestLoadStartTimestampMs + minUpdatePeriodMs;
+        long delayUntilNextLoadMs =
+            Math.max(0, nextLoadTimestampMs - SystemClock.elapsedRealtime());
+        scheduleManifestRefresh(delayUntilNextLoadMs);
       }
     }
   }
 
-  private void scheduleManifestRefresh() {
-    if (!manifest.dynamic) {
+  private void scheduleManifestRefresh(long delayUntilNextLoadMs) {
+    handler.postDelayed(refreshManifestRunnable, delayUntilNextLoadMs);
+  }
+
+  private void startLoadingManifest() {
+    handler.removeCallbacks(refreshManifestRunnable);
+    if (loader.isLoading()) {
+      manifestLoadPending = true;
       return;
     }
-    long minUpdatePeriod = manifest.minUpdatePeriod;
-    if (minUpdatePeriod == 0) {
-      // TODO: This is a temporary hack to avoid constantly refreshing the MPD in cases where
-      // minUpdatePeriod is set to 0. In such cases we shouldn't refresh unless there is explicit
-      // signaling in the stream, according to:
-      // http://azure.microsoft.com/blog/2014/09/13/dash-live-streaming-with-azure-media-service/
-      minUpdatePeriod = 5000;
+    Uri manifestUri;
+    synchronized (manifestUriLock) {
+      manifestUri = this.manifestUri;
     }
-    long nextLoadTimestamp = manifestLoadStartTimestamp + minUpdatePeriod;
-    long delayUntilNextLoad = Math.max(0, nextLoadTimestamp - SystemClock.elapsedRealtime());
-    handler.postDelayed(refreshManifestRunnable, delayUntilNextLoad);
+    manifestLoadPending = false;
+    startLoading(
+        new ParsingLoadable<>(dataSource, manifestUri, C.DATA_TYPE_MANIFEST, manifestParser),
+        manifestCallback,
+        minLoadableRetryCount);
+  }
+
+  private long getManifestLoadRetryDelayMillis() {
+    return Math.min((staleManifestReloadAttempt - 1) * 1000, 5000);
   }
 
   private <T> void startLoading(ParsingLoadable<T> loadable,
@@ -595,11 +899,11 @@ public static PeriodSeekInfo createPeriodSeekInfo(
           availableStartTimeUs = 0;
           availableEndTimeUs = 0;
         } else if (!seenEmptyIndex) {
-          int firstSegmentNum = index.getFirstSegmentNum();
+          long firstSegmentNum = index.getFirstSegmentNum();
           long adaptationSetAvailableStartTimeUs = index.getTimeUs(firstSegmentNum);
           availableStartTimeUs = Math.max(availableStartTimeUs, adaptationSetAvailableStartTimeUs);
           if (segmentCount != DashSegmentIndex.INDEX_UNBOUNDED) {
-            int lastSegmentNum = firstSegmentNum + segmentCount - 1;
+            long lastSegmentNum = firstSegmentNum + segmentCount - 1;
             long adaptationSetAvailableEndTimeUs = index.getTimeUs(lastSegmentNum)
                 + index.getDurationUs(lastSegmentNum, durationUs);
             availableEndTimeUs = Math.min(availableEndTimeUs, adaptationSetAvailableEndTimeUs);
@@ -724,15 +1028,32 @@ private long getAdjustedWindowDefaultStartPositionUs(long defaultPositionProject
         // Video adaptation set does not include a non-empty index for snapping.
         return windowDefaultStartPositionUs;
       }
-      int segmentNum = snapIndex.getSegmentNum(defaultStartPositionInPeriodUs, periodDurationUs);
+      long segmentNum = snapIndex.getSegmentNum(defaultStartPositionInPeriodUs, periodDurationUs);
       return windowDefaultStartPositionUs + snapIndex.getTimeUs(segmentNum)
           - defaultStartPositionInPeriodUs;
     }
 
   }
 
-  private final class ManifestCallback implements
-      Loader.Callback<ParsingLoadable<DashManifest>> {
+  private final class DefaultPlayerEmsgCallback implements PlayerEmsgCallback {
+
+    @Override
+    public void onDashManifestRefreshRequested() {
+      DashMediaSource.this.onDashManifestRefreshRequested();
+    }
+
+    @Override
+    public void onDashManifestPublishTimeExpired(long expiredManifestPublishTimeUs) {
+      DashMediaSource.this.onDashManifestPublishTimeExpired(expiredManifestPublishTimeUs);
+    }
+
+    @Override
+    public void onDashLiveMediaPresentationEndSignalEncountered() {
+      DashMediaSource.this.onDashLiveMediaPresentationEndSignalEncountered();
+    }
+  }
+
+  private final class ManifestCallback implements Loader.Callback<ParsingLoadable<DashManifest>> {
 
     @Override
     public void onLoadCompleted(ParsingLoadable<DashManifest> loadable,
@@ -786,16 +1107,39 @@ public Long parse(Uri uri, InputStream inputStream) throws IOException {
 
   }
 
-  private static final class Iso8601Parser implements ParsingLoadable.Parser<Long> {
+  /* package */ static final class Iso8601Parser implements ParsingLoadable.Parser<Long> {
+
+    private static final Pattern TIMESTAMP_WITH_TIMEZONE_PATTERN =
+        Pattern.compile("(.+?)(Z|((\\+|-|−)(\\d\\d)(:?(\\d\\d))?))");
 
     @Override
     public Long parse(Uri uri, InputStream inputStream) throws IOException {
-      String firstLine = new BufferedReader(new InputStreamReader(inputStream)).readLine();
+      String firstLine =
+          new BufferedReader(new InputStreamReader(inputStream, Charset.forName(C.UTF8_NAME)))
+              .readLine();
       try {
-        // TODO: It may be necessary to handle timestamp offsets from UTC.
-        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US);
+        Matcher matcher = TIMESTAMP_WITH_TIMEZONE_PATTERN.matcher(firstLine);
+        if (!matcher.matches()) {
+          throw new ParserException("Couldn't parse timestamp: " + firstLine);
+        }
+        // Parse the timestamp.
+        String timestampWithoutTimezone = matcher.group(1);
+        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.US);
         format.setTimeZone(TimeZone.getTimeZone("UTC"));
-        return format.parse(firstLine).getTime();
+        long timestampMs = format.parse(timestampWithoutTimezone).getTime();
+        // Parse the timezone.
+        String timezone = matcher.group(2);
+        if ("Z".equals(timezone)) {
+          // UTC (no offset).
+        } else {
+          long sign = "+".equals(matcher.group(4)) ? 1 : -1;
+          long hours = Long.parseLong(matcher.group(5));
+          String minutesString = matcher.group(7);
+          long minutes = TextUtils.isEmpty(minutesString) ? 0 : Long.parseLong(minutesString);
+          long timestampOffsetMs = sign * (((hours * 60) + minutes) * 60 * 1000);
+          timestampMs -= timestampOffsetMs;
+        }
+        return timestampMs;
       } catch (ParseException e) {
         throw new ParserException(e);
       }
@@ -803,4 +1147,28 @@ public Long parse(Uri uri, InputStream inputStream) throws IOException {
 
   }
 
+  /**
+   * A {@link LoaderErrorThrower} that throws fatal {@link IOException} that has occurred during
+   * manifest loading from the manifest {@code loader}, or exception with the loaded manifest.
+   */
+  /* package */ final class ManifestLoadErrorThrower implements LoaderErrorThrower {
+
+    @Override
+    public void maybeThrowError() throws IOException {
+      loader.maybeThrowError();
+      maybeThrowManifestError();
+    }
+
+    @Override
+    public void maybeThrowError(int minRetryCount) throws IOException {
+      loader.maybeThrowError(minRetryCount);
+      maybeThrowManifestError();
+    }
+
+    private void maybeThrowManifestError() throws IOException {
+      if (manifestFatalError != null) {
+        throw manifestFatalError;
+      }
+    }
+  }
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashSegmentIndex.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashSegmentIndex.java
index 2ddc7f4f80..9d45bc726e 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashSegmentIndex.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashSegmentIndex.java
@@ -32,11 +32,11 @@
    * Otherwise, returns the segment number of the segment containing the given media time.
    *
    * @param timeUs The time in microseconds.
-   * @param periodDurationUs The duration of the enclosing period in microseconds, or
-   *     {@link C#TIME_UNSET} if the period's duration is not yet known.
+   * @param periodDurationUs The duration of the enclosing period in microseconds, or {@link
+   *     C#TIME_UNSET} if the period's duration is not yet known.
    * @return The segment number of the corresponding segment.
    */
-  int getSegmentNum(long timeUs, long periodDurationUs);
+  long getSegmentNum(long timeUs, long periodDurationUs);
 
   /**
    * Returns the start time of a segment.
@@ -44,17 +44,17 @@
    * @param segmentNum The segment number.
    * @return The corresponding start time in microseconds.
    */
-  long getTimeUs(int segmentNum);
+  long getTimeUs(long segmentNum);
 
   /**
    * Returns the duration of a segment.
    *
    * @param segmentNum The segment number.
-   * @param periodDurationUs The duration of the enclosing period in microseconds, or
-   *     {@link C#TIME_UNSET} if the period's duration is not yet known.
+   * @param periodDurationUs The duration of the enclosing period in microseconds, or {@link
+   *     C#TIME_UNSET} if the period's duration is not yet known.
    * @return The duration of the segment, in microseconds.
    */
-  long getDurationUs(int segmentNum, long periodDurationUs);
+  long getDurationUs(long segmentNum, long periodDurationUs);
 
   /**
    * Returns a {@link RangedUri} defining the location of a segment.
@@ -62,14 +62,14 @@
    * @param segmentNum The segment number.
    * @return The {@link RangedUri} defining the location of the data.
    */
-  RangedUri getSegmentUrl(int segmentNum);
+  RangedUri getSegmentUrl(long segmentNum);
 
   /**
    * Returns the segment number of the first segment.
    *
    * @return The segment number of the first segment.
    */
-  int getFirstSegmentNum();
+  long getFirstSegmentNum();
 
   /**
    * Returns the number of segments in the index, or {@link #INDEX_UNBOUNDED}.
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
index ed2f916b87..2227044da7 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashUtil.java
@@ -53,10 +53,8 @@
    */
   public static DashManifest loadManifest(DataSource dataSource, Uri uri)
       throws IOException {
-    DataSpec dataSpec = new DataSpec(uri,
-        DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH | DataSpec.FLAG_ALLOW_GZIP);
-    ParsingLoadable<DashManifest> loadable = new ParsingLoadable<>(dataSource, dataSpec,
-        C.DATA_TYPE_MANIFEST, new DashManifestParser());
+    ParsingLoadable<DashManifest> loadable =
+        new ParsingLoadable<>(dataSource, uri, C.DATA_TYPE_MANIFEST, new DashManifestParser());
     loadable.load();
     return loadable.getResult();
   }
@@ -81,14 +79,11 @@ public static DrmInitData loadDrmInitData(DataSource dataSource, Period period)
         return null;
       }
     }
-    DrmInitData drmInitData = representation.format.drmInitData;
-    if (drmInitData != null) {
-      // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
-      // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
-      return drmInitData;
-    }
+    Format manifestFormat = representation.format;
     Format sampleFormat = DashUtil.loadSampleFormat(dataSource, primaryTrackType, representation);
-    return sampleFormat == null ? null : sampleFormat.drmInitData;
+    return sampleFormat == null
+        ? manifestFormat.drmInitData
+        : sampleFormat.copyWithManifestFormatInfo(manifestFormat).drmInitData;
   }
 
   /**
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
index 8cd5018dc7..078305a687 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DashWrappingSegmentIndex.java
@@ -34,7 +34,7 @@ public DashWrappingSegmentIndex(ChunkIndex chunkIndex) {
   }
 
   @Override
-  public int getFirstSegmentNum() {
+  public long getFirstSegmentNum() {
     return 0;
   }
 
@@ -44,22 +44,23 @@ public int getSegmentCount(long periodDurationUs) {
   }
 
   @Override
-  public long getTimeUs(int segmentNum) {
-    return chunkIndex.timesUs[segmentNum];
+  public long getTimeUs(long segmentNum) {
+    return chunkIndex.timesUs[(int) segmentNum];
   }
 
   @Override
-  public long getDurationUs(int segmentNum, long periodDurationUs) {
-    return chunkIndex.durationsUs[segmentNum];
+  public long getDurationUs(long segmentNum, long periodDurationUs) {
+    return chunkIndex.durationsUs[(int) segmentNum];
   }
 
   @Override
-  public RangedUri getSegmentUrl(int segmentNum) {
-    return new RangedUri(null, chunkIndex.offsets[segmentNum], chunkIndex.sizes[segmentNum]);
+  public RangedUri getSegmentUrl(long segmentNum) {
+    return new RangedUri(
+        null, chunkIndex.offsets[(int) segmentNum], chunkIndex.sizes[(int) segmentNum]);
   }
 
   @Override
-  public int getSegmentNum(long timeUs, long periodDurationUs) {
+  public long getSegmentNum(long timeUs, long periodDurationUs) {
     return chunkIndex.getChunkIndex(timeUs);
   }
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
index 1eac1b5616..a76349adac 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java
@@ -17,11 +17,14 @@
 
 import android.net.Uri;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.extractor.ChunkIndex;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.SeekMap;
+import com.google.android.exoplayer2.extractor.TrackOutput;
 import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
 import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer2.extractor.rawcc.RawCcExtractor;
@@ -34,6 +37,7 @@
 import com.google.android.exoplayer2.source.chunk.InitializationChunk;
 import com.google.android.exoplayer2.source.chunk.MediaChunk;
 import com.google.android.exoplayer2.source.chunk.SingleSampleMediaChunk;
+import com.google.android.exoplayer2.source.dash.PlayerEmsgHandler.PlayerTrackEmsgHandler;
 import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
@@ -47,6 +51,7 @@
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -69,14 +74,31 @@ public Factory(DataSource.Factory dataSourceFactory, int maxSegmentsPerLoad) {
     }
 
     @Override
-    public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
-        DashManifest manifest, int periodIndex, int[] adaptationSetIndices,
-        TrackSelection trackSelection, int trackType, long elapsedRealtimeOffsetMs,
-        boolean enableEventMessageTrack, boolean enableCea608Track) {
+    public DashChunkSource createDashChunkSource(
+        LoaderErrorThrower manifestLoaderErrorThrower,
+        DashManifest manifest,
+        int periodIndex,
+        int[] adaptationSetIndices,
+        TrackSelection trackSelection,
+        int trackType,
+        long elapsedRealtimeOffsetMs,
+        boolean enableEventMessageTrack,
+        boolean enableCea608Track,
+        @Nullable PlayerTrackEmsgHandler playerEmsgHandler) {
       DataSource dataSource = dataSourceFactory.createDataSource();
-      return new DefaultDashChunkSource(manifestLoaderErrorThrower, manifest, periodIndex,
-          adaptationSetIndices, trackSelection, trackType, dataSource, elapsedRealtimeOffsetMs,
-          maxSegmentsPerLoad, enableEventMessageTrack, enableCea608Track);
+      return new DefaultDashChunkSource(
+          manifestLoaderErrorThrower,
+          manifest,
+          periodIndex,
+          adaptationSetIndices,
+          trackSelection,
+          trackType,
+          dataSource,
+          elapsedRealtimeOffsetMs,
+          maxSegmentsPerLoad,
+          enableEventMessageTrack,
+          enableCea608Track,
+          playerEmsgHandler);
     }
 
   }
@@ -88,6 +110,7 @@ public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderEr
   private final DataSource dataSource;
   private final long elapsedRealtimeOffsetMs;
   private final int maxSegmentsPerLoad;
+  @Nullable private final PlayerTrackEmsgHandler playerTrackEmsgHandler;
 
   protected final RepresentationHolder[] representationHolders;
 
@@ -108,18 +131,28 @@ public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderEr
    * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference between
    *     server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds, specified
    *     as the server's unix time minus the local elapsed time. If unknown, set to 0.
-   * @param maxSegmentsPerLoad The maximum number of segments to combine into a single request.
-   *     Note that segments will only be combined if their {@link Uri}s are the same and if their
-   *     data ranges are adjacent.
+   * @param maxSegmentsPerLoad The maximum number of segments to combine into a single request. Note
+   *     that segments will only be combined if their {@link Uri}s are the same and if their data
+   *     ranges are adjacent.
    * @param enableEventMessageTrack Whether the chunks generated by the source may output an event
    *     message track.
    * @param enableCea608Track Whether the chunks generated by the source may output a CEA-608 track.
+   * @param playerTrackEmsgHandler The {@link PlayerTrackEmsgHandler} instance to handle emsg
+   *     messages targeting the player. Maybe null if this is not necessary.
    */
-  public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
-      DashManifest manifest, int periodIndex, int[] adaptationSetIndices,
-      TrackSelection trackSelection, int trackType, DataSource dataSource,
-      long elapsedRealtimeOffsetMs, int maxSegmentsPerLoad, boolean enableEventMessageTrack,
-      boolean enableCea608Track) {
+  public DefaultDashChunkSource(
+      LoaderErrorThrower manifestLoaderErrorThrower,
+      DashManifest manifest,
+      int periodIndex,
+      int[] adaptationSetIndices,
+      TrackSelection trackSelection,
+      int trackType,
+      DataSource dataSource,
+      long elapsedRealtimeOffsetMs,
+      int maxSegmentsPerLoad,
+      boolean enableEventMessageTrack,
+      boolean enableCea608Track,
+      @Nullable PlayerTrackEmsgHandler playerTrackEmsgHandler) {
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.manifest = manifest;
     this.adaptationSetIndices = adaptationSetIndices;
@@ -129,16 +162,42 @@ public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
     this.periodIndex = periodIndex;
     this.elapsedRealtimeOffsetMs = elapsedRealtimeOffsetMs;
     this.maxSegmentsPerLoad = maxSegmentsPerLoad;
+    this.playerTrackEmsgHandler = playerTrackEmsgHandler;
 
     long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
     liveEdgeTimeUs = C.TIME_UNSET;
+
     List<Representation> representations = getRepresentations();
     representationHolders = new RepresentationHolder[trackSelection.length()];
     for (int i = 0; i < representationHolders.length; i++) {
       Representation representation = representations.get(trackSelection.getIndexInTrackGroup(i));
-      representationHolders[i] = new RepresentationHolder(periodDurationUs, trackType,
-          representation, enableEventMessageTrack, enableCea608Track);
+      representationHolders[i] =
+          new RepresentationHolder(
+              periodDurationUs,
+              trackType,
+              representation,
+              enableEventMessageTrack,
+              enableCea608Track,
+              playerTrackEmsgHandler);
+    }
+  }
+
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    // Segments are aligned across representations, so any segment index will do.
+    for (RepresentationHolder representationHolder : representationHolders) {
+      if (representationHolder.segmentIndex != null) {
+        long segmentNum = representationHolder.getSegmentNum(positionUs);
+        long firstSyncUs = representationHolder.getSegmentStartTimeUs(segmentNum);
+        long secondSyncUs =
+            firstSyncUs < positionUs && segmentNum < representationHolder.getSegmentCount() - 1
+                ? representationHolder.getSegmentStartTimeUs(segmentNum + 1)
+                : firstSyncUs;
+        return Util.resolveSeekPositionUs(positionUs, seekParameters, firstSyncUs, secondSyncUs);
+      }
     }
+    // We don't have a segment index to adjust the seek position with yet.
+    return positionUs;
   }
 
   @Override
@@ -183,6 +242,17 @@ public void getNextChunk(MediaChunk previous, long playbackPositionUs, long load
 
     long bufferedDurationUs = loadPositionUs - playbackPositionUs;
     long timeToLiveEdgeUs = resolveTimeToLiveEdgeUs(playbackPositionUs);
+    long presentationPositionUs =
+        C.msToUs(manifest.availabilityStartTimeMs)
+            + C.msToUs(manifest.getPeriod(periodIndex).startMs)
+            + loadPositionUs;
+
+    if (playerTrackEmsgHandler != null
+        && playerTrackEmsgHandler.maybeRefreshManifestBeforeLoadingNextChunk(
+            presentationPositionUs)) {
+      return;
+    }
+
     trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, timeToLiveEdgeUs);
 
     RepresentationHolder representationHolder =
@@ -214,16 +284,16 @@ public void getNextChunk(MediaChunk previous, long playbackPositionUs, long load
       return;
     }
 
-    int firstAvailableSegmentNum = representationHolder.getFirstSegmentNum();
-    int lastAvailableSegmentNum;
+    long firstAvailableSegmentNum = representationHolder.getFirstSegmentNum();
+    long lastAvailableSegmentNum;
     if (availableSegmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
       // The index is itself unbounded. We need to use the current time to calculate the range of
       // available segments.
-      long liveEdgeTimeUs = getNowUnixTimeUs() - C.msToUs(manifest.availabilityStartTime);
+      long liveEdgeTimeUs = getNowUnixTimeUs() - C.msToUs(manifest.availabilityStartTimeMs);
       long periodStartUs = C.msToUs(manifest.getPeriod(periodIndex).startMs);
       long liveEdgeTimeInPeriodUs = liveEdgeTimeUs - periodStartUs;
-      if (manifest.timeShiftBufferDepth != C.TIME_UNSET) {
-        long bufferDepthUs = C.msToUs(manifest.timeShiftBufferDepth);
+      if (manifest.timeShiftBufferDepthMs != C.TIME_UNSET) {
+        long bufferDepthUs = C.msToUs(manifest.timeShiftBufferDepthMs);
         firstAvailableSegmentNum = Math.max(firstAvailableSegmentNum,
             representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs - bufferDepthUs));
       }
@@ -236,7 +306,7 @@ public void getNextChunk(MediaChunk previous, long playbackPositionUs, long load
 
     updateLiveEdgeTimeUs(representationHolder, lastAvailableSegmentNum);
 
-    int segmentNum;
+    long segmentNum;
     if (previous == null) {
       segmentNum = Util.constrainValue(representationHolder.getSegmentNum(loadPositionUs),
           firstAvailableSegmentNum, lastAvailableSegmentNum);
@@ -256,7 +326,8 @@ public void getNextChunk(MediaChunk previous, long playbackPositionUs, long load
       return;
     }
 
-    int maxSegmentCount = Math.min(maxSegmentsPerLoad, lastAvailableSegmentNum - segmentNum + 1);
+    int maxSegmentCount =
+        (int) Math.min(maxSegmentsPerLoad, lastAvailableSegmentNum - segmentNum + 1);
     out.chunk = newMediaChunk(representationHolder, dataSource, trackType,
         trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
         trackSelection.getSelectionData(), segmentNum, maxSegmentCount);
@@ -278,6 +349,9 @@ public void onChunkLoadCompleted(Chunk chunk) {
         }
       }
     }
+    if (playerTrackEmsgHandler != null) {
+      playerTrackEmsgHandler.onChunkLoadCompleted(chunk);
+    }
   }
 
   @Override
@@ -285,6 +359,10 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
     if (!cancelable) {
       return false;
     }
+    if (playerTrackEmsgHandler != null
+        && playerTrackEmsgHandler.maybeRefreshManifestOnLoadingError(chunk)) {
+      return true;
+    }
     // Workaround for missing segment at the end of the period
     if (!manifest.dynamic && chunk instanceof MediaChunk
         && e instanceof InvalidResponseCodeException
@@ -293,7 +371,7 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
           representationHolders[trackSelection.indexOf(chunk.trackFormat)];
       int segmentCount = representationHolder.getSegmentCount();
       if (segmentCount != DashSegmentIndex.INDEX_UNBOUNDED && segmentCount != 0) {
-        int lastAvailableSegmentNum = representationHolder.getFirstSegmentNum() + segmentCount - 1;
+        long lastAvailableSegmentNum = representationHolder.getFirstSegmentNum() + segmentCount - 1;
         if (((MediaChunk) chunk).getNextChunkIndex() > lastAvailableSegmentNum) {
           missingLastSegment = true;
           return true;
@@ -316,8 +394,8 @@ public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
     return representations;
   }
 
-  private void updateLiveEdgeTimeUs(RepresentationHolder representationHolder,
-      int lastAvailableSegmentNum) {
+  private void updateLiveEdgeTimeUs(
+      RepresentationHolder representationHolder, long lastAvailableSegmentNum) {
     liveEdgeTimeUs = manifest.dynamic
         ? representationHolder.getSegmentEndTimeUs(lastAvailableSegmentNum) : C.TIME_UNSET;
   }
@@ -356,9 +434,15 @@ protected static Chunk newInitializationChunk(RepresentationHolder representatio
         trackSelectionReason, trackSelectionData, representationHolder.extractorWrapper);
   }
 
-  protected static Chunk newMediaChunk(RepresentationHolder representationHolder,
-      DataSource dataSource, int trackType, Format trackFormat, int trackSelectionReason,
-      Object trackSelectionData, int firstSegmentNum, int maxSegmentCount) {
+  protected static Chunk newMediaChunk(
+      RepresentationHolder representationHolder,
+      DataSource dataSource,
+      int trackType,
+      Format trackFormat,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long firstSegmentNum,
+      int maxSegmentCount) {
     Representation representation = representationHolder.representation;
     long startTimeUs = representationHolder.getSegmentStartTimeUs(firstSegmentNum);
     RangedUri segmentUri = representationHolder.getSegmentUrl(firstSegmentNum);
@@ -404,10 +488,15 @@ protected static Chunk newMediaChunk(RepresentationHolder representationHolder,
     public DashSegmentIndex segmentIndex;
 
     private long periodDurationUs;
-    private int segmentNumShift;
-
-    /* package */ RepresentationHolder(long periodDurationUs, int trackType,
-        Representation representation, boolean enableEventMessageTrack, boolean enableCea608Track) {
+    private long segmentNumShift;
+
+    /* package */ RepresentationHolder(
+        long periodDurationUs,
+        int trackType,
+        Representation representation,
+        boolean enableEventMessageTrack,
+        boolean enableCea608Track,
+        TrackOutput playerEmsgTrackOutput) {
       this.periodDurationUs = periodDurationUs;
       this.representation = representation;
       String containerMimeType = representation.format.containerMimeType;
@@ -424,10 +513,15 @@ protected static Chunk newMediaChunk(RepresentationHolder representationHolder,
           if (enableEventMessageTrack) {
             flags |= FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK;
           }
-          if (enableCea608Track) {
-            flags |= FragmentedMp4Extractor.FLAG_ENABLE_CEA608_TRACK;
-          }
-          extractor = new FragmentedMp4Extractor(flags);
+          // TODO: Use caption format information from the manifest if available.
+          List<Format> closedCaptionFormats = enableCea608Track
+              ? Collections.singletonList(
+                  Format.createTextSampleFormat(null, MimeTypes.APPLICATION_CEA608, 0, null))
+              : Collections.<Format>emptyList();
+
+          extractor =
+              new FragmentedMp4Extractor(
+                  flags, null, null, null, closedCaptionFormats, playerEmsgTrackOutput);
         }
         // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
         // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
@@ -460,10 +554,10 @@ protected static Chunk newMediaChunk(RepresentationHolder representationHolder,
         return;
       }
 
-      int oldIndexLastSegmentNum = oldIndex.getFirstSegmentNum() + oldIndexSegmentCount - 1;
+      long oldIndexLastSegmentNum = oldIndex.getFirstSegmentNum() + oldIndexSegmentCount - 1;
       long oldIndexEndTimeUs = oldIndex.getTimeUs(oldIndexLastSegmentNum)
           + oldIndex.getDurationUs(oldIndexLastSegmentNum, periodDurationUs);
-      int newIndexFirstSegmentNum = newIndex.getFirstSegmentNum();
+      long newIndexFirstSegmentNum = newIndex.getFirstSegmentNum();
       long newIndexStartTimeUs = newIndex.getTimeUs(newIndexFirstSegmentNum);
       if (oldIndexEndTimeUs == newIndexStartTimeUs) {
         // The new index continues where the old one ended, with no overlap.
@@ -479,7 +573,7 @@ protected static Chunk newMediaChunk(RepresentationHolder representationHolder,
       }
     }
 
-    public int getFirstSegmentNum() {
+    public long getFirstSegmentNum() {
       return segmentIndex.getFirstSegmentNum() + segmentNumShift;
     }
 
@@ -487,20 +581,20 @@ public int getSegmentCount() {
       return segmentIndex.getSegmentCount(periodDurationUs);
     }
 
-    public long getSegmentStartTimeUs(int segmentNum) {
+    public long getSegmentStartTimeUs(long segmentNum) {
       return segmentIndex.getTimeUs(segmentNum - segmentNumShift);
     }
 
-    public long getSegmentEndTimeUs(int segmentNum) {
+    public long getSegmentEndTimeUs(long segmentNum) {
       return getSegmentStartTimeUs(segmentNum)
           + segmentIndex.getDurationUs(segmentNum - segmentNumShift, periodDurationUs);
     }
 
-    public int getSegmentNum(long positionUs) {
+    public long getSegmentNum(long positionUs) {
       return segmentIndex.getSegmentNum(positionUs, periodDurationUs) + segmentNumShift;
     }
 
-    public RangedUri getSegmentUrl(int segmentNum) {
+    public RangedUri getSegmentUrl(long segmentNum) {
       return segmentIndex.getSegmentUrl(segmentNum - segmentNumShift);
     }
 
@@ -512,7 +606,5 @@ private static boolean mimeTypeIsWebm(String mimeType) {
     private static boolean mimeTypeIsRawText(String mimeType) {
       return MimeTypes.isText(mimeType) || MimeTypes.APPLICATION_TTML.equals(mimeType);
     }
-
   }
-
 }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
new file mode 100644
index 0000000000..694f9f843e
--- /dev/null
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/EventSampleStream.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
+import com.google.android.exoplayer2.metadata.emsg.EventMessageEncoder;
+import com.google.android.exoplayer2.source.SampleStream;
+import com.google.android.exoplayer2.source.dash.manifest.EventStream;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+
+/**
+ * A {@link SampleStream} consisting of serialized {@link EventMessage}s read from an
+ * {@link EventStream}.
+ */
+/* package */ final class EventSampleStream implements SampleStream {
+
+  private final Format upstreamFormat;
+  private final EventMessageEncoder eventMessageEncoder;
+
+  private long[] eventTimesUs;
+  private boolean eventStreamUpdatable;
+  private EventStream eventStream;
+
+  private boolean isFormatSentDownstream;
+  private int currentIndex;
+  private long pendingSeekPositionUs;
+
+  EventSampleStream(EventStream eventStream, Format upstreamFormat, boolean eventStreamUpdatable) {
+    this.upstreamFormat = upstreamFormat;
+    eventMessageEncoder = new EventMessageEncoder();
+    pendingSeekPositionUs = C.TIME_UNSET;
+    updateEventStream(eventStream, eventStreamUpdatable);
+  }
+
+  void updateEventStream(EventStream eventStream, boolean eventStreamUpdatable) {
+    long lastReadPositionUs = currentIndex == 0 ? C.TIME_UNSET : eventTimesUs[currentIndex - 1];
+
+    this.eventStreamUpdatable = eventStreamUpdatable;
+    this.eventStream = eventStream;
+    this.eventTimesUs = eventStream.presentationTimesUs;
+    if (pendingSeekPositionUs != C.TIME_UNSET) {
+      seekToUs(pendingSeekPositionUs);
+    } else if (lastReadPositionUs != C.TIME_UNSET) {
+      currentIndex = Util.binarySearchCeil(eventTimesUs, lastReadPositionUs, false, false);
+    }
+  }
+
+  String eventStreamId() {
+    return eventStream.id();
+  }
+
+  @Override
+  public boolean isReady() {
+    return true;
+  }
+
+  @Override
+  public void maybeThrowError() throws IOException {
+    // Do nothing.
+  }
+
+  @Override
+  public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
+      boolean formatRequired) {
+    if (formatRequired || !isFormatSentDownstream) {
+      formatHolder.format = upstreamFormat;
+      isFormatSentDownstream = true;
+      return C.RESULT_FORMAT_READ;
+    }
+    if (currentIndex == eventTimesUs.length) {
+      if (!eventStreamUpdatable) {
+        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
+        return C.RESULT_BUFFER_READ;
+      } else {
+        return C.RESULT_NOTHING_READ;
+      }
+    }
+    int sampleIndex = currentIndex++;
+    byte[] serializedEvent = eventMessageEncoder.encode(eventStream.events[sampleIndex],
+        eventStream.timescale);
+    if (serializedEvent != null) {
+      buffer.ensureSpaceForWrite(serializedEvent.length);
+      buffer.setFlags(C.BUFFER_FLAG_KEY_FRAME);
+      buffer.data.put(serializedEvent);
+      buffer.timeUs = eventTimesUs[sampleIndex];
+      return C.RESULT_BUFFER_READ;
+    } else {
+      return C.RESULT_NOTHING_READ;
+    }
+  }
+
+  @Override
+  public int skipData(long positionUs) {
+    int newIndex =
+        Math.max(currentIndex, Util.binarySearchCeil(eventTimesUs, positionUs, true, false));
+    int skipped = newIndex - currentIndex;
+    currentIndex = newIndex;
+    return skipped;
+  }
+
+  /**
+   * Seeks to the specified position in microseconds.
+   *
+   * @param positionUs The seek position in microseconds.
+   */
+  public void seekToUs(long positionUs) {
+    currentIndex = Util.binarySearchCeil(eventTimesUs, positionUs, true, false);
+    boolean isPendingSeek = eventStreamUpdatable && currentIndex == eventTimesUs.length;
+    pendingSeekPositionUs = isPendingSeek ? positionUs : C.TIME_UNSET;
+  }
+
+}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
new file mode 100644
index 0000000000..affeeafe50
--- /dev/null
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/PlayerEmsgHandler.java
@@ -0,0 +1,450 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash;
+
+import static com.google.android.exoplayer2.util.Util.parseXsDateTime;
+
+import android.os.Handler;
+import android.os.Message;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.extractor.ExtractorInput;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
+import com.google.android.exoplayer2.metadata.emsg.EventMessageDecoder;
+import com.google.android.exoplayer2.source.SampleQueue;
+import com.google.android.exoplayer2.source.chunk.Chunk;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.ParsableByteArray;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.TreeMap;
+
+/**
+ * Handles all emsg messages from all media tracks for the player.
+ *
+ * <p>This class will only respond to emsg messages which have schemeIdUri
+ * "urn:mpeg:dash:event:2012", and value "1"/"2"/"3". When it encounters one of these messages, it
+ * will handle the message according to Section 4.5.2.1 DASH -IF IOP Version 4.1:
+ *
+ * <ul>
+ *   <li>If both presentation time delta and event duration are zero, it means the media
+ *       presentation has ended.
+ *   <li>Else, it will parse the message data from the emsg message to find the publishTime of the
+ *       expired manifest, and mark manifest with publishTime smaller than that values to be
+ *       expired.
+ * </ul>
+ *
+ * In both cases, the DASH media source will be notified, and a manifest reload should be triggered.
+ */
+public final class PlayerEmsgHandler implements Handler.Callback {
+
+  private static final int EMSG_MEDIA_PRESENTATION_ENDED = 1;
+  private static final int EMSG_MANIFEST_EXPIRED = 2;
+
+  /** Callbacks for player emsg events encountered during DASH live stream. */
+  public interface PlayerEmsgCallback {
+
+    /** Called when the current manifest should be refreshed. */
+    void onDashManifestRefreshRequested();
+
+    /**
+     * Called when the manifest with the publish time has been expired.
+     *
+     * @param expiredManifestPublishTimeUs The manifest publish time that has been expired.
+     */
+    void onDashManifestPublishTimeExpired(long expiredManifestPublishTimeUs);
+
+    /** Called when a media presentation end signal is encountered during live stream. * */
+    void onDashLiveMediaPresentationEndSignalEncountered();
+  }
+
+  private final Allocator allocator;
+  private final PlayerEmsgCallback playerEmsgCallback;
+  private final EventMessageDecoder decoder;
+  private final Handler handler;
+  private final TreeMap<Long, Long> manifestPublishTimeToExpiryTimeUs;
+
+  private DashManifest manifest;
+
+  private boolean dynamicMediaPresentationEnded;
+  private long expiredManifestPublishTimeUs;
+  private long lastLoadedChunkEndTimeUs;
+  private long lastLoadedChunkEndTimeBeforeRefreshUs;
+  private boolean isWaitingForManifestRefresh;
+  private boolean released;
+
+  /**
+   * @param manifest The initial manifest.
+   * @param playerEmsgCallback The callback that this event handler can invoke when handling emsg
+   *     messages that generate DASH media source events.
+   * @param allocator An {@link Allocator} from which allocations can be obtained.
+   */
+  public PlayerEmsgHandler(
+      DashManifest manifest, PlayerEmsgCallback playerEmsgCallback, Allocator allocator) {
+    this.manifest = manifest;
+    this.playerEmsgCallback = playerEmsgCallback;
+    this.allocator = allocator;
+
+    manifestPublishTimeToExpiryTimeUs = new TreeMap<>();
+    handler = new Handler(this);
+    decoder = new EventMessageDecoder();
+    lastLoadedChunkEndTimeUs = C.TIME_UNSET;
+    lastLoadedChunkEndTimeBeforeRefreshUs = C.TIME_UNSET;
+  }
+
+  /**
+   * Updates the {@link DashManifest} that this handler works on.
+   *
+   * @param newManifest The updated manifest.
+   */
+  public void updateManifest(DashManifest newManifest) {
+    isWaitingForManifestRefresh = false;
+    expiredManifestPublishTimeUs = C.TIME_UNSET;
+    this.manifest = newManifest;
+    removePreviouslyExpiredManifestPublishTimeValues();
+  }
+
+  /* package*/ boolean maybeRefreshManifestBeforeLoadingNextChunk(long presentationPositionUs) {
+    if (!manifest.dynamic) {
+      return false;
+    }
+    if (isWaitingForManifestRefresh) {
+      return true;
+    }
+    boolean manifestRefreshNeeded = false;
+    if (dynamicMediaPresentationEnded) {
+      // The manifest we have is dynamic, but we know a non-dynamic one representing the final state
+      // should be available.
+      manifestRefreshNeeded = true;
+    } else {
+      // Find the smallest publishTime (greater than or equal to the current manifest's publish
+      // time) that has a corresponding expiry time.
+      Map.Entry<Long, Long> expiredEntry = ceilingExpiryEntryForPublishTime(manifest.publishTimeMs);
+      if (expiredEntry != null) {
+        long expiredPointUs = expiredEntry.getValue();
+        if (expiredPointUs < presentationPositionUs) {
+          expiredManifestPublishTimeUs = expiredEntry.getKey();
+          notifyManifestPublishTimeExpired();
+          manifestRefreshNeeded = true;
+        }
+      }
+    }
+    if (manifestRefreshNeeded) {
+      maybeNotifyDashManifestRefreshNeeded();
+    }
+    return manifestRefreshNeeded;
+  }
+
+  /**
+   * For live streaming with emsg event stream, forward seeking can seek pass the emsg messages that
+   * signals end-of-stream or Manifest expiry, which results in load error. In this case, we should
+   * notify the Dash media source to refresh its manifest.
+   *
+   * @param chunk The chunk whose load encountered the error.
+   * @return True if manifest refresh has been requested, false otherwise.
+   */
+  /* package */ boolean maybeRefreshManifestOnLoadingError(Chunk chunk) {
+    if (!manifest.dynamic) {
+      return false;
+    }
+    if (isWaitingForManifestRefresh) {
+      return true;
+    }
+    boolean isAfterForwardSeek =
+        lastLoadedChunkEndTimeUs != C.TIME_UNSET && lastLoadedChunkEndTimeUs < chunk.startTimeUs;
+    if (isAfterForwardSeek) {
+      // if we are after a forward seek, and the playback is dynamic with embedded emsg stream,
+      // there's a chance that we have seek over the emsg messages, in which case we should ask
+      // media source for a refresh.
+      maybeNotifyDashManifestRefreshNeeded();
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Called when the a new chunk in the current media stream has been loaded.
+   *
+   * @param chunk The chunk whose load has been completed.
+   */
+  /* package */ void onChunkLoadCompleted(Chunk chunk) {
+    if (lastLoadedChunkEndTimeUs != C.TIME_UNSET || chunk.endTimeUs > lastLoadedChunkEndTimeUs) {
+      lastLoadedChunkEndTimeUs = chunk.endTimeUs;
+    }
+  }
+
+  /**
+   * Returns whether an event with given schemeIdUri and value is a DASH emsg event targeting the
+   * player.
+   */
+  public static boolean isPlayerEmsgEvent(String schemeIdUri, String value) {
+    return "urn:mpeg:dash:event:2012".equals(schemeIdUri)
+        && ("1".equals(value) || "2".equals(value) || "3".equals(value));
+  }
+
+  /** Returns a {@link TrackOutput} that emsg messages could be written to. */
+  public PlayerTrackEmsgHandler newPlayerTrackEmsgHandler() {
+    return new PlayerTrackEmsgHandler(new SampleQueue(allocator));
+  }
+
+  /** Release this emsg handler. It should not be reused after this call. */
+  public void release() {
+    released = true;
+    handler.removeCallbacksAndMessages(null);
+  }
+
+  @Override
+  public boolean handleMessage(Message message) {
+    if (released) {
+      return true;
+    }
+    switch (message.what) {
+      case (EMSG_MEDIA_PRESENTATION_ENDED):
+        handleMediaPresentationEndedMessageEncountered();
+        return true;
+      case (EMSG_MANIFEST_EXPIRED):
+        ManifestExpiryEventInfo messageObj = (ManifestExpiryEventInfo) message.obj;
+        handleManifestExpiredMessage(
+            messageObj.eventTimeUs, messageObj.manifestPublishTimeMsInEmsg);
+        return true;
+      default:
+        // Do nothing.
+    }
+    return false;
+  }
+
+  // Internal methods.
+
+  private void handleManifestExpiredMessage(long eventTimeUs, long manifestPublishTimeMsInEmsg) {
+    if (!manifestPublishTimeToExpiryTimeUs.containsKey(manifestPublishTimeMsInEmsg)) {
+      manifestPublishTimeToExpiryTimeUs.put(manifestPublishTimeMsInEmsg, eventTimeUs);
+    } else {
+      long previousExpiryTimeUs =
+          manifestPublishTimeToExpiryTimeUs.get(manifestPublishTimeMsInEmsg);
+      if (previousExpiryTimeUs > eventTimeUs) {
+        manifestPublishTimeToExpiryTimeUs.put(manifestPublishTimeMsInEmsg, eventTimeUs);
+      }
+    }
+  }
+
+  private void handleMediaPresentationEndedMessageEncountered() {
+    dynamicMediaPresentationEnded = true;
+    notifySourceMediaPresentationEnded();
+  }
+
+  private Map.Entry<Long, Long> ceilingExpiryEntryForPublishTime(long publishTimeMs) {
+    if (manifestPublishTimeToExpiryTimeUs.isEmpty()) {
+      return null;
+    }
+    return manifestPublishTimeToExpiryTimeUs.ceilingEntry(publishTimeMs);
+  }
+
+  private void removePreviouslyExpiredManifestPublishTimeValues() {
+    for (Iterator<Map.Entry<Long, Long>> it =
+            manifestPublishTimeToExpiryTimeUs.entrySet().iterator();
+        it.hasNext(); ) {
+      Map.Entry<Long, Long> entry = it.next();
+      long expiredManifestPublishTime = entry.getKey();
+      if (expiredManifestPublishTime < manifest.publishTimeMs) {
+        it.remove();
+      }
+    }
+  }
+
+  private void notifyManifestPublishTimeExpired() {
+    playerEmsgCallback.onDashManifestPublishTimeExpired(expiredManifestPublishTimeUs);
+  }
+
+  private void notifySourceMediaPresentationEnded() {
+    playerEmsgCallback.onDashLiveMediaPresentationEndSignalEncountered();
+  }
+
+  /** Requests DASH media manifest to be refreshed if necessary. */
+  private void maybeNotifyDashManifestRefreshNeeded() {
+    if (lastLoadedChunkEndTimeBeforeRefreshUs != C.TIME_UNSET
+        && lastLoadedChunkEndTimeBeforeRefreshUs == lastLoadedChunkEndTimeUs) {
+      // Already requested manifest refresh.
+      return;
+    }
+    isWaitingForManifestRefresh = true;
+    lastLoadedChunkEndTimeBeforeRefreshUs = lastLoadedChunkEndTimeUs;
+    playerEmsgCallback.onDashManifestRefreshRequested();
+  }
+
+  private static long getManifestPublishTimeMsInEmsg(EventMessage eventMessage) {
+    try {
+      return parseXsDateTime(new String(eventMessage.messageData));
+    } catch (ParserException ignored) {
+      // if we can't parse this event, ignore
+      return C.TIME_UNSET;
+    }
+  }
+
+  private static boolean isMessageSignalingMediaPresentationEnded(EventMessage eventMessage) {
+    // According to section 4.5.2.1 DASH-IF IOP, if both presentation time delta and event duration
+    // are zero, the media presentation is ended.
+    return eventMessage.presentationTimeUs == 0 && eventMessage.durationMs == 0;
+  }
+
+  /** Handles emsg messages for a specific track for the player. */
+  public final class PlayerTrackEmsgHandler implements TrackOutput {
+
+    private final SampleQueue sampleQueue;
+    private final FormatHolder formatHolder;
+    private final MetadataInputBuffer buffer;
+
+    /* package */ PlayerTrackEmsgHandler(SampleQueue sampleQueue) {
+      this.sampleQueue = sampleQueue;
+
+      formatHolder = new FormatHolder();
+      buffer = new MetadataInputBuffer();
+    }
+
+    @Override
+    public void format(Format format) {
+      sampleQueue.format(format);
+    }
+
+    @Override
+    public int sampleData(ExtractorInput input, int length, boolean allowEndOfInput)
+        throws IOException, InterruptedException {
+      return sampleQueue.sampleData(input, length, allowEndOfInput);
+    }
+
+    @Override
+    public void sampleData(ParsableByteArray data, int length) {
+      sampleQueue.sampleData(data, length);
+    }
+
+    @Override
+    public void sampleMetadata(
+        long timeUs, int flags, int size, int offset, CryptoData encryptionData) {
+      sampleQueue.sampleMetadata(timeUs, flags, size, offset, encryptionData);
+      parseAndDiscardSamples();
+    }
+
+    /**
+     * For live streaming, check if the DASH manifest is expired before the next segment start time.
+     * If it is, the DASH media source will be notified to refresh the manifest.
+     *
+     * @param presentationPositionUs The next load position in presentation time.
+     * @return True if manifest refresh has been requested, false otherwise.
+     */
+    public boolean maybeRefreshManifestBeforeLoadingNextChunk(long presentationPositionUs) {
+      return PlayerEmsgHandler.this.maybeRefreshManifestBeforeLoadingNextChunk(
+          presentationPositionUs);
+    }
+
+    /**
+     * Called when the a new chunk in the current media stream has been loaded.
+     *
+     * @param chunk The chunk whose load has been completed.
+     */
+    public void onChunkLoadCompleted(Chunk chunk) {
+      PlayerEmsgHandler.this.onChunkLoadCompleted(chunk);
+    }
+
+    /**
+     * For live streaming with emsg event stream, forward seeking can seek pass the emsg messages
+     * that signals end-of-stream or Manifest expiry, which results in load error. In this case, we
+     * should notify the Dash media source to refresh its manifest.
+     *
+     * @param chunk The chunk whose load encountered the error.
+     * @return True if manifest refresh has been requested, false otherwise.
+     */
+    public boolean maybeRefreshManifestOnLoadingError(Chunk chunk) {
+      return PlayerEmsgHandler.this.maybeRefreshManifestOnLoadingError(chunk);
+    }
+
+    /** Release this track emsg handler. It should not be reused after this call. */
+    public void release() {
+      sampleQueue.reset();
+    }
+
+    // Internal methods.
+
+    private void parseAndDiscardSamples() {
+      while (sampleQueue.hasNextSample()) {
+        MetadataInputBuffer inputBuffer = dequeueSample();
+        if (inputBuffer == null) {
+          continue;
+        }
+        long eventTimeUs = inputBuffer.timeUs;
+        Metadata metadata = decoder.decode(inputBuffer);
+        EventMessage eventMessage = (EventMessage) metadata.get(0);
+        if (isPlayerEmsgEvent(eventMessage.schemeIdUri, eventMessage.value)) {
+          parsePlayerEmsgEvent(eventTimeUs, eventMessage);
+        }
+      }
+      sampleQueue.discardToRead();
+    }
+
+    @Nullable
+    private MetadataInputBuffer dequeueSample() {
+      buffer.clear();
+      int result = sampleQueue.read(formatHolder, buffer, false, false, 0);
+      if (result == C.RESULT_BUFFER_READ) {
+        buffer.flip();
+        return buffer;
+      }
+      return null;
+    }
+
+    private void parsePlayerEmsgEvent(long eventTimeUs, EventMessage eventMessage) {
+      long manifestPublishTimeMsInEmsg = getManifestPublishTimeMsInEmsg(eventMessage);
+      if (manifestPublishTimeMsInEmsg == C.TIME_UNSET) {
+        return;
+      }
+
+      if (isMessageSignalingMediaPresentationEnded(eventMessage)) {
+        onMediaPresentationEndedMessageEncountered();
+      } else {
+        onManifestExpiredMessageEncountered(eventTimeUs, manifestPublishTimeMsInEmsg);
+      }
+    }
+
+    private void onMediaPresentationEndedMessageEncountered() {
+      handler.sendMessage(handler.obtainMessage(EMSG_MEDIA_PRESENTATION_ENDED));
+    }
+
+    private void onManifestExpiredMessageEncountered(
+        long eventTimeUs, long manifestPublishTimeMsInEmsg) {
+      ManifestExpiryEventInfo manifestExpiryEventInfo =
+          new ManifestExpiryEventInfo(eventTimeUs, manifestPublishTimeMsInEmsg);
+      handler.sendMessage(handler.obtainMessage(EMSG_MANIFEST_EXPIRED, manifestExpiryEventInfo));
+    }
+  }
+
+  /** Holds information related to a manifest expiry event. */
+  private static final class ManifestExpiryEventInfo {
+
+    public final long eventTimeUs;
+    public final long manifestPublishTimeMsInEmsg;
+
+    public ManifestExpiryEventInfo(long eventTimeUs, long manifestPublishTimeMsInEmsg) {
+      this.eventTimeUs = eventTimeUs;
+      this.manifestPublishTimeMsInEmsg = manifestPublishTimeMsInEmsg;
+    }
+  }
+}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
index cd02e27fce..95fe938fa4 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifest.java
@@ -23,41 +23,81 @@
 import java.util.List;
 
 /**
- * Represents a DASH media presentation description (mpd).
+ * Represents a DASH media presentation description (mpd), as defined by ISO/IEC 23009-1:2014
+ * Section 5.3.1.2.
  */
 public class DashManifest {
 
-  public final long availabilityStartTime;
+  /**
+   * The {@code availabilityStartTime} value in milliseconds since epoch, or {@link C#TIME_UNSET} if
+   * not present.
+   */
+  public final long availabilityStartTimeMs;
 
-  public final long duration;
+  /**
+   * The duration of the presentation in milliseconds, or {@link C#TIME_UNSET} if not applicable.
+   */
+  public final long durationMs;
 
-  public final long minBufferTime;
+  /**
+   * The {@code minBufferTime} value in milliseconds, or {@link C#TIME_UNSET} if not present.
+   */
+  public final long minBufferTimeMs;
 
+  /**
+   * Whether the manifest has value "dynamic" for the {@code type} attribute.
+   */
   public final boolean dynamic;
 
-  public final long minUpdatePeriod;
+  /**
+   * The {@code minimumUpdatePeriod} value in milliseconds, or {@link C#TIME_UNSET} if not
+   * applicable.
+   */
+  public final long minUpdatePeriodMs;
 
-  public final long timeShiftBufferDepth;
+  /**
+   * The {@code timeShiftBufferDepth} value in milliseconds, or {@link C#TIME_UNSET} if not
+   * present.
+   */
+  public final long timeShiftBufferDepthMs;
 
-  public final long suggestedPresentationDelay;
+  /**
+   * The {@code suggestedPresentationDelay} value in milliseconds, or {@link C#TIME_UNSET} if not
+   * present.
+   */
+  public final long suggestedPresentationDelayMs;
+
+  /**
+   * The {@code publishTime} value in milliseconds since epoch, or {@link C#TIME_UNSET} if
+   * not present.
+   */
+  public final long publishTimeMs;
 
+  /**
+   * The {@link UtcTimingElement}, or null if not present. Defined in DVB A168:7/2016, Section
+   * 4.7.2.
+   */
   public final UtcTimingElement utcTiming;
 
+  /**
+   * The location of this manifest.
+   */
   public final Uri location;
 
   private final List<Period> periods;
 
-  public DashManifest(long availabilityStartTime, long duration, long minBufferTime,
-      boolean dynamic, long minUpdatePeriod, long timeShiftBufferDepth,
-      long suggestedPresentationDelay, UtcTimingElement utcTiming, Uri location,
-      List<Period> periods) {
-    this.availabilityStartTime = availabilityStartTime;
-    this.duration = duration;
-    this.minBufferTime = minBufferTime;
+  public DashManifest(long availabilityStartTimeMs, long durationMs, long minBufferTimeMs,
+      boolean dynamic, long minUpdatePeriodMs, long timeShiftBufferDepthMs,
+      long suggestedPresentationDelayMs, long publishTimeMs, UtcTimingElement utcTiming,
+      Uri location, List<Period> periods) {
+    this.availabilityStartTimeMs = availabilityStartTimeMs;
+    this.durationMs = durationMs;
+    this.minBufferTimeMs = minBufferTimeMs;
     this.dynamic = dynamic;
-    this.minUpdatePeriod = minUpdatePeriod;
-    this.timeShiftBufferDepth = timeShiftBufferDepth;
-    this.suggestedPresentationDelay = suggestedPresentationDelay;
+    this.minUpdatePeriodMs = minUpdatePeriodMs;
+    this.timeShiftBufferDepthMs = timeShiftBufferDepthMs;
+    this.suggestedPresentationDelayMs = suggestedPresentationDelayMs;
+    this.publishTimeMs = publishTimeMs;
     this.utcTiming = utcTiming;
     this.location = location;
     this.periods = periods == null ? Collections.<Period>emptyList() : periods;
@@ -73,7 +113,7 @@ public final Period getPeriod(int index) {
 
   public final long getPeriodDurationMs(int index) {
     return index == periods.size() - 1
-        ? (duration == C.TIME_UNSET ? C.TIME_UNSET : (duration - periods.get(index).startMs))
+        ? (durationMs == C.TIME_UNSET ? C.TIME_UNSET : (durationMs - periods.get(index).startMs))
         : (periods.get(index + 1).startMs - periods.get(index).startMs);
   }
 
@@ -107,13 +147,15 @@ public final DashManifest copy(List<RepresentationKey> representationKeys) {
         Period period = getPeriod(periodIndex);
         ArrayList<AdaptationSet> copyAdaptationSets =
             copyAdaptationSets(period.adaptationSets, keys);
-        copyPeriods.add(new Period(period.id, period.startMs - shiftMs, copyAdaptationSets));
+        Period copiedPeriod = new Period(period.id, period.startMs - shiftMs, copyAdaptationSets,
+            period.eventStreams);
+        copyPeriods.add(copiedPeriod);
       }
     }
-    long newDuration = duration != C.TIME_UNSET ? duration - shiftMs : C.TIME_UNSET;
-    return new DashManifest(availabilityStartTime, newDuration, minBufferTime, dynamic,
-        minUpdatePeriod, timeShiftBufferDepth, suggestedPresentationDelay, utcTiming, location,
-        copyPeriods);
+    long newDuration = durationMs != C.TIME_UNSET ? durationMs - shiftMs : C.TIME_UNSET;
+    return new DashManifest(availabilityStartTimeMs, newDuration, minBufferTimeMs, dynamic,
+        minUpdatePeriodMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs, publishTimeMs,
+        utcTiming, location, copyPeriods);
   }
 
   private static ArrayList<AdaptationSet> copyAdaptationSets(
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
index 7ffb429784..aeae720517 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParser.java
@@ -20,12 +20,14 @@
 import android.util.Base64;
 import android.util.Log;
 import android.util.Pair;
+import android.util.Xml;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.drm.DrmInitData;
 import com.google.android.exoplayer2.drm.DrmInitData.SchemeData;
 import com.google.android.exoplayer2.extractor.mp4.PsshAtomUtil;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SegmentList;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SegmentTemplate;
 import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SegmentTimelineElement;
@@ -36,6 +38,7 @@
 import com.google.android.exoplayer2.util.UriUtil;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.util.XmlPullParserUtil;
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
@@ -47,6 +50,7 @@
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 import org.xmlpull.v1.XmlPullParserFactory;
+import org.xmlpull.v1.XmlSerializer;
 
 /**
  * A parser of media presentation description files.
@@ -115,6 +119,7 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
         ? parseDuration(xpp, "timeShiftBufferDepth", C.TIME_UNSET) : C.TIME_UNSET;
     long suggestedPresentationDelayMs = dynamic
         ? parseDuration(xpp, "suggestedPresentationDelay", C.TIME_UNSET) : C.TIME_UNSET;
+    long publishTimeMs = parseDateTime(xpp, "publishTime", C.TIME_UNSET);
     UtcTimingElement utcTiming = null;
     Uri location = null;
 
@@ -167,17 +172,17 @@ protected DashManifest parseMediaPresentationDescription(XmlPullParser xpp,
     }
 
     return buildMediaPresentationDescription(availabilityStartTime, durationMs, minBufferTimeMs,
-        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs, utcTiming,
-        location, periods);
+        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs,
+        publishTimeMs, utcTiming, location, periods);
   }
 
   protected DashManifest buildMediaPresentationDescription(long availabilityStartTime,
       long durationMs, long minBufferTimeMs, boolean dynamic, long minUpdateTimeMs,
-      long timeShiftBufferDepthMs, long suggestedPresentationDelayMs, UtcTimingElement utcTiming,
-      Uri location, List<Period> periods) {
+      long timeShiftBufferDepthMs, long suggestedPresentationDelayMs, long publishTimeMs,
+      UtcTimingElement utcTiming, Uri location, List<Period> periods) {
     return new DashManifest(availabilityStartTime, durationMs, minBufferTimeMs,
-        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs, utcTiming,
-        location, periods);
+        dynamic, minUpdateTimeMs, timeShiftBufferDepthMs, suggestedPresentationDelayMs,
+        publishTimeMs, utcTiming, location, periods);
   }
 
   protected UtcTimingElement parseUtcTiming(XmlPullParser xpp) {
@@ -197,6 +202,7 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
     long durationMs = parseDuration(xpp, "duration", C.TIME_UNSET);
     SegmentBase segmentBase = null;
     List<AdaptationSet> adaptationSets = new ArrayList<>();
+    List<EventStream> eventStreams = new ArrayList<>();
     boolean seenFirstBaseUrl = false;
     do {
       xpp.next();
@@ -207,6 +213,8 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
         }
       } else if (XmlPullParserUtil.isStartTag(xpp, "AdaptationSet")) {
         adaptationSets.add(parseAdaptationSet(xpp, baseUrl, segmentBase));
+      } else if (XmlPullParserUtil.isStartTag(xpp, "EventStream")) {
+        eventStreams.add(parseEventStream(xpp));
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentBase")) {
         segmentBase = parseSegmentBase(xpp, null);
       } else if (XmlPullParserUtil.isStartTag(xpp, "SegmentList")) {
@@ -216,11 +224,12 @@ protected UtcTimingElement buildUtcTimingElement(String schemeIdUri, String valu
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Period"));
 
-    return Pair.create(buildPeriod(id, startMs, adaptationSets), durationMs);
+    return Pair.create(buildPeriod(id, startMs, adaptationSets, eventStreams), durationMs);
   }
 
-  protected Period buildPeriod(String id, long startMs, List<AdaptationSet> adaptationSets) {
-    return new Period(id, startMs, adaptationSets);
+  protected Period buildPeriod(String id, long startMs, List<AdaptationSet> adaptationSets,
+      List<EventStream> eventStreams) {
+    return new Period(id, startMs, adaptationSets, eventStreams);
   }
 
   // AdaptationSet parsing.
@@ -356,9 +365,14 @@ protected int getContentType(Format format) {
         case "urn:mpeg:dash:mp4protection:2011":
           schemeType = xpp.getAttributeValue(null, "value");
           String defaultKid = xpp.getAttributeValue(null, "cenc:default_KID");
-          if (defaultKid != null && !"00000000-0000-0000-0000-000000000000".equals(defaultKid)) {
-            UUID keyId = UUID.fromString(defaultKid);
-            data = PsshAtomUtil.buildPsshAtom(C.COMMON_PSSH_UUID, new UUID[] {keyId}, null);
+          if (!TextUtils.isEmpty(defaultKid)
+              && !"00000000-0000-0000-0000-000000000000".equals(defaultKid)) {
+            String[] defaultKidStrings = defaultKid.split("\\s+");
+            UUID[] defaultKids = new UUID[defaultKidStrings.length];
+            for (int i = 0; i < defaultKidStrings.length; i++) {
+              defaultKids[i] = UUID.fromString(defaultKidStrings[i]);
+            }
+            data = PsshAtomUtil.buildPsshAtom(C.COMMON_PSSH_UUID, defaultKids, null);
             uuid = C.COMMON_PSSH_UUID;
           }
           break;
@@ -387,7 +401,7 @@ protected int getContentType(Format format) {
             Log.w(TAG, "Skipping malformed cenc:pssh data");
             data = null;
           }
-        } else if (uuid == C.PLAYREADY_UUID && XmlPullParserUtil.isStartTag(xpp, "mspr:pro")
+        } else if (C.PLAYREADY_UUID.equals(uuid) && XmlPullParserUtil.isStartTag(xpp, "mspr:pro")
             && xpp.next() == XmlPullParser.TEXT) {
           // The mspr:pro element is defined in DASH Content Protection using Microsoft PlayReady.
           data = PsshAtomUtil.buildPsshAtom(C.PLAYREADY_UUID,
@@ -452,6 +466,7 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
     String drmSchemeType = null;
     ArrayList<SchemeData> drmSchemeDatas = new ArrayList<>();
     ArrayList<Descriptor> inbandEventStreams = new ArrayList<>();
+    ArrayList<Descriptor> supplementalProperties = new ArrayList<>();
 
     boolean seenFirstBaseUrl = false;
     do {
@@ -479,24 +494,29 @@ protected RepresentationInfo parseRepresentation(XmlPullParser xpp, String baseU
         }
       } else if (XmlPullParserUtil.isStartTag(xpp, "InbandEventStream")) {
         inbandEventStreams.add(parseDescriptor(xpp, "InbandEventStream"));
+      } else if (XmlPullParserUtil.isStartTag(xpp, "SupplementalProperty")) {
+        supplementalProperties.add(parseDescriptor(xpp, "SupplementalProperty"));
       }
     } while (!XmlPullParserUtil.isEndTag(xpp, "Representation"));
 
     Format format = buildFormat(id, mimeType, width, height, frameRate, audioChannels,
         audioSamplingRate, bandwidth, adaptationSetLanguage, adaptationSetSelectionFlags,
-        adaptationSetAccessibilityDescriptors, codecs);
+        adaptationSetAccessibilityDescriptors, codecs, supplementalProperties);
     segmentBase = segmentBase != null ? segmentBase : new SingleSegmentBase();
 
     return new RepresentationInfo(format, baseUrl, segmentBase, drmSchemeType, drmSchemeDatas,
-        inbandEventStreams);
+        inbandEventStreams, Representation.REVISION_ID_DEFAULT);
   }
 
   protected Format buildFormat(String id, String containerMimeType, int width, int height,
       float frameRate, int audioChannels, int audioSamplingRate, int bitrate, String language,
       @C.SelectionFlags int selectionFlags, List<Descriptor> accessibilityDescriptors,
-      String codecs) {
+      String codecs, List<Descriptor> supplementalProperties) {
     String sampleMimeType = getSampleMimeType(containerMimeType, codecs);
     if (sampleMimeType != null) {
+      if (MimeTypes.AUDIO_E_AC3.equals(sampleMimeType)) {
+        sampleMimeType = parseEac3SupplementalProperties(supplementalProperties);
+      }
       if (MimeTypes.isVideo(sampleMimeType)) {
         return Format.createVideoContainerFormat(id, containerMimeType, sampleMimeType, codecs,
             bitrate, width, height, frameRate, null, selectionFlags);
@@ -535,7 +555,7 @@ protected Representation buildRepresentation(RepresentationInfo representationIn
     }
     ArrayList<Descriptor> inbandEventStreams = representationInfo.inbandEventStreams;
     inbandEventStreams.addAll(extraInbandEventStreams);
-    return Representation.newInstance(contentId, Representation.REVISION_ID_DEFAULT, format,
+    return Representation.newInstance(contentId, representationInfo.revisionId, format,
         representationInfo.baseUrl, representationInfo.segmentBase, inbandEventStreams);
   }
 
@@ -582,7 +602,7 @@ protected SegmentList parseSegmentList(XmlPullParser xpp, SegmentList parent)
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
         parent != null ? parent.presentationTimeOffset : 0);
     long duration = parseLong(xpp, "duration", parent != null ? parent.duration : C.TIME_UNSET);
-    int startNumber = parseInt(xpp, "startNumber", parent != null ? parent.startNumber : 1);
+    long startNumber = parseLong(xpp, "startNumber", parent != null ? parent.startNumber : 1);
 
     RangedUri initialization = null;
     List<SegmentTimelineElement> timeline = null;
@@ -612,9 +632,14 @@ protected SegmentList parseSegmentList(XmlPullParser xpp, SegmentList parent)
         startNumber, duration, timeline, segments);
   }
 
-  protected SegmentList buildSegmentList(RangedUri initialization, long timescale,
-      long presentationTimeOffset, int startNumber, long duration,
-      List<SegmentTimelineElement> timeline, List<RangedUri> segments) {
+  protected SegmentList buildSegmentList(
+      RangedUri initialization,
+      long timescale,
+      long presentationTimeOffset,
+      long startNumber,
+      long duration,
+      List<SegmentTimelineElement> timeline,
+      List<RangedUri> segments) {
     return new SegmentList(initialization, timescale, presentationTimeOffset,
         startNumber, duration, timeline, segments);
   }
@@ -625,7 +650,7 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplat
     long presentationTimeOffset = parseLong(xpp, "presentationTimeOffset",
         parent != null ? parent.presentationTimeOffset : 0);
     long duration = parseLong(xpp, "duration", parent != null ? parent.duration : C.TIME_UNSET);
-    int startNumber = parseInt(xpp, "startNumber", parent != null ? parent.startNumber : 1);
+    long startNumber = parseLong(xpp, "startNumber", parent != null ? parent.startNumber : 1);
     UrlTemplate mediaTemplate = parseUrlTemplate(xpp, "media",
         parent != null ? parent.mediaTemplate : null);
     UrlTemplate initializationTemplate = parseUrlTemplate(xpp, "initialization",
@@ -652,14 +677,154 @@ protected SegmentTemplate parseSegmentTemplate(XmlPullParser xpp, SegmentTemplat
         startNumber, duration, timeline, initializationTemplate, mediaTemplate);
   }
 
-  protected SegmentTemplate buildSegmentTemplate(RangedUri initialization, long timescale,
-      long presentationTimeOffset, int startNumber, long duration,
-      List<SegmentTimelineElement> timeline, UrlTemplate initializationTemplate,
+  protected SegmentTemplate buildSegmentTemplate(
+      RangedUri initialization,
+      long timescale,
+      long presentationTimeOffset,
+      long startNumber,
+      long duration,
+      List<SegmentTimelineElement> timeline,
+      UrlTemplate initializationTemplate,
       UrlTemplate mediaTemplate) {
     return new SegmentTemplate(initialization, timescale, presentationTimeOffset,
         startNumber, duration, timeline, initializationTemplate, mediaTemplate);
   }
 
+  /**
+   * /**
+   * Parses a single EventStream node in the manifest.
+   * <p>
+   * @param xpp The current xml parser.
+   * @return The {@link EventStream} parsed from this EventStream node.
+   * @throws XmlPullParserException If there is any error parsing this node.
+   * @throws IOException If there is any error reading from the underlying input stream.
+   */
+  protected EventStream parseEventStream(XmlPullParser xpp)
+      throws XmlPullParserException, IOException {
+    String schemeIdUri = parseString(xpp, "schemeIdUri", "");
+    String value = parseString(xpp, "value", "");
+    long timescale = parseLong(xpp, "timescale", 1);
+    List<EventMessage> eventMessages = new ArrayList<>();
+    ByteArrayOutputStream scratchOutputStream = new ByteArrayOutputStream(512);
+    do {
+      xpp.next();
+      if (XmlPullParserUtil.isStartTag(xpp, "Event")) {
+        EventMessage event = parseEvent(xpp, schemeIdUri, value, timescale,
+            scratchOutputStream);
+        eventMessages.add(event);
+      }
+    } while (!XmlPullParserUtil.isEndTag(xpp, "EventStream"));
+
+    long[] presentationTimesUs = new long[eventMessages.size()];
+    EventMessage[] events = new EventMessage[eventMessages.size()];
+    for (int i = 0; i < eventMessages.size(); i++) {
+      EventMessage event = eventMessages.get(i);
+      presentationTimesUs[i] = event.presentationTimeUs;
+      events[i] = event;
+    }
+    return buildEventStream(schemeIdUri, value, timescale, presentationTimesUs, events);
+  }
+
+  protected EventStream buildEventStream(String schemeIdUri, String value, long timescale,
+      long[] presentationTimesUs, EventMessage[] events) {
+    return new EventStream(schemeIdUri, value, timescale, presentationTimesUs, events);
+  }
+
+  /**
+   * Parses a single Event node in the manifest.
+   * <p>
+   * @param xpp The current xml parser.
+   * @param schemeIdUri The schemeIdUri of the parent EventStream.
+   * @param value The schemeIdUri of the parent EventStream.
+   * @param timescale The timescale of the parent EventStream.
+   * @param scratchOutputStream A {@link ByteArrayOutputStream} that's used when parsing event
+   *     objects.
+   * @return The {@link EventMessage} parsed from this EventStream node.
+   * @throws XmlPullParserException If there is any error parsing this node.
+   * @throws IOException If there is any error reading from the underlying input stream.
+   */
+  protected EventMessage parseEvent(XmlPullParser xpp, String schemeIdUri, String value,
+      long timescale, ByteArrayOutputStream scratchOutputStream)
+      throws IOException, XmlPullParserException {
+    long id = parseLong(xpp, "id", 0);
+    long duration = parseLong(xpp, "duration", C.TIME_UNSET);
+    long presentationTime = parseLong(xpp, "presentationTime", 0);
+    long durationMs = Util.scaleLargeTimestamp(duration, 1000, timescale);
+    long presentationTimesUs = Util.scaleLargeTimestamp(presentationTime, C.MICROS_PER_SECOND,
+        timescale);
+    byte[] eventObject = parseEventObject(xpp, scratchOutputStream);
+    return buildEvent(schemeIdUri, value, id, durationMs, eventObject, presentationTimesUs);
+  }
+
+  /**
+   * Parses an event object.
+   *
+   * @param xpp The current xml parser.
+   * @param scratchOutputStream A {@link ByteArrayOutputStream} that's used when parsing the object.
+   * @return The serialized byte array.
+   * @throws XmlPullParserException If there is any error parsing this node.
+   * @throws IOException If there is any error reading from the underlying input stream.
+   */
+  protected byte[] parseEventObject(XmlPullParser xpp, ByteArrayOutputStream scratchOutputStream)
+      throws XmlPullParserException, IOException {
+    scratchOutputStream.reset();
+    XmlSerializer xmlSerializer = Xml.newSerializer();
+    xmlSerializer.setOutput(scratchOutputStream, null);
+    // Start reading everything between <Event> and </Event>, and serialize them into an Xml
+    // byte array.
+    xpp.nextToken();
+    while (!XmlPullParserUtil.isEndTag(xpp, "Event")) {
+      switch (xpp.getEventType()) {
+        case (XmlPullParser.START_DOCUMENT):
+          xmlSerializer.startDocument(null, false);
+          break;
+        case (XmlPullParser.END_DOCUMENT):
+          xmlSerializer.endDocument();
+          break;
+        case (XmlPullParser.START_TAG):
+          xmlSerializer.startTag(xpp.getNamespace(), xpp.getName());
+          for (int i = 0; i < xpp.getAttributeCount(); i++) {
+            xmlSerializer.attribute(xpp.getAttributeNamespace(i), xpp.getAttributeName(i),
+                xpp.getAttributeValue(i));
+          }
+          break;
+        case (XmlPullParser.END_TAG):
+          xmlSerializer.endTag(xpp.getNamespace(), xpp.getName());
+          break;
+        case (XmlPullParser.TEXT):
+          xmlSerializer.text(xpp.getText());
+          break;
+        case (XmlPullParser.CDSECT):
+          xmlSerializer.cdsect(xpp.getText());
+          break;
+        case (XmlPullParser.ENTITY_REF):
+          xmlSerializer.entityRef(xpp.getText());
+          break;
+        case (XmlPullParser.IGNORABLE_WHITESPACE):
+          xmlSerializer.ignorableWhitespace(xpp.getText());
+          break;
+        case (XmlPullParser.PROCESSING_INSTRUCTION):
+          xmlSerializer.processingInstruction(xpp.getText());
+          break;
+        case (XmlPullParser.COMMENT):
+          xmlSerializer.comment(xpp.getText());
+          break;
+        case (XmlPullParser.DOCDECL):
+          xmlSerializer.docdecl(xpp.getText());
+          break;
+        default: // fall out
+      }
+      xpp.nextToken();
+    }
+    xmlSerializer.flush();
+    return scratchOutputStream.toByteArray();
+  }
+
+  protected EventMessage buildEvent(String schemeIdUri, String value, long id,
+      long durationMs, byte[] messageData, long presentationTimeUs) {
+    return new EventMessage(schemeIdUri, value, durationMs, id, messageData, presentationTimeUs);
+  }
+
   protected List<SegmentTimelineElement> parseSegmentTimeline(XmlPullParser xpp)
       throws XmlPullParserException, IOException {
     List<SegmentTimelineElement> segmentTimeline = new ArrayList<>();
@@ -900,6 +1065,18 @@ protected static int parseCea708AccessibilityChannel(
     return Format.NO_VALUE;
   }
 
+  protected static String parseEac3SupplementalProperties(List<Descriptor> supplementalProperties) {
+    for (int i = 0; i < supplementalProperties.size(); i++) {
+      Descriptor descriptor = supplementalProperties.get(i);
+      String schemeIdUri = descriptor.schemeIdUri;
+      if ("tag:dolby.com,2014:dash:DolbyDigitalPlusExtensionType:2014".equals(schemeIdUri)
+          && "ec+3".equals(descriptor.value)) {
+        return MimeTypes.AUDIO_E_AC3_JOC;
+      }
+    }
+    return MimeTypes.AUDIO_E_AC3;
+  }
+
   protected static float parseFrameRate(XmlPullParser xpp, float defaultValue) {
     float frameRate = defaultValue;
     String frameRateAttribute = xpp.getAttributeValue(null, "frameRate");
@@ -986,7 +1163,8 @@ protected static int parseDolbyChannelConfiguration(XmlPullParser xpp) {
     }
   }
 
-  private static final class RepresentationInfo {
+  /** A parsed Representation element. */
+  protected static final class RepresentationInfo {
 
     public final Format format;
     public final String baseUrl;
@@ -994,16 +1172,18 @@ protected static int parseDolbyChannelConfiguration(XmlPullParser xpp) {
     public final String drmSchemeType;
     public final ArrayList<SchemeData> drmSchemeDatas;
     public final ArrayList<Descriptor> inbandEventStreams;
+    public final long revisionId;
 
     public RepresentationInfo(Format format, String baseUrl, SegmentBase segmentBase,
         String drmSchemeType, ArrayList<SchemeData> drmSchemeDatas,
-        ArrayList<Descriptor> inbandEventStreams) {
+        ArrayList<Descriptor> inbandEventStreams, long revisionId) {
       this.format = format;
       this.baseUrl = baseUrl;
       this.segmentBase = segmentBase;
       this.drmSchemeType = drmSchemeType;
       this.drmSchemeDatas = drmSchemeDatas;
       this.inbandEventStreams = inbandEventStreams;
+      this.revisionId = revisionId;
     }
 
   }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/EventStream.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/EventStream.java
new file mode 100644
index 0000000000..8a4e1ad058
--- /dev/null
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/EventStream.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
+
+/**
+ * A DASH in-MPD EventStream element, as defined by ISO/IEC 23009-1, 2nd edition, section 5.10.
+ */
+public final class EventStream {
+
+  /**
+   * {@link EventMessage}s in the event stream.
+   */
+  public final EventMessage[] events;
+
+  /**
+   * Presentation time of the events in microsecond, sorted in ascending order.
+   */
+  public final long[] presentationTimesUs;
+
+  /**
+   * The scheme URI.
+   */
+  public final String schemeIdUri;
+
+  /**
+   * The value of the event stream. Use empty string if not defined in manifest.
+   */
+  public final String value;
+
+  /**
+   * The timescale in units per seconds, as defined in the manifest.
+   */
+  public final long timescale;
+
+  public EventStream(String schemeIdUri, String value, long timescale, long[] presentationTimesUs,
+      EventMessage[] events) {
+    this.schemeIdUri = schemeIdUri;
+    this.value = value;
+    this.timescale = timescale;
+    this.presentationTimesUs = presentationTimesUs;
+    this.events = events;
+  }
+
+  /**
+   * A constructed id of this {@link EventStream}. Equal to {@code schemeIdUri + "/" + value}.
+   */
+  public String id() {
+    return schemeIdUri + "/" + value;
+  }
+
+}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/FilteringDashManifestParser.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/FilteringDashManifestParser.java
new file mode 100644
index 0000000000..84c899f6c2
--- /dev/null
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/FilteringDashManifestParser.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.upstream.ParsingLoadable.Parser;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+
+/**
+ * A parser of media presentation description files which includes only the representations
+ * identified by the given keys.
+ */
+public final class FilteringDashManifestParser implements Parser<DashManifest> {
+
+  private final DashManifestParser dashManifestParser;
+  private final ArrayList<RepresentationKey> filter;
+
+  /** @param filter The representation keys that should be retained in the parsed manifests. */
+  public FilteringDashManifestParser(ArrayList<RepresentationKey> filter) {
+    this.dashManifestParser = new DashManifestParser();
+    this.filter = filter;
+  }
+
+  @Override
+  public DashManifest parse(Uri uri, InputStream inputStream) throws IOException {
+    return dashManifestParser.parse(uri, inputStream).copy(filter);
+  }
+}
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
index 269a63b7a9..bb1dbdac5d 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Period.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer2.source.dash.manifest;
 
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import java.util.Collections;
 import java.util.List;
@@ -27,7 +28,7 @@
   /**
    * The period identifier, if one exists.
    */
-  public final String id;
+  @Nullable public final String id;
 
   /**
    * The start time of the period in milliseconds.
@@ -39,15 +40,32 @@
    */
   public final List<AdaptationSet> adaptationSets;
 
+  /**
+   * The event stream belonging to the period.
+   */
+  public final List<EventStream> eventStreams;
+
+  /**
+   * @param id The period identifier. May be null.
+   * @param startMs The start time of the period in milliseconds.
+   * @param adaptationSets The adaptation sets belonging to the period.
+   */
+  public Period(@Nullable String id, long startMs, List<AdaptationSet> adaptationSets) {
+    this(id, startMs, adaptationSets, Collections.<EventStream>emptyList());
+  }
+
   /**
    * @param id The period identifier. May be null.
    * @param startMs The start time of the period in milliseconds.
    * @param adaptationSets The adaptation sets belonging to the period.
+   * @param eventStreams The {@link EventStream}s belonging to the period.
    */
-  public Period(String id, long startMs, List<AdaptationSet> adaptationSets) {
+  public Period(@Nullable String id, long startMs, List<AdaptationSet> adaptationSets,
+      List<EventStream> eventStreams) {
     this.id = id;
     this.startMs = startMs;
     this.adaptationSets = Collections.unmodifiableList(adaptationSets);
+    this.eventStreams = Collections.unmodifiableList(eventStreams);
   }
 
   /**
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
index 81e4602c1d..71a3a0122c 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/Representation.java
@@ -292,27 +292,27 @@ public String getCacheKey() {
     // DashSegmentIndex implementation.
 
     @Override
-    public RangedUri getSegmentUrl(int segmentIndex) {
+    public RangedUri getSegmentUrl(long segmentIndex) {
       return segmentBase.getSegmentUrl(this, segmentIndex);
     }
 
     @Override
-    public int getSegmentNum(long timeUs, long periodDurationUs) {
+    public long getSegmentNum(long timeUs, long periodDurationUs) {
       return segmentBase.getSegmentNum(timeUs, periodDurationUs);
     }
 
     @Override
-    public long getTimeUs(int segmentIndex) {
+    public long getTimeUs(long segmentIndex) {
       return segmentBase.getSegmentTimeUs(segmentIndex);
     }
 
     @Override
-    public long getDurationUs(int segmentIndex, long periodDurationUs) {
+    public long getDurationUs(long segmentIndex, long periodDurationUs) {
       return segmentBase.getSegmentDurationUs(segmentIndex, periodDurationUs);
     }
 
     @Override
-    public int getFirstSegmentNum() {
+    public long getFirstSegmentNum() {
       return segmentBase.getFirstSegmentNum();
     }
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
index 4f7dc81fc5..f033232590 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SegmentBase.java
@@ -99,7 +99,7 @@ public RangedUri getIndex() {
    */
   public abstract static class MultiSegmentBase extends SegmentBase {
 
-    /* package */ final int startNumber;
+    /* package */ final long startNumber;
     /* package */ final long duration;
     /* package */ final List<SegmentTimelineElement> segmentTimeline;
 
@@ -111,43 +111,46 @@ public RangedUri getIndex() {
      *     division of this value and {@code timescale}.
      * @param startNumber The sequence number of the first segment.
      * @param duration The duration of each segment in the case of fixed duration segments. The
-     *     value in seconds is the division of this value and {@code timescale}. If
-     *     {@code segmentTimeline} is non-null then this parameter is ignored.
+     *     value in seconds is the division of this value and {@code timescale}. If {@code
+     *     segmentTimeline} is non-null then this parameter is ignored.
      * @param segmentTimeline A segment timeline corresponding to the segments. If null, then
      *     segments are assumed to be of fixed duration as specified by the {@code duration}
      *     parameter.
      */
-    public MultiSegmentBase(RangedUri initialization, long timescale, long presentationTimeOffset,
-        int startNumber, long duration, List<SegmentTimelineElement> segmentTimeline) {
+    public MultiSegmentBase(
+        RangedUri initialization,
+        long timescale,
+        long presentationTimeOffset,
+        long startNumber,
+        long duration,
+        List<SegmentTimelineElement> segmentTimeline) {
       super(initialization, timescale, presentationTimeOffset);
       this.startNumber = startNumber;
       this.duration = duration;
       this.segmentTimeline = segmentTimeline;
     }
 
-    /**
-     * @see DashSegmentIndex#getSegmentNum(long, long)
-     */
-    public int getSegmentNum(long timeUs, long periodDurationUs) {
-      final int firstSegmentNum = getFirstSegmentNum();
-      final int segmentCount = getSegmentCount(periodDurationUs);
+    /** @see DashSegmentIndex#getSegmentNum(long, long) */
+    public long getSegmentNum(long timeUs, long periodDurationUs) {
+      final long firstSegmentNum = getFirstSegmentNum();
+      final long segmentCount = getSegmentCount(periodDurationUs);
       if (segmentCount == 0) {
         return firstSegmentNum;
       }
       if (segmentTimeline == null) {
         // All segments are of equal duration (with the possible exception of the last one).
         long durationUs = (duration * C.MICROS_PER_SECOND) / timescale;
-        int segmentNum = startNumber + (int) (timeUs / durationUs);
+        long segmentNum = startNumber + timeUs / durationUs;
         // Ensure we stay within bounds.
         return segmentNum < firstSegmentNum ? firstSegmentNum
             : segmentCount == DashSegmentIndex.INDEX_UNBOUNDED ? segmentNum
             : Math.min(segmentNum, firstSegmentNum + segmentCount - 1);
       } else {
         // The index cannot be unbounded. Identify the segment using binary search.
-        int lowIndex = firstSegmentNum;
-        int highIndex = firstSegmentNum + segmentCount - 1;
+        long lowIndex = firstSegmentNum;
+        long highIndex = firstSegmentNum + segmentCount - 1;
         while (lowIndex <= highIndex) {
-          int midIndex = lowIndex + (highIndex - lowIndex) / 2;
+          long midIndex = lowIndex + (highIndex - lowIndex) / 2;
           long midTimeUs = getSegmentTimeUs(midIndex);
           if (midTimeUs < timeUs) {
             lowIndex = midIndex + 1;
@@ -161,12 +164,10 @@ public int getSegmentNum(long timeUs, long periodDurationUs) {
       }
     }
 
-    /**
-     * @see DashSegmentIndex#getDurationUs(int, long)
-     */
-    public final long getSegmentDurationUs(int sequenceNumber, long periodDurationUs) {
+    /** @see DashSegmentIndex#getDurationUs(long, long) */
+    public final long getSegmentDurationUs(long sequenceNumber, long periodDurationUs) {
       if (segmentTimeline != null) {
-        long duration = segmentTimeline.get(sequenceNumber - startNumber).duration;
+        long duration = segmentTimeline.get((int) (sequenceNumber - startNumber)).duration;
         return (duration * C.MICROS_PER_SECOND) / timescale;
       } else {
         int segmentCount = getSegmentCount(periodDurationUs);
@@ -177,14 +178,13 @@ public final long getSegmentDurationUs(int sequenceNumber, long periodDurationUs
       }
     }
 
-    /**
-     * @see DashSegmentIndex#getTimeUs(int)
-     */
-    public final long getSegmentTimeUs(int sequenceNumber) {
+    /** @see DashSegmentIndex#getTimeUs(long) */
+    public final long getSegmentTimeUs(long sequenceNumber) {
       long unscaledSegmentTime;
       if (segmentTimeline != null) {
-        unscaledSegmentTime = segmentTimeline.get(sequenceNumber - startNumber).startTime
-            - presentationTimeOffset;
+        unscaledSegmentTime =
+            segmentTimeline.get((int) (sequenceNumber - startNumber)).startTime
+                - presentationTimeOffset;
       } else {
         unscaledSegmentTime = (sequenceNumber - startNumber) * duration;
       }
@@ -195,14 +195,12 @@ public final long getSegmentTimeUs(int sequenceNumber) {
      * Returns a {@link RangedUri} defining the location of a segment for the given index in the
      * given representation.
      *
-     * @see DashSegmentIndex#getSegmentUrl(int)
+     * @see DashSegmentIndex#getSegmentUrl(long)
      */
-    public abstract RangedUri getSegmentUrl(Representation representation, int index);
+    public abstract RangedUri getSegmentUrl(Representation representation, long index);
 
-    /**
-     * @see DashSegmentIndex#getFirstSegmentNum()
-     */
-    public int getFirstSegmentNum() {
+    /** @see DashSegmentIndex#getFirstSegmentNum() */
+    public long getFirstSegmentNum() {
       return startNumber;
     }
 
@@ -235,15 +233,20 @@ public boolean isExplicit() {
      *     division of this value and {@code timescale}.
      * @param startNumber The sequence number of the first segment.
      * @param duration The duration of each segment in the case of fixed duration segments. The
-     *     value in seconds is the division of this value and {@code timescale}. If
-     *     {@code segmentTimeline} is non-null then this parameter is ignored.
+     *     value in seconds is the division of this value and {@code timescale}. If {@code
+     *     segmentTimeline} is non-null then this parameter is ignored.
      * @param segmentTimeline A segment timeline corresponding to the segments. If null, then
      *     segments are assumed to be of fixed duration as specified by the {@code duration}
      *     parameter.
      * @param mediaSegments A list of {@link RangedUri}s indicating the locations of the segments.
      */
-    public SegmentList(RangedUri initialization, long timescale, long presentationTimeOffset,
-        int startNumber, long duration, List<SegmentTimelineElement> segmentTimeline,
+    public SegmentList(
+        RangedUri initialization,
+        long timescale,
+        long presentationTimeOffset,
+        long startNumber,
+        long duration,
+        List<SegmentTimelineElement> segmentTimeline,
         List<RangedUri> mediaSegments) {
       super(initialization, timescale, presentationTimeOffset, startNumber, duration,
           segmentTimeline);
@@ -251,8 +254,8 @@ public SegmentList(RangedUri initialization, long timescale, long presentationTi
     }
 
     @Override
-    public RangedUri getSegmentUrl(Representation representation, int sequenceNumber) {
-      return mediaSegments.get(sequenceNumber - startNumber);
+    public RangedUri getSegmentUrl(Representation representation, long sequenceNumber) {
+      return mediaSegments.get((int) (sequenceNumber - startNumber));
     }
 
     @Override
@@ -284,8 +287,8 @@ public boolean isExplicit() {
      *     division of this value and {@code timescale}.
      * @param startNumber The sequence number of the first segment.
      * @param duration The duration of each segment in the case of fixed duration segments. The
-     *     value in seconds is the division of this value and {@code timescale}. If
-     *     {@code segmentTimeline} is non-null then this parameter is ignored.
+     *     value in seconds is the division of this value and {@code timescale}. If {@code
+     *     segmentTimeline} is non-null then this parameter is ignored.
      * @param segmentTimeline A segment timeline corresponding to the segments. If null, then
      *     segments are assumed to be of fixed duration as specified by the {@code duration}
      *     parameter.
@@ -294,9 +297,15 @@ public boolean isExplicit() {
      *     null then {@code initialization} will be used.
      * @param mediaTemplate A template defining the location of each media segment.
      */
-    public SegmentTemplate(RangedUri initialization, long timescale, long presentationTimeOffset,
-        int startNumber, long duration, List<SegmentTimelineElement> segmentTimeline,
-        UrlTemplate initializationTemplate, UrlTemplate mediaTemplate) {
+    public SegmentTemplate(
+        RangedUri initialization,
+        long timescale,
+        long presentationTimeOffset,
+        long startNumber,
+        long duration,
+        List<SegmentTimelineElement> segmentTimeline,
+        UrlTemplate initializationTemplate,
+        UrlTemplate mediaTemplate) {
       super(initialization, timescale, presentationTimeOffset, startNumber,
           duration, segmentTimeline);
       this.initializationTemplate = initializationTemplate;
@@ -315,10 +324,10 @@ public RangedUri getInitialization(Representation representation) {
     }
 
     @Override
-    public RangedUri getSegmentUrl(Representation representation, int sequenceNumber) {
+    public RangedUri getSegmentUrl(Representation representation, long sequenceNumber) {
       long time;
       if (segmentTimeline != null) {
-        time = segmentTimeline.get(sequenceNumber - startNumber).startTime;
+        time = segmentTimeline.get((int) (sequenceNumber - startNumber)).startTime;
       } else {
         time = (sequenceNumber - startNumber) * duration;
       }
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SingleSegmentIndex.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SingleSegmentIndex.java
index 4ce49c5ffe..a56a11fe50 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SingleSegmentIndex.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/SingleSegmentIndex.java
@@ -32,27 +32,27 @@ public SingleSegmentIndex(RangedUri uri) {
   }
 
   @Override
-  public int getSegmentNum(long timeUs, long periodDurationUs) {
+  public long getSegmentNum(long timeUs, long periodDurationUs) {
     return 0;
   }
 
   @Override
-  public long getTimeUs(int segmentNum) {
+  public long getTimeUs(long segmentNum) {
     return 0;
   }
 
   @Override
-  public long getDurationUs(int segmentNum, long periodDurationUs) {
+  public long getDurationUs(long segmentNum, long periodDurationUs) {
     return periodDurationUs;
   }
 
   @Override
-  public RangedUri getSegmentUrl(int segmentNum) {
+  public RangedUri getSegmentUrl(long segmentNum) {
     return uri;
   }
 
   @Override
-  public int getFirstSegmentNum() {
+  public long getFirstSegmentNum() {
     return 0;
   }
 
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplate.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplate.java
index c47eec90a1..a7ce7eb9a0 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplate.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplate.java
@@ -71,8 +71,8 @@ private UrlTemplate(String[] urlPieces, int[] identifiers, String[] identifierFo
 
   /**
    * Constructs a Uri from the template, substituting in the provided arguments.
-   * <p>
-   * Arguments whose corresponding identifiers are not present in the template will be ignored.
+   *
+   * <p>Arguments whose corresponding identifiers are not present in the template will be ignored.
    *
    * @param representationId The representation identifier.
    * @param segmentNumber The segment number.
@@ -80,7 +80,7 @@ private UrlTemplate(String[] urlPieces, int[] identifiers, String[] identifierFo
    * @param time The time as specified by the segment timeline.
    * @return The built Uri.
    */
-  public String buildUri(String representationId, int segmentNumber, int bandwidth, long time) {
+  public String buildUri(String representationId, long segmentNumber, int bandwidth, long time) {
     StringBuilder builder = new StringBuilder();
     for (int i = 0; i < identifierCount; i++) {
       builder.append(urlPieces[i]);
diff --git a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
index 4c07e4874e..4a90feb532 100644
--- a/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
+++ b/library/dash/src/main/java/com/google/android/exoplayer2/source/dash/offline/DashDownloader.java
@@ -54,7 +54,7 @@
  * // Select the first representation of the first adaptation set of the first period
  * dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
  * dashDownloader.download(new ProgressListener() {
- *   @Override
+ *   {@literal @}Override
  *   public void onDownloadProgress(Downloader downloader, float downloadPercentage,
  *       long downloadedBytes) {
  *     // Invoked periodically during the download.
@@ -75,26 +75,24 @@ public DashDownloader(Uri manifestUri, DownloaderConstructorHelper constructorHe
   }
 
   @Override
-  public DashManifest getManifest(DataSource dataSource, Uri uri) throws IOException {
-    return DashUtil.loadManifest(dataSource, uri);
-  }
-
-  @Override
-  protected List<Segment> getAllSegments(DataSource dataSource, DashManifest manifest,
-      boolean allowIndexLoadErrors) throws InterruptedException, IOException {
-    ArrayList<Segment> segments = new ArrayList<>();
+  public RepresentationKey[] getAllRepresentationKeys() throws IOException {
+    ArrayList<RepresentationKey> keys = new ArrayList<>();
+    DashManifest manifest = getManifest();
     for (int periodIndex = 0; periodIndex < manifest.getPeriodCount(); periodIndex++) {
       List<AdaptationSet> adaptationSets = manifest.getPeriod(periodIndex).adaptationSets;
       for (int adaptationIndex = 0; adaptationIndex < adaptationSets.size(); adaptationIndex++) {
-        AdaptationSet adaptationSet = adaptationSets.get(adaptationIndex);
-        RepresentationKey[] keys = new RepresentationKey[adaptationSet.representations.size()];
-        for (int i = 0; i < keys.length; i++) {
-          keys[i] = new RepresentationKey(periodIndex, adaptationIndex, i);
+        int representationsCount = adaptationSets.get(adaptationIndex).representations.size();
+        for (int i = 0; i < representationsCount; i++) {
+          keys.add(new RepresentationKey(periodIndex, adaptationIndex, i));
         }
-        segments.addAll(getSegments(dataSource, manifest, keys, allowIndexLoadErrors));
       }
     }
-    return segments;
+    return keys.toArray(new RepresentationKey[keys.size()]);
+  }
+
+  @Override
+  protected DashManifest getManifest(DataSource dataSource, Uri uri) throws IOException {
+    return DashUtil.loadManifest(dataSource, uri);
   }
 
   @Override
@@ -119,7 +117,8 @@ public DashManifest getManifest(DataSource dataSource, Uri uri) throws IOExcepti
         }
       }
 
-      int segmentCount = index.getSegmentCount(C.TIME_UNSET);
+      long periodDurationUs = manifest.getPeriodDurationUs(key.periodIndex);
+      int segmentCount = index.getSegmentCount(periodDurationUs);
       if (segmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
         throw new DownloadException("Unbounded index for representation: " + key);
       }
@@ -138,9 +137,9 @@ public DashManifest getManifest(DataSource dataSource, Uri uri) throws IOExcepti
         addSegment(segments, startUs, baseUrl, indexUri);
       }
 
-      int firstSegmentNum = index.getFirstSegmentNum();
-      int lastSegmentNum = firstSegmentNum + segmentCount - 1;
-      for (int j = firstSegmentNum; j <= lastSegmentNum; j++) {
+      long firstSegmentNum = index.getFirstSegmentNum();
+      long lastSegmentNum = firstSegmentNum + segmentCount - 1;
+      for (long j = firstSegmentNum; j <= lastSegmentNum; j++) {
         addSegment(segments, startUs + index.getTimeUs(j), baseUrl, index.getSegmentUrl(j));
       }
     }
diff --git a/library/dash/src/androidTest/AndroidManifest.xml b/library/dash/src/test/AndroidManifest.xml
similarity index 71%
rename from library/dash/src/androidTest/AndroidManifest.xml
rename to library/dash/src/test/AndroidManifest.xml
index 3a5b0c1fa2..eecf596b92 100644
--- a/library/dash/src/androidTest/AndroidManifest.xml
+++ b/library/dash/src/test/AndroidManifest.xml
@@ -18,16 +18,6 @@
     xmlns:tools="http://schemas.android.com/tools"
     package="com.google.android.exoplayer2.source.dash.test">
 
-  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
-
-  <application android:debuggable="true"
-      android:allowBackup="false"
-      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
-    <uses-library android:name="android.test.runner"/>
-  </application>
-
-  <instrumentation
-      android:targetPackage="com.google.android.exoplayer2.source.dash.test"
-      android:name="android.test.InstrumentationTestRunner"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="25"/>
 
 </manifest>
diff --git a/library/dash/src/androidTest/assets/sample_mpd_1 b/library/dash/src/test/assets/sample_mpd_1
similarity index 100%
rename from library/dash/src/androidTest/assets/sample_mpd_1
rename to library/dash/src/test/assets/sample_mpd_1
diff --git a/library/dash/src/androidTest/assets/sample_mpd_2_unknown_mime_type b/library/dash/src/test/assets/sample_mpd_2_unknown_mime_type
similarity index 100%
rename from library/dash/src/androidTest/assets/sample_mpd_2_unknown_mime_type
rename to library/dash/src/test/assets/sample_mpd_2_unknown_mime_type
diff --git a/library/dash/src/androidTest/assets/sample_mpd_3_segment_template b/library/dash/src/test/assets/sample_mpd_3_segment_template
similarity index 100%
rename from library/dash/src/androidTest/assets/sample_mpd_3_segment_template
rename to library/dash/src/test/assets/sample_mpd_3_segment_template
diff --git a/library/dash/src/test/assets/sample_mpd_4_event_stream b/library/dash/src/test/assets/sample_mpd_4_event_stream
new file mode 100644
index 0000000000..cf96541ca0
--- /dev/null
+++ b/library/dash/src/test/assets/sample_mpd_4_event_stream
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<MPD xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:mpeg:DASH:schema:MPD:2011" xmlns:yt="http://youtube.com/yt/2012/10/10" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd" minBufferTime="PT1.500S" profiles="urn:mpeg:dash:profile:isoff-main:2011" type="dynamic" availabilityStartTime="2016-10-14T17:00:17" timeShiftBufferDepth="PT7200.000S" minimumUpdatePeriod="PT2.000S" yt:earliestMediaSequence="0" yt:mpdRequestTime="2016-10-14T18:29:17.082" yt:mpdResponseTime="2016-10-14T18:29:17.194">
+ <Period start="PT0.000S" yt:segmentIngestTime="2016-10-14T17:00:14.257">
+   <EventStream schemeIdUri="urn:uuid:XYZY" timescale="1000" value="call">
+     <Event presentationTime="0" duration="10000" id="0">+ 1 800 10101010</Event>
+   </EventStream>
+   <EventStream schemeIdUri="urn:dvb:iptv:cpm:2014">
+     <Event presentationTime="300" duration="1500" id="1"><![CDATA[<BroadcastEvent>
+      <Program crid="crid://broadcaster.example.com/ABCDEF"/>
+      <InstanceDescription>
+      <Title xml:lang="en">The title</Title>
+      <Synopsis xml:lang="en" length="medium">The description</Synopsis>
+      <ParentalGuidance>
+      <mpeg7:ParentalRating href="urn:dvb:iptv:rating:2014:15"/>
+      <mpeg7:Region>GB</mpeg7:Region>
+      </ParentalGuidance>
+      </InstanceDescription>
+      </BroadcastEvent>]]></Event>
+   </EventStream>
+   <EventStream schemeIdUri="urn:scte:scte35:2014:xml+bin">
+     <Event timescale="90000" presentationTime="1000" duration="1000" id="2"><scte35:Signal>
+         <scte35:Binary>
+         /DAIAAAAAAAAAAAQAAZ/I0VniQAQAgBDVUVJQAAAAH+cAAAAAA==
+         </scte35:Binary>
+       </scte35:Signal></Event>
+   </EventStream>
+  <SegmentTemplate startNumber="0" timescale="1000" media="sq/$Number$">
+   <SegmentTimeline>
+    <S d="2002" t="6009" r="2"/>
+   </SegmentTimeline>
+  </SegmentTemplate>
+  <AdaptationSet id="0" mimeType="audio/mp4" subsegmentAlignment="true">
+   <Role schemeIdUri="urn:mpeg:DASH:role:2011" value="main"/>
+   <Representation id="140" codecs="mp4a.40.2" audioSamplingRate="48000" startWithSAP="1" bandwidth="144000">
+    <AudioChannelConfiguration schemeIdUri="urn:mpeg:dash:23003:3:audio_channel_configuration:2011" value="2"/>
+    <BaseURL>http://www.dummy.url/</BaseURL>
+   </Representation>
+  </AdaptationSet>
+  <AdaptationSet id="1" mimeType="video/mp4" subsegmentAlignment="true">
+   <Role schemeIdUri="urn:mpeg:DASH:role:2011" value="main"/>
+   <Representation id="133" codecs="avc1.4d4015" width="426" height="240" startWithSAP="1" maxPlayoutRate="1" bandwidth="258000" frameRate="30">
+    <BaseURL>http://www.dummy.url/</BaseURL>
+   </Representation>
+  </AdaptationSet>
+ </Period>
+</MPD>
+
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaSourceTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaSourceTest.java
new file mode 100644
index 0000000000..1c440c70be
--- /dev/null
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashMediaSourceTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.upstream.ParsingLoadable;
+import com.google.android.exoplayer2.util.Util;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link DashMediaSource}. */
+@RunWith(RobolectricTestRunner.class)
+public final class DashMediaSourceTest {
+
+  @Test
+  public void testIso8601ParserParse() throws IOException {
+    DashMediaSource.Iso8601Parser parser = new DashMediaSource.Iso8601Parser();
+    // UTC.
+    assertParseStringToLong(1512381697000L, parser, "2017-12-04T10:01:37Z");
+    assertParseStringToLong(1512381697000L, parser, "2017-12-04T10:01:37+00:00");
+    assertParseStringToLong(1512381697000L, parser, "2017-12-04T10:01:37+0000");
+    assertParseStringToLong(1512381697000L, parser, "2017-12-04T10:01:37+00");
+    // Positive timezone offsets.
+    assertParseStringToLong(1512381697000L - 4980000L, parser, "2017-12-04T10:01:37+01:23");
+    assertParseStringToLong(1512381697000L - 4980000L, parser, "2017-12-04T10:01:37+0123");
+    assertParseStringToLong(1512381697000L - 3600000L, parser, "2017-12-04T10:01:37+01");
+    // Negative timezone offsets with minus character.
+    assertParseStringToLong(1512381697000L + 4980000L, parser, "2017-12-04T10:01:37-01:23");
+    assertParseStringToLong(1512381697000L + 4980000L, parser, "2017-12-04T10:01:37-0123");
+    assertParseStringToLong(1512381697000L + 3600000L, parser, "2017-12-04T10:01:37-01:00");
+    assertParseStringToLong(1512381697000L + 3600000L, parser, "2017-12-04T10:01:37-0100");
+    assertParseStringToLong(1512381697000L + 3600000L, parser, "2017-12-04T10:01:37-01");
+    // Negative timezone offsets with hyphen character.
+    assertParseStringToLong(1512381697000L + 4980000L, parser, "2017-12-04T10:01:37−01:23");
+    assertParseStringToLong(1512381697000L + 4980000L, parser, "2017-12-04T10:01:37−0123");
+    assertParseStringToLong(1512381697000L + 3600000L, parser, "2017-12-04T10:01:37−01:00");
+    assertParseStringToLong(1512381697000L + 3600000L, parser, "2017-12-04T10:01:37−0100");
+    assertParseStringToLong(1512381697000L + 3600000L, parser, "2017-12-04T10:01:37−01");
+  }
+
+  @Test
+  public void testIso8601ParserParseMissingTimezone() throws IOException {
+    DashMediaSource.Iso8601Parser parser = new DashMediaSource.Iso8601Parser();
+    try {
+      assertParseStringToLong(0, parser, "2017-12-04T10:01:37");
+      fail();
+    } catch (ParserException e) {
+      // Expected.
+    }
+  }
+
+  private static void assertParseStringToLong(
+      long expected, ParsingLoadable.Parser<Long> parser, String data) throws IOException {
+    long actual = parser.parse(null, new ByteArrayInputStream(Util.getUtf8Bytes(data)));
+    assertThat(actual).isEqualTo(expected);
+  }
+}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
similarity index 75%
rename from library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
rename to library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
index 3db8c6b2f9..15fa3b3355 100644
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/DashUtilTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.source.dash;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.drm.DrmInitData;
@@ -26,35 +28,40 @@
 import com.google.android.exoplayer2.upstream.DummyDataSource;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.Arrays;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit tests for {@link DashUtil}.
- */
-public final class DashUtilTest extends TestCase {
+/** Unit tests for {@link DashUtil}. */
+@RunWith(RobolectricTestRunner.class)
+public final class DashUtilTest {
 
+  @Test
   public void testLoadDrmInitDataFromManifest() throws Exception {
     Period period = newPeriod(newAdaptationSets(newRepresentations(newDrmInitData())));
     DrmInitData drmInitData = DashUtil.loadDrmInitData(DummyDataSource.INSTANCE, period);
-    assertEquals(newDrmInitData(), drmInitData);
+    assertThat(drmInitData).isEqualTo(newDrmInitData());
   }
 
+  @Test
   public void testLoadDrmInitDataMissing() throws Exception {
     Period period = newPeriod(newAdaptationSets(newRepresentations(null /* no init data */)));
     DrmInitData drmInitData = DashUtil.loadDrmInitData(DummyDataSource.INSTANCE, period);
-    assertNull(drmInitData);
+    assertThat(drmInitData).isNull();
   }
 
+  @Test
   public void testLoadDrmInitDataNoRepresentations() throws Exception {
-    Period period = newPeriod(newAdaptationSets(/* no representation */));
+    Period period = newPeriod(newAdaptationSets(/* no representation */ ));
     DrmInitData drmInitData = DashUtil.loadDrmInitData(DummyDataSource.INSTANCE, period);
-    assertNull(drmInitData);
+    assertThat(drmInitData).isNull();
   }
 
+  @Test
   public void testLoadDrmInitDataNoAdaptationSets() throws Exception {
-    Period period = newPeriod(/* no adaptation set */);
+    Period period = newPeriod(/* no adaptation set */ );
     DrmInitData drmInitData = DashUtil.loadDrmInitData(DummyDataSource.INSTANCE, period);
-    assertNull(drmInitData);
+    assertThat(drmInitData).isNull();
   }
 
   private static Period newPeriod(AdaptationSet... adaptationSets) {
@@ -66,8 +73,18 @@ private static AdaptationSet newAdaptationSets(Representation... representations
   }
 
   private static Representation newRepresentations(DrmInitData drmInitData) {
-    Format format = Format.createVideoContainerFormat("id", MimeTypes.VIDEO_MP4,
-        MimeTypes.VIDEO_H264, "", Format.NO_VALUE, 1024, 768, Format.NO_VALUE, null, 0);
+    Format format =
+        Format.createVideoContainerFormat(
+            "id",
+            MimeTypes.VIDEO_MP4,
+            MimeTypes.VIDEO_H264,
+            "",
+            Format.NO_VALUE,
+            1024,
+            768,
+            Format.NO_VALUE,
+            null,
+            0);
     if (drmInitData != null) {
       format = format.copyWithDrmInitData(drmInitData);
     }
@@ -75,8 +92,7 @@ private static Representation newRepresentations(DrmInitData drmInitData) {
   }
 
   private static DrmInitData newDrmInitData() {
-    return new DrmInitData(new SchemeData(C.WIDEVINE_UUID, "mimeType",
-        new byte[] {1, 4, 7, 0, 3, 6}));
+    return new DrmInitData(
+        new SchemeData(C.WIDEVINE_UUID, "mimeType", new byte[] {1, 4, 7, 0, 3, 6}));
   }
-
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java
new file mode 100644
index 0000000000..9c3752551a
--- /dev/null
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/EventSampleStreamTest.java
@@ -0,0 +1,356 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.metadata.MetadataInputBuffer;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
+import com.google.android.exoplayer2.metadata.emsg.EventMessageEncoder;
+import com.google.android.exoplayer2.source.dash.manifest.EventStream;
+import com.google.android.exoplayer2.util.MimeTypes;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/**
+ * Unit test for {@link EventSampleStream}.
+ */
+@RunWith(RobolectricTestRunner.class)
+public final class EventSampleStreamTest {
+
+  private static final String SCHEME_ID = "urn:test";
+  private static final String VALUE = "123";
+  private static final Format FORMAT = Format.createSampleFormat("urn:test/123",
+      MimeTypes.APPLICATION_EMSG, null, Format.NO_VALUE, null);
+  private static final byte[] MESSAGE_DATA = new byte[] {1, 2, 3, 4};
+  private static final long DURATION_MS = 3000;
+  private static final long TIME_SCALE = 1000;
+
+  private FormatHolder formatHolder;
+  private MetadataInputBuffer inputBuffer;
+  private EventMessageEncoder eventMessageEncoder;
+
+  @Before
+  public void setUp() {
+    formatHolder = new FormatHolder();
+    inputBuffer = new MetadataInputBuffer();
+    eventMessageEncoder = new EventMessageEncoder();
+  }
+
+  /**
+   * Tests that {@link EventSampleStream#readData(FormatHolder, DecoderInputBuffer, boolean)} will
+   * return format for the first call.
+   */
+  @Test
+  public void testReadDataReturnFormatForFirstRead() {
+    EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[0], new EventMessage[0]);
+    EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);
+
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_FORMAT_READ);
+    assertThat(formatHolder.format).isEqualTo(FORMAT);
+  }
+
+  /**
+   * Tests that a non-dynamic {@link EventSampleStream} will return a buffer with
+   * {@link C#BUFFER_FLAG_END_OF_STREAM} when trying to read sample out-of-bound.
+   */
+  @Test
+  public void testReadDataOutOfBoundReturnEndOfStreamAfterFormatForNonDynamicEventSampleStream() {
+    EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[0], new EventMessage[0]);
+    EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);
+    // first read - read format
+    readData(sampleStream);
+
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);
+    assertThat(inputBuffer.isEndOfStream()).isTrue();
+  }
+
+  /**
+   * Tests that a dynamic {@link EventSampleStream} will return {@link C#RESULT_NOTHING_READ}
+   * when trying to read sample out-of-bound.
+   */
+  @Test
+  public void testReadDataOutOfBoundReturnEndOfStreamAfterFormatForDynamicEventSampleStream() {
+    EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[0], new EventMessage[0]);
+    EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, true);
+    // first read - read format
+    readData(sampleStream);
+
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_NOTHING_READ);
+  }
+
+  /**
+   * Tests that {@link EventSampleStream#readData(FormatHolder, DecoderInputBuffer, boolean)} will
+   * return sample data after the first call.
+   */
+  @Test
+  public void testReadDataReturnDataAfterFormat() {
+    long presentationTimeUs = 1000000;
+    EventMessage eventMessage = newEventMessageWithIdAndTime(1, presentationTimeUs);
+    EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs}, new EventMessage[] {eventMessage});
+    EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);
+    // first read - read format
+    readData(sampleStream);
+
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);
+    assertThat(inputBuffer.data.array())
+        .isEqualTo(getEncodedMessage(eventMessage));
+  }
+
+  /**
+   * Tests that {@link EventSampleStream#skipData(long)} will skip until the given position, and
+   * the next {@link EventSampleStream#readData(FormatHolder, DecoderInputBuffer, boolean)} call
+   * will return sample data from that position.
+   */
+  @Test
+  public void testSkipDataThenReadDataReturnDataFromSkippedPosition() {
+    long presentationTimeUs1 = 1000000;
+    long presentationTimeUs2 = 2000000;
+    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
+    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2},
+        new EventMessage[] {eventMessage1, eventMessage2});
+    EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);
+    // first read - read format
+    readData(sampleStream);
+
+    int skipped = sampleStream.skipData(presentationTimeUs2);
+    int result = readData(sampleStream);
+    assertThat(skipped).isEqualTo(1);
+    assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);
+    assertThat(inputBuffer.data.array())
+        .isEqualTo(getEncodedMessage(eventMessage2));
+  }
+
+  /**
+   * Tests that {@link EventSampleStream#seekToUs(long)} (long)} will seek to the given position,
+   * and the next {@link EventSampleStream#readData(FormatHolder, DecoderInputBuffer, boolean)} call
+   * will return sample data from that position.
+   */
+  @Test
+  public void testSeekToUsThenReadDataReturnDataFromSeekPosition() {
+    long presentationTimeUs1 = 1000000;
+    long presentationTimeUs2 = 2000000;
+    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
+    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventStream eventStream = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2},
+        new EventMessage[] {eventMessage1, eventMessage2});
+    EventSampleStream sampleStream = new EventSampleStream(eventStream, FORMAT, false);
+    // first read - read format
+    readData(sampleStream);
+
+    sampleStream.seekToUs(presentationTimeUs2);
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);
+    assertThat(inputBuffer.data.array())
+        .isEqualTo(getEncodedMessage(eventMessage2));
+  }
+
+  /**
+   * Tests that {@link EventSampleStream#updateEventStream(EventStream, boolean)} will update the
+   * underlying event stream, but keep the read timestamp, so the next
+   * {@link EventSampleStream#readData(FormatHolder, DecoderInputBuffer, boolean)} call
+   * will return sample data from after the last read sample timestamp.
+   */
+  @Test
+  public void testUpdateEventStreamContinueToReadAfterLastReadSamplePresentationTime() {
+    long presentationTimeUs1 = 1000000;
+    long presentationTimeUs2 = 2000000;
+    long presentationTimeUs3 = 3000000;
+    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
+    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2},
+        new EventMessage[] {eventMessage1, eventMessage2});
+    EventStream eventStream2 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},
+        new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});
+    EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);
+    // first read - read format
+    readData(sampleStream);
+    // read first and second sample.
+    readData(sampleStream);
+    readData(sampleStream);
+
+    sampleStream.updateEventStream(eventStream2, true);
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);
+    assertThat(inputBuffer.data.array())
+        .isEqualTo(getEncodedMessage(eventMessage3));
+  }
+
+  /**
+   * Tests that {@link EventSampleStream#updateEventStream(EventStream, boolean)} will update the
+   * underlying event stream, but keep the timestamp the stream has skipped to, so the next
+   * {@link EventSampleStream#readData(FormatHolder, DecoderInputBuffer, boolean)} call
+   * will return sample data from the skipped position.
+   */
+  @Test
+  public void testSkipDataThenUpdateStreamContinueToReadFromSkippedPosition() {
+    long presentationTimeUs1 = 1000000;
+    long presentationTimeUs2 = 2000000;
+    long presentationTimeUs3 = 3000000;
+    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
+    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2},
+        new EventMessage[] {eventMessage1, eventMessage2});
+    EventStream eventStream2 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},
+        new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});
+    EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);
+    // first read - read format
+    readData(sampleStream);
+    sampleStream.skipData(presentationTimeUs2 + 1);
+
+    sampleStream.updateEventStream(eventStream2, true);
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);
+    assertThat(inputBuffer.data.array())
+        .isEqualTo(getEncodedMessage(eventMessage3));
+  }
+
+  /**
+   * Tests that {@link EventSampleStream#skipData(long)} will only skip to the point right after
+   * it last event. A following {@link EventSampleStream#updateEventStream(EventStream, boolean)}
+   * will update the underlying event stream and keep the timestamp the stream has skipped to, so
+   * the next {@link EventSampleStream#readData(FormatHolder, DecoderInputBuffer, boolean)} call
+   * will return sample data from the skipped position.
+   */
+  @Test
+  public void testSkipDataThenUpdateStreamContinueToReadDoNotSkippedMoreThanAvailable() {
+    long presentationTimeUs1 = 1000000;
+    long presentationTimeUs2 = 2000000;
+    long presentationTimeUs3 = 3000000;
+    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
+    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1},
+        new EventMessage[] {eventMessage1});
+    EventStream eventStream2 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},
+        new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});
+    EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);
+    // first read - read format
+    readData(sampleStream);
+    // even though the skip call is to 2000001, since eventStream1 only contains sample until
+    // 1000000, it will only skip to 1000001.
+    sampleStream.skipData(presentationTimeUs2 + 1);
+
+    sampleStream.updateEventStream(eventStream2, true);
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);
+    assertThat(inputBuffer.data.array())
+        .isEqualTo(getEncodedMessage(eventMessage2));
+  }
+
+  /**
+   * Tests that {@link EventSampleStream#updateEventStream(EventStream, boolean)} will update the
+   * underlying event stream, but keep the timestamp the stream has seek to, so the next
+   * {@link EventSampleStream#readData(FormatHolder, DecoderInputBuffer, boolean)} call
+   * will return sample data from the seek position.
+   */
+  @Test
+  public void testSeekToUsThenUpdateStreamContinueToReadFromSeekPosition() {
+    long presentationTimeUs1 = 1000000;
+    long presentationTimeUs2 = 2000000;
+    long presentationTimeUs3 = 3000000;
+    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
+    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2},
+        new EventMessage[] {eventMessage1, eventMessage2});
+    EventStream eventStream2 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},
+        new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});
+    EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);
+    // first read - read format
+    readData(sampleStream);
+    sampleStream.seekToUs(presentationTimeUs2);
+
+    sampleStream.updateEventStream(eventStream2, true);
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);
+    assertThat(inputBuffer.data.array())
+        .isEqualTo(getEncodedMessage(eventMessage2));
+  }
+
+  /**
+   * Tests that {@link EventSampleStream#updateEventStream(EventStream, boolean)} will update the
+   * underlying event stream, but keep the timestamp the stream has seek to, so the next
+   * {@link EventSampleStream#readData(FormatHolder, DecoderInputBuffer, boolean)} call
+   * will return sample data from the seek position.
+   */
+  @Test
+  public void testSeekToThenUpdateStreamContinueToReadFromSeekPositionEvenSeekMoreThanAvailable() {
+    long presentationTimeUs1 = 1000000;
+    long presentationTimeUs2 = 2000000;
+    long presentationTimeUs3 = 3000000;
+    EventMessage eventMessage1 = newEventMessageWithIdAndTime(1, presentationTimeUs1);
+    EventMessage eventMessage2 = newEventMessageWithIdAndTime(2, presentationTimeUs2);
+    EventMessage eventMessage3 = newEventMessageWithIdAndTime(3, presentationTimeUs3);
+    EventStream eventStream1 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1},
+        new EventMessage[] {eventMessage1});
+    EventStream eventStream2 = new EventStream(SCHEME_ID, VALUE, TIME_SCALE,
+        new long[] {presentationTimeUs1, presentationTimeUs2, presentationTimeUs3},
+        new EventMessage[] {eventMessage1, eventMessage2, eventMessage3});
+    EventSampleStream sampleStream = new EventSampleStream(eventStream1, FORMAT, true);
+    // first read - read format
+    readData(sampleStream);
+    sampleStream.seekToUs(presentationTimeUs2 + 1);
+
+    sampleStream.updateEventStream(eventStream2, true);
+    int result = readData(sampleStream);
+    assertThat(result).isEqualTo(C.RESULT_BUFFER_READ);
+    assertThat(inputBuffer.data.array())
+        .isEqualTo(getEncodedMessage(eventMessage3));
+  }
+
+  private int readData(EventSampleStream sampleStream) {
+    inputBuffer.clear();
+    return sampleStream.readData(formatHolder, inputBuffer, false);
+  }
+
+  private EventMessage newEventMessageWithIdAndTime(int id, long presentationTimeUs) {
+    return new EventMessage(SCHEME_ID, VALUE, DURATION_MS, id, MESSAGE_DATA, presentationTimeUs);
+  }
+
+  private byte[] getEncodedMessage(EventMessage eventMessage) {
+    return eventMessageEncoder.encode(eventMessage, TIME_SCALE);
+  }
+
+}
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
new file mode 100644
index 0000000000..6f14c8790f
--- /dev/null
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestParserTest.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.metadata.emsg.EventMessage;
+import com.google.android.exoplayer2.testutil.TestUtil;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+
+/** Unit tests for {@link DashManifestParser}. */
+@RunWith(RobolectricTestRunner.class)
+public class DashManifestParserTest {
+
+  private static final String SAMPLE_MPD_1 = "sample_mpd_1";
+  private static final String SAMPLE_MPD_2_UNKNOWN_MIME_TYPE = "sample_mpd_2_unknown_mime_type";
+  private static final String SAMPLE_MPD_3_SEGMENT_TEMPLATE = "sample_mpd_3_segment_template";
+  private static final String SAMPLE_MPD_4_EVENT_STREAM = "sample_mpd_4_event_stream";
+
+  /** Simple test to ensure the sample manifests parse without any exceptions being thrown. */
+  @Test
+  public void testParseMediaPresentationDescription() throws IOException {
+    DashManifestParser parser = new DashManifestParser();
+    parser.parse(
+        Uri.parse("https://example.com/test.mpd"),
+        TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_1));
+    parser.parse(
+        Uri.parse("https://example.com/test.mpd"),
+        TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_2_UNKNOWN_MIME_TYPE));
+  }
+
+  @Test
+  public void testParseMediaPresentationDescriptionWithSegmentTemplate() throws IOException {
+    DashManifestParser parser = new DashManifestParser();
+    DashManifest mpd =
+        parser.parse(
+            Uri.parse("https://example.com/test.mpd"),
+            TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_3_SEGMENT_TEMPLATE));
+
+    assertThat(mpd.getPeriodCount()).isEqualTo(1);
+
+    Period period = mpd.getPeriod(0);
+    assertThat(period).isNotNull();
+    assertThat(period.adaptationSets).hasSize(2);
+
+    for (AdaptationSet adaptationSet : period.adaptationSets) {
+      assertThat(adaptationSet).isNotNull();
+      for (Representation representation : adaptationSet.representations) {
+        if (representation instanceof Representation.MultiSegmentRepresentation) {
+          Representation.MultiSegmentRepresentation multiSegmentRepresentation =
+              (Representation.MultiSegmentRepresentation) representation;
+          long firstSegmentIndex = multiSegmentRepresentation.getFirstSegmentNum();
+          RangedUri uri = multiSegmentRepresentation.getSegmentUrl(firstSegmentIndex);
+          assertThat(
+                  uri.resolveUriString(representation.baseUrl)
+                      .contains("redirector.googlevideo.com"))
+              .isTrue();
+        }
+      }
+    }
+  }
+
+  @Test
+  public void testParseMediaPresentationDescriptionCanParseEventStream() throws IOException {
+    DashManifestParser parser = new DashManifestParser();
+    DashManifest mpd =
+        parser.parse(
+            Uri.parse("https://example.com/test.mpd"),
+            TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_MPD_4_EVENT_STREAM));
+
+    Period period = mpd.getPeriod(0);
+    assertThat(period.eventStreams).hasSize(3);
+
+    // assert text-only event stream
+    EventStream eventStream1 = period.eventStreams.get(0);
+    assertThat(eventStream1.events.length).isEqualTo(1);
+    EventMessage expectedEvent1 =
+        new EventMessage(
+            "urn:uuid:XYZY",
+            "call",
+            10000,
+            0,
+            "+ 1 800 10101010".getBytes(Charset.forName(C.UTF8_NAME)),
+            0);
+    assertThat(eventStream1.events[0]).isEqualTo(expectedEvent1);
+
+    // assert CData-structured event stream
+    EventStream eventStream2 = period.eventStreams.get(1);
+    assertThat(eventStream2.events.length).isEqualTo(1);
+    assertThat(eventStream2.events[0])
+        .isEqualTo(
+            new EventMessage(
+                "urn:dvb:iptv:cpm:2014",
+                "",
+                1500000,
+                1,
+                ("<![CDATA[<BroadcastEvent>\n"
+                        + "      <Program crid=\"crid://broadcaster.example.com/ABCDEF\"/>\n"
+                        + "      <InstanceDescription>\n"
+                        + "      <Title xml:lang=\"en\">The title</Title>\n"
+                        + "      <Synopsis xml:lang=\"en\" length=\"medium\">"
+                        + "The description</Synopsis>\n"
+                        + "      <ParentalGuidance>\n"
+                        + "      <mpeg7:ParentalRating href=\"urn:dvb:iptv:rating:2014:15\"/>\n"
+                        + "      <mpeg7:Region>GB</mpeg7:Region>\n"
+                        + "      </ParentalGuidance>\n"
+                        + "      </InstanceDescription>\n"
+                        + "      </BroadcastEvent>]]>")
+                    .getBytes(),
+                300000000));
+
+    // assert xml-structured event stream
+    EventStream eventStream3 = period.eventStreams.get(2);
+    assertThat(eventStream3.events.length).isEqualTo(1);
+    assertThat(eventStream3.events[0])
+        .isEqualTo(
+            new EventMessage(
+                "urn:scte:scte35:2014:xml+bin",
+                "",
+                1000000,
+                2,
+                ("<scte35:Signal>\n"
+                        + "         <scte35:Binary>\n"
+                        + "         /DAIAAAAAAAAAAAQAAZ/I0VniQAQAgBDVUVJQAAAAH+cAAAAAA==\n"
+                        + "         </scte35:Binary>\n"
+                        + "       </scte35:Signal>")
+                    .getBytes(),
+                1000000000));
+  }
+
+  @Test
+  public void testParseCea608AccessibilityChannel() {
+    assertThat(
+            DashManifestParser.parseCea608AccessibilityChannel(
+                buildCea608AccessibilityDescriptors("CC1=eng")))
+        .isEqualTo(1);
+    assertThat(
+            DashManifestParser.parseCea608AccessibilityChannel(
+                buildCea608AccessibilityDescriptors("CC2=eng")))
+        .isEqualTo(2);
+    assertThat(
+            DashManifestParser.parseCea608AccessibilityChannel(
+                buildCea608AccessibilityDescriptors("CC3=eng")))
+        .isEqualTo(3);
+    assertThat(
+            DashManifestParser.parseCea608AccessibilityChannel(
+                buildCea608AccessibilityDescriptors("CC4=eng")))
+        .isEqualTo(4);
+
+    assertThat(
+            DashManifestParser.parseCea608AccessibilityChannel(
+                buildCea608AccessibilityDescriptors(null)))
+        .isEqualTo(Format.NO_VALUE);
+    assertThat(
+            DashManifestParser.parseCea608AccessibilityChannel(
+                buildCea608AccessibilityDescriptors("")))
+        .isEqualTo(Format.NO_VALUE);
+    assertThat(
+            DashManifestParser.parseCea608AccessibilityChannel(
+                buildCea608AccessibilityDescriptors("CC0=eng")))
+        .isEqualTo(Format.NO_VALUE);
+    assertThat(
+            DashManifestParser.parseCea608AccessibilityChannel(
+                buildCea608AccessibilityDescriptors("CC5=eng")))
+        .isEqualTo(Format.NO_VALUE);
+    assertThat(
+            DashManifestParser.parseCea608AccessibilityChannel(
+                buildCea608AccessibilityDescriptors("Wrong format")))
+        .isEqualTo(Format.NO_VALUE);
+  }
+
+  @Test
+  public void testParseCea708AccessibilityChannel() {
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors("1=lang:eng")))
+        .isEqualTo(1);
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors("2=lang:eng")))
+        .isEqualTo(2);
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors("3=lang:eng")))
+        .isEqualTo(3);
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors("62=lang:eng")))
+        .isEqualTo(62);
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors("63=lang:eng")))
+        .isEqualTo(63);
+
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors(null)))
+        .isEqualTo(Format.NO_VALUE);
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors("")))
+        .isEqualTo(Format.NO_VALUE);
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors("0=lang:eng")))
+        .isEqualTo(Format.NO_VALUE);
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors("64=lang:eng")))
+        .isEqualTo(Format.NO_VALUE);
+    assertThat(
+            DashManifestParser.parseCea708AccessibilityChannel(
+                buildCea708AccessibilityDescriptors("Wrong format")))
+        .isEqualTo(Format.NO_VALUE);
+  }
+
+  private static List<Descriptor> buildCea608AccessibilityDescriptors(String value) {
+    return Collections.singletonList(new Descriptor("urn:scte:dash:cc:cea-608:2015", value, null));
+  }
+
+  private static List<Descriptor> buildCea708AccessibilityDescriptors(String value) {
+    return Collections.singletonList(new Descriptor("urn:scte:dash:cc:cea-708:2015", value, null));
+  }
+}
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
new file mode 100644
index 0000000000..9cf3594116
--- /dev/null
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/DashManifestTest.java
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit tests for {@link DashManifest}. */
+@RunWith(RobolectricTestRunner.class)
+public class DashManifestTest {
+
+  private static final UtcTimingElement DUMMY_UTC_TIMING = new UtcTimingElement("", "");
+  private static final SingleSegmentBase DUMMY_SEGMENT_BASE = new SingleSegmentBase();
+  private static final Format DUMMY_FORMAT = Format.createSampleFormat("", "", 0);
+
+  @Test
+  public void testCopy() throws Exception {
+    Representation[][][] representations = newRepresentations(3, 2, 3);
+    DashManifest sourceManifest =
+        newDashManifest(
+            10,
+            newPeriod(
+                "1",
+                1,
+                newAdaptationSet(2, representations[0][0]),
+                newAdaptationSet(3, representations[0][1])),
+            newPeriod(
+                "4",
+                4,
+                newAdaptationSet(5, representations[1][0]),
+                newAdaptationSet(6, representations[1][1])),
+            newPeriod(
+                "7",
+                7,
+                newAdaptationSet(8, representations[2][0]),
+                newAdaptationSet(9, representations[2][1])));
+
+    List<RepresentationKey> keys =
+        Arrays.asList(
+            new RepresentationKey(0, 0, 0),
+            new RepresentationKey(0, 0, 1),
+            new RepresentationKey(0, 1, 2),
+            new RepresentationKey(1, 0, 1),
+            new RepresentationKey(1, 1, 0),
+            new RepresentationKey(1, 1, 2),
+            new RepresentationKey(2, 0, 1),
+            new RepresentationKey(2, 0, 2),
+            new RepresentationKey(2, 1, 0));
+    // Keys don't need to be in any particular order
+    Collections.shuffle(keys, new Random(0));
+
+    DashManifest copyManifest = sourceManifest.copy(keys);
+
+    DashManifest expectedManifest =
+        newDashManifest(
+            10,
+            newPeriod(
+                "1",
+                1,
+                newAdaptationSet(2, representations[0][0][0], representations[0][0][1]),
+                newAdaptationSet(3, representations[0][1][2])),
+            newPeriod(
+                "4",
+                4,
+                newAdaptationSet(5, representations[1][0][1]),
+                newAdaptationSet(6, representations[1][1][0], representations[1][1][2])),
+            newPeriod(
+                "7",
+                7,
+                newAdaptationSet(8, representations[2][0][1], representations[2][0][2]),
+                newAdaptationSet(9, representations[2][1][0])));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  @Test
+  public void testCopySameAdaptationIndexButDifferentPeriod() throws Exception {
+    Representation[][][] representations = newRepresentations(2, 1, 1);
+    DashManifest sourceManifest =
+        newDashManifest(
+            10,
+            newPeriod("1", 1, newAdaptationSet(2, representations[0][0])),
+            newPeriod("4", 4, newAdaptationSet(5, representations[1][0])));
+
+    DashManifest copyManifest =
+        sourceManifest.copy(
+            Arrays.asList(new RepresentationKey(0, 0, 0), new RepresentationKey(1, 0, 0)));
+
+    DashManifest expectedManifest =
+        newDashManifest(
+            10,
+            newPeriod("1", 1, newAdaptationSet(2, representations[0][0])),
+            newPeriod("4", 4, newAdaptationSet(5, representations[1][0])));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  @Test
+  public void testCopySkipPeriod() throws Exception {
+    Representation[][][] representations = newRepresentations(3, 2, 3);
+    DashManifest sourceManifest =
+        newDashManifest(
+            10,
+            newPeriod(
+                "1",
+                1,
+                newAdaptationSet(2, representations[0][0]),
+                newAdaptationSet(3, representations[0][1])),
+            newPeriod(
+                "4",
+                4,
+                newAdaptationSet(5, representations[1][0]),
+                newAdaptationSet(6, representations[1][1])),
+            newPeriod(
+                "7",
+                7,
+                newAdaptationSet(8, representations[2][0]),
+                newAdaptationSet(9, representations[2][1])));
+
+    DashManifest copyManifest =
+        sourceManifest.copy(
+            Arrays.asList(
+                new RepresentationKey(0, 0, 0),
+                new RepresentationKey(0, 0, 1),
+                new RepresentationKey(0, 1, 2),
+                new RepresentationKey(2, 0, 1),
+                new RepresentationKey(2, 0, 2),
+                new RepresentationKey(2, 1, 0)));
+
+    DashManifest expectedManifest =
+        newDashManifest(
+            7,
+            newPeriod(
+                "1",
+                1,
+                newAdaptationSet(2, representations[0][0][0], representations[0][0][1]),
+                newAdaptationSet(3, representations[0][1][2])),
+            newPeriod(
+                "7",
+                4,
+                newAdaptationSet(8, representations[2][0][1], representations[2][0][2]),
+                newAdaptationSet(9, representations[2][1][0])));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  private static void assertManifestEquals(DashManifest expected, DashManifest actual) {
+    assertThat(actual.availabilityStartTimeMs).isEqualTo(expected.availabilityStartTimeMs);
+    assertThat(actual.durationMs).isEqualTo(expected.durationMs);
+    assertThat(actual.minBufferTimeMs).isEqualTo(expected.minBufferTimeMs);
+    assertThat(actual.dynamic).isEqualTo(expected.dynamic);
+    assertThat(actual.minUpdatePeriodMs).isEqualTo(expected.minUpdatePeriodMs);
+    assertThat(actual.timeShiftBufferDepthMs).isEqualTo(expected.timeShiftBufferDepthMs);
+    assertThat(actual.suggestedPresentationDelayMs)
+        .isEqualTo(expected.suggestedPresentationDelayMs);
+    assertThat(actual.publishTimeMs).isEqualTo(expected.publishTimeMs);
+    assertThat(actual.utcTiming).isEqualTo(expected.utcTiming);
+    assertThat(actual.location).isEqualTo(expected.location);
+    assertThat(actual.getPeriodCount()).isEqualTo(expected.getPeriodCount());
+    for (int i = 0; i < expected.getPeriodCount(); i++) {
+      Period expectedPeriod = expected.getPeriod(i);
+      Period actualPeriod = actual.getPeriod(i);
+      assertThat(actualPeriod.id).isEqualTo(expectedPeriod.id);
+      assertThat(actualPeriod.startMs).isEqualTo(expectedPeriod.startMs);
+      List<AdaptationSet> expectedAdaptationSets = expectedPeriod.adaptationSets;
+      List<AdaptationSet> actualAdaptationSets = actualPeriod.adaptationSets;
+      assertThat(actualAdaptationSets).hasSize(expectedAdaptationSets.size());
+      for (int j = 0; j < expectedAdaptationSets.size(); j++) {
+        AdaptationSet expectedAdaptationSet = expectedAdaptationSets.get(j);
+        AdaptationSet actualAdaptationSet = actualAdaptationSets.get(j);
+        assertThat(actualAdaptationSet.id).isEqualTo(expectedAdaptationSet.id);
+        assertThat(actualAdaptationSet.type).isEqualTo(expectedAdaptationSet.type);
+        assertThat(actualAdaptationSet.accessibilityDescriptors)
+            .isEqualTo(expectedAdaptationSet.accessibilityDescriptors);
+        assertThat(actualAdaptationSet.representations)
+            .isEqualTo(expectedAdaptationSet.representations);
+      }
+    }
+  }
+
+  private static Representation[][][] newRepresentations(
+      int periodCount, int adaptationSetCounts, int representationCounts) {
+    Representation[][][] representations = new Representation[periodCount][][];
+    for (int i = 0; i < periodCount; i++) {
+      representations[i] = new Representation[adaptationSetCounts][];
+      for (int j = 0; j < adaptationSetCounts; j++) {
+        representations[i][j] = new Representation[representationCounts];
+        for (int k = 0; k < representationCounts; k++) {
+          representations[i][j][k] = newRepresentation();
+        }
+      }
+    }
+    return representations;
+  }
+
+  private static Representation newRepresentation() {
+    return Representation.newInstance("", 0, DUMMY_FORMAT, "", DUMMY_SEGMENT_BASE);
+  }
+
+  private static DashManifest newDashManifest(int duration, Period... periods) {
+    return new DashManifest(
+        0, duration, 1, false, 2, 3, 4, 12345, DUMMY_UTC_TIMING, Uri.EMPTY, Arrays.asList(periods));
+  }
+
+  private static Period newPeriod(String id, int startMs, AdaptationSet... adaptationSets) {
+    return new Period(id, startMs, Arrays.asList(adaptationSets));
+  }
+
+  private static AdaptationSet newAdaptationSet(int seed, Representation... representations) {
+    return new AdaptationSet(++seed, ++seed, Arrays.asList(representations), null, null);
+  }
+}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
similarity index 86%
rename from library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
rename to library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
index fd559381fa..16c9a4706e 100644
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RangedUriTest.java
@@ -15,18 +15,22 @@
  */
 package com.google.android.exoplayer2.source.dash.manifest;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.C;
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
-/**
- * Unit test for {@link RangedUri}.
- */
-public class RangedUriTest extends TestCase {
+/** Unit test for {@link RangedUri}. */
+@RunWith(RobolectricTestRunner.class)
+public class RangedUriTest {
 
   private static final String BASE_URI = "http://www.test.com/";
   private static final String PARTIAL_URI = "path/file.ext";
   private static final String FULL_URI = BASE_URI + PARTIAL_URI;
 
+  @Test
   public void testMerge() {
     RangedUri rangeA = new RangedUri(FULL_URI, 0, 10);
     RangedUri rangeB = new RangedUri(FULL_URI, 10, 10);
@@ -34,6 +38,7 @@ public void testMerge() {
     assertMerge(rangeA, rangeB, expected, null);
   }
 
+  @Test
   public void testMergeUnbounded() {
     RangedUri rangeA = new RangedUri(FULL_URI, 0, 10);
     RangedUri rangeB = new RangedUri(FULL_URI, 10, C.LENGTH_UNSET);
@@ -41,6 +46,7 @@ public void testMergeUnbounded() {
     assertMerge(rangeA, rangeB, expected, null);
   }
 
+  @Test
   public void testNonMerge() {
     // A and B do not overlap, so should not merge
     RangedUri rangeA = new RangedUri(FULL_URI, 0, 10);
@@ -63,6 +69,7 @@ public void testNonMerge() {
     assertNonMerge(rangeA, rangeB, null);
   }
 
+  @Test
   public void testMergeWithBaseUri() {
     RangedUri rangeA = new RangedUri(PARTIAL_URI, 0, 10);
     RangedUri rangeB = new RangedUri(FULL_URI, 10, 10);
@@ -72,16 +79,15 @@ public void testMergeWithBaseUri() {
 
   private void assertMerge(RangedUri rangeA, RangedUri rangeB, RangedUri expected, String baseUrl) {
     RangedUri merged = rangeA.attemptMerge(rangeB, baseUrl);
-    assertEquals(expected, merged);
+    assertThat(merged).isEqualTo(expected);
     merged = rangeB.attemptMerge(rangeA, baseUrl);
-    assertEquals(expected, merged);
+    assertThat(merged).isEqualTo(expected);
   }
 
   private void assertNonMerge(RangedUri rangeA, RangedUri rangeB, String baseUrl) {
     RangedUri merged = rangeA.attemptMerge(rangeB, baseUrl);
-    assertNull(merged);
+    assertThat(merged).isNull();
     merged = rangeB.attemptMerge(rangeA, baseUrl);
-    assertNull(merged);
+    assertThat(merged).isNull();
   }
-
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
new file mode 100644
index 0000000000..309e6c8eb0
--- /dev/null
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/RepresentationTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.manifest;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.dash.manifest.SegmentBase.SingleSegmentBase;
+import com.google.android.exoplayer2.util.MimeTypes;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link Representation}. */
+@RunWith(RobolectricTestRunner.class)
+public class RepresentationTest {
+
+  @Test
+  public void testGetCacheKey() {
+    String uri = "http://www.google.com";
+    SegmentBase base = new SingleSegmentBase(new RangedUri(null, 0, 1), 1, 0, 1, 1);
+    Format format =
+        Format.createVideoContainerFormat(
+            "0",
+            MimeTypes.APPLICATION_MP4,
+            null,
+            MimeTypes.VIDEO_H264,
+            2500000,
+            1920,
+            1080,
+            Format.NO_VALUE,
+            null,
+            0);
+    Representation representation =
+        Representation.newInstance("test_stream_1", 3, format, uri, base);
+    assertThat(representation.getCacheKey()).isEqualTo("test_stream_1.0.3");
+
+    format =
+        Format.createVideoContainerFormat(
+            "150",
+            MimeTypes.APPLICATION_MP4,
+            null,
+            MimeTypes.VIDEO_H264,
+            2500000,
+            1920,
+            1080,
+            Format.NO_VALUE,
+            null,
+            0);
+    representation =
+        Representation.newInstance(
+            "test_stream_1", Representation.REVISION_ID_DEFAULT, format, uri, base);
+    assertThat(representation.getCacheKey()).isEqualTo("test_stream_1.150.-1");
+  }
+}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java
similarity index 74%
rename from library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java
rename to library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java
index 1959d33172..4192280c81 100644
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/manifest/UrlTemplateTest.java
@@ -15,44 +15,52 @@
  */
 package com.google.android.exoplayer2.source.dash.manifest;
 
-import junit.framework.TestCase;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
-/**
- * Unit test for {@link UrlTemplate}.
- */
-public class UrlTemplateTest extends TestCase {
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link UrlTemplate}. */
+@RunWith(RobolectricTestRunner.class)
+public class UrlTemplateTest {
 
+  @Test
   public void testRealExamples() {
     String template = "QualityLevels($Bandwidth$)/Fragments(video=$Time$,format=mpd-time-csf)";
     UrlTemplate urlTemplate = UrlTemplate.compile(template);
     String url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
-    assertEquals("QualityLevels(650000)/Fragments(video=5000,format=mpd-time-csf)", url);
+    assertThat(url).isEqualTo("QualityLevels(650000)/Fragments(video=5000,format=mpd-time-csf)");
 
     template = "$RepresentationID$/$Number$";
     urlTemplate = UrlTemplate.compile(template);
     url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
-    assertEquals("abc1/10", url);
+    assertThat(url).isEqualTo("abc1/10");
 
     template = "chunk_ctvideo_cfm4s_rid$RepresentationID$_cn$Number$_w2073857842_mpd.m4s";
     urlTemplate = UrlTemplate.compile(template);
     url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
-    assertEquals("chunk_ctvideo_cfm4s_ridabc1_cn10_w2073857842_mpd.m4s", url);
+    assertThat(url).isEqualTo("chunk_ctvideo_cfm4s_ridabc1_cn10_w2073857842_mpd.m4s");
   }
 
+  @Test
   public void testFull() {
     String template = "$Bandwidth$_a_$RepresentationID$_b_$Time$_c_$Number$";
     UrlTemplate urlTemplate = UrlTemplate.compile(template);
     String url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
-    assertEquals("650000_a_abc1_b_5000_c_10", url);
+    assertThat(url).isEqualTo("650000_a_abc1_b_5000_c_10");
   }
 
+  @Test
   public void testFullWithDollarEscaping() {
     String template = "$$$Bandwidth$$$_a$$_$RepresentationID$_b_$Time$_c_$Number$$$";
     UrlTemplate urlTemplate = UrlTemplate.compile(template);
     String url = urlTemplate.buildUri("abc1", 10, 650000, 5000);
-    assertEquals("$650000$_a$_abc1_b_5000_c_10$", url);
+    assertThat(url).isEqualTo("$650000$_a$_abc1_b_5000_c_10$");
   }
 
+  @Test
   public void testInvalidSubstitution() {
     String template = "$IllegalId$";
     try {
@@ -62,5 +70,4 @@ public void testInvalidSubstitution() {
       // Expected.
     }
   }
-
 }
diff --git a/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java
new file mode 100644
index 0000000000..a215347f15
--- /dev/null
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloadTestData.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.dash.offline;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import java.nio.charset.Charset;
+
+/** Data for DASH downloading tests. */
+/* package */ interface DashDownloadTestData {
+
+  Uri TEST_MPD_URI = Uri.parse("test.mpd");
+
+  byte[] TEST_MPD =
+      ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+              + "<MPD xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" type=\"static\" "
+              + "    mediaPresentationDuration=\"PT31S\">\n"
+              + "    <Period duration=\"PT16S\" >\n"
+              + "        <AdaptationSet>\n"
+              + "            <SegmentList>\n"
+              + "                <SegmentTimeline>\n"
+              + "                    <S d=\"5\" />\n"
+              + "                    <S d=\"5\" />\n"
+              + "                    <S d=\"5\" />\n"
+              + "                </SegmentTimeline>\n"
+              + "            </SegmentList>\n"
+              + "            <Representation>\n"
+              + "                <SegmentList>\n"
+              // Bounded range data
+              + "                    <Initialization\n"
+              + "                        range=\"0-9\" sourceURL=\"audio_init_data\" />\n"
+              // Unbounded range data
+              + "                    <SegmentURL media=\"audio_segment_1\" />\n"
+              + "                    <SegmentURL media=\"audio_segment_2\" />\n"
+              + "                    <SegmentURL media=\"audio_segment_3\" />\n"
+              + "                </SegmentList>\n"
+              + "            </Representation>\n"
+              + "        </AdaptationSet>\n"
+              + "        <AdaptationSet>\n"
+              // This segment list has a 1 second offset to make sure the progressive download order
+              + "            <SegmentList>\n"
+              + "                <SegmentTimeline>\n"
+              + "                    <S t=\"1\" d=\"5\" />\n" // 1s offset
+              + "                    <S d=\"5\" />\n"
+              + "                    <S d=\"5\" />\n"
+              + "                </SegmentTimeline>\n"
+              + "            </SegmentList>\n"
+              + "            <Representation>\n"
+              + "                <SegmentList>\n"
+              + "                    <SegmentURL media=\"text_segment_1\" />\n"
+              + "                    <SegmentURL media=\"text_segment_2\" />\n"
+              + "                    <SegmentURL media=\"text_segment_3\" />\n"
+              + "                </SegmentList>\n"
+              + "            </Representation>\n"
+              + "        </AdaptationSet>\n"
+              + "    </Period>\n"
+              + "    <Period>\n"
+              + "        <SegmentList>\n"
+              + "            <SegmentTimeline>\n"
+              + "                <S d=\"5\" />\n"
+              + "                <S d=\"5\" />\n"
+              + "                <S d=\"5\" />\n"
+              + "            </SegmentTimeline>\n"
+              + "        </SegmentList>\n"
+              + "        <AdaptationSet>\n"
+              + "            <Representation>\n"
+              + "                <SegmentList>\n"
+              + "                    <SegmentURL media=\"period_2_segment_1\" />\n"
+              + "                    <SegmentURL media=\"period_2_segment_2\" />\n"
+              + "                    <SegmentURL media=\"period_2_segment_3\" />\n"
+              + "                </SegmentList>\n"
+              + "            </Representation>\n"
+              + "        </AdaptationSet>\n"
+              + "    </Period>\n"
+              + "</MPD>")
+          .getBytes(Charset.forName(C.UTF8_NAME));
+
+  byte[] TEST_MPD_NO_INDEX =
+      ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+              + "<MPD xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" type=\"dynamic\">\n"
+              + "    <Period start=\"PT6462826.784S\" >\n"
+              + "        <AdaptationSet>\n"
+              + "            <Representation>\n"
+              + "                <SegmentBase indexRange='0-10'/>\n"
+              + "            </Representation>\n"
+              + "        </AdaptationSet>\n"
+              + "    </Period>\n"
+              + "</MPD>")
+          .getBytes(Charset.forName(C.UTF8_NAME));
+}
diff --git a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
similarity index 53%
rename from library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
rename to library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
index 8532e65a68..d00b24e84f 100644
--- a/library/dash/src/androidTest/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
+++ b/library/dash/src/test/java/com/google/android/exoplayer2/source/dash/offline/DashDownloaderTest.java
@@ -21,13 +21,15 @@
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCachedData;
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertDataCached;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.offline.DownloadException;
 import com.google.android.exoplayer2.offline.Downloader.ProgressListener;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
-import com.google.android.exoplayer2.source.dash.MockitoUtil;
 import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
 import com.google.android.exoplayer2.source.dash.manifest.RepresentationKey;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
@@ -41,51 +43,57 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.mockito.InOrder;
 import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit tests for {@link DashDownloader}.
- */
-public class DashDownloaderTest extends InstrumentationTestCase {
+/** Unit tests for {@link DashDownloader}. */
+@RunWith(RobolectricTestRunner.class)
+public class DashDownloaderTest {
 
   private SimpleCache cache;
   private File tempFolder;
 
-  @Override
+  @Before
   public void setUp() throws Exception {
-    super.setUp();
-    MockitoUtil.setUpMockito(this);
-    tempFolder = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
+    MockitoAnnotations.initMocks(this);
+    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
   }
 
-  @Override
+  @After
   public void tearDown() throws Exception {
     Util.recursiveDelete(tempFolder);
-    super.tearDown();
   }
 
+  @Test
   public void testGetManifest() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD);
+    FakeDataSet fakeDataSet = new FakeDataSet().setData(TEST_MPD_URI, TEST_MPD);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     DashManifest manifest = dashDownloader.getManifest();
 
-    assertNotNull(manifest);
+    assertThat(manifest).isNotNull();
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testDownloadManifestFailure() throws Exception {
     byte[] testMpdFirstPart = Arrays.copyOf(TEST_MPD, 10);
     byte[] testMpdSecondPart = Arrays.copyOfRange(TEST_MPD, 10, TEST_MPD.length);
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .newData(TEST_MPD_URI)
-        .appendReadData(testMpdFirstPart)
-        .appendReadError(new IOException())
-        .appendReadData(testMpdSecondPart)
-        .endData();
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .newData(TEST_MPD_URI)
+            .appendReadData(testMpdFirstPart)
+            .appendReadError(new IOException())
+            .appendReadData(testMpdSecondPart)
+            .endData();
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     // fails on the first try
@@ -95,22 +103,25 @@ public void testDownloadManifestFailure() throws Exception {
     } catch (IOException e) {
       // ignore
     }
-    assertDataCached(cache, TEST_MPD_URI, testMpdFirstPart);
+    DataSpec dataSpec = new DataSpec(TEST_MPD_URI, 0, testMpdFirstPart.length, null);
+    assertDataCached(cache, dataSpec, testMpdFirstPart);
 
     // on the second try it downloads the rest of the data
     DashManifest manifest = dashDownloader.getManifest();
 
-    assertNotNull(manifest);
+    assertThat(manifest).isNotNull();
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testDownloadRepresentation() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .setRandomData("audio_segment_2", 5)
-        .setRandomData("audio_segment_3", 6);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .setRandomData("audio_segment_2", 5)
+            .setRandomData("audio_segment_3", 6);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
@@ -119,17 +130,19 @@ public void testDownloadRepresentation() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testDownloadRepresentationInSmallParts() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .newData("audio_segment_1")
-        .appendReadData(TestUtil.buildTestData(10))
-        .appendReadData(TestUtil.buildTestData(10))
-        .appendReadData(TestUtil.buildTestData(10))
-        .endData()
-        .setRandomData("audio_segment_2", 5)
-        .setRandomData("audio_segment_3", 6);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .newData("audio_segment_1")
+            .appendReadData(TestUtil.buildTestData(10))
+            .appendReadData(TestUtil.buildTestData(10))
+            .appendReadData(TestUtil.buildTestData(10))
+            .endData()
+            .setRandomData("audio_segment_2", 5)
+            .setRandomData("audio_segment_3", 6);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
@@ -138,16 +151,18 @@ public void testDownloadRepresentationInSmallParts() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testDownloadRepresentations() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .setRandomData("audio_segment_2", 5)
-        .setRandomData("audio_segment_3", 6)
-        .setRandomData("text_segment_1", 1)
-        .setRandomData("text_segment_2", 2)
-        .setRandomData("text_segment_3", 3);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .setRandomData("audio_segment_2", 5)
+            .setRandomData("audio_segment_3", 6)
+            .setRandomData("text_segment_1", 1)
+            .setRandomData("text_segment_2", 2)
+            .setRandomData("text_segment_3", 3);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     dashDownloader.selectRepresentations(
@@ -157,19 +172,21 @@ public void testDownloadRepresentations() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testDownloadAllRepresentations() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .setRandomData("audio_segment_2", 5)
-        .setRandomData("audio_segment_3", 6)
-        .setRandomData("text_segment_1", 1)
-        .setRandomData("text_segment_2", 2)
-        .setRandomData("text_segment_3", 3)
-        .setRandomData("period_2_segment_1", 1)
-        .setRandomData("period_2_segment_2", 2)
-        .setRandomData("period_2_segment_3", 3);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .setRandomData("audio_segment_2", 5)
+            .setRandomData("audio_segment_3", 6)
+            .setRandomData("text_segment_1", 1)
+            .setRandomData("text_segment_2", 2)
+            .setRandomData("text_segment_3", 3)
+            .setRandomData("period_2_segment_1", 1)
+            .setRandomData("period_2_segment_2", 2)
+            .setRandomData("period_2_segment_3", 3);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     // dashDownloader.selectRepresentations() isn't called
@@ -191,81 +208,87 @@ public void testDownloadAllRepresentations() throws Exception {
     dashDownloader.remove();
   }
 
+  @Test
   public void testProgressiveDownload() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .setRandomData("audio_segment_2", 5)
-        .setRandomData("audio_segment_3", 6)
-        .setRandomData("text_segment_1", 1)
-        .setRandomData("text_segment_2", 2)
-        .setRandomData("text_segment_3", 3);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .setRandomData("audio_segment_2", 5)
+            .setRandomData("audio_segment_3", 6)
+            .setRandomData("text_segment_1", 1)
+            .setRandomData("text_segment_2", 2)
+            .setRandomData("text_segment_3", 3);
     FakeDataSource fakeDataSource = new FakeDataSource(fakeDataSet);
-    Factory factory = Mockito.mock(Factory.class);
-    Mockito.when(factory.createDataSource()).thenReturn(fakeDataSource);
-    DashDownloader dashDownloader = new DashDownloader(TEST_MPD_URI,
-        new DownloaderConstructorHelper(cache, factory));
+    Factory factory = mock(Factory.class);
+    when(factory.createDataSource()).thenReturn(fakeDataSource);
+    DashDownloader dashDownloader =
+        new DashDownloader(TEST_MPD_URI, new DownloaderConstructorHelper(cache, factory));
 
     dashDownloader.selectRepresentations(
         new RepresentationKey[] {new RepresentationKey(0, 0, 0), new RepresentationKey(0, 1, 0)});
     dashDownloader.download(null);
 
     DataSpec[] openedDataSpecs = fakeDataSource.getAndClearOpenedDataSpecs();
-    assertEquals(8, openedDataSpecs.length);
-    assertEquals(TEST_MPD_URI, openedDataSpecs[0].uri);
-    assertEquals("audio_init_data", openedDataSpecs[1].uri.getPath());
-    assertEquals("audio_segment_1", openedDataSpecs[2].uri.getPath());
-    assertEquals("text_segment_1", openedDataSpecs[3].uri.getPath());
-    assertEquals("audio_segment_2", openedDataSpecs[4].uri.getPath());
-    assertEquals("text_segment_2", openedDataSpecs[5].uri.getPath());
-    assertEquals("audio_segment_3", openedDataSpecs[6].uri.getPath());
-    assertEquals("text_segment_3", openedDataSpecs[7].uri.getPath());
+    assertThat(openedDataSpecs.length).isEqualTo(8);
+    assertThat(openedDataSpecs[0].uri).isEqualTo(TEST_MPD_URI);
+    assertThat(openedDataSpecs[1].uri.getPath()).isEqualTo("audio_init_data");
+    assertThat(openedDataSpecs[2].uri.getPath()).isEqualTo("audio_segment_1");
+    assertThat(openedDataSpecs[3].uri.getPath()).isEqualTo("text_segment_1");
+    assertThat(openedDataSpecs[4].uri.getPath()).isEqualTo("audio_segment_2");
+    assertThat(openedDataSpecs[5].uri.getPath()).isEqualTo("text_segment_2");
+    assertThat(openedDataSpecs[6].uri.getPath()).isEqualTo("audio_segment_3");
+    assertThat(openedDataSpecs[7].uri.getPath()).isEqualTo("text_segment_3");
   }
 
+  @Test
   public void testProgressiveDownloadSeparatePeriods() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .setRandomData("audio_segment_2", 5)
-        .setRandomData("audio_segment_3", 6)
-        .setRandomData("period_2_segment_1", 1)
-        .setRandomData("period_2_segment_2", 2)
-        .setRandomData("period_2_segment_3", 3);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .setRandomData("audio_segment_2", 5)
+            .setRandomData("audio_segment_3", 6)
+            .setRandomData("period_2_segment_1", 1)
+            .setRandomData("period_2_segment_2", 2)
+            .setRandomData("period_2_segment_3", 3);
     FakeDataSource fakeDataSource = new FakeDataSource(fakeDataSet);
-    Factory factory = Mockito.mock(Factory.class);
-    Mockito.when(factory.createDataSource()).thenReturn(fakeDataSource);
-    DashDownloader dashDownloader = new DashDownloader(TEST_MPD_URI,
-        new DownloaderConstructorHelper(cache, factory));
+    Factory factory = mock(Factory.class);
+    when(factory.createDataSource()).thenReturn(fakeDataSource);
+    DashDownloader dashDownloader =
+        new DashDownloader(TEST_MPD_URI, new DownloaderConstructorHelper(cache, factory));
 
     dashDownloader.selectRepresentations(
         new RepresentationKey[] {new RepresentationKey(0, 0, 0), new RepresentationKey(1, 0, 0)});
     dashDownloader.download(null);
 
     DataSpec[] openedDataSpecs = fakeDataSource.getAndClearOpenedDataSpecs();
-    assertEquals(8, openedDataSpecs.length);
-    assertEquals(TEST_MPD_URI, openedDataSpecs[0].uri);
-    assertEquals("audio_init_data", openedDataSpecs[1].uri.getPath());
-    assertEquals("audio_segment_1", openedDataSpecs[2].uri.getPath());
-    assertEquals("audio_segment_2", openedDataSpecs[3].uri.getPath());
-    assertEquals("audio_segment_3", openedDataSpecs[4].uri.getPath());
-    assertEquals("period_2_segment_1", openedDataSpecs[5].uri.getPath());
-    assertEquals("period_2_segment_2", openedDataSpecs[6].uri.getPath());
-    assertEquals("period_2_segment_3", openedDataSpecs[7].uri.getPath());
+    assertThat(openedDataSpecs.length).isEqualTo(8);
+    assertThat(openedDataSpecs[0].uri).isEqualTo(TEST_MPD_URI);
+    assertThat(openedDataSpecs[1].uri.getPath()).isEqualTo("audio_init_data");
+    assertThat(openedDataSpecs[2].uri.getPath()).isEqualTo("audio_segment_1");
+    assertThat(openedDataSpecs[3].uri.getPath()).isEqualTo("audio_segment_2");
+    assertThat(openedDataSpecs[4].uri.getPath()).isEqualTo("audio_segment_3");
+    assertThat(openedDataSpecs[5].uri.getPath()).isEqualTo("period_2_segment_1");
+    assertThat(openedDataSpecs[6].uri.getPath()).isEqualTo("period_2_segment_2");
+    assertThat(openedDataSpecs[7].uri.getPath()).isEqualTo("period_2_segment_3");
   }
 
+  @Test
   public void testDownloadRepresentationFailure() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .newData("audio_segment_2")
-        .appendReadData(TestUtil.buildTestData(2))
-        .appendReadError(new IOException())
-        .appendReadData(TestUtil.buildTestData(3))
-        .endData()
-        .setRandomData("audio_segment_3", 6);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .newData("audio_segment_2")
+            .appendReadData(TestUtil.buildTestData(2))
+            .appendReadError(new IOException())
+            .appendReadData(TestUtil.buildTestData(3))
+            .endData()
+            .setRandomData("audio_segment_3", 6);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
@@ -281,17 +304,19 @@ public void testDownloadRepresentationFailure() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testCounters() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .newData("audio_segment_2")
-        .appendReadData(TestUtil.buildTestData(2))
-        .appendReadError(new IOException())
-        .appendReadData(TestUtil.buildTestData(3))
-        .endData()
-        .setRandomData("audio_segment_3", 6);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .newData("audio_segment_2")
+            .appendReadData(TestUtil.buildTestData(2))
+            .appendReadError(new IOException())
+            .appendReadData(TestUtil.buildTestData(3))
+            .endData()
+            .setRandomData("audio_segment_3", 6);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     assertCounters(dashDownloader, C.LENGTH_UNSET, C.LENGTH_UNSET, C.LENGTH_UNSET);
@@ -315,13 +340,15 @@ public void testCounters() throws Exception {
     assertCounters(dashDownloader, 4, 4, 10 + 4 + 5 + 6);
   }
 
+  @Test
   public void testListener() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .setRandomData("audio_segment_2", 5)
-        .setRandomData("audio_segment_3", 6);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .setRandomData("audio_segment_2", 5)
+            .setRandomData("audio_segment_3", 6);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
@@ -336,16 +363,18 @@ public void testListener() throws Exception {
     inOrder.verifyNoMoreInteractions();
   }
 
+  @Test
   public void testRemoveAll() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .setRandomData("audio_segment_2", 5)
-        .setRandomData("audio_segment_3", 6)
-        .setRandomData("text_segment_1", 1)
-        .setRandomData("text_segment_2", 2)
-        .setRandomData("text_segment_3", 3);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .setRandomData("audio_segment_2", 5)
+            .setRandomData("audio_segment_3", 6)
+            .setRandomData("text_segment_1", 1)
+            .setRandomData("text_segment_2", 2)
+            .setRandomData("text_segment_3", 3);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
     dashDownloader.selectRepresentations(
         new RepresentationKey[] {new RepresentationKey(0, 0, 0), new RepresentationKey(0, 1, 0)});
@@ -356,10 +385,12 @@ public void testRemoveAll() throws Exception {
     assertCacheEmpty(cache);
   }
 
+  @Test
   public void testRepresentationWithoutIndex() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD_NO_INDEX)
-        .setRandomData("test_segment_1", 4);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD_NO_INDEX)
+            .setRandomData("test_segment_1", 4);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     dashDownloader.selectRepresentations(new RepresentationKey[] {new RepresentationKey(0, 0, 0)});
@@ -375,13 +406,15 @@ public void testRepresentationWithoutIndex() throws Exception {
     assertCacheEmpty(cache);
   }
 
+  @Test
   public void testSelectRepresentationsClearsPreviousSelection() throws Exception {
-    FakeDataSet fakeDataSet = new FakeDataSet()
-        .setData(TEST_MPD_URI, TEST_MPD)
-        .setRandomData("audio_init_data", 10)
-        .setRandomData("audio_segment_1", 4)
-        .setRandomData("audio_segment_2", 5)
-        .setRandomData("audio_segment_3", 6);
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .setData(TEST_MPD_URI, TEST_MPD)
+            .setRandomData("audio_init_data", 10)
+            .setRandomData("audio_segment_1", 4)
+            .setRandomData("audio_segment_2", 5)
+            .setRandomData("audio_segment_3", 6);
     DashDownloader dashDownloader = getDashDownloader(fakeDataSet);
 
     dashDownloader.selectRepresentations(
@@ -397,11 +430,13 @@ private DashDownloader getDashDownloader(FakeDataSet fakeDataSet) {
     return new DashDownloader(TEST_MPD_URI, new DownloaderConstructorHelper(cache, factory));
   }
 
-  private static void assertCounters(DashDownloader dashDownloader, int totalSegments,
-      int downloadedSegments, int downloadedBytes) {
-    assertEquals(totalSegments, dashDownloader.getTotalSegments());
-    assertEquals(downloadedSegments, dashDownloader.getDownloadedSegments());
-    assertEquals(downloadedBytes, dashDownloader.getDownloadedBytes());
+  private static void assertCounters(
+      DashDownloader dashDownloader,
+      int totalSegments,
+      int downloadedSegments,
+      int downloadedBytes) {
+    assertThat(dashDownloader.getTotalSegments()).isEqualTo(totalSegments);
+    assertThat(dashDownloader.getDownloadedSegments()).isEqualTo(downloadedSegments);
+    assertThat(dashDownloader.getDownloadedBytes()).isEqualTo(downloadedBytes);
   }
-
 }
diff --git a/library/dash/src/test/resources/robolectric.properties b/library/dash/src/test/resources/robolectric.properties
new file mode 100644
index 0000000000..2f3210368e
--- /dev/null
+++ b/library/dash/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+manifest=src/test/AndroidManifest.xml
diff --git a/library/hls/build.gradle b/library/hls/build.gradle
index 5471eacec6..c2268a3007 100644
--- a/library/hls/build.gradle
+++ b/library/hls/build.gradle
@@ -33,12 +33,9 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile 'com.android.support:support-annotations:' + supportLibraryVersion
-    androidTestCompile project(modulePrefix + 'testutils')
-    androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
-    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
-    androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation project(modulePrefix + 'library-core')
+    testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
 ext {
diff --git a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadTestData.java b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadTestData.java
deleted file mode 100644
index ec70fb1200..0000000000
--- a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadTestData.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.hls.offline;
-
-/**
- * Data for HLS downloading tests.
- */
-/* package */ interface HlsDownloadTestData {
-
-  String MASTER_PLAYLIST_URI = "test.m3u8";
-
-  String MEDIA_PLAYLIST_0_DIR = "gear0/";
-  String MEDIA_PLAYLIST_0_URI = MEDIA_PLAYLIST_0_DIR + "prog_index.m3u8";
-  String MEDIA_PLAYLIST_1_DIR = "gear1/";
-  String MEDIA_PLAYLIST_1_URI = MEDIA_PLAYLIST_1_DIR + "prog_index.m3u8";
-  String MEDIA_PLAYLIST_2_DIR = "gear2/";
-  String MEDIA_PLAYLIST_2_URI = MEDIA_PLAYLIST_2_DIR + "prog_index.m3u8";
-  String MEDIA_PLAYLIST_3_DIR = "gear3/";
-  String MEDIA_PLAYLIST_3_URI = MEDIA_PLAYLIST_3_DIR + "prog_index.m3u8";
-
-  byte[] MASTER_PLAYLIST_DATA =
-      ("#EXTM3U\n"
-          + "#EXT-X-STREAM-INF:BANDWIDTH=232370,CODECS=\"mp4a.40.2, avc1.4d4015\"\n"
-          + MEDIA_PLAYLIST_1_URI + "\n"
-          + "#EXT-X-STREAM-INF:BANDWIDTH=649879,CODECS=\"mp4a.40.2, avc1.4d401e\"\n"
-          + MEDIA_PLAYLIST_2_URI + "\n"
-          + "#EXT-X-STREAM-INF:BANDWIDTH=991714,CODECS=\"mp4a.40.2, avc1.4d401e\"\n"
-          + MEDIA_PLAYLIST_3_URI + "\n"
-          + "#EXT-X-STREAM-INF:BANDWIDTH=41457,CODECS=\"mp4a.40.2\"\n"
-          + MEDIA_PLAYLIST_0_URI).getBytes();
-
-  byte[] MEDIA_PLAYLIST_DATA =
-      ("#EXTM3U\n"
-          + "#EXT-X-TARGETDURATION:10\n"
-          + "#EXT-X-VERSION:3\n"
-          + "#EXT-X-MEDIA-SEQUENCE:0\n"
-          + "#EXT-X-PLAYLIST-TYPE:VOD\n"
-          + "#EXTINF:9.97667,\n"
-          + "fileSequence0.ts\n"
-          + "#EXTINF:9.97667,\n"
-          + "fileSequence1.ts\n"
-          + "#EXTINF:9.97667,\n"
-          + "fileSequence2.ts\n"
-          + "#EXT-X-ENDLIST").getBytes();
-
-  String ENC_MEDIA_PLAYLIST_URI = "enc_index.m3u8";
-
-  byte[] ENC_MEDIA_PLAYLIST_DATA =
-      ("#EXTM3U\n"
-          + "#EXT-X-TARGETDURATION:10\n"
-          + "#EXT-X-VERSION:3\n"
-          + "#EXT-X-MEDIA-SEQUENCE:0\n"
-          + "#EXT-X-PLAYLIST-TYPE:VOD\n"
-          + "#EXT-X-KEY:METHOD=AES-128,URI=\"enc.key\"\n"
-          + "#EXTINF:9.97667,\n"
-          + "fileSequence0.ts\n"
-          + "#EXTINF:9.97667,\n"
-          + "fileSequence1.ts\n"
-          + "#EXT-X-KEY:METHOD=AES-128,URI=\"enc2.key\"\n"
-          + "#EXTINF:9.97667,\n"
-          + "fileSequence2.ts\n"
-          + "#EXT-X-ENDLIST").getBytes();
-
-}
diff --git a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
deleted file mode 100644
index 8b0d76d2e5..0000000000
--- a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.hls.playlist;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.ParserException;
-import com.google.android.exoplayer2.util.MimeTypes;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.Collections;
-import java.util.List;
-import junit.framework.TestCase;
-
-/**
- * Test for {@link HlsMasterPlaylistParserTest}.
- */
-public class HlsMasterPlaylistParserTest extends TestCase {
-
-  private static final String PLAYLIST_URI = "https://example.com/test.m3u8";
-
-  private static final String MASTER_PLAYLIST = " #EXTM3U \n"
-      + "\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
-      + "http://example.com/low.m3u8\n"
-      + "\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
-      + "http://example.com/spaces_in_codecs.m3u8\n"
-      + "\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,FRAME-RATE=25,RESOLUTION=384x160\n"
-      + "http://example.com/mid.m3u8\n"
-      + "\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=7680000,FRAME-RATE=29.997\n"
-      + "http://example.com/hi.m3u8\n"
-      + "\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
-      + "http://example.com/audio-only.m3u8";
-
-  private static final String AVG_BANDWIDTH_MASTER_PLAYLIST = " #EXTM3U \n"
-      + "\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
-      + "http://example.com/low.m3u8\n"
-      + "\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,AVERAGE-BANDWIDTH=1270000,"
-      + "CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
-      + "http://example.com/spaces_in_codecs.m3u8\n";
-
-  private static final String PLAYLIST_WITH_INVALID_HEADER = "#EXTMU3\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
-      + "http://example.com/low.m3u8\n";
-
-  private static final String MASTER_PLAYLIST_WITH_CC = " #EXTM3U \n"
-      + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,LANGUAGE=\"es\",NAME=\"Eng\",INSTREAM-ID=\"SERVICE4\"\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
-      + "http://example.com/low.m3u8\n";
-
-  private static final String MASTER_PLAYLIST_WITHOUT_CC = " #EXTM3U \n"
-      + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,LANGUAGE=\"es\",NAME=\"Eng\",INSTREAM-ID=\"SERVICE4\"\n"
-      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128,"
-      + "CLOSED-CAPTIONS=NONE\n"
-      + "http://example.com/low.m3u8\n";
-
-  public void testParseMasterPlaylist() throws IOException{
-    HlsMasterPlaylist masterPlaylist = parseMasterPlaylist(PLAYLIST_URI, MASTER_PLAYLIST);
-
-    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
-    assertEquals(5, variants.size());
-    assertNull(masterPlaylist.muxedCaptionFormats);
-
-    assertEquals(1280000, variants.get(0).format.bitrate);
-    assertEquals("mp4a.40.2,avc1.66.30", variants.get(0).format.codecs);
-    assertEquals(304, variants.get(0).format.width);
-    assertEquals(128, variants.get(0).format.height);
-    assertEquals("http://example.com/low.m3u8", variants.get(0).url);
-
-    assertEquals(1280000, variants.get(1).format.bitrate);
-    assertEquals("mp4a.40.2 , avc1.66.30 ", variants.get(1).format.codecs);
-    assertEquals("http://example.com/spaces_in_codecs.m3u8", variants.get(1).url);
-
-    assertEquals(2560000, variants.get(2).format.bitrate);
-    assertNull(variants.get(2).format.codecs);
-    assertEquals(384, variants.get(2).format.width);
-    assertEquals(160, variants.get(2).format.height);
-    assertEquals(25.0f, variants.get(2).format.frameRate);
-    assertEquals("http://example.com/mid.m3u8", variants.get(2).url);
-
-    assertEquals(7680000, variants.get(3).format.bitrate);
-    assertNull(variants.get(3).format.codecs);
-    assertEquals(Format.NO_VALUE, variants.get(3).format.width);
-    assertEquals(Format.NO_VALUE, variants.get(3).format.height);
-    assertEquals(29.997f, variants.get(3).format.frameRate);
-    assertEquals("http://example.com/hi.m3u8", variants.get(3).url);
-
-    assertEquals(65000, variants.get(4).format.bitrate);
-    assertEquals("mp4a.40.5", variants.get(4).format.codecs);
-    assertEquals(Format.NO_VALUE, variants.get(4).format.width);
-    assertEquals(Format.NO_VALUE, variants.get(4).format.height);
-    assertEquals((float) Format.NO_VALUE, variants.get(4).format.frameRate);
-    assertEquals("http://example.com/audio-only.m3u8", variants.get(4).url);
-  }
-
-  public void testMasterPlaylistWithBandwdithAverage() throws IOException {
-    HlsMasterPlaylist masterPlaylist = parseMasterPlaylist(PLAYLIST_URI,
-        AVG_BANDWIDTH_MASTER_PLAYLIST);
-
-    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
-
-    assertEquals(1280000, variants.get(0).format.bitrate);
-    assertEquals(1270000, variants.get(1).format.bitrate);
-  }
-
-  public void testPlaylistWithInvalidHeader() throws IOException {
-    try {
-      parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_INVALID_HEADER);
-      fail("Expected exception not thrown.");
-    } catch (ParserException e) {
-      // Expected due to invalid header.
-    }
-  }
-
-  public void testPlaylistWithClosedCaption() throws IOException {
-    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, MASTER_PLAYLIST_WITH_CC);
-    assertEquals(1, playlist.muxedCaptionFormats.size());
-    Format closedCaptionFormat = playlist.muxedCaptionFormats.get(0);
-    assertEquals(MimeTypes.APPLICATION_CEA708, closedCaptionFormat.sampleMimeType);
-    assertEquals(4, closedCaptionFormat.accessibilityChannel);
-    assertEquals("es", closedCaptionFormat.language);
-  }
-
-  public void testPlaylistWithoutClosedCaptions() throws IOException {
-    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, MASTER_PLAYLIST_WITHOUT_CC);
-    assertEquals(Collections.emptyList(), playlist.muxedCaptionFormats);
-  }
-
-  private static HlsMasterPlaylist parseMasterPlaylist(String uri, String playlistString)
-      throws IOException {
-    Uri playlistUri = Uri.parse(uri);
-    ByteArrayInputStream inputStream = new ByteArrayInputStream(
-        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
-    return (HlsMasterPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
-  }
-
-}
diff --git a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java b/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
deleted file mode 100644
index e4edb07926..0000000000
--- a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.hls.playlist;
-
-import android.net.Uri;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.charset.Charset;
-import java.util.List;
-import java.util.Locale;
-import junit.framework.TestCase;
-
-/**
- * Test for {@link HlsMediaPlaylistParserTest}.
- */
-public class HlsMediaPlaylistParserTest extends TestCase {
-
-  public void testParseMediaPlaylist() {
-    Uri playlistUri = Uri.parse("https://example.com/test.m3u8");
-    String playlistString = "#EXTM3U\n"
-        + "#EXT-X-VERSION:3\n"
-        + "#EXT-X-PLAYLIST-TYPE:VOD\n"
-        + "#EXT-X-START:TIME-OFFSET=-25"
-        + "#EXT-X-TARGETDURATION:8\n"
-        + "#EXT-X-MEDIA-SEQUENCE:2679\n"
-        + "#EXT-X-DISCONTINUITY-SEQUENCE:4\n"
-        + "#EXT-X-ALLOW-CACHE:YES\n"
-        + "\n"
-        + "#EXTINF:7.975,\n"
-        + "#EXT-X-BYTERANGE:51370@0\n"
-        + "https://priv.example.com/fileSequence2679.ts\n"
-        + "\n"
-        + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=2680\",IV=0x1566B\n"
-        + "#EXTINF:7.975,\n"
-        + "#EXT-X-BYTERANGE:51501@2147483648\n"
-        + "https://priv.example.com/fileSequence2680.ts\n"
-        + "\n"
-        + "#EXT-X-KEY:METHOD=NONE\n"
-        + "#EXTINF:7.941,\n"
-        + "#EXT-X-BYTERANGE:51501\n" // @2147535149
-        + "https://priv.example.com/fileSequence2681.ts\n"
-        + "\n"
-        + "#EXT-X-DISCONTINUITY\n"
-        + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=2682\"\n"
-        + "#EXTINF:7.975,\n"
-        + "#EXT-X-BYTERANGE:51740\n" // @2147586650
-        + "https://priv.example.com/fileSequence2682.ts\n"
-        + "\n"
-        + "#EXTINF:7.975,\n"
-        + "https://priv.example.com/fileSequence2683.ts\n"
-        + "#EXT-X-ENDLIST";
-    InputStream inputStream = new ByteArrayInputStream(
-        playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
-    try {
-      HlsPlaylist playlist = new HlsPlaylistParser().parse(playlistUri, inputStream);
-      assertNotNull(playlist);
-
-      HlsMediaPlaylist mediaPlaylist = (HlsMediaPlaylist) playlist;
-      assertEquals(HlsMediaPlaylist.PLAYLIST_TYPE_VOD, mediaPlaylist.playlistType);
-      assertEquals(mediaPlaylist.durationUs - 25000000, mediaPlaylist.startOffsetUs);
-
-      assertEquals(2679, mediaPlaylist.mediaSequence);
-      assertEquals(3, mediaPlaylist.version);
-      assertTrue(mediaPlaylist.hasEndTag);
-      List<Segment> segments = mediaPlaylist.segments;
-      assertNotNull(segments);
-      assertEquals(5, segments.size());
-
-      Segment segment = segments.get(0);
-      assertEquals(4, mediaPlaylist.discontinuitySequence + segment.relativeDiscontinuitySequence);
-      assertEquals(7975000, segment.durationUs);
-      assertNull(segment.fullSegmentEncryptionKeyUri);
-      assertNull(segment.encryptionIV);
-      assertEquals(51370, segment.byterangeLength);
-      assertEquals(0, segment.byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2679.ts", segment.url);
-
-      segment = segments.get(1);
-      assertEquals(0, segment.relativeDiscontinuitySequence);
-      assertEquals(7975000, segment.durationUs);
-      assertEquals("https://priv.example.com/key.php?r=2680", segment.fullSegmentEncryptionKeyUri);
-      assertEquals("0x1566B", segment.encryptionIV);
-      assertEquals(51501, segment.byterangeLength);
-      assertEquals(2147483648L, segment.byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2680.ts", segment.url);
-
-      segment = segments.get(2);
-      assertEquals(0, segment.relativeDiscontinuitySequence);
-      assertEquals(7941000, segment.durationUs);
-      assertNull(segment.fullSegmentEncryptionKeyUri);
-      assertEquals(null, segment.encryptionIV);
-      assertEquals(51501, segment.byterangeLength);
-      assertEquals(2147535149L, segment.byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2681.ts", segment.url);
-
-      segment = segments.get(3);
-      assertEquals(1, segment.relativeDiscontinuitySequence);
-      assertEquals(7975000, segment.durationUs);
-      assertEquals("https://priv.example.com/key.php?r=2682", segment.fullSegmentEncryptionKeyUri);
-      // 0xA7A == 2682.
-      assertNotNull(segment.encryptionIV);
-      assertEquals("A7A", segment.encryptionIV.toUpperCase(Locale.getDefault()));
-      assertEquals(51740, segment.byterangeLength);
-      assertEquals(2147586650L, segment.byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2682.ts", segment.url);
-
-      segment = segments.get(4);
-      assertEquals(1, segment.relativeDiscontinuitySequence);
-      assertEquals(7975000, segment.durationUs);
-      assertEquals("https://priv.example.com/key.php?r=2682", segment.fullSegmentEncryptionKeyUri);
-      // 0xA7B == 2683.
-      assertNotNull(segment.encryptionIV);
-      assertEquals("A7B", segment.encryptionIV.toUpperCase(Locale.getDefault()));
-      assertEquals(C.LENGTH_UNSET, segment.byterangeLength);
-      assertEquals(0, segment.byterangeOffset);
-      assertEquals("https://priv.example.com/fileSequence2683.ts", segment.url);
-    } catch (IOException exception) {
-      fail(exception.getMessage());
-    }
-  }
-
-}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
index ca94fb86ea..686664cd3c 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/DefaultHlsExtractorFactory.java
@@ -43,6 +43,7 @@
   public static final String MP3_FILE_EXTENSION = ".mp3";
   public static final String MP4_FILE_EXTENSION = ".mp4";
   public static final String M4_FILE_EXTENSION_PREFIX = ".m4";
+  public static final String MP4_FILE_EXTENSION_PREFIX = ".mp4";
   public static final String VTT_FILE_EXTENSION = ".vtt";
   public static final String WEBVTT_FILE_EXTENSION = ".webvtt";
 
@@ -51,6 +52,9 @@
       Format format, List<Format> muxedCaptionFormats, DrmInitData drmInitData,
       TimestampAdjuster timestampAdjuster) {
     String lastPathSegment = uri.getLastPathSegment();
+    if (lastPathSegment == null) {
+      lastPathSegment = "";
+    }
     boolean isPackedAudioExtractor = false;
     Extractor extractor;
     if (MimeTypes.TEXT_VTT.equals(format.sampleMimeType)
@@ -71,8 +75,10 @@
       // Only reuse TS and fMP4 extractors.
       extractor = previousExtractor;
     } else if (lastPathSegment.endsWith(MP4_FILE_EXTENSION)
-        || lastPathSegment.startsWith(M4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 4)) {
-      extractor = new FragmentedMp4Extractor(0, timestampAdjuster, null, drmInitData);
+        || lastPathSegment.startsWith(M4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 4)
+        || lastPathSegment.startsWith(MP4_FILE_EXTENSION_PREFIX, lastPathSegment.length() - 5)) {
+      extractor = new FragmentedMp4Extractor(0, timestampAdjuster, null, drmInitData,
+          muxedCaptionFormats != null ? muxedCaptionFormats : Collections.<Format>emptyList());
     } else {
       // For any other file extension, we assume TS format.
       @DefaultTsPayloadReaderFactory.Flags
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
index 2b1ece4eee..d8496a63d2 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java
@@ -253,7 +253,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, long l
     updateLiveEdgeTimeUs(mediaPlaylist);
 
     // Select the chunk.
-    int chunkMediaSequence;
+    long chunkMediaSequence;
     if (previous == null || switchingVariant) {
       long targetPositionUs = (previous == null || independentSegments) ? loadPositionUs
           : previous.startTimeUs;
@@ -261,9 +261,13 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, long l
         // If the playlist is too old to contain the chunk, we need to refresh it.
         chunkMediaSequence = mediaPlaylist.mediaSequence + mediaPlaylist.segments.size();
       } else {
-        chunkMediaSequence = Util.binarySearchFloor(mediaPlaylist.segments,
-            targetPositionUs - mediaPlaylist.startTimeUs, true,
-            !playlistTracker.isLive() || previous == null) + mediaPlaylist.mediaSequence;
+        chunkMediaSequence =
+            Util.binarySearchFloor(
+                    mediaPlaylist.segments,
+                    targetPositionUs,
+                    /* inclusive= */ true,
+                    /* stayInBounds= */ !playlistTracker.isLive() || previous == null)
+                + mediaPlaylist.mediaSequence;
         if (chunkMediaSequence < mediaPlaylist.mediaSequence && previous != null) {
           // We try getting the next chunk without adapting in case that's the reason for falling
           // behind the live window.
@@ -281,7 +285,7 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, long l
       return;
     }
 
-    int chunkIndex = chunkMediaSequence - mediaPlaylist.mediaSequence;
+    int chunkIndex = (int) (chunkMediaSequence - mediaPlaylist.mediaSequence);
     if (chunkIndex >= mediaPlaylist.segments.size()) {
       if (mediaPlaylist.hasEndTag) {
         out.endOfStream = true;
@@ -320,7 +324,9 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, long l
     }
 
     // Compute start time of the next chunk.
-    long startTimeUs = mediaPlaylist.startTimeUs + segment.relativeStartTimeUs;
+    long offsetFromInitialStartTimeUs =
+        mediaPlaylist.startTimeUs - playlistTracker.getInitialStartTimeUs();
+    long startTimeUs = offsetFromInitialStartTimeUs + segment.relativeStartTimeUs;
     int discontinuitySequence = mediaPlaylist.discontinuitySequence
         + segment.relativeDiscontinuitySequence;
     TimestampAdjuster timestampAdjuster = timestampAdjusterProvider.getAdjuster(
@@ -330,11 +336,27 @@ public void getNextChunk(HlsMediaChunk previous, long playbackPositionUs, long l
     Uri chunkUri = UriUtil.resolveToUri(mediaPlaylist.baseUri, segment.url);
     DataSpec dataSpec = new DataSpec(chunkUri, segment.byterangeOffset, segment.byterangeLength,
         null);
-    out.chunk = new HlsMediaChunk(extractorFactory, mediaDataSource, dataSpec, initDataSpec,
-        selectedUrl, muxedCaptionFormats, trackSelection.getSelectionReason(),
-        trackSelection.getSelectionData(), startTimeUs, startTimeUs + segment.durationUs,
-        chunkMediaSequence, discontinuitySequence, isTimestampMaster, timestampAdjuster, previous,
-        mediaPlaylist.drmInitData, encryptionKey, encryptionIv);
+    out.chunk =
+        new HlsMediaChunk(
+            extractorFactory,
+            mediaDataSource,
+            dataSpec,
+            initDataSpec,
+            selectedUrl,
+            muxedCaptionFormats,
+            trackSelection.getSelectionReason(),
+            trackSelection.getSelectionData(),
+            startTimeUs,
+            startTimeUs + segment.durationUs,
+            chunkMediaSequence,
+            discontinuitySequence,
+            segment.hasGapTag,
+            isTimestampMaster,
+            timestampAdjuster,
+            previous,
+            mediaPlaylist.drmInitData,
+            encryptionKey,
+            encryptionIv);
   }
 
   /**
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
index 5ca8675dd9..9e993aa27b 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java
@@ -66,6 +66,7 @@
   private final DataSpec initDataSpec;
   private final boolean isEncrypted;
   private final boolean isMasterTimestampSource;
+  private final boolean hasGapTag;
   private final TimestampAdjuster timestampAdjuster;
   private final boolean shouldSpliceIn;
   private final Extractor extractor;
@@ -83,8 +84,8 @@
   private volatile boolean loadCompleted;
 
   /**
-   * @param extractorFactory A {@link HlsExtractorFactory} from which the HLS media chunk
-   *     extractor is obtained.
+   * @param extractorFactory A {@link HlsExtractorFactory} from which the HLS media chunk extractor
+   *     is obtained.
    * @param dataSource The source from which the data should be loaded.
    * @param dataSpec Defines the data to be loaded.
    * @param initDataSpec Defines the initialization data to be fed to new extractors. May be null.
@@ -95,8 +96,9 @@
    * @param trackSelectionData See {@link #trackSelectionData}.
    * @param startTimeUs The start time of the chunk in microseconds.
    * @param endTimeUs The end time of the chunk in microseconds.
-   * @param chunkIndex The media sequence number of the chunk.
+   * @param chunkMediaSequence The media sequence number of the chunk.
    * @param discontinuitySequenceNumber The discontinuity sequence number of the chunk.
+   * @param hasGapTag Whether the chunk is tagged with EXT-X-GAP.
    * @param isMasterTimestampSource True if the chunk can initialize the timestamp adjuster.
    * @param timestampAdjuster Adjuster corresponding to the provided discontinuity sequence number.
    * @param previousChunk The {@link HlsMediaChunk} that preceded this one. May be null.
@@ -106,15 +108,35 @@
    * @param encryptionIv The AES initialization vector, or null if the segment is not fully
    *     encrypted.
    */
-  public HlsMediaChunk(HlsExtractorFactory extractorFactory, DataSource dataSource,
-      DataSpec dataSpec, DataSpec initDataSpec, HlsUrl hlsUrl, List<Format> muxedCaptionFormats,
-      int trackSelectionReason, Object trackSelectionData, long startTimeUs, long endTimeUs,
-      int chunkIndex, int discontinuitySequenceNumber, boolean isMasterTimestampSource,
-      TimestampAdjuster timestampAdjuster, HlsMediaChunk previousChunk, DrmInitData drmInitData,
-      byte[] fullSegmentEncryptionKey, byte[] encryptionIv) {
-    super(buildDataSource(dataSource, fullSegmentEncryptionKey, encryptionIv), dataSpec,
-        hlsUrl.format, trackSelectionReason, trackSelectionData, startTimeUs, endTimeUs,
-        chunkIndex);
+  public HlsMediaChunk(
+      HlsExtractorFactory extractorFactory,
+      DataSource dataSource,
+      DataSpec dataSpec,
+      DataSpec initDataSpec,
+      HlsUrl hlsUrl,
+      List<Format> muxedCaptionFormats,
+      int trackSelectionReason,
+      Object trackSelectionData,
+      long startTimeUs,
+      long endTimeUs,
+      long chunkMediaSequence,
+      int discontinuitySequenceNumber,
+      boolean hasGapTag,
+      boolean isMasterTimestampSource,
+      TimestampAdjuster timestampAdjuster,
+      HlsMediaChunk previousChunk,
+      DrmInitData drmInitData,
+      byte[] fullSegmentEncryptionKey,
+      byte[] encryptionIv) {
+    super(
+        buildDataSource(dataSource, fullSegmentEncryptionKey, encryptionIv),
+        dataSpec,
+        hlsUrl.format,
+        trackSelectionReason,
+        trackSelectionData,
+        startTimeUs,
+        endTimeUs,
+        chunkMediaSequence);
     this.discontinuitySequenceNumber = discontinuitySequenceNumber;
     this.initDataSpec = initDataSpec;
     this.hlsUrl = hlsUrl;
@@ -122,6 +144,7 @@ public HlsMediaChunk(HlsExtractorFactory extractorFactory, DataSource dataSource
     this.timestampAdjuster = timestampAdjuster;
     // Note: this.dataSource and dataSource may be different.
     this.isEncrypted = this.dataSource instanceof Aes128DataSource;
+    this.hasGapTag = hasGapTag;
     Extractor previousExtractor = null;
     if (previousChunk != null) {
       shouldSpliceIn = previousChunk.hlsUrl != hlsUrl;
@@ -137,9 +160,13 @@ public HlsMediaChunk(HlsExtractorFactory extractorFactory, DataSource dataSource
     reusingExtractor = extractor == previousExtractor;
     initLoadCompleted = reusingExtractor && initDataSpec != null;
     if (isPackedAudioExtractor) {
-      id3Decoder = previousChunk != null ? previousChunk.id3Decoder : new Id3Decoder();
-      id3Data =  previousChunk != null ? previousChunk.id3Data
-          : new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
+      if (previousChunk != null && previousChunk.id3Data != null) {
+        id3Decoder = previousChunk.id3Decoder;
+        id3Data = previousChunk.id3Data;
+      } else {
+        id3Decoder = new Id3Decoder();
+        id3Data = new ParsableByteArray(Id3Decoder.ID3_HEADER_LENGTH);
+      }
     } else {
       id3Decoder = null;
       id3Data = null;
@@ -156,7 +183,7 @@ public HlsMediaChunk(HlsExtractorFactory extractorFactory, DataSource dataSource
    */
   public void init(HlsSampleStreamWrapper output) {
     this.output = output;
-    output.init(uid, shouldSpliceIn);
+    output.init(uid, shouldSpliceIn, reusingExtractor);
     if (!reusingExtractor) {
       extractor.init(output);
     }
@@ -188,7 +215,10 @@ public boolean isLoadCanceled() {
   public void load() throws IOException, InterruptedException {
     maybeLoadInitData();
     if (!loadCanceled) {
-      loadMedia();
+      if (!hasGapTag) {
+        loadMedia();
+      }
+      loadCompleted = true;
     }
   }
 
@@ -260,7 +290,6 @@ private void loadMedia() throws IOException, InterruptedException {
     } finally {
       Util.closeQuietly(dataSource);
     }
-    loadCompleted = true;
   }
 
   /**
@@ -306,7 +335,9 @@ private long peekId3PrivTimestamp(ExtractorInput input) throws IOException, Inte
         if (PRIV_TIMESTAMP_FRAME_OWNER.equals(privFrame.owner)) {
           System.arraycopy(privFrame.privateData, 0, id3Data.data, 0, 8 /* timestamp size */);
           id3Data.reset(8);
-          return id3Data.readLong();
+          // The top 31 bits should be zeros, but explicitly zero them to wrap in the case that the
+          // streaming provider forgot. See: https://github.com/google/ExoPlayer/pull/3495.
+          return id3Data.readLong() & 0x1FFFFFFFFL;
         }
       }
     }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
index ea9e52e62e..11602c722f 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaPeriod.java
@@ -16,13 +16,14 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.os.Handler;
-import android.text.TextUtils;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
-import com.google.android.exoplayer2.source.CompositeSequenceableLoader;
+import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleStream;
+import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
@@ -31,6 +32,8 @@
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -53,23 +56,33 @@
   private final IdentityHashMap<SampleStream, Integer> streamWrapperIndices;
   private final TimestampAdjusterProvider timestampAdjusterProvider;
   private final Handler continueLoadingHandler;
+  private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
+  private final boolean allowChunklessPreparation;
 
   private Callback callback;
   private int pendingPrepareCount;
   private TrackGroupArray trackGroups;
   private HlsSampleStreamWrapper[] sampleStreamWrappers;
   private HlsSampleStreamWrapper[] enabledSampleStreamWrappers;
-  private CompositeSequenceableLoader sequenceableLoader;
-
-  public HlsMediaPeriod(HlsExtractorFactory extractorFactory, HlsPlaylistTracker playlistTracker,
-      HlsDataSourceFactory dataSourceFactory, int minLoadableRetryCount,
-      EventDispatcher eventDispatcher, Allocator allocator) {
+  private SequenceableLoader compositeSequenceableLoader;
+
+  public HlsMediaPeriod(
+      HlsExtractorFactory extractorFactory,
+      HlsPlaylistTracker playlistTracker,
+      HlsDataSourceFactory dataSourceFactory,
+      int minLoadableRetryCount,
+      EventDispatcher eventDispatcher,
+      Allocator allocator,
+      CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
+      boolean allowChunklessPreparation) {
     this.extractorFactory = extractorFactory;
     this.playlistTracker = playlistTracker;
     this.dataSourceFactory = dataSourceFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventDispatcher = eventDispatcher;
     this.allocator = allocator;
+    this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
+    this.allowChunklessPreparation = allowChunklessPreparation;
     streamWrapperIndices = new IdentityHashMap<>();
     timestampAdjusterProvider = new TimestampAdjusterProvider();
     continueLoadingHandler = new Handler();
@@ -178,25 +191,32 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     // Update the local state.
     enabledSampleStreamWrappers = Arrays.copyOf(newEnabledSampleStreamWrappers,
         newEnabledSampleStreamWrapperCount);
-    sequenceableLoader = new CompositeSequenceableLoader(enabledSampleStreamWrappers);
+    compositeSequenceableLoader =
+        compositeSequenceableLoaderFactory.createCompositeSequenceableLoader(
+            enabledSampleStreamWrappers);
     return positionUs;
   }
 
   @Override
-  public void discardBuffer(long positionUs) {
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
     for (HlsSampleStreamWrapper sampleStreamWrapper : enabledSampleStreamWrappers) {
-      sampleStreamWrapper.discardBuffer(positionUs);
+      sampleStreamWrapper.discardBuffer(positionUs, toKeyframe);
     }
   }
 
+  @Override
+  public void reevaluateBuffer(long positionUs) {
+    compositeSequenceableLoader.reevaluateBuffer(positionUs);
+  }
+
   @Override
   public boolean continueLoading(long positionUs) {
-    return sequenceableLoader.continueLoading(positionUs);
+    return compositeSequenceableLoader.continueLoading(positionUs);
   }
 
   @Override
   public long getNextLoadPositionUs() {
-    return sequenceableLoader.getNextLoadPositionUs();
+    return compositeSequenceableLoader.getNextLoadPositionUs();
   }
 
   @Override
@@ -206,7 +226,7 @@ public long readDiscontinuity() {
 
   @Override
   public long getBufferedPositionUs() {
-    return sequenceableLoader.getBufferedPositionUs();
+    return compositeSequenceableLoader.getBufferedPositionUs();
   }
 
   @Override
@@ -225,6 +245,11 @@ public long seekToUs(long positionUs) {
     return positionUs;
   }
 
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    return positionUs;
+  }
+
   // HlsSampleStreamWrapper.Callback implementation.
 
   @Override
@@ -282,15 +307,92 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
 
   private void buildAndPrepareSampleStreamWrappers(long positionUs) {
     HlsMasterPlaylist masterPlaylist = playlistTracker.getMasterPlaylist();
-    // Build the default stream wrapper.
+    List<HlsUrl> audioRenditions = masterPlaylist.audios;
+    List<HlsUrl> subtitleRenditions = masterPlaylist.subtitles;
+
+    int wrapperCount = 1 /* variants */ + audioRenditions.size() + subtitleRenditions.size();
+    sampleStreamWrappers = new HlsSampleStreamWrapper[wrapperCount];
+    pendingPrepareCount = wrapperCount;
+
+    buildAndPrepareMainSampleStreamWrapper(masterPlaylist, positionUs);
+    int currentWrapperIndex = 1;
+
+    // TODO: Build video stream wrappers here.
+
+    // Audio sample stream wrappers.
+    for (int i = 0; i < audioRenditions.size(); i++) {
+      HlsUrl audioRendition = audioRenditions.get(i);
+      HlsSampleStreamWrapper sampleStreamWrapper =
+          buildSampleStreamWrapper(
+              C.TRACK_TYPE_AUDIO,
+              new HlsUrl[] {audioRendition},
+              null,
+              Collections.<Format>emptyList(),
+              positionUs);
+      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+      Format renditionFormat = audioRendition.format;
+      if (allowChunklessPreparation && renditionFormat.codecs != null) {
+        sampleStreamWrapper.prepareWithMasterPlaylistInfo(
+            new TrackGroupArray(new TrackGroup(audioRendition.format)), 0);
+      } else {
+        sampleStreamWrapper.continuePreparing();
+      }
+    }
+
+    // Subtitle stream wrappers. We can always use master playlist information to prepare these.
+    for (int i = 0; i < subtitleRenditions.size(); i++) {
+      HlsUrl url = subtitleRenditions.get(i);
+      HlsSampleStreamWrapper sampleStreamWrapper =
+          buildSampleStreamWrapper(
+              C.TRACK_TYPE_TEXT,
+              new HlsUrl[] {url},
+              null,
+              Collections.<Format>emptyList(),
+              positionUs);
+      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+      sampleStreamWrapper.prepareWithMasterPlaylistInfo(
+          new TrackGroupArray(new TrackGroup(url.format)), 0);
+    }
+
+    // All wrappers are enabled during preparation.
+    enabledSampleStreamWrappers = sampleStreamWrappers;
+  }
+
+  /**
+   * This method creates and starts preparation of the main {@link HlsSampleStreamWrapper}.
+   *
+   * <p>The main sample stream wrapper is the first element of {@link #sampleStreamWrappers}. It
+   * provides {@link SampleStream}s for the variant urls in the master playlist. It may be adaptive
+   * and may contain multiple muxed tracks.
+   *
+   * <p>If chunkless preparation is allowed, the media period will try preparation without segment
+   * downloads. This is only possible if variants contain the CODECS attribute. If not, traditional
+   * preparation with segment downloads will take place. The following points apply to chunkless
+   * preparation:
+   *
+   * <ul>
+   *   <li>A muxed audio track will be exposed if the codecs list contain an audio entry and the
+   *       master playlist either contains an EXT-X-MEDIA tag without the URI attribute or does not
+   *       contain any EXT-X-MEDIA tag.
+   *   <li>Closed captions will only be exposed if they are declared by the master playlist.
+   *   <li>ID3 tracks are not exposed.
+   * </ul>
+   *
+   * @param masterPlaylist The HLS master playlist.
+   * @param positionUs If preparation requires any chunk downloads, the position in microseconds at
+   *     which downloading should start. Ignored otherwise.
+   */
+  private void buildAndPrepareMainSampleStreamWrapper(
+      HlsMasterPlaylist masterPlaylist, long positionUs) {
     List<HlsUrl> selectedVariants = new ArrayList<>(masterPlaylist.variants);
     ArrayList<HlsUrl> definiteVideoVariants = new ArrayList<>();
     ArrayList<HlsUrl> definiteAudioOnlyVariants = new ArrayList<>();
     for (int i = 0; i < selectedVariants.size(); i++) {
       HlsUrl variant = selectedVariants.get(i);
-      if (variant.format.height > 0 || variantHasExplicitCodecWithPrefix(variant, "avc")) {
+      Format format = variant.format;
+      if (format.height > 0 || Util.getCodecsOfType(format.codecs, C.TRACK_TYPE_VIDEO) != null) {
         definiteVideoVariants.add(variant);
-      } else if (variantHasExplicitCodecWithPrefix(variant, "mp4a")) {
+      } else if (Util.getCodecsOfType(format.codecs, C.TRACK_TYPE_AUDIO) != null) {
         definiteAudioOnlyVariants.add(variant);
       }
     }
@@ -306,43 +408,56 @@ private void buildAndPrepareSampleStreamWrappers(long positionUs) {
     } else {
       // Leave the enabled variants unchanged. They're likely either all video or all audio.
     }
-    List<HlsUrl> audioRenditions = masterPlaylist.audios;
-    List<HlsUrl> subtitleRenditions = masterPlaylist.subtitles;
-    sampleStreamWrappers = new HlsSampleStreamWrapper[1 /* variants */ + audioRenditions.size()
-        + subtitleRenditions.size()];
-    int currentWrapperIndex = 0;
-    pendingPrepareCount = sampleStreamWrappers.length;
-
     Assertions.checkArgument(!selectedVariants.isEmpty());
-    HlsUrl[] variants = new HlsMasterPlaylist.HlsUrl[selectedVariants.size()];
-    selectedVariants.toArray(variants);
+    HlsUrl[] variants = selectedVariants.toArray(new HlsUrl[0]);
+    String codecs = variants[0].format.codecs;
     HlsSampleStreamWrapper sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_DEFAULT,
         variants, masterPlaylist.muxedAudioFormat, masterPlaylist.muxedCaptionFormats, positionUs);
-    sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
-    sampleStreamWrapper.setIsTimestampMaster(true);
-    sampleStreamWrapper.continuePreparing();
-
-    // TODO: Build video stream wrappers here.
-
-    // Build audio stream wrappers.
-    for (int i = 0; i < audioRenditions.size(); i++) {
-      sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_AUDIO,
-          new HlsUrl[] {audioRenditions.get(i)}, null, Collections.<Format>emptyList(), positionUs);
-      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
+    sampleStreamWrappers[0] = sampleStreamWrapper;
+    if (allowChunklessPreparation && codecs != null) {
+      boolean variantsContainVideoCodecs = Util.getCodecsOfType(codecs, C.TRACK_TYPE_VIDEO) != null;
+      boolean variantsContainAudioCodecs = Util.getCodecsOfType(codecs, C.TRACK_TYPE_AUDIO) != null;
+      List<TrackGroup> muxedTrackGroups = new ArrayList<>();
+      if (variantsContainVideoCodecs) {
+        Format[] videoFormats = new Format[selectedVariants.size()];
+        for (int i = 0; i < videoFormats.length; i++) {
+          videoFormats[i] = deriveVideoFormat(variants[i].format);
+        }
+        muxedTrackGroups.add(new TrackGroup(videoFormats));
+
+        if (variantsContainAudioCodecs
+            && (masterPlaylist.muxedAudioFormat != null || masterPlaylist.audios.isEmpty())) {
+          muxedTrackGroups.add(
+              new TrackGroup(
+                  deriveMuxedAudioFormat(
+                      variants[0].format, masterPlaylist.muxedAudioFormat, Format.NO_VALUE)));
+        }
+        List<Format> ccFormats = masterPlaylist.muxedCaptionFormats;
+        if (ccFormats != null) {
+          for (int i = 0; i < ccFormats.size(); i++) {
+            muxedTrackGroups.add(new TrackGroup(ccFormats.get(i)));
+          }
+        }
+      } else if (variantsContainAudioCodecs) {
+        // Variants only contain audio.
+        Format[] audioFormats = new Format[selectedVariants.size()];
+        for (int i = 0; i < audioFormats.length; i++) {
+          Format variantFormat = variants[i].format;
+          audioFormats[i] =
+              deriveMuxedAudioFormat(
+                  variantFormat, masterPlaylist.muxedAudioFormat, variantFormat.bitrate);
+        }
+        muxedTrackGroups.add(new TrackGroup(audioFormats));
+      } else {
+        // Variants contain codecs but no video or audio entries could be identified.
+        throw new IllegalArgumentException("Unexpected codecs attribute: " + codecs);
+      }
+      sampleStreamWrapper.prepareWithMasterPlaylistInfo(
+          new TrackGroupArray(muxedTrackGroups.toArray(new TrackGroup[0])), 0);
+    } else {
+      sampleStreamWrapper.setIsTimestampMaster(true);
       sampleStreamWrapper.continuePreparing();
     }
-
-    // Build subtitle stream wrappers.
-    for (int i = 0; i < subtitleRenditions.size(); i++) {
-      HlsUrl url = subtitleRenditions.get(i);
-      sampleStreamWrapper = buildSampleStreamWrapper(C.TRACK_TYPE_TEXT, new HlsUrl[] {url}, null,
-          Collections.<Format>emptyList(), positionUs);
-      sampleStreamWrapper.prepareSingleTrack(url.format);
-      sampleStreamWrappers[currentWrapperIndex++] = sampleStreamWrapper;
-    }
-
-    // All wrappers are enabled during preparation.
-    enabledSampleStreamWrappers = sampleStreamWrappers;
   }
 
   private HlsSampleStreamWrapper buildSampleStreamWrapper(int trackType, HlsUrl[] variants,
@@ -364,18 +479,49 @@ private void continuePreparingOrLoading() {
     }
   }
 
-  private static boolean variantHasExplicitCodecWithPrefix(HlsUrl variant, String prefix) {
-    String codecs = variant.format.codecs;
-    if (TextUtils.isEmpty(codecs)) {
-      return false;
-    }
-    String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
-    for (String codec : codecArray) {
-      if (codec.startsWith(prefix)) {
-        return true;
-      }
+  private static Format deriveVideoFormat(Format variantFormat) {
+    String codecs = Util.getCodecsOfType(variantFormat.codecs, C.TRACK_TYPE_VIDEO);
+    String mimeType = MimeTypes.getMediaMimeType(codecs);
+    return Format.createVideoSampleFormat(
+        variantFormat.id,
+        mimeType,
+        codecs,
+        variantFormat.bitrate,
+        Format.NO_VALUE,
+        variantFormat.width,
+        variantFormat.height,
+        variantFormat.frameRate,
+        null,
+        null);
+  }
+
+  private static Format deriveMuxedAudioFormat(
+      Format variantFormat, Format mediaTagFormat, int bitrate) {
+    String codecs;
+    int channelCount = Format.NO_VALUE;
+    int selectionFlags = 0;
+    String language = null;
+    if (mediaTagFormat != null) {
+      codecs = mediaTagFormat.codecs;
+      channelCount = mediaTagFormat.channelCount;
+      selectionFlags = mediaTagFormat.selectionFlags;
+      language = mediaTagFormat.language;
+    } else {
+      codecs = Util.getCodecsOfType(variantFormat.codecs, C.TRACK_TYPE_AUDIO);
     }
-    return false;
+    String mimeType = MimeTypes.getMediaMimeType(codecs);
+    return Format.createAudioSampleFormat(
+        variantFormat.id,
+        mimeType,
+        codecs,
+        bitrate,
+        Format.NO_VALUE,
+        channelCount,
+        Format.NO_VALUE,
+        null,
+        null,
+        selectionFlags,
+        language);
   }
 
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
index 21b27e655d..1fe0d72ea1 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java
@@ -17,15 +17,20 @@
 
 import android.net.Uri;
 import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.extractor.Extractor;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
+import com.google.android.exoplayer2.source.DefaultCompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSourceEventListener;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.source.SinglePeriodTimeline;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylist;
 import com.google.android.exoplayer2.source.hls.playlist.HlsPlaylistParser;
@@ -47,6 +52,163 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.hls");
   }
 
+  /** Factory for {@link HlsMediaSource}s. */
+  public static final class Factory implements AdsMediaSource.MediaSourceFactory {
+
+    private final HlsDataSourceFactory hlsDataSourceFactory;
+
+    private HlsExtractorFactory extractorFactory;
+    private @Nullable ParsingLoadable.Parser<HlsPlaylist> playlistParser;
+    private CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
+    private int minLoadableRetryCount;
+    private boolean allowChunklessPreparation;
+    private boolean isCreateCalled;
+
+    /**
+     * Creates a new factory for {@link HlsMediaSource}s.
+     *
+     * @param dataSourceFactory A data source factory that will be wrapped by a {@link
+     *     DefaultHlsDataSourceFactory} to create {@link DataSource}s for manifests, segments and
+     *     keys.
+     */
+    public Factory(DataSource.Factory dataSourceFactory) {
+      this(new DefaultHlsDataSourceFactory(dataSourceFactory));
+    }
+
+    /**
+     * Creates a new factory for {@link HlsMediaSource}s.
+     *
+     * @param hlsDataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for
+     *     manifests, segments and keys.
+     */
+    public Factory(HlsDataSourceFactory hlsDataSourceFactory) {
+      this.hlsDataSourceFactory = Assertions.checkNotNull(hlsDataSourceFactory);
+      extractorFactory = HlsExtractorFactory.DEFAULT;
+      minLoadableRetryCount = DEFAULT_MIN_LOADABLE_RETRY_COUNT;
+      compositeSequenceableLoaderFactory = new DefaultCompositeSequenceableLoaderFactory();
+    }
+
+    /**
+     * Sets the factory for {@link Extractor}s for the segments. The default value is {@link
+     * HlsExtractorFactory#DEFAULT}.
+     *
+     * @param extractorFactory An {@link HlsExtractorFactory} for {@link Extractor}s for the
+     *     segments.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setExtractorFactory(HlsExtractorFactory extractorFactory) {
+      Assertions.checkState(!isCreateCalled);
+      this.extractorFactory = Assertions.checkNotNull(extractorFactory);
+      return this;
+    }
+
+    /**
+     * Sets the minimum number of times to retry if a loading error occurs. The default value is
+     * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+     *
+     * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
+      Assertions.checkState(!isCreateCalled);
+      this.minLoadableRetryCount = minLoadableRetryCount;
+      return this;
+    }
+
+    /**
+     * Sets the parser to parse HLS playlists. The default is an instance of {@link
+     * HlsPlaylistParser}.
+     *
+     * @param playlistParser A {@link ParsingLoadable.Parser} for HLS playlists.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setPlaylistParser(ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
+      Assertions.checkState(!isCreateCalled);
+      this.playlistParser = Assertions.checkNotNull(playlistParser);
+      return this;
+    }
+
+    /**
+     * Sets the factory to create composite {@link SequenceableLoader}s for when this media source
+     * loads data from multiple streams (video, audio etc...). The default is an instance of {@link
+     * DefaultCompositeSequenceableLoaderFactory}.
+     *
+     * @param compositeSequenceableLoaderFactory A factory to create composite {@link
+     *     SequenceableLoader}s for when this media source loads data from multiple streams (video,
+     *     audio etc...).
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setCompositeSequenceableLoaderFactory(
+        CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory) {
+      Assertions.checkState(!isCreateCalled);
+      this.compositeSequenceableLoaderFactory =
+          Assertions.checkNotNull(compositeSequenceableLoaderFactory);
+      return this;
+    }
+
+    /**
+     * Sets whether chunkless preparation is allowed. If true, preparation without chunk downloads
+     * will be enabled for streams that provide sufficient information in their master playlist.
+     *
+     * @param allowChunklessPreparation Whether chunkless preparation is allowed.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setAllowChunklessPreparation(boolean allowChunklessPreparation) {
+      Assertions.checkState(!isCreateCalled);
+      this.allowChunklessPreparation = allowChunklessPreparation;
+      return this;
+    }
+
+    /**
+     * Returns a new {@link HlsMediaSource} using the current parameters. Media source events will
+     * not be delivered.
+     *
+     * @return The new {@link HlsMediaSource}.
+     */
+    public HlsMediaSource createMediaSource(Uri playlistUri) {
+      return createMediaSource(playlistUri, null, null);
+    }
+
+    /**
+     * Returns a new {@link HlsMediaSource} using the current parameters.
+     *
+     * @param playlistUri The playlist {@link Uri}.
+     * @param eventHandler A handler for events.
+     * @param eventListener A listener of events.
+     * @return The new {@link HlsMediaSource}.
+     */
+    @Override
+    public HlsMediaSource createMediaSource(
+        Uri playlistUri,
+        @Nullable Handler eventHandler,
+        @Nullable MediaSourceEventListener eventListener) {
+      isCreateCalled = true;
+      if (playlistParser == null) {
+        playlistParser = new HlsPlaylistParser();
+      }
+      return new HlsMediaSource(
+          playlistUri,
+          hlsDataSourceFactory,
+          extractorFactory,
+          compositeSequenceableLoaderFactory,
+          minLoadableRetryCount,
+          eventHandler,
+          eventListener,
+          playlistParser,
+          allowChunklessPreparation);
+    }
+
+    @Override
+    public int[] getSupportedTypes() {
+      return new int[] {C.TYPE_HLS};
+    }
+  }
+
   /**
    * The default minimum number of times to retry loading data prior to failing.
    */
@@ -55,9 +217,11 @@
   private final HlsExtractorFactory extractorFactory;
   private final Uri manifestUri;
   private final HlsDataSourceFactory dataSourceFactory;
+  private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
   private final int minLoadableRetryCount;
   private final EventDispatcher eventDispatcher;
   private final ParsingLoadable.Parser<HlsPlaylist> playlistParser;
+  private final boolean allowChunklessPreparation;
 
   private HlsPlaylistTracker playlistTracker;
   private Listener sourceListener;
@@ -67,11 +231,16 @@
    * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
    *     segments and keys.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener An {@link AdaptiveMediaSourceEventListener}. May be null if delivery of
-   *     events is not required.
+   * @param eventListener A {@link MediaSourceEventListener}. May be null if delivery of events is
+   *     not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+  @Deprecated
+  public HlsMediaSource(
+      Uri manifestUri,
+      DataSource.Factory dataSourceFactory,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(manifestUri, dataSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT, eventHandler,
         eventListener);
   }
@@ -80,15 +249,20 @@ public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory, Han
    * @param manifestUri The {@link Uri} of the HLS manifest.
    * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
    *     segments and keys.
-   * @param minLoadableRetryCount The minimum number of times loads must be retried before
-   *     errors are propagated.
+   * @param minLoadableRetryCount The minimum number of times loads must be retried before errors
+   *     are propagated.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener An {@link AdaptiveMediaSourceEventListener}. May be null if delivery of
-   *     events is not required.
+   * @param eventListener A {@link MediaSourceEventListener}. May be null if delivery of events is
+   *     not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
-      int minLoadableRetryCount, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+  @Deprecated
+  public HlsMediaSource(
+      Uri manifestUri,
+      DataSource.Factory dataSourceFactory,
+      int minLoadableRetryCount,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(manifestUri, new DefaultHlsDataSourceFactory(dataSourceFactory),
         HlsExtractorFactory.DEFAULT, minLoadableRetryCount, eventHandler, eventListener,
         new HlsPlaylistParser());
@@ -99,31 +273,60 @@ public HlsMediaSource(Uri manifestUri, DataSource.Factory dataSourceFactory,
    * @param dataSourceFactory An {@link HlsDataSourceFactory} for {@link DataSource}s for manifests,
    *     segments and keys.
    * @param extractorFactory An {@link HlsExtractorFactory} for {@link Extractor}s for the segments.
-   * @param minLoadableRetryCount The minimum number of times loads must be retried before
-   *     errors are propagated.
+   * @param minLoadableRetryCount The minimum number of times loads must be retried before errors
+   *     are propagated.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
-   * @param eventListener An {@link AdaptiveMediaSourceEventListener}. May be null if delivery of
-   *     events is not required.
+   * @param eventListener A {@link MediaSourceEventListener}. May be null if delivery of events is
+   *     not required.
    * @param playlistParser A {@link ParsingLoadable.Parser} for HLS playlists.
+   * @deprecated Use {@link Factory} instead.
    */
-  public HlsMediaSource(Uri manifestUri, HlsDataSourceFactory dataSourceFactory,
-     HlsExtractorFactory extractorFactory, int minLoadableRetryCount, Handler eventHandler,
-     AdaptiveMediaSourceEventListener eventListener,
+  @Deprecated
+  public HlsMediaSource(
+      Uri manifestUri,
+      HlsDataSourceFactory dataSourceFactory,
+      HlsExtractorFactory extractorFactory,
+      int minLoadableRetryCount,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener,
       ParsingLoadable.Parser<HlsPlaylist> playlistParser) {
+    this(
+        manifestUri,
+        dataSourceFactory,
+        extractorFactory,
+        new DefaultCompositeSequenceableLoaderFactory(),
+        minLoadableRetryCount,
+        eventHandler,
+        eventListener,
+        playlistParser,
+        false);
+  }
+
+  private HlsMediaSource(
+      Uri manifestUri,
+      HlsDataSourceFactory dataSourceFactory,
+      HlsExtractorFactory extractorFactory,
+      CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
+      int minLoadableRetryCount,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener,
+      ParsingLoadable.Parser<HlsPlaylist> playlistParser,
+      boolean allowChunklessPreparation) {
     this.manifestUri = manifestUri;
     this.dataSourceFactory = dataSourceFactory;
     this.extractorFactory = extractorFactory;
+    this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.playlistParser = playlistParser;
+    this.allowChunklessPreparation = allowChunklessPreparation;
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
   }
 
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
-    Assertions.checkState(playlistTracker == null);
+    sourceListener = listener;
     playlistTracker = new HlsPlaylistTracker(manifestUri, dataSourceFactory, eventDispatcher,
         minLoadableRetryCount, this, playlistParser);
-    sourceListener = listener;
     playlistTracker.start();
   }
 
@@ -135,8 +338,15 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     Assertions.checkArgument(id.periodIndex == 0);
-    return new HlsMediaPeriod(extractorFactory, playlistTracker, dataSourceFactory,
-        minLoadableRetryCount, eventDispatcher, allocator);
+    return new HlsMediaPeriod(
+        extractorFactory,
+        playlistTracker,
+        dataSourceFactory,
+        minLoadableRetryCount,
+        eventDispatcher,
+        allocator,
+        compositeSequenceableLoaderFactory,
+        allowChunklessPreparation);
   }
 
   @Override
@@ -156,28 +366,50 @@ public void releaseSource() {
   @Override
   public void onPrimaryPlaylistRefreshed(HlsMediaPlaylist playlist) {
     SinglePeriodTimeline timeline;
-    long presentationStartTimeMs = playlist.hasProgramDateTime ? 0 : C.TIME_UNSET;
     long windowStartTimeMs = playlist.hasProgramDateTime ? C.usToMs(playlist.startTimeUs)
         : C.TIME_UNSET;
+    // For playlist types EVENT and VOD we know segments are never removed, so the presentation
+    // started at the same time as the window. Otherwise, we don't know the presentation start time.
+    long presentationStartTimeMs =
+        playlist.playlistType == HlsMediaPlaylist.PLAYLIST_TYPE_EVENT
+                || playlist.playlistType == HlsMediaPlaylist.PLAYLIST_TYPE_VOD
+            ? windowStartTimeMs
+            : C.TIME_UNSET;
     long windowDefaultStartPositionUs = playlist.startOffsetUs;
     if (playlistTracker.isLive()) {
-      long periodDurationUs = playlist.hasEndTag ? (playlist.startTimeUs + playlist.durationUs)
-          : C.TIME_UNSET;
+      long offsetFromInitialStartTimeUs =
+          playlist.startTimeUs - playlistTracker.getInitialStartTimeUs();
+      long periodDurationUs =
+          playlist.hasEndTag ? offsetFromInitialStartTimeUs + playlist.durationUs : C.TIME_UNSET;
       List<HlsMediaPlaylist.Segment> segments = playlist.segments;
       if (windowDefaultStartPositionUs == C.TIME_UNSET) {
         windowDefaultStartPositionUs = segments.isEmpty() ? 0
             : segments.get(Math.max(0, segments.size() - 3)).relativeStartTimeUs;
       }
-      timeline = new SinglePeriodTimeline(presentationStartTimeMs, windowStartTimeMs,
-          periodDurationUs, playlist.durationUs, playlist.startTimeUs, windowDefaultStartPositionUs,
-          true, !playlist.hasEndTag);
+      timeline =
+          new SinglePeriodTimeline(
+              presentationStartTimeMs,
+              windowStartTimeMs,
+              periodDurationUs,
+              /* windowDurationUs= */ playlist.durationUs,
+              /* windowPositionInPeriodUs= */ offsetFromInitialStartTimeUs,
+              windowDefaultStartPositionUs,
+              /* isSeekable= */ true,
+              /* isDynamic= */ !playlist.hasEndTag);
     } else /* not live */ {
       if (windowDefaultStartPositionUs == C.TIME_UNSET) {
         windowDefaultStartPositionUs = 0;
       }
-      timeline = new SinglePeriodTimeline(presentationStartTimeMs, windowStartTimeMs,
-          playlist.startTimeUs + playlist.durationUs, playlist.durationUs, playlist.startTimeUs,
-          windowDefaultStartPositionUs, true, false);
+      timeline =
+          new SinglePeriodTimeline(
+              presentationStartTimeMs,
+              windowStartTimeMs,
+              /* periodDurationUs= */ playlist.durationUs,
+              /* windowDurationUs= */ playlist.durationUs,
+              /* windowPositionInPeriodUs= */ 0,
+              windowDefaultStartPositionUs,
+              /* isSeekable= */ true,
+              /* isDynamic= */ false);
     }
     sourceListener.onSourceInfoRefreshed(this, timeline,
         new HlsManifest(playlistTracker.getMasterPlaylist(), playlist));
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
index e423a682f3..6563a5fba0 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStream.java
@@ -15,43 +15,73 @@
  */
 package com.google.android.exoplayer2.source.hls;
 
+import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
 import com.google.android.exoplayer2.source.SampleStream;
 import java.io.IOException;
 
 /**
- * {@link SampleStream} for a particular track group in HLS.
+ * {@link SampleStream} for a particular sample queue in HLS.
  */
 /* package */ final class HlsSampleStream implements SampleStream {
 
-  public final int group;
-
+  private final int trackGroupIndex;
   private final HlsSampleStreamWrapper sampleStreamWrapper;
+  private int sampleQueueIndex;
 
-  public HlsSampleStream(HlsSampleStreamWrapper sampleStreamWrapper, int group) {
+  public HlsSampleStream(HlsSampleStreamWrapper sampleStreamWrapper, int trackGroupIndex) {
     this.sampleStreamWrapper = sampleStreamWrapper;
-    this.group = group;
+    this.trackGroupIndex = trackGroupIndex;
+    sampleQueueIndex = C.INDEX_UNSET;
+  }
+
+  public void unbindSampleQueue() {
+    if (sampleQueueIndex != C.INDEX_UNSET) {
+      sampleStreamWrapper.unbindSampleQueue(trackGroupIndex);
+      sampleQueueIndex = C.INDEX_UNSET;
+    }
   }
 
+  // SampleStream implementation.
+
   @Override
   public boolean isReady() {
-    return sampleStreamWrapper.isReady(group);
+    return ensureBoundSampleQueue() && sampleStreamWrapper.isReady(sampleQueueIndex);
   }
 
   @Override
   public void maybeThrowError() throws IOException {
+    if (!ensureBoundSampleQueue() && sampleStreamWrapper.isMappingFinished()) {
+      throw new SampleQueueMappingException(
+          sampleStreamWrapper.getTrackGroups().get(trackGroupIndex).getFormat(0).sampleMimeType);
+    }
     sampleStreamWrapper.maybeThrowError();
   }
 
   @Override
   public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer, boolean requireFormat) {
-    return sampleStreamWrapper.readData(group, formatHolder, buffer, requireFormat);
+    if (!ensureBoundSampleQueue()) {
+      return C.RESULT_NOTHING_READ;
+    }
+    return sampleStreamWrapper.readData(sampleQueueIndex, formatHolder, buffer, requireFormat);
   }
 
   @Override
   public int skipData(long positionUs) {
-    return sampleStreamWrapper.skipData(group, positionUs);
+    if (!ensureBoundSampleQueue()) {
+      return 0;
+    }
+    return sampleStreamWrapper.skipData(sampleQueueIndex, positionUs);
   }
 
+  // Internal methods.
+
+  private boolean ensureBoundSampleQueue() {
+    if (sampleQueueIndex != C.INDEX_UNSET) {
+      return true;
+    }
+    sampleQueueIndex = sampleStreamWrapper.bindSampleQueueToSampleStream(trackGroupIndex);
+    return sampleQueueIndex != C.INDEX_UNSET;
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
index ddd6689fa6..f027ba5b05 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsSampleStreamWrapper.java
@@ -16,14 +16,17 @@
 package com.google.android.exoplayer2.source.hls;
 
 import android.os.Handler;
-import android.text.TextUtils;
+import android.util.Log;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.FormatHolder;
+import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.extractor.DummyTrackOutput;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.SeekMap;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.extractor.TrackOutput;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleQueue;
 import com.google.android.exoplayer2.source.SampleQueue.UpstreamFormatChangedListener;
 import com.google.android.exoplayer2.source.SampleStream;
@@ -40,8 +43,8 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.LinkedList;
 
 /**
  * Loads {@link HlsMediaChunk}s obtained from a {@link HlsChunkSource}, and provides
@@ -68,6 +71,8 @@
 
   }
 
+  private static final String TAG = "HlsSampleStreamWrapper";
+
   private static final int PRIMARY_TYPE_NONE = 0;
   private static final int PRIMARY_TYPE_TEXT = 1;
   private static final int PRIMARY_TYPE_AUDIO = 2;
@@ -82,34 +87,43 @@
   private final Loader loader;
   private final EventDispatcher eventDispatcher;
   private final HlsChunkSource.HlsChunkHolder nextChunkHolder;
-  private final LinkedList<HlsMediaChunk> mediaChunks;
+  private final ArrayList<HlsMediaChunk> mediaChunks;
   private final Runnable maybeFinishPrepareRunnable;
+  private final Runnable onTracksEndedRunnable;
   private final Handler handler;
 
   private SampleQueue[] sampleQueues;
   private int[] sampleQueueTrackIds;
+  private boolean audioSampleQueueMappingDone;
+  private int audioSampleQueueIndex;
+  private boolean videoSampleQueueMappingDone;
+  private int videoSampleQueueIndex;
   private boolean sampleQueuesBuilt;
   private boolean prepared;
-  private int enabledTrackCount;
+  private int enabledTrackGroupCount;
   private Format downstreamTrackFormat;
   private boolean released;
 
   // Tracks are complicated in HLS. See documentation of buildTracks for details.
   // Indexed by track (as exposed by this source).
   private TrackGroupArray trackGroups;
-  private int primaryTrackGroupIndex;
-  private boolean haveAudioVideoTrackGroups;
   // Indexed by track group.
-  private boolean[] trackGroupEnabledStates;
-  private boolean[] trackGroupIsAudioVideoFlags;
+  private int[] trackGroupToSampleQueueIndex;
+  private int primaryTrackGroupIndex;
+  private boolean haveAudioVideoSampleQueues;
+  private boolean[] sampleQueuesEnabledStates;
+  private boolean[] sampleQueueIsAudioVideoFlags;
 
-  private long sampleOffsetUs;
   private long lastSeekPositionUs;
   private long pendingResetPositionUs;
   private boolean pendingResetUpstreamFormats;
   private boolean seenFirstTrackSelection;
   private boolean loadingFinished;
 
+  // Accessed only by the loading thread.
+  private boolean tracksEnded;
+  private long sampleOffsetUs;
+
   /**
    * @param trackType The type of the track. One of the {@link C} {@code TRACK_TYPE_*} constants.
    * @param callback A callback for the wrapper.
@@ -134,14 +148,26 @@ public HlsSampleStreamWrapper(int trackType, Callback callback, HlsChunkSource c
     loader = new Loader("Loader:HlsSampleStreamWrapper");
     nextChunkHolder = new HlsChunkSource.HlsChunkHolder();
     sampleQueueTrackIds = new int[0];
+    audioSampleQueueIndex = C.INDEX_UNSET;
+    videoSampleQueueIndex = C.INDEX_UNSET;
     sampleQueues = new SampleQueue[0];
-    mediaChunks = new LinkedList<>();
-    maybeFinishPrepareRunnable = new Runnable() {
-      @Override
-      public void run() {
-        maybeFinishPrepare();
-      }
-    };
+    sampleQueueIsAudioVideoFlags = new boolean[0];
+    sampleQueuesEnabledStates = new boolean[0];
+    mediaChunks = new ArrayList<>();
+    maybeFinishPrepareRunnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            maybeFinishPrepare();
+          }
+        };
+    onTracksEndedRunnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            onTracksEnded();
+          }
+        };
     handler = new Handler();
     lastSeekPositionUs = positionUs;
     pendingResetPositionUs = positionUs;
@@ -154,13 +180,17 @@ public void continuePreparing() {
   }
 
   /**
-   * Prepares a sample stream wrapper for which the master playlist provides enough information to
-   * prepare.
+   * Prepares the sample stream wrapper with master playlist information.
+   *
+   * @param trackGroups This {@link TrackGroupArray} to expose.
+   * @param primaryTrackGroupIndex The index of the adaptive track group.
    */
-  public void prepareSingleTrack(Format format) {
-    track(0, C.TRACK_TYPE_UNKNOWN).format(format);
-    sampleQueuesBuilt = true;
-    maybeFinishPrepare();
+  public void prepareWithMasterPlaylistInfo(
+      TrackGroupArray trackGroups, int primaryTrackGroupIndex) {
+    prepared = true;
+    this.trackGroups = trackGroups;
+    this.primaryTrackGroupIndex = primaryTrackGroupIndex;
+    callback.onPrepared();
   }
 
   public void maybeThrowPrepareError() throws IOException {
@@ -171,6 +201,32 @@ public TrackGroupArray getTrackGroups() {
     return trackGroups;
   }
 
+  public boolean isMappingFinished() {
+    return trackGroupToSampleQueueIndex != null;
+  }
+
+  public int bindSampleQueueToSampleStream(int trackGroupIndex) {
+    if (!isMappingFinished()) {
+      return C.INDEX_UNSET;
+    }
+    int sampleQueueIndex = trackGroupToSampleQueueIndex[trackGroupIndex];
+    if (sampleQueueIndex == C.INDEX_UNSET) {
+      return C.INDEX_UNSET;
+    }
+    if (sampleQueuesEnabledStates[sampleQueueIndex]) {
+      // This sample queue is already bound to a different sample stream.
+      return C.INDEX_UNSET;
+    }
+    sampleQueuesEnabledStates[sampleQueueIndex] = true;
+    return sampleQueueIndex;
+  }
+
+  public void unbindSampleQueue(int trackGroupIndex) {
+    int sampleQueueIndex = trackGroupToSampleQueueIndex[trackGroupIndex];
+    Assertions.checkState(sampleQueuesEnabledStates[sampleQueueIndex]);
+    sampleQueuesEnabledStates[sampleQueueIndex] = false;
+  }
+
   /**
    * Called by the parent {@link HlsMediaPeriod} when a track selection occurs.
    *
@@ -191,20 +247,23 @@ public TrackGroupArray getTrackGroups() {
   public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs, boolean forceReset) {
     Assertions.checkState(prepared);
-    int oldEnabledTrackCount = enabledTrackCount;
+    int oldEnabledTrackGroupCount = enabledTrackGroupCount;
     // Deselect old tracks.
     for (int i = 0; i < selections.length; i++) {
       if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
-        int group = ((HlsSampleStream) streams[i]).group;
-        setTrackGroupEnabledState(group, false);
+        enabledTrackGroupCount--;
+        ((HlsSampleStream) streams[i]).unbindSampleQueue();
         streams[i] = null;
       }
     }
     // We'll always need to seek if we're being forced to reset, or if this is a first selection to
     // a position other than the one we started preparing with, or if we're making a selection
     // having previously disabled all tracks.
-    boolean seekRequired = forceReset
-        || (seenFirstTrackSelection ? oldEnabledTrackCount == 0 : positionUs != lastSeekPositionUs);
+    boolean seekRequired =
+        forceReset
+            || (seenFirstTrackSelection
+                ? oldEnabledTrackGroupCount == 0
+                : positionUs != lastSeekPositionUs);
     // Get the old (i.e. current before the loop below executes) primary track selection. The new
     // primary selection will equal the old one unless it's changed in the loop.
     TrackSelection oldPrimaryTrackSelection = chunkSource.getTrackSelection();
@@ -212,9 +271,9 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
     // Select new tracks.
     for (int i = 0; i < selections.length; i++) {
       if (streams[i] == null && selections[i] != null) {
+        enabledTrackGroupCount++;
         TrackSelection selection = selections[i];
         int trackGroupIndex = trackGroups.indexOf(selection.getTrackGroup());
-        setTrackGroupEnabledState(trackGroupIndex, true);
         if (trackGroupIndex == primaryTrackGroupIndex) {
           primaryTrackSelection = selection;
           chunkSource.selectTracks(selection);
@@ -222,8 +281,8 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
         streams[i] = new HlsSampleStream(this, trackGroupIndex);
         streamResetFlags[i] = true;
         // If there's still a chance of avoiding a seek, try and seek within the sample queue.
-        if (!seekRequired) {
-          SampleQueue sampleQueue = sampleQueues[trackGroupIndex];
+        if (sampleQueuesBuilt && !seekRequired) {
+          SampleQueue sampleQueue = sampleQueues[trackGroupToSampleQueueIndex[trackGroupIndex]];
           sampleQueue.rewind();
           // A seek can be avoided if we're able to advance to the current playback position in the
           // sample queue, or if we haven't read anything from the queue since the previous seek
@@ -235,14 +294,16 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
       }
     }
 
-    if (enabledTrackCount == 0) {
+    if (enabledTrackGroupCount == 0) {
       chunkSource.reset();
       downstreamTrackFormat = null;
       mediaChunks.clear();
       if (loader.isLoading()) {
-        // Discard as much as we can synchronously.
-        for (SampleQueue sampleQueue : sampleQueues) {
-          sampleQueue.discardToEnd();
+        if (sampleQueuesBuilt) {
+          // Discard as much as we can synchronously.
+          for (SampleQueue sampleQueue : sampleQueues) {
+            sampleQueue.discardToEnd();
+          }
         }
         loader.cancelLoading();
       } else {
@@ -257,7 +318,7 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
         if (!seenFirstTrackSelection) {
           long bufferedDurationUs = positionUs < 0 ? -positionUs : 0;
           primaryTrackSelection.updateSelectedTrack(positionUs, bufferedDurationUs, C.TIME_UNSET);
-          int chunkIndex = chunkSource.getTrackGroup().indexOf(mediaChunks.getLast().trackFormat);
+          int chunkIndex = chunkSource.getTrackGroup().indexOf(getLastMediaChunk().trackFormat);
           if (primaryTrackSelection.getSelectedIndexInTrackGroup() != chunkIndex) {
             // This is the first selection and the chunk loaded during preparation does not match
             // the initially selected format.
@@ -288,10 +349,13 @@ public boolean selectTracks(TrackSelection[] selections, boolean[] mayRetainStre
     return seekRequired;
   }
 
-  public void discardBuffer(long positionUs) {
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
+    if (!sampleQueuesBuilt) {
+      return;
+    }
     int sampleQueueCount = sampleQueues.length;
     for (int i = 0; i < sampleQueueCount; i++) {
-      sampleQueues[i].discardTo(positionUs, false, trackGroupEnabledStates[i]);
+      sampleQueues[i].discardTo(positionUs, toKeyframe, sampleQueuesEnabledStates[i]);
     }
   }
 
@@ -306,7 +370,7 @@ public void discardBuffer(long positionUs) {
   public boolean seekToUs(long positionUs, boolean forceReset) {
     lastSeekPositionUs = positionUs;
     // If we're not forced to reset nor have a pending reset, see if we can seek within the buffer.
-    if (!forceReset && !isPendingReset() && seekInsideBufferUs(positionUs)) {
+    if (sampleQueuesBuilt && !forceReset && !isPendingReset() && seekInsideBufferUs(positionUs)) {
       return false;
     }
     // We were unable to seek within the buffer, so need to reset.
@@ -321,37 +385,15 @@ public boolean seekToUs(long positionUs, boolean forceReset) {
     return true;
   }
 
-  @Override
-  public long getBufferedPositionUs() {
-    if (loadingFinished) {
-      return C.TIME_END_OF_SOURCE;
-    } else if (isPendingReset()) {
-      return pendingResetPositionUs;
-    } else {
-      long bufferedPositionUs = lastSeekPositionUs;
-      HlsMediaChunk lastMediaChunk = mediaChunks.getLast();
-      HlsMediaChunk lastCompletedMediaChunk = lastMediaChunk.isLoadCompleted() ? lastMediaChunk
-          : mediaChunks.size() > 1 ? mediaChunks.get(mediaChunks.size() - 2) : null;
-      if (lastCompletedMediaChunk != null) {
-        bufferedPositionUs = Math.max(bufferedPositionUs, lastCompletedMediaChunk.endTimeUs);
-      }
-      for (SampleQueue sampleQueue : sampleQueues) {
-        bufferedPositionUs = Math.max(bufferedPositionUs,
-            sampleQueue.getLargestQueuedTimestampUs());
-      }
-      return bufferedPositionUs;
-    }
-  }
-
   public void release() {
-    boolean releasedSynchronously = loader.release(this);
-    if (prepared && !releasedSynchronously) {
+    if (prepared) {
       // Discard as much as we can synchronously. We only do this if we're prepared, since otherwise
       // sampleQueues may still be being modified by the loading thread.
       for (SampleQueue sampleQueue : sampleQueues) {
         sampleQueue.discardToEnd();
       }
     }
+    loader.release(this);
     handler.removeCallbacksAndMessages(null);
     released = true;
   }
@@ -371,8 +413,8 @@ public void onPlaylistBlacklisted(HlsUrl url, long blacklistMs) {
 
   // SampleStream implementation.
 
-  public boolean isReady(int trackGroupIndex) {
-    return loadingFinished || (!isPendingReset() && sampleQueues[trackGroupIndex].hasNextSample());
+  public boolean isReady(int sampleQueueIndex) {
+    return loadingFinished || (!isPendingReset() && sampleQueues[sampleQueueIndex].hasNextSample());
   }
 
   public void maybeThrowError() throws IOException {
@@ -380,45 +422,23 @@ public void maybeThrowError() throws IOException {
     chunkSource.maybeThrowError();
   }
 
-  public int readData(int trackGroupIndex, FormatHolder formatHolder,
-      DecoderInputBuffer buffer, boolean requireFormat) {
+  public int readData(int sampleQueueIndex, FormatHolder formatHolder, DecoderInputBuffer buffer,
+      boolean requireFormat) {
     if (isPendingReset()) {
       return C.RESULT_NOTHING_READ;
     }
-    int result = sampleQueues[trackGroupIndex].read(formatHolder, buffer, requireFormat,
-        loadingFinished, lastSeekPositionUs);
-    if (result == C.RESULT_BUFFER_READ) {
-      discardToRead();
-    }
-    return result;
-  }
-
-  public int skipData(int trackGroupIndex, long positionUs) {
-    if (isPendingReset()) {
-      return 0;
-    }
-    int skipCount;
-    SampleQueue sampleQueue = sampleQueues[trackGroupIndex];
-    if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
-      skipCount = sampleQueue.advanceToEnd();
-    } else {
-      skipCount = sampleQueue.advanceTo(positionUs, true, true);
-      if (skipCount == SampleQueue.ADVANCE_FAILED) {
-        skipCount = 0;
-      }
-    }
-    if (skipCount > 0) {
-      discardToRead();
-    }
-    return skipCount;
-  }
 
-  private void discardToRead() {
+    // TODO: Split into discard (in discardBuffer) and format change (here and in skipData) steps.
     if (!mediaChunks.isEmpty()) {
-      while (mediaChunks.size() > 1 && finishedReadingChunk(mediaChunks.getFirst())) {
-        mediaChunks.removeFirst();
+      int discardToMediaChunkIndex = 0;
+      while (discardToMediaChunkIndex < mediaChunks.size() - 1
+          && finishedReadingChunk(mediaChunks.get(discardToMediaChunkIndex))) {
+        discardToMediaChunkIndex++;
       }
-      HlsMediaChunk currentChunk = mediaChunks.getFirst();
+      if (discardToMediaChunkIndex > 0) {
+        Util.removeRange(mediaChunks, 0, discardToMediaChunkIndex);
+      }
+      HlsMediaChunk currentChunk = mediaChunks.get(0);
       Format trackFormat = currentChunk.trackFormat;
       if (!trackFormat.equals(downstreamTrackFormat)) {
         eventDispatcher.downstreamFormatChanged(trackType, trackFormat,
@@ -427,27 +447,60 @@ private void discardToRead() {
       }
       downstreamTrackFormat = trackFormat;
     }
+
+    return sampleQueues[sampleQueueIndex].read(formatHolder, buffer, requireFormat, loadingFinished,
+        lastSeekPositionUs);
   }
 
-  private boolean finishedReadingChunk(HlsMediaChunk chunk) {
-    int chunkUid = chunk.uid;
-    for (int i = 0; i < sampleQueues.length; i++) {
-      if (trackGroupEnabledStates[i] && sampleQueues[i].peekSourceId() == chunkUid) {
-        return false;
-      }
+  public int skipData(int sampleQueueIndex, long positionUs) {
+    if (isPendingReset()) {
+      return 0;
     }
-    return true;
-  }
 
-  private void resetSampleQueues() {
-    for (SampleQueue sampleQueue : sampleQueues) {
-      sampleQueue.reset(pendingResetUpstreamFormats);
+    SampleQueue sampleQueue = sampleQueues[sampleQueueIndex];
+    if (loadingFinished && positionUs > sampleQueue.getLargestQueuedTimestampUs()) {
+      return sampleQueue.advanceToEnd();
+    } else {
+      int skipCount = sampleQueue.advanceTo(positionUs, true, true);
+      return skipCount == SampleQueue.ADVANCE_FAILED ? 0 : skipCount;
     }
-    pendingResetUpstreamFormats = false;
   }
 
   // SequenceableLoader implementation
 
+  @Override
+  public long getBufferedPositionUs() {
+    if (loadingFinished) {
+      return C.TIME_END_OF_SOURCE;
+    } else if (isPendingReset()) {
+      return pendingResetPositionUs;
+    } else {
+      long bufferedPositionUs = lastSeekPositionUs;
+      HlsMediaChunk lastMediaChunk = getLastMediaChunk();
+      HlsMediaChunk lastCompletedMediaChunk = lastMediaChunk.isLoadCompleted() ? lastMediaChunk
+          : mediaChunks.size() > 1 ? mediaChunks.get(mediaChunks.size() - 2) : null;
+      if (lastCompletedMediaChunk != null) {
+        bufferedPositionUs = Math.max(bufferedPositionUs, lastCompletedMediaChunk.endTimeUs);
+      }
+      if (sampleQueuesBuilt) {
+        for (SampleQueue sampleQueue : sampleQueues) {
+          bufferedPositionUs =
+              Math.max(bufferedPositionUs, sampleQueue.getLargestQueuedTimestampUs());
+        }
+      }
+      return bufferedPositionUs;
+    }
+  }
+
+  @Override
+  public long getNextLoadPositionUs() {
+    if (isPendingReset()) {
+      return pendingResetPositionUs;
+    } else {
+      return loadingFinished ? C.TIME_END_OF_SOURCE : getLastMediaChunk().endTimeUs;
+    }
+  }
+
   @Override
   public boolean continueLoading(long positionUs) {
     if (loadingFinished || loader.isLoading()) {
@@ -460,7 +513,7 @@ public boolean continueLoading(long positionUs) {
       previousChunk = null;
       loadPositionUs = pendingResetPositionUs;
     } else {
-      previousChunk = mediaChunks.getLast();
+      previousChunk = getLastMediaChunk();
       loadPositionUs = previousChunk.endTimeUs;
     }
     chunkSource.getNextChunk(previousChunk, positionUs, loadPositionUs, nextChunkHolder);
@@ -496,12 +549,8 @@ public boolean continueLoading(long positionUs) {
   }
 
   @Override
-  public long getNextLoadPositionUs() {
-    if (isPendingReset()) {
-      return pendingResetPositionUs;
-    } else {
-      return loadingFinished ? C.TIME_END_OF_SOURCE : mediaChunks.getLast().endTimeUs;
-    }
+  public void reevaluateBuffer(long positionUs) {
+    // Do nothing.
   }
 
   // Loader.Callback implementation.
@@ -527,7 +576,7 @@ public void onLoadCanceled(Chunk loadable, long elapsedRealtimeMs, long loadDura
         loadable.endTimeUs, elapsedRealtimeMs, loadDurationMs, loadable.bytesLoaded());
     if (!released) {
       resetSampleQueues();
-      if (enabledTrackCount > 0) {
+      if (enabledTrackGroupCount > 0) {
         callback.onContinueLoadingRequested(this);
       }
     }
@@ -542,7 +591,7 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
     boolean canceled = false;
     if (chunkSource.onChunkLoadError(loadable, cancelable, error)) {
       if (isMediaChunk) {
-        HlsMediaChunk removed = mediaChunks.removeLast();
+        HlsMediaChunk removed = mediaChunks.remove(mediaChunks.size() - 1);
         Assertions.checkState(removed == loadable);
         if (mediaChunks.isEmpty()) {
           pendingResetPositionUs = lastSeekPositionUs;
@@ -562,7 +611,7 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
       }
       return Loader.DONT_RETRY;
     } else {
-      return Loader.RETRY;
+      return error instanceof ParserException ? Loader.DONT_RETRY_FATAL : Loader.RETRY;
     }
   }
 
@@ -574,8 +623,14 @@ public int onLoadError(Chunk loadable, long elapsedRealtimeMs, long loadDuration
    * @param chunkUid The chunk's uid.
    * @param shouldSpliceIn Whether the samples parsed from the chunk should be spliced into any
    *     samples already queued to the wrapper.
+   * @param reusingExtractor Whether the extractor for the chunk has already been used for preceding
+   *     chunks.
    */
-  public void init(int chunkUid, boolean shouldSpliceIn) {
+  public void init(int chunkUid, boolean shouldSpliceIn, boolean reusingExtractor) {
+    if (!reusingExtractor) {
+      audioSampleQueueMappingDone = false;
+      videoSampleQueueMappingDone = false;
+    }
     for (SampleQueue sampleQueue : sampleQueues) {
       sampleQueue.sourceId(chunkUid);
     }
@@ -589,11 +644,44 @@ public void init(int chunkUid, boolean shouldSpliceIn) {
   // ExtractorOutput implementation. Called by the loading thread.
 
   @Override
-  public SampleQueue track(int id, int type) {
+  public TrackOutput track(int id, int type) {
     int trackCount = sampleQueues.length;
-    for (int i = 0; i < trackCount; i++) {
-      if (sampleQueueTrackIds[i] == id) {
-        return sampleQueues[i];
+
+    // Audio and video tracks are handled manually to ignore ids.
+    if (type == C.TRACK_TYPE_AUDIO) {
+      if (audioSampleQueueIndex != C.INDEX_UNSET) {
+        if (audioSampleQueueMappingDone) {
+          return sampleQueueTrackIds[audioSampleQueueIndex] == id
+              ? sampleQueues[audioSampleQueueIndex]
+              : createDummyTrackOutput(id, type);
+        }
+        audioSampleQueueMappingDone = true;
+        sampleQueueTrackIds[audioSampleQueueIndex] = id;
+        return sampleQueues[audioSampleQueueIndex];
+      } else if (tracksEnded) {
+        return createDummyTrackOutput(id, type);
+      }
+    } else if (type == C.TRACK_TYPE_VIDEO) {
+      if (videoSampleQueueIndex != C.INDEX_UNSET) {
+        if (videoSampleQueueMappingDone) {
+          return sampleQueueTrackIds[videoSampleQueueIndex] == id
+              ? sampleQueues[videoSampleQueueIndex]
+              : createDummyTrackOutput(id, type);
+        }
+        videoSampleQueueMappingDone = true;
+        sampleQueueTrackIds[videoSampleQueueIndex] = id;
+        return sampleQueues[videoSampleQueueIndex];
+      } else if (tracksEnded) {
+        return createDummyTrackOutput(id, type);
+      }
+    } else /* sparse track */ {
+      for (int i = 0; i < trackCount; i++) {
+        if (sampleQueueTrackIds[i] == id) {
+          return sampleQueues[i];
+        }
+      }
+      if (tracksEnded) {
+        return createDummyTrackOutput(id, type);
       }
     }
     SampleQueue trackOutput = new SampleQueue(allocator);
@@ -603,13 +691,25 @@ public SampleQueue track(int id, int type) {
     sampleQueueTrackIds[trackCount] = id;
     sampleQueues = Arrays.copyOf(sampleQueues, trackCount + 1);
     sampleQueues[trackCount] = trackOutput;
+    sampleQueueIsAudioVideoFlags = Arrays.copyOf(sampleQueueIsAudioVideoFlags, trackCount + 1);
+    sampleQueueIsAudioVideoFlags[trackCount] = type == C.TRACK_TYPE_AUDIO
+        || type == C.TRACK_TYPE_VIDEO;
+    haveAudioVideoSampleQueues |= sampleQueueIsAudioVideoFlags[trackCount];
+    if (type == C.TRACK_TYPE_AUDIO) {
+      audioSampleQueueMappingDone = true;
+      audioSampleQueueIndex = trackCount;
+    } else if (type == C.TRACK_TYPE_VIDEO) {
+      videoSampleQueueMappingDone = true;
+      videoSampleQueueIndex = trackCount;
+    }
+    sampleQueuesEnabledStates = Arrays.copyOf(sampleQueuesEnabledStates, trackCount + 1);
     return trackOutput;
   }
 
   @Override
   public void endTracks() {
-    sampleQueuesBuilt = true;
-    handler.post(maybeFinishPrepareRunnable);
+    tracksEnded = true;
+    handler.post(onTracksEndedRunnable);
   }
 
   @Override
@@ -635,8 +735,31 @@ public void setSampleOffsetUs(long sampleOffsetUs) {
 
   // Internal methods.
 
+  private boolean finishedReadingChunk(HlsMediaChunk chunk) {
+    int chunkUid = chunk.uid;
+    int sampleQueueCount = sampleQueues.length;
+    for (int i = 0; i < sampleQueueCount; i++) {
+      if (sampleQueuesEnabledStates[i] && sampleQueues[i].peekSourceId() == chunkUid) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private void resetSampleQueues() {
+    for (SampleQueue sampleQueue : sampleQueues) {
+      sampleQueue.reset(pendingResetUpstreamFormats);
+    }
+    pendingResetUpstreamFormats = false;
+  }
+
+  private void onTracksEnded() {
+    sampleQueuesBuilt = true;
+    maybeFinishPrepare();
+  }
+
   private void maybeFinishPrepare() {
-    if (released || prepared || !sampleQueuesBuilt) {
+    if (released || trackGroupToSampleQueueIndex != null || !sampleQueuesBuilt) {
       return;
     }
     for (SampleQueue sampleQueue : sampleQueues) {
@@ -644,9 +767,31 @@ private void maybeFinishPrepare() {
         return;
       }
     }
-    buildTracks();
-    prepared = true;
-    callback.onPrepared();
+    if (trackGroups != null) {
+      // The track groups were created with master playlist information. They only need to be mapped
+      // to a sample queue.
+      mapSampleQueuesToMatchTrackGroups();
+    } else {
+      // Tracks are created using media segment information.
+      buildTracks();
+      prepared = true;
+      callback.onPrepared();
+    }
+  }
+
+  private void mapSampleQueuesToMatchTrackGroups() {
+    int trackGroupCount = trackGroups.length;
+    trackGroupToSampleQueueIndex = new int[trackGroupCount];
+    Arrays.fill(trackGroupToSampleQueueIndex, C.INDEX_UNSET);
+    for (int i = 0; i < trackGroupCount; i++) {
+      for (int queueIndex = 0; queueIndex < sampleQueues.length; queueIndex++) {
+        SampleQueue sampleQueue = sampleQueues[queueIndex];
+        if (formatsMatch(sampleQueue.getUpstreamFormat(), trackGroups.get(i).getFormat(0))) {
+          trackGroupToSampleQueueIndex[i] = queueIndex;
+          break;
+        }
+      }
+    }
   }
 
   /**
@@ -712,71 +857,33 @@ private void buildTracks() {
 
     // Instantiate the necessary internal data-structures.
     primaryTrackGroupIndex = C.INDEX_UNSET;
-    trackGroupEnabledStates = new boolean[extractorTrackCount];
-    trackGroupIsAudioVideoFlags = new boolean[extractorTrackCount];
+    trackGroupToSampleQueueIndex = new int[extractorTrackCount];
+    for (int i = 0; i < extractorTrackCount; i++) {
+      trackGroupToSampleQueueIndex[i] = i;
+    }
 
     // Construct the set of exposed track groups.
     TrackGroup[] trackGroups = new TrackGroup[extractorTrackCount];
     for (int i = 0; i < extractorTrackCount; i++) {
       Format sampleFormat = sampleQueues[i].getUpstreamFormat();
-      String mimeType = sampleFormat.sampleMimeType;
-      boolean isAudioVideo = MimeTypes.isVideo(mimeType) || MimeTypes.isAudio(mimeType);
-      trackGroupIsAudioVideoFlags[i] = isAudioVideo;
-      haveAudioVideoTrackGroups |= isAudioVideo;
       if (i == primaryExtractorTrackIndex) {
         Format[] formats = new Format[chunkSourceTrackCount];
         for (int j = 0; j < chunkSourceTrackCount; j++) {
-          formats[j] = deriveFormat(chunkSourceTrackGroup.getFormat(j), sampleFormat);
+          formats[j] = deriveFormat(chunkSourceTrackGroup.getFormat(j), sampleFormat, true);
         }
         trackGroups[i] = new TrackGroup(formats);
         primaryTrackGroupIndex = i;
       } else {
         Format trackFormat = primaryExtractorTrackType == PRIMARY_TYPE_VIDEO
             && MimeTypes.isAudio(sampleFormat.sampleMimeType) ? muxedAudioFormat : null;
-        trackGroups[i] = new TrackGroup(deriveFormat(trackFormat, sampleFormat));
+        trackGroups[i] = new TrackGroup(deriveFormat(trackFormat, sampleFormat, false));
       }
     }
     this.trackGroups = new TrackGroupArray(trackGroups);
   }
 
-  /**
-   * Enables or disables a specified track group.
-   *
-   * @param trackGroupIndex The index of the track group.
-   * @param enabledState True if the group is being enabled, or false if it's being disabled.
-   */
-  private void setTrackGroupEnabledState(int trackGroupIndex, boolean enabledState) {
-    Assertions.checkState(trackGroupEnabledStates[trackGroupIndex] != enabledState);
-    trackGroupEnabledStates[trackGroupIndex] = enabledState;
-    enabledTrackCount = enabledTrackCount + (enabledState ? 1 : -1);
-  }
-
-  /**
-   * Derives a track format corresponding to a given container format, by combining it with sample
-   * level information obtained from the samples.
-   *
-   * @param containerFormat The container format for which the track format should be derived.
-   * @param sampleFormat A sample format from which to obtain sample level information.
-   * @return The derived track format.
-   */
-  private static Format deriveFormat(Format containerFormat, Format sampleFormat) {
-    if (containerFormat == null) {
-      return sampleFormat;
-    }
-    String codecs = null;
-    int sampleTrackType = MimeTypes.getTrackType(sampleFormat.sampleMimeType);
-    if (sampleTrackType == C.TRACK_TYPE_AUDIO) {
-      codecs = getAudioCodecs(containerFormat.codecs);
-    } else if (sampleTrackType == C.TRACK_TYPE_VIDEO) {
-      codecs = getVideoCodecs(containerFormat.codecs);
-    }
-    return sampleFormat.copyWithContainerInfo(containerFormat.id, codecs, containerFormat.bitrate,
-        containerFormat.width, containerFormat.height, containerFormat.selectionFlags,
-        containerFormat.language);
-  }
-
-  private boolean isMediaChunk(Chunk chunk) {
-    return chunk instanceof HlsMediaChunk;
+  private HlsMediaChunk getLastMediaChunk() {
+    return mediaChunks.get(mediaChunks.size() - 1);
   }
 
   private boolean isPendingReset() {
@@ -790,8 +897,8 @@ private boolean isPendingReset() {
    * @return Whether the in-buffer seek was successful.
    */
   private boolean seekInsideBufferUs(long positionUs) {
-    int trackCount = sampleQueues.length;
-    for (int i = 0; i < trackCount; i++) {
+    int sampleQueueCount = sampleQueues.length;
+    for (int i = 0; i < sampleQueueCount; i++) {
       SampleQueue sampleQueue = sampleQueues[i];
       sampleQueue.rewind();
       boolean seekInsideQueue = sampleQueue.advanceTo(positionUs, true, false)
@@ -800,37 +907,67 @@ private boolean seekInsideBufferUs(long positionUs) {
       // is successful. We ignore whether seeks within non-AV queues are successful in this case, as
       // they may be sparse or poorly interleaved. If we only have non-AV tracks then a seek is
       // successful only if the seek into every queue succeeds.
-      if (!seekInsideQueue && (trackGroupIsAudioVideoFlags[i] || !haveAudioVideoTrackGroups)) {
+      if (!seekInsideQueue && (sampleQueueIsAudioVideoFlags[i] || !haveAudioVideoSampleQueues)) {
         return false;
       }
-      sampleQueue.discardToRead();
     }
     return true;
   }
 
-  private static String getAudioCodecs(String codecs) {
-    return getCodecsOfType(codecs, C.TRACK_TYPE_AUDIO);
-  }
-
-  private static String getVideoCodecs(String codecs) {
-    return getCodecsOfType(codecs, C.TRACK_TYPE_VIDEO);
+  /**
+   * Derives a track format using master playlist and sample format information.
+   *
+   * @param playlistFormat The format information obtained from the master playlist.
+   * @param sampleFormat The format information obtained from the samples.
+   * @param propagateBitrate Whether the bitrate from the playlist format should be included in the
+   *     derived format.
+   * @return The derived track format.
+   */
+  private static Format deriveFormat(
+      Format playlistFormat, Format sampleFormat, boolean propagateBitrate) {
+    if (playlistFormat == null) {
+      return sampleFormat;
+    }
+    int bitrate = propagateBitrate ? playlistFormat.bitrate : Format.NO_VALUE;
+    int sampleTrackType = MimeTypes.getTrackType(sampleFormat.sampleMimeType);
+    String codecs = Util.getCodecsOfType(playlistFormat.codecs, sampleTrackType);
+    String mimeType = MimeTypes.getMediaMimeType(codecs);
+    if (mimeType == null) {
+      mimeType = sampleFormat.sampleMimeType;
+    }
+    return sampleFormat.copyWithContainerInfo(
+        playlistFormat.id,
+        mimeType,
+        codecs,
+        bitrate,
+        playlistFormat.width,
+        playlistFormat.height,
+        playlistFormat.selectionFlags,
+        playlistFormat.language);
+  }
+
+  private static boolean isMediaChunk(Chunk chunk) {
+    return chunk instanceof HlsMediaChunk;
   }
 
-  private static String getCodecsOfType(String codecs, int trackType) {
-    if (TextUtils.isEmpty(codecs)) {
-      return null;
+  private static boolean formatsMatch(Format manifestFormat, Format sampleFormat) {
+    String manifestFormatMimeType = manifestFormat.sampleMimeType;
+    String sampleFormatMimeType = sampleFormat.sampleMimeType;
+    int manifestFormatTrackType = MimeTypes.getTrackType(manifestFormatMimeType);
+    if (manifestFormatTrackType != C.TRACK_TYPE_TEXT) {
+      return manifestFormatTrackType == MimeTypes.getTrackType(sampleFormatMimeType);
+    } else if (!Util.areEqual(manifestFormatMimeType, sampleFormatMimeType)) {
+      return false;
     }
-    String[] codecArray = codecs.split("(\\s*,\\s*)|(\\s*$)");
-    StringBuilder builder = new StringBuilder();
-    for (String codec : codecArray) {
-      if (trackType == MimeTypes.getTrackTypeOfCodec(codec)) {
-        if (builder.length() > 0) {
-          builder.append(",");
-        }
-        builder.append(codec);
-      }
+    if (MimeTypes.APPLICATION_CEA608.equals(manifestFormatMimeType)
+        || MimeTypes.APPLICATION_CEA708.equals(manifestFormatMimeType)) {
+      return manifestFormat.accessibilityChannel == sampleFormat.accessibilityChannel;
     }
-    return builder.length() > 0 ? builder.toString() : null;
+    return true;
   }
 
+  private static DummyTrackOutput createDummyTrackOutput(int id, int type) {
+    Log.w(TAG, "Unmapped track with id " + id + " of type " + type);
+    return new DummyTrackOutput();
+  }
 }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/SampleQueueMappingException.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/SampleQueueMappingException.java
new file mode 100644
index 0000000000..2d430d2c79
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/SampleQueueMappingException.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls;
+
+import com.google.android.exoplayer2.source.SampleQueue;
+import com.google.android.exoplayer2.source.TrackGroup;
+import java.io.IOException;
+
+/** Thrown when it is not possible to map a {@link TrackGroup} to a {@link SampleQueue}. */
+public final class SampleQueueMappingException extends IOException {
+
+  /** @param mimeType The mime type of the track group whose mapping failed. */
+  public SampleQueueMappingException(String mimeType) {
+    super("Unable to bind a sample queue to TrackGroup with mime type " + mimeType + ".");
+  }
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
index 5ac61294a4..3d14283e86 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloader.java
@@ -36,7 +36,7 @@
 /**
  * Helper class to download HLS streams.
  *
- * A subset of renditions can be downloaded by selecting them using {@link
+ * <p>A subset of renditions can be downloaded by selecting them using {@link
  * #selectRepresentations(Object[])}. As key, string form of the rendition's url is used. The urls
  * can be absolute or relative to the master playlist url.
  */
@@ -49,6 +49,16 @@ public HlsDownloader(Uri manifestUri, DownloaderConstructorHelper constructorHel
     super(manifestUri, constructorHelper);
   }
 
+  @Override
+  public String[] getAllRepresentationKeys() throws IOException {
+    ArrayList<String> urls = new ArrayList<>();
+    HlsMasterPlaylist manifest = getManifest();
+    extractUrls(manifest.variants, urls);
+    extractUrls(manifest.audios, urls);
+    extractUrls(manifest.subtitles, urls);
+    return urls.toArray(new String[urls.size()]);
+  }
+
   @Override
   protected HlsMasterPlaylist getManifest(DataSource dataSource, Uri uri) throws IOException {
     HlsPlaylist hlsPlaylist = loadManifest(dataSource, uri);
@@ -59,17 +69,6 @@ protected HlsMasterPlaylist getManifest(DataSource dataSource, Uri uri) throws I
     }
   }
 
-  @Override
-  protected List<Segment> getAllSegments(DataSource dataSource, HlsMasterPlaylist manifest,
-      boolean allowIndexLoadErrors) throws InterruptedException, IOException {
-    ArrayList<String> urls = new ArrayList<>();
-    extractUrls(manifest.variants, urls);
-    extractUrls(manifest.audios, urls);
-    extractUrls(manifest.subtitles, urls);
-    return getSegments(dataSource, manifest, urls.toArray(new String[urls.size()]),
-        allowIndexLoadErrors);
-  }
-
   @Override
   protected List<Segment> getSegments(DataSource dataSource, HlsMasterPlaylist manifest,
       String[] keys, boolean allowIndexLoadErrors) throws InterruptedException, IOException {
@@ -104,18 +103,18 @@ protected HlsMasterPlaylist getManifest(DataSource dataSource, Uri uri) throws I
     return segments;
   }
 
-  private HlsPlaylist loadManifest(DataSource dataSource, Uri uri) throws IOException {
-    DataSpec dataSpec = new DataSpec(uri,
-        DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH | DataSpec.FLAG_ALLOW_GZIP);
-    ParsingLoadable<HlsPlaylist> loadable = new ParsingLoadable<>(dataSource, dataSpec,
-        C.DATA_TYPE_MANIFEST, new HlsPlaylistParser());
+  private static HlsPlaylist loadManifest(DataSource dataSource, Uri uri) throws IOException {
+    ParsingLoadable<HlsPlaylist> loadable =
+        new ParsingLoadable<>(dataSource, uri, C.DATA_TYPE_MANIFEST, new HlsPlaylistParser());
     loadable.load();
     return loadable.getResult();
   }
 
-  private static void addSegment(ArrayList<Segment> segments, HlsMediaPlaylist mediaPlaylist,
-      HlsMediaPlaylist.Segment hlsSegment, HashSet<Uri> encryptionKeyUris)
-      throws IOException, InterruptedException {
+  private static void addSegment(
+      ArrayList<Segment> segments,
+      HlsMediaPlaylist mediaPlaylist,
+      HlsMediaPlaylist.Segment hlsSegment,
+      HashSet<Uri> encryptionKeyUris) {
     long startTimeUs = mediaPlaylist.startTimeUs + hlsSegment.relativeStartTimeUs;
     if (hlsSegment.fullSegmentEncryptionKeyUri != null) {
       Uri keyUri = UriUtil.resolveToUri(mediaPlaylist.baseUri,
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/FilteringHlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/FilteringHlsPlaylistParser.java
new file mode 100644
index 0000000000..24fa0df7d1
--- /dev/null
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/FilteringHlsPlaylistParser.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.playlist;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.upstream.ParsingLoadable.Parser;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+
+/** A HLS playlists parser which includes only the renditions identified by the given urls. */
+public final class FilteringHlsPlaylistParser implements Parser<HlsPlaylist> {
+
+  private final HlsPlaylistParser hlsPlaylistParser;
+  private final List<String> filter;
+
+  /** @param filter The urls to renditions that should be retained in the parsed playlists. */
+  public FilteringHlsPlaylistParser(List<String> filter) {
+    this.hlsPlaylistParser = new HlsPlaylistParser();
+    this.filter = filter;
+  }
+
+  @Override
+  public HlsPlaylist parse(Uri uri, InputStream inputStream) throws IOException {
+    HlsPlaylist hlsPlaylist = hlsPlaylistParser.parse(uri, inputStream);
+    if (hlsPlaylist instanceof HlsMasterPlaylist) {
+      return ((HlsMasterPlaylist) hlsPlaylist).copy(filter);
+    } else {
+      return hlsPlaylist;
+    }
+  }
+}
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
index b21ecb02d5..9a9517e2d4 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylist.java
@@ -29,9 +29,8 @@
  */
 public final class HlsMediaPlaylist extends HlsPlaylist {
 
-  /**
-   * Media segment reference.
-   */
+  /** Media segment reference. */
+  @SuppressWarnings("ComparableType")
   public static final class Segment implements Comparable<Long> {
 
     /**
@@ -70,8 +69,16 @@
      */
     public final long byterangeLength;
 
+    /** Whether the segment is tagged with #EXT-X-GAP. */
+    public final boolean hasGapTag;
+
+    /**
+     * @param uri See {@link #url}.
+     * @param byterangeOffset See {@link #byterangeOffset}.
+     * @param byterangeLength See {@link #byterangeLength}.
+     */
     public Segment(String uri, long byterangeOffset, long byterangeLength) {
-      this(uri, 0, -1, C.TIME_UNSET, null, null, byterangeOffset, byterangeLength);
+      this(uri, 0, -1, C.TIME_UNSET, null, null, byterangeOffset, byterangeLength, false);
     }
 
     /**
@@ -83,10 +90,18 @@ public Segment(String uri, long byterangeOffset, long byterangeLength) {
      * @param encryptionIV See {@link #encryptionIV}.
      * @param byterangeOffset See {@link #byterangeOffset}.
      * @param byterangeLength See {@link #byterangeLength}.
+     * @param hasGapTag See {@link #hasGapTag}.
      */
-    public Segment(String url, long durationUs, int relativeDiscontinuitySequence,
-        long relativeStartTimeUs, String fullSegmentEncryptionKeyUri,
-        String encryptionIV, long byterangeOffset, long byterangeLength) {
+    public Segment(
+        String url,
+        long durationUs,
+        int relativeDiscontinuitySequence,
+        long relativeStartTimeUs,
+        String fullSegmentEncryptionKeyUri,
+        String encryptionIV,
+        long byterangeOffset,
+        long byterangeLength,
+        boolean hasGapTag) {
       this.url = url;
       this.durationUs = durationUs;
       this.relativeDiscontinuitySequence = relativeDiscontinuitySequence;
@@ -95,6 +110,7 @@ public Segment(String url, long durationUs, int relativeDiscontinuitySequence,
       this.encryptionIV = encryptionIV;
       this.byterangeOffset = byterangeOffset;
       this.byterangeLength = byterangeLength;
+      this.hasGapTag = hasGapTag;
     }
 
     @Override
@@ -140,7 +156,7 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    * The media sequence number of the first media segment in the playlist, as defined by
    * #EXT-X-MEDIA-SEQUENCE.
    */
-  public final int mediaSequence;
+  public final long mediaSequence;
   /**
    * The compatibility version, as defined by #EXT-X-VERSION.
    */
@@ -197,11 +213,23 @@ public int compareTo(@NonNull Long relativeStartTimeUs) {
    * @param initializationSegment See {@link #initializationSegment}.
    * @param segments See {@link #segments}.
    */
-  public HlsMediaPlaylist(@PlaylistType int playlistType, String baseUri, List<String> tags,
-      long startOffsetUs, long startTimeUs, boolean hasDiscontinuitySequence,
-      int discontinuitySequence, int mediaSequence, int version, long targetDurationUs,
-      boolean hasIndependentSegmentsTag, boolean hasEndTag, boolean hasProgramDateTime,
-      DrmInitData drmInitData, Segment initializationSegment, List<Segment> segments) {
+  public HlsMediaPlaylist(
+      @PlaylistType int playlistType,
+      String baseUri,
+      List<String> tags,
+      long startOffsetUs,
+      long startTimeUs,
+      boolean hasDiscontinuitySequence,
+      int discontinuitySequence,
+      long mediaSequence,
+      int version,
+      long targetDurationUs,
+      boolean hasIndependentSegmentsTag,
+      boolean hasEndTag,
+      boolean hasProgramDateTime,
+      DrmInitData drmInitData,
+      Segment initializationSegment,
+      List<Segment> segments) {
     super(baseUri, tags);
     this.playlistType = playlistType;
     this.startTimeUs = startTimeUs;
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
index c63ded6275..acd0746e72 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistParser.java
@@ -35,6 +35,7 @@
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Queue;
@@ -66,6 +67,7 @@
   private static final String TAG_ENDLIST = "#EXT-X-ENDLIST";
   private static final String TAG_KEY = "#EXT-X-KEY";
   private static final String TAG_BYTERANGE = "#EXT-X-BYTERANGE";
+  private static final String TAG_GAP = "#EXT-X-GAP";
 
   private static final String TYPE_AUDIO = "AUDIO";
   private static final String TYPE_VIDEO = "VIDEO";
@@ -75,7 +77,9 @@
   private static final String METHOD_NONE = "NONE";
   private static final String METHOD_AES_128 = "AES-128";
   private static final String METHOD_SAMPLE_AES = "SAMPLE-AES";
+  // Replaced by METHOD_SAMPLE_AES_CTR. Keep for backward compatibility.
   private static final String METHOD_SAMPLE_AES_CENC = "SAMPLE-AES-CENC";
+  private static final String METHOD_SAMPLE_AES_CTR = "SAMPLE-AES-CTR";
   private static final String KEYFORMAT_IDENTITY = "identity";
   private static final String KEYFORMAT_WIDEVINE_PSSH_BINARY =
       "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
@@ -88,6 +92,7 @@
 
   private static final Pattern REGEX_AVERAGE_BANDWIDTH =
       Pattern.compile("AVERAGE-BANDWIDTH=(\\d+)\\b");
+  private static final Pattern REGEX_AUDIO = Pattern.compile("AUDIO=\"(.+?)\"");
   private static final Pattern REGEX_BANDWIDTH = Pattern.compile("[^-]BANDWIDTH=(\\d+)\\b");
   private static final Pattern REGEX_CODECS = Pattern.compile("CODECS=\"(.+?)\"");
   private static final Pattern REGEX_RESOLUTION = Pattern.compile("RESOLUTION=(\\d+x\\d+)");
@@ -106,8 +111,19 @@
       + ":(\\d+(?:@\\d+)?)\\b");
   private static final Pattern REGEX_ATTR_BYTERANGE =
       Pattern.compile("BYTERANGE=\"(\\d+(?:@\\d+)?)\\b\"");
-  private static final Pattern REGEX_METHOD = Pattern.compile("METHOD=(" + METHOD_NONE + "|"
-      + METHOD_AES_128 + "|" + METHOD_SAMPLE_AES + ")");
+  private static final Pattern REGEX_METHOD =
+      Pattern.compile(
+          "METHOD=("
+              + METHOD_NONE
+              + "|"
+              + METHOD_AES_128
+              + "|"
+              + METHOD_SAMPLE_AES
+              + "|"
+              + METHOD_SAMPLE_AES_CENC
+              + "|"
+              + METHOD_SAMPLE_AES_CTR
+              + ")");
   private static final Pattern REGEX_KEYFORMAT = Pattern.compile("KEYFORMAT=\"(.+?)\"");
   private static final Pattern REGEX_URI = Pattern.compile("URI=\"(.+?)\"");
   private static final Pattern REGEX_IV = Pattern.compile("IV=([^,.*]+)");
@@ -115,6 +131,7 @@
       + "|" + TYPE_SUBTITLES + "|" + TYPE_CLOSED_CAPTIONS + ")");
   private static final Pattern REGEX_LANGUAGE = Pattern.compile("LANGUAGE=\"(.+?)\"");
   private static final Pattern REGEX_NAME = Pattern.compile("NAME=\"(.+?)\"");
+  private static final Pattern REGEX_GROUP_ID = Pattern.compile("GROUP-ID=\"(.+?)\"");
   private static final Pattern REGEX_INSTREAM_ID =
       Pattern.compile("INSTREAM-ID=\"((?:CC|SERVICE)\\d+)\"");
   private static final Pattern REGEX_AUTOSELECT = compileBooleanAttrPattern("AUTOSELECT");
@@ -190,9 +207,11 @@ private static int skipIgnorableWhitespace(BufferedReader reader, boolean skipLi
   private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, String baseUri)
       throws IOException {
     HashSet<String> variantUrls = new HashSet<>();
+    HashMap<String, String> audioGroupIdToCodecs = new HashMap<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> variants = new ArrayList<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> audios = new ArrayList<>();
     ArrayList<HlsMasterPlaylist.HlsUrl> subtitles = new ArrayList<>();
+    ArrayList<String> mediaTags = new ArrayList<>();
     ArrayList<String> tags = new ArrayList<>();
     Format muxedAudioFormat = null;
     List<Format> muxedCaptionFormats = null;
@@ -208,47 +227,9 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
       }
 
       if (line.startsWith(TAG_MEDIA)) {
-        @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
-        String uri = parseOptionalStringAttr(line, REGEX_URI);
-        String id = parseStringAttr(line, REGEX_NAME);
-        String language = parseOptionalStringAttr(line, REGEX_LANGUAGE);
-        Format format;
-        switch (parseStringAttr(line, REGEX_TYPE)) {
-          case TYPE_AUDIO:
-            format = Format.createAudioContainerFormat(id, MimeTypes.APPLICATION_M3U8, null, null,
-                Format.NO_VALUE, Format.NO_VALUE, Format.NO_VALUE, null, selectionFlags, language);
-            if (uri == null) {
-              muxedAudioFormat = format;
-            } else {
-              audios.add(new HlsMasterPlaylist.HlsUrl(uri, format));
-            }
-            break;
-          case TYPE_SUBTITLES:
-            format = Format.createTextContainerFormat(id, MimeTypes.APPLICATION_M3U8,
-                MimeTypes.TEXT_VTT, null, Format.NO_VALUE, selectionFlags, language);
-            subtitles.add(new HlsMasterPlaylist.HlsUrl(uri, format));
-            break;
-          case TYPE_CLOSED_CAPTIONS:
-            String instreamId = parseStringAttr(line, REGEX_INSTREAM_ID);
-            String mimeType;
-            int accessibilityChannel;
-            if (instreamId.startsWith("CC")) {
-              mimeType = MimeTypes.APPLICATION_CEA608;
-              accessibilityChannel = Integer.parseInt(instreamId.substring(2));
-            } else /* starts with SERVICE */ {
-              mimeType = MimeTypes.APPLICATION_CEA708;
-              accessibilityChannel = Integer.parseInt(instreamId.substring(7));
-            }
-            if (muxedCaptionFormats == null) {
-              muxedCaptionFormats = new ArrayList<>();
-            }
-            muxedCaptionFormats.add(Format.createTextContainerFormat(id, null, mimeType, null,
-                Format.NO_VALUE, selectionFlags, language, accessibilityChannel));
-            break;
-          default:
-            // Do nothing.
-            break;
-        }
+        // Media tags are parsed at the end to include codec information from #EXT-X-STREAM-INF
+        // tags.
+        mediaTags.add(line);
       } else if (line.startsWith(TAG_STREAM_INF)) {
         noClosedCaptions |= line.contains(ATTR_CLOSED_CAPTIONS_NONE);
         int bitrate = parseIntAttr(line, REGEX_BANDWIDTH);
@@ -279,6 +260,10 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         if (frameRateString != null) {
           frameRate = Float.parseFloat(frameRateString);
         }
+        String audioGroupId = parseOptionalStringAttr(line, REGEX_AUDIO);
+        if (audioGroupId != null && codecs != null) {
+          audioGroupIdToCodecs.put(audioGroupId, Util.getCodecsOfType(codecs, C.TRACK_TYPE_AUDIO));
+        }
         line = iterator.next(); // #EXT-X-STREAM-INF's URI.
         if (variantUrls.add(line)) {
           Format format = Format.createVideoContainerFormat(Integer.toString(variants.size()),
@@ -287,6 +272,56 @@ private static HlsMasterPlaylist parseMasterPlaylist(LineIterator iterator, Stri
         }
       }
     }
+
+    for (int i = 0; i < mediaTags.size(); i++) {
+      line = mediaTags.get(i);
+      @C.SelectionFlags int selectionFlags = parseSelectionFlags(line);
+      String uri = parseOptionalStringAttr(line, REGEX_URI);
+      String id = parseStringAttr(line, REGEX_NAME);
+      String language = parseOptionalStringAttr(line, REGEX_LANGUAGE);
+      String groupId = parseOptionalStringAttr(line, REGEX_GROUP_ID);
+      Format format;
+      switch (parseStringAttr(line, REGEX_TYPE)) {
+        case TYPE_AUDIO:
+          String codecs = audioGroupIdToCodecs.get(groupId);
+          String sampleMimeType = codecs != null ? MimeTypes.getMediaMimeType(codecs) : null;
+          format = Format.createAudioContainerFormat(id, MimeTypes.APPLICATION_M3U8, sampleMimeType,
+              codecs, Format.NO_VALUE, Format.NO_VALUE, Format.NO_VALUE, null, selectionFlags,
+              language);
+          if (uri == null) {
+            muxedAudioFormat = format;
+          } else {
+            audios.add(new HlsMasterPlaylist.HlsUrl(uri, format));
+          }
+          break;
+        case TYPE_SUBTITLES:
+          format = Format.createTextContainerFormat(id, MimeTypes.APPLICATION_M3U8,
+              MimeTypes.TEXT_VTT, null, Format.NO_VALUE, selectionFlags, language);
+          subtitles.add(new HlsMasterPlaylist.HlsUrl(uri, format));
+          break;
+        case TYPE_CLOSED_CAPTIONS:
+          String instreamId = parseStringAttr(line, REGEX_INSTREAM_ID);
+          String mimeType;
+          int accessibilityChannel;
+          if (instreamId.startsWith("CC")) {
+            mimeType = MimeTypes.APPLICATION_CEA608;
+            accessibilityChannel = Integer.parseInt(instreamId.substring(2));
+          } else /* starts with SERVICE */ {
+            mimeType = MimeTypes.APPLICATION_CEA708;
+            accessibilityChannel = Integer.parseInt(instreamId.substring(7));
+          }
+          if (muxedCaptionFormats == null) {
+            muxedCaptionFormats = new ArrayList<>();
+          }
+          muxedCaptionFormats.add(Format.createTextContainerFormat(id, null, mimeType, null,
+              Format.NO_VALUE, selectionFlags, language, accessibilityChannel));
+          break;
+        default:
+          // Do nothing.
+          break;
+      }
+    }
+
     if (noClosedCaptions) {
       muxedCaptionFormats = Collections.emptyList();
     }
@@ -305,7 +340,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
       throws IOException {
     @HlsMediaPlaylist.PlaylistType int playlistType = HlsMediaPlaylist.PLAYLIST_TYPE_UNKNOWN;
     long startOffsetUs = C.TIME_UNSET;
-    int mediaSequence = 0;
+    long mediaSequence = 0;
     int version = 1; // Default version == 1.
     long targetDurationUs = C.TIME_UNSET;
     boolean hasIndependentSegmentsTag = false;
@@ -322,7 +357,8 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
     long segmentStartTimeUs = 0;
     long segmentByteRangeOffset = 0;
     long segmentByteRangeLength = C.LENGTH_UNSET;
-    int segmentMediaSequence = 0;
+    long segmentMediaSequence = 0;
+    boolean hasGapTag = false;
 
     String encryptionKeyUri = null;
     String encryptionIV = null;
@@ -362,7 +398,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
       } else if (line.startsWith(TAG_TARGET_DURATION)) {
         targetDurationUs = parseIntAttr(line, REGEX_TARGET_DURATION) * C.MICROS_PER_SECOND;
       } else if (line.startsWith(TAG_MEDIA_SEQUENCE)) {
-        mediaSequence = parseIntAttr(line, REGEX_MEDIA_SEQUENCE);
+        mediaSequence = parseLongAttr(line, REGEX_MEDIA_SEQUENCE);
         segmentMediaSequence = mediaSequence;
       } else if (line.startsWith(TAG_VERSION)) {
         version = parseIntAttr(line, REGEX_VERSION);
@@ -370,7 +406,7 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         segmentDurationUs =
             (long) (parseDoubleAttr(line, REGEX_MEDIA_DURATION) * C.MICROS_PER_SECOND);
       } else if (line.startsWith(TAG_KEY)) {
-        String method = parseStringAttr(line, REGEX_METHOD);
+        String method = parseOptionalStringAttr(line, REGEX_METHOD);
         String keyFormat = parseOptionalStringAttr(line, REGEX_KEYFORMAT);
         encryptionKeyUri = null;
         encryptionIV = null;
@@ -384,11 +420,16 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
               // Do nothing. Samples are encrypted using an identity key, but this is not supported.
               // Hopefully, a traditional DRM alternative is also provided.
             }
-          } else {
+          } else if (method != null) {
             SchemeData schemeData = parseWidevineSchemeData(line, keyFormat);
             if (schemeData != null) {
-              drmInitData = new DrmInitData(METHOD_SAMPLE_AES_CENC.equals(method)
-                  ? C.CENC_TYPE_cenc : C.CENC_TYPE_cbcs, schemeData);
+              drmInitData =
+                  new DrmInitData(
+                      (METHOD_SAMPLE_AES_CENC.equals(method)
+                              || METHOD_SAMPLE_AES_CTR.equals(method))
+                          ? C.CENC_TYPE_cenc
+                          : C.CENC_TYPE_cbcs,
+                      schemeData);
             }
           }
         }
@@ -410,6 +451,12 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
               C.msToUs(Util.parseXsDateTime(line.substring(line.indexOf(':') + 1)));
           playlistStartTimeUs = programDatetimeUs - segmentStartTimeUs;
         }
+      } else if (line.equals(TAG_GAP)) {
+        hasGapTag = true;
+      } else if (line.equals(TAG_INDEPENDENT_SEGMENTS)) {
+        hasIndependentSegmentsTag = true;
+      } else if (line.equals(TAG_ENDLIST)) {
+        hasEndTag = true;
       } else if (!line.startsWith("#")) {
         String segmentEncryptionIV;
         if (encryptionKeyUri == null) {
@@ -417,25 +464,30 @@ private static HlsMediaPlaylist parseMediaPlaylist(LineIterator iterator, String
         } else if (encryptionIV != null) {
           segmentEncryptionIV = encryptionIV;
         } else {
-          segmentEncryptionIV = Integer.toHexString(segmentMediaSequence);
+          segmentEncryptionIV = Long.toHexString(segmentMediaSequence);
         }
         segmentMediaSequence++;
         if (segmentByteRangeLength == C.LENGTH_UNSET) {
           segmentByteRangeOffset = 0;
         }
-        segments.add(new Segment(line, segmentDurationUs, relativeDiscontinuitySequence,
-            segmentStartTimeUs, encryptionKeyUri, segmentEncryptionIV,
-            segmentByteRangeOffset, segmentByteRangeLength));
+        segments.add(
+            new Segment(
+                line,
+                segmentDurationUs,
+                relativeDiscontinuitySequence,
+                segmentStartTimeUs,
+                encryptionKeyUri,
+                segmentEncryptionIV,
+                segmentByteRangeOffset,
+                segmentByteRangeLength,
+                hasGapTag));
         segmentStartTimeUs += segmentDurationUs;
         segmentDurationUs = 0;
         if (segmentByteRangeLength != C.LENGTH_UNSET) {
           segmentByteRangeOffset += segmentByteRangeLength;
         }
         segmentByteRangeLength = C.LENGTH_UNSET;
-      } else if (line.equals(TAG_INDEPENDENT_SEGMENTS)) {
-        hasIndependentSegmentsTag = true;
-      } else if (line.equals(TAG_ENDLIST)) {
-        hasEndTag = true;
+        hasGapTag = false;
       }
     }
     return new HlsMediaPlaylist(playlistType, baseUri, tags, startOffsetUs, playlistStartTimeUs,
@@ -465,6 +517,10 @@ private static int parseIntAttr(String line, Pattern pattern) throws ParserExcep
     return Integer.parseInt(parseStringAttr(line, pattern));
   }
 
+  private static long parseLongAttr(String line, Pattern pattern) throws ParserException {
+    return Long.parseLong(parseStringAttr(line, pattern));
+  }
+
   private static double parseDoubleAttr(String line, Pattern pattern) throws ParserException {
     return Double.parseDouble(parseStringAttr(line, pattern));
   }
diff --git a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
index 355a8575ca..2e565c322a 100644
--- a/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
+++ b/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsPlaylistTracker.java
@@ -20,7 +20,7 @@
 import android.os.SystemClock;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ParserException;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
 import com.google.android.exoplayer2.source.hls.HlsDataSourceFactory;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist.HlsUrl;
@@ -83,7 +83,6 @@ private PlaylistResetException(String url) {
      * @param mediaPlaylist The primary playlist new snapshot.
      */
     void onPrimaryPlaylistRefreshed(HlsMediaPlaylist mediaPlaylist);
-
   }
 
   /**
@@ -128,6 +127,7 @@ private PlaylistResetException(String url) {
   private HlsUrl primaryHlsUrl;
   private HlsMediaPlaylist primaryUrlSnapshot;
   private boolean isLive;
+  private long initialStartTimeUs;
 
   /**
    * @param initialPlaylistUri Uri for the initial playlist of the stream. Can refer a media
@@ -153,6 +153,7 @@ public HlsPlaylistTracker(Uri initialPlaylistUri, HlsDataSourceFactory dataSourc
     initialPlaylistLoader = new Loader("HlsPlaylistTracker:MasterPlaylist");
     playlistBundles = new IdentityHashMap<>();
     playlistRefreshHandler = new Handler();
+    initialStartTimeUs = C.TIME_UNSET;
   }
 
   /**
@@ -208,6 +209,11 @@ public HlsMediaPlaylist getPlaylistSnapshot(HlsUrl url) {
     return snapshot;
   }
 
+  /** Returns the start time of the first loaded primary playlist. */
+  public long getInitialStartTimeUs() {
+    return initialStartTimeUs;
+  }
+
   /**
    * Returns whether the snapshot of the playlist referenced by the provided {@link HlsUrl} is
    * valid, meaning all the segments referenced by the playlist are expected to be available. If the
@@ -371,6 +377,7 @@ private void onPlaylistUpdated(HlsUrl url, HlsMediaPlaylist newSnapshot) {
       if (primaryUrlSnapshot == null) {
         // This is the first primary url snapshot.
         isLive = !newSnapshot.hasEndTag;
+        initialStartTimeUs = newSnapshot.startTimeUs;
       }
       primaryUrlSnapshot = newSnapshot;
       primaryPlaylistListener.onPrimaryPlaylistRefreshed(newSnapshot);
@@ -450,7 +457,7 @@ private int getLoadedPlaylistDiscontinuitySequence(HlsMediaPlaylist oldPlaylist,
 
   private static Segment getFirstOldOverlappingSegment(HlsMediaPlaylist oldPlaylist,
       HlsMediaPlaylist loadedPlaylist) {
-    int mediaSequenceOffset = loadedPlaylist.mediaSequence - oldPlaylist.mediaSequence;
+    int mediaSequenceOffset = (int) (loadedPlaylist.mediaSequence - oldPlaylist.mediaSequence);
     List<Segment> oldSegments = oldPlaylist.segments;
     return mediaSequenceOffset < oldSegments.size() ? oldSegments.get(mediaSequenceOffset) : null;
   }
diff --git a/library/hls/src/androidTest/AndroidManifest.xml b/library/hls/src/test/AndroidManifest.xml
similarity index 71%
rename from library/hls/src/androidTest/AndroidManifest.xml
rename to library/hls/src/test/AndroidManifest.xml
index 1abbcad810..331f3439ad 100644
--- a/library/hls/src/androidTest/AndroidManifest.xml
+++ b/library/hls/src/test/AndroidManifest.xml
@@ -20,14 +20,4 @@
 
   <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
-  <application android:debuggable="true"
-      android:allowBackup="false"
-      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
-    <uses-library android:name="android.test.runner"/>
-  </application>
-
-  <instrumentation
-      android:targetPackage="com.google.android.exoplayer2.source.hls.test"
-      android:name="android.test.InstrumentationTestRunner"/>
-
 </manifest>
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadTestData.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadTestData.java
new file mode 100644
index 0000000000..55db28a59a
--- /dev/null
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloadTestData.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.offline;
+
+import com.google.android.exoplayer2.C;
+import java.nio.charset.Charset;
+
+/** Data for HLS downloading tests. */
+/* package */ interface HlsDownloadTestData {
+
+  String MASTER_PLAYLIST_URI = "test.m3u8";
+
+  String MEDIA_PLAYLIST_0_DIR = "gear0/";
+  String MEDIA_PLAYLIST_0_URI = MEDIA_PLAYLIST_0_DIR + "prog_index.m3u8";
+  String MEDIA_PLAYLIST_1_DIR = "gear1/";
+  String MEDIA_PLAYLIST_1_URI = MEDIA_PLAYLIST_1_DIR + "prog_index.m3u8";
+  String MEDIA_PLAYLIST_2_DIR = "gear2/";
+  String MEDIA_PLAYLIST_2_URI = MEDIA_PLAYLIST_2_DIR + "prog_index.m3u8";
+  String MEDIA_PLAYLIST_3_DIR = "gear3/";
+  String MEDIA_PLAYLIST_3_URI = MEDIA_PLAYLIST_3_DIR + "prog_index.m3u8";
+
+  byte[] MASTER_PLAYLIST_DATA =
+      ("#EXTM3U\n"
+              + "#EXT-X-STREAM-INF:BANDWIDTH=232370,CODECS=\"mp4a.40.2, avc1.4d4015\"\n"
+              + MEDIA_PLAYLIST_1_URI
+              + "\n"
+              + "#EXT-X-STREAM-INF:BANDWIDTH=649879,CODECS=\"mp4a.40.2, avc1.4d401e\"\n"
+              + MEDIA_PLAYLIST_2_URI
+              + "\n"
+              + "#EXT-X-STREAM-INF:BANDWIDTH=991714,CODECS=\"mp4a.40.2, avc1.4d401e\"\n"
+              + MEDIA_PLAYLIST_3_URI
+              + "\n"
+              + "#EXT-X-STREAM-INF:BANDWIDTH=41457,CODECS=\"mp4a.40.2\"\n"
+              + MEDIA_PLAYLIST_0_URI)
+          .getBytes(Charset.forName(C.UTF8_NAME));
+
+  byte[] MEDIA_PLAYLIST_DATA =
+      ("#EXTM3U\n"
+              + "#EXT-X-TARGETDURATION:10\n"
+              + "#EXT-X-VERSION:3\n"
+              + "#EXT-X-MEDIA-SEQUENCE:0\n"
+              + "#EXT-X-PLAYLIST-TYPE:VOD\n"
+              + "#EXTINF:9.97667,\n"
+              + "fileSequence0.ts\n"
+              + "#EXTINF:9.97667,\n"
+              + "fileSequence1.ts\n"
+              + "#EXTINF:9.97667,\n"
+              + "fileSequence2.ts\n"
+              + "#EXT-X-ENDLIST")
+          .getBytes(Charset.forName(C.UTF8_NAME));
+
+  String ENC_MEDIA_PLAYLIST_URI = "enc_index.m3u8";
+
+  byte[] ENC_MEDIA_PLAYLIST_DATA =
+      ("#EXTM3U\n"
+              + "#EXT-X-TARGETDURATION:10\n"
+              + "#EXT-X-VERSION:3\n"
+              + "#EXT-X-MEDIA-SEQUENCE:0\n"
+              + "#EXT-X-PLAYLIST-TYPE:VOD\n"
+              + "#EXT-X-KEY:METHOD=AES-128,URI=\"enc.key\"\n"
+              + "#EXTINF:9.97667,\n"
+              + "fileSequence0.ts\n"
+              + "#EXTINF:9.97667,\n"
+              + "fileSequence1.ts\n"
+              + "#EXT-X-KEY:METHOD=AES-128,URI=\"enc2.key\"\n"
+              + "#EXTINF:9.97667,\n"
+              + "fileSequence2.ts\n"
+              + "#EXT-X-ENDLIST")
+          .getBytes(Charset.forName(C.UTF8_NAME));
+}
diff --git a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
similarity index 72%
rename from library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
rename to library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
index ebf73ebfd7..1e6b98092b 100644
--- a/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/offline/HlsDownloaderTest.java
@@ -30,9 +30,9 @@
 import static com.google.android.exoplayer2.source.hls.offline.HlsDownloadTestData.MEDIA_PLAYLIST_DATA;
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCacheEmpty;
 import static com.google.android.exoplayer2.testutil.CacheAsserts.assertCachedData;
+import static com.google.common.truth.Truth.assertThat;
 
 import android.net.Uri;
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.offline.DownloaderConstructorHelper;
 import com.google.android.exoplayer2.source.hls.playlist.HlsMasterPlaylist;
 import com.google.android.exoplayer2.testutil.FakeDataSet;
@@ -41,91 +41,112 @@
 import com.google.android.exoplayer2.upstream.cache.SimpleCache;
 import com.google.android.exoplayer2.util.Util;
 import java.io.File;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
 /** Unit tests for {@link HlsDownloader}. */
-public class HlsDownloaderTest extends InstrumentationTestCase {
+@RunWith(RobolectricTestRunner.class)
+public class HlsDownloaderTest {
 
   private SimpleCache cache;
   private File tempFolder;
   private FakeDataSet fakeDataSet;
   private HlsDownloader hlsDownloader;
 
-  @Override
+  @Before
   public void setUp() throws Exception {
-    super.setUp();
-    tempFolder = Util.createTempDirectory(getInstrumentation().getContext(), "ExoPlayerTest");
+    tempFolder = Util.createTempDirectory(RuntimeEnvironment.application, "ExoPlayerTest");
     cache = new SimpleCache(tempFolder, new NoOpCacheEvictor());
 
-    fakeDataSet = new FakeDataSet()
-        .setData(MASTER_PLAYLIST_URI, MASTER_PLAYLIST_DATA)
-        .setData(MEDIA_PLAYLIST_1_URI, MEDIA_PLAYLIST_DATA)
-        .setRandomData(MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts", 10)
-        .setRandomData(MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts", 11)
-        .setRandomData(MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts", 12)
-        .setData(MEDIA_PLAYLIST_2_URI, MEDIA_PLAYLIST_DATA)
-        .setRandomData(MEDIA_PLAYLIST_2_DIR + "fileSequence0.ts", 13)
-        .setRandomData(MEDIA_PLAYLIST_2_DIR + "fileSequence1.ts", 14)
-        .setRandomData(MEDIA_PLAYLIST_2_DIR + "fileSequence2.ts", 15);
+    fakeDataSet =
+        new FakeDataSet()
+            .setData(MASTER_PLAYLIST_URI, MASTER_PLAYLIST_DATA)
+            .setData(MEDIA_PLAYLIST_1_URI, MEDIA_PLAYLIST_DATA)
+            .setRandomData(MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts", 10)
+            .setRandomData(MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts", 11)
+            .setRandomData(MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts", 12)
+            .setData(MEDIA_PLAYLIST_2_URI, MEDIA_PLAYLIST_DATA)
+            .setRandomData(MEDIA_PLAYLIST_2_DIR + "fileSequence0.ts", 13)
+            .setRandomData(MEDIA_PLAYLIST_2_DIR + "fileSequence1.ts", 14)
+            .setRandomData(MEDIA_PLAYLIST_2_DIR + "fileSequence2.ts", 15);
     hlsDownloader = getHlsDownloader(MASTER_PLAYLIST_URI);
   }
 
-  @Override
+  @After
   public void tearDown() throws Exception {
     Util.recursiveDelete(tempFolder);
-    super.tearDown();
   }
 
+  @Test
   public void testDownloadManifest() throws Exception {
     HlsMasterPlaylist manifest = hlsDownloader.getManifest();
 
-    assertNotNull(manifest);
+    assertThat(manifest).isNotNull();
     assertCachedData(cache, fakeDataSet, MASTER_PLAYLIST_URI);
   }
 
+  @Test
   public void testSelectRepresentationsClearsPreviousSelection() throws Exception {
     hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
     hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_2_URI});
     hlsDownloader.download(null);
 
-    assertCachedData(cache, fakeDataSet, MASTER_PLAYLIST_URI, MEDIA_PLAYLIST_2_URI,
+    assertCachedData(
+        cache,
+        fakeDataSet,
+        MASTER_PLAYLIST_URI,
+        MEDIA_PLAYLIST_2_URI,
         MEDIA_PLAYLIST_2_DIR + "fileSequence0.ts",
         MEDIA_PLAYLIST_2_DIR + "fileSequence1.ts",
         MEDIA_PLAYLIST_2_DIR + "fileSequence2.ts");
   }
 
+  @Test
   public void testCounterMethods() throws Exception {
     hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
     hlsDownloader.download(null);
 
-    assertEquals(4, hlsDownloader.getTotalSegments());
-    assertEquals(4, hlsDownloader.getDownloadedSegments());
-    assertEquals(MEDIA_PLAYLIST_DATA.length + 10 + 11 + 12, hlsDownloader.getDownloadedBytes());
+    assertThat(hlsDownloader.getTotalSegments()).isEqualTo(4);
+    assertThat(hlsDownloader.getDownloadedSegments()).isEqualTo(4);
+    assertThat(hlsDownloader.getDownloadedBytes())
+        .isEqualTo(MEDIA_PLAYLIST_DATA.length + 10 + 11 + 12);
   }
 
+  @Test
   public void testInitStatus() throws Exception {
     hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
     hlsDownloader.download(null);
 
-    HlsDownloader newHlsDownloader =
-        getHlsDownloader(MASTER_PLAYLIST_URI);
+    HlsDownloader newHlsDownloader = getHlsDownloader(MASTER_PLAYLIST_URI);
     newHlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
     newHlsDownloader.init();
 
-    assertEquals(4, newHlsDownloader.getTotalSegments());
-    assertEquals(4, newHlsDownloader.getDownloadedSegments());
-    assertEquals(MEDIA_PLAYLIST_DATA.length + 10 + 11 + 12, newHlsDownloader.getDownloadedBytes());
+    assertThat(newHlsDownloader.getTotalSegments()).isEqualTo(4);
+    assertThat(newHlsDownloader.getDownloadedSegments()).isEqualTo(4);
+    assertThat(newHlsDownloader.getDownloadedBytes())
+        .isEqualTo(MEDIA_PLAYLIST_DATA.length + 10 + 11 + 12);
   }
 
+  @Test
   public void testDownloadRepresentation() throws Exception {
     hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
     hlsDownloader.download(null);
 
-    assertCachedData(cache, fakeDataSet, MASTER_PLAYLIST_URI, MEDIA_PLAYLIST_1_URI,
+    assertCachedData(
+        cache,
+        fakeDataSet,
+        MASTER_PLAYLIST_URI,
+        MEDIA_PLAYLIST_1_URI,
         MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
         MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
         MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
   }
 
+  @Test
   public void testDownloadMultipleRepresentations() throws Exception {
     hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI, MEDIA_PLAYLIST_2_URI});
     hlsDownloader.download(null);
@@ -133,9 +154,11 @@ public void testDownloadMultipleRepresentations() throws Exception {
     assertCachedData(cache, fakeDataSet);
   }
 
+  @Test
   public void testDownloadAllRepresentations() throws Exception {
     // Add data for the rest of the playlists
-    fakeDataSet.setData(MEDIA_PLAYLIST_0_URI, MEDIA_PLAYLIST_DATA)
+    fakeDataSet
+        .setData(MEDIA_PLAYLIST_0_URI, MEDIA_PLAYLIST_DATA)
         .setRandomData(MEDIA_PLAYLIST_0_DIR + "fileSequence0.ts", 10)
         .setRandomData(MEDIA_PLAYLIST_0_DIR + "fileSequence1.ts", 11)
         .setRandomData(MEDIA_PLAYLIST_0_DIR + "fileSequence2.ts", 12)
@@ -164,6 +187,7 @@ public void testDownloadAllRepresentations() throws Exception {
     hlsDownloader.remove();
   }
 
+  @Test
   public void testRemoveAll() throws Exception {
     hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI, MEDIA_PLAYLIST_2_URI});
     hlsDownloader.download(null);
@@ -172,27 +196,32 @@ public void testRemoveAll() throws Exception {
     assertCacheEmpty(cache);
   }
 
+  @Test
   public void testDownloadMediaPlaylist() throws Exception {
     hlsDownloader = getHlsDownloader(MEDIA_PLAYLIST_1_URI);
     hlsDownloader.selectRepresentations(new String[] {MEDIA_PLAYLIST_1_URI});
     hlsDownloader.download(null);
 
-    assertCachedData(cache, fakeDataSet, MEDIA_PLAYLIST_1_URI,
+    assertCachedData(
+        cache,
+        fakeDataSet,
+        MEDIA_PLAYLIST_1_URI,
         MEDIA_PLAYLIST_1_DIR + "fileSequence0.ts",
         MEDIA_PLAYLIST_1_DIR + "fileSequence1.ts",
         MEDIA_PLAYLIST_1_DIR + "fileSequence2.ts");
   }
 
+  @Test
   public void testDownloadEncMediaPlaylist() throws Exception {
-    fakeDataSet = new FakeDataSet()
-        .setData(ENC_MEDIA_PLAYLIST_URI, ENC_MEDIA_PLAYLIST_DATA)
-        .setRandomData("enc.key", 8)
-        .setRandomData("enc2.key", 9)
-        .setRandomData("fileSequence0.ts", 10)
-        .setRandomData("fileSequence1.ts", 11)
-        .setRandomData("fileSequence2.ts", 12);
-    hlsDownloader =
-        getHlsDownloader(ENC_MEDIA_PLAYLIST_URI);
+    fakeDataSet =
+        new FakeDataSet()
+            .setData(ENC_MEDIA_PLAYLIST_URI, ENC_MEDIA_PLAYLIST_DATA)
+            .setRandomData("enc.key", 8)
+            .setRandomData("enc2.key", 9)
+            .setRandomData("fileSequence0.ts", 10)
+            .setRandomData("fileSequence1.ts", 11)
+            .setRandomData("fileSequence2.ts", 12);
+    hlsDownloader = getHlsDownloader(ENC_MEDIA_PLAYLIST_URI);
     hlsDownloader.selectRepresentations(new String[] {ENC_MEDIA_PLAYLIST_URI});
     hlsDownloader.download(null);
 
@@ -201,8 +230,7 @@ public void testDownloadEncMediaPlaylist() throws Exception {
 
   private HlsDownloader getHlsDownloader(String mediaPlaylistUri) {
     Factory factory = new Factory(null).setFakeDataSet(fakeDataSet);
-    return new HlsDownloader(Uri.parse(mediaPlaylistUri),
-        new DownloaderConstructorHelper(cache, factory));
+    return new HlsDownloader(
+        Uri.parse(mediaPlaylistUri), new DownloaderConstructorHelper(cache, factory));
   }
-
 }
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
new file mode 100644
index 0000000000..86426e1f94
--- /dev/null
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.playlist;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.ParserException;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Test for {@link HlsMasterPlaylistParserTest}. */
+@RunWith(RobolectricTestRunner.class)
+public class HlsMasterPlaylistParserTest {
+
+  private static final String PLAYLIST_URI = "https://example.com/test.m3u8";
+
+  private static final String PLAYLIST_SIMPLE =
+      " #EXTM3U \n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+          + "http://example.com/low.m3u8\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
+          + "http://example.com/spaces_in_codecs.m3u8\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=2560000,FRAME-RATE=25,RESOLUTION=384x160\n"
+          + "http://example.com/mid.m3u8\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=7680000,FRAME-RATE=29.997\n"
+          + "http://example.com/hi.m3u8\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\n"
+          + "http://example.com/audio-only.m3u8";
+
+  private static final String PLAYLIST_WITH_AVG_BANDWIDTH =
+      " #EXTM3U \n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+          + "http://example.com/low.m3u8\n"
+          + "\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,AVERAGE-BANDWIDTH=1270000,"
+          + "CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
+          + "http://example.com/spaces_in_codecs.m3u8\n";
+
+  private static final String PLAYLIST_WITH_INVALID_HEADER =
+      "#EXTMU3\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+          + "http://example.com/low.m3u8\n";
+
+  private static final String PLAYLIST_WITH_CC =
+      " #EXTM3U \n"
+          + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,"
+          + "LANGUAGE=\"es\",NAME=\"Eng\",INSTREAM-ID=\"SERVICE4\"\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
+          + "http://example.com/low.m3u8\n";
+
+  private static final String PLAYLIST_WITHOUT_CC =
+      " #EXTM3U \n"
+          + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,"
+          + "LANGUAGE=\"es\",NAME=\"Eng\",INSTREAM-ID=\"SERVICE4\"\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,"
+          + "CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128,"
+          + "CLOSED-CAPTIONS=NONE\n"
+          + "http://example.com/low.m3u8\n";
+
+  private static final String PLAYLIST_WITH_AUDIO_MEDIA_TAG =
+      "#EXTM3U\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=2227464,CODECS=\"avc1.640020,mp4a.40.2\",AUDIO=\"aud1\"\n"
+          + "uri1.m3u8\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=8178040,CODECS=\"avc1.64002a,mp4a.40.2\",AUDIO=\"aud1\"\n"
+          + "uri2.m3u8\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=2448841,CODECS=\"avc1.640020,ac-3\",AUDIO=\"aud2\"\n"
+          + "uri1.m3u8\n"
+          + "#EXT-X-STREAM-INF:BANDWIDTH=8399417,CODECS=\"avc1.64002a,ac-3\",AUDIO=\"aud2\"\n"
+          + "uri2.m3u8\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aud1\",LANGUAGE=\"en\",NAME=\"English\","
+          + "AUTOSELECT=YES,DEFAULT=YES,CHANNELS=\"2\",URI=\"a1/prog_index.m3u8\"\n"
+          + "#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aud2\",LANGUAGE=\"en\",NAME=\"English\","
+          + "AUTOSELECT=YES,DEFAULT=YES,CHANNELS=\"6\",URI=\"a2/prog_index.m3u8\"\n";
+
+  @Test
+  public void testParseMasterPlaylist() throws IOException {
+    HlsMasterPlaylist masterPlaylist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_SIMPLE);
+
+    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
+    assertThat(variants).hasSize(5);
+    assertThat(masterPlaylist.muxedCaptionFormats).isNull();
+
+    assertThat(variants.get(0).format.bitrate).isEqualTo(1280000);
+    assertThat(variants.get(0).format.codecs).isEqualTo("mp4a.40.2,avc1.66.30");
+    assertThat(variants.get(0).format.width).isEqualTo(304);
+    assertThat(variants.get(0).format.height).isEqualTo(128);
+    assertThat(variants.get(0).url).isEqualTo("http://example.com/low.m3u8");
+
+    assertThat(variants.get(1).format.bitrate).isEqualTo(1280000);
+    assertThat(variants.get(1).format.codecs).isEqualTo("mp4a.40.2 , avc1.66.30 ");
+    assertThat(variants.get(1).url).isEqualTo("http://example.com/spaces_in_codecs.m3u8");
+
+    assertThat(variants.get(2).format.bitrate).isEqualTo(2560000);
+    assertThat(variants.get(2).format.codecs).isNull();
+    assertThat(variants.get(2).format.width).isEqualTo(384);
+    assertThat(variants.get(2).format.height).isEqualTo(160);
+    assertThat(variants.get(2).format.frameRate).isEqualTo(25.0f);
+    assertThat(variants.get(2).url).isEqualTo("http://example.com/mid.m3u8");
+
+    assertThat(variants.get(3).format.bitrate).isEqualTo(7680000);
+    assertThat(variants.get(3).format.codecs).isNull();
+    assertThat(variants.get(3).format.width).isEqualTo(Format.NO_VALUE);
+    assertThat(variants.get(3).format.height).isEqualTo(Format.NO_VALUE);
+    assertThat(variants.get(3).format.frameRate).isEqualTo(29.997f);
+    assertThat(variants.get(3).url).isEqualTo("http://example.com/hi.m3u8");
+
+    assertThat(variants.get(4).format.bitrate).isEqualTo(65000);
+    assertThat(variants.get(4).format.codecs).isEqualTo("mp4a.40.5");
+    assertThat(variants.get(4).format.width).isEqualTo(Format.NO_VALUE);
+    assertThat(variants.get(4).format.height).isEqualTo(Format.NO_VALUE);
+    assertThat(variants.get(4).format.frameRate).isEqualTo((float) Format.NO_VALUE);
+    assertThat(variants.get(4).url).isEqualTo("http://example.com/audio-only.m3u8");
+  }
+
+  @Test
+  public void testMasterPlaylistWithBandwdithAverage() throws IOException {
+    HlsMasterPlaylist masterPlaylist =
+        parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_AVG_BANDWIDTH);
+
+    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;
+
+    assertThat(variants.get(0).format.bitrate).isEqualTo(1280000);
+    assertThat(variants.get(1).format.bitrate).isEqualTo(1270000);
+  }
+
+  @Test
+  public void testPlaylistWithInvalidHeader() throws IOException {
+    try {
+      parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_INVALID_HEADER);
+      fail("Expected exception not thrown.");
+    } catch (ParserException e) {
+      // Expected due to invalid header.
+    }
+  }
+
+  @Test
+  public void testPlaylistWithClosedCaption() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_CC);
+    assertThat(playlist.muxedCaptionFormats).hasSize(1);
+    Format closedCaptionFormat = playlist.muxedCaptionFormats.get(0);
+    assertThat(closedCaptionFormat.sampleMimeType).isEqualTo(MimeTypes.APPLICATION_CEA708);
+    assertThat(closedCaptionFormat.accessibilityChannel).isEqualTo(4);
+    assertThat(closedCaptionFormat.language).isEqualTo("es");
+  }
+
+  @Test
+  public void testPlaylistWithoutClosedCaptions() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITHOUT_CC);
+    assertThat(playlist.muxedCaptionFormats).isEmpty();
+  }
+
+  @Test
+  public void testCodecPropagation() throws IOException {
+    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, PLAYLIST_WITH_AUDIO_MEDIA_TAG);
+
+    Format firstAudioFormat = playlist.audios.get(0).format;
+    assertThat(firstAudioFormat.codecs).isEqualTo("mp4a.40.2");
+    assertThat(firstAudioFormat.sampleMimeType).isEqualTo(MimeTypes.AUDIO_AAC);
+
+    Format secondAudioFormat = playlist.audios.get(1).format;
+    assertThat(secondAudioFormat.codecs).isEqualTo("ac-3");
+    assertThat(secondAudioFormat.sampleMimeType).isEqualTo(MimeTypes.AUDIO_AC3);
+  }
+
+  private static HlsMasterPlaylist parseMasterPlaylist(String uri, String playlistString)
+      throws IOException {
+    Uri playlistUri = Uri.parse(uri);
+    ByteArrayInputStream inputStream =
+        new ByteArrayInputStream(playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    return (HlsMasterPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
+  }
+}
diff --git a/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
new file mode 100644
index 0000000000..5ba6f0c7f4
--- /dev/null
+++ b/library/hls/src/test/java/com/google/android/exoplayer2/source/hls/playlist/HlsMediaPlaylistParserTest.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.hls.playlist;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.source.hls.playlist.HlsMediaPlaylist.Segment;
+import com.google.android.exoplayer2.util.Util;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Test for {@link HlsMediaPlaylistParserTest}. */
+@RunWith(RobolectricTestRunner.class)
+public class HlsMediaPlaylistParserTest {
+
+  @Test
+  public void testParseMediaPlaylist() throws Exception {
+    Uri playlistUri = Uri.parse("https://example.com/test.m3u8");
+    String playlistString =
+        "#EXTM3U\n"
+            + "#EXT-X-VERSION:3\n"
+            + "#EXT-X-PLAYLIST-TYPE:VOD\n"
+            + "#EXT-X-START:TIME-OFFSET=-25"
+            + "#EXT-X-TARGETDURATION:8\n"
+            + "#EXT-X-MEDIA-SEQUENCE:2679\n"
+            + "#EXT-X-DISCONTINUITY-SEQUENCE:4\n"
+            + "#EXT-X-ALLOW-CACHE:YES\n"
+            + "\n"
+            + "#EXTINF:7.975,\n"
+            + "#EXT-X-BYTERANGE:51370@0\n"
+            + "https://priv.example.com/fileSequence2679.ts\n"
+            + "\n"
+            + "#EXT-X-KEY:METHOD=AES-128,"
+            + "URI=\"https://priv.example.com/key.php?r=2680\",IV=0x1566B\n"
+            + "#EXTINF:7.975,\n"
+            + "#EXT-X-BYTERANGE:51501@2147483648\n"
+            + "https://priv.example.com/fileSequence2680.ts\n"
+            + "\n"
+            + "#EXT-X-KEY:METHOD=NONE\n"
+            + "#EXTINF:7.941,\n"
+            + "#EXT-X-BYTERANGE:51501\n" // @2147535149
+            + "https://priv.example.com/fileSequence2681.ts\n"
+            + "\n"
+            + "#EXT-X-DISCONTINUITY\n"
+            + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=2682\"\n"
+            + "#EXTINF:7.975,\n"
+            + "#EXT-X-BYTERANGE:51740\n" // @2147586650
+            + "https://priv.example.com/fileSequence2682.ts\n"
+            + "\n"
+            + "#EXTINF:7.975,\n"
+            + "https://priv.example.com/fileSequence2683.ts\n"
+            + "#EXT-X-ENDLIST";
+    InputStream inputStream =
+        new ByteArrayInputStream(playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    HlsPlaylist playlist = new HlsPlaylistParser().parse(playlistUri, inputStream);
+
+    HlsMediaPlaylist mediaPlaylist = (HlsMediaPlaylist) playlist;
+    assertThat(mediaPlaylist.playlistType).isEqualTo(HlsMediaPlaylist.PLAYLIST_TYPE_VOD);
+    assertThat(mediaPlaylist.startOffsetUs).isEqualTo(mediaPlaylist.durationUs - 25000000);
+
+    assertThat(mediaPlaylist.mediaSequence).isEqualTo(2679);
+    assertThat(mediaPlaylist.version).isEqualTo(3);
+    assertThat(mediaPlaylist.hasEndTag).isTrue();
+    List<Segment> segments = mediaPlaylist.segments;
+    assertThat(segments).isNotNull();
+    assertThat(segments).hasSize(5);
+
+    Segment segment = segments.get(0);
+    assertThat(mediaPlaylist.discontinuitySequence + segment.relativeDiscontinuitySequence)
+        .isEqualTo(4);
+    assertThat(segment.durationUs).isEqualTo(7975000);
+    assertThat(segment.fullSegmentEncryptionKeyUri).isNull();
+    assertThat(segment.encryptionIV).isNull();
+    assertThat(segment.byterangeLength).isEqualTo(51370);
+    assertThat(segment.byterangeOffset).isEqualTo(0);
+    assertThat(segment.url).isEqualTo("https://priv.example.com/fileSequence2679.ts");
+
+    segment = segments.get(1);
+    assertThat(segment.relativeDiscontinuitySequence).isEqualTo(0);
+    assertThat(segment.durationUs).isEqualTo(7975000);
+    assertThat(segment.fullSegmentEncryptionKeyUri)
+        .isEqualTo("https://priv.example.com/key.php?r=2680");
+    assertThat(segment.encryptionIV).isEqualTo("0x1566B");
+    assertThat(segment.byterangeLength).isEqualTo(51501);
+    assertThat(segment.byterangeOffset).isEqualTo(2147483648L);
+    assertThat(segment.url).isEqualTo("https://priv.example.com/fileSequence2680.ts");
+
+    segment = segments.get(2);
+    assertThat(segment.relativeDiscontinuitySequence).isEqualTo(0);
+    assertThat(segment.durationUs).isEqualTo(7941000);
+    assertThat(segment.fullSegmentEncryptionKeyUri).isNull();
+    assertThat(segment.encryptionIV).isEqualTo(null);
+    assertThat(segment.byterangeLength).isEqualTo(51501);
+    assertThat(segment.byterangeOffset).isEqualTo(2147535149L);
+    assertThat(segment.url).isEqualTo("https://priv.example.com/fileSequence2681.ts");
+
+    segment = segments.get(3);
+    assertThat(segment.relativeDiscontinuitySequence).isEqualTo(1);
+    assertThat(segment.durationUs).isEqualTo(7975000);
+    assertThat(segment.fullSegmentEncryptionKeyUri)
+        .isEqualTo("https://priv.example.com/key.php?r=2682");
+    // 0xA7A == 2682.
+    assertThat(segment.encryptionIV).isNotNull();
+    assertThat(Util.toUpperInvariant(segment.encryptionIV)).isEqualTo("A7A");
+    assertThat(segment.byterangeLength).isEqualTo(51740);
+    assertThat(segment.byterangeOffset).isEqualTo(2147586650L);
+    assertThat(segment.url).isEqualTo("https://priv.example.com/fileSequence2682.ts");
+
+    segment = segments.get(4);
+    assertThat(segment.relativeDiscontinuitySequence).isEqualTo(1);
+    assertThat(segment.durationUs).isEqualTo(7975000);
+    assertThat(segment.fullSegmentEncryptionKeyUri)
+        .isEqualTo("https://priv.example.com/key.php?r=2682");
+    // 0xA7B == 2683.
+    assertThat(segment.encryptionIV).isNotNull();
+    assertThat(Util.toUpperInvariant(segment.encryptionIV)).isEqualTo("A7B");
+    assertThat(segment.byterangeLength).isEqualTo(C.LENGTH_UNSET);
+    assertThat(segment.byterangeOffset).isEqualTo(0);
+    assertThat(segment.url).isEqualTo("https://priv.example.com/fileSequence2683.ts");
+  }
+
+  @Test
+  public void testGapTag() throws IOException {
+    Uri playlistUri = Uri.parse("https://example.com/test2.m3u8");
+    String playlistString =
+        "#EXTM3U\n"
+            + "#EXT-X-VERSION:3\n"
+            + "#EXT-X-TARGETDURATION:5\n"
+            + "#EXT-X-PLAYLIST-TYPE:VOD\n"
+            + "#EXT-X-MEDIA-SEQUENCE:0\n"
+            + "#EXT-X-PROGRAM-DATE-TIME:2016-09-22T02:00:01+00:00\n"
+            + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://example.com/key?value=something\"\n"
+            + "#EXTINF:5.005,\n"
+            + "02/00/27.ts\n"
+            + "#EXTINF:5.005,\n"
+            + "02/00/32.ts\n"
+            + "#EXT-X-KEY:METHOD=NONE\n"
+            + "#EXTINF:5.005,\n"
+            + "#EXT-X-GAP \n"
+            + "../dummy.ts\n"
+            + "#EXT-X-KEY:METHOD=AES-128,URI=\"https://key-service.bamgrid.com/1.0/key?"
+            + "hex-value=9FB8989D15EEAAF8B21B860D7ED3072A\",IV=0x410C8AC18AA42EFA18B5155484F5FC34\n"
+            + "#EXTINF:5.005,\n"
+            + "02/00/42.ts\n"
+            + "#EXTINF:5.005,\n"
+            + "02/00/47.ts\n";
+    InputStream inputStream =
+        new ByteArrayInputStream(playlistString.getBytes(Charset.forName(C.UTF8_NAME)));
+    HlsMediaPlaylist playlist =
+        (HlsMediaPlaylist) new HlsPlaylistParser().parse(playlistUri, inputStream);
+
+    assertThat(playlist.hasEndTag).isFalse();
+    assertThat(playlist.segments.get(1).hasGapTag).isFalse();
+    assertThat(playlist.segments.get(2).hasGapTag).isTrue();
+    assertThat(playlist.segments.get(3).hasGapTag).isFalse();
+  }
+}
diff --git a/library/hls/src/test/resources/robolectric.properties b/library/hls/src/test/resources/robolectric.properties
new file mode 100644
index 0000000000..2f3210368e
--- /dev/null
+++ b/library/hls/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+manifest=src/test/AndroidManifest.xml
diff --git a/library/smoothstreaming/build.gradle b/library/smoothstreaming/build.gradle
index ee5a8c4e73..6ca5570a93 100644
--- a/library/smoothstreaming/build.gradle
+++ b/library/smoothstreaming/build.gradle
@@ -33,12 +33,9 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile 'com.android.support:support-annotations:' + supportLibraryVersion
-    androidTestCompile project(modulePrefix + 'testutils')
-    androidTestCompile 'com.google.dexmaker:dexmaker:' + dexmakerVersion
-    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:' + dexmakerVersion
-    androidTestCompile 'org.mockito:mockito-core:' + mockitoVersion
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    testImplementation project(modulePrefix + 'testutils-robolectric')
 }
 
 ext {
diff --git a/library/smoothstreaming/src/androidTest/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java b/library/smoothstreaming/src/androidTest/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
deleted file mode 100644
index f172293c22..0000000000
--- a/library/smoothstreaming/src/androidTest/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.source.smoothstreaming.manifest;
-
-import android.test.MoreAsserts;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
-import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
-import com.google.android.exoplayer2.util.MimeTypes;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import junit.framework.TestCase;
-
-/**
- * Unit tests for {@link SsManifest}.
- */
-public class SsManifestTest extends TestCase {
-
-  private static final ProtectionElement DUMMY_PROTECTION_ELEMENT =
-      new ProtectionElement(C.WIDEVINE_UUID, new byte[] {0, 1, 2});
-
-  public void testCopy() throws Exception {
-    Format[][] formats = newFormats(2, 3);
-    SsManifest sourceManifest = newSsManifest(
-        newStreamElement("1",formats[0]),
-        newStreamElement("2", formats[1]));
-
-    List<TrackKey> keys = Arrays.asList(
-        new TrackKey(0, 0),
-        new TrackKey(0, 2),
-        new TrackKey(1, 0));
-    // Keys don't need to be in any particular order
-    Collections.shuffle(keys, new Random(0));
-
-    SsManifest copyManifest = sourceManifest.copy(keys);
-
-    SsManifest expectedManifest = newSsManifest(
-        newStreamElement("1", formats[0][0], formats[0][2]),
-        newStreamElement("2", formats[1][0]));
-    assertManifestEquals(expectedManifest, copyManifest);
-  }
-
-  public void testCopyRemoveStreamElement() throws Exception {
-    Format[][] formats = newFormats(2, 3);
-    SsManifest sourceManifest = newSsManifest(
-        newStreamElement("1", formats[0]),
-        newStreamElement("2", formats[1]));
-
-    List<TrackKey> keys = Arrays.asList(
-        new TrackKey(1, 0));
-    // Keys don't need to be in any particular order
-    Collections.shuffle(keys, new Random(0));
-
-    SsManifest copyManifest = sourceManifest.copy(keys);
-
-    SsManifest expectedManifest = newSsManifest(
-        newStreamElement("2", formats[1][0]));
-    assertManifestEquals(expectedManifest, copyManifest);
-  }
-
-  private static void assertManifestEquals(SsManifest expected, SsManifest actual) {
-    assertEquals(expected.durationUs, actual.durationUs);
-    assertEquals(expected.dvrWindowLengthUs, actual.dvrWindowLengthUs);
-    assertEquals(expected.isLive, actual.isLive);
-    assertEquals(expected.lookAheadCount, actual.lookAheadCount);
-    assertEquals(expected.majorVersion, actual.majorVersion);
-    assertEquals(expected.minorVersion, actual.minorVersion);
-    assertEquals(expected.protectionElement.uuid, actual.protectionElement.uuid);
-    assertEquals(expected.protectionElement, actual.protectionElement);
-    for (int i = 0; i < expected.streamElements.length; i++) {
-      StreamElement expectedStreamElement = expected.streamElements[i];
-      StreamElement actualStreamElement = actual.streamElements[i];
-      assertEquals(expectedStreamElement.chunkCount, actualStreamElement.chunkCount);
-      assertEquals(expectedStreamElement.displayHeight, actualStreamElement.displayHeight);
-      assertEquals(expectedStreamElement.displayWidth, actualStreamElement.displayWidth);
-      assertEquals(expectedStreamElement.language, actualStreamElement.language);
-      assertEquals(expectedStreamElement.maxHeight, actualStreamElement.maxHeight);
-      assertEquals(expectedStreamElement.maxWidth, actualStreamElement.maxWidth);
-      assertEquals(expectedStreamElement.name, actualStreamElement.name);
-      assertEquals(expectedStreamElement.subType, actualStreamElement.subType);
-      assertEquals(expectedStreamElement.timescale, actualStreamElement.timescale);
-      assertEquals(expectedStreamElement.type, actualStreamElement.type);
-      MoreAsserts.assertEquals(expectedStreamElement.formats, actualStreamElement.formats);
-    }
-  }
-
-  private static Format[][] newFormats(int streamElementCount, int trackCounts) {
-    Format[][] formats = new Format[streamElementCount][];
-    for (int i = 0; i < streamElementCount; i++) {
-      formats[i] = new Format[trackCounts];
-      for (int j = 0; j < trackCounts; j++) {
-        formats[i][j] = newFormat(i + "." + j);
-      }
-    }
-    return formats;
-  }
-
-  private static SsManifest newSsManifest(StreamElement... streamElements) {
-    return new SsManifest(1, 2, 1000, 5000, 0, 0, false, DUMMY_PROTECTION_ELEMENT, streamElements);
-  }
-
-  private static StreamElement newStreamElement(String name, Format... formats) {
-    return new StreamElement("baseUri", "chunkTemplate", C.TRACK_TYPE_VIDEO, "subType",
-        1000, name, 1024, 768, 1024, 768, null, formats, Collections.<Long>emptyList(), 0);
-  }
-
-  private static Format newFormat(String id) {
-    return Format.createContainerFormat(id, MimeTypes.VIDEO_MP4, MimeTypes.VIDEO_H264, null,
-        Format.NO_VALUE, 0, null);
-  }
-
-}
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
index 5a6493b702..d0e5ed29af 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/DefaultSsChunkSource.java
@@ -18,6 +18,7 @@
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
 import com.google.android.exoplayer2.extractor.mp4.Track;
 import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
@@ -34,6 +35,7 @@
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.List;
 
@@ -62,7 +64,7 @@ public SsChunkSource createChunkSource(LoaderErrorThrower manifestLoaderErrorThr
   }
 
   private final LoaderErrorThrower manifestLoaderErrorThrower;
-  private final int elementIndex;
+  private final int streamElementIndex;
   private final TrackSelection trackSelection;
   private final ChunkExtractorWrapper[] extractorWrappers;
   private final DataSource dataSource;
@@ -75,22 +77,25 @@ public SsChunkSource createChunkSource(LoaderErrorThrower manifestLoaderErrorThr
   /**
    * @param manifestLoaderErrorThrower Throws errors affecting loading of manifests.
    * @param manifest The initial manifest.
-   * @param elementIndex The index of the stream element in the manifest.
+   * @param streamElementIndex The index of the stream element in the manifest.
    * @param trackSelection The track selection.
    * @param dataSource A {@link DataSource} suitable for loading the media data.
    * @param trackEncryptionBoxes Track encryption boxes for the stream.
    */
-  public DefaultSsChunkSource(LoaderErrorThrower manifestLoaderErrorThrower, SsManifest manifest,
-      int elementIndex, TrackSelection trackSelection, DataSource dataSource,
+  public DefaultSsChunkSource(
+      LoaderErrorThrower manifestLoaderErrorThrower,
+      SsManifest manifest,
+      int streamElementIndex,
+      TrackSelection trackSelection,
+      DataSource dataSource,
       TrackEncryptionBox[] trackEncryptionBoxes) {
     this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
     this.manifest = manifest;
-    this.elementIndex = elementIndex;
+    this.streamElementIndex = streamElementIndex;
     this.trackSelection = trackSelection;
     this.dataSource = dataSource;
 
-    StreamElement streamElement = manifest.streamElements[elementIndex];
-
+    StreamElement streamElement = manifest.streamElements[streamElementIndex];
     extractorWrappers = new ChunkExtractorWrapper[trackSelection.length()];
     for (int i = 0; i < extractorWrappers.length; i++) {
       int manifestTrackIndex = trackSelection.getIndexInTrackGroup(i);
@@ -106,11 +111,23 @@ public DefaultSsChunkSource(LoaderErrorThrower manifestLoaderErrorThrower, SsMan
     }
   }
 
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    StreamElement streamElement = manifest.streamElements[streamElementIndex];
+    int chunkIndex = streamElement.getChunkIndex(positionUs);
+    long firstSyncUs = streamElement.getStartTimeUs(chunkIndex);
+    long secondSyncUs =
+        firstSyncUs < positionUs && chunkIndex < streamElement.chunkCount - 1
+            ? streamElement.getStartTimeUs(chunkIndex + 1)
+            : firstSyncUs;
+    return Util.resolveSeekPositionUs(positionUs, seekParameters, firstSyncUs, secondSyncUs);
+  }
+
   @Override
   public void updateManifest(SsManifest newManifest) {
-    StreamElement currentElement = manifest.streamElements[elementIndex];
+    StreamElement currentElement = manifest.streamElements[streamElementIndex];
     int currentElementChunkCount = currentElement.chunkCount;
-    StreamElement newElement = newManifest.streamElements[elementIndex];
+    StreamElement newElement = newManifest.streamElements[streamElementIndex];
     if (currentElementChunkCount == 0 || newElement.chunkCount == 0) {
       // There's no overlap between the old and new elements because at least one is empty.
       currentManifestChunkOffset += currentElementChunkCount;
@@ -155,7 +172,7 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, lon
       return;
     }
 
-    StreamElement streamElement = manifest.streamElements[elementIndex];
+    StreamElement streamElement = manifest.streamElements[streamElementIndex];
     if (streamElement.chunkCount == 0) {
       // There aren't any chunks for us to load.
       out.endOfStream = !manifest.isLive;
@@ -166,7 +183,7 @@ public final void getNextChunk(MediaChunk previous, long playbackPositionUs, lon
     if (previous == null) {
       chunkIndex = streamElement.getChunkIndex(loadPositionUs);
     } else {
-      chunkIndex = previous.getNextChunkIndex() - currentManifestChunkOffset;
+      chunkIndex = (int) (previous.getNextChunkIndex() - currentManifestChunkOffset);
       if (chunkIndex < 0) {
         // This is before the first chunk in the current manifest.
         fatalError = new BehindLiveWindowException();
@@ -229,7 +246,7 @@ private long resolveTimeToLiveEdgeUs(long playbackPositionUs) {
       return C.TIME_UNSET;
     }
 
-    StreamElement currentElement = manifest.streamElements[elementIndex];
+    StreamElement currentElement = manifest.streamElements[streamElementIndex];
     int lastChunkIndex = currentElement.chunkCount - 1;
     long lastChunkEndTimeUs = currentElement.getStartTimeUs(lastChunkIndex)
         + currentElement.getChunkDurationUs(lastChunkIndex);
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
index e8815ff424..48491cd0bd 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsChunkSource.java
@@ -26,14 +26,31 @@
  */
 public interface SsChunkSource extends ChunkSource {
 
+  /** Factory for {@link SsChunkSource}s. */
   interface Factory {
 
-    SsChunkSource createChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
-        SsManifest manifest, int elementIndex, TrackSelection trackSelection,
+    /**
+     * Creates a new {@link SsChunkSource}.
+     *
+     * @param manifestLoaderErrorThrower Throws errors affecting loading of manifests.
+     * @param manifest The initial manifest.
+     * @param streamElementIndex The index of the corresponding stream element in the manifest.
+     * @param trackSelection The track selection.
+     * @param trackEncryptionBoxes Track encryption boxes for the stream.
+     * @return The created {@link SsChunkSource}.
+     */
+    SsChunkSource createChunkSource(
+        LoaderErrorThrower manifestLoaderErrorThrower,
+        SsManifest manifest,
+        int streamElementIndex,
+        TrackSelection trackSelection,
         TrackEncryptionBox[] trackEncryptionBoxes);
-
   }
 
+  /**
+   * Updates the manifest.
+   *
+   * @param newManifest The new manifest.
+   */
   void updateManifest(SsManifest newManifest);
-
 }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
index 1cc2a6833d..a600741362 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaPeriod.java
@@ -17,10 +17,11 @@
 
 import android.util.Base64;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.extractor.mp4.TrackEncryptionBox;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
-import com.google.android.exoplayer2.source.CompositeSequenceableLoader;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.source.TrackGroup;
@@ -49,13 +50,15 @@
   private final Allocator allocator;
   private final TrackGroupArray trackGroups;
   private final TrackEncryptionBox[] trackEncryptionBoxes;
+  private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
 
   private Callback callback;
   private SsManifest manifest;
   private ChunkSampleStream<SsChunkSource>[] sampleStreams;
-  private CompositeSequenceableLoader sequenceableLoader;
+  private SequenceableLoader compositeSequenceableLoader;
 
   public SsMediaPeriod(SsManifest manifest, SsChunkSource.Factory chunkSourceFactory,
+      CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
       int minLoadableRetryCount, EventDispatcher eventDispatcher,
       LoaderErrorThrower manifestLoaderErrorThrower, Allocator allocator) {
     this.chunkSourceFactory = chunkSourceFactory;
@@ -63,6 +66,7 @@ public SsMediaPeriod(SsManifest manifest, SsChunkSource.Factory chunkSourceFacto
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.eventDispatcher = eventDispatcher;
     this.allocator = allocator;
+    this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
 
     trackGroups = buildTrackGroups(manifest);
     ProtectionElement protectionElement = manifest.protectionElement;
@@ -76,7 +80,8 @@ public SsMediaPeriod(SsManifest manifest, SsChunkSource.Factory chunkSourceFacto
     }
     this.manifest = manifest;
     sampleStreams = newSampleStreamArray(0);
-    sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
+    compositeSequenceableLoader =
+        compositeSequenceableLoaderFactory.createCompositeSequenceableLoader(sampleStreams);
   }
 
   public void updateManifest(SsManifest manifest) {
@@ -133,23 +138,31 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
     }
     sampleStreams = newSampleStreamArray(sampleStreamsList.size());
     sampleStreamsList.toArray(sampleStreams);
-    sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
+    compositeSequenceableLoader =
+        compositeSequenceableLoaderFactory.createCompositeSequenceableLoader(sampleStreams);
     return positionUs;
   }
 
   @Override
-  public void discardBuffer(long positionUs) {
-    // Do nothing.
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
+    for (ChunkSampleStream<SsChunkSource> sampleStream : sampleStreams) {
+      sampleStream.discardBuffer(positionUs, toKeyframe);
+    }
+  }
+
+  @Override
+  public void reevaluateBuffer(long positionUs) {
+    compositeSequenceableLoader.reevaluateBuffer(positionUs);
   }
 
   @Override
   public boolean continueLoading(long positionUs) {
-    return sequenceableLoader.continueLoading(positionUs);
+    return compositeSequenceableLoader.continueLoading(positionUs);
   }
 
   @Override
   public long getNextLoadPositionUs() {
-    return sequenceableLoader.getNextLoadPositionUs();
+    return compositeSequenceableLoader.getNextLoadPositionUs();
   }
 
   @Override
@@ -159,7 +172,7 @@ public long readDiscontinuity() {
 
   @Override
   public long getBufferedPositionUs() {
-    return sequenceableLoader.getBufferedPositionUs();
+    return compositeSequenceableLoader.getBufferedPositionUs();
   }
 
   @Override
@@ -170,6 +183,16 @@ public long seekToUs(long positionUs) {
     return positionUs;
   }
 
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    for (ChunkSampleStream<SsChunkSource> sampleStream : sampleStreams) {
+      if (sampleStream.primaryTrackType == C.TRACK_TYPE_VIDEO) {
+        return sampleStream.getAdjustedSeekPositionUs(positionUs, seekParameters);
+      }
+    }
+    return positionUs;
+  }
+
   // SequenceableLoader.Callback implementation
 
   @Override
@@ -184,8 +207,16 @@ public void onContinueLoadingRequested(ChunkSampleStream<SsChunkSource> sampleSt
     int streamElementIndex = trackGroups.indexOf(selection.getTrackGroup());
     SsChunkSource chunkSource = chunkSourceFactory.createChunkSource(manifestLoaderErrorThrower,
         manifest, streamElementIndex, selection, trackEncryptionBoxes);
-    return new ChunkSampleStream<>(manifest.streamElements[streamElementIndex].type, null,
-        chunkSource, this, allocator, positionUs, minLoadableRetryCount, eventDispatcher);
+    return new ChunkSampleStream<>(
+        manifest.streamElements[streamElementIndex].type,
+        null,
+        null,
+        chunkSource,
+        this,
+        allocator,
+        positionUs,
+        minLoadableRetryCount,
+        eventDispatcher);
   }
 
   private static TrackGroupArray buildTrackGroups(SsManifest manifest) {
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
index 548f787741..da9024a5b5 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/SsMediaSource.java
@@ -18,26 +18,31 @@
 import android.net.Uri;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
 import com.google.android.exoplayer2.ParserException;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.CompositeSequenceableLoaderFactory;
+import com.google.android.exoplayer2.source.DefaultCompositeSequenceableLoaderFactory;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSourceEventListener;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
+import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.source.SinglePeriodTimeline;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsUtil;
 import com.google.android.exoplayer2.upstream.Allocator;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.Loader;
 import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
 import com.google.android.exoplayer2.upstream.ParsingLoadable;
 import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.ArrayList;
 
@@ -51,6 +56,176 @@
     ExoPlayerLibraryInfo.registerModule("goog.exo.smoothstreaming");
   }
 
+  /** Factory for {@link SsMediaSource}. */
+  public static final class Factory implements AdsMediaSource.MediaSourceFactory {
+
+    private final SsChunkSource.Factory chunkSourceFactory;
+    private final @Nullable DataSource.Factory manifestDataSourceFactory;
+
+    private @Nullable ParsingLoadable.Parser<? extends SsManifest> manifestParser;
+    private CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
+    private int minLoadableRetryCount;
+    private long livePresentationDelayMs;
+    private boolean isCreateCalled;
+
+    /**
+     * Creates a new factory for {@link SsMediaSource}s.
+     *
+     * @param chunkSourceFactory A factory for {@link SsChunkSource} instances.
+     * @param manifestDataSourceFactory A factory for {@link DataSource} instances that will be used
+     *     to load (and refresh) the manifest. May be {@code null} if the factory will only ever be
+     *     used to create create media sources with sideloaded manifests via {@link
+     *     #createMediaSource(SsManifest, Handler, MediaSourceEventListener)}.
+     */
+    public Factory(
+        SsChunkSource.Factory chunkSourceFactory,
+        @Nullable DataSource.Factory manifestDataSourceFactory) {
+      this.chunkSourceFactory = Assertions.checkNotNull(chunkSourceFactory);
+      this.manifestDataSourceFactory = manifestDataSourceFactory;
+      minLoadableRetryCount = DEFAULT_MIN_LOADABLE_RETRY_COUNT;
+      livePresentationDelayMs = DEFAULT_LIVE_PRESENTATION_DELAY_MS;
+      compositeSequenceableLoaderFactory = new DefaultCompositeSequenceableLoaderFactory();
+    }
+
+    /**
+     * Sets the minimum number of times to retry if a loading error occurs. The default value is
+     * {@link #DEFAULT_MIN_LOADABLE_RETRY_COUNT}.
+     *
+     * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setMinLoadableRetryCount(int minLoadableRetryCount) {
+      Assertions.checkState(!isCreateCalled);
+      this.minLoadableRetryCount = minLoadableRetryCount;
+      return this;
+    }
+
+    /**
+     * Sets the duration in milliseconds by which the default start position should precede the end
+     * of the live window for live playbacks. The default value is {@link
+     * #DEFAULT_LIVE_PRESENTATION_DELAY_MS}.
+     *
+     * @param livePresentationDelayMs For live playbacks, the duration in milliseconds by which the
+     *     default start position should precede the end of the live window.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setLivePresentationDelayMs(long livePresentationDelayMs) {
+      Assertions.checkState(!isCreateCalled);
+      this.livePresentationDelayMs = livePresentationDelayMs;
+      return this;
+    }
+
+    /**
+     * Sets the manifest parser to parse loaded manifest data when loading a manifest URI.
+     *
+     * @param manifestParser A parser for loaded manifest data.
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setManifestParser(ParsingLoadable.Parser<? extends SsManifest> manifestParser) {
+      Assertions.checkState(!isCreateCalled);
+      this.manifestParser = Assertions.checkNotNull(manifestParser);
+      return this;
+    }
+
+    /**
+     * Sets the factory to create composite {@link SequenceableLoader}s for when this media source
+     * loads data from multiple streams (video, audio etc.). The default is an instance of {@link
+     * DefaultCompositeSequenceableLoaderFactory}.
+     *
+     * @param compositeSequenceableLoaderFactory A factory to create composite {@link
+     *     SequenceableLoader}s for when this media source loads data from multiple streams (video,
+     *     audio etc.).
+     * @return This factory, for convenience.
+     * @throws IllegalStateException If one of the {@code create} methods has already been called.
+     */
+    public Factory setCompositeSequenceableLoaderFactory(
+        CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory) {
+      Assertions.checkState(!isCreateCalled);
+      this.compositeSequenceableLoaderFactory =
+          Assertions.checkNotNull(compositeSequenceableLoaderFactory);
+      return this;
+    }
+
+    /**
+     * Returns a new {@link SsMediaSource} using the current parameters and the specified sideloaded
+     * manifest.
+     *
+     * @param manifest The manifest. {@link SsManifest#isLive} must be false.
+     * @param eventHandler A handler for events.
+     * @param eventListener A listener of events.
+     * @return The new {@link SsMediaSource}.
+     * @throws IllegalArgumentException If {@link SsManifest#isLive} is true.
+     */
+    public SsMediaSource createMediaSource(
+        SsManifest manifest,
+        @Nullable Handler eventHandler,
+        @Nullable MediaSourceEventListener eventListener) {
+      Assertions.checkArgument(!manifest.isLive);
+      isCreateCalled = true;
+      return new SsMediaSource(
+          manifest,
+          null,
+          null,
+          null,
+          chunkSourceFactory,
+          compositeSequenceableLoaderFactory,
+          minLoadableRetryCount,
+          livePresentationDelayMs,
+          eventHandler,
+          eventListener);
+    }
+
+    /**
+     * Returns a new {@link SsMediaSource} using the current parameters. Media source events will
+     * not be delivered.
+     *
+     * @param manifestUri The manifest {@link Uri}.
+     * @return The new {@link SsMediaSource}.
+     */
+    public SsMediaSource createMediaSource(Uri manifestUri) {
+      return createMediaSource(manifestUri, null, null);
+    }
+
+    /**
+     * Returns a new {@link SsMediaSource} using the current parameters.
+     *
+     * @param manifestUri The manifest {@link Uri}.
+     * @param eventHandler A handler for events.
+     * @param eventListener A listener of events.
+     * @return The new {@link SsMediaSource}.
+     */
+    @Override
+    public SsMediaSource createMediaSource(
+        Uri manifestUri,
+        @Nullable Handler eventHandler,
+        @Nullable MediaSourceEventListener eventListener) {
+      isCreateCalled = true;
+      if (manifestParser == null) {
+        manifestParser = new SsManifestParser();
+      }
+      return new SsMediaSource(
+          null,
+          Assertions.checkNotNull(manifestUri),
+          manifestDataSourceFactory,
+          manifestParser,
+          chunkSourceFactory,
+          compositeSequenceableLoaderFactory,
+          minLoadableRetryCount,
+          livePresentationDelayMs,
+          eventHandler,
+          eventListener);
+    }
+
+    @Override
+    public int[] getSupportedTypes() {
+      return new int[] {C.TYPE_SS};
+    }
+
+  }
+
   /**
    * The default minimum number of times to retry loading data prior to failing.
    */
@@ -70,9 +245,11 @@
    */
   private static final long MIN_LIVE_DEFAULT_START_POSITION_US = 5000000;
 
+  private final boolean sideloadedManifest;
   private final Uri manifestUri;
   private final DataSource.Factory manifestDataSourceFactory;
   private final SsChunkSource.Factory chunkSourceFactory;
+  private final CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory;
   private final int minLoadableRetryCount;
   private final long livePresentationDelayMs;
   private final EventDispatcher eventDispatcher;
@@ -96,9 +273,14 @@
    * @param chunkSourceFactory A factory for {@link SsChunkSource} instances.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public SsMediaSource(SsManifest manifest, SsChunkSource.Factory chunkSourceFactory,
-      Handler eventHandler, AdaptiveMediaSourceEventListener eventListener) {
+  @Deprecated
+  public SsMediaSource(
+      SsManifest manifest,
+      SsChunkSource.Factory chunkSourceFactory,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(manifest, chunkSourceFactory, DEFAULT_MIN_LOADABLE_RETRY_COUNT,
         eventHandler, eventListener);
   }
@@ -111,11 +293,17 @@ public SsMediaSource(SsManifest manifest, SsChunkSource.Factory chunkSourceFacto
    * @param minLoadableRetryCount The minimum number of times to retry if a loading error occurs.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public SsMediaSource(SsManifest manifest, SsChunkSource.Factory chunkSourceFactory,
-      int minLoadableRetryCount, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
-    this(manifest, null, null, null, chunkSourceFactory, minLoadableRetryCount,
+  @Deprecated
+  public SsMediaSource(
+      SsManifest manifest,
+      SsChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
+    this(manifest, null, null, null, chunkSourceFactory,
+        new DefaultCompositeSequenceableLoaderFactory(), minLoadableRetryCount,
         DEFAULT_LIVE_PRESENTATION_DELAY_MS, eventHandler, eventListener);
   }
 
@@ -129,10 +317,15 @@ public SsMediaSource(SsManifest manifest, SsChunkSource.Factory chunkSourceFacto
    * @param chunkSourceFactory A factory for {@link SsChunkSource} instances.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public SsMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
-      SsChunkSource.Factory chunkSourceFactory, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+  @Deprecated
+  public SsMediaSource(
+      Uri manifestUri,
+      DataSource.Factory manifestDataSourceFactory,
+      SsChunkSource.Factory chunkSourceFactory,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(manifestUri, manifestDataSourceFactory, chunkSourceFactory,
         DEFAULT_MIN_LOADABLE_RETRY_COUNT, DEFAULT_LIVE_PRESENTATION_DELAY_MS, eventHandler,
         eventListener);
@@ -151,11 +344,17 @@ public SsMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFacto
    *     default start position should precede the end of the live window.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public SsMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
-      SsChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
-      long livePresentationDelayMs, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+  @Deprecated
+  public SsMediaSource(
+      Uri manifestUri,
+      DataSource.Factory manifestDataSourceFactory,
+      SsChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount,
+      long livePresentationDelayMs,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(manifestUri, manifestDataSourceFactory, new SsManifestParser(), chunkSourceFactory,
         minLoadableRetryCount, livePresentationDelayMs, eventHandler, eventListener);
   }
@@ -174,33 +373,45 @@ public SsMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFacto
    *     default start position should precede the end of the live window.
    * @param eventHandler A handler for events. May be null if delivery of events is not required.
    * @param eventListener A listener of events. May be null if delivery of events is not required.
+   * @deprecated Use {@link Factory} instead.
    */
-  public SsMediaSource(Uri manifestUri, DataSource.Factory manifestDataSourceFactory,
+  @Deprecated
+  public SsMediaSource(
+      Uri manifestUri,
+      DataSource.Factory manifestDataSourceFactory,
       ParsingLoadable.Parser<? extends SsManifest> manifestParser,
-      SsChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
-      long livePresentationDelayMs, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+      SsChunkSource.Factory chunkSourceFactory,
+      int minLoadableRetryCount,
+      long livePresentationDelayMs,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     this(null, manifestUri, manifestDataSourceFactory, manifestParser, chunkSourceFactory,
-        minLoadableRetryCount, livePresentationDelayMs, eventHandler, eventListener);
+        new DefaultCompositeSequenceableLoaderFactory(), minLoadableRetryCount,
+        livePresentationDelayMs, eventHandler, eventListener);
   }
 
-  private SsMediaSource(SsManifest manifest, Uri manifestUri,
+  private SsMediaSource(
+      SsManifest manifest,
+      Uri manifestUri,
       DataSource.Factory manifestDataSourceFactory,
       ParsingLoadable.Parser<? extends SsManifest> manifestParser,
-      SsChunkSource.Factory chunkSourceFactory, int minLoadableRetryCount,
-      long livePresentationDelayMs, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener) {
+      SsChunkSource.Factory chunkSourceFactory,
+      CompositeSequenceableLoaderFactory compositeSequenceableLoaderFactory,
+      int minLoadableRetryCount,
+      long livePresentationDelayMs,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener) {
     Assertions.checkState(manifest == null || !manifest.isLive);
     this.manifest = manifest;
-    this.manifestUri = manifestUri == null ? null
-        : Util.toLowerInvariant(manifestUri.getLastPathSegment()).matches("manifest(\\(.+\\))?")
-            ? manifestUri : Uri.withAppendedPath(manifestUri, "Manifest");
+    this.manifestUri = manifestUri == null ? null : SsUtil.fixManifestUri(manifestUri);
     this.manifestDataSourceFactory = manifestDataSourceFactory;
     this.manifestParser = manifestParser;
     this.chunkSourceFactory = chunkSourceFactory;
+    this.compositeSequenceableLoaderFactory = compositeSequenceableLoaderFactory;
     this.minLoadableRetryCount = minLoadableRetryCount;
     this.livePresentationDelayMs = livePresentationDelayMs;
     this.eventDispatcher = new EventDispatcher(eventHandler, eventListener);
+    sideloadedManifest = manifest != null;
     mediaPeriods = new ArrayList<>();
   }
 
@@ -209,7 +420,7 @@ private SsMediaSource(SsManifest manifest, Uri manifestUri,
   @Override
   public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
     sourceListener = listener;
-    if (manifest != null) {
+    if (sideloadedManifest) {
       manifestLoaderErrorThrower = new LoaderErrorThrower.Dummy();
       processManifest();
     } else {
@@ -229,8 +440,9 @@ public void maybeThrowSourceInfoRefreshError() throws IOException {
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
     Assertions.checkArgument(id.periodIndex == 0);
-    SsMediaPeriod period = new SsMediaPeriod(manifest, chunkSourceFactory, minLoadableRetryCount,
-        eventDispatcher, manifestLoaderErrorThrower, allocator);
+    SsMediaPeriod period = new SsMediaPeriod(manifest, chunkSourceFactory,
+        compositeSequenceableLoaderFactory, minLoadableRetryCount, eventDispatcher,
+        manifestLoaderErrorThrower, allocator);
     mediaPeriods.add(period);
     return period;
   }
@@ -244,7 +456,7 @@ public void releasePeriod(MediaPeriod period) {
   @Override
   public void releaseSource() {
     sourceListener = null;
-    manifest = null;
+    manifest = sideloadedManifest ? manifest : null;
     manifestDataSource = null;
     manifestLoadStartTimestamp = 0;
     if (manifestLoader != null) {
@@ -273,8 +485,12 @@ public void onLoadCompleted(ParsingLoadable<SsManifest> loadable, long elapsedRe
   @Override
   public void onLoadCanceled(ParsingLoadable<SsManifest> loadable, long elapsedRealtimeMs,
       long loadDurationMs, boolean released) {
-    eventDispatcher.loadCompleted(loadable.dataSpec, loadable.type, elapsedRealtimeMs,
-        loadDurationMs, loadable.bytesLoaded());
+    eventDispatcher.loadCanceled(
+        loadable.dataSpec,
+        loadable.type,
+        elapsedRealtimeMs,
+        loadDurationMs,
+        loadable.bytesLoaded());
   }
 
   @Override
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/FilteringSsManifestParser.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/FilteringSsManifestParser.java
new file mode 100644
index 0000000000..eed040df97
--- /dev/null
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/FilteringSsManifestParser.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming.manifest;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.upstream.ParsingLoadable.Parser;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+
+/**
+ * A parser of SmoothStreaming manifest which includes only the tracks identified by the given keys.
+ */
+public final class FilteringSsManifestParser implements Parser<SsManifest> {
+
+  private final SsManifestParser ssManifestParser;
+  private final List<TrackKey> filter;
+
+  /** @param filter The track keys that should be retained in the parsed manifests. */
+  public FilteringSsManifestParser(List<TrackKey> filter) {
+    this.ssManifestParser = new SsManifestParser();
+    this.filter = filter;
+  }
+
+  @Override
+  public SsManifest parse(Uri uri, InputStream inputStream) throws IOException {
+    return ssManifestParser.parse(uri, inputStream).copy(filter);
+  }
+}
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
index fbc3726a0e..0df180a5a6 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifest.java
@@ -203,8 +203,20 @@ public StreamElement(String baseUri, String chunkTemplate, int type, String subT
         long timescale, String name, int maxWidth, int maxHeight, int displayWidth,
         int displayHeight, String language, Format[] formats, List<Long> chunkStartTimes,
         long lastChunkDuration) {
-      this (baseUri, chunkTemplate, type, subType, timescale, name, maxWidth, maxHeight,
-          displayWidth, displayHeight, language, formats, chunkStartTimes,
+      this(
+          baseUri,
+          chunkTemplate,
+          type,
+          subType,
+          timescale,
+          name,
+          maxWidth,
+          maxHeight,
+          displayWidth,
+          displayHeight,
+          language,
+          formats,
+          chunkStartTimes,
           Util.scaleLargeTimestamps(chunkStartTimes, C.MICROS_PER_SECOND, timescale),
           Util.scaleLargeTimestamp(lastChunkDuration, C.MICROS_PER_SECOND, timescale));
     }
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsUtil.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsUtil.java
new file mode 100644
index 0000000000..4adf6acff7
--- /dev/null
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsUtil.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming.manifest;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.util.Util;
+
+/** SmoothStreaming related utility methods. */
+public final class SsUtil {
+
+  /** Returns a fixed SmoothStreaming client manifest {@link Uri}. */
+  public static Uri fixManifestUri(Uri manifestUri) {
+    if (Util.toLowerInvariant(manifestUri.getLastPathSegment()).matches("manifest(\\(.+\\))?")) {
+      return manifestUri;
+    }
+    return Uri.withAppendedPath(manifestUri, "Manifest");
+  }
+
+  private SsUtil() {}
+}
diff --git a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
index 5e9ae9a164..7988523bed 100644
--- a/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
+++ b/library/smoothstreaming/src/main/java/com/google/android/exoplayer2/source/smoothstreaming/offline/SsDownloader.java
@@ -22,6 +22,7 @@
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifestParser;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsUtil;
 import com.google.android.exoplayer2.source.smoothstreaming.manifest.TrackKey;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -33,13 +34,12 @@
 /**
  * Helper class to download SmoothStreaming streams.
  *
- * <p>Except {@link #getTotalSegments()}, {@link #getDownloadedSegments()} and
- * {@link #getDownloadedBytes()}, this class isn't thread safe.
+ * <p>Except {@link #getTotalSegments()}, {@link #getDownloadedSegments()} and {@link
+ * #getDownloadedBytes()}, this class isn't thread safe.
  *
  * <p>Example usage:
  *
- * <pre>
- * {@code
+ * <pre>{@code
  * SimpleCache cache = new SimpleCache(downloadFolder, new NoOpCacheEvictor());
  * DefaultHttpDataSourceFactory factory = new DefaultHttpDataSourceFactory("ExoPlayer", null);
  * DownloaderConstructorHelper constructorHelper =
@@ -48,7 +48,7 @@
  * // Select the first track of the first stream element
  * ssDownloader.selectRepresentations(new TrackKey[] {new TrackKey(0, 0)});
  * ssDownloader.download(new ProgressListener() {
- *   @Override
+ *   {@literal @}Override
  *   public void onDownloadProgress(Downloader downloader, float downloadPercentage,
  *       long downloadedBytes) {
  *     // Invoked periodically during the download.
@@ -56,8 +56,8 @@
  * });
  * // Access downloaded data using CacheDataSource
  * CacheDataSource cacheDataSource =
- *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);}
- * </pre>
+ *     new CacheDataSource(cache, factory.createDataSource(), CacheDataSource.FLAG_BLOCK_ON_CACHE);
+ * }</pre>
  */
 public final class SsDownloader extends SegmentDownloader<SsManifest, TrackKey> {
 
@@ -65,31 +65,28 @@
    * @see SegmentDownloader#SegmentDownloader(Uri, DownloaderConstructorHelper)
    */
   public SsDownloader(Uri manifestUri, DownloaderConstructorHelper constructorHelper)  {
-    super(manifestUri, constructorHelper);
+    super(SsUtil.fixManifestUri(manifestUri), constructorHelper);
   }
 
   @Override
-  public SsManifest getManifest(DataSource dataSource, Uri uri) throws IOException {
-    DataSpec dataSpec = new DataSpec(uri,
-        DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH | DataSpec.FLAG_ALLOW_GZIP);
-    ParsingLoadable<SsManifest> loadable = new ParsingLoadable<>(dataSource, dataSpec,
-        C.DATA_TYPE_MANIFEST, new SsManifestParser());
-    loadable.load();
-    return loadable.getResult();
-  }
-
-  @Override
-  protected List<Segment> getAllSegments(DataSource dataSource, SsManifest manifest,
-      boolean allowIndexLoadErrors) throws InterruptedException, IOException {
-    ArrayList<Segment> segments = new ArrayList<>();
+  public TrackKey[] getAllRepresentationKeys() throws IOException {
+    ArrayList<TrackKey> keys = new ArrayList<>();
+    SsManifest manifest = getManifest();
     for (int i = 0; i < manifest.streamElements.length; i++) {
       StreamElement streamElement = manifest.streamElements[i];
       for (int j = 0; j < streamElement.formats.length; j++) {
-        segments.addAll(getSegments(dataSource, manifest, new TrackKey[] {new TrackKey(i, j)},
-            allowIndexLoadErrors));
+        keys.add(new TrackKey(i, j));
       }
     }
-    return segments;
+    return keys.toArray(new TrackKey[keys.size()]);
+  }
+
+  @Override
+  protected SsManifest getManifest(DataSource dataSource, Uri uri) throws IOException {
+    ParsingLoadable<SsManifest> loadable =
+        new ParsingLoadable<>(dataSource, uri, C.DATA_TYPE_MANIFEST, new SsManifestParser());
+    loadable.load();
+    return loadable.getResult();
   }
 
   @Override
diff --git a/library/smoothstreaming/src/androidTest/AndroidManifest.xml b/library/smoothstreaming/src/test/AndroidManifest.xml
similarity index 71%
rename from library/smoothstreaming/src/androidTest/AndroidManifest.xml
rename to library/smoothstreaming/src/test/AndroidManifest.xml
index 1d2317677b..1a8f8ee9c4 100644
--- a/library/smoothstreaming/src/androidTest/AndroidManifest.xml
+++ b/library/smoothstreaming/src/test/AndroidManifest.xml
@@ -20,14 +20,4 @@
 
   <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
 
-  <application android:debuggable="true"
-      android:allowBackup="false"
-      tools:ignore="MissingApplicationIcon,HardcodedDebugMode">
-    <uses-library android:name="android.test.runner"/>
-  </application>
-
-  <instrumentation
-      android:targetPackage="com.google.android.exoplayer2.source.smoothstreaming.test"
-      android:name="android.test.InstrumentationTestRunner"/>
-
 </manifest>
diff --git a/library/smoothstreaming/src/androidTest/assets/sample_ismc_1 b/library/smoothstreaming/src/test/assets/sample_ismc_1
similarity index 100%
rename from library/smoothstreaming/src/androidTest/assets/sample_ismc_1
rename to library/smoothstreaming/src/test/assets/sample_ismc_1
diff --git a/library/smoothstreaming/src/androidTest/assets/sample_ismc_2 b/library/smoothstreaming/src/test/assets/sample_ismc_2
similarity index 100%
rename from library/smoothstreaming/src/androidTest/assets/sample_ismc_2
rename to library/smoothstreaming/src/test/assets/sample_ismc_2
diff --git a/library/smoothstreaming/src/androidTest/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java
similarity index 60%
rename from library/smoothstreaming/src/androidTest/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java
rename to library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java
index 4663f014ff..2ce9fec970 100644
--- a/library/smoothstreaming/src/androidTest/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestParserTest.java
@@ -16,27 +16,29 @@
 package com.google.android.exoplayer2.source.smoothstreaming.manifest;
 
 import android.net.Uri;
-import android.test.InstrumentationTestCase;
 import com.google.android.exoplayer2.testutil.TestUtil;
 import java.io.IOException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
 
-/**
- * Unit tests for {@link SsManifestParser}.
- */
-public final class SsManifestParserTest extends InstrumentationTestCase {
+/** Unit tests for {@link SsManifestParser}. */
+@RunWith(RobolectricTestRunner.class)
+public final class SsManifestParserTest {
 
   private static final String SAMPLE_ISMC_1 = "sample_ismc_1";
   private static final String SAMPLE_ISMC_2 = "sample_ismc_2";
 
-  /**
-   * Simple test to ensure the sample manifests parse without any exceptions being thrown.
-   */
+  /** Simple test to ensure the sample manifests parse without any exceptions being thrown. */
+  @Test
   public void testParseSmoothStreamingManifest() throws IOException {
     SsManifestParser parser = new SsManifestParser();
-    parser.parse(Uri.parse("https://example.com/test.ismc"),
-        TestUtil.getInputStream(getInstrumentation(), SAMPLE_ISMC_1));
-    parser.parse(Uri.parse("https://example.com/test.ismc"),
-        TestUtil.getInputStream(getInstrumentation(), SAMPLE_ISMC_2));
+    parser.parse(
+        Uri.parse("https://example.com/test.ismc"),
+        TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_ISMC_1));
+    parser.parse(
+        Uri.parse("https://example.com/test.ismc"),
+        TestUtil.getInputStream(RuntimeEnvironment.application, SAMPLE_ISMC_2));
   }
-
 }
diff --git a/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
new file mode 100644
index 0000000000..fbb2c3d4c4
--- /dev/null
+++ b/library/smoothstreaming/src/test/java/com/google/android/exoplayer2/source/smoothstreaming/manifest/SsManifestTest.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.source.smoothstreaming.manifest;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.ProtectionElement;
+import com.google.android.exoplayer2.source.smoothstreaming.manifest.SsManifest.StreamElement;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit tests for {@link SsManifest}. */
+@RunWith(RobolectricTestRunner.class)
+public class SsManifestTest {
+
+  private static final ProtectionElement DUMMY_PROTECTION_ELEMENT =
+      new ProtectionElement(C.WIDEVINE_UUID, new byte[] {0, 1, 2});
+
+  @Test
+  public void testCopy() throws Exception {
+    Format[][] formats = newFormats(2, 3);
+    SsManifest sourceManifest =
+        newSsManifest(newStreamElement("1", formats[0]), newStreamElement("2", formats[1]));
+
+    List<TrackKey> keys = Arrays.asList(new TrackKey(0, 0), new TrackKey(0, 2), new TrackKey(1, 0));
+    // Keys don't need to be in any particular order
+    Collections.shuffle(keys, new Random(0));
+
+    SsManifest copyManifest = sourceManifest.copy(keys);
+
+    SsManifest expectedManifest =
+        newSsManifest(
+            newStreamElement("1", formats[0][0], formats[0][2]),
+            newStreamElement("2", formats[1][0]));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  @Test
+  public void testCopyRemoveStreamElement() throws Exception {
+    Format[][] formats = newFormats(2, 3);
+    SsManifest sourceManifest =
+        newSsManifest(newStreamElement("1", formats[0]), newStreamElement("2", formats[1]));
+
+    List<TrackKey> keys = Arrays.asList(new TrackKey(1, 0));
+    // Keys don't need to be in any particular order
+    Collections.shuffle(keys, new Random(0));
+
+    SsManifest copyManifest = sourceManifest.copy(keys);
+
+    SsManifest expectedManifest = newSsManifest(newStreamElement("2", formats[1][0]));
+    assertManifestEquals(expectedManifest, copyManifest);
+  }
+
+  private static void assertManifestEquals(SsManifest expected, SsManifest actual) {
+    assertThat(actual.durationUs).isEqualTo(expected.durationUs);
+    assertThat(actual.dvrWindowLengthUs).isEqualTo(expected.dvrWindowLengthUs);
+    assertThat(actual.isLive).isEqualTo(expected.isLive);
+    assertThat(actual.lookAheadCount).isEqualTo(expected.lookAheadCount);
+    assertThat(actual.majorVersion).isEqualTo(expected.majorVersion);
+    assertThat(actual.minorVersion).isEqualTo(expected.minorVersion);
+    assertThat(actual.protectionElement.uuid).isEqualTo(expected.protectionElement.uuid);
+    assertThat(actual.protectionElement).isEqualTo(expected.protectionElement);
+    for (int i = 0; i < expected.streamElements.length; i++) {
+      StreamElement expectedStreamElement = expected.streamElements[i];
+      StreamElement actualStreamElement = actual.streamElements[i];
+      assertThat(actualStreamElement.chunkCount).isEqualTo(expectedStreamElement.chunkCount);
+      assertThat(actualStreamElement.displayHeight).isEqualTo(expectedStreamElement.displayHeight);
+      assertThat(actualStreamElement.displayWidth).isEqualTo(expectedStreamElement.displayWidth);
+      assertThat(actualStreamElement.language).isEqualTo(expectedStreamElement.language);
+      assertThat(actualStreamElement.maxHeight).isEqualTo(expectedStreamElement.maxHeight);
+      assertThat(actualStreamElement.maxWidth).isEqualTo(expectedStreamElement.maxWidth);
+      assertThat(actualStreamElement.name).isEqualTo(expectedStreamElement.name);
+      assertThat(actualStreamElement.subType).isEqualTo(expectedStreamElement.subType);
+      assertThat(actualStreamElement.timescale).isEqualTo(expectedStreamElement.timescale);
+      assertThat(actualStreamElement.type).isEqualTo(expectedStreamElement.type);
+      assertThat(actualStreamElement.formats).isEqualTo(expectedStreamElement.formats);
+    }
+  }
+
+  private static Format[][] newFormats(int streamElementCount, int trackCounts) {
+    Format[][] formats = new Format[streamElementCount][];
+    for (int i = 0; i < streamElementCount; i++) {
+      formats[i] = new Format[trackCounts];
+      for (int j = 0; j < trackCounts; j++) {
+        formats[i][j] = newFormat(i + "." + j);
+      }
+    }
+    return formats;
+  }
+
+  private static SsManifest newSsManifest(StreamElement... streamElements) {
+    return new SsManifest(1, 2, 1000, 5000, 0, 0, false, DUMMY_PROTECTION_ELEMENT, streamElements);
+  }
+
+  private static StreamElement newStreamElement(String name, Format... formats) {
+    return new StreamElement(
+        "baseUri",
+        "chunkTemplate",
+        C.TRACK_TYPE_VIDEO,
+        "subType",
+        1000,
+        name,
+        1024,
+        768,
+        1024,
+        768,
+        null,
+        formats,
+        Collections.<Long>emptyList(),
+        0);
+  }
+
+  private static Format newFormat(String id) {
+    return Format.createContainerFormat(
+        id, MimeTypes.VIDEO_MP4, MimeTypes.VIDEO_H264, null, Format.NO_VALUE, 0, null);
+  }
+}
diff --git a/library/smoothstreaming/src/test/resources/robolectric.properties b/library/smoothstreaming/src/test/resources/robolectric.properties
new file mode 100644
index 0000000000..2f3210368e
--- /dev/null
+++ b/library/smoothstreaming/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+manifest=src/test/AndroidManifest.xml
diff --git a/library/ui/build.gradle b/library/ui/build.gradle
index 89734ed806..9689fcef97 100644
--- a/library/ui/build.gradle
+++ b/library/ui/build.gradle
@@ -33,8 +33,8 @@ android {
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
 }
 
 ext {
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
index 037519b7a4..d039581cf0 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/AspectRatioFrameLayout.java
@@ -28,12 +28,16 @@
  */
 public final class AspectRatioFrameLayout extends FrameLayout {
 
-  /**
-   * Resize modes for {@link AspectRatioFrameLayout}.
-   */
+  // LINT.IfChange
+  /** Resize modes for {@link AspectRatioFrameLayout}. */
   @Retention(RetentionPolicy.SOURCE)
-  @IntDef({RESIZE_MODE_FIT, RESIZE_MODE_FIXED_WIDTH, RESIZE_MODE_FIXED_HEIGHT, RESIZE_MODE_FILL,
-      RESIZE_MODE_ZOOM})
+  @IntDef({
+    RESIZE_MODE_FIT,
+    RESIZE_MODE_FIXED_WIDTH,
+    RESIZE_MODE_FIXED_HEIGHT,
+    RESIZE_MODE_FILL,
+    RESIZE_MODE_ZOOM
+  })
   public @interface ResizeMode {}
 
   /**
@@ -56,12 +60,13 @@
    * Either the width or height is increased to obtain the desired aspect ratio.
    */
   public static final int RESIZE_MODE_ZOOM = 4;
+  // LINT.ThenChange(../../../../../../res/values/attrs.xml)
 
   /**
    * The {@link FrameLayout} will not resize itself if the fractional difference between its natural
    * aspect ratio and the requested aspect ratio falls below this threshold.
-   * <p>
-   * This tolerance allows the view to occupy the whole of the screen when the requested aspect
+   *
+   * <p>This tolerance allows the view to occupy the whole of the screen when the requested aspect
    * ratio is very close, but not exactly equal to, the aspect ratio of the screen. This may reduce
    * the number of view layers that need to be composited by the underlying system, which can help
    * to reduce power consumption.
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
index fda74db28d..6066445e9d 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DebugTextViewHelper.java
@@ -27,7 +27,7 @@
  * A helper class for periodically updating a {@link TextView} with debug information obtained from
  * a {@link SimpleExoPlayer}.
  */
-public final class DebugTextViewHelper extends Player.DefaultEventListener implements Runnable {
+public class DebugTextViewHelper extends Player.DefaultEventListener implements Runnable {
 
   private static final int REFRESH_INTERVAL_MS = 1000;
 
@@ -49,7 +49,7 @@ public DebugTextViewHelper(SimpleExoPlayer player, TextView textView) {
    * Starts periodic updates of the {@link TextView}. Must be called from the application's main
    * thread.
    */
-  public void start() {
+  public final void start() {
     if (started) {
       return;
     }
@@ -62,7 +62,7 @@ public void start() {
    * Stops periodic updates of the {@link TextView}. Must be called from the application's main
    * thread.
    */
-  public void stop() {
+  public final void stop() {
     if (!started) {
       return;
     }
@@ -74,59 +74,63 @@ public void stop() {
   // Player.EventListener implementation.
 
   @Override
-  public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+  public final void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
     updateAndPost();
   }
 
   @Override
-  public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+  public final void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
     updateAndPost();
   }
 
   // Runnable implementation.
 
   @Override
-  public void run() {
+  public final void run() {
     updateAndPost();
   }
 
-  // Private methods.
+  // Protected methods.
 
   @SuppressLint("SetTextI18n")
-  private void updateAndPost() {
-    textView.setText(getPlayerStateString() + getPlayerWindowIndexString() + getVideoString()
-        + getAudioString());
+  protected final void updateAndPost() {
+    textView.setText(getDebugString());
     textView.removeCallbacks(this);
     textView.postDelayed(this, REFRESH_INTERVAL_MS);
   }
 
-  private String getPlayerStateString() {
-    String text = "playWhenReady:" + player.getPlayWhenReady() + " playbackState:";
+  /** Returns the debugging information string to be shown by the target {@link TextView}. */
+  protected String getDebugString() {
+    return getPlayerStateString() + getVideoString() + getAudioString();
+  }
+
+  /** Returns a string containing player state debugging information. */
+  protected String getPlayerStateString() {
+    String playbackStateString;
     switch (player.getPlaybackState()) {
       case Player.STATE_BUFFERING:
-        text += "buffering";
+        playbackStateString = "buffering";
         break;
       case Player.STATE_ENDED:
-        text += "ended";
+        playbackStateString = "ended";
         break;
       case Player.STATE_IDLE:
-        text += "idle";
+        playbackStateString = "idle";
         break;
       case Player.STATE_READY:
-        text += "ready";
+        playbackStateString = "ready";
         break;
       default:
-        text += "unknown";
+        playbackStateString = "unknown";
         break;
     }
-    return text;
-  }
-
-  private String getPlayerWindowIndexString() {
-    return " window:" + player.getCurrentWindowIndex();
+    return String.format(
+        "playWhenReady:%s playbackState:%s window:%s",
+        player.getPlayWhenReady(), playbackStateString, player.getCurrentWindowIndex());
   }
 
-  private String getVideoString() {
+  /** Returns a string containing video debugging information. */
+  protected String getVideoString() {
     Format format = player.getVideoFormat();
     if (format == null) {
       return "";
@@ -136,7 +140,8 @@ private String getVideoString() {
         + getDecoderCountersBufferCountString(player.getVideoDecoderCounters()) + ")";
   }
 
-  private String getAudioString() {
+  /** Returns a string containing audio debugging information. */
+  protected String getAudioString() {
     Format format = player.getAudioFormat();
     if (format == null) {
       return "";
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
index 048bb3ffff..a15ee1b88e 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java
@@ -250,7 +250,7 @@ public DefaultTimeBar(Context context, AttributeSet attrs) {
       try {
         scrubberDrawable = a.getDrawable(R.styleable.DefaultTimeBar_scrubber_drawable);
         if (scrubberDrawable != null) {
-          setDrawableLayoutDirection(scrubberDrawable, getLayoutDirection());
+          setDrawableLayoutDirection(scrubberDrawable);
           defaultTouchTargetHeight =
               Math.max(scrubberDrawable.getMinimumHeight(), defaultTouchTargetHeight);
         }
@@ -747,8 +747,8 @@ private boolean scrubIncrementally(long positionChange) {
     return true;
   }
 
-  private static int dpToPx(DisplayMetrics displayMetrics, int dps) {
-    return (int) (dps * displayMetrics.density + 0.5f);
+  private boolean setDrawableLayoutDirection(Drawable drawable) {
+    return Util.SDK_INT >= 23 && setDrawableLayoutDirection(drawable, getLayoutDirection());
   }
 
   private static boolean setDrawableLayoutDirection(Drawable drawable, int layoutDirection) {
@@ -771,4 +771,7 @@ public static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
     return 0x33000000 | (adMarkerColor & 0x00FFFFFF);
   }
 
+  private static int dpToPx(DisplayMetrics displayMetrics, int dps) {
+    return (int) (dps * displayMetrics.density + 0.5f);
+  }
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
index a96ed3a622..da03d28cba 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java
@@ -15,1120 +15,60 @@
  */
 package com.google.android.exoplayer2.ui;
 
-import android.annotation.SuppressLint;
 import android.content.Context;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.drawable.Drawable;
-import android.os.SystemClock;
-import android.support.annotation.Nullable;
 import android.util.AttributeSet;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.TextView;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.RepeatModeUtil;
-import com.google.android.exoplayer2.util.Util;
-import java.util.Arrays;
-import java.util.Formatter;
-import java.util.Locale;
 
-/**
- * A view for controlling {@link Player} instances.
- * <p>
- * A PlaybackControlView can be customized by setting attributes (or calling corresponding methods),
- * overriding the view's layout file or by specifying a custom view layout file, as outlined below.
- *
- * <h3>Attributes</h3>
- * The following attributes can be set on a PlaybackControlView when used in a layout XML file:
- * <p>
- * <ul>
- *   <li><b>{@code show_timeout}</b> - The time between the last user interaction and the controls
- *       being automatically hidden, in milliseconds. Use zero if the controls should not
- *       automatically timeout.
- *       <ul>
- *         <li>Corresponding method: {@link #setShowTimeoutMs(int)}</li>
- *         <li>Default: {@link #DEFAULT_SHOW_TIMEOUT_MS}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code rewind_increment}</b> - The duration of the rewind applied when the user taps the
- *       rewind button, in milliseconds. Use zero to disable the rewind button.
- *       <ul>
- *         <li>Corresponding method: {@link #setRewindIncrementMs(int)}</li>
- *         <li>Default: {@link #DEFAULT_REWIND_MS}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code fastforward_increment}</b> - Like {@code rewind_increment}, but for fast forward.
- *       <ul>
- *         <li>Corresponding method: {@link #setFastForwardIncrementMs(int)}</li>
- *         <li>Default: {@link #DEFAULT_FAST_FORWARD_MS}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code repeat_toggle_modes}</b> - A flagged enumeration value specifying which repeat
- *       mode toggle options are enabled. Valid values are: {@code none}, {@code one},
- *       {@code all}, or {@code one|all}.
- *       <ul>
- *         <li>Corresponding method: {@link #setRepeatToggleModes(int)}</li>
- *         <li>Default: {@link PlaybackControlView#DEFAULT_REPEAT_TOGGLE_MODES}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code show_shuffle_button}</b> - Whether the shuffle button is shown.
- *       <ul>
- *         <li>Corresponding method: {@link #setShowShuffleButton(boolean)}</li>
- *         <li>Default: false</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout to be inflated. See
- *       below for more details.
- *       <ul>
- *         <li>Corresponding method: None</li>
- *         <li>Default: {@code R.id.exo_playback_control_view}</li>
- *       </ul>
- *   </li>
- * </ul>
- *
- * <h3>Overriding the layout file</h3>
- * To customize the layout of PlaybackControlView throughout your app, or just for certain
- * configurations, you can define {@code exo_playback_control_view.xml} layout files in your
- * application {@code res/layout*} directories. These layouts will override the one provided by the
- * ExoPlayer library, and will be inflated for use by PlaybackControlView. The view identifies and
- * binds its children by looking for the following ids:
- * <p>
- * <ul>
- *   <li><b>{@code exo_play}</b> - The play button.
- *       <ul>
- *         <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_pause}</b> - The pause button.
- *       <ul>
- *         <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_ffwd}</b> - The fast forward button.
- *       <ul>
- *         <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_rew}</b> - The rewind button.
- *       <ul>
- *         <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_prev}</b> - The previous track button.
- *       <ul>
- *         <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_next}</b> - The next track button.
- *       <ul>
- *         <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_repeat_toggle}</b> - The repeat toggle button.
- *       <ul>
- *         <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_shuffle}</b> - The shuffle button.
- *       <ul>
- *         <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_position}</b> - Text view displaying the current playback position.
- *       <ul>
- *         <li>Type: {@link TextView}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_duration}</b> - Text view displaying the current media duration.
- *       <ul>
- *         <li>Type: {@link TextView}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_progress}</b> - Time bar that's updated during playback and allows seeking.
- *       <ul>
- *         <li>Type: {@link TimeBar}</li>
- *       </ul>
- *   </li>
- * </ul>
- * <p>
- * All child views are optional and so can be omitted if not required, however where defined they
- * must be of the expected type.
- *
- * <h3>Specifying a custom layout file</h3>
- * Defining your own {@code exo_playback_control_view.xml} is useful to customize the layout of
- * PlaybackControlView throughout your application. It's also possible to customize the layout for a
- * single instance in a layout file. This is achieved by setting the {@code controller_layout_id}
- * attribute on a PlaybackControlView. This will cause the specified layout to be inflated instead
- * of {@code exo_playback_control_view.xml} for only the instance on which the attribute is set.
- */
-public class PlaybackControlView extends FrameLayout {
-
-  static {
-    ExoPlayerLibraryInfo.registerModule("goog.exo.ui");
-  }
+/** @deprecated Use {@link PlayerControlView}. */
+@Deprecated
+public class PlaybackControlView extends PlayerControlView {
 
-  /**
-   * @deprecated Use {@link com.google.android.exoplayer2.ControlDispatcher}.
-   */
+  /** @deprecated Use {@link com.google.android.exoplayer2.ControlDispatcher}. */
   @Deprecated
   public interface ControlDispatcher extends com.google.android.exoplayer2.ControlDispatcher {}
 
   /**
-   * Listener to be notified about changes of the visibility of the UI control.
+   * @deprecated Use {@link com.google.android.exoplayer2.ui.PlayerControlView.VisibilityListener}.
    */
-  public interface VisibilityListener {
-
-    /**
-     * Called when the visibility changes.
-     *
-     * @param visibility The new visibility. Either {@link View#VISIBLE} or {@link View#GONE}.
-     */
-    void onVisibilityChange(int visibility);
-
-  }
+  @Deprecated
+  public interface VisibilityListener
+      extends com.google.android.exoplayer2.ui.PlayerControlView.VisibilityListener {}
 
   private static final class DefaultControlDispatcher
       extends com.google.android.exoplayer2.DefaultControlDispatcher implements ControlDispatcher {}
-  /**
-   * @deprecated Use {@link com.google.android.exoplayer2.DefaultControlDispatcher}.
-   */
+  /** @deprecated Use {@link com.google.android.exoplayer2.DefaultControlDispatcher}. */
   @Deprecated
   public static final ControlDispatcher DEFAULT_CONTROL_DISPATCHER = new DefaultControlDispatcher();
 
-  /**
-   * The default fast forward increment, in milliseconds.
-   */
-  public static final int DEFAULT_FAST_FORWARD_MS = 15000;
-  /**
-   * The default rewind increment, in milliseconds.
-   */
-  public static final int DEFAULT_REWIND_MS = 5000;
-  /**
-   * The default show timeout, in milliseconds.
-   */
-  public static final int DEFAULT_SHOW_TIMEOUT_MS = 5000;
-  /**
-   * The default repeat toggle modes.
-   */
+  /** The default fast forward increment, in milliseconds. */
+  public static final int DEFAULT_FAST_FORWARD_MS = PlayerControlView.DEFAULT_FAST_FORWARD_MS;
+  /** The default rewind increment, in milliseconds. */
+  public static final int DEFAULT_REWIND_MS = PlayerControlView.DEFAULT_REWIND_MS;
+  /** The default show timeout, in milliseconds. */
+  public static final int DEFAULT_SHOW_TIMEOUT_MS = PlayerControlView.DEFAULT_SHOW_TIMEOUT_MS;
+  /** The default repeat toggle modes. */
   public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
-      RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE;
-
-  /**
-   * The maximum number of windows that can be shown in a multi-window time bar.
-   */
-  public static final int MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR = 100;
-
-  private static final long MAX_POSITION_FOR_SEEK_TO_PREVIOUS = 3000;
-
-  private final ComponentListener componentListener;
-  private final View previousButton;
-  private final View nextButton;
-  private final View playButton;
-  private final View pauseButton;
-  private final View fastForwardButton;
-  private final View rewindButton;
-  private final ImageView repeatToggleButton;
-  private final View shuffleButton;
-  private final TextView durationView;
-  private final TextView positionView;
-  private final TimeBar timeBar;
-  private final StringBuilder formatBuilder;
-  private final Formatter formatter;
-  private final Timeline.Period period;
-  private final Timeline.Window window;
+      PlayerControlView.DEFAULT_REPEAT_TOGGLE_MODES;
 
-  private final Drawable repeatOffButtonDrawable;
-  private final Drawable repeatOneButtonDrawable;
-  private final Drawable repeatAllButtonDrawable;
-  private final String repeatOffButtonContentDescription;
-  private final String repeatOneButtonContentDescription;
-  private final String repeatAllButtonContentDescription;
-
-  private Player player;
-  private com.google.android.exoplayer2.ControlDispatcher controlDispatcher;
-  private VisibilityListener visibilityListener;
-
-  private boolean isAttachedToWindow;
-  private boolean showMultiWindowTimeBar;
-  private boolean multiWindowTimeBar;
-  private boolean scrubbing;
-  private int rewindMs;
-  private int fastForwardMs;
-  private int showTimeoutMs;
-  private @RepeatModeUtil.RepeatToggleModes int repeatToggleModes;
-  private boolean showShuffleButton;
-  private long hideAtMs;
-  private long[] adGroupTimesMs;
-  private boolean[] playedAdGroups;
-  private long[] extraAdGroupTimesMs;
-  private boolean[] extraPlayedAdGroups;
-
-  private final Runnable updateProgressAction = new Runnable() {
-    @Override
-    public void run() {
-      updateProgress();
-    }
-  };
-
-  private final Runnable hideAction = new Runnable() {
-    @Override
-    public void run() {
-      hide();
-    }
-  };
+  /** The maximum number of windows that can be shown in a multi-window time bar. */
+  public static final int MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR =
+      PlayerControlView.MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR;
 
   public PlaybackControlView(Context context) {
-    this(context, null);
+    super(context);
   }
 
   public PlaybackControlView(Context context, AttributeSet attrs) {
-    this(context, attrs, 0);
+    super(context, attrs);
   }
 
   public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr) {
-    this(context, attrs, defStyleAttr, attrs);
-  }
-
-  public PlaybackControlView(Context context, AttributeSet attrs, int defStyleAttr,
-      AttributeSet playbackAttrs) {
     super(context, attrs, defStyleAttr);
-    int controllerLayoutId = R.layout.exo_playback_control_view;
-    rewindMs = DEFAULT_REWIND_MS;
-    fastForwardMs = DEFAULT_FAST_FORWARD_MS;
-    showTimeoutMs = DEFAULT_SHOW_TIMEOUT_MS;
-    repeatToggleModes = DEFAULT_REPEAT_TOGGLE_MODES;
-    showShuffleButton = false;
-    if (playbackAttrs != null) {
-      TypedArray a = context.getTheme().obtainStyledAttributes(playbackAttrs,
-          R.styleable.PlaybackControlView, 0, 0);
-      try {
-        rewindMs = a.getInt(R.styleable.PlaybackControlView_rewind_increment, rewindMs);
-        fastForwardMs = a.getInt(R.styleable.PlaybackControlView_fastforward_increment,
-            fastForwardMs);
-        showTimeoutMs = a.getInt(R.styleable.PlaybackControlView_show_timeout, showTimeoutMs);
-        controllerLayoutId = a.getResourceId(R.styleable.PlaybackControlView_controller_layout_id,
-            controllerLayoutId);
-        repeatToggleModes = getRepeatToggleModes(a, repeatToggleModes);
-        showShuffleButton = a.getBoolean(R.styleable.PlaybackControlView_show_shuffle_button,
-            showShuffleButton);
-      } finally {
-        a.recycle();
-      }
-    }
-    period = new Timeline.Period();
-    window = new Timeline.Window();
-    formatBuilder = new StringBuilder();
-    formatter = new Formatter(formatBuilder, Locale.getDefault());
-    adGroupTimesMs = new long[0];
-    playedAdGroups = new boolean[0];
-    extraAdGroupTimesMs = new long[0];
-    extraPlayedAdGroups = new boolean[0];
-    componentListener = new ComponentListener();
-    controlDispatcher = new com.google.android.exoplayer2.DefaultControlDispatcher();
-
-    LayoutInflater.from(context).inflate(controllerLayoutId, this);
-    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
-
-    durationView = findViewById(R.id.exo_duration);
-    positionView = findViewById(R.id.exo_position);
-    timeBar = findViewById(R.id.exo_progress);
-    if (timeBar != null) {
-      timeBar.addListener(componentListener);
-    }
-    playButton = findViewById(R.id.exo_play);
-    if (playButton != null) {
-      playButton.setOnClickListener(componentListener);
-    }
-    pauseButton = findViewById(R.id.exo_pause);
-    if (pauseButton != null) {
-      pauseButton.setOnClickListener(componentListener);
-    }
-    previousButton = findViewById(R.id.exo_prev);
-    if (previousButton != null) {
-      previousButton.setOnClickListener(componentListener);
-    }
-    nextButton = findViewById(R.id.exo_next);
-    if (nextButton != null) {
-      nextButton.setOnClickListener(componentListener);
-    }
-    rewindButton = findViewById(R.id.exo_rew);
-    if (rewindButton != null) {
-      rewindButton.setOnClickListener(componentListener);
-    }
-    fastForwardButton = findViewById(R.id.exo_ffwd);
-    if (fastForwardButton != null) {
-      fastForwardButton.setOnClickListener(componentListener);
-    }
-    repeatToggleButton = findViewById(R.id.exo_repeat_toggle);
-    if (repeatToggleButton != null) {
-      repeatToggleButton.setOnClickListener(componentListener);
-    }
-    shuffleButton = findViewById(R.id.exo_shuffle);
-    if (shuffleButton != null) {
-      shuffleButton.setOnClickListener(componentListener);
-    }
-    Resources resources = context.getResources();
-    repeatOffButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_off);
-    repeatOneButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_one);
-    repeatAllButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_all);
-    repeatOffButtonContentDescription = resources.getString(
-        R.string.exo_controls_repeat_off_description);
-    repeatOneButtonContentDescription = resources.getString(
-        R.string.exo_controls_repeat_one_description);
-    repeatAllButtonContentDescription = resources.getString(
-        R.string.exo_controls_repeat_all_description);
-  }
-
-  @SuppressWarnings("ResourceType")
-  private static @RepeatModeUtil.RepeatToggleModes int getRepeatToggleModes(TypedArray a,
-      @RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
-    return a.getInt(R.styleable.PlaybackControlView_repeat_toggle_modes, repeatToggleModes);
-  }
-
-  /**
-   * Returns the {@link Player} currently being controlled by this view, or null if no player is
-   * set.
-   */
-  public Player getPlayer() {
-    return player;
-  }
-
-  /**
-   * Sets the {@link Player} to control.
-   *
-   * @param player The {@link Player} to control.
-   */
-  public void setPlayer(Player player) {
-    if (this.player == player) {
-      return;
-    }
-    if (this.player != null) {
-      this.player.removeListener(componentListener);
-    }
-    this.player = player;
-    if (player != null) {
-      player.addListener(componentListener);
-    }
-    updateAll();
-  }
-
-  /**
-   * Sets whether the time bar should show all windows, as opposed to just the current one. If the
-   * timeline has a period with unknown duration or more than
-   * {@link #MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR} windows the time bar will fall back to showing a
-   * single window.
-   *
-   * @param showMultiWindowTimeBar Whether the time bar should show all windows.
-   */
-  public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {
-    this.showMultiWindowTimeBar = showMultiWindowTimeBar;
-    updateTimeBarMode();
-  }
-
-  /**
-   * Sets the millisecond positions of extra ad markers relative to the start of the window (or
-   * timeline, if in multi-window mode) and whether each extra ad has been played or not. The
-   * markers are shown in addition to any ad markers for ads in the player's timeline.
-   *
-   * @param extraAdGroupTimesMs The millisecond timestamps of the extra ad markers to show, or
-   *     {@code null} to show no extra ad markers.
-   * @param extraPlayedAdGroups Whether each ad has been played, or {@code null} to show no extra ad
-   *     markers.
-   */
-  public void setExtraAdGroupMarkers(@Nullable long[] extraAdGroupTimesMs,
-      @Nullable boolean[] extraPlayedAdGroups) {
-    if (extraAdGroupTimesMs == null) {
-      this.extraAdGroupTimesMs = new long[0];
-      this.extraPlayedAdGroups = new boolean[0];
-    } else {
-      Assertions.checkArgument(extraAdGroupTimesMs.length == extraPlayedAdGroups.length);
-      this.extraAdGroupTimesMs = extraAdGroupTimesMs;
-      this.extraPlayedAdGroups = extraPlayedAdGroups;
-    }
-    updateProgress();
-  }
-
-  /**
-   * Sets the {@link VisibilityListener}.
-   *
-   * @param listener The listener to be notified about visibility changes.
-   */
-  public void setVisibilityListener(VisibilityListener listener) {
-    this.visibilityListener = listener;
-  }
-
-  /**
-   * Sets the {@link com.google.android.exoplayer2.ControlDispatcher}.
-   *
-   * @param controlDispatcher The {@link com.google.android.exoplayer2.ControlDispatcher}, or null
-   *     to use {@link com.google.android.exoplayer2.DefaultControlDispatcher}.
-   */
-  public void setControlDispatcher(
-      @Nullable com.google.android.exoplayer2.ControlDispatcher controlDispatcher) {
-    this.controlDispatcher = controlDispatcher == null
-        ? new com.google.android.exoplayer2.DefaultControlDispatcher() : controlDispatcher;
-  }
-
-  /**
-   * Sets the rewind increment in milliseconds.
-   *
-   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
-   *     rewind button to be disabled.
-   */
-  public void setRewindIncrementMs(int rewindMs) {
-    this.rewindMs = rewindMs;
-    updateNavigation();
-  }
-
-  /**
-   * Sets the fast forward increment in milliseconds.
-   *
-   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
-   *     cause the fast forward button to be disabled.
-   */
-  public void setFastForwardIncrementMs(int fastForwardMs) {
-    this.fastForwardMs = fastForwardMs;
-    updateNavigation();
   }
 
-  /**
-   * Returns the playback controls timeout. The playback controls are automatically hidden after
-   * this duration of time has elapsed without user input.
-   *
-   * @return The duration in milliseconds. A non-positive value indicates that the controls will
-   *     remain visible indefinitely.
-   */
-  public int getShowTimeoutMs() {
-    return showTimeoutMs;
-  }
-
-  /**
-   * Sets the playback controls timeout. The playback controls are automatically hidden after this
-   * duration of time has elapsed without user input.
-   *
-   * @param showTimeoutMs The duration in milliseconds. A non-positive value will cause the controls
-   *     to remain visible indefinitely.
-   */
-  public void setShowTimeoutMs(int showTimeoutMs) {
-    this.showTimeoutMs = showTimeoutMs;
-  }
-
-  /**
-   * Returns which repeat toggle modes are enabled.
-   *
-   * @return The currently enabled {@link RepeatModeUtil.RepeatToggleModes}.
-   */
-  public @RepeatModeUtil.RepeatToggleModes int getRepeatToggleModes() {
-    return repeatToggleModes;
-  }
-
-  /**
-   * Sets which repeat toggle modes are enabled.
-   *
-   * @param repeatToggleModes A set of {@link RepeatModeUtil.RepeatToggleModes}.
-   */
-  public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
-    this.repeatToggleModes = repeatToggleModes;
-    if (player != null) {
-      @Player.RepeatMode int currentMode = player.getRepeatMode();
-      if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE
-          && currentMode != Player.REPEAT_MODE_OFF) {
-        controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_OFF);
-      } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE
-          && currentMode == Player.REPEAT_MODE_ALL) {
-        controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_ONE);
-      } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL
-          && currentMode == Player.REPEAT_MODE_ONE) {
-        controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_ALL);
-      }
-    }
-  }
-
-  /**
-   * Returns whether the shuffle button is shown.
-   */
-  public boolean getShowShuffleButton() {
-    return showShuffleButton;
-  }
-
-  /**
-   * Sets whether the shuffle button is shown.
-   *
-   * @param showShuffleButton Whether the shuffle button is shown.
-   */
-  public void setShowShuffleButton(boolean showShuffleButton) {
-    this.showShuffleButton = showShuffleButton;
-    updateShuffleButton();
-  }
-
-  /**
-   * Shows the playback controls. If {@link #getShowTimeoutMs()} is positive then the controls will
-   * be automatically hidden after this duration of time has elapsed without user input.
-   */
-  public void show() {
-    if (!isVisible()) {
-      setVisibility(VISIBLE);
-      if (visibilityListener != null) {
-        visibilityListener.onVisibilityChange(getVisibility());
-      }
-      updateAll();
-      requestPlayPauseFocus();
-    }
-    // Call hideAfterTimeout even if already visible to reset the timeout.
-    hideAfterTimeout();
-  }
-
-  /**
-   * Hides the controller.
-   */
-  public void hide() {
-    if (isVisible()) {
-      setVisibility(GONE);
-      if (visibilityListener != null) {
-        visibilityListener.onVisibilityChange(getVisibility());
-      }
-      removeCallbacks(updateProgressAction);
-      removeCallbacks(hideAction);
-      hideAtMs = C.TIME_UNSET;
-    }
-  }
-
-  /**
-   * Returns whether the controller is currently visible.
-   */
-  public boolean isVisible() {
-    return getVisibility() == VISIBLE;
-  }
-
-  private void hideAfterTimeout() {
-    removeCallbacks(hideAction);
-    if (showTimeoutMs > 0) {
-      hideAtMs = SystemClock.uptimeMillis() + showTimeoutMs;
-      if (isAttachedToWindow) {
-        postDelayed(hideAction, showTimeoutMs);
-      }
-    } else {
-      hideAtMs = C.TIME_UNSET;
-    }
-  }
-
-  private void updateAll() {
-    updatePlayPauseButton();
-    updateNavigation();
-    updateRepeatModeButton();
-    updateShuffleButton();
-    updateProgress();
-  }
-
-  private void updatePlayPauseButton() {
-    if (!isVisible() || !isAttachedToWindow) {
-      return;
-    }
-    boolean requestPlayPauseFocus = false;
-    boolean playing = player != null && player.getPlayWhenReady();
-    if (playButton != null) {
-      requestPlayPauseFocus |= playing && playButton.isFocused();
-      playButton.setVisibility(playing ? View.GONE : View.VISIBLE);
-    }
-    if (pauseButton != null) {
-      requestPlayPauseFocus |= !playing && pauseButton.isFocused();
-      pauseButton.setVisibility(!playing ? View.GONE : View.VISIBLE);
-    }
-    if (requestPlayPauseFocus) {
-      requestPlayPauseFocus();
-    }
-  }
-
-  private void updateNavigation() {
-    if (!isVisible() || !isAttachedToWindow) {
-      return;
-    }
-    Timeline timeline = player != null ? player.getCurrentTimeline() : null;
-    boolean haveNonEmptyTimeline = timeline != null && !timeline.isEmpty();
-    boolean isSeekable = false;
-    boolean enablePrevious = false;
-    boolean enableNext = false;
-    if (haveNonEmptyTimeline && !player.isPlayingAd()) {
-      int windowIndex = player.getCurrentWindowIndex();
-      timeline.getWindow(windowIndex, window);
-      isSeekable = window.isSeekable;
-      enablePrevious = isSeekable || !window.isDynamic
-          || player.getPreviousWindowIndex() != C.INDEX_UNSET;
-      enableNext = window.isDynamic || player.getNextWindowIndex() != C.INDEX_UNSET;
-    }
-    setButtonEnabled(enablePrevious, previousButton);
-    setButtonEnabled(enableNext, nextButton);
-    setButtonEnabled(fastForwardMs > 0 && isSeekable, fastForwardButton);
-    setButtonEnabled(rewindMs > 0 && isSeekable, rewindButton);
-    if (timeBar != null) {
-      timeBar.setEnabled(isSeekable);
-    }
-  }
-
-  private void updateRepeatModeButton() {
-    if (!isVisible() || !isAttachedToWindow || repeatToggleButton == null) {
-      return;
-    }
-    if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE) {
-      repeatToggleButton.setVisibility(View.GONE);
-      return;
-    }
-    if (player == null) {
-      setButtonEnabled(false, repeatToggleButton);
-      return;
-    }
-    setButtonEnabled(true, repeatToggleButton);
-    switch (player.getRepeatMode()) {
-      case Player.REPEAT_MODE_OFF:
-        repeatToggleButton.setImageDrawable(repeatOffButtonDrawable);
-        repeatToggleButton.setContentDescription(repeatOffButtonContentDescription);
-        break;
-      case Player.REPEAT_MODE_ONE:
-        repeatToggleButton.setImageDrawable(repeatOneButtonDrawable);
-        repeatToggleButton.setContentDescription(repeatOneButtonContentDescription);
-        break;
-      case Player.REPEAT_MODE_ALL:
-        repeatToggleButton.setImageDrawable(repeatAllButtonDrawable);
-        repeatToggleButton.setContentDescription(repeatAllButtonContentDescription);
-        break;
-    }
-    repeatToggleButton.setVisibility(View.VISIBLE);
-  }
-
-  private void updateShuffleButton() {
-    if (!isVisible() || !isAttachedToWindow || shuffleButton == null) {
-      return;
-    }
-    if (!showShuffleButton) {
-      shuffleButton.setVisibility(View.GONE);
-    } else if (player == null) {
-      setButtonEnabled(false, shuffleButton);
-    } else {
-      shuffleButton.setAlpha(player.getShuffleModeEnabled() ? 1f : 0.3f);
-      shuffleButton.setEnabled(true);
-      shuffleButton.setVisibility(View.VISIBLE);
-    }
-  }
-
-  private void updateTimeBarMode() {
-    if (player == null) {
-      return;
-    }
-    multiWindowTimeBar = showMultiWindowTimeBar
-        && canShowMultiWindowTimeBar(player.getCurrentTimeline(), window);
-  }
-
-  private void updateProgress() {
-    if (!isVisible() || !isAttachedToWindow) {
-      return;
-    }
-
-    long position = 0;
-    long bufferedPosition = 0;
-    long duration = 0;
-    if (player != null) {
-      long currentWindowTimeBarOffsetUs = 0;
-      long durationUs = 0;
-      int adGroupCount = 0;
-      Timeline timeline = player.getCurrentTimeline();
-      if (!timeline.isEmpty()) {
-        int currentWindowIndex = player.getCurrentWindowIndex();
-        int firstWindowIndex = multiWindowTimeBar ? 0 : currentWindowIndex;
-        int lastWindowIndex =
-            multiWindowTimeBar ? timeline.getWindowCount() - 1 : currentWindowIndex;
-        for (int i = firstWindowIndex; i <= lastWindowIndex; i++) {
-          if (i == currentWindowIndex) {
-            currentWindowTimeBarOffsetUs = durationUs;
-          }
-          timeline.getWindow(i, window);
-          if (window.durationUs == C.TIME_UNSET) {
-            Assertions.checkState(!multiWindowTimeBar);
-            break;
-          }
-          for (int j = window.firstPeriodIndex; j <= window.lastPeriodIndex; j++) {
-            timeline.getPeriod(j, period);
-            int periodAdGroupCount = period.getAdGroupCount();
-            for (int adGroupIndex = 0; adGroupIndex < periodAdGroupCount; adGroupIndex++) {
-              long adGroupTimeInPeriodUs = period.getAdGroupTimeUs(adGroupIndex);
-              if (adGroupTimeInPeriodUs == C.TIME_END_OF_SOURCE) {
-                if (period.durationUs == C.TIME_UNSET) {
-                  // Don't show ad markers for postrolls in periods with unknown duration.
-                  continue;
-                }
-                adGroupTimeInPeriodUs = period.durationUs;
-              }
-              long adGroupTimeInWindowUs = adGroupTimeInPeriodUs + period.getPositionInWindowUs();
-              if (adGroupTimeInWindowUs >= 0 && adGroupTimeInWindowUs <= window.durationUs) {
-                if (adGroupCount == adGroupTimesMs.length) {
-                  int newLength = adGroupTimesMs.length == 0 ? 1 : adGroupTimesMs.length * 2;
-                  adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, newLength);
-                  playedAdGroups = Arrays.copyOf(playedAdGroups, newLength);
-                }
-                adGroupTimesMs[adGroupCount] = C.usToMs(durationUs + adGroupTimeInWindowUs);
-                playedAdGroups[adGroupCount] = period.hasPlayedAdGroup(adGroupIndex);
-                adGroupCount++;
-              }
-            }
-          }
-          durationUs += window.durationUs;
-        }
-      }
-      duration = C.usToMs(durationUs);
-      position = C.usToMs(currentWindowTimeBarOffsetUs);
-      bufferedPosition = position;
-      if (player.isPlayingAd()) {
-        position += player.getContentPosition();
-        bufferedPosition = position;
-      } else {
-        position += player.getCurrentPosition();
-        bufferedPosition += player.getBufferedPosition();
-      }
-      if (timeBar != null) {
-        int extraAdGroupCount = extraAdGroupTimesMs.length;
-        int totalAdGroupCount = adGroupCount + extraAdGroupCount;
-        if (totalAdGroupCount > adGroupTimesMs.length) {
-          adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, totalAdGroupCount);
-          playedAdGroups = Arrays.copyOf(playedAdGroups, totalAdGroupCount);
-        }
-        System.arraycopy(extraAdGroupTimesMs, 0, adGroupTimesMs, adGroupCount, extraAdGroupCount);
-        System.arraycopy(extraPlayedAdGroups, 0, playedAdGroups, adGroupCount, extraAdGroupCount);
-        timeBar.setAdGroupTimesMs(adGroupTimesMs, playedAdGroups, totalAdGroupCount);
-      }
-    }
-    if (durationView != null) {
-      durationView.setText(Util.getStringForTime(formatBuilder, formatter, duration));
-    }
-    if (positionView != null && !scrubbing) {
-      positionView.setText(Util.getStringForTime(formatBuilder, formatter, position));
-    }
-    if (timeBar != null) {
-      timeBar.setPosition(position);
-      timeBar.setBufferedPosition(bufferedPosition);
-      timeBar.setDuration(duration);
-    }
-
-    // Cancel any pending updates and schedule a new one if necessary.
-    removeCallbacks(updateProgressAction);
-    int playbackState = player == null ? Player.STATE_IDLE : player.getPlaybackState();
-    if (playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED) {
-      long delayMs;
-      if (player.getPlayWhenReady() && playbackState == Player.STATE_READY) {
-        float playbackSpeed = player.getPlaybackParameters().speed;
-        if (playbackSpeed <= 0.1f) {
-          delayMs = 1000;
-        } else if (playbackSpeed <= 5f) {
-          long mediaTimeUpdatePeriodMs = 1000 / Math.max(1, Math.round(1 / playbackSpeed));
-          long mediaTimeDelayMs = mediaTimeUpdatePeriodMs - (position % mediaTimeUpdatePeriodMs);
-          if (mediaTimeDelayMs < (mediaTimeUpdatePeriodMs / 5)) {
-            mediaTimeDelayMs += mediaTimeUpdatePeriodMs;
-          }
-          delayMs = playbackSpeed == 1 ? mediaTimeDelayMs
-              : (long) (mediaTimeDelayMs / playbackSpeed);
-        } else {
-          delayMs = 200;
-        }
-      } else {
-        delayMs = 1000;
-      }
-      postDelayed(updateProgressAction, delayMs);
-    }
-  }
-
-  private void requestPlayPauseFocus() {
-    boolean playing = player != null && player.getPlayWhenReady();
-    if (!playing && playButton != null) {
-      playButton.requestFocus();
-    } else if (playing && pauseButton != null) {
-      pauseButton.requestFocus();
-    }
-  }
-
-  private void setButtonEnabled(boolean enabled, View view) {
-    if (view == null) {
-      return;
-    }
-    view.setEnabled(enabled);
-    view.setAlpha(enabled ? 1f : 0.3f);
-    view.setVisibility(VISIBLE);
-  }
-
-  private void previous() {
-    Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
-      return;
-    }
-    int windowIndex = player.getCurrentWindowIndex();
-    timeline.getWindow(windowIndex, window);
-    int previousWindowIndex = player.getPreviousWindowIndex();
-    if (previousWindowIndex != C.INDEX_UNSET
-        && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
-        || (window.isDynamic && !window.isSeekable))) {
-      seekTo(previousWindowIndex, C.TIME_UNSET);
-    } else {
-      seekTo(0);
-    }
-  }
-
-  private void next() {
-    Timeline timeline = player.getCurrentTimeline();
-    if (timeline.isEmpty()) {
-      return;
-    }
-    int windowIndex = player.getCurrentWindowIndex();
-    int nextWindowIndex = player.getNextWindowIndex();
-    if (nextWindowIndex != C.INDEX_UNSET) {
-      seekTo(nextWindowIndex, C.TIME_UNSET);
-    } else if (timeline.getWindow(windowIndex, window, false).isDynamic) {
-      seekTo(windowIndex, C.TIME_UNSET);
-    }
-  }
-
-  private void rewind() {
-    if (rewindMs <= 0) {
-      return;
-    }
-    seekTo(Math.max(player.getCurrentPosition() - rewindMs, 0));
-  }
-
-  private void fastForward() {
-    if (fastForwardMs <= 0) {
-      return;
-    }
-    long durationMs = player.getDuration();
-    long seekPositionMs = player.getCurrentPosition() + fastForwardMs;
-    if (durationMs != C.TIME_UNSET) {
-      seekPositionMs = Math.min(seekPositionMs, durationMs);
-    }
-    seekTo(seekPositionMs);
-  }
-
-  private void seekTo(long positionMs) {
-    seekTo(player.getCurrentWindowIndex(), positionMs);
-  }
-
-  private void seekTo(int windowIndex, long positionMs) {
-    boolean dispatched = controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
-    if (!dispatched) {
-      // The seek wasn't dispatched. If the progress bar was dragged by the user to perform the
-      // seek then it'll now be in the wrong position. Trigger a progress update to snap it back.
-      updateProgress();
-    }
-  }
-
-  private void seekToTimeBarPosition(long positionMs) {
-    int windowIndex;
-    Timeline timeline = player.getCurrentTimeline();
-    if (multiWindowTimeBar && !timeline.isEmpty()) {
-      int windowCount = timeline.getWindowCount();
-      windowIndex = 0;
-      while (true) {
-        long windowDurationMs = timeline.getWindow(windowIndex, window).getDurationMs();
-        if (positionMs < windowDurationMs) {
-          break;
-        } else if (windowIndex == windowCount - 1) {
-          // Seeking past the end of the last window should seek to the end of the timeline.
-          positionMs = windowDurationMs;
-          break;
-        }
-        positionMs -= windowDurationMs;
-        windowIndex++;
-      }
-    } else {
-      windowIndex = player.getCurrentWindowIndex();
-    }
-    seekTo(windowIndex, positionMs);
-  }
-
-  @Override
-  public void onAttachedToWindow() {
-    super.onAttachedToWindow();
-    isAttachedToWindow = true;
-    if (hideAtMs != C.TIME_UNSET) {
-      long delayMs = hideAtMs - SystemClock.uptimeMillis();
-      if (delayMs <= 0) {
-        hide();
-      } else {
-        postDelayed(hideAction, delayMs);
-      }
-    }
-    updateAll();
-  }
-
-  @Override
-  public void onDetachedFromWindow() {
-    super.onDetachedFromWindow();
-    isAttachedToWindow = false;
-    removeCallbacks(updateProgressAction);
-    removeCallbacks(hideAction);
-  }
-
-  @Override
-  public boolean dispatchKeyEvent(KeyEvent event) {
-    return dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
-  }
-
-  /**
-   * Called to process media key events. Any {@link KeyEvent} can be passed but only media key
-   * events will be handled.
-   *
-   * @param event A key event.
-   * @return Whether the key event was handled.
-   */
-  public boolean dispatchMediaKeyEvent(KeyEvent event) {
-    int keyCode = event.getKeyCode();
-    if (player == null || !isHandledMediaKey(keyCode)) {
-      return false;
-    }
-    if (event.getAction() == KeyEvent.ACTION_DOWN) {
-      if (keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD) {
-        fastForward();
-      } else if (keyCode == KeyEvent.KEYCODE_MEDIA_REWIND) {
-        rewind();
-      } else if (event.getRepeatCount() == 0) {
-        switch (keyCode) {
-          case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-            controlDispatcher.dispatchSetPlayWhenReady(player, !player.getPlayWhenReady());
-            break;
-          case KeyEvent.KEYCODE_MEDIA_PLAY:
-            controlDispatcher.dispatchSetPlayWhenReady(player, true);
-            break;
-          case KeyEvent.KEYCODE_MEDIA_PAUSE:
-            controlDispatcher.dispatchSetPlayWhenReady(player, false);
-            break;
-          case KeyEvent.KEYCODE_MEDIA_NEXT:
-            next();
-            break;
-          case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
-            previous();
-            break;
-          default:
-            break;
-        }
-      }
-    }
-    return true;
-  }
-
-  @SuppressLint("InlinedApi")
-  private static boolean isHandledMediaKey(int keyCode) {
-    return keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD
-        || keyCode == KeyEvent.KEYCODE_MEDIA_REWIND
-        || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE
-        || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY
-        || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE
-        || keyCode == KeyEvent.KEYCODE_MEDIA_NEXT
-        || keyCode == KeyEvent.KEYCODE_MEDIA_PREVIOUS;
-  }
-
-  /**
-   * Returns whether the specified {@code timeline} can be shown on a multi-window time bar.
-   *
-   * @param timeline The {@link Timeline} to check.
-   * @param window A scratch {@link Timeline.Window} instance.
-   * @return Whether the specified timeline can be shown on a multi-window time bar.
-   */
-  private static boolean canShowMultiWindowTimeBar(Timeline timeline, Timeline.Window window) {
-    if (timeline.getWindowCount() > MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR) {
-      return false;
-    }
-    int windowCount = timeline.getWindowCount();
-    for (int i = 0; i < windowCount; i++) {
-      if (timeline.getWindow(i, window).durationUs == C.TIME_UNSET) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  private final class ComponentListener extends Player.DefaultEventListener implements
-      TimeBar.OnScrubListener, OnClickListener {
-
-    @Override
-    public void onScrubStart(TimeBar timeBar, long position) {
-      removeCallbacks(hideAction);
-      scrubbing = true;
-    }
-
-    @Override
-    public void onScrubMove(TimeBar timeBar, long position) {
-      if (positionView != null) {
-        positionView.setText(Util.getStringForTime(formatBuilder, formatter, position));
-      }
-    }
-
-    @Override
-    public void onScrubStop(TimeBar timeBar, long position, boolean canceled) {
-      scrubbing = false;
-      if (!canceled && player != null) {
-        seekToTimeBarPosition(position);
-      }
-      hideAfterTimeout();
-    }
-
-    @Override
-    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      updatePlayPauseButton();
-      updateProgress();
-    }
-
-    @Override
-    public void onRepeatModeChanged(int repeatMode) {
-      updateRepeatModeButton();
-      updateNavigation();
-    }
-
-    @Override
-    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
-      updateShuffleButton();
-      updateNavigation();
-    }
-
-    @Override
-    public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
-      updateNavigation();
-      updateProgress();
-    }
-
-    @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest) {
-      updateNavigation();
-      updateTimeBarMode();
-      updateProgress();
-    }
-
-    @Override
-    public void onClick(View view) {
-      if (player != null) {
-        if (nextButton == view) {
-          next();
-        } else if (previousButton == view) {
-          previous();
-        } else if (fastForwardButton == view) {
-          fastForward();
-        } else if (rewindButton == view) {
-          rewind();
-        } else if (playButton == view) {
-          controlDispatcher.dispatchSetPlayWhenReady(player, true);
-        } else if (pauseButton == view) {
-          controlDispatcher.dispatchSetPlayWhenReady(player, false);
-        } else if (repeatToggleButton == view) {
-          controlDispatcher.dispatchSetRepeatMode(player, RepeatModeUtil.getNextRepeatMode(
-              player.getRepeatMode(), repeatToggleModes));
-        } else if (shuffleButton == view) {
-          controlDispatcher.dispatchSetShuffleModeEnabled(player, !player.getShuffleModeEnabled());
-        }
-      }
-      hideAfterTimeout();
-    }
-
+  public PlaybackControlView(
+      Context context, AttributeSet attrs, int defStyleAttr, AttributeSet playbackAttrs) {
+    super(context, attrs, defStyleAttr, playbackAttrs);
   }
 
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
new file mode 100644
index 0000000000..63c791d166
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerControlView.java
@@ -0,0 +1,1129 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.os.SystemClock;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.TextView;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
+import com.google.android.exoplayer2.PlaybackPreparer;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.RepeatModeUtil;
+import com.google.android.exoplayer2.util.Util;
+import java.util.Arrays;
+import java.util.Formatter;
+import java.util.Locale;
+
+/**
+ * A view for controlling {@link Player} instances.
+ *
+ * <p>A PlayerControlView can be customized by setting attributes (or calling corresponding
+ * methods), overriding the view's layout file or by specifying a custom view layout file, as
+ * outlined below.
+ *
+ * <h3>Attributes</h3>
+ *
+ * The following attributes can be set on a PlayerControlView when used in a layout XML file:
+ *
+ * <ul>
+ *   <li><b>{@code show_timeout}</b> - The time between the last user interaction and the controls
+ *       being automatically hidden, in milliseconds. Use zero if the controls should not
+ *       automatically timeout.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setShowTimeoutMs(int)}
+ *         <li>Default: {@link #DEFAULT_SHOW_TIMEOUT_MS}
+ *       </ul>
+ *   <li><b>{@code rewind_increment}</b> - The duration of the rewind applied when the user taps the
+ *       rewind button, in milliseconds. Use zero to disable the rewind button.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setRewindIncrementMs(int)}
+ *         <li>Default: {@link #DEFAULT_REWIND_MS}
+ *       </ul>
+ *   <li><b>{@code fastforward_increment}</b> - Like {@code rewind_increment}, but for fast forward.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setFastForwardIncrementMs(int)}
+ *         <li>Default: {@link #DEFAULT_FAST_FORWARD_MS}
+ *       </ul>
+ *   <li><b>{@code repeat_toggle_modes}</b> - A flagged enumeration value specifying which repeat
+ *       mode toggle options are enabled. Valid values are: {@code none}, {@code one}, {@code all},
+ *       or {@code one|all}.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setRepeatToggleModes(int)}
+ *         <li>Default: {@link PlayerControlView#DEFAULT_REPEAT_TOGGLE_MODES}
+ *       </ul>
+ *   <li><b>{@code show_shuffle_button}</b> - Whether the shuffle button is shown.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setShowShuffleButton(boolean)}
+ *         <li>Default: false
+ *       </ul>
+ *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout to be inflated. See
+ *       below for more details.
+ *       <ul>
+ *         <li>Corresponding method: None
+ *         <li>Default: {@code R.id.exo_player_control_view}
+ *       </ul>
+ * </ul>
+ *
+ * <h3>Overriding the layout file</h3>
+ *
+ * To customize the layout of PlayerControlView throughout your app, or just for certain
+ * configurations, you can define {@code exo_player_control_view.xml} layout files in your
+ * application {@code res/layout*} directories. These layouts will override the one provided by the
+ * ExoPlayer library, and will be inflated for use by PlayerControlView. The view identifies and
+ * binds its children by looking for the following ids:
+ *
+ * <p>
+ *
+ * <ul>
+ *   <li><b>{@code exo_play}</b> - The play button.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_pause}</b> - The pause button.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_ffwd}</b> - The fast forward button.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_rew}</b> - The rewind button.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_prev}</b> - The previous track button.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_next}</b> - The next track button.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_repeat_toggle}</b> - The repeat toggle button.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_shuffle}</b> - The shuffle button.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_position}</b> - Text view displaying the current playback position.
+ *       <ul>
+ *         <li>Type: {@link TextView}
+ *       </ul>
+ *   <li><b>{@code exo_duration}</b> - Text view displaying the current media duration.
+ *       <ul>
+ *         <li>Type: {@link TextView}
+ *       </ul>
+ *   <li><b>{@code exo_progress}</b> - Time bar that's updated during playback and allows seeking.
+ *       <ul>
+ *         <li>Type: {@link TimeBar}
+ *       </ul>
+ * </ul>
+ *
+ * <p>All child views are optional and so can be omitted if not required, however where defined they
+ * must be of the expected type.
+ *
+ * <h3>Specifying a custom layout file</h3>
+ *
+ * Defining your own {@code exo_player_control_view.xml} is useful to customize the layout of
+ * PlayerControlView throughout your application. It's also possible to customize the layout for a
+ * single instance in a layout file. This is achieved by setting the {@code controller_layout_id}
+ * attribute on a PlayerControlView. This will cause the specified layout to be inflated instead of
+ * {@code exo_player_control_view.xml} for only the instance on which the attribute is set.
+ */
+public class PlayerControlView extends FrameLayout {
+
+  static {
+    ExoPlayerLibraryInfo.registerModule("goog.exo.ui");
+  }
+
+  /** Listener to be notified about changes of the visibility of the UI control. */
+  public interface VisibilityListener {
+
+    /**
+     * Called when the visibility changes.
+     *
+     * @param visibility The new visibility. Either {@link View#VISIBLE} or {@link View#GONE}.
+     */
+    void onVisibilityChange(int visibility);
+  }
+
+  /** The default fast forward increment, in milliseconds. */
+  public static final int DEFAULT_FAST_FORWARD_MS = 15000;
+  /** The default rewind increment, in milliseconds. */
+  public static final int DEFAULT_REWIND_MS = 5000;
+  /** The default show timeout, in milliseconds. */
+  public static final int DEFAULT_SHOW_TIMEOUT_MS = 5000;
+  /** The default repeat toggle modes. */
+  public static final @RepeatModeUtil.RepeatToggleModes int DEFAULT_REPEAT_TOGGLE_MODES =
+      RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE;
+
+  /** The maximum number of windows that can be shown in a multi-window time bar. */
+  public static final int MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR = 100;
+
+  private static final long MAX_POSITION_FOR_SEEK_TO_PREVIOUS = 3000;
+
+  private final ComponentListener componentListener;
+  private final View previousButton;
+  private final View nextButton;
+  private final View playButton;
+  private final View pauseButton;
+  private final View fastForwardButton;
+  private final View rewindButton;
+  private final ImageView repeatToggleButton;
+  private final View shuffleButton;
+  private final TextView durationView;
+  private final TextView positionView;
+  private final TimeBar timeBar;
+  private final StringBuilder formatBuilder;
+  private final Formatter formatter;
+  private final Timeline.Period period;
+  private final Timeline.Window window;
+
+  private final Drawable repeatOffButtonDrawable;
+  private final Drawable repeatOneButtonDrawable;
+  private final Drawable repeatAllButtonDrawable;
+  private final String repeatOffButtonContentDescription;
+  private final String repeatOneButtonContentDescription;
+  private final String repeatAllButtonContentDescription;
+
+  private Player player;
+  private com.google.android.exoplayer2.ControlDispatcher controlDispatcher;
+  private VisibilityListener visibilityListener;
+  private @Nullable PlaybackPreparer playbackPreparer;
+
+  private boolean isAttachedToWindow;
+  private boolean showMultiWindowTimeBar;
+  private boolean multiWindowTimeBar;
+  private boolean scrubbing;
+  private int rewindMs;
+  private int fastForwardMs;
+  private int showTimeoutMs;
+  private @RepeatModeUtil.RepeatToggleModes int repeatToggleModes;
+  private boolean showShuffleButton;
+  private long hideAtMs;
+  private long[] adGroupTimesMs;
+  private boolean[] playedAdGroups;
+  private long[] extraAdGroupTimesMs;
+  private boolean[] extraPlayedAdGroups;
+
+  private final Runnable updateProgressAction =
+      new Runnable() {
+        @Override
+        public void run() {
+          updateProgress();
+        }
+      };
+
+  private final Runnable hideAction =
+      new Runnable() {
+        @Override
+        public void run() {
+          hide();
+        }
+      };
+
+  public PlayerControlView(Context context) {
+    this(context, null);
+  }
+
+  public PlayerControlView(Context context, AttributeSet attrs) {
+    this(context, attrs, 0);
+  }
+
+  public PlayerControlView(Context context, AttributeSet attrs, int defStyleAttr) {
+    this(context, attrs, defStyleAttr, attrs);
+  }
+
+  public PlayerControlView(
+      Context context, AttributeSet attrs, int defStyleAttr, AttributeSet playbackAttrs) {
+    super(context, attrs, defStyleAttr);
+    int controllerLayoutId = R.layout.exo_player_control_view;
+    rewindMs = DEFAULT_REWIND_MS;
+    fastForwardMs = DEFAULT_FAST_FORWARD_MS;
+    showTimeoutMs = DEFAULT_SHOW_TIMEOUT_MS;
+    repeatToggleModes = DEFAULT_REPEAT_TOGGLE_MODES;
+    hideAtMs = C.TIME_UNSET;
+    showShuffleButton = false;
+    if (playbackAttrs != null) {
+      TypedArray a =
+          context
+              .getTheme()
+              .obtainStyledAttributes(playbackAttrs, R.styleable.PlayerControlView, 0, 0);
+      try {
+        rewindMs = a.getInt(R.styleable.PlayerControlView_rewind_increment, rewindMs);
+        fastForwardMs =
+            a.getInt(R.styleable.PlayerControlView_fastforward_increment, fastForwardMs);
+        showTimeoutMs = a.getInt(R.styleable.PlayerControlView_show_timeout, showTimeoutMs);
+        controllerLayoutId =
+            a.getResourceId(R.styleable.PlayerControlView_controller_layout_id, controllerLayoutId);
+        repeatToggleModes = getRepeatToggleModes(a, repeatToggleModes);
+        showShuffleButton =
+            a.getBoolean(R.styleable.PlayerControlView_show_shuffle_button, showShuffleButton);
+      } finally {
+        a.recycle();
+      }
+    }
+    period = new Timeline.Period();
+    window = new Timeline.Window();
+    formatBuilder = new StringBuilder();
+    formatter = new Formatter(formatBuilder, Locale.getDefault());
+    adGroupTimesMs = new long[0];
+    playedAdGroups = new boolean[0];
+    extraAdGroupTimesMs = new long[0];
+    extraPlayedAdGroups = new boolean[0];
+    componentListener = new ComponentListener();
+    controlDispatcher = new com.google.android.exoplayer2.DefaultControlDispatcher();
+
+    LayoutInflater.from(context).inflate(controllerLayoutId, this);
+    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
+
+    durationView = findViewById(R.id.exo_duration);
+    positionView = findViewById(R.id.exo_position);
+    timeBar = findViewById(R.id.exo_progress);
+    if (timeBar != null) {
+      timeBar.addListener(componentListener);
+    }
+    playButton = findViewById(R.id.exo_play);
+    if (playButton != null) {
+      playButton.setOnClickListener(componentListener);
+    }
+    pauseButton = findViewById(R.id.exo_pause);
+    if (pauseButton != null) {
+      pauseButton.setOnClickListener(componentListener);
+    }
+    previousButton = findViewById(R.id.exo_prev);
+    if (previousButton != null) {
+      previousButton.setOnClickListener(componentListener);
+    }
+    nextButton = findViewById(R.id.exo_next);
+    if (nextButton != null) {
+      nextButton.setOnClickListener(componentListener);
+    }
+    rewindButton = findViewById(R.id.exo_rew);
+    if (rewindButton != null) {
+      rewindButton.setOnClickListener(componentListener);
+    }
+    fastForwardButton = findViewById(R.id.exo_ffwd);
+    if (fastForwardButton != null) {
+      fastForwardButton.setOnClickListener(componentListener);
+    }
+    repeatToggleButton = findViewById(R.id.exo_repeat_toggle);
+    if (repeatToggleButton != null) {
+      repeatToggleButton.setOnClickListener(componentListener);
+    }
+    shuffleButton = findViewById(R.id.exo_shuffle);
+    if (shuffleButton != null) {
+      shuffleButton.setOnClickListener(componentListener);
+    }
+    Resources resources = context.getResources();
+    repeatOffButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_off);
+    repeatOneButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_one);
+    repeatAllButtonDrawable = resources.getDrawable(R.drawable.exo_controls_repeat_all);
+    repeatOffButtonContentDescription =
+        resources.getString(R.string.exo_controls_repeat_off_description);
+    repeatOneButtonContentDescription =
+        resources.getString(R.string.exo_controls_repeat_one_description);
+    repeatAllButtonContentDescription =
+        resources.getString(R.string.exo_controls_repeat_all_description);
+  }
+
+  @SuppressWarnings("ResourceType")
+  private static @RepeatModeUtil.RepeatToggleModes int getRepeatToggleModes(
+      TypedArray a, @RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
+    return a.getInt(R.styleable.PlayerControlView_repeat_toggle_modes, repeatToggleModes);
+  }
+
+  /**
+   * Returns the {@link Player} currently being controlled by this view, or null if no player is
+   * set.
+   */
+  public Player getPlayer() {
+    return player;
+  }
+
+  /**
+   * Sets the {@link Player} to control.
+   *
+   * @param player The {@link Player} to control.
+   */
+  public void setPlayer(Player player) {
+    if (this.player == player) {
+      return;
+    }
+    if (this.player != null) {
+      this.player.removeListener(componentListener);
+    }
+    this.player = player;
+    if (player != null) {
+      player.addListener(componentListener);
+    }
+    updateAll();
+  }
+
+  /**
+   * Sets whether the time bar should show all windows, as opposed to just the current one. If the
+   * timeline has a period with unknown duration or more than {@link
+   * #MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR} windows the time bar will fall back to showing a single
+   * window.
+   *
+   * @param showMultiWindowTimeBar Whether the time bar should show all windows.
+   */
+  public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {
+    this.showMultiWindowTimeBar = showMultiWindowTimeBar;
+    updateTimeBarMode();
+  }
+
+  /**
+   * Sets the millisecond positions of extra ad markers relative to the start of the window (or
+   * timeline, if in multi-window mode) and whether each extra ad has been played or not. The
+   * markers are shown in addition to any ad markers for ads in the player's timeline.
+   *
+   * @param extraAdGroupTimesMs The millisecond timestamps of the extra ad markers to show, or
+   *     {@code null} to show no extra ad markers.
+   * @param extraPlayedAdGroups Whether each ad has been played, or {@code null} to show no extra ad
+   *     markers.
+   */
+  public void setExtraAdGroupMarkers(
+      @Nullable long[] extraAdGroupTimesMs, @Nullable boolean[] extraPlayedAdGroups) {
+    if (extraAdGroupTimesMs == null) {
+      this.extraAdGroupTimesMs = new long[0];
+      this.extraPlayedAdGroups = new boolean[0];
+    } else {
+      Assertions.checkArgument(extraAdGroupTimesMs.length == extraPlayedAdGroups.length);
+      this.extraAdGroupTimesMs = extraAdGroupTimesMs;
+      this.extraPlayedAdGroups = extraPlayedAdGroups;
+    }
+    updateProgress();
+  }
+
+  /**
+   * Sets the {@link VisibilityListener}.
+   *
+   * @param listener The listener to be notified about visibility changes.
+   */
+  public void setVisibilityListener(VisibilityListener listener) {
+    this.visibilityListener = listener;
+  }
+
+  /**
+   * Sets the {@link PlaybackPreparer}.
+   *
+   * @param playbackPreparer The {@link PlaybackPreparer}.
+   */
+  public void setPlaybackPreparer(@Nullable PlaybackPreparer playbackPreparer) {
+    this.playbackPreparer = playbackPreparer;
+  }
+
+  /**
+   * Sets the {@link com.google.android.exoplayer2.ControlDispatcher}.
+   *
+   * @param controlDispatcher The {@link com.google.android.exoplayer2.ControlDispatcher}, or null
+   *     to use {@link com.google.android.exoplayer2.DefaultControlDispatcher}.
+   */
+  public void setControlDispatcher(
+      @Nullable com.google.android.exoplayer2.ControlDispatcher controlDispatcher) {
+    this.controlDispatcher =
+        controlDispatcher == null
+            ? new com.google.android.exoplayer2.DefaultControlDispatcher()
+            : controlDispatcher;
+  }
+
+  /**
+   * Sets the rewind increment in milliseconds.
+   *
+   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
+   *     rewind button to be disabled.
+   */
+  public void setRewindIncrementMs(int rewindMs) {
+    this.rewindMs = rewindMs;
+    updateNavigation();
+  }
+
+  /**
+   * Sets the fast forward increment in milliseconds.
+   *
+   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
+   *     cause the fast forward button to be disabled.
+   */
+  public void setFastForwardIncrementMs(int fastForwardMs) {
+    this.fastForwardMs = fastForwardMs;
+    updateNavigation();
+  }
+
+  /**
+   * Returns the playback controls timeout. The playback controls are automatically hidden after
+   * this duration of time has elapsed without user input.
+   *
+   * @return The duration in milliseconds. A non-positive value indicates that the controls will
+   *     remain visible indefinitely.
+   */
+  public int getShowTimeoutMs() {
+    return showTimeoutMs;
+  }
+
+  /**
+   * Sets the playback controls timeout. The playback controls are automatically hidden after this
+   * duration of time has elapsed without user input.
+   *
+   * @param showTimeoutMs The duration in milliseconds. A non-positive value will cause the controls
+   *     to remain visible indefinitely.
+   */
+  public void setShowTimeoutMs(int showTimeoutMs) {
+    this.showTimeoutMs = showTimeoutMs;
+    if (isVisible()) {
+      // Reset the timeout.
+      hideAfterTimeout();
+    }
+  }
+
+  /**
+   * Returns which repeat toggle modes are enabled.
+   *
+   * @return The currently enabled {@link RepeatModeUtil.RepeatToggleModes}.
+   */
+  public @RepeatModeUtil.RepeatToggleModes int getRepeatToggleModes() {
+    return repeatToggleModes;
+  }
+
+  /**
+   * Sets which repeat toggle modes are enabled.
+   *
+   * @param repeatToggleModes A set of {@link RepeatModeUtil.RepeatToggleModes}.
+   */
+  public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
+    this.repeatToggleModes = repeatToggleModes;
+    if (player != null) {
+      @Player.RepeatMode int currentMode = player.getRepeatMode();
+      if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE
+          && currentMode != Player.REPEAT_MODE_OFF) {
+        controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_OFF);
+      } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ONE
+          && currentMode == Player.REPEAT_MODE_ALL) {
+        controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_ONE);
+      } else if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_ALL
+          && currentMode == Player.REPEAT_MODE_ONE) {
+        controlDispatcher.dispatchSetRepeatMode(player, Player.REPEAT_MODE_ALL);
+      }
+    }
+  }
+
+  /** Returns whether the shuffle button is shown. */
+  public boolean getShowShuffleButton() {
+    return showShuffleButton;
+  }
+
+  /**
+   * Sets whether the shuffle button is shown.
+   *
+   * @param showShuffleButton Whether the shuffle button is shown.
+   */
+  public void setShowShuffleButton(boolean showShuffleButton) {
+    this.showShuffleButton = showShuffleButton;
+    updateShuffleButton();
+  }
+
+  /**
+   * Shows the playback controls. If {@link #getShowTimeoutMs()} is positive then the controls will
+   * be automatically hidden after this duration of time has elapsed without user input.
+   */
+  public void show() {
+    if (!isVisible()) {
+      setVisibility(VISIBLE);
+      if (visibilityListener != null) {
+        visibilityListener.onVisibilityChange(getVisibility());
+      }
+      updateAll();
+      requestPlayPauseFocus();
+    }
+    // Call hideAfterTimeout even if already visible to reset the timeout.
+    hideAfterTimeout();
+  }
+
+  /** Hides the controller. */
+  public void hide() {
+    if (isVisible()) {
+      setVisibility(GONE);
+      if (visibilityListener != null) {
+        visibilityListener.onVisibilityChange(getVisibility());
+      }
+      removeCallbacks(updateProgressAction);
+      removeCallbacks(hideAction);
+      hideAtMs = C.TIME_UNSET;
+    }
+  }
+
+  /** Returns whether the controller is currently visible. */
+  public boolean isVisible() {
+    return getVisibility() == VISIBLE;
+  }
+
+  private void hideAfterTimeout() {
+    removeCallbacks(hideAction);
+    if (showTimeoutMs > 0) {
+      hideAtMs = SystemClock.uptimeMillis() + showTimeoutMs;
+      if (isAttachedToWindow) {
+        postDelayed(hideAction, showTimeoutMs);
+      }
+    } else {
+      hideAtMs = C.TIME_UNSET;
+    }
+  }
+
+  private void updateAll() {
+    updatePlayPauseButton();
+    updateNavigation();
+    updateRepeatModeButton();
+    updateShuffleButton();
+    updateProgress();
+  }
+
+  private void updatePlayPauseButton() {
+    if (!isVisible() || !isAttachedToWindow) {
+      return;
+    }
+    boolean requestPlayPauseFocus = false;
+    boolean playing = isPlaying();
+    if (playButton != null) {
+      requestPlayPauseFocus |= playing && playButton.isFocused();
+      playButton.setVisibility(playing ? View.GONE : View.VISIBLE);
+    }
+    if (pauseButton != null) {
+      requestPlayPauseFocus |= !playing && pauseButton.isFocused();
+      pauseButton.setVisibility(!playing ? View.GONE : View.VISIBLE);
+    }
+    if (requestPlayPauseFocus) {
+      requestPlayPauseFocus();
+    }
+  }
+
+  private void updateNavigation() {
+    if (!isVisible() || !isAttachedToWindow) {
+      return;
+    }
+    Timeline timeline = player != null ? player.getCurrentTimeline() : null;
+    boolean haveNonEmptyTimeline = timeline != null && !timeline.isEmpty();
+    boolean isSeekable = false;
+    boolean enablePrevious = false;
+    boolean enableNext = false;
+    if (haveNonEmptyTimeline && !player.isPlayingAd()) {
+      int windowIndex = player.getCurrentWindowIndex();
+      timeline.getWindow(windowIndex, window);
+      isSeekable = window.isSeekable;
+      enablePrevious =
+          isSeekable || !window.isDynamic || player.getPreviousWindowIndex() != C.INDEX_UNSET;
+      enableNext = window.isDynamic || player.getNextWindowIndex() != C.INDEX_UNSET;
+    }
+    setButtonEnabled(enablePrevious, previousButton);
+    setButtonEnabled(enableNext, nextButton);
+    setButtonEnabled(fastForwardMs > 0 && isSeekable, fastForwardButton);
+    setButtonEnabled(rewindMs > 0 && isSeekable, rewindButton);
+    if (timeBar != null) {
+      timeBar.setEnabled(isSeekable);
+    }
+  }
+
+  private void updateRepeatModeButton() {
+    if (!isVisible() || !isAttachedToWindow || repeatToggleButton == null) {
+      return;
+    }
+    if (repeatToggleModes == RepeatModeUtil.REPEAT_TOGGLE_MODE_NONE) {
+      repeatToggleButton.setVisibility(View.GONE);
+      return;
+    }
+    if (player == null) {
+      setButtonEnabled(false, repeatToggleButton);
+      return;
+    }
+    setButtonEnabled(true, repeatToggleButton);
+    switch (player.getRepeatMode()) {
+      case Player.REPEAT_MODE_OFF:
+        repeatToggleButton.setImageDrawable(repeatOffButtonDrawable);
+        repeatToggleButton.setContentDescription(repeatOffButtonContentDescription);
+        break;
+      case Player.REPEAT_MODE_ONE:
+        repeatToggleButton.setImageDrawable(repeatOneButtonDrawable);
+        repeatToggleButton.setContentDescription(repeatOneButtonContentDescription);
+        break;
+      case Player.REPEAT_MODE_ALL:
+        repeatToggleButton.setImageDrawable(repeatAllButtonDrawable);
+        repeatToggleButton.setContentDescription(repeatAllButtonContentDescription);
+        break;
+      default:
+        // Never happens.
+    }
+    repeatToggleButton.setVisibility(View.VISIBLE);
+  }
+
+  private void updateShuffleButton() {
+    if (!isVisible() || !isAttachedToWindow || shuffleButton == null) {
+      return;
+    }
+    if (!showShuffleButton) {
+      shuffleButton.setVisibility(View.GONE);
+    } else if (player == null) {
+      setButtonEnabled(false, shuffleButton);
+    } else {
+      shuffleButton.setAlpha(player.getShuffleModeEnabled() ? 1f : 0.3f);
+      shuffleButton.setEnabled(true);
+      shuffleButton.setVisibility(View.VISIBLE);
+    }
+  }
+
+  private void updateTimeBarMode() {
+    if (player == null) {
+      return;
+    }
+    multiWindowTimeBar =
+        showMultiWindowTimeBar && canShowMultiWindowTimeBar(player.getCurrentTimeline(), window);
+  }
+
+  private void updateProgress() {
+    if (!isVisible() || !isAttachedToWindow) {
+      return;
+    }
+
+    long position = 0;
+    long bufferedPosition = 0;
+    long duration = 0;
+    if (player != null) {
+      long currentWindowTimeBarOffsetUs = 0;
+      long durationUs = 0;
+      int adGroupCount = 0;
+      Timeline timeline = player.getCurrentTimeline();
+      if (!timeline.isEmpty()) {
+        int currentWindowIndex = player.getCurrentWindowIndex();
+        int firstWindowIndex = multiWindowTimeBar ? 0 : currentWindowIndex;
+        int lastWindowIndex =
+            multiWindowTimeBar ? timeline.getWindowCount() - 1 : currentWindowIndex;
+        for (int i = firstWindowIndex; i <= lastWindowIndex; i++) {
+          if (i == currentWindowIndex) {
+            currentWindowTimeBarOffsetUs = durationUs;
+          }
+          timeline.getWindow(i, window);
+          if (window.durationUs == C.TIME_UNSET) {
+            Assertions.checkState(!multiWindowTimeBar);
+            break;
+          }
+          for (int j = window.firstPeriodIndex; j <= window.lastPeriodIndex; j++) {
+            timeline.getPeriod(j, period);
+            int periodAdGroupCount = period.getAdGroupCount();
+            for (int adGroupIndex = 0; adGroupIndex < periodAdGroupCount; adGroupIndex++) {
+              long adGroupTimeInPeriodUs = period.getAdGroupTimeUs(adGroupIndex);
+              if (adGroupTimeInPeriodUs == C.TIME_END_OF_SOURCE) {
+                if (period.durationUs == C.TIME_UNSET) {
+                  // Don't show ad markers for postrolls in periods with unknown duration.
+                  continue;
+                }
+                adGroupTimeInPeriodUs = period.durationUs;
+              }
+              long adGroupTimeInWindowUs = adGroupTimeInPeriodUs + period.getPositionInWindowUs();
+              if (adGroupTimeInWindowUs >= 0 && adGroupTimeInWindowUs <= window.durationUs) {
+                if (adGroupCount == adGroupTimesMs.length) {
+                  int newLength = adGroupTimesMs.length == 0 ? 1 : adGroupTimesMs.length * 2;
+                  adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, newLength);
+                  playedAdGroups = Arrays.copyOf(playedAdGroups, newLength);
+                }
+                adGroupTimesMs[adGroupCount] = C.usToMs(durationUs + adGroupTimeInWindowUs);
+                playedAdGroups[adGroupCount] = period.hasPlayedAdGroup(adGroupIndex);
+                adGroupCount++;
+              }
+            }
+          }
+          durationUs += window.durationUs;
+        }
+      }
+      duration = C.usToMs(durationUs);
+      position = C.usToMs(currentWindowTimeBarOffsetUs);
+      bufferedPosition = position;
+      if (player.isPlayingAd()) {
+        position += player.getContentPosition();
+        bufferedPosition = position;
+      } else {
+        position += player.getCurrentPosition();
+        bufferedPosition += player.getBufferedPosition();
+      }
+      if (timeBar != null) {
+        int extraAdGroupCount = extraAdGroupTimesMs.length;
+        int totalAdGroupCount = adGroupCount + extraAdGroupCount;
+        if (totalAdGroupCount > adGroupTimesMs.length) {
+          adGroupTimesMs = Arrays.copyOf(adGroupTimesMs, totalAdGroupCount);
+          playedAdGroups = Arrays.copyOf(playedAdGroups, totalAdGroupCount);
+        }
+        System.arraycopy(extraAdGroupTimesMs, 0, adGroupTimesMs, adGroupCount, extraAdGroupCount);
+        System.arraycopy(extraPlayedAdGroups, 0, playedAdGroups, adGroupCount, extraAdGroupCount);
+        timeBar.setAdGroupTimesMs(adGroupTimesMs, playedAdGroups, totalAdGroupCount);
+      }
+    }
+    if (durationView != null) {
+      durationView.setText(Util.getStringForTime(formatBuilder, formatter, duration));
+    }
+    if (positionView != null && !scrubbing) {
+      positionView.setText(Util.getStringForTime(formatBuilder, formatter, position));
+    }
+    if (timeBar != null) {
+      timeBar.setPosition(position);
+      timeBar.setBufferedPosition(bufferedPosition);
+      timeBar.setDuration(duration);
+    }
+
+    // Cancel any pending updates and schedule a new one if necessary.
+    removeCallbacks(updateProgressAction);
+    int playbackState = player == null ? Player.STATE_IDLE : player.getPlaybackState();
+    if (playbackState != Player.STATE_IDLE && playbackState != Player.STATE_ENDED) {
+      long delayMs;
+      if (player.getPlayWhenReady() && playbackState == Player.STATE_READY) {
+        float playbackSpeed = player.getPlaybackParameters().speed;
+        if (playbackSpeed <= 0.1f) {
+          delayMs = 1000;
+        } else if (playbackSpeed <= 5f) {
+          long mediaTimeUpdatePeriodMs = 1000 / Math.max(1, Math.round(1 / playbackSpeed));
+          long mediaTimeDelayMs = mediaTimeUpdatePeriodMs - (position % mediaTimeUpdatePeriodMs);
+          if (mediaTimeDelayMs < (mediaTimeUpdatePeriodMs / 5)) {
+            mediaTimeDelayMs += mediaTimeUpdatePeriodMs;
+          }
+          delayMs =
+              playbackSpeed == 1 ? mediaTimeDelayMs : (long) (mediaTimeDelayMs / playbackSpeed);
+        } else {
+          delayMs = 200;
+        }
+      } else {
+        delayMs = 1000;
+      }
+      postDelayed(updateProgressAction, delayMs);
+    }
+  }
+
+  private void requestPlayPauseFocus() {
+    boolean playing = isPlaying();
+    if (!playing && playButton != null) {
+      playButton.requestFocus();
+    } else if (playing && pauseButton != null) {
+      pauseButton.requestFocus();
+    }
+  }
+
+  private void setButtonEnabled(boolean enabled, View view) {
+    if (view == null) {
+      return;
+    }
+    view.setEnabled(enabled);
+    view.setAlpha(enabled ? 1f : 0.3f);
+    view.setVisibility(VISIBLE);
+  }
+
+  private void previous() {
+    Timeline timeline = player.getCurrentTimeline();
+    if (timeline.isEmpty()) {
+      return;
+    }
+    int windowIndex = player.getCurrentWindowIndex();
+    timeline.getWindow(windowIndex, window);
+    int previousWindowIndex = player.getPreviousWindowIndex();
+    if (previousWindowIndex != C.INDEX_UNSET
+        && (player.getCurrentPosition() <= MAX_POSITION_FOR_SEEK_TO_PREVIOUS
+            || (window.isDynamic && !window.isSeekable))) {
+      seekTo(previousWindowIndex, C.TIME_UNSET);
+    } else {
+      seekTo(0);
+    }
+  }
+
+  private void next() {
+    Timeline timeline = player.getCurrentTimeline();
+    if (timeline.isEmpty()) {
+      return;
+    }
+    int windowIndex = player.getCurrentWindowIndex();
+    int nextWindowIndex = player.getNextWindowIndex();
+    if (nextWindowIndex != C.INDEX_UNSET) {
+      seekTo(nextWindowIndex, C.TIME_UNSET);
+    } else if (timeline.getWindow(windowIndex, window, false).isDynamic) {
+      seekTo(windowIndex, C.TIME_UNSET);
+    }
+  }
+
+  private void rewind() {
+    if (rewindMs <= 0) {
+      return;
+    }
+    seekTo(Math.max(player.getCurrentPosition() - rewindMs, 0));
+  }
+
+  private void fastForward() {
+    if (fastForwardMs <= 0) {
+      return;
+    }
+    long durationMs = player.getDuration();
+    long seekPositionMs = player.getCurrentPosition() + fastForwardMs;
+    if (durationMs != C.TIME_UNSET) {
+      seekPositionMs = Math.min(seekPositionMs, durationMs);
+    }
+    seekTo(seekPositionMs);
+  }
+
+  private void seekTo(long positionMs) {
+    seekTo(player.getCurrentWindowIndex(), positionMs);
+  }
+
+  private void seekTo(int windowIndex, long positionMs) {
+    boolean dispatched = controlDispatcher.dispatchSeekTo(player, windowIndex, positionMs);
+    if (!dispatched) {
+      // The seek wasn't dispatched. If the progress bar was dragged by the user to perform the
+      // seek then it'll now be in the wrong position. Trigger a progress update to snap it back.
+      updateProgress();
+    }
+  }
+
+  private void seekToTimeBarPosition(long positionMs) {
+    int windowIndex;
+    Timeline timeline = player.getCurrentTimeline();
+    if (multiWindowTimeBar && !timeline.isEmpty()) {
+      int windowCount = timeline.getWindowCount();
+      windowIndex = 0;
+      while (true) {
+        long windowDurationMs = timeline.getWindow(windowIndex, window).getDurationMs();
+        if (positionMs < windowDurationMs) {
+          break;
+        } else if (windowIndex == windowCount - 1) {
+          // Seeking past the end of the last window should seek to the end of the timeline.
+          positionMs = windowDurationMs;
+          break;
+        }
+        positionMs -= windowDurationMs;
+        windowIndex++;
+      }
+    } else {
+      windowIndex = player.getCurrentWindowIndex();
+    }
+    seekTo(windowIndex, positionMs);
+  }
+
+  @Override
+  public void onAttachedToWindow() {
+    super.onAttachedToWindow();
+    isAttachedToWindow = true;
+    if (hideAtMs != C.TIME_UNSET) {
+      long delayMs = hideAtMs - SystemClock.uptimeMillis();
+      if (delayMs <= 0) {
+        hide();
+      } else {
+        postDelayed(hideAction, delayMs);
+      }
+    } else if (isVisible()) {
+      hideAfterTimeout();
+    }
+    updateAll();
+  }
+
+  @Override
+  public void onDetachedFromWindow() {
+    super.onDetachedFromWindow();
+    isAttachedToWindow = false;
+    removeCallbacks(updateProgressAction);
+    removeCallbacks(hideAction);
+  }
+
+  @Override
+  public boolean dispatchKeyEvent(KeyEvent event) {
+    return dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
+  }
+
+  /**
+   * Called to process media key events. Any {@link KeyEvent} can be passed but only media key
+   * events will be handled.
+   *
+   * @param event A key event.
+   * @return Whether the key event was handled.
+   */
+  public boolean dispatchMediaKeyEvent(KeyEvent event) {
+    int keyCode = event.getKeyCode();
+    if (player == null || !isHandledMediaKey(keyCode)) {
+      return false;
+    }
+    if (event.getAction() == KeyEvent.ACTION_DOWN) {
+      if (keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD) {
+        fastForward();
+      } else if (keyCode == KeyEvent.KEYCODE_MEDIA_REWIND) {
+        rewind();
+      } else if (event.getRepeatCount() == 0) {
+        switch (keyCode) {
+          case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+            controlDispatcher.dispatchSetPlayWhenReady(player, !player.getPlayWhenReady());
+            break;
+          case KeyEvent.KEYCODE_MEDIA_PLAY:
+            controlDispatcher.dispatchSetPlayWhenReady(player, true);
+            break;
+          case KeyEvent.KEYCODE_MEDIA_PAUSE:
+            controlDispatcher.dispatchSetPlayWhenReady(player, false);
+            break;
+          case KeyEvent.KEYCODE_MEDIA_NEXT:
+            next();
+            break;
+          case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+            previous();
+            break;
+          default:
+            break;
+        }
+      }
+    }
+    return true;
+  }
+
+  private boolean isPlaying() {
+    return player != null
+        && player.getPlaybackState() != Player.STATE_ENDED
+        && player.getPlaybackState() != Player.STATE_IDLE
+        && player.getPlayWhenReady();
+  }
+
+  @SuppressLint("InlinedApi")
+  private static boolean isHandledMediaKey(int keyCode) {
+    return keyCode == KeyEvent.KEYCODE_MEDIA_FAST_FORWARD
+        || keyCode == KeyEvent.KEYCODE_MEDIA_REWIND
+        || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE
+        || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY
+        || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE
+        || keyCode == KeyEvent.KEYCODE_MEDIA_NEXT
+        || keyCode == KeyEvent.KEYCODE_MEDIA_PREVIOUS;
+  }
+
+  /**
+   * Returns whether the specified {@code timeline} can be shown on a multi-window time bar.
+   *
+   * @param timeline The {@link Timeline} to check.
+   * @param window A scratch {@link Timeline.Window} instance.
+   * @return Whether the specified timeline can be shown on a multi-window time bar.
+   */
+  private static boolean canShowMultiWindowTimeBar(Timeline timeline, Timeline.Window window) {
+    if (timeline.getWindowCount() > MAX_WINDOWS_FOR_MULTI_WINDOW_TIME_BAR) {
+      return false;
+    }
+    int windowCount = timeline.getWindowCount();
+    for (int i = 0; i < windowCount; i++) {
+      if (timeline.getWindow(i, window).durationUs == C.TIME_UNSET) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private final class ComponentListener extends Player.DefaultEventListener
+      implements TimeBar.OnScrubListener, OnClickListener {
+
+    @Override
+    public void onScrubStart(TimeBar timeBar, long position) {
+      removeCallbacks(hideAction);
+      scrubbing = true;
+    }
+
+    @Override
+    public void onScrubMove(TimeBar timeBar, long position) {
+      if (positionView != null) {
+        positionView.setText(Util.getStringForTime(formatBuilder, formatter, position));
+      }
+    }
+
+    @Override
+    public void onScrubStop(TimeBar timeBar, long position, boolean canceled) {
+      scrubbing = false;
+      if (!canceled && player != null) {
+        seekToTimeBarPosition(position);
+      }
+      hideAfterTimeout();
+    }
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      updatePlayPauseButton();
+      updateProgress();
+    }
+
+    @Override
+    public void onRepeatModeChanged(int repeatMode) {
+      updateRepeatModeButton();
+      updateNavigation();
+    }
+
+    @Override
+    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
+      updateShuffleButton();
+      updateNavigation();
+    }
+
+    @Override
+    public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
+      updateNavigation();
+      updateProgress();
+    }
+
+    @Override
+    public void onTimelineChanged(
+        Timeline timeline, Object manifest, @Player.TimelineChangeReason int reason) {
+      updateNavigation();
+      updateTimeBarMode();
+      updateProgress();
+    }
+
+    @Override
+    public void onClick(View view) {
+      if (player != null) {
+        if (nextButton == view) {
+          next();
+        } else if (previousButton == view) {
+          previous();
+        } else if (fastForwardButton == view) {
+          fastForward();
+        } else if (rewindButton == view) {
+          rewind();
+        } else if (playButton == view) {
+          if (player.getPlaybackState() == Player.STATE_IDLE) {
+            if (playbackPreparer != null) {
+              playbackPreparer.preparePlayback();
+            }
+          } else if (player.getPlaybackState() == Player.STATE_ENDED) {
+            controlDispatcher.dispatchSeekTo(player, player.getCurrentWindowIndex(), C.TIME_UNSET);
+          }
+          controlDispatcher.dispatchSetPlayWhenReady(player, true);
+        } else if (pauseButton == view) {
+          controlDispatcher.dispatchSetPlayWhenReady(player, false);
+        } else if (repeatToggleButton == view) {
+          controlDispatcher.dispatchSetRepeatMode(
+              player, RepeatModeUtil.getNextRepeatMode(player.getRepeatMode(), repeatToggleModes));
+        } else if (shuffleButton == view) {
+          controlDispatcher.dispatchSetShuffleModeEnabled(player, !player.getShuffleModeEnabled());
+        }
+      }
+      hideAfterTimeout();
+    }
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
new file mode 100644
index 0000000000..24f365236f
--- /dev/null
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlayerView.java
@@ -0,0 +1,1068 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.ui;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Matrix;
+import android.graphics.RectF;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.AttributeSet;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.SurfaceView;
+import android.view.TextureView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ControlDispatcher;
+import com.google.android.exoplayer2.DefaultControlDispatcher;
+import com.google.android.exoplayer2.PlaybackPreparer;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Player.DiscontinuityReason;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.metadata.id3.ApicFrame;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.text.Cue;
+import com.google.android.exoplayer2.text.TextOutput;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.ui.AspectRatioFrameLayout.ResizeMode;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.RepeatModeUtil;
+import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.video.VideoListener;
+import java.util.List;
+
+/**
+ * A high level view for {@link Player} media playbacks. It displays video, subtitles and album art
+ * during playback, and displays playback controls using a {@link PlayerControlView}.
+ *
+ * <p>A PlayerView can be customized by setting attributes (or calling corresponding methods),
+ * overriding the view's layout file or by specifying a custom view layout file, as outlined below.
+ *
+ * <h3>Attributes</h3>
+ *
+ * The following attributes can be set on a PlayerView when used in a layout XML file:
+ *
+ * <ul>
+ *   <li><b>{@code use_artwork}</b> - Whether artwork is used if available in audio streams.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setUseArtwork(boolean)}
+ *         <li>Default: {@code true}
+ *       </ul>
+ *   <li><b>{@code default_artwork}</b> - Default artwork to use if no artwork available in audio
+ *       streams.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setDefaultArtwork(Bitmap)}
+ *         <li>Default: {@code null}
+ *       </ul>
+ *   <li><b>{@code use_controller}</b> - Whether the playback controls can be shown.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setUseController(boolean)}
+ *         <li>Default: {@code true}
+ *       </ul>
+ *   <li><b>{@code hide_on_touch}</b> - Whether the playback controls are hidden by touch events.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setControllerHideOnTouch(boolean)}
+ *         <li>Default: {@code true}
+ *       </ul>
+ *   <li><b>{@code auto_show}</b> - Whether the playback controls are automatically shown when
+ *       playback starts, pauses, ends, or fails. If set to false, the playback controls can be
+ *       manually operated with {@link #showController()} and {@link #hideController()}.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setControllerAutoShow(boolean)}
+ *         <li>Default: {@code true}
+ *       </ul>
+ *   <li><b>{@code hide_during_ads}</b> - Whether the playback controls are hidden during ads.
+ *       Controls are always shown during ads if they are enabled and the player is paused.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setControllerHideDuringAds(boolean)}
+ *         <li>Default: {@code true}
+ *       </ul>
+ *   <li><b>{@code resize_mode}</b> - Controls how video and album art is resized within the view.
+ *       Valid values are {@code fit}, {@code fixed_width}, {@code fixed_height} and {@code fill}.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setResizeMode(int)}
+ *         <li>Default: {@code fit}
+ *       </ul>
+ *   <li><b>{@code surface_type}</b> - The type of surface view used for video playbacks. Valid
+ *       values are {@code surface_view}, {@code texture_view} and {@code none}. Using {@code none}
+ *       is recommended for audio only applications, since creating the surface can be expensive.
+ *       Using {@code surface_view} is recommended for video applications.
+ *       <ul>
+ *         <li>Corresponding method: None
+ *         <li>Default: {@code surface_view}
+ *       </ul>
+ *   <li><b>{@code shutter_background_color}</b> - The background color of the {@code exo_shutter}
+ *       view.
+ *       <ul>
+ *         <li>Corresponding method: {@link #setShutterBackgroundColor(int)}
+ *         <li>Default: {@code unset}
+ *       </ul>
+ *   <li><b>{@code player_layout_id}</b> - Specifies the id of the layout to be inflated. See below
+ *       for more details.
+ *       <ul>
+ *         <li>Corresponding method: None
+ *         <li>Default: {@code R.id.exo_player_view}
+ *       </ul>
+ *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout resource to be
+ *       inflated by the child {@link PlayerControlView}. See below for more details.
+ *       <ul>
+ *         <li>Corresponding method: None
+ *         <li>Default: {@code R.id.exo_player_control_view}
+ *       </ul>
+ *   <li>All attributes that can be set on a {@link PlayerControlView} can also be set on a
+ *       PlayerView, and will be propagated to the inflated {@link PlayerControlView} unless the
+ *       layout is overridden to specify a custom {@code exo_controller} (see below).
+ * </ul>
+ *
+ * <h3>Overriding the layout file</h3>
+ *
+ * To customize the layout of PlayerView throughout your app, or just for certain configurations,
+ * you can define {@code exo_player_view.xml} layout files in your application {@code res/layout*}
+ * directories. These layouts will override the one provided by the ExoPlayer library, and will be
+ * inflated for use by PlayerView. The view identifies and binds its children by looking for the
+ * following ids:
+ *
+ * <p>
+ *
+ * <ul>
+ *   <li><b>{@code exo_content_frame}</b> - A frame whose aspect ratio is resized based on the video
+ *       or album art of the media being played, and the configured {@code resize_mode}. The video
+ *       surface view is inflated into this frame as its first child.
+ *       <ul>
+ *         <li>Type: {@link AspectRatioFrameLayout}
+ *       </ul>
+ *   <li><b>{@code exo_shutter}</b> - A view that's made visible when video should be hidden. This
+ *       view is typically an opaque view that covers the video surface view, thereby obscuring it
+ *       when visible.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_subtitles}</b> - Displays subtitles.
+ *       <ul>
+ *         <li>Type: {@link SubtitleView}
+ *       </ul>
+ *   <li><b>{@code exo_artwork}</b> - Displays album art.
+ *       <ul>
+ *         <li>Type: {@link ImageView}
+ *       </ul>
+ *   <li><b>{@code exo_controller_placeholder}</b> - A placeholder that's replaced with the inflated
+ *       {@link PlayerControlView}. Ignored if an {@code exo_controller} view exists.
+ *       <ul>
+ *         <li>Type: {@link View}
+ *       </ul>
+ *   <li><b>{@code exo_controller}</b> - An already inflated {@link PlayerControlView}. Allows use
+ *       of a custom extension of {@link PlayerControlView}. Note that attributes such as {@code
+ *       rewind_increment} will not be automatically propagated through to this instance. If a view
+ *       exists with this id, any {@code exo_controller_placeholder} view will be ignored.
+ *       <ul>
+ *         <li>Type: {@link PlayerControlView}
+ *       </ul>
+ *   <li><b>{@code exo_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
+ *       the app can access via {@link #getOverlayFrameLayout()}, provided for convenience.
+ *       <ul>
+ *         <li>Type: {@link FrameLayout}
+ *       </ul>
+ * </ul>
+ *
+ * <p>All child views are optional and so can be omitted if not required, however where defined they
+ * must be of the expected type.
+ *
+ * <h3>Specifying a custom layout file</h3>
+ *
+ * Defining your own {@code exo_player_view.xml} is useful to customize the layout of PlayerView
+ * throughout your application. It's also possible to customize the layout for a single instance in
+ * a layout file. This is achieved by setting the {@code player_layout_id} attribute on a
+ * PlayerView. This will cause the specified layout to be inflated instead of {@code
+ * exo_player_view.xml} for only the instance on which the attribute is set.
+ */
+public class PlayerView extends FrameLayout {
+
+  private static final int SURFACE_TYPE_NONE = 0;
+  private static final int SURFACE_TYPE_SURFACE_VIEW = 1;
+  private static final int SURFACE_TYPE_TEXTURE_VIEW = 2;
+
+  private final AspectRatioFrameLayout contentFrame;
+  private final View shutterView;
+  private final View surfaceView;
+  private final ImageView artworkView;
+  private final SubtitleView subtitleView;
+  private final PlayerControlView controller;
+  private final ComponentListener componentListener;
+  private final FrameLayout overlayFrameLayout;
+
+  private Player player;
+  private boolean useController;
+  private boolean useArtwork;
+  private Bitmap defaultArtwork;
+  private int controllerShowTimeoutMs;
+  private boolean controllerAutoShow;
+  private boolean controllerHideDuringAds;
+  private boolean controllerHideOnTouch;
+  private int textureViewRotation;
+
+  public PlayerView(Context context) {
+    this(context, null);
+  }
+
+  public PlayerView(Context context, AttributeSet attrs) {
+    this(context, attrs, 0);
+  }
+
+  public PlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
+    super(context, attrs, defStyleAttr);
+
+    if (isInEditMode()) {
+      contentFrame = null;
+      shutterView = null;
+      surfaceView = null;
+      artworkView = null;
+      subtitleView = null;
+      controller = null;
+      componentListener = null;
+      overlayFrameLayout = null;
+      ImageView logo = new ImageView(context);
+      if (Util.SDK_INT >= 23) {
+        configureEditModeLogoV23(getResources(), logo);
+      } else {
+        configureEditModeLogo(getResources(), logo);
+      }
+      addView(logo);
+      return;
+    }
+
+    boolean shutterColorSet = false;
+    int shutterColor = 0;
+    int playerLayoutId = R.layout.exo_player_view;
+    boolean useArtwork = true;
+    int defaultArtworkId = 0;
+    boolean useController = true;
+    int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
+    int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;
+    int controllerShowTimeoutMs = PlayerControlView.DEFAULT_SHOW_TIMEOUT_MS;
+    boolean controllerHideOnTouch = true;
+    boolean controllerAutoShow = true;
+    boolean controllerHideDuringAds = true;
+    if (attrs != null) {
+      TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.PlayerView, 0, 0);
+      try {
+        shutterColorSet = a.hasValue(R.styleable.PlayerView_shutter_background_color);
+        shutterColor = a.getColor(R.styleable.PlayerView_shutter_background_color, shutterColor);
+        playerLayoutId = a.getResourceId(R.styleable.PlayerView_player_layout_id, playerLayoutId);
+        useArtwork = a.getBoolean(R.styleable.PlayerView_use_artwork, useArtwork);
+        defaultArtworkId =
+            a.getResourceId(R.styleable.PlayerView_default_artwork, defaultArtworkId);
+        useController = a.getBoolean(R.styleable.PlayerView_use_controller, useController);
+        surfaceType = a.getInt(R.styleable.PlayerView_surface_type, surfaceType);
+        resizeMode = a.getInt(R.styleable.PlayerView_resize_mode, resizeMode);
+        controllerShowTimeoutMs =
+            a.getInt(R.styleable.PlayerView_show_timeout, controllerShowTimeoutMs);
+        controllerHideOnTouch =
+            a.getBoolean(R.styleable.PlayerView_hide_on_touch, controllerHideOnTouch);
+        controllerAutoShow = a.getBoolean(R.styleable.PlayerView_auto_show, controllerAutoShow);
+        controllerHideDuringAds =
+            a.getBoolean(R.styleable.PlayerView_hide_during_ads, controllerHideDuringAds);
+      } finally {
+        a.recycle();
+      }
+    }
+
+    LayoutInflater.from(context).inflate(playerLayoutId, this);
+    componentListener = new ComponentListener();
+    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
+
+    // Content frame.
+    contentFrame = findViewById(R.id.exo_content_frame);
+    if (contentFrame != null) {
+      setResizeModeRaw(contentFrame, resizeMode);
+    }
+
+    // Shutter view.
+    shutterView = findViewById(R.id.exo_shutter);
+    if (shutterView != null && shutterColorSet) {
+      shutterView.setBackgroundColor(shutterColor);
+    }
+
+    // Create a surface view and insert it into the content frame, if there is one.
+    if (contentFrame != null && surfaceType != SURFACE_TYPE_NONE) {
+      ViewGroup.LayoutParams params =
+          new ViewGroup.LayoutParams(
+              ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
+      surfaceView =
+          surfaceType == SURFACE_TYPE_TEXTURE_VIEW
+              ? new TextureView(context)
+              : new SurfaceView(context);
+      surfaceView.setLayoutParams(params);
+      contentFrame.addView(surfaceView, 0);
+    } else {
+      surfaceView = null;
+    }
+
+    // Overlay frame layout.
+    overlayFrameLayout = findViewById(R.id.exo_overlay);
+
+    // Artwork view.
+    artworkView = findViewById(R.id.exo_artwork);
+    this.useArtwork = useArtwork && artworkView != null;
+    if (defaultArtworkId != 0) {
+      defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId);
+    }
+
+    // Subtitle view.
+    subtitleView = findViewById(R.id.exo_subtitles);
+    if (subtitleView != null) {
+      subtitleView.setUserDefaultStyle();
+      subtitleView.setUserDefaultTextSize();
+    }
+
+    // Playback control view.
+    PlayerControlView customController = findViewById(R.id.exo_controller);
+    View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);
+    if (customController != null) {
+      this.controller = customController;
+    } else if (controllerPlaceholder != null) {
+      // Propagate attrs as playbackAttrs so that PlayerControlView's custom attributes are
+      // transferred, but standard FrameLayout attributes (e.g. background) are not.
+      this.controller = new PlayerControlView(context, null, 0, attrs);
+      controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
+      ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());
+      int controllerIndex = parent.indexOfChild(controllerPlaceholder);
+      parent.removeView(controllerPlaceholder);
+      parent.addView(controller, controllerIndex);
+    } else {
+      this.controller = null;
+    }
+    this.controllerShowTimeoutMs = controller != null ? controllerShowTimeoutMs : 0;
+    this.controllerHideOnTouch = controllerHideOnTouch;
+    this.controllerAutoShow = controllerAutoShow;
+    this.controllerHideDuringAds = controllerHideDuringAds;
+    this.useController = useController && controller != null;
+    hideController();
+  }
+
+  /**
+   * Switches the view targeted by a given {@link Player}.
+   *
+   * @param player The player whose target view is being switched.
+   * @param oldPlayerView The old view to detach from the player.
+   * @param newPlayerView The new view to attach to the player.
+   */
+  public static void switchTargetView(
+      @NonNull Player player,
+      @Nullable PlayerView oldPlayerView,
+      @Nullable PlayerView newPlayerView) {
+    if (oldPlayerView == newPlayerView) {
+      return;
+    }
+    // We attach the new view before detaching the old one because this ordering allows the player
+    // to swap directly from one surface to another, without transitioning through a state where no
+    // surface is attached. This is significantly more efficient and achieves a more seamless
+    // transition when using platform provided video decoders.
+    if (newPlayerView != null) {
+      newPlayerView.setPlayer(player);
+    }
+    if (oldPlayerView != null) {
+      oldPlayerView.setPlayer(null);
+    }
+  }
+
+  /** Returns the player currently set on this view, or null if no player is set. */
+  public Player getPlayer() {
+    return player;
+  }
+
+  /**
+   * Set the {@link Player} to use.
+   *
+   * <p>To transition a {@link Player} from targeting one view to another, it's recommended to use
+   * {@link #switchTargetView(Player, PlayerView, PlayerView)} rather than this method. If you do
+   * wish to use this method directly, be sure to attach the player to the new view <em>before</em>
+   * calling {@code setPlayer(null)} to detach it from the old one. This ordering is significantly
+   * more efficient and may allow for more seamless transitions.
+   *
+   * @param player The {@link Player} to use.
+   */
+  public void setPlayer(Player player) {
+    if (this.player == player) {
+      return;
+    }
+    if (this.player != null) {
+      this.player.removeListener(componentListener);
+      Player.VideoComponent oldVideoComponent = this.player.getVideoComponent();
+      if (oldVideoComponent != null) {
+        oldVideoComponent.removeVideoListener(componentListener);
+        if (surfaceView instanceof TextureView) {
+          oldVideoComponent.clearVideoTextureView((TextureView) surfaceView);
+        } else if (surfaceView instanceof SurfaceView) {
+          oldVideoComponent.clearVideoSurfaceView((SurfaceView) surfaceView);
+        }
+      }
+      Player.TextComponent oldTextComponent = this.player.getTextComponent();
+      if (oldTextComponent != null) {
+        oldTextComponent.removeTextOutput(componentListener);
+      }
+    }
+    this.player = player;
+    if (useController) {
+      controller.setPlayer(player);
+    }
+    if (shutterView != null) {
+      shutterView.setVisibility(VISIBLE);
+    }
+    if (subtitleView != null) {
+      subtitleView.setCues(null);
+    }
+    if (player != null) {
+      Player.VideoComponent newVideoComponent = player.getVideoComponent();
+      if (newVideoComponent != null) {
+        if (surfaceView instanceof TextureView) {
+          newVideoComponent.setVideoTextureView((TextureView) surfaceView);
+        } else if (surfaceView instanceof SurfaceView) {
+          newVideoComponent.setVideoSurfaceView((SurfaceView) surfaceView);
+        }
+        newVideoComponent.addVideoListener(componentListener);
+      }
+      Player.TextComponent newTextComponent = player.getTextComponent();
+      if (newTextComponent != null) {
+        newTextComponent.addTextOutput(componentListener);
+      }
+      player.addListener(componentListener);
+      maybeShowController(false);
+      updateForCurrentTrackSelections();
+    } else {
+      hideController();
+      hideArtwork();
+    }
+  }
+
+  @Override
+  public void setVisibility(int visibility) {
+    super.setVisibility(visibility);
+    if (surfaceView instanceof SurfaceView) {
+      // Work around https://github.com/google/ExoPlayer/issues/3160.
+      surfaceView.setVisibility(visibility);
+    }
+  }
+
+  /**
+   * Sets the resize mode.
+   *
+   * @param resizeMode The resize mode.
+   */
+  public void setResizeMode(@ResizeMode int resizeMode) {
+    Assertions.checkState(contentFrame != null);
+    contentFrame.setResizeMode(resizeMode);
+  }
+
+  /** Returns whether artwork is displayed if present in the media. */
+  public boolean getUseArtwork() {
+    return useArtwork;
+  }
+
+  /**
+   * Sets whether artwork is displayed if present in the media.
+   *
+   * @param useArtwork Whether artwork is displayed.
+   */
+  public void setUseArtwork(boolean useArtwork) {
+    Assertions.checkState(!useArtwork || artworkView != null);
+    if (this.useArtwork != useArtwork) {
+      this.useArtwork = useArtwork;
+      updateForCurrentTrackSelections();
+    }
+  }
+
+  /** Returns the default artwork to display. */
+  public Bitmap getDefaultArtwork() {
+    return defaultArtwork;
+  }
+
+  /**
+   * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
+   * present in the media.
+   *
+   * @param defaultArtwork the default artwork to display.
+   */
+  public void setDefaultArtwork(Bitmap defaultArtwork) {
+    if (this.defaultArtwork != defaultArtwork) {
+      this.defaultArtwork = defaultArtwork;
+      updateForCurrentTrackSelections();
+    }
+  }
+
+  /** Returns whether the playback controls can be shown. */
+  public boolean getUseController() {
+    return useController;
+  }
+
+  /**
+   * Sets whether the playback controls can be shown. If set to {@code false} the playback controls
+   * are never visible and are disconnected from the player.
+   *
+   * @param useController Whether the playback controls can be shown.
+   */
+  public void setUseController(boolean useController) {
+    Assertions.checkState(!useController || controller != null);
+    if (this.useController == useController) {
+      return;
+    }
+    this.useController = useController;
+    if (useController) {
+      controller.setPlayer(player);
+    } else if (controller != null) {
+      controller.hide();
+      controller.setPlayer(null);
+    }
+  }
+
+  /**
+   * Sets the background color of the {@code exo_shutter} view.
+   *
+   * @param color The background color.
+   */
+  public void setShutterBackgroundColor(int color) {
+    if (shutterView != null) {
+      shutterView.setBackgroundColor(color);
+    }
+  }
+
+  @Override
+  public boolean dispatchKeyEvent(KeyEvent event) {
+    if (player != null && player.isPlayingAd()) {
+      // Focus any overlay UI now, in case it's provided by a WebView whose contents may update
+      // dynamically. This is needed to make the "Skip ad" button focused on Android TV when using
+      // IMA [Internal: b/62371030].
+      overlayFrameLayout.requestFocus();
+      return super.dispatchKeyEvent(event);
+    }
+    boolean isDpadWhenControlHidden =
+        isDpadKey(event.getKeyCode()) && useController && !controller.isVisible();
+    maybeShowController(true);
+    return isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
+  }
+
+  /**
+   * Called to process media key events. Any {@link KeyEvent} can be passed but only media key
+   * events will be handled. Does nothing if playback controls are disabled.
+   *
+   * @param event A key event.
+   * @return Whether the key event was handled.
+   */
+  public boolean dispatchMediaKeyEvent(KeyEvent event) {
+    return useController && controller.dispatchMediaKeyEvent(event);
+  }
+
+  /**
+   * Shows the playback controls. Does nothing if playback controls are disabled.
+   *
+   * <p>The playback controls are automatically hidden during playback after {{@link
+   * #getControllerShowTimeoutMs()}}. They are shown indefinitely when playback has not started yet,
+   * is paused, has ended or failed.
+   */
+  public void showController() {
+    showController(shouldShowControllerIndefinitely());
+  }
+
+  /** Hides the playback controls. Does nothing if playback controls are disabled. */
+  public void hideController() {
+    if (controller != null) {
+      controller.hide();
+    }
+  }
+
+  /**
+   * Returns the playback controls timeout. The playback controls are automatically hidden after
+   * this duration of time has elapsed without user input and with playback or buffering in
+   * progress.
+   *
+   * @return The timeout in milliseconds. A non-positive value will cause the controller to remain
+   *     visible indefinitely.
+   */
+  public int getControllerShowTimeoutMs() {
+    return controllerShowTimeoutMs;
+  }
+
+  /**
+   * Sets the playback controls timeout. The playback controls are automatically hidden after this
+   * duration of time has elapsed without user input and with playback or buffering in progress.
+   *
+   * @param controllerShowTimeoutMs The timeout in milliseconds. A non-positive value will cause the
+   *     controller to remain visible indefinitely.
+   */
+  public void setControllerShowTimeoutMs(int controllerShowTimeoutMs) {
+    Assertions.checkState(controller != null);
+    this.controllerShowTimeoutMs = controllerShowTimeoutMs;
+    if (controller.isVisible()) {
+      // Update the controller's timeout if necessary.
+      showController();
+    }
+  }
+
+  /** Returns whether the playback controls are hidden by touch events. */
+  public boolean getControllerHideOnTouch() {
+    return controllerHideOnTouch;
+  }
+
+  /**
+   * Sets whether the playback controls are hidden by touch events.
+   *
+   * @param controllerHideOnTouch Whether the playback controls are hidden by touch events.
+   */
+  public void setControllerHideOnTouch(boolean controllerHideOnTouch) {
+    Assertions.checkState(controller != null);
+    this.controllerHideOnTouch = controllerHideOnTouch;
+  }
+
+  /**
+   * Returns whether the playback controls are automatically shown when playback starts, pauses,
+   * ends, or fails. If set to false, the playback controls can be manually operated with {@link
+   * #showController()} and {@link #hideController()}.
+   */
+  public boolean getControllerAutoShow() {
+    return controllerAutoShow;
+  }
+
+  /**
+   * Sets whether the playback controls are automatically shown when playback starts, pauses, ends,
+   * or fails. If set to false, the playback controls can be manually operated with {@link
+   * #showController()} and {@link #hideController()}.
+   *
+   * @param controllerAutoShow Whether the playback controls are allowed to show automatically.
+   */
+  public void setControllerAutoShow(boolean controllerAutoShow) {
+    this.controllerAutoShow = controllerAutoShow;
+  }
+
+  /**
+   * Sets whether the playback controls are hidden when ads are playing. Controls are always shown
+   * during ads if they are enabled and the player is paused.
+   *
+   * @param controllerHideDuringAds Whether the playback controls are hidden when ads are playing.
+   */
+  public void setControllerHideDuringAds(boolean controllerHideDuringAds) {
+    this.controllerHideDuringAds = controllerHideDuringAds;
+  }
+
+  /**
+   * Set the {@link PlayerControlView.VisibilityListener}.
+   *
+   * @param listener The listener to be notified about visibility changes.
+   */
+  public void setControllerVisibilityListener(PlayerControlView.VisibilityListener listener) {
+    Assertions.checkState(controller != null);
+    controller.setVisibilityListener(listener);
+  }
+
+  /**
+   * Sets the {@link PlaybackPreparer}.
+   *
+   * @param playbackPreparer The {@link PlaybackPreparer}.
+   */
+  public void setPlaybackPreparer(@Nullable PlaybackPreparer playbackPreparer) {
+    Assertions.checkState(controller != null);
+    controller.setPlaybackPreparer(playbackPreparer);
+  }
+
+  /**
+   * Sets the {@link ControlDispatcher}.
+   *
+   * @param controlDispatcher The {@link ControlDispatcher}, or null to use {@link
+   *     DefaultControlDispatcher}.
+   */
+  public void setControlDispatcher(@Nullable ControlDispatcher controlDispatcher) {
+    Assertions.checkState(controller != null);
+    controller.setControlDispatcher(controlDispatcher);
+  }
+
+  /**
+   * Sets the rewind increment in milliseconds.
+   *
+   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
+   *     rewind button to be disabled.
+   */
+  public void setRewindIncrementMs(int rewindMs) {
+    Assertions.checkState(controller != null);
+    controller.setRewindIncrementMs(rewindMs);
+  }
+
+  /**
+   * Sets the fast forward increment in milliseconds.
+   *
+   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
+   *     cause the fast forward button to be disabled.
+   */
+  public void setFastForwardIncrementMs(int fastForwardMs) {
+    Assertions.checkState(controller != null);
+    controller.setFastForwardIncrementMs(fastForwardMs);
+  }
+
+  /**
+   * Sets which repeat toggle modes are enabled.
+   *
+   * @param repeatToggleModes A set of {@link RepeatModeUtil.RepeatToggleModes}.
+   */
+  public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
+    Assertions.checkState(controller != null);
+    controller.setRepeatToggleModes(repeatToggleModes);
+  }
+
+  /**
+   * Sets whether the shuffle button is shown.
+   *
+   * @param showShuffleButton Whether the shuffle button is shown.
+   */
+  public void setShowShuffleButton(boolean showShuffleButton) {
+    Assertions.checkState(controller != null);
+    controller.setShowShuffleButton(showShuffleButton);
+  }
+
+  /**
+   * Sets whether the time bar should show all windows, as opposed to just the current one.
+   *
+   * @param showMultiWindowTimeBar Whether to show all windows.
+   */
+  public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {
+    Assertions.checkState(controller != null);
+    controller.setShowMultiWindowTimeBar(showMultiWindowTimeBar);
+  }
+
+  /**
+   * Gets the view onto which video is rendered. This is a:
+   *
+   * <ul>
+   *   <li>{@link SurfaceView} by default, or if the {@code surface_type} attribute is set to {@code
+   *       surface_view}.
+   *   <li>{@link TextureView} if {@code surface_type} is {@code texture_view}.
+   *   <li>{@code null} if {@code surface_type} is {@code none}.
+   * </ul>
+   *
+   * @return The {@link SurfaceView}, {@link TextureView} or {@code null}.
+   */
+  public View getVideoSurfaceView() {
+    return surfaceView;
+  }
+
+  /**
+   * Gets the overlay {@link FrameLayout}, which can be populated with UI elements to show on top of
+   * the player.
+   *
+   * @return The overlay {@link FrameLayout}, or {@code null} if the layout has been customized and
+   *     the overlay is not present.
+   */
+  public FrameLayout getOverlayFrameLayout() {
+    return overlayFrameLayout;
+  }
+
+  /**
+   * Gets the {@link SubtitleView}.
+   *
+   * @return The {@link SubtitleView}, or {@code null} if the layout has been customized and the
+   *     subtitle view is not present.
+   */
+  public SubtitleView getSubtitleView() {
+    return subtitleView;
+  }
+
+  @Override
+  public boolean onTouchEvent(MotionEvent ev) {
+    if (!useController || player == null || ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
+      return false;
+    }
+    if (!controller.isVisible()) {
+      maybeShowController(true);
+    } else if (controllerHideOnTouch) {
+      controller.hide();
+    }
+    return true;
+  }
+
+  @Override
+  public boolean onTrackballEvent(MotionEvent ev) {
+    if (!useController || player == null) {
+      return false;
+    }
+    maybeShowController(true);
+    return true;
+  }
+
+  /** Shows the playback controls, but only if forced or shown indefinitely. */
+  private void maybeShowController(boolean isForced) {
+    if (isPlayingAd() && controllerHideDuringAds) {
+      return;
+    }
+    if (useController) {
+      boolean wasShowingIndefinitely = controller.isVisible() && controller.getShowTimeoutMs() <= 0;
+      boolean shouldShowIndefinitely = shouldShowControllerIndefinitely();
+      if (isForced || wasShowingIndefinitely || shouldShowIndefinitely) {
+        showController(shouldShowIndefinitely);
+      }
+    }
+  }
+
+  private boolean shouldShowControllerIndefinitely() {
+    if (player == null) {
+      return true;
+    }
+    int playbackState = player.getPlaybackState();
+    return controllerAutoShow
+        && (playbackState == Player.STATE_IDLE
+            || playbackState == Player.STATE_ENDED
+            || !player.getPlayWhenReady());
+  }
+
+  private void showController(boolean showIndefinitely) {
+    if (!useController) {
+      return;
+    }
+    controller.setShowTimeoutMs(showIndefinitely ? 0 : controllerShowTimeoutMs);
+    controller.show();
+  }
+
+  private boolean isPlayingAd() {
+    return player != null && player.isPlayingAd() && player.getPlayWhenReady();
+  }
+
+  private void updateForCurrentTrackSelections() {
+    if (player == null) {
+      return;
+    }
+    TrackSelectionArray selections = player.getCurrentTrackSelections();
+    for (int i = 0; i < selections.length; i++) {
+      if (player.getRendererType(i) == C.TRACK_TYPE_VIDEO && selections.get(i) != null) {
+        // Video enabled so artwork must be hidden. If the shutter is closed, it will be opened in
+        // onRenderedFirstFrame().
+        hideArtwork();
+        return;
+      }
+    }
+    // Video disabled so the shutter must be closed.
+    if (shutterView != null) {
+      shutterView.setVisibility(VISIBLE);
+    }
+    // Display artwork if enabled and available, else hide it.
+    if (useArtwork) {
+      for (int i = 0; i < selections.length; i++) {
+        TrackSelection selection = selections.get(i);
+        if (selection != null) {
+          for (int j = 0; j < selection.length(); j++) {
+            Metadata metadata = selection.getFormat(j).metadata;
+            if (metadata != null && setArtworkFromMetadata(metadata)) {
+              return;
+            }
+          }
+        }
+      }
+      if (setArtworkFromBitmap(defaultArtwork)) {
+        return;
+      }
+    }
+    // Artwork disabled or unavailable.
+    hideArtwork();
+  }
+
+  private boolean setArtworkFromMetadata(Metadata metadata) {
+    for (int i = 0; i < metadata.length(); i++) {
+      Metadata.Entry metadataEntry = metadata.get(i);
+      if (metadataEntry instanceof ApicFrame) {
+        byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
+        Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
+        return setArtworkFromBitmap(bitmap);
+      }
+    }
+    return false;
+  }
+
+  private boolean setArtworkFromBitmap(Bitmap bitmap) {
+    if (bitmap != null) {
+      int bitmapWidth = bitmap.getWidth();
+      int bitmapHeight = bitmap.getHeight();
+      if (bitmapWidth > 0 && bitmapHeight > 0) {
+        if (contentFrame != null) {
+          contentFrame.setAspectRatio((float) bitmapWidth / bitmapHeight);
+        }
+        artworkView.setImageBitmap(bitmap);
+        artworkView.setVisibility(VISIBLE);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  private void hideArtwork() {
+    if (artworkView != null) {
+      artworkView.setImageResource(android.R.color.transparent); // Clears any bitmap reference.
+      artworkView.setVisibility(INVISIBLE);
+    }
+  }
+
+  @TargetApi(23)
+  private static void configureEditModeLogoV23(Resources resources, ImageView logo) {
+    logo.setImageDrawable(resources.getDrawable(R.drawable.exo_edit_mode_logo, null));
+    logo.setBackgroundColor(resources.getColor(R.color.exo_edit_mode_background_color, null));
+  }
+
+  @SuppressWarnings("deprecation")
+  private static void configureEditModeLogo(Resources resources, ImageView logo) {
+    logo.setImageDrawable(resources.getDrawable(R.drawable.exo_edit_mode_logo));
+    logo.setBackgroundColor(resources.getColor(R.color.exo_edit_mode_background_color));
+  }
+
+  @SuppressWarnings("ResourceType")
+  private static void setResizeModeRaw(AspectRatioFrameLayout aspectRatioFrame, int resizeMode) {
+    aspectRatioFrame.setResizeMode(resizeMode);
+  }
+
+  /** Applies a texture rotation to a {@link TextureView}. */
+  private static void applyTextureViewRotation(TextureView textureView, int textureViewRotation) {
+    float textureViewWidth = textureView.getWidth();
+    float textureViewHeight = textureView.getHeight();
+    if (textureViewWidth == 0 || textureViewHeight == 0 || textureViewRotation == 0) {
+      textureView.setTransform(null);
+    } else {
+      Matrix transformMatrix = new Matrix();
+      float pivotX = textureViewWidth / 2;
+      float pivotY = textureViewHeight / 2;
+      transformMatrix.postRotate(textureViewRotation, pivotX, pivotY);
+
+      // After rotation, scale the rotated texture to fit the TextureView size.
+      RectF originalTextureRect = new RectF(0, 0, textureViewWidth, textureViewHeight);
+      RectF rotatedTextureRect = new RectF();
+      transformMatrix.mapRect(rotatedTextureRect, originalTextureRect);
+      transformMatrix.postScale(
+          textureViewWidth / rotatedTextureRect.width(),
+          textureViewHeight / rotatedTextureRect.height(),
+          pivotX,
+          pivotY);
+      textureView.setTransform(transformMatrix);
+    }
+  }
+
+  @SuppressLint("InlinedApi")
+  private boolean isDpadKey(int keyCode) {
+    return keyCode == KeyEvent.KEYCODE_DPAD_UP
+        || keyCode == KeyEvent.KEYCODE_DPAD_UP_RIGHT
+        || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT
+        || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_RIGHT
+        || keyCode == KeyEvent.KEYCODE_DPAD_DOWN
+        || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_LEFT
+        || keyCode == KeyEvent.KEYCODE_DPAD_LEFT
+        || keyCode == KeyEvent.KEYCODE_DPAD_UP_LEFT
+        || keyCode == KeyEvent.KEYCODE_DPAD_CENTER;
+  }
+
+  private final class ComponentListener extends Player.DefaultEventListener
+      implements TextOutput, VideoListener, OnLayoutChangeListener {
+
+    // TextOutput implementation
+
+    @Override
+    public void onCues(List<Cue> cues) {
+      if (subtitleView != null) {
+        subtitleView.onCues(cues);
+      }
+    }
+
+    // VideoListener implementation
+
+    @Override
+    public void onVideoSizeChanged(
+        int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
+      if (contentFrame == null) {
+        return;
+      }
+      float videoAspectRatio =
+          (height == 0 || width == 0) ? 1 : (width * pixelWidthHeightRatio) / height;
+
+      if (surfaceView instanceof TextureView) {
+        // Try to apply rotation transformation when our surface is a TextureView.
+        if (unappliedRotationDegrees == 90 || unappliedRotationDegrees == 270) {
+          // We will apply a rotation 90/270 degree to the output texture of the TextureView.
+          // In this case, the output video's width and height will be swapped.
+          videoAspectRatio = 1 / videoAspectRatio;
+        }
+        if (textureViewRotation != 0) {
+          surfaceView.removeOnLayoutChangeListener(this);
+        }
+        textureViewRotation = unappliedRotationDegrees;
+        if (textureViewRotation != 0) {
+          // The texture view's dimensions might be changed after layout step.
+          // So add an OnLayoutChangeListener to apply rotation after layout step.
+          surfaceView.addOnLayoutChangeListener(this);
+        }
+        applyTextureViewRotation((TextureView) surfaceView, textureViewRotation);
+      }
+
+      contentFrame.setAspectRatio(videoAspectRatio);
+    }
+
+    @Override
+    public void onRenderedFirstFrame() {
+      if (shutterView != null) {
+        shutterView.setVisibility(INVISIBLE);
+      }
+    }
+
+    @Override
+    public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selections) {
+      updateForCurrentTrackSelections();
+    }
+
+    // Player.EventListener implementation
+
+    @Override
+    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+      if (isPlayingAd() && controllerHideDuringAds) {
+        hideController();
+      } else {
+        maybeShowController(false);
+      }
+    }
+
+    @Override
+    public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
+      if (isPlayingAd() && controllerHideDuringAds) {
+        hideController();
+      }
+    }
+
+    // OnLayoutChangeListener implementation
+
+    @Override
+    public void onLayoutChange(
+        View view,
+        int left,
+        int top,
+        int right,
+        int bottom,
+        int oldLeft,
+        int oldTop,
+        int oldRight,
+        int oldBottom) {
+      applyTextureViewRotation((TextureView) view, textureViewRotation);
+    }
+  }
+}
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
index b09e80c591..b8098b6fa7 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java
@@ -15,351 +15,28 @@
  */
 package com.google.android.exoplayer2.ui;
 
-import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.content.Context;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.AttributeSet;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.MotionEvent;
-import android.view.SurfaceView;
-import android.view.TextureView;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ControlDispatcher;
-import com.google.android.exoplayer2.DefaultControlDispatcher;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Player.DiscontinuityReason;
 import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.metadata.Metadata;
-import com.google.android.exoplayer2.metadata.id3.ApicFrame;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.text.Cue;
-import com.google.android.exoplayer2.text.TextOutput;
-import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
-import com.google.android.exoplayer2.ui.AspectRatioFrameLayout.ResizeMode;
-import com.google.android.exoplayer2.util.Assertions;
-import com.google.android.exoplayer2.util.RepeatModeUtil;
-import com.google.android.exoplayer2.util.Util;
-import java.util.List;
 
-/**
- * A high level view for {@link SimpleExoPlayer} media playbacks. It displays video, subtitles and
- * album art during playback, and displays playback controls using a {@link PlaybackControlView}.
- * <p>
- * A SimpleExoPlayerView can be customized by setting attributes (or calling corresponding methods),
- * overriding the view's layout file or by specifying a custom view layout file, as outlined below.
- *
- * <h3>Attributes</h3>
- * The following attributes can be set on a SimpleExoPlayerView when used in a layout XML file:
- * <p>
- * <ul>
- *   <li><b>{@code use_artwork}</b> - Whether artwork is used if available in audio streams.
- *       <ul>
- *         <li>Corresponding method: {@link #setUseArtwork(boolean)}</li>
- *         <li>Default: {@code true}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code default_artwork}</b> - Default artwork to use if no artwork available in audio
- *       streams.
- *       <ul>
- *         <li>Corresponding method: {@link #setDefaultArtwork(Bitmap)}</li>
- *         <li>Default: {@code null}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code use_controller}</b> - Whether the playback controls can be shown.
- *       <ul>
- *         <li>Corresponding method: {@link #setUseController(boolean)}</li>
- *         <li>Default: {@code true}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code hide_on_touch}</b> - Whether the playback controls are hidden by touch events.
- *       <ul>
- *         <li>Corresponding method: {@link #setControllerHideOnTouch(boolean)}</li>
- *         <li>Default: {@code true}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code auto_show}</b> - Whether the playback controls are automatically shown when
- *       playback starts, pauses, ends, or fails. If set to false, the playback controls can be
- *       manually operated with {@link #showController()} and {@link #hideController()}.
- *       <ul>
- *         <li>Corresponding method: {@link #setControllerAutoShow(boolean)}</li>
- *         <li>Default: {@code true}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code resize_mode}</b> - Controls how video and album art is resized within the view.
- *       Valid values are {@code fit}, {@code fixed_width}, {@code fixed_height} and {@code fill}.
- *       <ul>
- *         <li>Corresponding method: {@link #setResizeMode(int)}</li>
- *         <li>Default: {@code fit}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code surface_type}</b> - The type of surface view used for video playbacks. Valid
- *       values are {@code surface_view}, {@code texture_view} and {@code none}. Using {@code none}
- *       is recommended for audio only applications, since creating the surface can be expensive.
- *       Using {@code surface_view} is recommended for video applications.
- *       <ul>
- *         <li>Corresponding method: None</li>
- *         <li>Default: {@code surface_view}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code shutter_background_color}</b> - The background color of the {@code exo_shutter}
- *       view.
- *       <ul>
- *         <li>Corresponding method: {@link #setShutterBackgroundColor(int)}</li>
- *         <li>Default: {@code unset}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code player_layout_id}</b> - Specifies the id of the layout to be inflated. See below
- *       for more details.
- *       <ul>
- *         <li>Corresponding method: None</li>
- *         <li>Default: {@code R.id.exo_simple_player_view}</li>
- *       </ul>
- *   <li><b>{@code controller_layout_id}</b> - Specifies the id of the layout resource to be
- *       inflated by the child {@link PlaybackControlView}. See below for more details.
- *       <ul>
- *         <li>Corresponding method: None</li>
- *         <li>Default: {@code R.id.exo_playback_control_view}</li>
- *       </ul>
- *   <li>All attributes that can be set on a {@link PlaybackControlView} can also be set on a
- *       SimpleExoPlayerView, and will be propagated to the inflated {@link PlaybackControlView}
- *       unless the layout is overridden to specify a custom {@code exo_controller} (see below).
- *   </li>
- * </ul>
- *
- * <h3>Overriding the layout file</h3>
- * To customize the layout of SimpleExoPlayerView throughout your app, or just for certain
- * configurations, you can define {@code exo_simple_player_view.xml} layout files in your
- * application {@code res/layout*} directories. These layouts will override the one provided by the
- * ExoPlayer library, and will be inflated for use by SimpleExoPlayerView. The view identifies and
- * binds its children by looking for the following ids:
- * <p>
- * <ul>
- *   <li><b>{@code exo_content_frame}</b> - A frame whose aspect ratio is resized based on the video
- *       or album art of the media being played, and the configured {@code resize_mode}. The video
- *       surface view is inflated into this frame as its first child.
- *       <ul>
- *         <li>Type: {@link AspectRatioFrameLayout}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_shutter}</b> - A view that's made visible when video should be hidden. This
- *       view is typically an opaque view that covers the video surface view, thereby obscuring it
- *       when visible.
- *       <ul>
- *        <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_subtitles}</b> - Displays subtitles.
- *       <ul>
- *        <li>Type: {@link SubtitleView}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_artwork}</b> - Displays album art.
- *       <ul>
- *        <li>Type: {@link ImageView}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_controller_placeholder}</b> - A placeholder that's replaced with the inflated
- *       {@link PlaybackControlView}. Ignored if an {@code exo_controller} view exists.
- *       <ul>
- *        <li>Type: {@link View}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_controller}</b> - An already inflated {@link PlaybackControlView}. Allows use
- *       of a custom extension of {@link PlaybackControlView}. Note that attributes such as
- *       {@code rewind_increment} will not be automatically propagated through to this instance. If
- *       a view exists with this id, any {@code exo_controller_placeholder} view will be ignored.
- *       <ul>
- *        <li>Type: {@link PlaybackControlView}</li>
- *       </ul>
- *   </li>
- *   <li><b>{@code exo_overlay}</b> - A {@link FrameLayout} positioned on top of the player which
- *       the app can access via {@link #getOverlayFrameLayout()}, provided for convenience.
- *       <ul>
- *        <li>Type: {@link FrameLayout}</li>
- *       </ul>
- *   </li>
- * </ul>
- * <p>
- * All child views are optional and so can be omitted if not required, however where defined they
- * must be of the expected type.
- *
- * <h3>Specifying a custom layout file</h3>
- * Defining your own {@code exo_simple_player_view.xml} is useful to customize the layout of
- * SimpleExoPlayerView throughout your application. It's also possible to customize the layout for a
- * single instance in a layout file. This is achieved by setting the {@code player_layout_id}
- * attribute on a SimpleExoPlayerView. This will cause the specified layout to be inflated instead
- * of {@code exo_simple_player_view.xml} for only the instance on which the attribute is set.
- */
+/** @deprecated Use {@link PlayerView}. */
+@Deprecated
 @TargetApi(16)
-public final class SimpleExoPlayerView extends FrameLayout {
-
-  private static final int SURFACE_TYPE_NONE = 0;
-  private static final int SURFACE_TYPE_SURFACE_VIEW = 1;
-  private static final int SURFACE_TYPE_TEXTURE_VIEW = 2;
-
-  private final AspectRatioFrameLayout contentFrame;
-  private final View shutterView;
-  private final View surfaceView;
-  private final ImageView artworkView;
-  private final SubtitleView subtitleView;
-  private final PlaybackControlView controller;
-  private final ComponentListener componentListener;
-  private final FrameLayout overlayFrameLayout;
-
-  private SimpleExoPlayer player;
-  private boolean useController;
-  private boolean useArtwork;
-  private Bitmap defaultArtwork;
-  private int controllerShowTimeoutMs;
-  private boolean controllerAutoShow;
-  private boolean controllerHideOnTouch;
+public final class SimpleExoPlayerView extends PlayerView {
 
   public SimpleExoPlayerView(Context context) {
-    this(context, null);
+    super(context);
   }
 
   public SimpleExoPlayerView(Context context, AttributeSet attrs) {
-    this(context, attrs, 0);
+    super(context, attrs);
   }
 
   public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr) {
     super(context, attrs, defStyleAttr);
-
-    if (isInEditMode()) {
-      contentFrame = null;
-      shutterView = null;
-      surfaceView = null;
-      artworkView = null;
-      subtitleView = null;
-      controller = null;
-      componentListener = null;
-      overlayFrameLayout = null;
-      ImageView logo = new ImageView(context);
-      if (Util.SDK_INT >= 23) {
-        configureEditModeLogoV23(getResources(), logo);
-      } else {
-        configureEditModeLogo(getResources(), logo);
-      }
-      addView(logo);
-      return;
-    }
-
-    boolean shutterColorSet = false;
-    int shutterColor = 0;
-    int playerLayoutId = R.layout.exo_simple_player_view;
-    boolean useArtwork = true;
-    int defaultArtworkId = 0;
-    boolean useController = true;
-    int surfaceType = SURFACE_TYPE_SURFACE_VIEW;
-    int resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FIT;
-    int controllerShowTimeoutMs = PlaybackControlView.DEFAULT_SHOW_TIMEOUT_MS;
-    boolean controllerHideOnTouch = true;
-    boolean controllerAutoShow = true;
-    if (attrs != null) {
-      TypedArray a = context.getTheme().obtainStyledAttributes(attrs,
-          R.styleable.SimpleExoPlayerView, 0, 0);
-      try {
-        shutterColorSet = a.hasValue(R.styleable.SimpleExoPlayerView_shutter_background_color);
-        shutterColor = a.getColor(R.styleable.SimpleExoPlayerView_shutter_background_color,
-              shutterColor);
-        playerLayoutId = a.getResourceId(R.styleable.SimpleExoPlayerView_player_layout_id,
-            playerLayoutId);
-        useArtwork = a.getBoolean(R.styleable.SimpleExoPlayerView_use_artwork, useArtwork);
-        defaultArtworkId = a.getResourceId(R.styleable.SimpleExoPlayerView_default_artwork,
-            defaultArtworkId);
-        useController = a.getBoolean(R.styleable.SimpleExoPlayerView_use_controller, useController);
-        surfaceType = a.getInt(R.styleable.SimpleExoPlayerView_surface_type, surfaceType);
-        resizeMode = a.getInt(R.styleable.SimpleExoPlayerView_resize_mode, resizeMode);
-        controllerShowTimeoutMs = a.getInt(R.styleable.SimpleExoPlayerView_show_timeout,
-            controllerShowTimeoutMs);
-        controllerHideOnTouch = a.getBoolean(R.styleable.SimpleExoPlayerView_hide_on_touch,
-            controllerHideOnTouch);
-        controllerAutoShow = a.getBoolean(R.styleable.SimpleExoPlayerView_auto_show,
-            controllerAutoShow);
-      } finally {
-        a.recycle();
-      }
-    }
-
-    LayoutInflater.from(context).inflate(playerLayoutId, this);
-    componentListener = new ComponentListener();
-    setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
-
-    // Content frame.
-    contentFrame = findViewById(R.id.exo_content_frame);
-    if (contentFrame != null) {
-      setResizeModeRaw(contentFrame, resizeMode);
-    }
-
-    // Shutter view.
-    shutterView = findViewById(R.id.exo_shutter);
-    if (shutterView != null && shutterColorSet) {
-      shutterView.setBackgroundColor(shutterColor);
-    }
-
-    // Create a surface view and insert it into the content frame, if there is one.
-    if (contentFrame != null && surfaceType != SURFACE_TYPE_NONE) {
-      ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(
-          ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
-      surfaceView = surfaceType == SURFACE_TYPE_TEXTURE_VIEW ? new TextureView(context)
-          : new SurfaceView(context);
-      surfaceView.setLayoutParams(params);
-      contentFrame.addView(surfaceView, 0);
-    } else {
-      surfaceView = null;
-    }
-
-    // Overlay frame layout.
-    overlayFrameLayout = findViewById(R.id.exo_overlay);
-
-    // Artwork view.
-    artworkView = findViewById(R.id.exo_artwork);
-    this.useArtwork = useArtwork && artworkView != null;
-    if (defaultArtworkId != 0) {
-      defaultArtwork = BitmapFactory.decodeResource(context.getResources(), defaultArtworkId);
-    }
-
-    // Subtitle view.
-    subtitleView = findViewById(R.id.exo_subtitles);
-    if (subtitleView != null) {
-      subtitleView.setUserDefaultStyle();
-      subtitleView.setUserDefaultTextSize();
-    }
-
-    // Playback control view.
-    PlaybackControlView customController = findViewById(R.id.exo_controller);
-    View controllerPlaceholder = findViewById(R.id.exo_controller_placeholder);
-    if (customController != null) {
-      this.controller = customController;
-    } else if (controllerPlaceholder != null) {
-      // Propagate attrs as playbackAttrs so that PlaybackControlView's custom attributes are
-      // transferred, but standard FrameLayout attributes (e.g. background) are not.
-      this.controller = new PlaybackControlView(context, null, 0, attrs);
-      controller.setLayoutParams(controllerPlaceholder.getLayoutParams());
-      ViewGroup parent = ((ViewGroup) controllerPlaceholder.getParent());
-      int controllerIndex = parent.indexOfChild(controllerPlaceholder);
-      parent.removeView(controllerPlaceholder);
-      parent.addView(controller, controllerIndex);
-    } else {
-      this.controller = null;
-    }
-    this.controllerShowTimeoutMs = controller != null ? controllerShowTimeoutMs : 0;
-    this.controllerHideOnTouch = controllerHideOnTouch;
-    this.controllerAutoShow = controllerAutoShow;
-    this.useController = useController && controller != null;
-    hideController();
   }
 
   /**
@@ -369,604 +46,11 @@ public SimpleExoPlayerView(Context context, AttributeSet attrs, int defStyleAttr
    * @param oldPlayerView The old view to detach from the player.
    * @param newPlayerView The new view to attach to the player.
    */
-  public static void switchTargetView(@NonNull SimpleExoPlayer player,
-      @Nullable SimpleExoPlayerView oldPlayerView, @Nullable SimpleExoPlayerView newPlayerView) {
-    if (oldPlayerView == newPlayerView) {
-      return;
-    }
-    // We attach the new view before detaching the old one because this ordering allows the player
-    // to swap directly from one surface to another, without transitioning through a state where no
-    // surface is attached. This is significantly more efficient and achieves a more seamless
-    // transition when using platform provided video decoders.
-    if (newPlayerView != null) {
-      newPlayerView.setPlayer(player);
-    }
-    if (oldPlayerView != null) {
-      oldPlayerView.setPlayer(null);
-    }
-  }
-
-  /**
-   * Returns the player currently set on this view, or null if no player is set.
-   */
-  public SimpleExoPlayer getPlayer() {
-    return player;
-  }
-
-  /**
-   * Set the {@link SimpleExoPlayer} to use.
-   * <p>
-   * To transition a {@link SimpleExoPlayer} from targeting one view to another, it's recommended to
-   * use {@link #switchTargetView(SimpleExoPlayer, SimpleExoPlayerView, SimpleExoPlayerView)} rather
-   * than this method. If you do wish to use this method directly, be sure to attach the player to
-   * the new view <em>before</em> calling {@code setPlayer(null)} to detach it from the old one.
-   * This ordering is significantly more efficient and may allow for more seamless transitions.
-   *
-   * @param player The {@link SimpleExoPlayer} to use.
-   */
-  public void setPlayer(SimpleExoPlayer player) {
-    if (this.player == player) {
-      return;
-    }
-    if (this.player != null) {
-      this.player.removeListener(componentListener);
-      this.player.removeTextOutput(componentListener);
-      this.player.removeVideoListener(componentListener);
-      if (surfaceView instanceof TextureView) {
-        this.player.clearVideoTextureView((TextureView) surfaceView);
-      } else if (surfaceView instanceof SurfaceView) {
-        this.player.clearVideoSurfaceView((SurfaceView) surfaceView);
-      }
-    }
-    this.player = player;
-    if (useController) {
-      controller.setPlayer(player);
-    }
-    if (shutterView != null) {
-      shutterView.setVisibility(VISIBLE);
-    }
-    if (player != null) {
-      if (surfaceView instanceof TextureView) {
-        player.setVideoTextureView((TextureView) surfaceView);
-      } else if (surfaceView instanceof SurfaceView) {
-        player.setVideoSurfaceView((SurfaceView) surfaceView);
-      }
-      player.addVideoListener(componentListener);
-      player.addTextOutput(componentListener);
-      player.addListener(componentListener);
-      maybeShowController(false);
-      updateForCurrentTrackSelections();
-    } else {
-      hideController();
-      hideArtwork();
-    }
-  }
-
-  @Override
-  public void setVisibility(int visibility) {
-    super.setVisibility(visibility);
-    if (surfaceView instanceof SurfaceView) {
-      // Work around https://github.com/google/ExoPlayer/issues/3160.
-      surfaceView.setVisibility(visibility);
-    }
-  }
-
-  /**
-   * Sets the resize mode.
-   *
-   * @param resizeMode The resize mode.
-   */
-  public void setResizeMode(@ResizeMode int resizeMode) {
-    Assertions.checkState(contentFrame != null);
-    contentFrame.setResizeMode(resizeMode);
-  }
-
-  /**
-   * Returns whether artwork is displayed if present in the media.
-   */
-  public boolean getUseArtwork() {
-    return useArtwork;
-  }
-
-  /**
-   * Sets whether artwork is displayed if present in the media.
-   *
-   * @param useArtwork Whether artwork is displayed.
-   */
-  public void setUseArtwork(boolean useArtwork) {
-    Assertions.checkState(!useArtwork || artworkView != null);
-    if (this.useArtwork != useArtwork) {
-      this.useArtwork = useArtwork;
-      updateForCurrentTrackSelections();
-    }
-  }
-
-  /**
-   * Returns the default artwork to display.
-   */
-  public Bitmap getDefaultArtwork() {
-    return defaultArtwork;
-  }
-
-  /**
-   * Sets the default artwork to display if {@code useArtwork} is {@code true} and no artwork is
-   * present in the media.
-   *
-   * @param defaultArtwork the default artwork to display.
-   */
-  public void setDefaultArtwork(Bitmap defaultArtwork) {
-    if (this.defaultArtwork != defaultArtwork) {
-      this.defaultArtwork = defaultArtwork;
-      updateForCurrentTrackSelections();
-    }
-  }
-
-  /**
-   * Returns whether the playback controls can be shown.
-   */
-  public boolean getUseController() {
-    return useController;
-  }
-
-  /**
-   * Sets whether the playback controls can be shown. If set to {@code false} the playback controls
-   * are never visible and are disconnected from the player.
-   *
-   * @param useController Whether the playback controls can be shown.
-   */
-  public void setUseController(boolean useController) {
-    Assertions.checkState(!useController || controller != null);
-    if (this.useController == useController) {
-      return;
-    }
-    this.useController = useController;
-    if (useController) {
-      controller.setPlayer(player);
-    } else if (controller != null) {
-      controller.hide();
-      controller.setPlayer(null);
-    }
-  }
-
-  /**
-   * Sets the background color of the {@code exo_shutter} view.
-   *
-   * @param color The background color.
-   */
-  public void setShutterBackgroundColor(int color) {
-    if (shutterView != null) {
-      shutterView.setBackgroundColor(color);
-    }
-  }
-
-  @Override
-  public boolean dispatchKeyEvent(KeyEvent event) {
-    if (player != null && player.isPlayingAd()) {
-      // Focus any overlay UI now, in case it's provided by a WebView whose contents may update
-      // dynamically. This is needed to make the "Skip ad" button focused on Android TV when using
-      // IMA [Internal: b/62371030].
-      overlayFrameLayout.requestFocus();
-      return super.dispatchKeyEvent(event);
-    }
-    boolean isDpadWhenControlHidden = isDpadKey(event.getKeyCode()) && useController
-        && !controller.isVisible();
-    maybeShowController(true);
-    return isDpadWhenControlHidden || dispatchMediaKeyEvent(event) || super.dispatchKeyEvent(event);
-  }
-
-  /**
-   * Called to process media key events. Any {@link KeyEvent} can be passed but only media key
-   * events will be handled. Does nothing if playback controls are disabled.
-   *
-   * @param event A key event.
-   * @return Whether the key event was handled.
-   */
-  public boolean dispatchMediaKeyEvent(KeyEvent event) {
-    return useController && controller.dispatchMediaKeyEvent(event);
-  }
-
-  /**
-   * Shows the playback controls. Does nothing if playback controls are disabled.
-   *
-   * <p>The playback controls are automatically hidden during playback after
-   * {{@link #getControllerShowTimeoutMs()}}. They are shown indefinitely when playback has not
-   * started yet, is paused, has ended or failed.
-   */
-  public void showController() {
-    showController(shouldShowControllerIndefinitely());
-  }
-
-  /**
-   * Hides the playback controls. Does nothing if playback controls are disabled.
-   */
-  public void hideController() {
-    if (controller != null) {
-      controller.hide();
-    }
-  }
-
-  /**
-   * Returns the playback controls timeout. The playback controls are automatically hidden after
-   * this duration of time has elapsed without user input and with playback or buffering in
-   * progress.
-   *
-   * @return The timeout in milliseconds. A non-positive value will cause the controller to remain
-   *     visible indefinitely.
-   */
-  public int getControllerShowTimeoutMs() {
-    return controllerShowTimeoutMs;
-  }
-
-  /**
-   * Sets the playback controls timeout. The playback controls are automatically hidden after this
-   * duration of time has elapsed without user input and with playback or buffering in progress.
-   *
-   * @param controllerShowTimeoutMs The timeout in milliseconds. A non-positive value will cause
-   *     the controller to remain visible indefinitely.
-   */
-  public void setControllerShowTimeoutMs(int controllerShowTimeoutMs) {
-    Assertions.checkState(controller != null);
-    this.controllerShowTimeoutMs = controllerShowTimeoutMs;
-  }
-
-  /**
-   * Returns whether the playback controls are hidden by touch events.
-   */
-  public boolean getControllerHideOnTouch() {
-    return controllerHideOnTouch;
-  }
-
-  /**
-   * Sets whether the playback controls are hidden by touch events.
-   *
-   * @param controllerHideOnTouch Whether the playback controls are hidden by touch events.
-   */
-  public void setControllerHideOnTouch(boolean controllerHideOnTouch) {
-    Assertions.checkState(controller != null);
-    this.controllerHideOnTouch = controllerHideOnTouch;
-  }
-
-  /**
-   * Returns whether the playback controls are automatically shown when playback starts, pauses,
-   * ends, or fails. If set to false, the playback controls can be manually operated with {@link
-   * #showController()} and {@link #hideController()}.
-   */
-  public boolean getControllerAutoShow() {
-    return controllerAutoShow;
-  }
-
-  /**
-   * Sets whether the playback controls are automatically shown when playback starts, pauses, ends,
-   * or fails. If set to false, the playback controls can be manually operated with {@link
-   * #showController()} and {@link #hideController()}.
-   *
-   * @param controllerAutoShow Whether the playback controls are allowed to show automatically.
-   */
-  public void setControllerAutoShow(boolean controllerAutoShow) {
-    this.controllerAutoShow = controllerAutoShow;
-  }
-
-  /**
-   * Set the {@link PlaybackControlView.VisibilityListener}.
-   *
-   * @param listener The listener to be notified about visibility changes.
-   */
-  public void setControllerVisibilityListener(PlaybackControlView.VisibilityListener listener) {
-    Assertions.checkState(controller != null);
-    controller.setVisibilityListener(listener);
-  }
-
-  /**
-   * Sets the {@link ControlDispatcher}.
-   *
-   * @param controlDispatcher The {@link ControlDispatcher}, or null to use
-   *     {@link DefaultControlDispatcher}.
-   */
-  public void setControlDispatcher(@Nullable ControlDispatcher controlDispatcher) {
-    Assertions.checkState(controller != null);
-    controller.setControlDispatcher(controlDispatcher);
-  }
-
-  /**
-   * Sets the rewind increment in milliseconds.
-   *
-   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
-   *     rewind button to be disabled.
-   */
-  public void setRewindIncrementMs(int rewindMs) {
-    Assertions.checkState(controller != null);
-    controller.setRewindIncrementMs(rewindMs);
-  }
-
-  /**
-   * Sets the fast forward increment in milliseconds.
-   *
-   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
-   *     cause the fast forward button to be disabled.
-   */
-  public void setFastForwardIncrementMs(int fastForwardMs) {
-    Assertions.checkState(controller != null);
-    controller.setFastForwardIncrementMs(fastForwardMs);
-  }
-
-  /**
-   * Sets which repeat toggle modes are enabled.
-   *
-   * @param repeatToggleModes A set of {@link RepeatModeUtil.RepeatToggleModes}.
-   */
-  public void setRepeatToggleModes(@RepeatModeUtil.RepeatToggleModes int repeatToggleModes) {
-    Assertions.checkState(controller != null);
-    controller.setRepeatToggleModes(repeatToggleModes);
-  }
-
-  /**
-   * Sets whether the shuffle button is shown.
-   *
-   * @param showShuffleButton Whether the shuffle button is shown.
-   */
-  public void setShowShuffleButton(boolean showShuffleButton) {
-    Assertions.checkState(controller != null);
-    controller.setShowShuffleButton(showShuffleButton);
-  }
-
-  /**
-   * Sets whether the time bar should show all windows, as opposed to just the current one.
-   *
-   * @param showMultiWindowTimeBar Whether to show all windows.
-   */
-  public void setShowMultiWindowTimeBar(boolean showMultiWindowTimeBar) {
-    Assertions.checkState(controller != null);
-    controller.setShowMultiWindowTimeBar(showMultiWindowTimeBar);
-  }
-
-  /**
-   * Gets the view onto which video is rendered. This is a:
-   * <ul>
-   *   <li>{@link SurfaceView} by default, or if the {@code surface_type} attribute is set to
-   *   {@code surface_view}.</li>
-   *   <li>{@link TextureView} if {@code surface_type} is {@code texture_view}.</li>
-   *   <li>{@code null} if {@code surface_type} is {@code none}.</li>
-   * </ul>
-   *
-   * @return The {@link SurfaceView}, {@link TextureView} or {@code null}.
-   */
-  public View getVideoSurfaceView() {
-    return surfaceView;
-  }
-
-  /**
-   * Gets the overlay {@link FrameLayout}, which can be populated with UI elements to show on top of
-   * the player.
-   *
-   * @return The overlay {@link FrameLayout}, or {@code null} if the layout has been customized and
-   *     the overlay is not present.
-   */
-  public FrameLayout getOverlayFrameLayout() {
-    return overlayFrameLayout;
-  }
-
-  /**
-   * Gets the {@link SubtitleView}.
-   *
-   * @return The {@link SubtitleView}, or {@code null} if the layout has been customized and the
-   *     subtitle view is not present.
-   */
-  public SubtitleView getSubtitleView() {
-    return subtitleView;
-  }
-
-  @Override
-  public boolean onTouchEvent(MotionEvent ev) {
-    if (!useController || player == null || ev.getActionMasked() != MotionEvent.ACTION_DOWN) {
-      return false;
-    }
-    if (!controller.isVisible()) {
-      maybeShowController(true);
-    } else if (controllerHideOnTouch) {
-      controller.hide();
-    }
-    return true;
-  }
-
-  @Override
-  public boolean onTrackballEvent(MotionEvent ev) {
-    if (!useController || player == null) {
-      return false;
-    }
-    maybeShowController(true);
-    return true;
-  }
-
-  /**
-   * Shows the playback controls, but only if forced or shown indefinitely.
-   */
-  private void maybeShowController(boolean isForced) {
-    if (isPlayingAd()) {
-      // Never show the controller if an ad is currently playing.
-      return;
-    }
-    if (useController) {
-      boolean wasShowingIndefinitely = controller.isVisible() && controller.getShowTimeoutMs() <= 0;
-      boolean shouldShowIndefinitely = shouldShowControllerIndefinitely();
-      if (isForced || wasShowingIndefinitely || shouldShowIndefinitely) {
-        showController(shouldShowIndefinitely);
-      }
-    }
-  }
-
-  private boolean shouldShowControllerIndefinitely() {
-    if (player == null) {
-      return true;
-    }
-    int playbackState = player.getPlaybackState();
-    return controllerAutoShow && (playbackState == Player.STATE_IDLE
-        || playbackState == Player.STATE_ENDED || !player.getPlayWhenReady());
-  }
-
-  private void showController(boolean showIndefinitely) {
-    if (!useController) {
-      return;
-    }
-    controller.setShowTimeoutMs(showIndefinitely ? 0 : controllerShowTimeoutMs);
-    controller.show();
-  }
-
-  private boolean isPlayingAd() {
-    return player != null && player.isPlayingAd() && player.getPlayWhenReady();
-  }
-
-  private void updateForCurrentTrackSelections() {
-    if (player == null) {
-      return;
-    }
-    TrackSelectionArray selections = player.getCurrentTrackSelections();
-    for (int i = 0; i < selections.length; i++) {
-      if (player.getRendererType(i) == C.TRACK_TYPE_VIDEO && selections.get(i) != null) {
-        // Video enabled so artwork must be hidden. If the shutter is closed, it will be opened in
-        // onRenderedFirstFrame().
-        hideArtwork();
-        return;
-      }
-    }
-    // Video disabled so the shutter must be closed.
-    if (shutterView != null) {
-      shutterView.setVisibility(VISIBLE);
-    }
-    // Display artwork if enabled and available, else hide it.
-    if (useArtwork) {
-      for (int i = 0; i < selections.length; i++) {
-        TrackSelection selection = selections.get(i);
-        if (selection != null) {
-          for (int j = 0; j < selection.length(); j++) {
-            Metadata metadata = selection.getFormat(j).metadata;
-            if (metadata != null && setArtworkFromMetadata(metadata)) {
-              return;
-            }
-          }
-        }
-      }
-      if (setArtworkFromBitmap(defaultArtwork)) {
-        return;
-      }
-    }
-    // Artwork disabled or unavailable.
-    hideArtwork();
-  }
-
-  private boolean setArtworkFromMetadata(Metadata metadata) {
-    for (int i = 0; i < metadata.length(); i++) {
-      Metadata.Entry metadataEntry = metadata.get(i);
-      if (metadataEntry instanceof ApicFrame) {
-        byte[] bitmapData = ((ApicFrame) metadataEntry).pictureData;
-        Bitmap bitmap = BitmapFactory.decodeByteArray(bitmapData, 0, bitmapData.length);
-        return setArtworkFromBitmap(bitmap);
-      }
-    }
-    return false;
-  }
-
-  private boolean setArtworkFromBitmap(Bitmap bitmap) {
-    if (bitmap != null) {
-      int bitmapWidth = bitmap.getWidth();
-      int bitmapHeight = bitmap.getHeight();
-      if (bitmapWidth > 0 && bitmapHeight > 0) {
-        if (contentFrame != null) {
-          contentFrame.setAspectRatio((float) bitmapWidth / bitmapHeight);
-        }
-        artworkView.setImageBitmap(bitmap);
-        artworkView.setVisibility(VISIBLE);
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private void hideArtwork() {
-    if (artworkView != null) {
-      artworkView.setImageResource(android.R.color.transparent); // Clears any bitmap reference.
-      artworkView.setVisibility(INVISIBLE);
-    }
-  }
-
-  @TargetApi(23)
-  private static void configureEditModeLogoV23(Resources resources, ImageView logo) {
-    logo.setImageDrawable(resources.getDrawable(R.drawable.exo_edit_mode_logo, null));
-    logo.setBackgroundColor(resources.getColor(R.color.exo_edit_mode_background_color, null));
-  }
-
-  @SuppressWarnings("deprecation")
-  private static void configureEditModeLogo(Resources resources, ImageView logo) {
-    logo.setImageDrawable(resources.getDrawable(R.drawable.exo_edit_mode_logo));
-    logo.setBackgroundColor(resources.getColor(R.color.exo_edit_mode_background_color));
-  }
-
-  @SuppressWarnings("ResourceType")
-  private static void setResizeModeRaw(AspectRatioFrameLayout aspectRatioFrame, int resizeMode) {
-    aspectRatioFrame.setResizeMode(resizeMode);
-  }
-
-  @SuppressLint("InlinedApi")
-  private boolean isDpadKey(int keyCode) {
-    return keyCode == KeyEvent.KEYCODE_DPAD_UP || keyCode == KeyEvent.KEYCODE_DPAD_UP_RIGHT
-        || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_RIGHT
-        || keyCode == KeyEvent.KEYCODE_DPAD_DOWN || keyCode == KeyEvent.KEYCODE_DPAD_DOWN_LEFT
-        || keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_UP_LEFT
-        || keyCode == KeyEvent.KEYCODE_DPAD_CENTER;
-  }
-
-  private final class ComponentListener extends Player.DefaultEventListener implements TextOutput,
-      SimpleExoPlayer.VideoListener {
-
-    // TextOutput implementation
-
-    @Override
-    public void onCues(List<Cue> cues) {
-      if (subtitleView != null) {
-        subtitleView.onCues(cues);
-      }
-    }
-
-    // SimpleExoPlayer.VideoInfoListener implementation
-
-    @Override
-    public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees,
-        float pixelWidthHeightRatio) {
-      if (contentFrame != null) {
-        float aspectRatio = height == 0 ? 1 : (width * pixelWidthHeightRatio) / height;
-        contentFrame.setAspectRatio(aspectRatio);
-      }
-    }
-
-    @Override
-    public void onRenderedFirstFrame() {
-      if (shutterView != null) {
-        shutterView.setVisibility(INVISIBLE);
-      }
-    }
-
-    @Override
-    public void onTracksChanged(TrackGroupArray tracks, TrackSelectionArray selections) {
-      updateForCurrentTrackSelections();
-    }
-
-    // Player.EventListener implementation
-
-    @Override
-    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-      if (isPlayingAd()) {
-        hideController();
-      } else {
-        maybeShowController(false);
-      }
-    }
-
-    @Override
-    public void onPositionDiscontinuity(@DiscontinuityReason int reason) {
-      if (isPlayingAd()) {
-        hideController();
-      }
-    }
-
+  public static void switchTargetView(
+      @NonNull SimpleExoPlayer player,
+      @Nullable SimpleExoPlayerView oldPlayerView,
+      @Nullable SimpleExoPlayerView newPlayerView) {
+    PlayerView.switchTargetView(player, oldPlayerView, newPlayerView);
   }
 
 }
diff --git a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
index 618f2fa336..d89f82b7c4 100644
--- a/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
+++ b/library/ui/src/main/java/com/google/android/exoplayer2/ui/SubtitleView.java
@@ -19,6 +19,7 @@
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Canvas;
+import android.support.annotation.Nullable;
 import android.util.AttributeSet;
 import android.util.TypedValue;
 import android.view.View;
@@ -87,9 +88,9 @@ public void onCues(List<Cue> cues) {
   /**
    * Sets the cues to be displayed by the view.
    *
-   * @param cues The cues to display.
+   * @param cues The cues to display, or null to clear the cues.
    */
-  public void setCues(List<Cue> cues) {
+  public void setCues(@Nullable List<Cue> cues) {
     if (this.cues == cues) {
       return;
     }
diff --git a/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_fullscreen_enter.xml b/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_fullscreen_enter.xml
new file mode 100644
index 0000000000..db11f299be
--- /dev/null
+++ b/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_fullscreen_enter.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:viewportWidth="24"
+    android:viewportHeight="24"
+    android:width="48dp"
+    android:height="48dp">
+  <path
+      android:pathData="M7 14l-2 0 0 5 5 0 0 -2 -3 0 0 -3zm-2 -4l2 0 0 -3 3 0 0 -2 -5 0 0 5zm12 7l-3 0 0 2 5 0 0 -5 -2 0 0 3zm-3 -12l0 2 3 0 0 3 2 0 0 -5 -5 0z"
+      android:fillColor="#FFFFFF" />
+</vector>
diff --git a/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_fullscreen_exit.xml b/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_fullscreen_exit.xml
new file mode 100644
index 0000000000..782d9ff34d
--- /dev/null
+++ b/library/ui/src/main/res/drawable-anydpi-v21/exo_controls_fullscreen_exit.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:viewportWidth="24"
+    android:viewportHeight="24"
+    android:width="48dp"
+    android:height="48dp">
+  <path
+      android:pathData="M5 16l3 0 0 3 2 0 0 -5 -5 0 0 2zm3 -8l-3 0 0 2 5 0 0 -5 -2 0 0 3zm6 11l2 0 0 -3 3 0 0 -2 -5 0 0 5zm2 -11l0 -3 -2 0 0 5 5 0 0 -2 -3 0z"
+      android:fillColor="#FFFFFF" />
+</vector>
diff --git a/library/ui/src/main/res/drawable-hdpi/exo_controls_fullscreen_enter.png b/library/ui/src/main/res/drawable-hdpi/exo_controls_fullscreen_enter.png
new file mode 100644
index 0000000000..9b8131124d
Binary files /dev/null and b/library/ui/src/main/res/drawable-hdpi/exo_controls_fullscreen_enter.png differ
diff --git a/library/ui/src/main/res/drawable-hdpi/exo_controls_fullscreen_exit.png b/library/ui/src/main/res/drawable-hdpi/exo_controls_fullscreen_exit.png
new file mode 100644
index 0000000000..159bea7fd8
Binary files /dev/null and b/library/ui/src/main/res/drawable-hdpi/exo_controls_fullscreen_exit.png differ
diff --git a/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_enter.png b/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_enter.png
new file mode 100644
index 0000000000..9b8131124d
Binary files /dev/null and b/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_enter.png differ
diff --git a/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_exit.png b/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_exit.png
new file mode 100644
index 0000000000..159bea7fd8
Binary files /dev/null and b/library/ui/src/main/res/drawable-ldpi/exo_controls_fullscreen_exit.png differ
diff --git a/library/ui/src/main/res/drawable-mdpi/exo_controls_fullscreen_enter.png b/library/ui/src/main/res/drawable-mdpi/exo_controls_fullscreen_enter.png
new file mode 100644
index 0000000000..4423c7ce99
Binary files /dev/null and b/library/ui/src/main/res/drawable-mdpi/exo_controls_fullscreen_enter.png differ
diff --git a/library/ui/src/main/res/drawable-mdpi/exo_controls_fullscreen_exit.png b/library/ui/src/main/res/drawable-mdpi/exo_controls_fullscreen_exit.png
new file mode 100644
index 0000000000..364bad0b84
Binary files /dev/null and b/library/ui/src/main/res/drawable-mdpi/exo_controls_fullscreen_exit.png differ
diff --git a/library/ui/src/main/res/drawable-xhdpi/exo_controls_fullscreen_enter.png b/library/ui/src/main/res/drawable-xhdpi/exo_controls_fullscreen_enter.png
new file mode 100644
index 0000000000..c1dcfb2902
Binary files /dev/null and b/library/ui/src/main/res/drawable-xhdpi/exo_controls_fullscreen_enter.png differ
diff --git a/library/ui/src/main/res/drawable-xhdpi/exo_controls_fullscreen_exit.png b/library/ui/src/main/res/drawable-xhdpi/exo_controls_fullscreen_exit.png
new file mode 100644
index 0000000000..ef360fe40c
Binary files /dev/null and b/library/ui/src/main/res/drawable-xhdpi/exo_controls_fullscreen_exit.png differ
diff --git a/library/ui/src/main/res/drawable-xxhdpi/exo_controls_fullscreen_enter.png b/library/ui/src/main/res/drawable-xxhdpi/exo_controls_fullscreen_enter.png
new file mode 100644
index 0000000000..a0a1b4d4f3
Binary files /dev/null and b/library/ui/src/main/res/drawable-xxhdpi/exo_controls_fullscreen_enter.png differ
diff --git a/library/ui/src/main/res/drawable-xxhdpi/exo_controls_fullscreen_exit.png b/library/ui/src/main/res/drawable-xxhdpi/exo_controls_fullscreen_exit.png
new file mode 100644
index 0000000000..b7f4133fd9
Binary files /dev/null and b/library/ui/src/main/res/drawable-xxhdpi/exo_controls_fullscreen_exit.png differ
diff --git a/library/ui/src/main/res/layout/exo_player_control_view.xml b/library/ui/src/main/res/layout/exo_player_control_view.xml
new file mode 100644
index 0000000000..fd221e5d84
--- /dev/null
+++ b/library/ui/src/main/res/layout/exo_player_control_view.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<merge>
+  <include layout="@layout/exo_playback_control_view"/>
+</merge>
diff --git a/library/ui/src/main/res/layout/exo_player_view.xml b/library/ui/src/main/res/layout/exo_player_view.xml
new file mode 100644
index 0000000000..dc6dda1667
--- /dev/null
+++ b/library/ui/src/main/res/layout/exo_player_view.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<merge>
+  <include layout="@layout/exo_simple_player_view"/>
+</merge>
diff --git a/library/ui/src/main/res/values-af/strings.xml b/library/ui/src/main/res/values-af/strings.xml
index 2510552c0c..f8b249d57d 100644
--- a/library/ui/src/main/res/values-af/strings.xml
+++ b/library/ui/src/main/res/values-af/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Vorige snit"</string>
-  <string name="exo_controls_next_description">"Volgende snit"</string>
-  <string name="exo_controls_pause_description">"Wag"</string>
-  <string name="exo_controls_play_description">"Speel"</string>
-  <string name="exo_controls_stop_description">"Stop"</string>
-  <string name="exo_controls_rewind_description">"Spoel terug"</string>
-  <string name="exo_controls_fastforward_description">"Vinnig vorentoe"</string>
-  <string name="exo_controls_repeat_all_description">"Herhaal alles"</string>
-  <string name="exo_controls_repeat_off_description">"Herhaal niks"</string>
-  <string name="exo_controls_repeat_one_description">"Herhaal een"</string>
-  <string name="exo_controls_shuffle_description">"Skommel"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Vorige snit"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Volgende snit"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Onderbreek"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Speel"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Stop"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Spoel terug"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Spoel vorentoe"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Herhaal niks"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Herhaal een"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Herhaal alles"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Skommel"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-am/strings.xml b/library/ui/src/main/res/values-am/strings.xml
index 165b5eee62..38e805eef6 100644
--- a/library/ui/src/main/res/values-am/strings.xml
+++ b/library/ui/src/main/res/values-am/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"ቀዳሚ ትራክ"</string>
-  <string name="exo_controls_next_description">"ቀጣይ ትራክ"</string>
-  <string name="exo_controls_pause_description">"ለአፍታ አቁም"</string>
-  <string name="exo_controls_play_description">"አጫውት"</string>
-  <string name="exo_controls_stop_description">"አቁም"</string>
-  <string name="exo_controls_rewind_description">"ወደኋላ አጠንጥን"</string>
-  <string name="exo_controls_fastforward_description">"በፍጥነት አሳልፍ"</string>
-  <string name="exo_controls_repeat_all_description">"ሁሉንም ድገም"</string>
-  <string name="exo_controls_repeat_off_description">"ምንም አትድገም"</string>
-  <string name="exo_controls_repeat_one_description">"አንዱን ድገም"</string>
-  <string name="exo_controls_shuffle_description">"በው"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"ቀዳሚ ትራክ"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"ቀጣይ ትራክ"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"ላፍታ አቁም"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"አጫውት"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"አቁም"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"ወደኋላ መልስ"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"በፍጥነት አሳልፍ"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"ምንም አትድገም"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"አንድ ድገም"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"ሁሉንም ድገም"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"በውዝ"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ar/strings.xml b/library/ui/src/main/res/values-ar/strings.xml
index 239f01be6b..98c1b555a2 100644
--- a/library/ui/src/main/res/values-ar/strings.xml
+++ b/library/ui/src/main/res/values-ar/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"المقطع الصوتي السابق"</string>
-  <string name="exo_controls_next_description">"المقطع الصوتي التالي"</string>
-  <string name="exo_controls_pause_description">"إيقاف مؤقت"</string>
-  <string name="exo_controls_play_description">"تشغيل"</string>
-  <string name="exo_controls_stop_description">"إيقاف"</string>
-  <string name="exo_controls_rewind_description">"إرجاع"</string>
-  <string name="exo_controls_fastforward_description">"تقديم سريع"</string>
-  <string name="exo_controls_repeat_all_description">"تكرار الكل"</string>
-  <string name="exo_controls_repeat_off_description">"عدم التكرار"</string>
-  <string name="exo_controls_repeat_one_description">"تكرار مقطع واحد"</string>
-  <string name="exo_controls_shuffle_description">"ترتيب عشوائي"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"المقطع الصوتي السابق"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"المقطع الصوتي التالي"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"إيقاف مؤقت"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"تشغيل"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"إيقاف"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"إرجاع"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"تقديم سريع"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"عدم التكرار"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"تكرار مقطع صوتي واحد"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"تكرار الكل"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"ترتيب عشوائي"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-b+sr+Latn/strings.xml b/library/ui/src/main/res/values-b+sr+Latn/strings.xml
index a9d35e5cb6..e66605b599 100644
--- a/library/ui/src/main/res/values-b+sr+Latn/strings.xml
+++ b/library/ui/src/main/res/values-b+sr+Latn/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Prethodna pesma"</string>
-  <string name="exo_controls_next_description">"Sledeća pesma"</string>
-  <string name="exo_controls_pause_description">"Pauza"</string>
-  <string name="exo_controls_play_description">"Pusti"</string>
-  <string name="exo_controls_stop_description">"Zaustavi"</string>
-  <string name="exo_controls_rewind_description">"Premotaj unazad"</string>
-  <string name="exo_controls_fastforward_description">"Premotaj unapred"</string>
-  <string name="exo_controls_repeat_all_description">"Ponovi sve"</string>
-  <string name="exo_controls_repeat_off_description">"Ne ponavljaj nijednu"</string>
-  <string name="exo_controls_repeat_one_description">"Ponovi jednu"</string>
-  <string name="exo_controls_shuffle_description">"Pusti nasumično"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Prethodna pesma"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Sledeća pesma"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pauziraj"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Pusti"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Zaustavi"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Premotaj unazad"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Premotaj unapred"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Ne ponavljaj nijednu"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Ponovi jednu"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Ponovi sve"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Pusti nasumično"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-bg/strings.xml b/library/ui/src/main/res/values-bg/strings.xml
index e350479788..6eb4e8881a 100644
--- a/library/ui/src/main/res/values-bg/strings.xml
+++ b/library/ui/src/main/res/values-bg/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Предишен запис"</string>
-  <string name="exo_controls_next_description">"Следващ запис"</string>
-  <string name="exo_controls_pause_description">"Пауза"</string>
-  <string name="exo_controls_play_description">"Пускане"</string>
-  <string name="exo_controls_stop_description">"Спиране"</string>
-  <string name="exo_controls_rewind_description">"Превъртане назад"</string>
-  <string name="exo_controls_fastforward_description">"Превъртане напред"</string>
-  <string name="exo_controls_repeat_all_description">"Повтаряне на всички"</string>
-  <string name="exo_controls_repeat_off_description">"Без повтаряне"</string>
-  <string name="exo_controls_repeat_one_description">"Повтаряне на един елемент"</string>
-  <string name="exo_controls_shuffle_description">"Разбъркване"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Предишен запис"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Следващ запис"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Поставяне на пауза"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Възпроизвеждане"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Спиране"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Превъртане назад"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Превъртане напред"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Без повтаряне"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Повтаряне на един елемент"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Повтаряне на всички"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Разбъркване"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ca/strings.xml b/library/ui/src/main/res/values-ca/strings.xml
index fd76a8e08e..0e2512c061 100644
--- a/library/ui/src/main/res/values-ca/strings.xml
+++ b/library/ui/src/main/res/values-ca/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Ruta anterior"</string>
-  <string name="exo_controls_next_description">"Ruta següent"</string>
-  <string name="exo_controls_pause_description">"Posa en pausa"</string>
-  <string name="exo_controls_play_description">"Reprodueix"</string>
-  <string name="exo_controls_stop_description">"Atura"</string>
-  <string name="exo_controls_rewind_description">"Rebobina"</string>
-  <string name="exo_controls_fastforward_description">"Avança ràpidament"</string>
-  <string name="exo_controls_repeat_all_description">"Repeteix-ho tot"</string>
-  <string name="exo_controls_repeat_off_description">"No en repeteixis cap"</string>
-  <string name="exo_controls_repeat_one_description">"Repeteix-ne un"</string>
-  <string name="exo_controls_shuffle_description">"Reprodueix aleatòriament"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Pista anterior"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Pista següent"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Posa en pausa"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Reprodueix"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Atura"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Rebobina"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Avança ràpidament"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"No en repeteixis cap"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Repeteix una"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Repeteix tot"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Reprodueix aleatòriament"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-cs/strings.xml b/library/ui/src/main/res/values-cs/strings.xml
index 087ab79c25..e397968647 100644
--- a/library/ui/src/main/res/values-cs/strings.xml
+++ b/library/ui/src/main/res/values-cs/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Předchozí skladba"</string>
-  <string name="exo_controls_next_description">"Další skladba"</string>
-  <string name="exo_controls_pause_description">"Pozastavit"</string>
-  <string name="exo_controls_play_description">"Přehrát"</string>
-  <string name="exo_controls_stop_description">"Zastavit"</string>
-  <string name="exo_controls_rewind_description">"Přetočit zpět"</string>
-  <string name="exo_controls_fastforward_description">"Přetočit vpřed"</string>
-  <string name="exo_controls_repeat_all_description">"Opakovat vše"</string>
-  <string name="exo_controls_repeat_off_description">"Neopakovat"</string>
-  <string name="exo_controls_repeat_one_description">"Opakovat jednu položku"</string>
-  <string name="exo_controls_shuffle_description">"Náhodně"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Předchozí skladba"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Další skladba"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pozastavit"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Přehrát"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Zastavit"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Přetočit zpět"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Rychle vpřed"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Neopakovat"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Opakovat jednu"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Opakovat vše"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Náhodně"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-da/strings.xml b/library/ui/src/main/res/values-da/strings.xml
index 0ae23ee288..7a909daba4 100644
--- a/library/ui/src/main/res/values-da/strings.xml
+++ b/library/ui/src/main/res/values-da/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Forrige nummer"</string>
-  <string name="exo_controls_next_description">"Næste nummer"</string>
-  <string name="exo_controls_pause_description">"Pause"</string>
-  <string name="exo_controls_play_description">"Afspil"</string>
-  <string name="exo_controls_stop_description">"Stop"</string>
-  <string name="exo_controls_rewind_description">"Spol tilbage"</string>
-  <string name="exo_controls_fastforward_description">"Spol frem"</string>
-  <string name="exo_controls_repeat_all_description">"Gentag alle"</string>
-  <string name="exo_controls_repeat_off_description">"Gentag ingen"</string>
-  <string name="exo_controls_repeat_one_description">"Gentag en"</string>
-  <string name="exo_controls_shuffle_description">"Bland"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Afspil forrige"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Afspil næste"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Sæt på pause"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Afspil"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Stop"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Spol tilbage"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Spol frem"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Gentag ingen"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Gentag én"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Gentag alle"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Bland"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-de/strings.xml b/library/ui/src/main/res/values-de/strings.xml
index 37ca6c44ac..b40fce1fb5 100644
--- a/library/ui/src/main/res/values-de/strings.xml
+++ b/library/ui/src/main/res/values-de/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Vorheriger Titel"</string>
-  <string name="exo_controls_next_description">"Nächster Titel"</string>
-  <string name="exo_controls_pause_description">"Pausieren"</string>
-  <string name="exo_controls_play_description">"Wiedergabe"</string>
-  <string name="exo_controls_stop_description">"Beenden"</string>
-  <string name="exo_controls_rewind_description">"Zurückspulen"</string>
-  <string name="exo_controls_fastforward_description">"Vorspulen"</string>
-  <string name="exo_controls_repeat_all_description">"Alle wiederholen"</string>
-  <string name="exo_controls_repeat_off_description">"Keinen Titel wiederholen"</string>
-  <string name="exo_controls_repeat_one_description">"Einen Titel wiederholen"</string>
-  <string name="exo_controls_shuffle_description">"Zufallsmix"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Vorheriger Titel"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Nächster Titel"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pausieren"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Wiedergeben"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Beenden"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Zurückspulen"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Vorspulen"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Keinen wiederholen"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Einen wiederholen"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Alle wiederholen"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Zufallsmix"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-el/strings.xml b/library/ui/src/main/res/values-el/strings.xml
index 534192e185..4c86019d47 100644
--- a/library/ui/src/main/res/values-el/strings.xml
+++ b/library/ui/src/main/res/values-el/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Προηγούμενο κομμάτι"</string>
-  <string name="exo_controls_next_description">"Επόμενο κομμάτι"</string>
-  <string name="exo_controls_pause_description">"Παύση"</string>
-  <string name="exo_controls_play_description">"Αναπαραγωγή"</string>
-  <string name="exo_controls_stop_description">"Διακοπή"</string>
-  <string name="exo_controls_rewind_description">"Επαναφορά"</string>
-  <string name="exo_controls_fastforward_description">"Γρήγορη προώθηση"</string>
-  <string name="exo_controls_repeat_all_description">"Επανάληψη όλων"</string>
-  <string name="exo_controls_repeat_off_description">"Καμία επανάληψη"</string>
-  <string name="exo_controls_repeat_one_description">"Επανάληψη ενός στοιχείου"</string>
-  <string name="exo_controls_shuffle_description">"Τυχαία αναπαραγωγή"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Προηγούμενο κομμάτι"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Επόμενο κομμάτι"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Παύση"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Αναπαραγωγή"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Διακοπή"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Επαναφορά"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Γρήγορη προώθηση"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Καμία επανάληψη"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Επανάληψη ενός κομματιού"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Επανάληψη όλων"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Τυχαία αναπαραγωγή"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-en-rAU/strings.xml b/library/ui/src/main/res/values-en-rAU/strings.xml
index 0b4c465853..2a73a3e98e 100644
--- a/library/ui/src/main/res/values-en-rAU/strings.xml
+++ b/library/ui/src/main/res/values-en-rAU/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Previous track"</string>
-  <string name="exo_controls_next_description">"Next track"</string>
-  <string name="exo_controls_pause_description">"Pause"</string>
-  <string name="exo_controls_play_description">"Play"</string>
-  <string name="exo_controls_stop_description">"Stop"</string>
-  <string name="exo_controls_rewind_description">"Rewind"</string>
-  <string name="exo_controls_fastforward_description">"Fast-forward"</string>
-  <string name="exo_controls_repeat_all_description">"Repeat all"</string>
-  <string name="exo_controls_repeat_off_description">"Repeat none"</string>
-  <string name="exo_controls_repeat_one_description">"Repeat one"</string>
-  <string name="exo_controls_shuffle_description">"Shuffle"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Previous track"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Next track"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pause"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Play"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Stop"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Rewind"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Fast-forward"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Repeat none"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Repeat one"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Repeat all"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-en-rGB/strings.xml b/library/ui/src/main/res/values-en-rGB/strings.xml
index 0b4c465853..2a73a3e98e 100644
--- a/library/ui/src/main/res/values-en-rGB/strings.xml
+++ b/library/ui/src/main/res/values-en-rGB/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Previous track"</string>
-  <string name="exo_controls_next_description">"Next track"</string>
-  <string name="exo_controls_pause_description">"Pause"</string>
-  <string name="exo_controls_play_description">"Play"</string>
-  <string name="exo_controls_stop_description">"Stop"</string>
-  <string name="exo_controls_rewind_description">"Rewind"</string>
-  <string name="exo_controls_fastforward_description">"Fast-forward"</string>
-  <string name="exo_controls_repeat_all_description">"Repeat all"</string>
-  <string name="exo_controls_repeat_off_description">"Repeat none"</string>
-  <string name="exo_controls_repeat_one_description">"Repeat one"</string>
-  <string name="exo_controls_shuffle_description">"Shuffle"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Previous track"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Next track"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pause"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Play"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Stop"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Rewind"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Fast-forward"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Repeat none"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Repeat one"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Repeat all"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-en-rIN/strings.xml b/library/ui/src/main/res/values-en-rIN/strings.xml
index 0b4c465853..2a73a3e98e 100644
--- a/library/ui/src/main/res/values-en-rIN/strings.xml
+++ b/library/ui/src/main/res/values-en-rIN/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Previous track"</string>
-  <string name="exo_controls_next_description">"Next track"</string>
-  <string name="exo_controls_pause_description">"Pause"</string>
-  <string name="exo_controls_play_description">"Play"</string>
-  <string name="exo_controls_stop_description">"Stop"</string>
-  <string name="exo_controls_rewind_description">"Rewind"</string>
-  <string name="exo_controls_fastforward_description">"Fast-forward"</string>
-  <string name="exo_controls_repeat_all_description">"Repeat all"</string>
-  <string name="exo_controls_repeat_off_description">"Repeat none"</string>
-  <string name="exo_controls_repeat_one_description">"Repeat one"</string>
-  <string name="exo_controls_shuffle_description">"Shuffle"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Previous track"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Next track"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pause"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Play"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Stop"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Rewind"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Fast-forward"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Repeat none"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Repeat one"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Repeat all"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-es-rUS/strings.xml b/library/ui/src/main/res/values-es-rUS/strings.xml
index e6cf3fc6f2..5fca31959b 100644
--- a/library/ui/src/main/res/values-es-rUS/strings.xml
+++ b/library/ui/src/main/res/values-es-rUS/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Pista anterior"</string>
-  <string name="exo_controls_next_description">"Siguiente pista"</string>
-  <string name="exo_controls_pause_description">"Pausar"</string>
-  <string name="exo_controls_play_description">"Reproducir"</string>
-  <string name="exo_controls_stop_description">"Detener"</string>
-  <string name="exo_controls_rewind_description">"Retroceder"</string>
-  <string name="exo_controls_fastforward_description">"Avanzar"</string>
-  <string name="exo_controls_repeat_all_description">"Repetir todo"</string>
-  <string name="exo_controls_repeat_off_description">"No repetir"</string>
-  <string name="exo_controls_repeat_one_description">"Repetir uno"</string>
-  <string name="exo_controls_shuffle_description">"Reproducir aleatoriamente"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Pista anterior"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Pista siguiente"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pausar"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Reproducir"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Detener"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Retroceder"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Avanzar"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"No repetir"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Repetir uno"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Repetir todo"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Reproducir aleatoriamente"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-es/strings.xml b/library/ui/src/main/res/values-es/strings.xml
index 04e1ea038c..b4f76b2828 100644
--- a/library/ui/src/main/res/values-es/strings.xml
+++ b/library/ui/src/main/res/values-es/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Canción anterior"</string>
-  <string name="exo_controls_next_description">"Siguiente canción"</string>
-  <string name="exo_controls_pause_description">"Pausar"</string>
-  <string name="exo_controls_play_description">"Reproducir"</string>
-  <string name="exo_controls_stop_description">"Detener"</string>
-  <string name="exo_controls_rewind_description">"Rebobinar"</string>
-  <string name="exo_controls_fastforward_description">"Avance rápido"</string>
-  <string name="exo_controls_repeat_all_description">"Repetir todo"</string>
-  <string name="exo_controls_repeat_off_description">"No repetir"</string>
-  <string name="exo_controls_repeat_one_description">"Repetir uno"</string>
-  <string name="exo_controls_shuffle_description">"Reproducción aleatoria"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Pista anterior"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Siguiente pista"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pausar"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Reproducir"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Detener"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Rebobinar"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Avanzar rápidamente"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"No repetir"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Repetir uno"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Repetir todo"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Reproducir aleatoriamente"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fa/strings.xml b/library/ui/src/main/res/values-fa/strings.xml
index 101fcdbfb5..097680ae6b 100644
--- a/library/ui/src/main/res/values-fa/strings.xml
+++ b/library/ui/src/main/res/values-fa/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"آهنگ قبلی"</string>
-  <string name="exo_controls_next_description">"آهنگ بعدی"</string>
-  <string name="exo_controls_pause_description">"مکث"</string>
-  <string name="exo_controls_play_description">"پخش"</string>
-  <string name="exo_controls_stop_description">"توقف"</string>
-  <string name="exo_controls_rewind_description">"عقب بردن"</string>
-  <string name="exo_controls_fastforward_description">"جلو بردن سریع"</string>
-  <string name="exo_controls_repeat_all_description">"تکرار همه"</string>
-  <string name="exo_controls_repeat_off_description">"تکرار هیچ‌کدام"</string>
-  <string name="exo_controls_repeat_one_description">"یک‌بار تکرار"</string>
-  <string name="exo_controls_shuffle_description">"پخش درهم"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"آهنگ قبلی"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"آهنگ بعدی"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"مکث"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"پخش"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"توقف"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"عقب بردن"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"جلو بردن سریع"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"تکرار هیچ‌کدام"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"یکبار تکرار"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"تکرار همه"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"درهم"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fi/strings.xml b/library/ui/src/main/res/values-fi/strings.xml
index 92feb86683..ba93ad4d1e 100644
--- a/library/ui/src/main/res/values-fi/strings.xml
+++ b/library/ui/src/main/res/values-fi/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Edellinen raita"</string>
-  <string name="exo_controls_next_description">"Seuraava raita"</string>
-  <string name="exo_controls_pause_description">"Tauko"</string>
-  <string name="exo_controls_play_description">"Toista"</string>
-  <string name="exo_controls_stop_description">"Seis"</string>
-  <string name="exo_controls_rewind_description">"Kelaa taakse"</string>
-  <string name="exo_controls_fastforward_description">"Kelaa eteen"</string>
-  <string name="exo_controls_repeat_all_description">"Toista kaikki"</string>
-  <string name="exo_controls_repeat_off_description">"Toista ei mitään"</string>
-  <string name="exo_controls_repeat_one_description">"Toista yksi"</string>
-  <string name="exo_controls_shuffle_description">"Toista satunnaisesti"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Edellinen kappale"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Seuraava kappale"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Keskeytä"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Toista"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Lopeta"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Kelaa taaksepäin"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Kelaa eteenpäin"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Ei uudelleentoistoa"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Toista yksi uudelleen"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Toista kaikki uudelleen"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Satunnaistoisto"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fr-rCA/strings.xml b/library/ui/src/main/res/values-fr-rCA/strings.xml
index 45fc0a86f9..f08bd3d680 100644
--- a/library/ui/src/main/res/values-fr-rCA/strings.xml
+++ b/library/ui/src/main/res/values-fr-rCA/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Chanson précédente"</string>
-  <string name="exo_controls_next_description">"Chanson suivante"</string>
-  <string name="exo_controls_pause_description">"Pause"</string>
-  <string name="exo_controls_play_description">"Lecture"</string>
-  <string name="exo_controls_stop_description">"Arrêter"</string>
-  <string name="exo_controls_rewind_description">"Reculer"</string>
-  <string name="exo_controls_fastforward_description">"Avance rapide"</string>
-  <string name="exo_controls_repeat_all_description">"Tout lire en boucle"</string>
-  <string name="exo_controls_repeat_off_description">"Aucune répétition"</string>
-  <string name="exo_controls_repeat_one_description">"Répéter un élément"</string>
-  <string name="exo_controls_shuffle_description">"Lecture aléatoire"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Chanson précédente"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Chanson suivante"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pause"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Lire"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Arrêter"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Retour arrière"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Avance rapide"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Ne rien lire en boucle"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Lire une chanson en boucle"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Tout lire en boucle"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Lecture aléatoire"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-fr/strings.xml b/library/ui/src/main/res/values-fr/strings.xml
index 82b5a40626..41dc7e9605 100644
--- a/library/ui/src/main/res/values-fr/strings.xml
+++ b/library/ui/src/main/res/values-fr/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Piste précédente"</string>
-  <string name="exo_controls_next_description">"Piste suivante"</string>
-  <string name="exo_controls_pause_description">"Interrompre"</string>
-  <string name="exo_controls_play_description">"Lire"</string>
-  <string name="exo_controls_stop_description">"Arrêter"</string>
-  <string name="exo_controls_rewind_description">"Retour arrière"</string>
-  <string name="exo_controls_fastforward_description">"Avance rapide"</string>
-  <string name="exo_controls_repeat_all_description">"Tout lire en boucle"</string>
-  <string name="exo_controls_repeat_off_description">"Ne rien lire en boucle"</string>
-  <string name="exo_controls_repeat_one_description">"Lire en boucle un élément"</string>
-  <string name="exo_controls_shuffle_description">"Lire en mode aléatoire"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Titre précédent"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Titre suivant"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pause"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Lecture"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Arrêter"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Retour arrière"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Avance rapide"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Ne rien lire en boucle"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Lire un titre en boucle"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Tout lire en boucle"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Aléatoire"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hi/strings.xml b/library/ui/src/main/res/values-hi/strings.xml
index ec624b1f35..a3a0c76b80 100644
--- a/library/ui/src/main/res/values-hi/strings.xml
+++ b/library/ui/src/main/res/values-hi/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"पिछला ट्रैक"</string>
-  <string name="exo_controls_next_description">"अगला ट्रैक"</string>
-  <string name="exo_controls_pause_description">"रोकें"</string>
-  <string name="exo_controls_play_description">"चलाएं"</string>
-  <string name="exo_controls_stop_description">"बंद करें"</string>
-  <string name="exo_controls_rewind_description">"रिवाइंड करें"</string>
-  <string name="exo_controls_fastforward_description">"फ़ास्ट फ़ॉरवर्ड"</string>
-  <string name="exo_controls_repeat_all_description">"सभी को दोहराएं"</string>
-  <string name="exo_controls_repeat_off_description">"कुछ भी न दोहराएं"</string>
-  <string name="exo_controls_repeat_one_description">"एक दोहराएं"</string>
-  <string name="exo_controls_shuffle_description">"शफ़ल करें"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"पिछला ट्रैक"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"अगला ट्रैक"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"रोकें"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"चलाएं"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"बंद करें"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"पीछे ले जाएं"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"तेज़ी से आगे बढ़ाएं"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"किसी को न दोहराएं"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"एक को दोहराएं"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"सभी को दोहराएं"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"शफ़ल करें"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hr/strings.xml b/library/ui/src/main/res/values-hr/strings.xml
index 7cb23e11dd..41a3c3f2e3 100644
--- a/library/ui/src/main/res/values-hr/strings.xml
+++ b/library/ui/src/main/res/values-hr/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Prethodna pjesma"</string>
-  <string name="exo_controls_next_description">"Sljedeća pjesma"</string>
-  <string name="exo_controls_pause_description">"Pauziraj"</string>
-  <string name="exo_controls_play_description">"Reproduciraj"</string>
-  <string name="exo_controls_stop_description">"Zaustavi"</string>
-  <string name="exo_controls_rewind_description">"Unatrag"</string>
-  <string name="exo_controls_fastforward_description">"Brzo unaprijed"</string>
-  <string name="exo_controls_repeat_all_description">"Ponovi sve"</string>
-  <string name="exo_controls_repeat_off_description">"Bez ponavljanja"</string>
-  <string name="exo_controls_repeat_one_description">"Ponovi jedno"</string>
-  <string name="exo_controls_shuffle_description">"Reproduciraj nasumično"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Prethodni zapis"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Sljedeći zapis"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pauza"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Reproduciraj"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Zaustavi"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Unatrag"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Brzo unaprijed"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Bez ponavljanja"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Ponovi jedno"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Ponovi sve"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Reproduciraj nasumično"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-hu/strings.xml b/library/ui/src/main/res/values-hu/strings.xml
index cf3d34c88f..3befaa70de 100644
--- a/library/ui/src/main/res/values-hu/strings.xml
+++ b/library/ui/src/main/res/values-hu/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Előző szám"</string>
-  <string name="exo_controls_next_description">"Következő szám"</string>
-  <string name="exo_controls_pause_description">"Szünet"</string>
-  <string name="exo_controls_play_description">"Lejátszás"</string>
-  <string name="exo_controls_stop_description">"Leállítás"</string>
-  <string name="exo_controls_rewind_description">"Visszatekerés"</string>
-  <string name="exo_controls_fastforward_description">"Előretekerés"</string>
-  <string name="exo_controls_repeat_all_description">"Összes ismétlése"</string>
-  <string name="exo_controls_repeat_off_description">"Nincs ismétlés"</string>
-  <string name="exo_controls_repeat_one_description">"Egy ismétlése"</string>
-  <string name="exo_controls_shuffle_description">"Véletlenszerű lejátszás"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Előző szám"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Következő szám"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Szüneteltetés"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Lejátszás"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Leállítás"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Visszatekerés"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Előretekerés"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Nincs ismétlés"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Egy szám ismétlése"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Összes szám ismétlése"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Keverés"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-in/strings.xml b/library/ui/src/main/res/values-in/strings.xml
index 09b05815e6..636fbf0bbf 100644
--- a/library/ui/src/main/res/values-in/strings.xml
+++ b/library/ui/src/main/res/values-in/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Lagu sebelumnya"</string>
-  <string name="exo_controls_next_description">"Lagu berikutnya"</string>
-  <string name="exo_controls_pause_description">"Jeda"</string>
-  <string name="exo_controls_play_description">"Putar"</string>
-  <string name="exo_controls_stop_description">"Berhenti"</string>
-  <string name="exo_controls_rewind_description">"Putar Ulang"</string>
-  <string name="exo_controls_fastforward_description">"Maju cepat"</string>
-  <string name="exo_controls_repeat_all_description">"Ulangi Semua"</string>
-  <string name="exo_controls_repeat_off_description">"Jangan Ulangi"</string>
-  <string name="exo_controls_repeat_one_description">"Ulangi Satu"</string>
-  <string name="exo_controls_shuffle_description">"Acak"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Lagu sebelumnya"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Lagu berikutnya"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Jeda"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Putar"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Berhenti"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Putar Ulang"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Maju cepat"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Jangan ulangi"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Ulangi 1"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Ulangi semua"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Acak"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-it/strings.xml b/library/ui/src/main/res/values-it/strings.xml
index aea20db82e..a962f25072 100644
--- a/library/ui/src/main/res/values-it/strings.xml
+++ b/library/ui/src/main/res/values-it/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Traccia precedente"</string>
-  <string name="exo_controls_next_description">"Traccia successiva"</string>
-  <string name="exo_controls_pause_description">"Metti in pausa"</string>
-  <string name="exo_controls_play_description">"Riproduci"</string>
-  <string name="exo_controls_stop_description">"Interrompi"</string>
-  <string name="exo_controls_rewind_description">"Riavvolgi"</string>
-  <string name="exo_controls_fastforward_description">"Avanti veloce"</string>
-  <string name="exo_controls_repeat_all_description">"Ripeti tutti"</string>
-  <string name="exo_controls_repeat_off_description">"Non ripetere nessuno"</string>
-  <string name="exo_controls_repeat_one_description">"Ripeti uno"</string>
-  <string name="exo_controls_shuffle_description">"Riproduci casualmente"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Traccia precedente"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Traccia successiva"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pausa"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Riproduci"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Interrompi"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Riavvolgi"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Avanti veloce"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Non ripetere nulla"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Ripeti uno"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Ripeti tutto"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Riproduzione casuale"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-iw/strings.xml b/library/ui/src/main/res/values-iw/strings.xml
index dd973af50b..56d85b90a5 100644
--- a/library/ui/src/main/res/values-iw/strings.xml
+++ b/library/ui/src/main/res/values-iw/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"הרצועה הקודמת"</string>
-  <string name="exo_controls_next_description">"הרצועה הבאה"</string>
-  <string name="exo_controls_pause_description">"השהה"</string>
-  <string name="exo_controls_play_description">"הפעל"</string>
-  <string name="exo_controls_stop_description">"הפסק"</string>
-  <string name="exo_controls_rewind_description">"הרץ אחורה"</string>
-  <string name="exo_controls_fastforward_description">"הרץ קדימה"</string>
-  <string name="exo_controls_repeat_all_description">"חזור על הכל"</string>
-  <string name="exo_controls_repeat_off_description">"אל תחזור על כלום"</string>
-  <string name="exo_controls_repeat_one_description">"חזור על פריט אחד"</string>
-  <string name="exo_controls_shuffle_description">"ערבב"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"הרצועה הקודמת"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"הרצועה הבאה"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"השהיה"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"הפעלה"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"הפסקה"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"הרצה אחורה"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"הרצה קדימה"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"אל תחזור על אף פריט"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"חזור על פריט אחד"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"חזור על הכול"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"ערבוב"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ja/strings.xml b/library/ui/src/main/res/values-ja/strings.xml
index d6ce751d5c..9a6ff4f98f 100644
--- a/library/ui/src/main/res/values-ja/strings.xml
+++ b/library/ui/src/main/res/values-ja/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"前のトラック"</string>
-  <string name="exo_controls_next_description">"次のトラック"</string>
-  <string name="exo_controls_pause_description">"一時停止"</string>
-  <string name="exo_controls_play_description">"再生"</string>
-  <string name="exo_controls_stop_description">"停止"</string>
-  <string name="exo_controls_rewind_description">"巻き戻し"</string>
-  <string name="exo_controls_fastforward_description">"早送り"</string>
-  <string name="exo_controls_repeat_all_description">"全曲を繰り返し"</string>
-  <string name="exo_controls_repeat_off_description">"繰り返しなし"</string>
-  <string name="exo_controls_repeat_one_description">"1曲を繰り返し"</string>
-  <string name="exo_controls_shuffle_description">"シャッフル"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"前のトラック"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"次のトラック"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"一時停止"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"再生"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"停止"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"巻き戻し"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"早送り"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"リピートなし"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"1 曲をリピート"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"全曲をリピート"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"シャッフル"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ko/strings.xml b/library/ui/src/main/res/values-ko/strings.xml
index 99d4a2f9a4..59c0bd6647 100644
--- a/library/ui/src/main/res/values-ko/strings.xml
+++ b/library/ui/src/main/res/values-ko/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"이전 트랙"</string>
-  <string name="exo_controls_next_description">"다음 트랙"</string>
-  <string name="exo_controls_pause_description">"일시중지"</string>
-  <string name="exo_controls_play_description">"재생"</string>
-  <string name="exo_controls_stop_description">"중지"</string>
-  <string name="exo_controls_rewind_description">"되감기"</string>
-  <string name="exo_controls_fastforward_description">"빨리 감기"</string>
-  <string name="exo_controls_repeat_all_description">"전체 반복"</string>
-  <string name="exo_controls_repeat_off_description">"반복 안함"</string>
-  <string name="exo_controls_repeat_one_description">"한 항목 반복"</string>
-  <string name="exo_controls_shuffle_description">"셔플"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"이전 트랙"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"다음 트랙"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"일시중지"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"재생"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"중지"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"되감기"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"빨리 감기"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"반복 안함"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"현재 미디어 반복"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"모두 반복"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"셔플"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-lt/strings.xml b/library/ui/src/main/res/values-lt/strings.xml
index d6073f42e3..4b01d4b3cd 100644
--- a/library/ui/src/main/res/values-lt/strings.xml
+++ b/library/ui/src/main/res/values-lt/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Ankstesnis takelis"</string>
-  <string name="exo_controls_next_description">"Kitas takelis"</string>
-  <string name="exo_controls_pause_description">"Pristabdyti"</string>
-  <string name="exo_controls_play_description">"Leisti"</string>
-  <string name="exo_controls_stop_description">"Stabdyti"</string>
-  <string name="exo_controls_rewind_description">"Sukti atgal"</string>
-  <string name="exo_controls_fastforward_description">"Sukti pirmyn"</string>
-  <string name="exo_controls_repeat_all_description">"Kartoti viską"</string>
-  <string name="exo_controls_repeat_off_description">"Nekartoti nieko"</string>
-  <string name="exo_controls_repeat_one_description">"Kartoti vieną"</string>
-  <string name="exo_controls_shuffle_description">"Maišyti"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Ankstesnis takelis"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Kitas takelis"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pristabdyti"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Leisti"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Sustabdyti"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Sukti atgal"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Sukti pirmyn"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Nekartoti nieko"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Kartoti vieną"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Kartoti viską"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Maišyti"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-lv/strings.xml b/library/ui/src/main/res/values-lv/strings.xml
index 64393d679a..5920e8b1a2 100644
--- a/library/ui/src/main/res/values-lv/strings.xml
+++ b/library/ui/src/main/res/values-lv/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Iepriekšējais ieraksts"</string>
-  <string name="exo_controls_next_description">"Nākamais ieraksts"</string>
-  <string name="exo_controls_pause_description">"Pārtraukt"</string>
-  <string name="exo_controls_play_description">"Atskaņot"</string>
-  <string name="exo_controls_stop_description">"Apturēt"</string>
-  <string name="exo_controls_rewind_description">"Attīt atpakaļ"</string>
-  <string name="exo_controls_fastforward_description">"Ātri patīt"</string>
-  <string name="exo_controls_repeat_all_description">"Atkārtot visu"</string>
-  <string name="exo_controls_repeat_off_description">"Neatkārtot nevienu"</string>
-  <string name="exo_controls_repeat_one_description">"Atkārtot vienu"</string>
-  <string name="exo_controls_shuffle_description">"Atskaņot jauktā secībā"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Iepriekšējais ieraksts"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Nākamais ieraksts"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pauzēt"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Atskaņot"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Apturēt"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Attīt atpakaļ"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Pārtīt uz priekšu"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Neatkārtot nevienu"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Atkārtot vienu"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Atkārtot visu"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Atskaņot jauktā secībā"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-nb/strings.xml b/library/ui/src/main/res/values-nb/strings.xml
index 370c759b84..da7de1f1dd 100644
--- a/library/ui/src/main/res/values-nb/strings.xml
+++ b/library/ui/src/main/res/values-nb/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Forrige spor"</string>
-  <string name="exo_controls_next_description">"Neste spor"</string>
-  <string name="exo_controls_pause_description">"Sett på pause"</string>
-  <string name="exo_controls_play_description">"Spill av"</string>
-  <string name="exo_controls_stop_description">"Stopp"</string>
-  <string name="exo_controls_rewind_description">"Tilbakespoling"</string>
-  <string name="exo_controls_fastforward_description">"Fremoverspoling"</string>
-  <string name="exo_controls_repeat_all_description">"Gjenta alle"</string>
-  <string name="exo_controls_repeat_off_description">"Ikke gjenta noen"</string>
-  <string name="exo_controls_repeat_one_description">"Gjenta én"</string>
-  <string name="exo_controls_shuffle_description">"Spill av i tilfeldig rekkefølge"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Forrige spor"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Neste spor"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Sett på pause"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Spill av"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Stopp"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Spol tilbake"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Spol forover"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Ikke gjenta noen"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Gjenta én"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Gjenta alle"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Tilfeldig rekkefølge"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-nl/strings.xml b/library/ui/src/main/res/values-nl/strings.xml
index a67ab2968c..3ad2d002ca 100644
--- a/library/ui/src/main/res/values-nl/strings.xml
+++ b/library/ui/src/main/res/values-nl/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Vorig nummer"</string>
-  <string name="exo_controls_next_description">"Volgend nummer"</string>
-  <string name="exo_controls_pause_description">"Onderbreken"</string>
-  <string name="exo_controls_play_description">"Afspelen"</string>
-  <string name="exo_controls_stop_description">"Stoppen"</string>
-  <string name="exo_controls_rewind_description">"Terugspoelen"</string>
-  <string name="exo_controls_fastforward_description">"Vooruitspoelen"</string>
-  <string name="exo_controls_repeat_all_description">"Alles herhalen"</string>
-  <string name="exo_controls_repeat_off_description">"Niet herhalen"</string>
-  <string name="exo_controls_repeat_one_description">"Eén herhalen"</string>
-  <string name="exo_controls_shuffle_description">"Shuffle"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Vorige track"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Volgende track"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pauzeren"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Afspelen"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Stoppen"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Terugspoelen"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Vooruitspoelen"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Niets herhalen"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Eén herhalen"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Alles herhalen"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pl/strings.xml b/library/ui/src/main/res/values-pl/strings.xml
index ff1d77fdd5..9098e2bb9e 100644
--- a/library/ui/src/main/res/values-pl/strings.xml
+++ b/library/ui/src/main/res/values-pl/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Poprzedni utwór"</string>
-  <string name="exo_controls_next_description">"Następny utwór"</string>
-  <string name="exo_controls_pause_description">"Wstrzymaj"</string>
-  <string name="exo_controls_play_description">"Odtwórz"</string>
-  <string name="exo_controls_stop_description">"Zatrzymaj"</string>
-  <string name="exo_controls_rewind_description">"Przewiń do tyłu"</string>
-  <string name="exo_controls_fastforward_description">"Przewiń do przodu"</string>
-  <string name="exo_controls_repeat_all_description">"Powtórz wszystkie"</string>
-  <string name="exo_controls_repeat_off_description">"Nie powtarzaj"</string>
-  <string name="exo_controls_repeat_one_description">"Powtórz jeden"</string>
-  <string name="exo_controls_shuffle_description">"Odtwarzaj losowo"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Poprzedni utwór"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Następny utwór"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Wstrzymaj"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Odtwórz"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Zatrzymaj"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Przewiń do tyłu"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Przewiń do przodu"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Nie powtarzaj"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Powtórz jeden"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Powtórz wszystkie"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Odtwarzanie losowe"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pt-rPT/strings.xml b/library/ui/src/main/res/values-pt-rPT/strings.xml
index 5a7144e36b..ede4093c94 100644
--- a/library/ui/src/main/res/values-pt-rPT/strings.xml
+++ b/library/ui/src/main/res/values-pt-rPT/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Faixa anterior"</string>
-  <string name="exo_controls_next_description">"Faixa seguinte"</string>
-  <string name="exo_controls_pause_description">"Interromper"</string>
-  <string name="exo_controls_play_description">"Reproduzir"</string>
-  <string name="exo_controls_stop_description">"Parar"</string>
-  <string name="exo_controls_rewind_description">"Rebobinar"</string>
-  <string name="exo_controls_fastforward_description">"Avançar"</string>
-  <string name="exo_controls_repeat_all_description">"Repetir tudo"</string>
-  <string name="exo_controls_repeat_off_description">"Não repetir"</string>
-  <string name="exo_controls_repeat_one_description">"Repetir um"</string>
-  <string name="exo_controls_shuffle_description">"Reproduzir aleatoriamente"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Faixa anterior"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Faixa seguinte"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Colocar em pausa"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Reproduzir"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Parar"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Recuar"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Avançar"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Não repetir nenhum"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Repetir um"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Repetir tudo"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Reproduzir aleatoriamente"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-pt/strings.xml b/library/ui/src/main/res/values-pt/strings.xml
index 8441e4e1cc..f3c2ec2533 100644
--- a/library/ui/src/main/res/values-pt/strings.xml
+++ b/library/ui/src/main/res/values-pt/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Faixa anterior"</string>
-  <string name="exo_controls_next_description">"Próxima faixa"</string>
-  <string name="exo_controls_pause_description">"Pausar"</string>
-  <string name="exo_controls_play_description">"Reproduzir"</string>
-  <string name="exo_controls_stop_description">"Parar"</string>
-  <string name="exo_controls_rewind_description">"Retroceder"</string>
-  <string name="exo_controls_fastforward_description">"Avançar"</string>
-  <string name="exo_controls_repeat_all_description">"Repetir tudo"</string>
-  <string name="exo_controls_repeat_off_description">"Não repetir"</string>
-  <string name="exo_controls_repeat_one_description">"Repetir uma"</string>
-  <string name="exo_controls_shuffle_description">"Reproduzir aleatoriamente"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Faixa anterior"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Próxima faixa"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pausar"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Reproduzir"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Parar"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Retroceder"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Avançar"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Não repetir"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Repetir uma"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Repetir tudo"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Aleatório"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ro/strings.xml b/library/ui/src/main/res/values-ro/strings.xml
index 6b8644e30a..398352d0d3 100644
--- a/library/ui/src/main/res/values-ro/strings.xml
+++ b/library/ui/src/main/res/values-ro/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Melodia anterioară"</string>
-  <string name="exo_controls_next_description">"Melodia următoare"</string>
-  <string name="exo_controls_pause_description">"Pauză"</string>
-  <string name="exo_controls_play_description">"Redați"</string>
-  <string name="exo_controls_stop_description">"Opriți"</string>
-  <string name="exo_controls_rewind_description">"Derulați"</string>
-  <string name="exo_controls_fastforward_description">"Derulați rapid înainte"</string>
-  <string name="exo_controls_repeat_all_description">"Repetați toate"</string>
-  <string name="exo_controls_repeat_off_description">"Repetați niciuna"</string>
-  <string name="exo_controls_repeat_one_description">"Repetați unul"</string>
-  <string name="exo_controls_shuffle_description">"Redați aleatoriu"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Melodia anterioară"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Următoarea înregistrare"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Întrerupeți"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Redați"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Opriți"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Derulați înapoi"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Derulați rapid înainte"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Nu repetați niciunul"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Repetați unul"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Repetați-le pe toate"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Redați aleatoriu"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-ru/strings.xml b/library/ui/src/main/res/values-ru/strings.xml
index 51d11d6371..779a2fc0f2 100644
--- a/library/ui/src/main/res/values-ru/strings.xml
+++ b/library/ui/src/main/res/values-ru/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Предыдущий трек"</string>
-  <string name="exo_controls_next_description">"Следующий трек"</string>
-  <string name="exo_controls_pause_description">"Приостановить"</string>
-  <string name="exo_controls_play_description">"Воспроизвести"</string>
-  <string name="exo_controls_stop_description">"Остановить"</string>
-  <string name="exo_controls_rewind_description">"Перемотать назад"</string>
-  <string name="exo_controls_fastforward_description">"Перемотать вперед"</string>
-  <string name="exo_controls_repeat_all_description">"Повторять все"</string>
-  <string name="exo_controls_repeat_off_description">"Не повторять"</string>
-  <string name="exo_controls_repeat_one_description">"Повторять один элемент"</string>
-  <string name="exo_controls_shuffle_description">"Перемешать"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Предыдущий трек"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Следующий трек"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Приостановить"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Воспроизвести"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Остановить"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Перемотать назад"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Перемотать вперед"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Не повторять"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Повторять трек"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Повторять все"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Перемешать"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sk/strings.xml b/library/ui/src/main/res/values-sk/strings.xml
index 2428dbdcce..51dab688c3 100644
--- a/library/ui/src/main/res/values-sk/strings.xml
+++ b/library/ui/src/main/res/values-sk/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Predchádzajúca stopa"</string>
-  <string name="exo_controls_next_description">"Ďalšia stopa"</string>
-  <string name="exo_controls_pause_description">"Pozastaviť"</string>
-  <string name="exo_controls_play_description">"Prehrať"</string>
-  <string name="exo_controls_stop_description">"Zastaviť"</string>
-  <string name="exo_controls_rewind_description">"Pretočiť späť"</string>
-  <string name="exo_controls_fastforward_description">"Pretočiť dopredu"</string>
-  <string name="exo_controls_repeat_all_description">"Opakovať všetko"</string>
-  <string name="exo_controls_repeat_off_description">"Neopakovať"</string>
-  <string name="exo_controls_repeat_one_description">"Opakovať jednu položku"</string>
-  <string name="exo_controls_shuffle_description">"Náhodne prehrávať"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Predchádzajúca skladba"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Ďalšia skladba"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pozastaviť"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Prehrať"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Zastaviť"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Pretočiť späť"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Pretočiť dopredu"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Neopakovať"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Opakovať jednu"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Opakovať všetko"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Náhodne prehrávať"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sl/strings.xml b/library/ui/src/main/res/values-sl/strings.xml
index 8ed731b0d3..832277bdc6 100644
--- a/library/ui/src/main/res/values-sl/strings.xml
+++ b/library/ui/src/main/res/values-sl/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Prejšnja skladba"</string>
-  <string name="exo_controls_next_description">"Naslednja skladba"</string>
-  <string name="exo_controls_pause_description">"Zaustavi"</string>
-  <string name="exo_controls_play_description">"Predvajaj"</string>
-  <string name="exo_controls_stop_description">"Ustavi"</string>
-  <string name="exo_controls_rewind_description">"Previj nazaj"</string>
-  <string name="exo_controls_fastforward_description">"Previj naprej"</string>
-  <string name="exo_controls_repeat_all_description">"Ponovi vse"</string>
-  <string name="exo_controls_repeat_off_description">"Ne ponovi"</string>
-  <string name="exo_controls_repeat_one_description">"Ponovi eno"</string>
-  <string name="exo_controls_shuffle_description">"Naključno predvajaj"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Prejšnja skladba"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Naslednja skladba"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Zaustavitev"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Predvajanje"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Ustavitev"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Previjanje nazaj"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Previjanje naprej"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Brez ponavljanja"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Ponavljanje ene"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Ponavljanje vseh"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Naključno predvajanje"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sr/strings.xml b/library/ui/src/main/res/values-sr/strings.xml
index 8e43a03079..8418a51767 100644
--- a/library/ui/src/main/res/values-sr/strings.xml
+++ b/library/ui/src/main/res/values-sr/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Претходна песма"</string>
-  <string name="exo_controls_next_description">"Следећа песма"</string>
-  <string name="exo_controls_pause_description">"Пауза"</string>
-  <string name="exo_controls_play_description">"Пусти"</string>
-  <string name="exo_controls_stop_description">"Заустави"</string>
-  <string name="exo_controls_rewind_description">"Премотај уназад"</string>
-  <string name="exo_controls_fastforward_description">"Премотај унапред"</string>
-  <string name="exo_controls_repeat_all_description">"Понови све"</string>
-  <string name="exo_controls_repeat_off_description">"Понављање је искључено"</string>
-  <string name="exo_controls_repeat_one_description">"Понови једну"</string>
-  <string name="exo_controls_shuffle_description">"Пусти насумично"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Претходна песма"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Следећа песма"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Паузирај"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Пусти"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Заустави"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Премотај уназад"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Премотај унапред"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Не понављај ниједну"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Понови једну"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Понови све"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Пусти насумично"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sv/strings.xml b/library/ui/src/main/res/values-sv/strings.xml
index 5ff1100632..acca62c10e 100644
--- a/library/ui/src/main/res/values-sv/strings.xml
+++ b/library/ui/src/main/res/values-sv/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Föregående spår"</string>
-  <string name="exo_controls_next_description">"Nästa spår"</string>
-  <string name="exo_controls_pause_description">"Pausa"</string>
-  <string name="exo_controls_play_description">"Spela upp"</string>
-  <string name="exo_controls_stop_description">"Avbryt"</string>
-  <string name="exo_controls_rewind_description">"Spola tillbaka"</string>
-  <string name="exo_controls_fastforward_description">"Snabbspola framåt"</string>
-  <string name="exo_controls_repeat_all_description">"Upprepa alla"</string>
-  <string name="exo_controls_repeat_off_description">"Upprepa inga"</string>
-  <string name="exo_controls_repeat_one_description">"Upprepa en"</string>
-  <string name="exo_controls_shuffle_description">"Blanda"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Föregående spår"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Nästa spår"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Pausa"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Spela upp"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Stoppa"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Spola tillbaka"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Snabbspola framåt"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Upprepa inga"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Upprepa en"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Upprepa alla"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Blanda spår"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-sw/strings.xml b/library/ui/src/main/res/values-sw/strings.xml
index d1d5978f9c..a2441b8270 100644
--- a/library/ui/src/main/res/values-sw/strings.xml
+++ b/library/ui/src/main/res/values-sw/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Wimbo uliotangulia"</string>
-  <string name="exo_controls_next_description">"Wimbo unaofuata"</string>
-  <string name="exo_controls_pause_description">"Sitisha"</string>
-  <string name="exo_controls_play_description">"Cheza"</string>
-  <string name="exo_controls_stop_description">"Simamisha"</string>
-  <string name="exo_controls_rewind_description">"Rudisha nyuma"</string>
-  <string name="exo_controls_fastforward_description">"Peleka mbele kwa kasi"</string>
-  <string name="exo_controls_repeat_all_description">"Rudia zote"</string>
-  <string name="exo_controls_repeat_off_description">"Usirudie Yoyote"</string>
-  <string name="exo_controls_repeat_one_description">"Rudia Moja"</string>
-  <string name="exo_controls_shuffle_description">"Changanya"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Wimbo uliotangulia"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Wimbo unaofuata"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Sitisha"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Cheza"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Simamisha"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Rudisha nyuma"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Sogeza mbele haraka"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Usirudie yoyote"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Rudia moja"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Rudia zote"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Changanya"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-th/strings.xml b/library/ui/src/main/res/values-th/strings.xml
index cd97712b67..02d5fff60c 100644
--- a/library/ui/src/main/res/values-th/strings.xml
+++ b/library/ui/src/main/res/values-th/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"แทร็กก่อนหน้า"</string>
-  <string name="exo_controls_next_description">"แทร็กถัดไป"</string>
-  <string name="exo_controls_pause_description">"หยุดชั่วคราว"</string>
-  <string name="exo_controls_play_description">"เล่น"</string>
-  <string name="exo_controls_stop_description">"หยุด"</string>
-  <string name="exo_controls_rewind_description">"กรอกลับ"</string>
-  <string name="exo_controls_fastforward_description">"กรอไปข้างหน้า"</string>
-  <string name="exo_controls_repeat_all_description">"เล่นซ้ำทั้งหมด"</string>
-  <string name="exo_controls_repeat_off_description">"ไม่เล่นซ้ำ"</string>
-  <string name="exo_controls_repeat_one_description">"เล่นซ้ำรายการเดียว"</string>
-  <string name="exo_controls_shuffle_description">"สุ่มเพลง"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"แทร็กก่อนหน้า"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"แทร็กถัดไป"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"หยุด"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"เล่น"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"หยุด"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"กรอกลับ"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"กรอไปข้างหน้า"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"ไม่เล่นซ้ำ"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"เล่นซ้ำเพลงเดียว"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"เล่นซ้ำทั้งหมด"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"สุ่ม"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-tl/strings.xml b/library/ui/src/main/res/values-tl/strings.xml
index e8cb87acdd..b4a3e1136c 100644
--- a/library/ui/src/main/res/values-tl/strings.xml
+++ b/library/ui/src/main/res/values-tl/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Nakaraang track"</string>
-  <string name="exo_controls_next_description">"Susunod na track"</string>
-  <string name="exo_controls_pause_description">"I-pause"</string>
-  <string name="exo_controls_play_description">"I-play"</string>
-  <string name="exo_controls_stop_description">"Ihinto"</string>
-  <string name="exo_controls_rewind_description">"I-rewind"</string>
-  <string name="exo_controls_fastforward_description">"I-fast forward"</string>
-  <string name="exo_controls_repeat_all_description">"Ulitin Lahat"</string>
-  <string name="exo_controls_repeat_off_description">"Walang Uulitin"</string>
-  <string name="exo_controls_repeat_one_description">"Ulitin ang Isa"</string>
-  <string name="exo_controls_shuffle_description">"I-shuffle"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Nakaraang track"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Susunod na track"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"I-pause"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"I-play"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Ihinto"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"I-rewind"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"I-fast forward"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Walang uulitin"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Mag-ulit ng isa"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Ulitin lahat"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"I-shuffle"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-tr/strings.xml b/library/ui/src/main/res/values-tr/strings.xml
index cd1bfc5444..e7f6c3c89b 100644
--- a/library/ui/src/main/res/values-tr/strings.xml
+++ b/library/ui/src/main/res/values-tr/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Önceki parça"</string>
-  <string name="exo_controls_next_description">"Sonraki parça"</string>
-  <string name="exo_controls_pause_description">"Duraklat"</string>
-  <string name="exo_controls_play_description">"Çal"</string>
-  <string name="exo_controls_stop_description">"Durdur"</string>
-  <string name="exo_controls_rewind_description">"Geri sar"</string>
-  <string name="exo_controls_fastforward_description">"İleri sar"</string>
-  <string name="exo_controls_repeat_all_description">"Tümünü Tekrarla"</string>
-  <string name="exo_controls_repeat_off_description">"Hiçbirini Tekrarlama"</string>
-  <string name="exo_controls_repeat_one_description">"Birini Tekrarla"</string>
-  <string name="exo_controls_shuffle_description">"Karıştır"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Önceki parça"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Sonraki parça"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Duraklat"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Çal"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Durdur"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Geri sar"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"İleri sar"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Hiçbirini tekrarlama"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Birini tekrarla"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Tümünü tekrarla"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Karıştır"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-uk/strings.xml b/library/ui/src/main/res/values-uk/strings.xml
index 1b0278ae94..114c7d9298 100644
--- a/library/ui/src/main/res/values-uk/strings.xml
+++ b/library/ui/src/main/res/values-uk/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Попередня композиція"</string>
-  <string name="exo_controls_next_description">"Наступна композиція"</string>
-  <string name="exo_controls_pause_description">"Пауза"</string>
-  <string name="exo_controls_play_description">"Відтворити"</string>
-  <string name="exo_controls_stop_description">"Зупинити"</string>
-  <string name="exo_controls_rewind_description">"Перемотати назад"</string>
-  <string name="exo_controls_fastforward_description">"Перемотати вперед"</string>
-  <string name="exo_controls_repeat_all_description">"Повторити все"</string>
-  <string name="exo_controls_repeat_off_description">"Не повторювати"</string>
-  <string name="exo_controls_repeat_one_description">"Повторити один елемент"</string>
-  <string name="exo_controls_shuffle_description">"Перемішати"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Попередня композиція"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Наступна композиція"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Призупинити"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Відтворити"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Припинити"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Перемотати назад"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Перемотати вперед"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Не повторювати"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Повторити 1"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Повторити всі"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Перемішати"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-vi/strings.xml b/library/ui/src/main/res/values-vi/strings.xml
index cff19eca7e..25604f52fa 100644
--- a/library/ui/src/main/res/values-vi/strings.xml
+++ b/library/ui/src/main/res/values-vi/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Bản nhạc trước"</string>
-  <string name="exo_controls_next_description">"Bản nhạc tiếp theo"</string>
-  <string name="exo_controls_pause_description">"Tạm dừng"</string>
-  <string name="exo_controls_play_description">"Phát"</string>
-  <string name="exo_controls_stop_description">"Ngừng"</string>
-  <string name="exo_controls_rewind_description">"Tua lại"</string>
-  <string name="exo_controls_fastforward_description">"Tua đi"</string>
-  <string name="exo_controls_repeat_all_description">"Lặp lại tất cả"</string>
-  <string name="exo_controls_repeat_off_description">"Không lặp lại"</string>
-  <string name="exo_controls_repeat_one_description">"Lặp lại một mục"</string>
-  <string name="exo_controls_shuffle_description">"Trộn bài"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Bản nhạc trước"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Bản nhạc tiếp theo"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Tạm dừng"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Phát"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Dừng"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Tua lại"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Tua đi"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Không lặp lại"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Lặp lại một"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Lặp lại tất cả"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Phát ngẫu nhiên"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zh-rCN/strings.xml b/library/ui/src/main/res/values-zh-rCN/strings.xml
index cf3fe5e88b..4624a9551e 100644
--- a/library/ui/src/main/res/values-zh-rCN/strings.xml
+++ b/library/ui/src/main/res/values-zh-rCN/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"上一曲"</string>
-  <string name="exo_controls_next_description">"下一曲"</string>
-  <string name="exo_controls_pause_description">"暂停"</string>
-  <string name="exo_controls_play_description">"播放"</string>
-  <string name="exo_controls_stop_description">"停止"</string>
-  <string name="exo_controls_rewind_description">"快退"</string>
-  <string name="exo_controls_fastforward_description">"快进"</string>
-  <string name="exo_controls_repeat_all_description">"重复播放全部"</string>
-  <string name="exo_controls_repeat_off_description">"不重复播放"</string>
-  <string name="exo_controls_repeat_one_description">"重复播放单个视频"</string>
-  <string name="exo_controls_shuffle_description">"随机播放"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"上一曲"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"下一曲"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"暂停"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"播放"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"停止"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"快退"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"快进"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"不重复播放"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"重复播放一项"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"全部重复播放"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"随机播放"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zh-rHK/strings.xml b/library/ui/src/main/res/values-zh-rHK/strings.xml
index 78fe4ad995..5957c595a5 100644
--- a/library/ui/src/main/res/values-zh-rHK/strings.xml
+++ b/library/ui/src/main/res/values-zh-rHK/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"上一首曲目"</string>
-  <string name="exo_controls_next_description">"下一首曲目"</string>
-  <string name="exo_controls_pause_description">"暫停"</string>
-  <string name="exo_controls_play_description">"播放"</string>
-  <string name="exo_controls_stop_description">"停止"</string>
-  <string name="exo_controls_rewind_description">"倒帶"</string>
-  <string name="exo_controls_fastforward_description">"向前快轉"</string>
-  <string name="exo_controls_repeat_all_description">"重複播放所有媒體項目"</string>
-  <string name="exo_controls_repeat_off_description">"不重複播放任何媒體項目"</string>
-  <string name="exo_controls_repeat_one_description">"重複播放一個媒體項目"</string>
-  <string name="exo_controls_shuffle_description">"隨機播放"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"上一首曲目"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"下一首曲目"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"暫停"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"播放"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"停止"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"倒轉"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"向前快轉"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"不重複播放"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"重複播放單一項目"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"全部重複播放"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"隨機播放"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zh-rTW/strings.xml b/library/ui/src/main/res/values-zh-rTW/strings.xml
index 3632742904..44275f85ff 100644
--- a/library/ui/src/main/res/values-zh-rTW/strings.xml
+++ b/library/ui/src/main/res/values-zh-rTW/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"上一首曲目"</string>
-  <string name="exo_controls_next_description">"下一首曲目"</string>
-  <string name="exo_controls_pause_description">"暫停"</string>
-  <string name="exo_controls_play_description">"播放"</string>
-  <string name="exo_controls_stop_description">"停止"</string>
-  <string name="exo_controls_rewind_description">"倒轉"</string>
-  <string name="exo_controls_fastforward_description">"快轉"</string>
-  <string name="exo_controls_repeat_all_description">"重複播放所有媒體項目"</string>
-  <string name="exo_controls_repeat_off_description">"不重複播放"</string>
-  <string name="exo_controls_repeat_one_description">"重複播放單一媒體項目"</string>
-  <string name="exo_controls_shuffle_description">"隨機播放"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"上一首曲目"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"下一首曲目"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"暫停"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"播放"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"停止"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"倒轉"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"快轉"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"不重複播放"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"重複播放單一項目"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"重複播放所有項目"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"隨機播放"</string>
 </resources>
diff --git a/library/ui/src/main/res/values-zu/strings.xml b/library/ui/src/main/res/values-zu/strings.xml
index 42dd59c97f..6d8e67154f 100644
--- a/library/ui/src/main/res/values-zu/strings.xml
+++ b/library/ui/src/main/res/values-zu/strings.xml
@@ -1,6 +1,5 @@
-<?xml version="1.0"?>
-<!--
-     Copyright (C) 2016 The Android Open Source Project
+<?xml version="1.0" encoding="UTF-8"?>
+<!--  Copyright (C) 2016 The Android Open Source Project
 
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
@@ -13,17 +12,19 @@
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
--->
-<resources>
-  <string name="exo_controls_previous_description">"Ithrekhi yangaphambilini"</string>
-  <string name="exo_controls_next_description">"Ithrekhi elandelayo"</string>
-  <string name="exo_controls_pause_description">"Misa isikhashana"</string>
-  <string name="exo_controls_play_description">"Dlala"</string>
-  <string name="exo_controls_stop_description">"Misa"</string>
-  <string name="exo_controls_rewind_description">"Buyisela emumva"</string>
-  <string name="exo_controls_fastforward_description">"Ukudlulisa ngokushesha"</string>
-  <string name="exo_controls_repeat_all_description">"Phinda konke"</string>
-  <string name="exo_controls_repeat_off_description">"Ungaphindi lutho"</string>
-  <string name="exo_controls_repeat_one_description">"Phida okukodwa"</string>
-  <string name="exo_controls_shuffle_description">"Shova"</string>
+ -->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="exo_controls_previous_description" msgid="4729846277375475426">"Ithrekhi yangaphambilini"</string>
+    <string name="exo_controls_next_description" msgid="7044845014191647105">"Ithrekhi elandelayo"</string>
+    <string name="exo_controls_pause_description" msgid="7924816224515798262">"Phumula"</string>
+    <string name="exo_controls_play_description" msgid="2326300949114396072">"Dlala"</string>
+    <string name="exo_controls_stop_description" msgid="121453720915069922">"Misa"</string>
+    <string name="exo_controls_rewind_description" msgid="5799450167394904608">"Buyisela emuva"</string>
+    <string name="exo_controls_fastforward_description" msgid="2382411136909255532">"Dlulisela phambili"</string>
+    <string name="exo_controls_repeat_off_description" msgid="2273550552389469729">"Phinda okungekho"</string>
+    <string name="exo_controls_repeat_one_description" msgid="475266640141093764">"Phinda okukodwa"</string>
+    <string name="exo_controls_repeat_all_description" msgid="8909385102773547833">"Phinda konke"</string>
+    <string name="exo_controls_shuffle_description" msgid="1374364424026734323">"Shova"</string>
 </resources>
diff --git a/library/ui/src/main/res/values/attrs.xml b/library/ui/src/main/res/values/attrs.xml
index 525f95768c..40f0db0ac9 100644
--- a/library/ui/src/main/res/values/attrs.xml
+++ b/library/ui/src/main/res/values/attrs.xml
@@ -21,6 +21,7 @@
     <enum name="fixed_width" value="1"/>
     <enum name="fixed_height" value="2"/>
     <enum name="fill" value="3"/>
+    <enum name="zoom" value="4"/>
   </attr>
 
   <!-- Must be kept in sync with SimpleExoPlayerView -->
@@ -41,19 +42,23 @@
   </attr>
   <attr name="show_shuffle_button" format="boolean"/>
 
-  <declare-styleable name="SimpleExoPlayerView">
+  <declare-styleable name="PlayerView">
     <attr name="use_artwork" format="boolean"/>
     <attr name="shutter_background_color" format="color"/>
     <attr name="default_artwork" format="reference"/>
     <attr name="use_controller" format="boolean"/>
     <attr name="hide_on_touch" format="boolean"/>
+    <attr name="hide_during_ads" format="boolean"/>
     <attr name="auto_show" format="boolean"/>
     <attr name="resize_mode"/>
     <attr name="surface_type"/>
+    <attr name="player_layout_id"/>
+    <!-- PlayerControlView attributes -->
     <attr name="show_timeout"/>
     <attr name="rewind_increment"/>
     <attr name="fastforward_increment"/>
-    <attr name="player_layout_id"/>
+    <attr name="repeat_toggle_modes"/>
+    <attr name="show_shuffle_button"/>
     <attr name="controller_layout_id"/>
   </declare-styleable>
 
@@ -61,7 +66,7 @@
     <attr name="resize_mode"/>
   </declare-styleable>
 
-  <declare-styleable name="PlaybackControlView">
+  <declare-styleable name="PlayerControlView">
     <attr name="show_timeout"/>
     <attr name="rewind_increment"/>
     <attr name="fastforward_increment"/>
diff --git a/library/ui/src/main/res/values/strings.xml b/library/ui/src/main/res/values/strings.xml
index ee8cd78be7..007309deda 100644
--- a/library/ui/src/main/res/values/strings.xml
+++ b/library/ui/src/main/res/values/strings.xml
@@ -14,15 +14,26 @@
      limitations under the License.
 -->
 <resources>
+  <!-- Description for a media control button that causes the previous track to be played. [CHAR LIMIT=30] -->
   <string name="exo_controls_previous_description">Previous track</string>
+  <!-- Description for a media control button that causes the next track to be played. [CHAR LIMIT=30] -->
   <string name="exo_controls_next_description">Next track</string>
+  <!-- Description for a media control button that causes playback to be paused. [CHAR LIMIT=30] -->
   <string name="exo_controls_pause_description">Pause</string>
+  <!-- Description for a media control button that causes playback to be started. [CHAR LIMIT=30] -->
   <string name="exo_controls_play_description">Play</string>
+  <!-- Description for a media control button that causes playback to be stopped. [CHAR LIMIT=30] -->
   <string name="exo_controls_stop_description">Stop</string>
+  <!-- Description for a media control button that causes playback to be rewound. [CHAR LIMIT=30] -->
   <string name="exo_controls_rewind_description">Rewind</string>
+  <!-- Description for a media control button that causes playback to be fast-forwarded. [CHAR LIMIT=30] -->
   <string name="exo_controls_fastforward_description">Fast forward</string>
+  <!-- Description for a button that controls the repeat mode of a media playback. In this mode media is not repeated. [CHAR LIMIT=30] -->
   <string name="exo_controls_repeat_off_description">Repeat none</string>
+  <!-- Description for a button that controls the repeat mode of a media playback. In this mode the current piece of media is repeated. [CHAR LIMIT=30] -->
   <string name="exo_controls_repeat_one_description">Repeat one</string>
+  <!-- Description for a button that controls the repeat mode of a media playback. In this mode the entire playlist is repeated. [CHAR LIMIT=30] -->
   <string name="exo_controls_repeat_all_description">Repeat all</string>
+  <!-- Description for a media control button that toggles whether shuffle mode is enabled. [CHAR LIMIT=30] -->
   <string name="exo_controls_shuffle_description">Shuffle</string>
 </resources>
diff --git a/playbacktests/build.gradle b/playbacktests/build.gradle
index 6cd56868f9..d5d524b5a5 100644
--- a/playbacktests/build.gradle
+++ b/playbacktests/build.gradle
@@ -25,8 +25,8 @@ android {
 }
 
 dependencies {
-    androidTestCompile project(modulePrefix + 'library-core')
-    androidTestCompile project(modulePrefix + 'library-dash')
-    androidTestCompile project(modulePrefix + 'library-hls')
-    androidTestCompile project(modulePrefix + 'testutils')
+    androidTestImplementation project(modulePrefix + 'library-core')
+    androidTestImplementation project(modulePrefix + 'library-dash')
+    androidTestImplementation project(modulePrefix + 'library-hls')
+    androidTestImplementation project(modulePrefix + 'testutils')
 }
diff --git a/playbacktests/src/androidTest/AndroidManifest.xml b/playbacktests/src/androidTest/AndroidManifest.xml
index 1a660591d8..328834e155 100644
--- a/playbacktests/src/androidTest/AndroidManifest.xml
+++ b/playbacktests/src/androidTest/AndroidManifest.xml
@@ -21,7 +21,7 @@
   <uses-permission android:name="android.permission.INTERNET"/>
   <uses-permission android:name="android.permission.WAKE_LOCK"/>
 
-  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="27"/>
 
   <application android:debuggable="true"
       android:allowBackup="false"
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
index 8e02204c26..dd5369d64d 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashDownloadTest.java
@@ -15,6 +15,9 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
 import android.net.Uri;
 import android.test.ActivityInstrumentationTestCase2;
 import android.util.Log;
@@ -89,15 +92,16 @@ public void testDownload() throws Exception {
 
     // Download representations
     DashDownloader dashDownloader = downloadContent(false, Float.NaN);
-    assertEquals(cache.getCacheSpace() - manifestLength, dashDownloader.getDownloadedBytes());
+    assertThat(dashDownloader.getDownloadedBytes())
+        .isEqualTo(cache.getCacheSpace() - manifestLength);
 
     testRunner.setStreamName("test_h264_fixed_download").
         setDataSourceFactory(newOfflineCacheDataSourceFactory()).run();
 
     dashDownloader.remove();
 
-    assertEquals("There should be no content left.", 0, cache.getKeys().size());
-    assertEquals("There should be no content left.", 0, cache.getCacheSpace());
+    assertWithMessage("There should be no cache key left").that(cache.getKeys()).isEmpty();
+    assertWithMessage("There should be no content left").that(cache.getCacheSpace()).isEqualTo(0);
   }
 
   public void testPartialDownload() throws Exception {
@@ -114,7 +118,7 @@ public void testPartialDownload() throws Exception {
 
     // Make sure it doesn't download any data
     dashDownloader = downloadContent(true, Float.NaN);
-    assertEquals(downloadedBytes, dashDownloader.getDownloadedBytes());
+    assertThat(dashDownloader.getDownloadedBytes()).isEqualTo(downloadedBytes);
 
     testRunner.setStreamName("test_h264_fixed_partial_download")
         .setDataSourceFactory(newOfflineCacheDataSourceFactory()).run();
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
index 3748779b9d..48b572fe87 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashStreamingTest.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import android.test.ActivityInstrumentationTestCase2;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Player;
@@ -603,8 +605,8 @@ public void testDecoderInfoH264() throws DecoderQueryException {
       return;
     }
     MediaCodecInfo decoderInfo = MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_H264, false);
-    assertNotNull(decoderInfo);
-    assertTrue(Util.SDK_INT < 21 || decoderInfo.adaptive);
+    assertThat(decoderInfo).isNotNull();
+    assertThat(Util.SDK_INT < 21 || decoderInfo.adaptive).isTrue();
   }
 
   public void testDecoderInfoH265V24() throws DecoderQueryException {
@@ -612,7 +614,7 @@ public void testDecoderInfoH265V24() throws DecoderQueryException {
       // Pass.
       return;
     }
-    assertTrue(MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_H265, false).adaptive);
+    assertThat(MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_H265, false).adaptive).isTrue();
   }
 
   public void testDecoderInfoVP9V24() throws DecoderQueryException {
@@ -620,7 +622,7 @@ public void testDecoderInfoVP9V24() throws DecoderQueryException {
       // Pass.
       return;
     }
-    assertTrue(MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_VP9, false).adaptive);
+    assertThat(MediaCodecUtil.getDecoderInfo(MimeTypes.VIDEO_VP9, false).adaptive).isTrue();
   }
 
   // Internal.
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
index 85cefbc2f6..e846a377dc 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashTestRunner.java
@@ -64,7 +64,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import junit.framework.AssertionFailedError;
 
 /** {@link DashHostedTest} builder. */
 public final class DashTestRunner {
@@ -316,8 +315,10 @@ protected MediaSource buildSource(HostActivity host, String userAgent,
       Uri manifestUri = Uri.parse(manifestUrl);
       DefaultDashChunkSource.Factory chunkSourceFactory = new DefaultDashChunkSource.Factory(
           mediaDataSourceFactory);
-      return new DashMediaSource(manifestUri, manifestDataSourceFactory, chunkSourceFactory,
-          MIN_LOADABLE_RETRY_COUNT, 0 /* livePresentationDelayMs */, null, null);
+      return new DashMediaSource.Factory(chunkSourceFactory, manifestDataSourceFactory)
+          .setMinLoadableRetryCount(MIN_LOADABLE_RETRY_COUNT)
+          .setLivePresentationDelayMs(0)
+          .createMediaSource(manifestUri);
     }
 
     @Override
@@ -360,7 +361,7 @@ protected void assertPassed(DecoderCounters audioCounters, DecoderCounters video
         // Assert that consecutive dropped frames were within limit.
         DecoderCountersUtil.assertConsecutiveDroppedBufferLimit(tag + VIDEO_TAG_SUFFIX,
             videoCounters, MAX_CONSECUTIVE_DROPPED_VIDEO_FRAMES);
-      } catch (AssertionFailedError e) {
+      } catch (AssertionError e) {
         if (trackSelector.includedAdditionalVideoFormats) {
           // Retry limiting to CDD mandated formats (b/28220076).
           Log.e(tag, "Too many dropped or consecutive dropped frames.", e);
diff --git a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
index a50c230a39..95c9cfbf97 100644
--- a/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
+++ b/playbacktests/src/androidTest/java/com/google/android/exoplayer2/playbacktests/gts/DashWidevineOfflineTest.java
@@ -15,6 +15,9 @@
  */
 package com.google.android.exoplayer2.playbacktests.gts;
 
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
 import android.media.MediaDrm.MediaDrmStateException;
 import android.net.Uri;
 import android.test.ActivityInstrumentationTestCase2;
@@ -33,7 +36,6 @@
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
-import junit.framework.Assert;
 
 /**
  * Tests Widevine encrypted DASH playbacks using offline keys.
@@ -98,7 +100,7 @@ public void testWidevineOfflineLicenseV22() throws Exception {
 
     // Renew license after playback should still work
     offlineLicenseKeySetId = offlineLicenseHelper.renewLicense(offlineLicenseKeySetId);
-    Assert.assertNotNull(offlineLicenseKeySetId);
+    assertThat(offlineLicenseKeySetId).isNotNull();
   }
 
   public void testWidevineOfflineReleasedLicenseV22() throws Throwable {
@@ -136,8 +138,10 @@ public void testWidevineOfflineExpiredLicenseV22() throws Exception {
     // Wait until the license expires
     long licenseDuration =
         offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId).first;
-    assertTrue("License duration should be less than 30 sec. "
-        + "Server settings might have changed.", licenseDuration < 30);
+    assertWithMessage(
+            "License duration should be less than 30 sec. " + "Server settings might have changed.")
+        .that(licenseDuration < 30)
+        .isTrue();
     while (licenseDuration > 0) {
       synchronized (this) {
         wait(licenseDuration * 1000 + 2000);
@@ -145,7 +149,9 @@ public void testWidevineOfflineExpiredLicenseV22() throws Exception {
       long previousDuration = licenseDuration;
       licenseDuration =
           offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId).first;
-      assertTrue("License duration should be decreasing.", previousDuration > licenseDuration);
+      assertWithMessage("License duration should be decreasing.")
+          .that(previousDuration > licenseDuration)
+          .isTrue();
     }
 
     // DefaultDrmSessionManager should renew the license and stream play fine
@@ -162,8 +168,10 @@ public void testWidevineOfflineLicenseExpiresOnPauseV22() throws Exception {
     Pair<Long, Long> licenseDurationRemainingSec =
         offlineLicenseHelper.getLicenseDurationRemainingSec(offlineLicenseKeySetId);
     long licenseDuration = licenseDurationRemainingSec.first;
-    assertTrue("License duration should be less than 30 sec. "
-        + "Server settings might have changed.", licenseDuration < 30);
+    assertWithMessage(
+            "License duration should be less than 30 sec. " + "Server settings might have changed.")
+        .that(licenseDuration < 30)
+        .isTrue();
     ActionSchedule schedule = new ActionSchedule.Builder(TAG)
         .waitForPlaybackState(Player.STATE_READY)
         .delay(3000).pause().delay(licenseDuration * 1000 + 2000).play().build();
@@ -178,8 +186,8 @@ private void downloadLicense() throws InterruptedException, DrmSessionException,
         Uri.parse(DashTestData.WIDEVINE_H264_MANIFEST));
     DrmInitData drmInitData = DashUtil.loadDrmInitData(dataSource, dashManifest.getPeriod(0));
     offlineLicenseKeySetId = offlineLicenseHelper.downloadLicense(drmInitData);
-    Assert.assertNotNull(offlineLicenseKeySetId);
-    Assert.assertTrue(offlineLicenseKeySetId.length > 0);
+    assertThat(offlineLicenseKeySetId).isNotNull();
+    assertThat(offlineLicenseKeySetId.length).isGreaterThan(0);
     testRunner.setOfflineLicenseKeySetId(offlineLicenseKeySetId);
   }
 
diff --git a/settings.gradle b/settings.gradle
index 0a404aad73..d4530d67b7 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -19,9 +19,11 @@ if (gradle.ext.has('exoplayerModulePrefix')) {
 }
 
 include modulePrefix + 'demo'
+include modulePrefix + 'demo-cast'
 include modulePrefix + 'demo-ima'
 include modulePrefix + 'playbacktests'
 project(modulePrefix + 'demo').projectDir = new File(rootDir, 'demos/main')
+project(modulePrefix + 'demo-cast').projectDir = new File(rootDir, 'demos/cast')
 project(modulePrefix + 'demo-ima').projectDir = new File(rootDir, 'demos/ima')
 project(modulePrefix + 'playbacktests').projectDir = new File(rootDir, 'playbacktests')
 
diff --git a/testutils/build.gradle b/testutils/build.gradle
index db8462b1fd..a7f05a2c5e 100644
--- a/testutils/build.gradle
+++ b/testutils/build.gradle
@@ -22,9 +22,19 @@ android {
         minSdkVersion project.ext.minSdkVersion
         targetSdkVersion project.ext.targetSdkVersion
     }
+
+    lintOptions {
+        // Truth depends on JUnit, which depends on java.lang.management, which
+        // is not part of Android. Remove this when JUnit 4.13 or later is used.
+        // See: https://github.com/junit-team/junit4/pull/1187.
+        disable 'InvalidPackage'
+    }
 }
 
 dependencies {
-    compile project(modulePrefix + 'library-core')
-    compile 'org.mockito:mockito-core:' + mockitoVersion
+    api 'org.mockito:mockito-core:' + mockitoVersion
+    api 'com.google.truth:truth:' + truthVersion
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+    implementation project(modulePrefix + 'library-core')
+    testImplementation project(modulePrefix + 'testutils-robolectric')
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
index 2abe521883..60cf6d278b 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/Action.java
@@ -16,15 +16,24 @@
 package com.google.android.exoplayer2.testutil;
 
 import android.os.Handler;
+import android.support.annotation.Nullable;
 import android.util.Log;
 import android.view.Surface;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
 import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.PlayerMessage;
+import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.testutil.ActionSchedule.ActionNode;
+import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerRunnable;
+import com.google.android.exoplayer2.testutil.ActionSchedule.PlayerTarget;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
+import com.google.android.exoplayer2.util.HandlerWrapper;
 
 /**
  * Base class for actions to perform during playback tests.
@@ -32,13 +41,14 @@
 public abstract class Action {
 
   private final String tag;
-  private final String description;
+  private final @Nullable String description;
 
   /**
    * @param tag A tag to use for logging.
-   * @param description A description to be logged when the action is executed.
+   * @param description A description to be logged when the action is executed, or null if no
+   *     logging is required.
    */
-  public Action(String tag, String description) {
+  public Action(String tag, @Nullable String description) {
     this.tag = tag;
     this.description = description;
   }
@@ -52,15 +62,21 @@ public Action(String tag, String description) {
    * @param handler The handler to use to pass to the next action.
    * @param nextAction The next action to schedule immediately after this action finished.
    */
-  public final void doActionAndScheduleNext(SimpleExoPlayer player,
-      MappingTrackSelector trackSelector, Surface surface, Handler handler, ActionNode nextAction) {
-    Log.i(tag, description);
+  public final void doActionAndScheduleNext(
+      SimpleExoPlayer player,
+      MappingTrackSelector trackSelector,
+      Surface surface,
+      HandlerWrapper handler,
+      ActionNode nextAction) {
+    if (description != null) {
+      Log.i(tag, description);
+    }
     doActionAndScheduleNextImpl(player, trackSelector, surface, handler, nextAction);
   }
 
   /**
    * Called by {@link #doActionAndScheduleNext(SimpleExoPlayer, MappingTrackSelector, Surface,
-   * Handler, ActionNode)} to perform the action and to schedule the next action node.
+   * HandlerWrapper, ActionNode)} to perform the action and to schedule the next action node.
    *
    * @param player The player to which the action should be applied.
    * @param trackSelector The track selector to which the action should be applied.
@@ -68,8 +84,12 @@ public final void doActionAndScheduleNext(SimpleExoPlayer player,
    * @param handler The handler to use to pass to the next action.
    * @param nextAction The next action to schedule immediately after this action finished.
    */
-  protected void doActionAndScheduleNextImpl(SimpleExoPlayer player,
-      MappingTrackSelector trackSelector, Surface surface, Handler handler, ActionNode nextAction) {
+  protected void doActionAndScheduleNextImpl(
+      SimpleExoPlayer player,
+      MappingTrackSelector trackSelector,
+      Surface surface,
+      HandlerWrapper handler,
+      ActionNode nextAction) {
     doActionImpl(player, trackSelector, surface);
     if (nextAction != null) {
       nextAction.schedule(player, trackSelector, surface, handler);
@@ -78,55 +98,99 @@ protected void doActionAndScheduleNextImpl(SimpleExoPlayer player,
 
   /**
    * Called by {@link #doActionAndScheduleNextImpl(SimpleExoPlayer, MappingTrackSelector, Surface,
-   * Handler, ActionNode)} to perform the action.
+   * HandlerWrapper, ActionNode)} to perform the action.
    *
    * @param player The player to which the action should be applied.
    * @param trackSelector The track selector to which the action should be applied.
    * @param surface The surface to use when applying actions.
    */
-  protected abstract void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
-      Surface surface);
+  protected abstract void doActionImpl(
+      SimpleExoPlayer player, MappingTrackSelector trackSelector, Surface surface);
 
   /**
-   * Calls {@link Player#seekTo(long)}.
+   * Calls {@link Player#seekTo(long)} or {@link Player#seekTo(int, long)}.
    */
   public static final class Seek extends Action {
 
+    private final Integer windowIndex;
     private final long positionMs;
 
     /**
+     * Action calls {@link Player#seekTo(long)}.
+     *
      * @param tag A tag to use for logging.
      * @param positionMs The seek position.
      */
     public Seek(String tag, long positionMs) {
       super(tag, "Seek:" + positionMs);
+      this.windowIndex = null;
+      this.positionMs = positionMs;
+    }
+
+    /**
+     * Action calls {@link Player#seekTo(int, long)}.
+     *
+     * @param tag A tag to use for logging.
+     * @param windowIndex The window to seek to.
+     * @param positionMs The seek position.
+     */
+    public Seek(String tag, int windowIndex, long positionMs) {
+      super(tag, "Seek:" + positionMs);
+      this.windowIndex = windowIndex;
       this.positionMs = positionMs;
     }
 
     @Override
     protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
         Surface surface) {
-      player.seekTo(positionMs);
+      if (windowIndex == null) {
+        player.seekTo(positionMs);
+      } else {
+        player.seekTo(windowIndex, positionMs);
+      }
     }
 
   }
 
   /**
-   * Calls {@link Player#stop()}.
+   * Calls {@link Player#stop()} or {@link Player#stop(boolean)}.
    */
   public static final class Stop extends Action {
 
+    private static final String STOP_ACTION_TAG = "Stop";
+
+    private final Boolean reset;
+
     /**
+     * Action will call {@link Player#stop()}.
+     *
      * @param tag A tag to use for logging.
      */
     public Stop(String tag) {
-      super(tag, "Stop");
+      super(tag, STOP_ACTION_TAG);
+      this.reset = null;
+    }
+
+    /**
+     * Action will call {@link Player#stop(boolean)}.
+     *
+     * @param tag A tag to use for logging.
+     * @param reset The value to pass to {@link Player#stop(boolean)}.
+     */
+    public Stop(String tag, boolean reset) {
+      super(tag, STOP_ACTION_TAG);
+      this.reset = reset;
     }
 
     @Override
     protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
         Surface surface) {
-      player.stop();
+      if (reset == null) {
+        player.stop();
+      } else {
+        player.stop(reset);
+      }
+
     }
 
   }
@@ -300,11 +364,183 @@ protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSe
         Surface surface) {
       player.setShuffleModeEnabled(shuffleModeEnabled);
     }
+  }
+
+  /** Calls {@link ExoPlayer#createMessage(Target)} and {@link PlayerMessage#send()}. */
+  public static final class SendMessages extends Action {
 
+    private final Target target;
+    private final int windowIndex;
+    private final long positionMs;
+    private final boolean deleteAfterDelivery;
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param target A message target.
+     * @param positionMs The position at which the message should be sent, in milliseconds.
+     */
+    public SendMessages(String tag, Target target, long positionMs) {
+      this(
+          tag,
+          target,
+          /* windowIndex= */ C.INDEX_UNSET,
+          positionMs,
+          /* deleteAfterDelivery= */ true);
+    }
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param target A message target.
+     * @param windowIndex The window index at which the message should be sent, or {@link
+     *     C#INDEX_UNSET} for the current window.
+     * @param positionMs The position at which the message should be sent, in milliseconds.
+     * @param deleteAfterDelivery Whether the message will be deleted after delivery.
+     */
+    public SendMessages(
+        String tag, Target target, int windowIndex, long positionMs, boolean deleteAfterDelivery) {
+      super(tag, "SendMessages");
+      this.target = target;
+      this.windowIndex = windowIndex;
+      this.positionMs = positionMs;
+      this.deleteAfterDelivery = deleteAfterDelivery;
+    }
+
+    @Override
+    protected void doActionImpl(
+        final SimpleExoPlayer player, MappingTrackSelector trackSelector, Surface surface) {
+      if (target instanceof PlayerTarget) {
+        ((PlayerTarget) target).setPlayer(player);
+      }
+      PlayerMessage message = player.createMessage(target);
+      if (windowIndex != C.INDEX_UNSET) {
+        message.setPosition(windowIndex, positionMs);
+      } else {
+        message.setPosition(positionMs);
+      }
+      message.setHandler(new Handler());
+      message.setDeleteAfterDelivery(deleteAfterDelivery);
+      message.send();
+    }
   }
 
   /**
-   * Waits for {@link Player.EventListener#onTimelineChanged(Timeline, Object)}.
+   * Calls {@link Player#setPlaybackParameters(PlaybackParameters)}.
+   */
+  public static final class SetPlaybackParameters extends Action {
+
+    private final PlaybackParameters playbackParameters;
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param playbackParameters The playback parameters.
+     */
+    public SetPlaybackParameters(String tag, PlaybackParameters playbackParameters) {
+      super(tag, "SetPlaybackParameters:" + playbackParameters);
+      this.playbackParameters = playbackParameters;
+    }
+
+    @Override
+    protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
+        Surface surface) {
+      player.setPlaybackParameters(playbackParameters);
+    }
+
+  }
+
+  /** Throws a playback exception on the playback thread. */
+  public static final class ThrowPlaybackException extends Action {
+
+    private final ExoPlaybackException exception;
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param exception The exception to throw.
+     */
+    public ThrowPlaybackException(String tag, ExoPlaybackException exception) {
+      super(tag, "ThrowPlaybackException:" + exception);
+      this.exception = exception;
+    }
+
+    @Override
+    protected void doActionImpl(
+        SimpleExoPlayer player, MappingTrackSelector trackSelector, Surface surface) {
+      player
+          .createMessage(
+              new Target() {
+                @Override
+                public void handleMessage(int messageType, Object payload)
+                    throws ExoPlaybackException {
+                  throw exception;
+                }
+              })
+          .send();
+    }
+  }
+
+  /**
+   * Schedules a play action to be executed, waits until the player reaches the specified position,
+   * and pauses the player again.
+   */
+  public static final class PlayUntilPosition extends Action {
+
+    private final int windowIndex;
+    private final long positionMs;
+
+    /**
+     * @param tag A tag to use for logging.
+     * @param windowIndex The window index at which the player should be paused again.
+     * @param positionMs The position in that window at which the player should be paused again.
+     */
+    public PlayUntilPosition(String tag, int windowIndex, long positionMs) {
+      super(tag, "PlayUntilPosition:" + windowIndex + "," + positionMs);
+      this.windowIndex = windowIndex;
+      this.positionMs = positionMs;
+    }
+
+    @Override
+    protected void doActionAndScheduleNextImpl(
+        final SimpleExoPlayer player,
+        final MappingTrackSelector trackSelector,
+        final Surface surface,
+        final HandlerWrapper handler,
+        final ActionNode nextAction) {
+      // Schedule one message on the playback thread to pause the player immediately.
+      player
+          .createMessage(
+              new Target() {
+                @Override
+                public void handleMessage(int messageType, Object payload)
+                    throws ExoPlaybackException {
+                  player.setPlayWhenReady(/* playWhenReady= */ false);
+                }
+              })
+          .setPosition(windowIndex, positionMs)
+          .send();
+      // Schedule another message on this test thread to continue action schedule.
+      player
+          .createMessage(
+              new Target() {
+                @Override
+                public void handleMessage(int messageType, Object payload)
+                    throws ExoPlaybackException {
+                  nextAction.schedule(player, trackSelector, surface, handler);
+                }
+              })
+          .setPosition(windowIndex, positionMs)
+          .setHandler(new Handler())
+          .send();
+      player.setPlayWhenReady(true);
+    }
+
+    @Override
+    protected void doActionImpl(
+        SimpleExoPlayer player, MappingTrackSelector trackSelector, Surface surface) {
+      // Not triggered.
+    }
+  }
+
+  /**
+   * Waits for {@link Player.EventListener#onTimelineChanged(Timeline, Object, int)}.
    */
   public static final class WaitForTimelineChanged extends Action {
 
@@ -319,15 +555,19 @@ public WaitForTimelineChanged(String tag, Timeline expectedTimeline) {
     }
 
     @Override
-    protected void doActionAndScheduleNextImpl(final SimpleExoPlayer player,
-        final MappingTrackSelector trackSelector, final Surface surface, final Handler handler,
+    protected void doActionAndScheduleNextImpl(
+        final SimpleExoPlayer player,
+        final MappingTrackSelector trackSelector,
+        final Surface surface,
+        final HandlerWrapper handler,
         final ActionNode nextAction) {
       if (nextAction == null) {
         return;
       }
       Player.EventListener listener = new Player.DefaultEventListener() {
         @Override
-        public void onTimelineChanged(Timeline timeline, Object manifest) {
+        public void onTimelineChanged(Timeline timeline, Object manifest,
+            @Player.TimelineChangeReason int reason) {
           if (timeline.equals(expectedTimeline)) {
             player.removeListener(this);
             nextAction.schedule(player, trackSelector, surface, handler);
@@ -362,8 +602,11 @@ public WaitForPositionDiscontinuity(String tag) {
     }
 
     @Override
-    protected void doActionAndScheduleNextImpl(final SimpleExoPlayer player,
-        final MappingTrackSelector trackSelector, final Surface surface, final Handler handler,
+    protected void doActionAndScheduleNextImpl(
+        final SimpleExoPlayer player,
+        final MappingTrackSelector trackSelector,
+        final Surface surface,
+        final HandlerWrapper handler,
         final ActionNode nextAction) {
       if (nextAction == null) {
         return;
@@ -402,8 +645,11 @@ public WaitForPlaybackState(String tag, int targetPlaybackState) {
     }
 
     @Override
-    protected void doActionAndScheduleNextImpl(final SimpleExoPlayer player,
-        final MappingTrackSelector trackSelector, final Surface surface, final Handler handler,
+    protected void doActionAndScheduleNextImpl(
+        final SimpleExoPlayer player,
+        final MappingTrackSelector trackSelector,
+        final Surface surface,
+        final HandlerWrapper handler,
         final ActionNode nextAction) {
       if (nextAction == null) {
         return;
@@ -444,8 +690,11 @@ public WaitForSeekProcessed(String tag) {
     }
 
     @Override
-    protected void doActionAndScheduleNextImpl(final SimpleExoPlayer player,
-        final MappingTrackSelector trackSelector, final Surface surface, final Handler handler,
+    protected void doActionAndScheduleNextImpl(
+        final SimpleExoPlayer player,
+        final MappingTrackSelector trackSelector,
+        final Surface surface,
+        final HandlerWrapper handler,
         final ActionNode nextAction) {
       if (nextAction == null) {
         return;
@@ -485,6 +734,9 @@ public ExecuteRunnable(String tag, Runnable runnable) {
     @Override
     protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSelector,
         Surface surface) {
+      if (runnable instanceof PlayerRunnable) {
+        ((PlayerRunnable) runnable).setPlayer(player);
+      }
       runnable.run();
     }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
index ddfa2345ee..2ea8a50a84 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ActionSchedule.java
@@ -15,43 +15,67 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.os.Handler;
 import android.os.Looper;
+import android.support.annotation.Nullable;
 import android.view.Surface;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.PlaybackParameters;
 import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.PlayerMessage;
+import com.google.android.exoplayer2.PlayerMessage.Target;
 import com.google.android.exoplayer2.SimpleExoPlayer;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.testutil.Action.ClearVideoSurface;
 import com.google.android.exoplayer2.testutil.Action.ExecuteRunnable;
+import com.google.android.exoplayer2.testutil.Action.PlayUntilPosition;
 import com.google.android.exoplayer2.testutil.Action.PrepareSource;
 import com.google.android.exoplayer2.testutil.Action.Seek;
+import com.google.android.exoplayer2.testutil.Action.SendMessages;
 import com.google.android.exoplayer2.testutil.Action.SetPlayWhenReady;
+import com.google.android.exoplayer2.testutil.Action.SetPlaybackParameters;
 import com.google.android.exoplayer2.testutil.Action.SetRendererDisabled;
 import com.google.android.exoplayer2.testutil.Action.SetRepeatMode;
 import com.google.android.exoplayer2.testutil.Action.SetShuffleModeEnabled;
 import com.google.android.exoplayer2.testutil.Action.SetVideoSurface;
 import com.google.android.exoplayer2.testutil.Action.Stop;
+import com.google.android.exoplayer2.testutil.Action.ThrowPlaybackException;
 import com.google.android.exoplayer2.testutil.Action.WaitForPlaybackState;
 import com.google.android.exoplayer2.testutil.Action.WaitForPositionDiscontinuity;
 import com.google.android.exoplayer2.testutil.Action.WaitForSeekProcessed;
 import com.google.android.exoplayer2.testutil.Action.WaitForTimelineChanged;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
-import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.HandlerWrapper;
 
 /**
  * Schedules a sequence of {@link Action}s for execution during a test.
  */
 public final class ActionSchedule {
 
+  /**
+   * Callback to notify listener that the action schedule has finished.
+   */
+  public interface Callback {
+
+    /**
+     * Called when action schedule finished executing all its actions.
+     */
+    void onActionScheduleFinished();
+
+  }
+
   private final ActionNode rootNode;
+  private final CallbackAction callbackAction;
 
   /**
    * @param rootNode The first node in the sequence.
+   * @param callbackAction The final action which can be used to trigger a callback.
    */
-  private ActionSchedule(ActionNode rootNode) {
+  private ActionSchedule(ActionNode rootNode, CallbackAction callbackAction) {
     this.rootNode = rootNode;
+    this.callbackAction = callbackAction;
   }
 
   /**
@@ -61,9 +85,16 @@ private ActionSchedule(ActionNode rootNode) {
    * @param trackSelector The track selector to which actions should be applied.
    * @param surface The surface to use when applying actions.
    * @param mainHandler A handler associated with the main thread of the host activity.
+   * @param callback A {@link Callback} to notify when the action schedule finishes, or null if no
+   *     notification is needed.
    */
-  /* package */ void start(SimpleExoPlayer player, MappingTrackSelector trackSelector,
-      Surface surface, Handler mainHandler) {
+  /* package */ void start(
+      SimpleExoPlayer player,
+      MappingTrackSelector trackSelector,
+      Surface surface,
+      HandlerWrapper mainHandler,
+      @Nullable Callback callback) {
+    callbackAction.setCallback(callback);
     rootNode.schedule(player, trackSelector, surface, mainHandler);
   }
 
@@ -73,7 +104,6 @@ private ActionSchedule(ActionNode rootNode) {
   public static final class Builder {
 
     private final String tag;
-    private final Clock clock;
     private final ActionNode rootNode;
 
     private long currentDelayMs;
@@ -83,17 +113,8 @@ private ActionSchedule(ActionNode rootNode) {
      * @param tag A tag to use for logging.
      */
     public Builder(String tag) {
-      this(tag, Clock.DEFAULT);
-    }
-
-    /**
-     * @param tag A tag to use for logging.
-     * @param clock A clock to use for measuring delays.
-     */
-    public Builder(String tag, Clock clock) {
       this.tag = tag;
-      this.clock = clock;
-      rootNode = new ActionNode(new RootAction(tag), clock, 0);
+      rootNode = new ActionNode(new RootAction(tag), 0);
       previousNode = rootNode;
     }
 
@@ -115,7 +136,7 @@ public Builder delay(long delayMs) {
      * @return The builder, for convenience.
      */
     public Builder apply(Action action) {
-      return appendActionNode(new ActionNode(action, clock, currentDelayMs));
+      return appendActionNode(new ActionNode(action, currentDelayMs));
     }
 
     /**
@@ -126,7 +147,7 @@ public Builder apply(Action action) {
      * @return The builder, for convenience.
      */
     public Builder repeat(Action action, long intervalMs) {
-      return appendActionNode(new ActionNode(action, clock, currentDelayMs, intervalMs));
+      return appendActionNode(new ActionNode(action, currentDelayMs, intervalMs));
     }
 
     /**
@@ -139,6 +160,17 @@ public Builder seek(long positionMs) {
       return apply(new Seek(tag, positionMs));
     }
 
+    /**
+     * Schedules a seek action to be executed.
+     *
+     * @param windowIndex The window to seek to.
+     * @param positionMs The seek position.
+     * @return The builder, for convenience.
+     */
+    public Builder seek(int windowIndex, long positionMs) {
+      return apply(new Seek(tag, windowIndex, positionMs));
+    }
+
     /**
      * Schedules a seek action to be executed and waits until playback resumes after the seek.
      *
@@ -151,6 +183,26 @@ public Builder seekAndWait(long positionMs) {
           .apply(new WaitForPlaybackState(tag, Player.STATE_READY));
     }
 
+    /**
+     * Schedules a delay until the player indicates that a seek has been processed.
+     *
+     * @return The builder, for convenience.
+     */
+    public Builder waitForSeekProcessed() {
+      return apply(new WaitForSeekProcessed(tag));
+    }
+
+    /**
+     * Schedules a playback parameters setting action to be executed.
+     *
+     * @param playbackParameters The playback parameters to set.
+     * @return The builder, for convenience.
+     * @see Player#setPlaybackParameters(PlaybackParameters)
+     */
+    public Builder setPlaybackParameters(PlaybackParameters playbackParameters) {
+      return apply(new SetPlaybackParameters(tag, playbackParameters));
+    }
+
     /**
      * Schedules a stop action to be executed.
      *
@@ -160,6 +212,16 @@ public Builder stop() {
       return apply(new Stop(tag));
     }
 
+    /**
+     * Schedules a stop action to be executed.
+     *
+     * @param reset Whether the player should be reset.
+     * @return The builder, for convenience.
+     */
+    public Builder stop(boolean reset) {
+      return apply(new Stop(tag, reset));
+    }
+
     /**
      * Schedules a play action to be executed.
      *
@@ -169,6 +231,29 @@ public Builder play() {
       return apply(new SetPlayWhenReady(tag, true));
     }
 
+    /**
+     * Schedules a play action to be executed, waits until the player reaches the specified
+     * position, and pauses the player again.
+     *
+     * @param windowIndex The window index at which the player should be paused again.
+     * @param positionMs The position in that window at which the player should be paused again.
+     * @return The builder, for convenience.
+     */
+    public Builder playUntilPosition(int windowIndex, long positionMs) {
+      return apply(new PlayUntilPosition(tag, windowIndex, positionMs));
+    }
+
+    /**
+     * Schedules a play action to be executed, waits until the player reaches the start of the
+     * specified window, and pauses the player again.
+     *
+     * @param windowIndex The window index at which the player should be paused again.
+     * @return The builder, for convenience.
+     */
+    public Builder playUntilStartOfWindow(int windowIndex) {
+      return apply(new PlayUntilPosition(tag, windowIndex, /* positionMs= */ 0));
+    }
+
     /**
      * Schedules a pause action to be executed.
      *
@@ -252,6 +337,44 @@ public Builder setShuffleModeEnabled(boolean shuffleModeEnabled) {
       return apply(new SetShuffleModeEnabled(tag, shuffleModeEnabled));
     }
 
+    /**
+     * Schedules sending a {@link PlayerMessage}.
+     *
+     * @param positionMs The position in the current window at which the message should be sent, in
+     *     milliseconds.
+     * @return The builder, for convenience.
+     */
+    public Builder sendMessage(Target target, long positionMs) {
+      return apply(new SendMessages(tag, target, positionMs));
+    }
+
+    /**
+     * Schedules sending a {@link PlayerMessage}.
+     *
+     * @param target A message target.
+     * @param windowIndex The window index at which the message should be sent.
+     * @param positionMs The position at which the message should be sent, in milliseconds.
+     * @return The builder, for convenience.
+     */
+    public Builder sendMessage(Target target, int windowIndex, long positionMs) {
+      return apply(
+          new SendMessages(tag, target, windowIndex, positionMs, /* deleteAfterDelivery= */ true));
+    }
+
+    /**
+     * Schedules to send a {@link PlayerMessage}.
+     *
+     * @param target A message target.
+     * @param windowIndex The window index at which the message should be sent.
+     * @param positionMs The position at which the message should be sent, in milliseconds.
+     * @param deleteAfterDelivery Whether the message will be deleted after delivery.
+     * @return The builder, for convenience.
+     */
+    public Builder sendMessage(
+        Target target, int windowIndex, long positionMs, boolean deleteAfterDelivery) {
+      return apply(new SendMessages(tag, target, windowIndex, positionMs, deleteAfterDelivery));
+    }
+
     /**
      * Schedules a delay until the timeline changed to a specified expected timeline.
      *
@@ -290,8 +413,20 @@ public Builder executeRunnable(Runnable runnable) {
       return apply(new ExecuteRunnable(tag, runnable));
     }
 
+    /**
+     * Schedules to throw a playback exception on the playback thread.
+     *
+     * @param exception The exception to throw.
+     * @return The builder, for convenience.
+     */
+    public Builder throwPlaybackException(ExoPlaybackException exception) {
+      return apply(new ThrowPlaybackException(tag, exception));
+    }
+
     public ActionSchedule build() {
-      return new ActionSchedule(rootNode);
+      CallbackAction callbackAction = new CallbackAction(tag);
+      apply(callbackAction);
+      return new ActionSchedule(rootNode, callbackAction);
     }
 
     private Builder appendActionNode(ActionNode actionNode) {
@@ -300,7 +435,50 @@ private Builder appendActionNode(ActionNode actionNode) {
       currentDelayMs = 0;
       return this;
     }
+  }
+
+  /**
+   * Provides a wrapper for a {@link Target} which has access to the player when handling messages.
+   * Can be used with {@link Builder#sendMessage(Target, long)}.
+   */
+  public abstract static class PlayerTarget implements Target {
+
+    private SimpleExoPlayer player;
 
+    /** Handles the message send to the component and additionally provides access to the player. */
+    public abstract void handleMessage(SimpleExoPlayer player, int messageType, Object message);
+
+    /** Sets the player to be passed to {@link #handleMessage(SimpleExoPlayer, int, Object)}. */
+    /* package */ void setPlayer(SimpleExoPlayer player) {
+      this.player = player;
+    }
+
+    @Override
+    public final void handleMessage(int messageType, Object message) throws ExoPlaybackException {
+      handleMessage(player, messageType, message);
+    }
+  }
+
+  /**
+   * Provides a wrapper for a {@link Runnable} which has access to the player. Can be used with
+   * {@link Builder#executeRunnable(Runnable)}.
+   */
+  public abstract static class PlayerRunnable implements Runnable {
+
+    private SimpleExoPlayer player;
+
+    /** Executes Runnable with reference to player. */
+    public abstract void run(SimpleExoPlayer player);
+
+    /** Sets the player to be passed to {@link #run(SimpleExoPlayer)} . */
+    /* package */ void setPlayer(SimpleExoPlayer player) {
+      this.player = player;
+    }
+
+    @Override
+    public final void run() {
+      run(player);
+    }
   }
 
   /**
@@ -309,7 +487,6 @@ private Builder appendActionNode(ActionNode actionNode) {
   /* package */ static final class ActionNode implements Runnable {
 
     private final Action action;
-    private final Clock clock;
     private final long delayMs;
     private final long repeatIntervalMs;
 
@@ -318,27 +495,24 @@ private Builder appendActionNode(ActionNode actionNode) {
     private SimpleExoPlayer player;
     private MappingTrackSelector trackSelector;
     private Surface surface;
-    private Handler mainHandler;
+    private HandlerWrapper mainHandler;
 
     /**
      * @param action The wrapped action.
-     * @param clock The clock to use for measuring the delay.
      * @param delayMs The delay between the node being scheduled and the action being executed.
      */
-    public ActionNode(Action action, Clock clock, long delayMs) {
-      this(action, clock, delayMs, C.TIME_UNSET);
+    public ActionNode(Action action, long delayMs) {
+      this(action, delayMs, C.TIME_UNSET);
     }
 
     /**
      * @param action The wrapped action.
-     * @param clock The clock to use for measuring the delay.
      * @param delayMs The delay between the node being scheduled and the action being executed.
      * @param repeatIntervalMs The interval between one execution and the next repetition. If set to
      *     {@link C#TIME_UNSET}, the action is executed once only.
      */
-    public ActionNode(Action action, Clock clock, long delayMs, long repeatIntervalMs) {
+    public ActionNode(Action action, long delayMs, long repeatIntervalMs) {
       this.action = action;
-      this.clock = clock;
       this.delayMs = delayMs;
       this.repeatIntervalMs = repeatIntervalMs;
     }
@@ -353,16 +527,19 @@ public void setNext(ActionNode next) {
     }
 
     /**
-     * Schedules {@link #action} to be executed after {@link #delayMs}. The {@link #next} node
-     * will be scheduled immediately after {@link #action} is executed.
+     * Schedules {@link #action} to be executed after {@link #delayMs}. The {@link #next} node will
+     * be scheduled immediately after {@link #action} is executed.
      *
      * @param player The player to which actions should be applied.
      * @param trackSelector The track selector to which actions should be applied.
      * @param surface The surface to use when applying actions.
      * @param mainHandler A handler associated with the main thread of the host activity.
      */
-    public void schedule(SimpleExoPlayer player, MappingTrackSelector trackSelector,
-        Surface surface, Handler mainHandler) {
+    public void schedule(
+        SimpleExoPlayer player,
+        MappingTrackSelector trackSelector,
+        Surface surface,
+        HandlerWrapper mainHandler) {
       this.player = player;
       this.trackSelector = trackSelector;
       this.surface = surface;
@@ -370,7 +547,7 @@ public void schedule(SimpleExoPlayer player, MappingTrackSelector trackSelector,
       if (delayMs == 0 && Looper.myLooper() == mainHandler.getLooper()) {
         run();
       } else {
-        clock.postDelayed(mainHandler, this, delayMs);
+        mainHandler.postDelayed(this, delayMs);
       }
     }
 
@@ -378,13 +555,15 @@ public void schedule(SimpleExoPlayer player, MappingTrackSelector trackSelector,
     public void run() {
       action.doActionAndScheduleNext(player, trackSelector, surface, mainHandler, next);
       if (repeatIntervalMs != C.TIME_UNSET) {
-        clock.postDelayed(mainHandler, new Runnable() {
-            @Override
-            public void run() {
-              action.doActionAndScheduleNext(player, trackSelector, surface, mainHandler, null);
-              clock.postDelayed(mainHandler, this, repeatIntervalMs);
-            }
-          }, repeatIntervalMs);
+        mainHandler.postDelayed(
+            new Runnable() {
+              @Override
+              public void run() {
+                action.doActionAndScheduleNext(player, trackSelector, surface, mainHandler, null);
+                mainHandler.postDelayed(this, repeatIntervalMs);
+              }
+            },
+            repeatIntervalMs);
       }
     }
 
@@ -407,4 +586,46 @@ protected void doActionImpl(SimpleExoPlayer player, MappingTrackSelector trackSe
 
   }
 
+  /**
+   * An action calling a specified {@link ActionSchedule.Callback}.
+   */
+  private static final class CallbackAction extends Action {
+
+    private @Nullable Callback callback;
+
+    public CallbackAction(String tag) {
+      super(tag, "FinishedCallback");
+    }
+
+    public void setCallback(@Nullable Callback callback) {
+      this.callback = callback;
+    }
+
+    @Override
+    protected void doActionAndScheduleNextImpl(
+        SimpleExoPlayer player,
+        MappingTrackSelector trackSelector,
+        Surface surface,
+        HandlerWrapper handler,
+        ActionNode nextAction) {
+      Assertions.checkArgument(nextAction == null);
+      if (callback != null) {
+        handler.post(
+            new Runnable() {
+              @Override
+              public void run() {
+                callback.onActionScheduleFinished();
+              }
+            });
+      }
+    }
+
+    @Override
+    protected void doActionImpl(
+        SimpleExoPlayer player, MappingTrackSelector trackSelector, Surface surface) {
+      // Not triggered.
+    }
+
+  }
+
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/AutoAdvancingFakeClock.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/AutoAdvancingFakeClock.java
new file mode 100644
index 0000000000..1d25429a67
--- /dev/null
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/AutoAdvancingFakeClock.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import com.google.android.exoplayer2.util.HandlerWrapper;
+
+/**
+ * {@link FakeClock} extension which automatically advances time whenever an empty message is
+ * enqueued at a future time. The clock time is advanced to the time of the message. Only the first
+ * Handler sending messages at a future time will be allowed to advance time to ensure there is only
+ * one "time master". This should usually be the Handler of the internal playback loop.
+ */
+public final class AutoAdvancingFakeClock extends FakeClock {
+
+  private HandlerWrapper autoAdvancingHandler;
+
+  public AutoAdvancingFakeClock() {
+    super(/* initialTimeMs= */ 0);
+  }
+
+  @Override
+  protected synchronized boolean addHandlerMessageAtTime(
+      HandlerWrapper handler, int message, long timeMs) {
+    boolean result = super.addHandlerMessageAtTime(handler, message, timeMs);
+    if (autoAdvancingHandler == null || autoAdvancingHandler == handler) {
+      autoAdvancingHandler = handler;
+      long currentTimeMs = elapsedRealtime();
+      if (currentTimeMs < timeMs) {
+        advanceTime(timeMs - currentTimeMs);
+      }
+    }
+    return result;
+  }
+}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DecoderCountersUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DecoderCountersUtil.java
index 16af394cdf..307443718c 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/DecoderCountersUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/DecoderCountersUtil.java
@@ -15,8 +15,9 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import static com.google.common.truth.Truth.assertWithMessage;
+
 import com.google.android.exoplayer2.decoder.DecoderCounters;
-import junit.framework.TestCase;
 
 /**
  * Assertions for {@link DecoderCounters}.
@@ -41,30 +42,60 @@ public static void assertSkippedOutputBufferCount(String name, DecoderCounters c
       int expected) {
     counters.ensureUpdated();
     int actual = counters.skippedOutputBufferCount;
-    TestCase.assertEquals("Codec(" + name + ") skipped " + actual + " buffers. Expected "
-        + expected + ".", expected, actual);
+    assertWithMessage(
+            "Codec(" + name + ") skipped " + actual + " buffers. Expected " + expected + ".")
+        .that(actual)
+        .isEqualTo(expected);
   }
 
   public static void assertTotalBufferCount(String name, DecoderCounters counters, int minCount,
       int maxCount) {
     int actual = getTotalBufferCount(counters);
-    TestCase.assertTrue("Codec(" + name + ") output " + actual + " buffers. Expected in range ["
-        + minCount + ", " + maxCount + "].", minCount <= actual && actual <= maxCount);
+    assertWithMessage(
+            "Codec("
+                + name
+                + ") output "
+                + actual
+                + " buffers. Expected in range ["
+                + minCount
+                + ", "
+                + maxCount
+                + "].")
+        .that(minCount <= actual && actual <= maxCount)
+        .isTrue();
   }
 
   public static void assertDroppedBufferLimit(String name, DecoderCounters counters, int limit) {
     counters.ensureUpdated();
     int actual = counters.droppedBufferCount;
-    TestCase.assertTrue("Codec(" + name + ") was late decoding: " + actual + " buffers. "
-        + "Limit: " + limit + ".", actual <= limit);
+    assertWithMessage(
+            "Codec("
+                + name
+                + ") was late decoding: "
+                + actual
+                + " buffers. "
+                + "Limit: "
+                + limit
+                + ".")
+        .that(actual)
+        .isAtMost(limit);
   }
 
   public static void assertConsecutiveDroppedBufferLimit(String name, DecoderCounters counters,
       int limit) {
     counters.ensureUpdated();
     int actual = counters.maxConsecutiveDroppedBufferCount;
-    TestCase.assertTrue("Codec(" + name + ") was late decoding: " + actual
-        + " buffers consecutively. " + "Limit: " + limit + ".", actual <= limit);
+    assertWithMessage(
+            "Codec("
+                + name
+                + ") was late decoding: "
+                + actual
+                + " buffers consecutively. "
+                + "Limit: "
+                + limit
+                + ".")
+        .that(actual)
+        .isAtMost(limit);
   }
 
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
index ee4018ba0e..9071bef01d 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoHostedTest.java
@@ -15,8 +15,10 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import static com.google.common.truth.Truth.assertWithMessage;
+
 import android.os.ConditionVariable;
-import android.os.Handler;
+import android.os.Looper;
 import android.os.SystemClock;
 import android.util.Log;
 import android.view.Surface;
@@ -42,9 +44,10 @@
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
 import com.google.android.exoplayer2.upstream.TransferListener;
+import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.HandlerWrapper;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
-import junit.framework.Assert;
 
 /**
  * A {@link HostedTest} for {@link ExoPlayer} playback tests.
@@ -72,12 +75,14 @@
   private final ConditionVariable testFinished;
 
   private ActionSchedule pendingSchedule;
-  private Handler actionHandler;
+  private HandlerWrapper actionHandler;
   private MappingTrackSelector trackSelector;
   private SimpleExoPlayer player;
   private Surface surface;
   private ExoPlaybackException playerError;
   private Player.EventListener playerEventListener;
+  private VideoRendererEventListener videoDebugListener;
+  private AudioRendererEventListener audioDebugListener;
   private boolean playerWasPrepared;
 
   private boolean playing;
@@ -126,7 +131,7 @@ public final void setSchedule(ActionSchedule schedule) {
     if (player == null) {
       pendingSchedule = schedule;
     } else {
-      schedule.start(player, trackSelector, surface, actionHandler);
+      schedule.start(player, trackSelector, surface, actionHandler, /* callback= */ null);
     }
   }
 
@@ -140,6 +145,26 @@ public final void setEventListener(Player.EventListener eventListener) {
     }
   }
 
+  /**
+   * Sets an {@link VideoRendererEventListener} to listen for video debug events during the test.
+   */
+  public final void setVideoDebugListener(VideoRendererEventListener videoDebugListener) {
+    this.videoDebugListener = videoDebugListener;
+    if (player != null) {
+      player.addVideoDebugListener(videoDebugListener);
+    }
+  }
+
+  /**
+   * Sets an {@link AudioRendererEventListener} to listen for audio debug events during the test.
+   */
+  public final void setAudioDebugListener(AudioRendererEventListener audioDebugListener) {
+    this.audioDebugListener = audioDebugListener;
+    if (player != null) {
+      player.addAudioDebugListener(audioDebugListener);
+    }
+  }
+
   // HostedTest implementation
 
   @Override
@@ -155,14 +180,20 @@ public final void onStart(HostActivity host, Surface surface) {
     if (playerEventListener != null) {
       player.addListener(playerEventListener);
     }
+    if (videoDebugListener != null) {
+      player.addVideoDebugListener(videoDebugListener);
+    }
+    if (audioDebugListener != null) {
+      player.addAudioDebugListener(audioDebugListener);
+    }
     player.addListener(this);
-    player.setAudioDebugListener(this);
-    player.setVideoDebugListener(this);
+    player.addAudioDebugListener(this);
+    player.addVideoDebugListener(this);
     player.setPlayWhenReady(true);
-    actionHandler = new Handler();
+    actionHandler = Clock.DEFAULT.createHandler(Looper.myLooper(), /* callback= */ null);
     // Schedule any pending actions.
     if (pendingSchedule != null) {
-      pendingSchedule.start(player, trackSelector, surface, actionHandler);
+      pendingSchedule.start(player, trackSelector, surface, actionHandler, /* callback= */ null);
       pendingSchedule = null;
     }
   }
@@ -189,9 +220,12 @@ public final void onFinished() {
       // Assert that the playback spanned the correct duration of time.
       long minAllowedActualPlayingTimeMs = playingTimeToAssertMs - MAX_PLAYING_TIME_DISCREPANCY_MS;
       long maxAllowedActualPlayingTimeMs = playingTimeToAssertMs + MAX_PLAYING_TIME_DISCREPANCY_MS;
-      Assert.assertTrue("Total playing time: " + totalPlayingTimeMs + ". Expected: "
-          + playingTimeToAssertMs, minAllowedActualPlayingTimeMs <= totalPlayingTimeMs
-          && totalPlayingTimeMs <= maxAllowedActualPlayingTimeMs);
+      assertWithMessage(
+              "Total playing time: " + totalPlayingTimeMs + ". Expected: " + playingTimeToAssertMs)
+          .that(
+              minAllowedActualPlayingTimeMs <= totalPlayingTimeMs
+                  && totalPlayingTimeMs <= maxAllowedActualPlayingTimeMs)
+          .isTrue();
     }
     // Make any additional assertions.
     assertPassed(audioDecoderCounters, videoDecoderCounters);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
index a87066415d..8f06b82674 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExoPlayerTestRunner.java
@@ -15,11 +15,12 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.os.Handler;
+import static com.google.common.truth.Truth.assertThat;
+
 import android.os.HandlerThread;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.DefaultLoadControl;
 import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayerFactory;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.LoadControl;
 import com.google.android.exoplayer2.Player;
@@ -31,24 +32,26 @@
 import com.google.android.exoplayer2.metadata.MetadataOutput;
 import com.google.android.exoplayer2.source.MediaSource;
 import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.testutil.ExoPlayerTestRunner.Builder.PlayerFactory;
-import com.google.android.exoplayer2.testutil.FakeTimeline.TimelineWindowDefinition;
 import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
 import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.trackselection.TrackSelector;
+import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.HandlerWrapper;
 import com.google.android.exoplayer2.util.MimeTypes;
 import com.google.android.exoplayer2.video.VideoRendererEventListener;
-import java.util.LinkedList;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
-import junit.framework.Assert;
 
 /**
  * Helper class to run an ExoPlayer test.
  */
-public final class ExoPlayerTestRunner extends Player.DefaultEventListener {
+public final class ExoPlayerTestRunner extends Player.DefaultEventListener
+    implements ActionSchedule.Callback {
 
   /**
    * Builder to set-up a {@link ExoPlayerTestRunner}. Default fake implementations will be used for
@@ -57,23 +60,19 @@
   public static final class Builder {
 
     /**
-     * Factory to create an {@link SimpleExoPlayer} instance. The player will be created on its own
-     * {@link HandlerThread}.
+     * A generic video {@link Format} which can be used to set up media sources and renderers.
      */
-    public interface PlayerFactory {
-
-      SimpleExoPlayer createExoPlayer(RenderersFactory renderersFactory,
-          MappingTrackSelector trackSelector, LoadControl loadControl);
-
-    }
-
     public static final Format VIDEO_FORMAT = Format.createVideoSampleFormat(null,
         MimeTypes.VIDEO_H264, null, Format.NO_VALUE, Format.NO_VALUE, 1280, 720, Format.NO_VALUE,
         null, null);
+
+    /**
+     * A generic audio {@link Format} which can be used to set up media sources and renderers.
+     */
     public static final Format AUDIO_FORMAT = Format.createAudioSampleFormat(null,
         MimeTypes.AUDIO_AAC, null, Format.NO_VALUE, Format.NO_VALUE, 2, 44100, null, null, 0, null);
 
-    private PlayerFactory playerFactory;
+    private Clock clock;
     private Timeline timeline;
     private Object manifest;
     private MediaSource mediaSource;
@@ -84,179 +83,363 @@ SimpleExoPlayer createExoPlayer(RenderersFactory renderersFactory,
     private RenderersFactory renderersFactory;
     private ActionSchedule actionSchedule;
     private Player.EventListener eventListener;
+    private VideoRendererEventListener videoRendererEventListener;
+    private AudioRendererEventListener audioRendererEventListener;
+    private Integer expectedPlayerEndedCount;
 
+    /**
+     * Sets a {@link Timeline} to be used by a {@link FakeMediaSource} in the test runner. The
+     * default value is a seekable, non-dynamic {@link FakeTimeline} with a duration of
+     * {@link FakeTimeline.TimelineWindowDefinition#DEFAULT_WINDOW_DURATION_US}. Setting the
+     * timeline is not allowed after a call to {@link #setMediaSource(MediaSource)}.
+     *
+     * @param timeline A {@link Timeline} to be used by a {@link FakeMediaSource} in the test
+     *     runner.
+     * @return This builder.
+     */
     public Builder setTimeline(Timeline timeline) {
-      Assert.assertNull(mediaSource);
+      assertThat(mediaSource).isNull();
       this.timeline = timeline;
       return this;
     }
 
+    /**
+     * Sets a manifest to be used by a {@link FakeMediaSource} in the test runner. The default value
+     * is null. Setting the manifest is not allowed after a call to
+     * {@link #setMediaSource(MediaSource)}.
+     *
+     * @param manifest A manifest to be used by a {@link FakeMediaSource} in the test runner.
+     * @return This builder.
+     */
     public Builder setManifest(Object manifest) {
-      Assert.assertNull(mediaSource);
+      assertThat(mediaSource).isNull();
       this.manifest = manifest;
       return this;
     }
 
-    /** Replaces {@link #setTimeline(Timeline)} and {@link #setManifest(Object)}. */
+    /**
+     * Sets a {@link MediaSource} to be used by the test runner. The default value is a
+     * {@link FakeMediaSource} with the timeline and manifest provided by
+     * {@link #setTimeline(Timeline)} and {@link #setManifest(Object)}. Setting the media source is
+     * not allowed after calls to {@link #setTimeline(Timeline)} and/or
+     * {@link #setManifest(Object)}.
+     *
+     * @param mediaSource A {@link MediaSource} to be used by the test runner.
+     * @return This builder.
+     */
     public Builder setMediaSource(MediaSource mediaSource) {
-      Assert.assertNull(timeline);
-      Assert.assertNull(manifest);
+      assertThat(timeline).isNull();
+      assertThat(manifest).isNull();
       this.mediaSource = mediaSource;
       return this;
     }
 
+    /**
+     * Sets a {@link MappingTrackSelector} to be used by the test runner. The default value is a
+     * {@link DefaultTrackSelector}.
+     *
+     * @param trackSelector A {@link MappingTrackSelector} to be used by the test runner.
+     * @return This builder.
+     */
     public Builder setTrackSelector(MappingTrackSelector trackSelector) {
       this.trackSelector = trackSelector;
       return this;
     }
 
+    /**
+     * Sets a {@link LoadControl} to be used by the test runner. The default value is a
+     * {@link DefaultLoadControl}.
+     *
+     * @param loadControl A {@link LoadControl} to be used by the test runner.
+     * @return This builder.
+     */
     public Builder setLoadControl(LoadControl loadControl) {
       this.loadControl = loadControl;
       return this;
     }
 
+    /**
+     * Sets a list of {@link Format}s to be used by a {@link FakeMediaSource} to create media
+     * periods and for setting up a {@link FakeRenderer}. The default value is a single
+     * {@link #VIDEO_FORMAT}. Note that this parameter doesn't have any influence if both a media
+     * source with {@link #setMediaSource(MediaSource)} and renderers with
+     * {@link #setRenderers(Renderer...)} or {@link #setRenderersFactory(RenderersFactory)} are set.
+     *
+     * @param supportedFormats A list of supported {@link Format}s.
+     * @return This builder.
+     */
     public Builder setSupportedFormats(Format... supportedFormats) {
       this.supportedFormats = supportedFormats;
       return this;
     }
 
+    /**
+     * Sets the {@link Renderer}s to be used by the test runner. The default value is a single
+     * {@link FakeRenderer} supporting the formats set by {@link #setSupportedFormats(Format...)}.
+     * Setting the renderers is not allowed after a call to
+     * {@link #setRenderersFactory(RenderersFactory)}.
+     *
+     * @param renderers A list of {@link Renderer}s to be used by the test runner.
+     * @return This builder.
+     */
     public Builder setRenderers(Renderer... renderers) {
-      Assert.assertNull(renderersFactory);
+      assertThat(renderersFactory).isNull();
       this.renderers = renderers;
       return this;
     }
 
-    /** Replaces {@link #setRenderers(Renderer...)}. */
+    /**
+     * Sets the {@link RenderersFactory} to be used by the test runner. The default factory creates
+     * all renderers set by {@link #setRenderers(Renderer...)}. Setting the renderer factory is not
+     * allowed after a call to {@link #setRenderers(Renderer...)}.
+     *
+     * @param renderersFactory A {@link RenderersFactory} to be used by the test runner.
+     * @return This builder.
+     */
     public Builder setRenderersFactory(RenderersFactory renderersFactory) {
-      Assert.assertNull(renderers);
+      assertThat(renderers).isNull();
       this.renderersFactory = renderersFactory;
       return this;
     }
 
-    public Builder setExoPlayer(PlayerFactory playerFactory) {
-      this.playerFactory = playerFactory;
+    /**
+     * Sets the {@link Clock} to be used by the test runner. The default value is a {@link
+     * AutoAdvancingFakeClock}.
+     *
+     * @param clock A {@link Clock} to be used by the test runner.
+     * @return This builder.
+     */
+    public Builder setClock(Clock clock) {
+      this.clock = clock;
       return this;
     }
 
+    /**
+     * Sets an {@link ActionSchedule} to be run by the test runner. The first action will be
+     * executed immediately before {@link SimpleExoPlayer#prepare(MediaSource)}.
+     *
+     * @param actionSchedule An {@link ActionSchedule} to be used by the test runner.
+     * @return This builder.
+     */
     public Builder setActionSchedule(ActionSchedule actionSchedule) {
       this.actionSchedule = actionSchedule;
       return this;
     }
 
+    /**
+     * Sets an {@link Player.EventListener} to be registered to listen to player events.
+     *
+     * @param eventListener A {@link Player.EventListener} to be registered by the test runner to
+     *     listen to player events.
+     * @return This builder.
+     */
     public Builder setEventListener(Player.EventListener eventListener) {
       this.eventListener = eventListener;
       return this;
     }
 
+    /**
+     * Sets a {@link VideoRendererEventListener} to be registered.
+     *
+     * @param eventListener A {@link VideoRendererEventListener} to be registered.
+     * @return This builder.
+     */
+    public Builder setVideoRendererEventListener(VideoRendererEventListener eventListener) {
+      this.videoRendererEventListener = eventListener;
+      return this;
+    }
+
+    /**
+     * Sets an {@link AudioRendererEventListener} to be registered.
+     *
+     * @param eventListener An {@link AudioRendererEventListener} to be registered.
+     * @return This builder.
+     */
+    public Builder setAudioRendererEventListener(AudioRendererEventListener eventListener) {
+      this.audioRendererEventListener = eventListener;
+      return this;
+    }
+
+    /**
+     * Sets the number of times the test runner is expected to reach the {@link Player#STATE_ENDED}
+     * or {@link Player#STATE_IDLE}. The default is 1. This affects how long
+     * {@link ExoPlayerTestRunner#blockUntilEnded(long)} waits.
+     *
+     * @param expectedPlayerEndedCount The number of times the player is expected to reach the ended
+     *     or idle state.
+     * @return This builder.
+     */
+    public Builder setExpectedPlayerEndedCount(int expectedPlayerEndedCount) {
+      this.expectedPlayerEndedCount = expectedPlayerEndedCount;
+      return this;
+    }
+
+    /**
+     * Builds an {@link ExoPlayerTestRunner} using the provided values or their defaults.
+     *
+     * @return The built {@link ExoPlayerTestRunner}.
+     */
     public ExoPlayerTestRunner build() {
       if (supportedFormats == null) {
-        supportedFormats = new Format[] { VIDEO_FORMAT };
+        supportedFormats = new Format[] {VIDEO_FORMAT};
       }
       if (trackSelector == null) {
         trackSelector = new DefaultTrackSelector();
       }
       if (renderersFactory == null) {
         if (renderers == null) {
-          renderers = new Renderer[] { new FakeRenderer(supportedFormats) };
+          renderers = new Renderer[] {new FakeRenderer(supportedFormats)};
         }
-        renderersFactory = new RenderersFactory() {
-          @Override
-          public Renderer[] createRenderers(Handler eventHandler,
-              VideoRendererEventListener videoRendererEventListener,
-              AudioRendererEventListener audioRendererEventListener, TextOutput textRendererOutput,
-              MetadataOutput metadataRendererOutput) {
-            return renderers;
-          }
-        };
+        renderersFactory =
+            new RenderersFactory() {
+              @Override
+              public Renderer[] createRenderers(
+                  android.os.Handler eventHandler,
+                  VideoRendererEventListener videoRendererEventListener,
+                  AudioRendererEventListener audioRendererEventListener,
+                  TextOutput textRendererOutput,
+                  MetadataOutput metadataRendererOutput) {
+                return renderers;
+              }
+            };
       }
       if (loadControl == null) {
         loadControl = new DefaultLoadControl();
       }
-      if (playerFactory == null) {
-        playerFactory = new PlayerFactory() {
-          @Override
-          public SimpleExoPlayer createExoPlayer(RenderersFactory renderersFactory,
-              MappingTrackSelector trackSelector, LoadControl loadControl) {
-            return ExoPlayerFactory.newSimpleInstance(renderersFactory, trackSelector, loadControl);
-          }
-        };
+      if (clock == null) {
+        clock = new AutoAdvancingFakeClock();
       }
       if (mediaSource == null) {
         if (timeline == null) {
-          timeline = new FakeTimeline(new TimelineWindowDefinition(false, false, 0));
+          timeline = new FakeTimeline(1);
         }
         mediaSource = new FakeMediaSource(timeline, manifest, supportedFormats);
       }
-      return new ExoPlayerTestRunner(playerFactory, mediaSource, renderersFactory, trackSelector,
-          loadControl, actionSchedule, eventListener);
+      if (expectedPlayerEndedCount == null) {
+        expectedPlayerEndedCount = 1;
+      }
+      return new ExoPlayerTestRunner(
+          clock,
+          mediaSource,
+          renderersFactory,
+          trackSelector,
+          loadControl,
+          actionSchedule,
+          eventListener,
+          videoRendererEventListener,
+          audioRendererEventListener,
+          expectedPlayerEndedCount);
     }
   }
 
-  private final PlayerFactory playerFactory;
+  private final Clock clock;
   private final MediaSource mediaSource;
   private final RenderersFactory renderersFactory;
   private final MappingTrackSelector trackSelector;
   private final LoadControl loadControl;
-  private final ActionSchedule actionSchedule;
-  private final Player.EventListener eventListener;
+  private final @Nullable ActionSchedule actionSchedule;
+  private final @Nullable Player.EventListener eventListener;
+  private final @Nullable VideoRendererEventListener videoRendererEventListener;
+  private final @Nullable AudioRendererEventListener audioRendererEventListener;
 
   private final HandlerThread playerThread;
-  private final Handler handler;
+  private final HandlerWrapper handler;
   private final CountDownLatch endedCountDownLatch;
-  private final LinkedList<Timeline> timelines;
-  private final LinkedList<Object> manifests;
-  private final LinkedList<Integer> periodIndices;
+  private final CountDownLatch actionScheduleFinishedCountDownLatch;
+  private final ArrayList<Timeline> timelines;
+  private final ArrayList<Object> manifests;
+  private final ArrayList<Integer> timelineChangeReasons;
+  private final ArrayList<Integer> periodIndices;
+  private final ArrayList<Integer> discontinuityReasons;
 
   private SimpleExoPlayer player;
   private Exception exception;
   private TrackGroupArray trackGroups;
-  private int positionDiscontinuityCount;
   private boolean playerWasPrepared;
 
-  private ExoPlayerTestRunner(PlayerFactory playerFactory, MediaSource mediaSource,
-      RenderersFactory renderersFactory, MappingTrackSelector trackSelector,
-      LoadControl loadControl, ActionSchedule actionSchedule, Player.EventListener eventListener) {
-    this.playerFactory = playerFactory;
+  private ExoPlayerTestRunner(
+      Clock clock,
+      MediaSource mediaSource,
+      RenderersFactory renderersFactory,
+      MappingTrackSelector trackSelector,
+      LoadControl loadControl,
+      @Nullable ActionSchedule actionSchedule,
+      @Nullable Player.EventListener eventListener,
+      @Nullable VideoRendererEventListener videoRendererEventListener,
+      @Nullable AudioRendererEventListener audioRendererEventListener,
+      int expectedPlayerEndedCount) {
+    this.clock = clock;
     this.mediaSource = mediaSource;
     this.renderersFactory = renderersFactory;
     this.trackSelector = trackSelector;
     this.loadControl = loadControl;
     this.actionSchedule = actionSchedule;
     this.eventListener = eventListener;
-    this.timelines = new LinkedList<>();
-    this.manifests = new LinkedList<>();
-    this.periodIndices = new LinkedList<>();
-    this.endedCountDownLatch = new CountDownLatch(1);
+    this.videoRendererEventListener = videoRendererEventListener;
+    this.audioRendererEventListener = audioRendererEventListener;
+    this.timelines = new ArrayList<>();
+    this.manifests = new ArrayList<>();
+    this.timelineChangeReasons = new ArrayList<>();
+    this.periodIndices = new ArrayList<>();
+    this.discontinuityReasons = new ArrayList<>();
+    this.endedCountDownLatch = new CountDownLatch(expectedPlayerEndedCount);
+    this.actionScheduleFinishedCountDownLatch = new CountDownLatch(actionSchedule != null ? 1 : 0);
     this.playerThread = new HandlerThread("ExoPlayerTest thread");
     playerThread.start();
-    this.handler = new Handler(playerThread.getLooper());
+    this.handler = clock.createHandler(playerThread.getLooper(), /* callback= */ null);
   }
 
   // Called on the test thread to run the test.
 
+  /**
+   * Starts the test runner on its own thread. This will trigger the creation of the player, the
+   * listener registration, the start of the action schedule, and the preparation of the player
+   * with the provided media source.
+   *
+   * @return This test runner.
+   */
   public ExoPlayerTestRunner start() {
-    handler.post(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          player = playerFactory.createExoPlayer(renderersFactory, trackSelector, loadControl);
-          player.addListener(ExoPlayerTestRunner.this);
-          if (eventListener != null) {
-            player.addListener(eventListener);
-          }
-          player.setPlayWhenReady(true);
-          if (actionSchedule != null) {
-            actionSchedule.start(player, trackSelector, null, handler);
+    handler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            try {
+              player = new TestSimpleExoPlayer(renderersFactory, trackSelector, loadControl, clock);
+              player.addListener(ExoPlayerTestRunner.this);
+              if (eventListener != null) {
+                player.addListener(eventListener);
+              }
+              if (videoRendererEventListener != null) {
+                player.addVideoDebugListener(videoRendererEventListener);
+              }
+              if (audioRendererEventListener != null) {
+                player.addAudioDebugListener(audioRendererEventListener);
+              }
+              player.setPlayWhenReady(true);
+              if (actionSchedule != null) {
+                actionSchedule.start(
+                    player, trackSelector, null, handler, ExoPlayerTestRunner.this);
+              }
+              player.prepare(mediaSource);
+            } catch (Exception e) {
+              handleException(e);
+            }
           }
-          player.prepare(mediaSource);
-        } catch (Exception e) {
-          handleException(e);
-        }
-      }
-    });
+        });
     return this;
   }
 
+  /**
+   * Blocks the current thread until the test runner finishes. A test is deemed to be finished when
+   * the playback state transitioned to {@link Player#STATE_ENDED} or {@link Player#STATE_IDLE} for
+   * the specified number of times. The test also finishes when an {@link ExoPlaybackException} is
+   * thrown.
+   *
+   * @param timeoutMs The maximum time to wait for the test runner to finish. If this time elapsed
+   *     the method will throw a {@link TimeoutException}.
+   * @return This test runner.
+   * @throws Exception If any exception occurred during playback, release, or due to a timeout.
+   */
   public ExoPlayerTestRunner blockUntilEnded(long timeoutMs) throws Exception {
     if (!endedCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS)) {
       exception = new TimeoutException("Test playback timed out waiting for playback to end.");
@@ -269,35 +452,98 @@ public ExoPlayerTestRunner blockUntilEnded(long timeoutMs) throws Exception {
     return this;
   }
 
+  /**
+   * Blocks the current thread until the action schedule finished. This does not release the test
+   * runner and the test must still call {@link #blockUntilEnded(long)}.
+   *
+   * @param timeoutMs The maximum time to wait for the action schedule to finish.
+   * @return This test runner.
+   * @throws TimeoutException If the action schedule did not finish within the specified timeout.
+   * @throws InterruptedException If the test thread gets interrupted while waiting.
+   */
+  public ExoPlayerTestRunner blockUntilActionScheduleFinished(long timeoutMs)
+      throws TimeoutException, InterruptedException {
+    if (!actionScheduleFinishedCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS)) {
+      throw new TimeoutException("Test playback timed out waiting for action schedule to finish.");
+    }
+    return this;
+  }
+
   // Assertions called on the test thread after test finished.
 
+  /**
+   * Asserts that the timelines reported by
+   * {@link Player.EventListener#onTimelineChanged(Timeline, Object, int)} are equal to the provided
+   * timelines.
+   *
+   * @param timelines A list of expected {@link Timeline}s.
+   */
   public void assertTimelinesEqual(Timeline... timelines) {
-    Assert.assertEquals(timelines.length, this.timelines.size());
-    for (Timeline timeline : timelines) {
-      Assert.assertEquals(timeline, this.timelines.remove());
-    }
+    assertThat(this.timelines).containsExactlyElementsIn(Arrays.asList(timelines)).inOrder();
   }
 
+  /**
+   * Asserts that the manifests reported by
+   * {@link Player.EventListener#onTimelineChanged(Timeline, Object, int)} are equal to the provided
+   * manifest.
+   *
+   * @param manifests A list of expected manifests.
+   */
   public void assertManifestsEqual(Object... manifests) {
-    Assert.assertEquals(manifests.length, this.manifests.size());
-    for (Object manifest : manifests) {
-      Assert.assertEquals(manifest, this.manifests.remove());
-    }
+    assertThat(this.manifests).containsExactlyElementsIn(Arrays.asList(manifests)).inOrder();
+  }
+
+  /**
+   * Asserts that the timeline change reasons reported by {@link
+   * Player.EventListener#onTimelineChanged(Timeline, Object, int)} are equal to the provided
+   * timeline change reasons.
+   */
+  public void assertTimelineChangeReasonsEqual(Integer... reasons) {
+    assertThat(timelineChangeReasons).containsExactlyElementsIn(Arrays.asList(reasons)).inOrder();
   }
 
+  /**
+   * Asserts that the last track group array reported by
+   * {@link Player.EventListener#onTracksChanged(TrackGroupArray, TrackSelectionArray)} is equal to
+   * the provided track group array.
+   *
+   * @param trackGroupArray The expected {@link TrackGroupArray}.
+   */
   public void assertTrackGroupsEqual(TrackGroupArray trackGroupArray) {
-    Assert.assertEquals(trackGroupArray, this.trackGroups);
+    assertThat(this.trackGroups).isEqualTo(trackGroupArray);
   }
 
-  public void assertPositionDiscontinuityCount(int expectedCount) {
-    Assert.assertEquals(expectedCount, positionDiscontinuityCount);
+  /**
+   * Asserts that {@link Player.EventListener#onPositionDiscontinuity(int)} was not called.
+   */
+  public void assertNoPositionDiscontinuities() {
+    assertThat(discontinuityReasons).isEmpty();
   }
 
-  public void assertPlayedPeriodIndices(int... periodIndices) {
-    Assert.assertEquals(periodIndices.length, this.periodIndices.size());
-    for (int periodIndex : periodIndices) {
-      Assert.assertEquals(periodIndex, (int) this.periodIndices.remove());
-    }
+  /**
+   * Asserts that the discontinuity reasons reported by {@link
+   * Player.EventListener#onPositionDiscontinuity(int)} are equal to the provided values.
+   *
+   * @param discontinuityReasons The expected discontinuity reasons.
+   */
+  public void assertPositionDiscontinuityReasonsEqual(Integer... discontinuityReasons) {
+    assertThat(this.discontinuityReasons)
+        .containsExactlyElementsIn(Arrays.asList(discontinuityReasons))
+        .inOrder();
+  }
+
+  /**
+   * Asserts that the indices of played periods is equal to the provided list of periods. A period
+   * is considered to be played if it was the current period after a position discontinuity or a
+   * media source preparation. When the same period is repeated automatically due to enabled repeat
+   * modes, it is reported twice. Seeks within the current period are not reported.
+   *
+   * @param periodIndices A list of expected period indices.
+   */
+  public void assertPlayedPeriodIndices(Integer... periodIndices) {
+    assertThat(this.periodIndices)
+        .containsExactlyElementsIn(Arrays.asList(periodIndices))
+        .inOrder();
   }
 
   // Private implementation details.
@@ -324,15 +570,22 @@ private void handleException(Exception exception) {
     if (this.exception == null) {
       this.exception = exception;
     }
-    endedCountDownLatch.countDown();
+    while (endedCountDownLatch.getCount() > 0) {
+      endedCountDownLatch.countDown();
+    }
   }
 
   // Player.EventListener
 
   @Override
-  public void onTimelineChanged(Timeline timeline, Object manifest) {
+  public void onTimelineChanged(Timeline timeline, Object manifest,
+      @Player.TimelineChangeReason int reason) {
     timelines.add(timeline);
     manifests.add(manifest);
+    timelineChangeReasons.add(reason);
+    if (reason == Player.TIMELINE_CHANGE_REASON_PREPARED) {
+      periodIndices.add(player.getCurrentPeriodIndex());
+    }
   }
 
   @Override
@@ -342,9 +595,6 @@ public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray tra
 
   @Override
   public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-    if (periodIndices.isEmpty() && playbackState == Player.STATE_READY) {
-      periodIndices.add(player.getCurrentPeriodIndex());
-    }
     playerWasPrepared |= playbackState != Player.STATE_IDLE;
     if (playbackState == Player.STATE_ENDED
         || (playbackState == Player.STATE_IDLE && playerWasPrepared)) {
@@ -354,13 +604,37 @@ public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
 
   @Override
   public void onPlayerError(ExoPlaybackException error) {
-    handleException(exception);
+    handleException(error);
   }
 
   @Override
   public void onPositionDiscontinuity(@Player.DiscontinuityReason int reason) {
-    positionDiscontinuityCount++;
-    periodIndices.add(player.getCurrentPeriodIndex());
+    discontinuityReasons.add(reason);
+    int currentIndex = player.getCurrentPeriodIndex();
+    if (reason == Player.DISCONTINUITY_REASON_PERIOD_TRANSITION
+        || periodIndices.isEmpty()
+        || periodIndices.get(periodIndices.size() - 1) != currentIndex) {
+      // Ignore seek or internal discontinuities within a period.
+      periodIndices.add(currentIndex);
+    }
   }
 
+  // ActionSchedule.Callback
+
+  @Override
+  public void onActionScheduleFinished() {
+    actionScheduleFinishedCountDownLatch.countDown();
+  }
+
+  /** SimpleExoPlayer implementation using a custom Clock. */
+  private static final class TestSimpleExoPlayer extends SimpleExoPlayer {
+
+    public TestSimpleExoPlayer(
+        RenderersFactory renderersFactory,
+        TrackSelector trackSelector,
+        LoadControl loadControl,
+        Clock clock) {
+      super(renderersFactory, trackSelector, loadControl, clock);
+    }
+  }
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java
index db63662c45..1e4811aadf 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/ExtractorAsserts.java
@@ -15,7 +15,9 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.app.Instrumentation;
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.Extractor;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -25,14 +27,30 @@
 import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
+import java.lang.reflect.Field;
 import java.util.Arrays;
-import junit.framework.Assert;
 
 /**
  * Assertion methods for {@link Extractor}.
  */
 public final class ExtractorAsserts {
 
+  private static Context robolectricContext;
+
+  static {
+    try {
+      Class<?> runtimeEnvironmentClass = Class.forName("org.robolectric.RuntimeEnvironment");
+      Field applicationField = runtimeEnvironmentClass.getDeclaredField("application");
+      robolectricContext = (Context) applicationField.get(null);
+    } catch (ClassNotFoundException e) {
+      // Keep Robolectric context at null if not found.
+    } catch (NoSuchFieldException e) {
+      // Keep Robolectric context at null if not found.
+    } catch (IllegalAccessException e) {
+      // Keep Robolectric context at null if not found.
+    }
+  }
+
   /**
    * A factory for {@link Extractor} instances.
    */
@@ -43,58 +61,88 @@
   private static final String DUMP_EXTENSION = ".dump";
   private static final String UNKNOWN_LENGTH_EXTENSION = ".unklen" + DUMP_EXTENSION;
 
+  /**
+   * Asserts that an extractor behaves correctly given valid input data. Can only be used from
+   * Robolectric tests.
+   *
+   * <ul>
+   *   <li>Calls {@link Extractor#seek(long, long)} and {@link Extractor#release()} without calling
+   *       {@link Extractor#init(ExtractorOutput)} to check these calls do not fail.
+   *   <li>Calls {@link #assertOutput(Extractor, String, byte[], Context, boolean, boolean, boolean,
+   *       boolean)} with all possible combinations of "simulate" parameters.
+   * </ul>
+   *
+   * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
+   *     class which is to be tested.
+   * @param file The path to the input sample.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from the input.
+   */
+  public static void assertBehavior(ExtractorFactory factory, String file)
+      throws IOException, InterruptedException {
+    // Check behavior prior to initialization.
+    Extractor extractor = factory.create();
+    extractor.seek(0, 0);
+    extractor.release();
+    // Assert output.
+    byte[] fileData = TestUtil.getByteArray(robolectricContext, file);
+    assertOutput(factory, file, fileData, robolectricContext);
+  }
+
   /**
    * Asserts that an extractor behaves correctly given valid input data:
+   *
    * <ul>
    *   <li>Calls {@link Extractor#seek(long, long)} and {@link Extractor#release()} without calling
-   *   {@link Extractor#init(ExtractorOutput)} to check these calls do not fail.</li>
-   *   <li>Calls {@link #assertOutput(Extractor, String, byte[], Instrumentation, boolean, boolean,
-   *   boolean, boolean)} with all possible combinations of "simulate" parameters.</li>
+   *       {@link Extractor#init(ExtractorOutput)} to check these calls do not fail.
+   *   <li>Calls {@link #assertOutput(Extractor, String, byte[], Context, boolean, boolean, boolean,
+   *       boolean)} with all possible combinations of "simulate" parameters.
    * </ul>
    *
    * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
    *     class which is to be tested.
    * @param file The path to the input sample.
-   * @param instrumentation To be used to load the sample file.
+   * @param context To be used to load the sample file.
    * @throws IOException If reading from the input fails.
    * @throws InterruptedException If interrupted while reading from the input.
    */
-  public static void assertBehavior(ExtractorFactory factory, String file,
-      Instrumentation instrumentation) throws IOException, InterruptedException {
+  public static void assertBehavior(ExtractorFactory factory, String file, Context context)
+      throws IOException, InterruptedException {
     // Check behavior prior to initialization.
     Extractor extractor = factory.create();
     extractor.seek(0, 0);
     extractor.release();
     // Assert output.
-    byte[] fileData = TestUtil.getByteArray(instrumentation, file);
-    assertOutput(factory, file, fileData, instrumentation);
+    byte[] fileData = TestUtil.getByteArray(context, file);
+    assertOutput(factory, file, fileData, context);
   }
 
   /**
-   * Calls {@link #assertOutput(Extractor, String, byte[], Instrumentation, boolean, boolean,
-   * boolean, boolean)} with all possible combinations of "simulate" parameters with
-   * {@code sniffFirst} set to true, and makes one additional call with the "simulate" and
-   * {@code sniffFirst} parameters all set to false.
+   * Calls {@link #assertOutput(Extractor, String, byte[], Context, boolean, boolean, boolean,
+   * boolean)} with all possible combinations of "simulate" parameters with {@code sniffFirst} set
+   * to true, and makes one additional call with the "simulate" and {@code sniffFirst} parameters
+   * all set to false.
    *
    * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
    *     class which is to be tested.
    * @param file The path to the input sample.
    * @param data Content of the input file.
-   * @param instrumentation To be used to load the sample file.
+   * @param context To be used to load the sample file.
    * @throws IOException If reading from the input fails.
    * @throws InterruptedException If interrupted while reading from the input.
    */
-  public static void assertOutput(ExtractorFactory factory, String file, byte[] data,
-      Instrumentation instrumentation) throws IOException, InterruptedException {
-    assertOutput(factory.create(), file, data, instrumentation,  true, false, false, false);
-    assertOutput(factory.create(), file, data, instrumentation,  true, false, false,  true);
-    assertOutput(factory.create(), file, data, instrumentation,  true, false,  true, false);
-    assertOutput(factory.create(), file, data, instrumentation,  true, false,  true,  true);
-    assertOutput(factory.create(), file, data, instrumentation,  true,  true, false, false);
-    assertOutput(factory.create(), file, data, instrumentation,  true,  true, false,  true);
-    assertOutput(factory.create(), file, data, instrumentation,  true,  true,  true, false);
-    assertOutput(factory.create(), file, data, instrumentation,  true,  true,  true,  true);
-    assertOutput(factory.create(), file, data, instrumentation, false, false, false, false);
+  public static void assertOutput(
+      ExtractorFactory factory, String file, byte[] data, Context context)
+      throws IOException, InterruptedException {
+    assertOutput(factory.create(), file, data, context, true, false, false, false);
+    assertOutput(factory.create(), file, data, context, true, false, false, true);
+    assertOutput(factory.create(), file, data, context, true, false, true, false);
+    assertOutput(factory.create(), file, data, context, true, false, true, true);
+    assertOutput(factory.create(), file, data, context, true, true, false, false);
+    assertOutput(factory.create(), file, data, context, true, true, false, true);
+    assertOutput(factory.create(), file, data, context, true, true, true, false);
+    assertOutput(factory.create(), file, data, context, true, true, true, true);
+    assertOutput(factory.create(), file, data, context, false, false, false, false);
   }
 
   /**
@@ -106,7 +154,7 @@ public static void assertOutput(ExtractorFactory factory, String file, byte[] da
    * @param extractor The {@link Extractor} to be tested.
    * @param file The path to the input sample.
    * @param data Content of the input file.
-   * @param instrumentation To be used to load the sample file.
+   * @param context To be used to load the sample file.
    * @param sniffFirst Whether to sniff the data by calling {@link Extractor#sniff(ExtractorInput)}
    *     prior to consuming it.
    * @param simulateIOErrors Whether to simulate IO errors.
@@ -116,26 +164,31 @@ public static void assertOutput(ExtractorFactory factory, String file, byte[] da
    * @throws IOException If reading from the input fails.
    * @throws InterruptedException If interrupted while reading from the input.
    */
-  public static FakeExtractorOutput assertOutput(Extractor extractor, String file, byte[] data,
-      Instrumentation instrumentation, boolean sniffFirst, boolean simulateIOErrors,
-      boolean simulateUnknownLength, boolean simulatePartialReads) throws IOException,
-      InterruptedException {
+  private static FakeExtractorOutput assertOutput(
+      Extractor extractor,
+      String file,
+      byte[] data,
+      Context context,
+      boolean sniffFirst,
+      boolean simulateIOErrors,
+      boolean simulateUnknownLength,
+      boolean simulatePartialReads)
+      throws IOException, InterruptedException {
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(data)
         .setSimulateIOErrors(simulateIOErrors)
         .setSimulateUnknownLength(simulateUnknownLength)
         .setSimulatePartialReads(simulatePartialReads).build();
 
     if (sniffFirst) {
-      Assert.assertTrue(TestUtil.sniffTestData(extractor, input));
+      assertThat(TestUtil.sniffTestData(extractor, input)).isTrue();
       input.resetPeekPosition();
     }
 
     FakeExtractorOutput extractorOutput = consumeTestData(extractor, input, 0, true);
-    if (simulateUnknownLength
-        && assetExists(instrumentation, file + UNKNOWN_LENGTH_EXTENSION)) {
-      extractorOutput.assertOutput(instrumentation, file + UNKNOWN_LENGTH_EXTENSION);
+    if (simulateUnknownLength && assetExists(context, file + UNKNOWN_LENGTH_EXTENSION)) {
+      extractorOutput.assertOutput(context, file + UNKNOWN_LENGTH_EXTENSION);
     } else {
-      extractorOutput.assertOutput(instrumentation, file + ".0" + DUMP_EXTENSION);
+      extractorOutput.assertOutput(context, file + ".0" + DUMP_EXTENSION);
     }
 
     SeekMap seekMap = extractorOutput.seekMap;
@@ -143,14 +196,14 @@ public static FakeExtractorOutput assertOutput(Extractor extractor, String file,
       long durationUs = seekMap.getDurationUs();
       for (int j = 0; j < 4; j++) {
         long timeUs = (durationUs * j) / 3;
-        long position = seekMap.getPosition(timeUs);
+        long position = seekMap.getSeekPoints(timeUs).first.position;
         input.setPosition((int) position);
         for (int i = 0; i < extractorOutput.numberOfTracks; i++) {
           extractorOutput.trackOutputs.valueAt(i).clear();
         }
 
         consumeTestData(extractor, input, timeUs, extractorOutput, false);
-        extractorOutput.assertOutput(instrumentation, file + '.' + j + DUMP_EXTENSION);
+        extractorOutput.assertOutput(context, file + '.' + j + DUMP_EXTENSION);
       }
     }
 
@@ -164,16 +217,19 @@ public static FakeExtractorOutput assertOutput(Extractor extractor, String file,
    * @param factory An {@link ExtractorFactory} which creates instances of the {@link Extractor}
    *     class which is to be tested.
    * @param sampleFile The path to the input sample.
-   * @param instrumentation To be used to load the sample file.
+   * @param context To be used to load the sample file.
    * @param expectedThrowable Expected {@link Throwable} class.
    * @throws IOException If reading from the input fails.
    * @throws InterruptedException If interrupted while reading from the input.
    * @see #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)
    */
-  public static void assertThrows(ExtractorFactory factory, String sampleFile,
-      Instrumentation instrumentation, Class<? extends Throwable> expectedThrowable)
+  public static void assertThrows(
+      ExtractorFactory factory,
+      String sampleFile,
+      Context context,
+      Class<? extends Throwable> expectedThrowable)
       throws IOException, InterruptedException {
-    byte[] fileData = TestUtil.getByteArray(instrumentation, sampleFile);
+    byte[] fileData = TestUtil.getByteArray(context, sampleFile);
     assertThrows(factory, fileData, expectedThrowable);
   }
 
@@ -189,8 +245,9 @@ public static void assertThrows(ExtractorFactory factory, String sampleFile,
    * @throws InterruptedException If interrupted while reading from the input.
    * @see #assertThrows(Extractor, byte[], Class, boolean, boolean, boolean)
    */
-  public static void assertThrows(ExtractorFactory factory, byte[] fileData,
-      Class<? extends Throwable> expectedThrowable) throws IOException, InterruptedException {
+  private static void assertThrows(
+      ExtractorFactory factory, byte[] fileData, Class<? extends Throwable> expectedThrowable)
+      throws IOException, InterruptedException {
     assertThrows(factory.create(), fileData, expectedThrowable, false, false, false);
     assertThrows(factory.create(), fileData, expectedThrowable,  true, false, false);
     assertThrows(factory.create(), fileData, expectedThrowable, false,  true, false);
@@ -213,10 +270,14 @@ public static void assertThrows(ExtractorFactory factory, byte[] fileData,
    * @throws IOException If reading from the input fails.
    * @throws InterruptedException If interrupted while reading from the input.
    */
-  public static void assertThrows(Extractor extractor, byte[] fileData,
-      Class<? extends Throwable> expectedThrowable, boolean simulateIOErrors,
-      boolean simulateUnknownLength, boolean simulatePartialReads) throws IOException,
-      InterruptedException {
+  private static void assertThrows(
+      Extractor extractor,
+      byte[] fileData,
+      Class<? extends Throwable> expectedThrowable,
+      boolean simulateIOErrors,
+      boolean simulateUnknownLength,
+      boolean simulatePartialReads)
+      throws IOException, InterruptedException {
     FakeExtractorInput input = new FakeExtractorInput.Builder().setData(fileData)
         .setSimulateIOErrors(simulateIOErrors)
         .setSimulateUnknownLength(simulateUnknownLength)
@@ -277,13 +338,11 @@ private static void consumeTestData(Extractor extractor, FakeExtractorInput inpu
     }
   }
 
-  private static boolean assetExists(Instrumentation instrumentation, String fileName)
-      throws IOException {
+  private static boolean assetExists(Context context, String fileName) throws IOException {
     int i = fileName.lastIndexOf('/');
     String path = i >= 0 ? fileName.substring(0, i) : "";
     String file = i >= 0 ? fileName.substring(i + 1) : fileName;
-    return Arrays.asList(instrumentation.getContext().getResources().getAssets().list(path))
-        .contains(file);
+    return Arrays.asList(context.getResources().getAssets().list(path)).contains(file);
   }
 
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
index 3dcf551943..d32dda65f4 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaPeriod.java
@@ -15,9 +15,9 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.CompositeSequenceableLoader;
 import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.SequenceableLoader;
 import com.google.android.exoplayer2.source.TrackGroupArray;
@@ -44,13 +44,18 @@
   private ChunkSampleStream<FakeChunkSource>[] sampleStreams;
   private SequenceableLoader sequenceableLoader;
 
-  public FakeAdaptiveMediaPeriod(TrackGroupArray trackGroupArray, EventDispatcher eventDispatcher,
-      Allocator allocator, FakeChunkSource.Factory chunkSourceFactory, long durationUs) {
+  public FakeAdaptiveMediaPeriod(
+      TrackGroupArray trackGroupArray,
+      EventDispatcher eventDispatcher,
+      Allocator allocator,
+      FakeChunkSource.Factory chunkSourceFactory,
+      long durationUs) {
     super(trackGroupArray);
     this.eventDispatcher = eventDispatcher;
     this.allocator = allocator;
     this.chunkSourceFactory = chunkSourceFactory;
     this.durationUs = durationUs;
+    this.sampleStreams = newSampleStreamArray(0);
   }
 
   @Override
@@ -62,13 +67,12 @@ public void release() {
   }
 
   @Override
-  public void prepare(Callback callback, long positionUs) {
+  public synchronized void prepare(Callback callback, long positionUs) {
     super.prepare(callback, positionUs);
     this.callback = callback;
   }
 
   @Override
-  @SuppressWarnings("unchecked")
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
     long returnPositionUs = super.selectTracks(selections, mayRetainStreamFlags, streams,
@@ -79,11 +83,25 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
         validStreams.add((ChunkSampleStream<FakeChunkSource>) stream);
       }
     }
-    this.sampleStreams = validStreams.toArray(new ChunkSampleStream[validStreams.size()]);
+    this.sampleStreams = validStreams.toArray(newSampleStreamArray(validStreams.size()));
     this.sequenceableLoader = new CompositeSequenceableLoader(sampleStreams);
     return returnPositionUs;
   }
 
+  @Override
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
+    super.discardBuffer(positionUs, toKeyframe);
+    for (ChunkSampleStream<FakeChunkSource> sampleStream : sampleStreams) {
+      sampleStream.discardBuffer(positionUs, toKeyframe);
+    }
+  }
+
+  @Override
+  public void reevaluateBuffer(long positionUs) {
+    super.reevaluateBuffer(positionUs);
+    sequenceableLoader.reevaluateBuffer(positionUs);
+  }
+
   @Override
   public long getBufferedPositionUs() {
     super.getBufferedPositionUs();
@@ -114,8 +132,15 @@ public boolean continueLoading(long positionUs) {
   protected SampleStream createSampleStream(TrackSelection trackSelection) {
     FakeChunkSource chunkSource = chunkSourceFactory.createChunkSource(trackSelection, durationUs);
     return new ChunkSampleStream<>(
-        MimeTypes.getTrackType(trackSelection.getSelectedFormat().sampleMimeType), null,
-        chunkSource, this, allocator, 0, 3, eventDispatcher);
+        MimeTypes.getTrackType(trackSelection.getSelectedFormat().sampleMimeType),
+        null,
+        null,
+        chunkSource,
+        this,
+        allocator,
+        0,
+        3,
+        eventDispatcher);
   }
 
   @Override
@@ -123,4 +148,8 @@ public void onContinueLoadingRequested(ChunkSampleStream<FakeChunkSource> source
     callback.onContinueLoadingRequested(this);
   }
 
+  @SuppressWarnings("unchecked")
+  private static ChunkSampleStream<FakeChunkSource>[] newSampleStreamArray(int length) {
+    return new ChunkSampleStream[length];
+  }
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
index 59bcaf3e7c..fbb2a83027 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeAdaptiveMediaSource.java
@@ -18,9 +18,9 @@
 import android.os.Handler;
 import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.Timeline.Period;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener;
-import com.google.android.exoplayer2.source.AdaptiveMediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSourceEventListener;
+import com.google.android.exoplayer2.source.MediaSourceEventListener.EventDispatcher;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.upstream.Allocator;
 
@@ -33,9 +33,13 @@
   private final EventDispatcher eventDispatcher;
   private final FakeChunkSource.Factory chunkSourceFactory;
 
-  public FakeAdaptiveMediaSource(Timeline timeline, Object manifest,
-      TrackGroupArray trackGroupArray, Handler eventHandler,
-      AdaptiveMediaSourceEventListener eventListener, FakeChunkSource.Factory chunkSourceFactory) {
+  public FakeAdaptiveMediaSource(
+      Timeline timeline,
+      Object manifest,
+      TrackGroupArray trackGroupArray,
+      Handler eventHandler,
+      MediaSourceEventListener eventListener,
+      FakeChunkSource.Factory chunkSourceFactory) {
     super(timeline, manifest, trackGroupArray);
     this.eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     this.chunkSourceFactory = chunkSourceFactory;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
index 28f5926bfa..9234287e92 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeChunkSource.java
@@ -18,6 +18,7 @@
 import android.net.Uri;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.source.chunk.Chunk;
 import com.google.android.exoplayer2.source.chunk.ChunkHolder;
 import com.google.android.exoplayer2.source.chunk.ChunkSource;
@@ -28,6 +29,7 @@
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.util.MimeTypes;
+import com.google.android.exoplayer2.util.Util;
 import java.io.IOException;
 import java.util.List;
 
@@ -71,6 +73,17 @@ public FakeChunkSource(TrackSelection trackSelection, DataSource dataSource,
     this.dataSet = dataSet;
   }
 
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
+    int chunkIndex = dataSet.getChunkIndexByPosition(positionUs);
+    long firstSyncUs = dataSet.getStartTime(chunkIndex);
+    long secondSyncUs =
+        firstSyncUs < positionUs && chunkIndex < dataSet.getChunkCount() - 1
+            ? dataSet.getStartTime(chunkIndex + 1)
+            : firstSyncUs;
+    return Util.resolveSeekPositionUs(positionUs, seekParameters, firstSyncUs, secondSyncUs);
+  }
+
   @Override
   public void maybeThrowError() throws IOException {
     // Do nothing.
@@ -86,8 +99,10 @@ public void getNextChunk(MediaChunk previous, long playbackPositionUs, long load
       ChunkHolder out) {
     long bufferedDurationUs = loadPositionUs - playbackPositionUs;
     trackSelection.updateSelectedTrack(playbackPositionUs, bufferedDurationUs, C.TIME_UNSET);
-    int chunkIndex = previous == null ? dataSet.getChunkIndexByPosition(playbackPositionUs)
-        : previous.getNextChunkIndex();
+    int chunkIndex =
+        previous == null
+            ? dataSet.getChunkIndexByPosition(playbackPositionUs)
+            : (int) previous.getNextChunkIndex();
     if (chunkIndex >= dataSet.getChunkCount()) {
       out.endOfStream = true;
     } else {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeClock.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeClock.java
index 843e5858d8..a591546613 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeClock.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeClock.java
@@ -15,19 +15,21 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.os.Handler;
+import android.os.Handler.Callback;
+import android.os.Looper;
+import android.os.Message;
 import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.HandlerWrapper;
 import java.util.ArrayList;
 import java.util.List;
 
-/**
- * Fake {@link Clock} implementation independent of {@link android.os.SystemClock}.
- */
-public final class FakeClock implements Clock {
+/** Fake {@link Clock} implementation independent of {@link android.os.SystemClock}. */
+public class FakeClock implements Clock {
 
-  private long currentTimeMs;
   private final List<Long> wakeUpTimes;
-  private final List<HandlerPostData> handlerPosts;
+  private final List<HandlerMessageData> handlerMessages;
+
+  private long currentTimeMs;
 
   /**
    * Create {@link FakeClock} with an arbitrary initial timestamp.
@@ -37,7 +39,7 @@
   public FakeClock(long initialTimeMs) {
     this.currentTimeMs = initialTimeMs;
     this.wakeUpTimes = new ArrayList<>();
-    this.handlerPosts = new ArrayList<>();
+    this.handlerMessages = new ArrayList<>();
   }
 
   /**
@@ -53,10 +55,9 @@ public synchronized void advanceTime(long timeDiffMs) {
         break;
       }
     }
-    for (int i = handlerPosts.size() - 1; i >= 0; i--) {
-      if (handlerPosts.get(i).postTime <= currentTimeMs) {
-        HandlerPostData postData = handlerPosts.remove(i);
-        postData.handler.post(postData.runnable);
+    for (int i = handlerMessages.size() - 1; i >= 0; i--) {
+      if (handlerMessages.get(i).maybeSendToTarget(currentTimeMs)) {
+        handlerMessages.remove(i);
       }
     }
   }
@@ -66,6 +67,11 @@ public synchronized long elapsedRealtime() {
     return currentTimeMs;
   }
 
+  @Override
+  public long uptimeMillis() {
+    return elapsedRealtime();
+  }
+
   @Override
   public synchronized void sleep(long sleepTimeMs) {
     if (sleepTimeMs <= 0) {
@@ -84,27 +90,129 @@ public synchronized void sleep(long sleepTimeMs) {
   }
 
   @Override
-  public synchronized void postDelayed(Handler handler, Runnable runnable, long delayMs) {
-    if (delayMs <= 0) {
-      handler.post(runnable);
-    } else {
-      handlerPosts.add(new HandlerPostData(currentTimeMs + delayMs, handler, runnable));
+  public HandlerWrapper createHandler(Looper looper, Callback callback) {
+    return new ClockHandler(looper, callback);
+  }
+
+  /** Adds a handler post to list of pending messages. */
+  protected synchronized boolean addHandlerMessageAtTime(
+      HandlerWrapper handler, Runnable runnable, long timeMs) {
+    if (timeMs <= currentTimeMs) {
+      return handler.post(runnable);
+    }
+    handlerMessages.add(new HandlerMessageData(timeMs, handler, runnable));
+    return true;
+  }
+
+  /** Adds an empty handler message to list of pending messages. */
+  protected synchronized boolean addHandlerMessageAtTime(
+      HandlerWrapper handler, int message, long timeMs) {
+    if (timeMs <= currentTimeMs) {
+      return handler.sendEmptyMessage(message);
     }
+    handlerMessages.add(new HandlerMessageData(timeMs, handler, message));
+    return true;
   }
 
-  private static final class HandlerPostData {
+  /** Message data saved to send messages or execute runnables at a later time on a Handler. */
+  private static final class HandlerMessageData {
 
-    public final long postTime;
-    public final Handler handler;
-    public final Runnable runnable;
+    private final long postTime;
+    private final HandlerWrapper handler;
+    private final Runnable runnable;
+    private final int message;
 
-    public HandlerPostData(long postTime, Handler handler, Runnable runnable) {
+    public HandlerMessageData(long postTime, HandlerWrapper handler, Runnable runnable) {
       this.postTime = postTime;
       this.handler = handler;
       this.runnable = runnable;
+      this.message = 0;
+    }
+
+    public HandlerMessageData(long postTime, HandlerWrapper handler, int message) {
+      this.postTime = postTime;
+      this.handler = handler;
+      this.runnable = null;
+      this.message = message;
     }
 
+    /** Sends the message and returns whether the message was sent to its target. */
+    public boolean maybeSendToTarget(long currentTimeMs) {
+      if (postTime <= currentTimeMs) {
+        if (runnable != null) {
+          handler.post(runnable);
+        } else {
+          handler.sendEmptyMessage(message);
+        }
+        return true;
+      }
+      return false;
+    }
   }
 
+  /** HandlerWrapper implementation using the enclosing Clock to schedule delayed messages. */
+  private final class ClockHandler implements HandlerWrapper {
+
+    private final android.os.Handler handler;
+
+    public ClockHandler(Looper looper, Callback callback) {
+      handler = new android.os.Handler(looper, callback);
+    }
+
+    @Override
+    public Looper getLooper() {
+      return handler.getLooper();
+    }
+
+    @Override
+    public Message obtainMessage(int what) {
+      return handler.obtainMessage(what);
+    }
+
+    @Override
+    public Message obtainMessage(int what, Object obj) {
+      return handler.obtainMessage(what, obj);
+    }
+
+    @Override
+    public Message obtainMessage(int what, int arg1, int arg2) {
+      return handler.obtainMessage(what, arg1, arg2);
+    }
+
+    @Override
+    public Message obtainMessage(int what, int arg1, int arg2, Object obj) {
+      return handler.obtainMessage(what, arg1, arg2, obj);
+    }
+
+    @Override
+    public boolean sendEmptyMessage(int what) {
+      return handler.sendEmptyMessage(what);
+    }
+
+    @Override
+    public boolean sendEmptyMessageAtTime(int what, long uptimeMs) {
+      return addHandlerMessageAtTime(this, what, uptimeMs);
+    }
+
+    @Override
+    public void removeMessages(int what) {
+      handler.removeMessages(what);
+    }
+
+    @Override
+    public void removeCallbacksAndMessages(Object token) {
+      handler.removeCallbacksAndMessages(token);
+    }
+
+    @Override
+    public boolean post(Runnable runnable) {
+      return handler.post(runnable);
+    }
+
+    @Override
+    public boolean postDelayed(Runnable runnable, long delayMs) {
+      return addHandlerMessageAtTime(this, runnable, uptimeMillis() + delayMs);
+    }
+  }
 }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
index 5cb11fdd81..552827c8da 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorInput.java
@@ -15,12 +15,13 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import android.util.SparseBooleanArray;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
 import java.io.EOFException;
 import java.io.IOException;
-import junit.framework.Assert;
 
 /**
  * A fake {@link ExtractorInput} capable of simulating various scenarios.
@@ -84,30 +85,23 @@ private FakeExtractorInput(byte[] data, boolean simulateUnknownLength,
    * @param position The position to set.
    */
   public void setPosition(int position) {
-    Assert.assertTrue(0 <= position && position <= data.length);
+    assertThat(0 <= position && position <= data.length).isTrue();
     readPosition = position;
     peekPosition = position;
   }
 
   @Override
   public int read(byte[] target, int offset, int length) throws IOException {
+    checkIOException(readPosition, failedReadPositions);
     length = getReadLength(length);
-    if (readFully(target, offset, length, true)) {
-      return length;
-    }
-    return C.RESULT_END_OF_INPUT;
+    return readFullyInternal(target, offset, length, true) ? length : C.RESULT_END_OF_INPUT;
   }
 
   @Override
   public boolean readFully(byte[] target, int offset, int length, boolean allowEndOfInput)
       throws IOException {
-    if (!checkXFully(allowEndOfInput, readPosition, length, failedReadPositions)) {
-      return false;
-    }
-    System.arraycopy(data, readPosition, target, offset, length);
-    readPosition += length;
-    peekPosition = readPosition;
-    return true;
+    checkIOException(readPosition, failedReadPositions);
+    return readFullyInternal(target, offset, length, allowEndOfInput);
   }
 
   @Override
@@ -117,21 +111,15 @@ public void readFully(byte[] target, int offset, int length) throws IOException
 
   @Override
   public int skip(int length) throws IOException {
+    checkIOException(readPosition, failedReadPositions);
     length = getReadLength(length);
-    if (skipFully(length, true)) {
-      return length;
-    }
-    return C.RESULT_END_OF_INPUT;
+    return skipFullyInternal(length, true) ? length : C.RESULT_END_OF_INPUT;
   }
 
   @Override
   public boolean skipFully(int length, boolean allowEndOfInput) throws IOException {
-    if (!checkXFully(allowEndOfInput, readPosition, length, failedReadPositions)) {
-      return false;
-    }
-    readPosition += length;
-    peekPosition = readPosition;
-    return true;
+    checkIOException(readPosition, failedReadPositions);
+    return skipFullyInternal(length, allowEndOfInput);
   }
 
   @Override
@@ -142,7 +130,8 @@ public void skipFully(int length) throws IOException {
   @Override
   public boolean peekFully(byte[] target, int offset, int length, boolean allowEndOfInput)
       throws IOException {
-    if (!checkXFully(allowEndOfInput, peekPosition, length, failedPeekPositions)) {
+    checkIOException(peekPosition, failedPeekPositions);
+    if (!checkXFully(allowEndOfInput, peekPosition, length)) {
       return false;
     }
     System.arraycopy(data, peekPosition, target, offset, length);
@@ -157,7 +146,8 @@ public void peekFully(byte[] target, int offset, int length) throws IOException
 
   @Override
   public boolean advancePeekPosition(int length, boolean allowEndOfInput) throws IOException {
-    if (!checkXFully(allowEndOfInput, peekPosition, length, failedPeekPositions)) {
+    checkIOException(peekPosition, failedPeekPositions);
+    if (!checkXFully(allowEndOfInput, peekPosition, length)) {
       return false;
     }
     peekPosition += length;
@@ -191,18 +181,22 @@ public long getLength() {
 
   @Override
   public <E extends Throwable> void setRetryPosition(long position, E e) throws E {
-    Assert.assertTrue(position >= 0);
+    assertThat(position >= 0).isTrue();
     readPosition = (int) position;
     throw e;
   }
 
-  private boolean checkXFully(boolean allowEndOfInput, int position, int length,
-      SparseBooleanArray failedPositions) throws IOException {
+  private void checkIOException(int position, SparseBooleanArray failedPositions)
+      throws SimulatedIOException {
     if (simulateIOErrors && !failedPositions.get(position)) {
       failedPositions.put(position, true);
       peekPosition = readPosition;
       throw new SimulatedIOException("Simulated IO error at position: " + position);
     }
+  }
+
+  private boolean checkXFully(boolean allowEndOfInput, int position, int length)
+      throws EOFException {
     if (length > 0 && position == data.length) {
       if (allowEndOfInput) {
         return false;
@@ -230,6 +224,26 @@ private int getReadLength(int requestedLength) {
     return Math.min(requestedLength, data.length - readPosition);
   }
 
+  private boolean readFullyInternal(byte[] target, int offset, int length, boolean allowEndOfInput)
+      throws EOFException {
+    if (!checkXFully(allowEndOfInput, readPosition, length)) {
+      return false;
+    }
+    System.arraycopy(data, readPosition, target, offset, length);
+    readPosition += length;
+    peekPosition = readPosition;
+    return true;
+  }
+
+  private boolean skipFullyInternal(int length, boolean allowEndOfInput) throws EOFException {
+    if (!checkXFully(allowEndOfInput, readPosition, length)) {
+      return false;
+    }
+    readPosition += length;
+    peekPosition = readPosition;
+    return true;
+  }
+
   /**
    * Builder of {@link FakeExtractorInput} instances.
    */
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
index ee8927ea21..c6543bd7a5 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeExtractorOutput.java
@@ -15,14 +15,16 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.app.Instrumentation;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import android.content.Context;
 import android.util.SparseArray;
 import com.google.android.exoplayer2.extractor.ExtractorOutput;
 import com.google.android.exoplayer2.extractor.SeekMap;
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
-import junit.framework.Assert;
 
 /**
  * A fake {@link ExtractorOutput}.
@@ -30,9 +32,9 @@
 public final class FakeExtractorOutput implements ExtractorOutput, Dumper.Dumpable {
 
   /**
-   * If true, makes {@link #assertOutput(Instrumentation, String)} method write dump result to
-   * {@code /sdcard/Android/data/apk_package/ + dumpfile} file instead of comparing it with an
-   * existing file.
+   * If true, makes {@link #assertOutput(Context, String)} method write dump result to {@code
+   * /sdcard/Android/data/apk_package/ + dumpfile} file instead of comparing it with an existing
+   * file.
    */
   private static final boolean WRITE_DUMP = false;
 
@@ -50,7 +52,7 @@ public FakeExtractorOutput() {
   public FakeTrackOutput track(int id, int type) {
     FakeTrackOutput output = trackOutputs.get(id);
     if (output == null) {
-      Assert.assertFalse(tracksEnded);
+      assertThat(tracksEnded).isFalse();
       numberOfTracks++;
       output = new FakeTrackOutput();
       trackOutputs.put(id, output);
@@ -69,19 +71,19 @@ public void seekMap(SeekMap seekMap) {
   }
 
   public void assertEquals(FakeExtractorOutput expected) {
-    Assert.assertEquals(expected.numberOfTracks, numberOfTracks);
-    Assert.assertEquals(expected.tracksEnded, tracksEnded);
+    assertThat(numberOfTracks).isEqualTo(expected.numberOfTracks);
+    assertThat(tracksEnded).isEqualTo(expected.tracksEnded);
     if (expected.seekMap == null) {
-      Assert.assertNull(seekMap);
+      assertThat(seekMap).isNull();
     } else {
       // TODO: Bulk up this check if possible.
-      Assert.assertNotNull(seekMap);
-      Assert.assertEquals(expected.seekMap.getClass(), seekMap.getClass());
-      Assert.assertEquals(expected.seekMap.isSeekable(), seekMap.isSeekable());
-      Assert.assertEquals(expected.seekMap.getPosition(0), seekMap.getPosition(0));
+      assertThat(seekMap).isNotNull();
+      assertThat(seekMap.getClass()).isEqualTo(expected.seekMap.getClass());
+      assertThat(seekMap.isSeekable()).isEqualTo(expected.seekMap.isSeekable());
+      assertThat(seekMap.getSeekPoints(0)).isEqualTo(expected.seekMap.getSeekPoints(0));
     }
     for (int i = 0; i < numberOfTracks; i++) {
-      Assert.assertEquals(expected.trackOutputs.keyAt(i), trackOutputs.keyAt(i));
+      assertThat(trackOutputs.keyAt(i)).isEqualTo(expected.trackOutputs.keyAt(i));
       trackOutputs.valueAt(i).assertEquals(expected.trackOutputs.valueAt(i));
     }
   }
@@ -95,29 +97,30 @@ public void assertEquals(FakeExtractorOutput expected) {
    * actual dump will be written to {@code dumpFile}. This new dump file needs to be copied to the
    * project, {@code library/src/androidTest/assets} folder manually.
    */
-  public void assertOutput(Instrumentation instrumentation, String dumpFile) throws IOException {
+  public void assertOutput(Context context, String dumpFile) throws IOException {
     String actual = new Dumper().add(this).toString();
 
     if (WRITE_DUMP) {
-      File directory = instrumentation.getContext().getExternalFilesDir(null);
+      File directory = context.getExternalFilesDir(null);
       File file = new File(directory, dumpFile);
       file.getParentFile().mkdirs();
       PrintWriter out = new PrintWriter(file);
       out.print(actual);
       out.close();
     } else {
-      String expected = TestUtil.getString(instrumentation, dumpFile);
-      Assert.assertEquals(dumpFile, expected, actual);
+      String expected = TestUtil.getString(context, dumpFile);
+      assertWithMessage(dumpFile).that(actual).isEqualTo(expected);
     }
   }
 
   @Override
   public void dump(Dumper dumper) {
     if (seekMap != null) {
-      dumper.startBlock("seekMap")
+      dumper
+          .startBlock("seekMap")
           .add("isSeekable", seekMap.isSeekable())
           .addTime("duration", seekMap.getDurationUs())
-          .add("getPosition(0)", seekMap.getPosition(0))
+          .add("getPosition(0)", seekMap.getSeekPoints(0))
           .endBlock();
     }
     dumper.add("numberOfTracks", numberOfTracks);
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
index 38a5e37fa5..ae2ed0d824 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaPeriod.java
@@ -15,14 +15,18 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.SeekParameters;
 import com.google.android.exoplayer2.source.MediaPeriod;
 import com.google.android.exoplayer2.source.SampleStream;
 import com.google.android.exoplayer2.source.TrackGroup;
 import com.google.android.exoplayer2.source.TrackGroupArray;
 import com.google.android.exoplayer2.trackselection.TrackSelection;
 import java.io.IOException;
-import junit.framework.Assert;
 
 /**
  * Fake {@link MediaPeriod} that provides tracks from the given {@link TrackGroupArray}. Selecting
@@ -32,38 +36,98 @@
 
   private final TrackGroupArray trackGroupArray;
 
-  private boolean preparedPeriod;
+  @Nullable private Handler playerHandler;
+  @Nullable private Callback prepareCallback;
+
+  private boolean deferOnPrepared;
+  private boolean prepared;
+  private long seekOffsetUs;
+  private long discontinuityPositionUs;
 
+  /**
+   * @param trackGroupArray The track group array.
+   */
   public FakeMediaPeriod(TrackGroupArray trackGroupArray) {
+    this(trackGroupArray, false);
+  }
+
+  /**
+   * @param trackGroupArray The track group array.
+   * @param deferOnPrepared Whether {@link MediaPeriod.Callback#onPrepared(MediaPeriod)} should be
+   *     called only after {@link #setPreparationComplete()} has been called. If {@code false}
+   *     preparation completes immediately.
+   */
+  public FakeMediaPeriod(TrackGroupArray trackGroupArray, boolean deferOnPrepared) {
     this.trackGroupArray = trackGroupArray;
+    this.deferOnPrepared = deferOnPrepared;
+    discontinuityPositionUs = C.TIME_UNSET;
+  }
+
+  /**
+   * Sets a discontinuity position to be returned from the next call to
+   * {@link #readDiscontinuity()}.
+   *
+   * @param discontinuityPositionUs The position to be returned, in microseconds.
+   */
+  public void setDiscontinuityPositionUs(long discontinuityPositionUs) {
+    this.discontinuityPositionUs = discontinuityPositionUs;
+  }
+
+  /**
+   * Allows the fake media period to complete preparation. May be called on any thread.
+   */
+  public synchronized void setPreparationComplete() {
+    deferOnPrepared = false;
+    if (playerHandler != null && prepareCallback != null) {
+      playerHandler.post(new Runnable() {
+        @Override
+        public void run() {
+          prepared = true;
+          prepareCallback.onPrepared(FakeMediaPeriod.this);
+        }
+      });
+    }
+  }
+
+  /**
+   * Sets an offset to be applied to positions returned by {@link #seekToUs(long)}.
+   *
+   * @param seekOffsetUs The offset to be applied, in microseconds.
+   */
+  public void setSeekToUsOffset(long seekOffsetUs) {
+    this.seekOffsetUs = seekOffsetUs;
   }
 
   public void release() {
-    preparedPeriod = false;
+    prepared = false;
   }
 
   @Override
-  public void prepare(Callback callback, long positionUs) {
-    Assert.assertFalse(preparedPeriod);
-    preparedPeriod = true;
-    callback.onPrepared(this);
+  public synchronized void prepare(Callback callback, long positionUs) {
+    if (deferOnPrepared) {
+      playerHandler = new Handler();
+      prepareCallback = callback;
+    } else {
+      prepared = true;
+      callback.onPrepared(this);
+    }
   }
 
   @Override
   public void maybeThrowPrepareError() throws IOException {
-    Assert.assertTrue(preparedPeriod);
+    // Do nothing.
   }
 
   @Override
   public TrackGroupArray getTrackGroups() {
-    Assert.assertTrue(preparedPeriod);
+    assertThat(prepared).isTrue();
     return trackGroupArray;
   }
 
   @Override
   public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
       SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
-    Assert.assertTrue(preparedPeriod);
+    assertThat(prepared).isTrue();
     int rendererCount = selections.length;
     for (int i = 0; i < rendererCount; i++) {
       if (streams[i] != null && (selections[i] == null || !mayRetainStreamFlags[i])) {
@@ -71,12 +135,12 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
       }
       if (streams[i] == null && selections[i] != null) {
         TrackSelection selection = selections[i];
-        Assert.assertTrue(1 <= selection.length());
+        assertThat(selection.length()).isAtLeast(1);
         TrackGroup trackGroup = selection.getTrackGroup();
-        Assert.assertTrue(trackGroupArray.indexOf(trackGroup) != C.INDEX_UNSET);
+        assertThat(trackGroupArray.indexOf(trackGroup) != C.INDEX_UNSET).isTrue();
         int indexInTrackGroup = selection.getIndexInTrackGroup(selection.getSelectedIndex());
-        Assert.assertTrue(0 <= indexInTrackGroup);
-        Assert.assertTrue(indexInTrackGroup < trackGroup.length);
+        assertThat(indexInTrackGroup).isAtLeast(0);
+        assertThat(indexInTrackGroup).isLessThan(trackGroup.length);
         streams[i] = createSampleStream(selection);
         streamResetFlags[i] = true;
       }
@@ -85,37 +149,49 @@ public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamF
   }
 
   @Override
-  public void discardBuffer(long positionUs) {
+  public void discardBuffer(long positionUs, boolean toKeyframe) {
+    // Do nothing.
+  }
+
+  @Override
+  public void reevaluateBuffer(long positionUs) {
     // Do nothing.
   }
 
   @Override
   public long readDiscontinuity() {
-    Assert.assertTrue(preparedPeriod);
-    return C.TIME_UNSET;
+    assertThat(prepared).isTrue();
+    long positionDiscontinuityUs = this.discontinuityPositionUs;
+    this.discontinuityPositionUs = C.TIME_UNSET;
+    return positionDiscontinuityUs;
   }
 
   @Override
   public long getBufferedPositionUs() {
-    Assert.assertTrue(preparedPeriod);
+    assertThat(prepared).isTrue();
     return C.TIME_END_OF_SOURCE;
   }
 
   @Override
   public long seekToUs(long positionUs) {
-    Assert.assertTrue(preparedPeriod);
+    assertThat(prepared).isTrue();
+    return positionUs + seekOffsetUs;
+  }
+
+  @Override
+  public long getAdjustedSeekPositionUs(long positionUs, SeekParameters seekParameters) {
     return positionUs;
   }
 
   @Override
   public long getNextLoadPositionUs() {
-    Assert.assertTrue(preparedPeriod);
+    assertThat(prepared).isTrue();
     return C.TIME_END_OF_SOURCE;
   }
 
   @Override
   public boolean continueLoading(long positionUs) {
-    Assert.assertTrue(preparedPeriod);
+    assertThat(prepared).isTrue();
     return false;
   }
 
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
index 1f2524110a..da81bbb62c 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaSource.java
@@ -15,6 +15,10 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.Handler;
+import android.support.annotation.Nullable;
 import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.Timeline;
@@ -26,7 +30,7 @@
 import com.google.android.exoplayer2.util.Assertions;
 import java.io.IOException;
 import java.util.ArrayList;
-import junit.framework.Assert;
+import java.util.List;
 
 /**
  * Fake {@link MediaSource} that provides a given timeline. Creating the period will return a
@@ -34,28 +38,35 @@
  */
 public class FakeMediaSource implements MediaSource {
 
-  protected final Timeline timeline;
-  private final Object manifest;
   private final TrackGroupArray trackGroupArray;
   private final ArrayList<FakeMediaPeriod> activeMediaPeriods;
   private final ArrayList<MediaPeriodId> createdMediaPeriods;
 
+  protected Timeline timeline;
+  private Object manifest;
   private boolean preparedSource;
   private boolean releasedSource;
+  private Listener listener;
+  private Handler sourceInfoRefreshHandler;
 
   /**
    * Creates a {@link FakeMediaSource}. This media source creates {@link FakeMediaPeriod}s with a
-   * {@link TrackGroupArray} using the given {@link Format}s.
+   * {@link TrackGroupArray} using the given {@link Format}s. The provided {@link Timeline} may be
+   * null to prevent an immediate source info refresh message when preparing the media source. It
+   * can be manually set later using {@link #setNewSourceInfo(Timeline, Object)}.
    */
-  public FakeMediaSource(Timeline timeline, Object manifest, Format... formats) {
+  public FakeMediaSource(@Nullable Timeline timeline, Object manifest, Format... formats) {
     this(timeline, manifest, buildTrackGroupArray(formats));
   }
 
   /**
    * Creates a {@link FakeMediaSource}. This media source creates {@link FakeMediaPeriod}s with the
-   * given {@link TrackGroupArray}.
+   * given {@link TrackGroupArray}. The provided {@link Timeline} may be null to prevent an
+   * immediate source info refresh message when preparing the media source. It can be manually set
+   * later using {@link #setNewSourceInfo(Timeline, Object)}.
    */
-  public FakeMediaSource(Timeline timeline, Object manifest, TrackGroupArray trackGroupArray) {
+  public FakeMediaSource(@Nullable Timeline timeline, Object manifest,
+      TrackGroupArray trackGroupArray) {
     this.timeline = timeline;
     this.manifest = manifest;
     this.activeMediaPeriods = new ArrayList<>();
@@ -64,22 +75,28 @@ public FakeMediaSource(Timeline timeline, Object manifest, TrackGroupArray track
   }
 
   @Override
-  public void prepareSource(ExoPlayer player, boolean isTopLevelSource, Listener listener) {
-    Assert.assertFalse(preparedSource);
+  public synchronized void prepareSource(
+      ExoPlayer player, boolean isTopLevelSource, Listener listener) {
+    assertThat(preparedSource).isFalse();
     preparedSource = true;
-    listener.onSourceInfoRefreshed(this, timeline, manifest);
+    releasedSource = false;
+    this.listener = listener;
+    sourceInfoRefreshHandler = new Handler();
+    if (timeline != null) {
+      listener.onSourceInfoRefreshed(this, timeline, manifest);
+    }
   }
 
   @Override
   public void maybeThrowSourceInfoRefreshError() throws IOException {
-    Assert.assertTrue(preparedSource);
+    assertThat(preparedSource).isTrue();
   }
 
   @Override
   public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
+    assertThat(preparedSource).isTrue();
+    assertThat(releasedSource).isFalse();
     Assertions.checkIndex(id.periodIndex, 0, timeline.getPeriodCount());
-    Assert.assertTrue(preparedSource);
-    Assert.assertFalse(releasedSource);
     FakeMediaPeriod mediaPeriod = createFakeMediaPeriod(id, trackGroupArray, allocator);
     activeMediaPeriods.add(mediaPeriod);
     createdMediaPeriods.add(id);
@@ -88,33 +105,65 @@ public MediaPeriod createPeriod(MediaPeriodId id, Allocator allocator) {
 
   @Override
   public void releasePeriod(MediaPeriod mediaPeriod) {
-    Assert.assertTrue(preparedSource);
-    Assert.assertFalse(releasedSource);
+    assertThat(preparedSource).isTrue();
+    assertThat(releasedSource).isFalse();
     FakeMediaPeriod fakeMediaPeriod = (FakeMediaPeriod) mediaPeriod;
-    Assert.assertTrue(activeMediaPeriods.remove(fakeMediaPeriod));
+    assertThat(activeMediaPeriods.remove(fakeMediaPeriod)).isTrue();
     fakeMediaPeriod.release();
   }
 
   @Override
   public void releaseSource() {
-    Assert.assertTrue(preparedSource);
-    Assert.assertFalse(releasedSource);
-    Assert.assertTrue(activeMediaPeriods.isEmpty());
+    assertThat(preparedSource).isTrue();
+    assertThat(releasedSource).isFalse();
+    assertThat(activeMediaPeriods.isEmpty()).isTrue();
     releasedSource = true;
+    preparedSource = false;
+    sourceInfoRefreshHandler.removeCallbacksAndMessages(null);
+    sourceInfoRefreshHandler = null;
+    listener = null;
+  }
+
+  /**
+   * Sets a new timeline and manifest. If the source is already prepared, this triggers a source
+   * info refresh message being sent to the listener.
+   */
+  public synchronized void setNewSourceInfo(final Timeline newTimeline, final Object newManifest) {
+    if (sourceInfoRefreshHandler != null) {
+      sourceInfoRefreshHandler.post(
+          new Runnable() {
+            @Override
+            public void run() {
+              assertThat(releasedSource).isFalse();
+              assertThat(preparedSource).isTrue();
+              timeline = newTimeline;
+              manifest = newManifest;
+              listener.onSourceInfoRefreshed(FakeMediaSource.this, timeline, manifest);
+            }
+          });
+    } else {
+      timeline = newTimeline;
+      manifest = newManifest;
+    }
   }
 
   /**
    * Assert that the source and all periods have been released.
    */
   public void assertReleased() {
-    Assert.assertTrue(releasedSource);
+    assertThat(releasedSource || !preparedSource).isTrue();
   }
 
   /**
    * Assert that a media period for the given id has been created.
    */
   public void assertMediaPeriodCreated(MediaPeriodId mediaPeriodId) {
-    Assert.assertTrue(createdMediaPeriods.contains(mediaPeriodId));
+    assertThat(createdMediaPeriods).contains(mediaPeriodId);
+  }
+
+  /** Returns a list of {@link MediaPeriodId}s, with one element for each created media period. */
+  public List<MediaPeriodId> getCreatedMediaPeriods() {
+    return createdMediaPeriods;
   }
 
   protected FakeMediaPeriod createFakeMediaPeriod(MediaPeriodId id, TrackGroupArray trackGroupArray,
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java
index c4270eb9c4..171e237fd1 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.BaseRenderer;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.ExoPlaybackException;
@@ -22,11 +24,11 @@
 import com.google.android.exoplayer2.FormatHolder;
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
+import com.google.android.exoplayer2.util.Assertions;
 import com.google.android.exoplayer2.util.MimeTypes;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import junit.framework.Assert;
 
 /**
  * Fake {@link Renderer} that supports any format with the matching MIME type. The renderer
@@ -34,51 +36,72 @@
  */
 public class FakeRenderer extends BaseRenderer {
 
+  /**
+   * The amount of time ahead of the current playback position that the renderer reads from the
+   * source. A real renderer will typically read ahead by a small amount due to pipelining through
+   * decoders and the media output path.
+   */
+  private static final long SOURCE_READAHEAD_US = 250000;
+
   private final List<Format> expectedFormats;
   private final DecoderInputBuffer buffer;
+  private final FormatHolder formatHolder;
+
+  private long playbackPositionUs;
+  private long lastSamplePositionUs;
 
+  public boolean isEnded;
   public int positionResetCount;
   public int formatReadCount;
-  public int bufferReadCount;
-  public boolean isEnded;
-  public boolean isReady;
+  public int sampleBufferReadCount;
 
   public FakeRenderer(Format... expectedFormats) {
     super(expectedFormats.length == 0 ? C.TRACK_TYPE_UNKNOWN
         : MimeTypes.getTrackType(expectedFormats[0].sampleMimeType));
     this.expectedFormats = Collections.unmodifiableList(Arrays.asList(expectedFormats));
-    this.buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+    buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
+    formatHolder = new FormatHolder();
+    lastSamplePositionUs = Long.MIN_VALUE;
   }
 
   @Override
   protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
+    playbackPositionUs = positionUs;
+    lastSamplePositionUs = Long.MIN_VALUE;
     positionResetCount++;
     isEnded = false;
   }
 
   @Override
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
-    if (!isEnded) {
+    if (isEnded) {
+      return;
+    }
+    playbackPositionUs = positionUs;
+    while (lastSamplePositionUs < positionUs + SOURCE_READAHEAD_US) {
+      formatHolder.format = null;
       buffer.clear();
-      // Verify the format matches the expected format.
-      FormatHolder formatHolder = new FormatHolder();
       int result = readSource(formatHolder, buffer, false);
       if (result == C.RESULT_FORMAT_READ) {
         formatReadCount++;
-        Assert.assertTrue(expectedFormats.contains(formatHolder.format));
+        assertThat(expectedFormats).contains(formatHolder.format);
       } else if (result == C.RESULT_BUFFER_READ) {
-        bufferReadCount++;
         if (buffer.isEndOfStream()) {
           isEnded = true;
+          return;
         }
+        lastSamplePositionUs = buffer.timeUs;
+        sampleBufferReadCount++;
+      } else {
+        Assertions.checkState(result == C.RESULT_NOTHING_READ);
+        return;
       }
     }
-    isReady = buffer.timeUs >= positionUs;
   }
 
   @Override
   public boolean isReady() {
-    return isReady || isSourceReady();
+    return lastSamplePositionUs >= playbackPositionUs || isSourceReady();
   }
 
   @Override
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
index 699b850f73..228169b6b3 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSampleStream.java
@@ -23,17 +23,23 @@
 import java.io.IOException;
 
 /**
- * Fake {@link SampleStream} that outputs a given {@link Format} then sets the end of stream flag
- * on its input buffer.
+ * Fake {@link SampleStream} that outputs a given {@link Format}, an optional sample containing a
+ * single zero byte, then end of stream.
  */
 public final class FakeSampleStream implements SampleStream {
 
   private final Format format;
 
   private boolean readFormat;
+  private boolean readSample;
 
   public FakeSampleStream(Format format) {
+    this(format, true);
+  }
+
+  public FakeSampleStream(Format format, boolean shouldOutputSample) {
     this.format = format;
+    readSample = !shouldOutputSample;
   }
 
   @Override
@@ -48,6 +54,13 @@ public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer,
       formatHolder.format = format;
       readFormat = true;
       return C.RESULT_FORMAT_READ;
+    } else if (!readSample) {
+      buffer.timeUs = 0;
+      buffer.ensureSpaceForWrite(1);
+      buffer.data.put((byte) 0);
+      buffer.flip();
+      readSample = true;
+      return C.RESULT_BUFFER_READ;
     } else {
       buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
       return C.RESULT_BUFFER_READ;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSimpleExoPlayer.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSimpleExoPlayer.java
deleted file mode 100644
index 4d53a6c89d..0000000000
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeSimpleExoPlayer.java
+++ /dev/null
@@ -1,575 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.testutil;
-
-import android.os.ConditionVariable;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.support.annotation.Nullable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayer;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.LoadControl;
-import com.google.android.exoplayer2.PlaybackParameters;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Renderer;
-import com.google.android.exoplayer2.RendererCapabilities;
-import com.google.android.exoplayer2.RenderersFactory;
-import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.Timeline.Period;
-import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
-import com.google.android.exoplayer2.source.SampleStream;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.trackselection.TrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
-import com.google.android.exoplayer2.trackselection.TrackSelector;
-import com.google.android.exoplayer2.trackselection.TrackSelector.InvalidationListener;
-import com.google.android.exoplayer2.trackselection.TrackSelectorResult;
-import com.google.android.exoplayer2.util.Assertions;
-import java.util.Arrays;
-import java.util.concurrent.CopyOnWriteArraySet;
-
-/**
- * Fake {@link SimpleExoPlayer} which runs a simplified copy of the playback loop as fast as
- * possible without waiting. It does only support single period timelines and does not support
- * updates during playback (like seek, timeline changes, repeat mode changes).
- */
-public class FakeSimpleExoPlayer extends SimpleExoPlayer {
-
-  private FakeExoPlayer player;
-
-  public FakeSimpleExoPlayer(RenderersFactory renderersFactory, TrackSelector trackSelector,
-      LoadControl loadControl, FakeClock clock) {
-    super (renderersFactory, trackSelector, loadControl);
-    player.setFakeClock(clock);
-  }
-
-  @Override
-  protected ExoPlayer createExoPlayerImpl(Renderer[] renderers, TrackSelector trackSelector,
-      LoadControl loadControl) {
-    this.player = new FakeExoPlayer(renderers, trackSelector, loadControl);
-    return player;
-  }
-
-  private static class FakeExoPlayer implements ExoPlayer, MediaSource.Listener,
-      MediaPeriod.Callback, Runnable {
-
-    private final Renderer[] renderers;
-    private final TrackSelector trackSelector;
-    private final LoadControl loadControl;
-    private final CopyOnWriteArraySet<Player.EventListener> eventListeners;
-    private final HandlerThread playbackThread;
-    private final Handler playbackHandler;
-    private final Handler eventListenerHandler;
-
-    private FakeClock clock;
-    private MediaSource mediaSource;
-    private Timeline timeline;
-    private Object manifest;
-    private MediaPeriod mediaPeriod;
-    private TrackSelectorResult selectorResult;
-
-    private boolean isStartingUp;
-    private boolean isLoading;
-    private int playbackState;
-    private long rendererPositionUs;
-    private long durationUs;
-    private volatile long currentPositionMs;
-    private volatile long bufferedPositionMs;
-
-    public FakeExoPlayer(Renderer[] renderers, TrackSelector trackSelector,
-        LoadControl loadControl) {
-      this.renderers = renderers;
-      this.trackSelector = trackSelector;
-      this.loadControl = loadControl;
-      this.eventListeners = new CopyOnWriteArraySet<>();
-      Looper eventListenerLooper = Looper.myLooper();
-      this.eventListenerHandler = new Handler(eventListenerLooper != null ? eventListenerLooper
-          : Looper.getMainLooper());
-      this.playbackThread = new HandlerThread("FakeExoPlayer Thread");
-      playbackThread.start();
-      this.playbackHandler = new Handler(playbackThread.getLooper());
-      this.isStartingUp = true;
-      this.isLoading = false;
-      this.playbackState = Player.STATE_IDLE;
-      this.durationUs = C.TIME_UNSET;
-    }
-
-    public void setFakeClock(FakeClock clock) {
-      this.clock = clock;
-    }
-
-    @Override
-    public void addListener(Player.EventListener listener) {
-      eventListeners.add(listener);
-    }
-
-    @Override
-    public void removeListener(Player.EventListener listener) {
-      eventListeners.remove(listener);
-    }
-
-    @Override
-    public int getPlaybackState() {
-      return playbackState;
-    }
-
-    @Override
-    public void setPlayWhenReady(boolean playWhenReady) {
-      if (!playWhenReady) {
-        throw new UnsupportedOperationException();
-      }
-    }
-
-    @Override
-    public boolean getPlayWhenReady() {
-      return true;
-    }
-
-    @Override
-    public void setRepeatMode(@RepeatMode int repeatMode) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public int getRepeatMode() {
-      return Player.REPEAT_MODE_OFF;
-    }
-
-    @Override
-    public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean getShuffleModeEnabled() {
-      return false;
-    }
-
-    @Override
-    public boolean isLoading() {
-      return isLoading;
-    }
-
-    @Override
-    public void seekToDefaultPosition() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void seekToDefaultPosition(int windowIndex) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void seekTo(long positionMs) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void seekTo(int windowIndex, long positionMs) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void setPlaybackParameters(@Nullable PlaybackParameters playbackParameters) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public PlaybackParameters getPlaybackParameters() {
-      return PlaybackParameters.DEFAULT;
-    }
-
-    @Override
-    public void stop() {
-      playbackHandler.post(new Runnable() {
-        @Override
-        public void run () {
-          playbackHandler.removeCallbacksAndMessages(null);
-          releaseMedia();
-          changePlaybackState(Player.STATE_IDLE);
-        }
-      });
-    }
-
-    @Override
-    @SuppressWarnings("ThreadJoinLoop")
-    public void release() {
-      stop();
-      playbackHandler.post(new Runnable() {
-        @Override
-        public void run () {
-          playbackHandler.removeCallbacksAndMessages(null);
-          playbackThread.quit();
-        }
-      });
-      while (playbackThread.isAlive()) {
-        try {
-          playbackThread.join();
-        } catch (InterruptedException e) {
-          // Ignore interrupt.
-        }
-      }
-    }
-
-    @Override
-    public int getRendererCount() {
-      return renderers.length;
-    }
-
-    @Override
-    public int getRendererType(int index) {
-      return renderers[index].getTrackType();
-    }
-
-    @Override
-    public TrackGroupArray getCurrentTrackGroups() {
-      return selectorResult != null ? selectorResult.groups : null;
-    }
-
-    @Override
-    public TrackSelectionArray getCurrentTrackSelections() {
-      return selectorResult != null ? selectorResult.selections : null;
-    }
-
-    @Nullable
-    @Override
-    public Object getCurrentManifest() {
-      return manifest;
-    }
-
-    @Override
-    public Timeline getCurrentTimeline() {
-      return timeline;
-    }
-
-    @Override
-    public int getCurrentPeriodIndex() {
-      return 0;
-    }
-
-    @Override
-    public int getCurrentWindowIndex() {
-      return 0;
-    }
-
-    @Override
-    public int getNextWindowIndex() {
-      return C.INDEX_UNSET;
-    }
-
-    @Override
-    public int getPreviousWindowIndex() {
-      return C.INDEX_UNSET;
-    }
-
-    @Override
-    public long getDuration() {
-      return C.usToMs(durationUs);
-    }
-
-    @Override
-    public long getCurrentPosition() {
-      return currentPositionMs;
-    }
-
-    @Override
-    public long getBufferedPosition() {
-      return bufferedPositionMs == C.TIME_END_OF_SOURCE ? getDuration() : bufferedPositionMs;
-    }
-
-    @Override
-    public int getBufferedPercentage() {
-      long duration = getDuration();
-      return duration == C.TIME_UNSET ? 0 : (int) (getBufferedPosition() * 100 / duration);
-    }
-
-    @Override
-    public boolean isCurrentWindowDynamic() {
-      return false;
-    }
-
-    @Override
-    public boolean isCurrentWindowSeekable() {
-      return false;
-    }
-
-    @Override
-    public boolean isPlayingAd() {
-      return false;
-    }
-
-    @Override
-    public int getCurrentAdGroupIndex() {
-      return 0;
-    }
-
-    @Override
-    public int getCurrentAdIndexInAdGroup() {
-      return 0;
-    }
-
-    @Override
-    public long getContentPosition() {
-      return getCurrentPosition();
-    }
-
-    @Override
-    public Looper getPlaybackLooper() {
-      return playbackThread.getLooper();
-    }
-
-    @Override
-    public void prepare(MediaSource mediaSource) {
-      prepare(mediaSource, true, true);
-    }
-
-    @Override
-    public void prepare(final MediaSource mediaSource, boolean resetPosition, boolean resetState) {
-      if (!resetPosition || !resetState) {
-        throw new UnsupportedOperationException();
-      }
-      this.mediaSource = mediaSource;
-      playbackHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          mediaSource.prepareSource(FakeExoPlayer.this, true, FakeExoPlayer.this);
-        }
-      });
-    }
-
-    @Override
-    public void sendMessages(ExoPlayerMessage... messages) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void blockingSendMessages(ExoPlayerMessage... messages) {
-      throw new UnsupportedOperationException();
-    }
-
-    // MediaSource.Listener
-
-    @Override
-    public void onSourceInfoRefreshed(MediaSource source, final Timeline timeline,
-        final @Nullable Object manifest) {
-      if (this.timeline != null) {
-        throw new UnsupportedOperationException();
-      }
-      Assertions.checkArgument(timeline.getPeriodCount() == 1);
-      Assertions.checkArgument(timeline.getWindowCount() == 1);
-      final ConditionVariable waitForNotification = new ConditionVariable();
-      eventListenerHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          for (Player.EventListener eventListener : eventListeners) {
-            FakeExoPlayer.this.durationUs = timeline.getPeriod(0, new Period()).durationUs;
-            FakeExoPlayer.this.timeline = timeline;
-            FakeExoPlayer.this.manifest = manifest;
-            eventListener.onTimelineChanged(timeline, manifest);
-            waitForNotification.open();
-          }
-        }
-      });
-      waitForNotification.block();
-      this.mediaPeriod = mediaSource.createPeriod(new MediaPeriodId(0), loadControl.getAllocator());
-      mediaPeriod.prepare(this, 0);
-    }
-
-    // MediaPeriod.Callback
-
-    @Override
-    public void onContinueLoadingRequested(MediaPeriod source) {
-      maybeContinueLoading();
-    }
-
-    @Override
-    public void onPrepared(MediaPeriod mediaPeriod) {
-      try {
-        initializePlaybackLoop();
-      } catch (ExoPlaybackException e) {
-        handlePlayerError(e);
-      }
-    }
-
-    // Runnable (Playback loop).
-
-    @Override
-    public void run() {
-      try {
-        maybeContinueLoading();
-        boolean allRenderersEnded = true;
-        boolean allRenderersReadyOrEnded = true;
-        if (playbackState == Player.STATE_READY) {
-          for (Renderer renderer : renderers) {
-            renderer.render(rendererPositionUs, C.msToUs(clock.elapsedRealtime()));
-            if (!renderer.isEnded()) {
-              allRenderersEnded = false;
-            }
-            if (!(renderer.isReady() || renderer.isEnded())) {
-              allRenderersReadyOrEnded = false;
-            }
-          }
-        }
-        if (rendererPositionUs >= durationUs && allRenderersEnded) {
-          changePlaybackState(Player.STATE_ENDED);
-          return;
-        }
-        long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
-        if (playbackState == Player.STATE_BUFFERING && allRenderersReadyOrEnded
-            && haveSufficientBuffer(!isStartingUp, rendererPositionUs, bufferedPositionUs)) {
-          changePlaybackState(Player.STATE_READY);
-          isStartingUp = false;
-        } else if (playbackState == Player.STATE_READY && !allRenderersReadyOrEnded) {
-          changePlaybackState(Player.STATE_BUFFERING);
-        }
-        // Advance simulated time by 10ms.
-        clock.advanceTime(10);
-        if (playbackState == Player.STATE_READY) {
-          rendererPositionUs += 10000;
-        }
-        this.currentPositionMs = C.usToMs(rendererPositionUs);
-        this.bufferedPositionMs = C.usToMs(bufferedPositionUs);
-        playbackHandler.post(this);
-      } catch (ExoPlaybackException e) {
-        handlePlayerError(e);
-      }
-    }
-
-    // Internal logic
-
-    private void initializePlaybackLoop() throws ExoPlaybackException {
-      Assertions.checkNotNull(clock);
-      trackSelector.init(new InvalidationListener() {
-        @Override
-        public void onTrackSelectionsInvalidated() {
-          throw new IllegalStateException();
-        }
-      });
-      RendererCapabilities[] rendererCapabilities = new RendererCapabilities[renderers.length];
-      for (int i = 0; i < renderers.length; i++) {
-        rendererCapabilities[i] = renderers[i].getCapabilities();
-      }
-      selectorResult = trackSelector.selectTracks(rendererCapabilities,
-          mediaPeriod.getTrackGroups());
-      SampleStream[] sampleStreams = new SampleStream[renderers.length];
-      boolean[] mayRetainStreamFlags = new boolean[renderers.length];
-      Arrays.fill(mayRetainStreamFlags, true);
-      mediaPeriod.selectTracks(selectorResult.selections.getAll(), mayRetainStreamFlags,
-          sampleStreams, new boolean[renderers.length], 0);
-      eventListenerHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          for (Player.EventListener eventListener : eventListeners) {
-            eventListener.onTracksChanged(selectorResult.groups, selectorResult.selections);
-          }
-        }
-      });
-
-      loadControl.onPrepared();
-      loadControl.onTracksSelected(renderers, selectorResult.groups, selectorResult.selections);
-
-      for (int i = 0; i < renderers.length; i++) {
-        TrackSelection selection = selectorResult.selections.get(i);
-        Format[] formats = new Format[selection.length()];
-        for (int j = 0; j < formats.length; j++) {
-          formats[j] = selection.getFormat(j);
-        }
-        renderers[i].enable(selectorResult.rendererConfigurations[i], formats, sampleStreams[i], 0,
-            false, 0);
-        renderers[i].setCurrentStreamFinal();
-      }
-
-      rendererPositionUs = 0;
-      changePlaybackState(Player.STATE_BUFFERING);
-      playbackHandler.post(this);
-    }
-
-    private void maybeContinueLoading() {
-      boolean newIsLoading = false;
-      long nextLoadPositionUs = mediaPeriod.getNextLoadPositionUs();
-      if (nextLoadPositionUs != C.TIME_END_OF_SOURCE) {
-        long bufferedDurationUs = nextLoadPositionUs - rendererPositionUs;
-        if (loadControl.shouldContinueLoading(bufferedDurationUs)) {
-          newIsLoading = true;
-          mediaPeriod.continueLoading(rendererPositionUs);
-        }
-      }
-      if (newIsLoading != isLoading) {
-        isLoading = newIsLoading;
-        eventListenerHandler.post(new Runnable() {
-          @Override
-          public void run() {
-            for (Player.EventListener eventListener : eventListeners) {
-              eventListener.onLoadingChanged(isLoading);
-            }
-          }
-        });
-      }
-    }
-
-    private boolean haveSufficientBuffer(boolean rebuffering, long rendererPositionUs,
-        long bufferedPositionUs) {
-      if (bufferedPositionUs == C.TIME_END_OF_SOURCE) {
-        return true;
-      }
-      return loadControl.shouldStartPlayback(bufferedPositionUs - rendererPositionUs, rebuffering);
-    }
-
-    private void handlePlayerError(final ExoPlaybackException e) {
-      eventListenerHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          for (Player.EventListener listener : eventListeners) {
-            listener.onPlayerError(e);
-          }
-        }
-      });
-      changePlaybackState(Player.STATE_ENDED);
-    }
-
-    private void changePlaybackState(final int playbackState) {
-      this.playbackState = playbackState;
-      eventListenerHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          for (Player.EventListener listener : eventListeners) {
-            listener.onPlayerStateChanged(true, playbackState);
-          }
-        }
-      });
-    }
-
-    private void releaseMedia() {
-      if (mediaSource != null) {
-        if (mediaPeriod != null) {
-          mediaSource.releasePeriod(mediaPeriod);
-          mediaPeriod = null;
-        }
-        mediaSource.releaseSource();
-        mediaSource = null;
-      }
-    }
-
-  }
-
-}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
index 2937ee2770..7b27d3bd80 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTimeline.java
@@ -15,8 +15,10 @@
  */
 package com.google.android.exoplayer2.testutil;
 
+import android.util.Pair;
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.ads.AdPlaybackState;
 import com.google.android.exoplayer2.util.Util;
 import java.util.Arrays;
 
@@ -30,38 +32,86 @@
    */
   public static final class TimelineWindowDefinition {
 
-    private static final int WINDOW_DURATION_US = 100000;
+    /** Default test window duration in microseconds. */
+    public static final long DEFAULT_WINDOW_DURATION_US = 10 * C.MICROS_PER_SECOND;
 
     public final int periodCount;
     public final Object id;
     public final boolean isSeekable;
     public final boolean isDynamic;
     public final long durationUs;
-    public final int adGroupsPerPeriodCount;
-    public final int adsPerAdGroupCount;
+    public final AdPlaybackState adPlaybackState;
+
+    /**
+     * Creates a seekable, non-dynamic window definition with one period with a duration of
+     * {@link #DEFAULT_WINDOW_DURATION_US}.
+     */
+    public TimelineWindowDefinition() {
+      this(1, 0, true, false, DEFAULT_WINDOW_DURATION_US);
+    }
 
+    /**
+     * Creates a seekable, non-dynamic window definition with a duration of
+     * {@link #DEFAULT_WINDOW_DURATION_US}.
+     *
+     * @param periodCount The number of periods in the window. Each period get an equal slice of the
+     *     total window duration.
+     * @param id The UID of the window.
+     */
     public TimelineWindowDefinition(int periodCount, Object id) {
-      this(periodCount, id, true, false, WINDOW_DURATION_US);
+      this(periodCount, id, true, false, DEFAULT_WINDOW_DURATION_US);
     }
 
+    /**
+     * Creates a window definition with one period.
+     *
+     * @param isSeekable Whether the window is seekable.
+     * @param isDynamic Whether the window is dynamic.
+     * @param durationUs The duration of the window in microseconds.
+     */
     public TimelineWindowDefinition(boolean isSeekable, boolean isDynamic, long durationUs) {
       this(1, 0, isSeekable, isDynamic, durationUs);
     }
 
+    /**
+     * Creates a window definition.
+     *
+     * @param periodCount The number of periods in the window. Each period get an equal slice of the
+     *     total window duration.
+     * @param id The UID of the window.
+     * @param isSeekable Whether the window is seekable.
+     * @param isDynamic Whether the window is dynamic.
+     * @param durationUs The duration of the window in microseconds.
+     */
     public TimelineWindowDefinition(int periodCount, Object id, boolean isSeekable,
         boolean isDynamic, long durationUs) {
-      this(periodCount, id, isSeekable, isDynamic, durationUs, 0, 0);
+      this(periodCount, id, isSeekable, isDynamic, durationUs, AdPlaybackState.NONE);
     }
 
-    public TimelineWindowDefinition(int periodCount, Object id, boolean isSeekable,
-        boolean isDynamic, long durationUs, int adGroupsCountPerPeriod, int adsPerAdGroupCount) {
+    /**
+     * Creates a window definition with ad groups.
+     *
+     * @param periodCount The number of periods in the window. Each period get an equal slice of the
+     *     total window duration.
+     * @param id The UID of the window.
+     * @param isSeekable Whether the window is seekable.
+     * @param isDynamic Whether the window is dynamic.
+     * @param durationUs The duration of the window in microseconds.
+     * @param adPlaybackState The ad playback state.
+     */
+    public TimelineWindowDefinition(
+        int periodCount,
+        Object id,
+        boolean isSeekable,
+        boolean isDynamic,
+        long durationUs,
+        AdPlaybackState adPlaybackState) {
       this.periodCount = periodCount;
       this.id = id;
       this.isSeekable = isSeekable;
       this.isDynamic = isDynamic;
       this.durationUs = durationUs;
-      this.adGroupsPerPeriodCount = adGroupsCountPerPeriod;
-      this.adsPerAdGroupCount = adsPerAdGroupCount;
+      this.adPlaybackState = adPlaybackState;
     }
 
   }
@@ -71,6 +121,42 @@ public TimelineWindowDefinition(int periodCount, Object id, boolean isSeekable,
   private final TimelineWindowDefinition[] windowDefinitions;
   private final int[] periodOffsets;
 
+  /**
+   * Returns an ad playback state with the specified number of ads in each of the specified ad
+   * groups, each ten seconds long.
+   *
+   * @param adsPerAdGroup The number of ads per ad group.
+   * @param adGroupTimesUs The times of ad groups, in microseconds.
+   * @return The ad playback state.
+   */
+  public static AdPlaybackState createAdPlaybackState(int adsPerAdGroup, long... adGroupTimesUs) {
+    int adGroupCount = adGroupTimesUs.length;
+    AdPlaybackState adPlaybackState = new AdPlaybackState(adGroupTimesUs);
+    long[][] adDurationsUs = new long[adGroupCount][];
+    for (int i = 0; i < adGroupCount; i++) {
+      adPlaybackState = adPlaybackState.withAdCount(i, adsPerAdGroup);
+      adDurationsUs[i] = new long[adsPerAdGroup];
+      Arrays.fill(adDurationsUs[i], AD_DURATION_US);
+    }
+    adPlaybackState = adPlaybackState.withAdDurationsUs(adDurationsUs);
+    return adPlaybackState;
+  }
+
+  /**
+   * Creates a fake timeline with the given number of seekable, non-dynamic windows with one period
+   * with a duration of {@link TimelineWindowDefinition#DEFAULT_WINDOW_DURATION_US} each.
+   *
+   * @param windowCount The number of windows.
+   */
+  public FakeTimeline(int windowCount) {
+    this(createDefaultWindowDefinitions(windowCount));
+  }
+
+  /**
+   * Creates a fake timeline with the given window definitions.
+   *
+   * @param windowDefinitions A list of {@link TimelineWindowDefinition}s.
+   */
   public FakeTimeline(TimelineWindowDefinition... windowDefinitions) {
     this.windowDefinitions = windowDefinitions;
     periodOffsets = new int[windowDefinitions.length + 1];
@@ -106,39 +192,33 @@ public Period getPeriod(int periodIndex, Period period, boolean setIds) {
     int windowPeriodIndex = periodIndex - periodOffsets[windowIndex];
     TimelineWindowDefinition windowDefinition = windowDefinitions[windowIndex];
     Object id = setIds ? windowPeriodIndex : null;
-    Object uid = setIds ? periodIndex : null;
+    Object uid = setIds ? Pair.create(windowDefinition.id, windowPeriodIndex) : null;
     long periodDurationUs = windowDefinition.durationUs / windowDefinition.periodCount;
     long positionInWindowUs = periodDurationUs * windowPeriodIndex;
-    if (windowDefinition.adGroupsPerPeriodCount == 0) {
-      return period.set(id, uid, windowIndex, periodDurationUs, positionInWindowUs);
-    } else {
-      int adGroups = windowDefinition.adGroupsPerPeriodCount;
-      long[] adGroupTimesUs = new long[adGroups];
-      int[] adCounts = new int[adGroups];
-      int[] adLoadedAndPlayedCounts = new int[adGroups];
-      long[][] adDurationsUs = new long[adGroups][];
-      long adResumePositionUs = 0;
-      long adGroupOffset = adGroups > 1 ? periodDurationUs / (adGroups - 1) : 0;
-      for (int i = 0; i < adGroups; i++) {
-        adGroupTimesUs[i] = i * adGroupOffset;
-        adCounts[i] = windowDefinition.adsPerAdGroupCount;
-        adLoadedAndPlayedCounts[i] = 0;
-        adDurationsUs[i] = new long[adCounts[i]];
-        Arrays.fill(adDurationsUs[i], AD_DURATION_US);
-      }
-      return period.set(id, uid, windowIndex, periodDurationUs, positionInWindowUs, adGroupTimesUs,
-          adCounts, adLoadedAndPlayedCounts, adLoadedAndPlayedCounts, adDurationsUs,
-          adResumePositionUs);
-    }
+    return period.set(
+        id,
+        uid,
+        windowIndex,
+        periodDurationUs,
+        positionInWindowUs,
+        windowDefinition.adPlaybackState);
   }
 
   @Override
   public int getIndexOfPeriod(Object uid) {
-    if (!(uid instanceof Integer)) {
-      return C.INDEX_UNSET;
+    Period period = new Period();
+    for (int i = 0; i < getPeriodCount(); i++) {
+      if (getPeriod(i, period, true).uid.equals(uid)) {
+        return i;
+      }
     }
-    int index = (Integer) uid;
-    return index >= 0 && index < getPeriodCount() ? index : C.INDEX_UNSET;
+    return C.INDEX_UNSET;
+  }
+
+  private static TimelineWindowDefinition[] createDefaultWindowDefinitions(int windowCount) {
+    TimelineWindowDefinition[] windowDefinitions = new TimelineWindowDefinition[windowCount];
+    Arrays.fill(windowDefinitions, new TimelineWindowDefinition());
+    return windowDefinitions;
   }
 
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java
index b14e6f60ef..639cb82c2d 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackOutput.java
@@ -15,7 +15,8 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.test.MoreAsserts;
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.android.exoplayer2.C;
 import com.google.android.exoplayer2.Format;
 import com.google.android.exoplayer2.extractor.ExtractorInput;
@@ -25,7 +26,6 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import junit.framework.Assert;
 
 /**
  * A fake {@link TrackOutput}.
@@ -98,15 +98,15 @@ public void sampleMetadata(long timeUs, @C.BufferFlags int flags, int size, int
   }
 
   public void assertSampleCount(int count) {
-    Assert.assertEquals(count, sampleTimesUs.size());
+    assertThat(sampleTimesUs).hasSize(count);
   }
 
   public void assertSample(int index, byte[] data, long timeUs, int flags, CryptoData cryptoData) {
     byte[] actualData = getSampleData(index);
-    MoreAsserts.assertEquals(data, actualData);
-    Assert.assertEquals(timeUs, (long) sampleTimesUs.get(index));
-    Assert.assertEquals(flags, (int) sampleFlags.get(index));
-    Assert.assertEquals(cryptoData, cryptoDatas.get(index));
+    assertThat(actualData).isEqualTo(data);
+    assertThat(sampleTimesUs.get(index)).isEqualTo(timeUs);
+    assertThat(sampleFlags.get(index)).isEqualTo(flags);
+    assertThat(cryptoDatas.get(index)).isEqualTo(cryptoData);
   }
 
   public byte[] getSampleData(int index) {
@@ -115,18 +115,18 @@ public void assertSample(int index, byte[] data, long timeUs, int flags, CryptoD
   }
 
   public void assertEquals(FakeTrackOutput expected) {
-    Assert.assertEquals(expected.format, format);
-    Assert.assertEquals(expected.sampleTimesUs.size(), sampleTimesUs.size());
-    MoreAsserts.assertEquals(expected.sampleData, sampleData);
+    assertThat(format).isEqualTo(expected.format);
+    assertThat(sampleTimesUs).hasSize(expected.sampleTimesUs.size());
+    assertThat(sampleData).isEqualTo(expected.sampleData);
     for (int i = 0; i < sampleTimesUs.size(); i++) {
-      Assert.assertEquals(expected.sampleTimesUs.get(i), sampleTimesUs.get(i));
-      Assert.assertEquals(expected.sampleFlags.get(i), sampleFlags.get(i));
-      Assert.assertEquals(expected.sampleStartOffsets.get(i), sampleStartOffsets.get(i));
-      Assert.assertEquals(expected.sampleEndOffsets.get(i), sampleEndOffsets.get(i));
+      assertThat(sampleTimesUs.get(i)).isEqualTo(expected.sampleTimesUs.get(i));
+      assertThat(sampleFlags.get(i)).isEqualTo(expected.sampleFlags.get(i));
+      assertThat(sampleStartOffsets.get(i)).isEqualTo(expected.sampleStartOffsets.get(i));
+      assertThat(sampleEndOffsets.get(i)).isEqualTo(expected.sampleEndOffsets.get(i));
       if (expected.cryptoDatas.get(i) == null) {
-        Assert.assertNull(cryptoDatas.get(i));
+        assertThat(cryptoDatas.get(i)).isNull();
       } else {
-        Assert.assertEquals(expected.cryptoDatas.get(i), cryptoDatas.get(i));
+        assertThat(cryptoDatas.get(i)).isEqualTo(expected.cryptoDatas.get(i));
       }
     }
   }
@@ -160,6 +160,7 @@ public void dump(Dumper dumper) {
     }
     dumper.endBlock().endBlock();
 
+    dumper.add("total output bytes", sampleData.length);
     dumper.add("sample count", sampleTimesUs.size());
 
     for (int i = 0; i < sampleTimesUs.size(); i++) {
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
index 1ef1acd80b..6cbba48f1f 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/HostActivity.java
@@ -15,7 +15,7 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.fail;
 
 import android.app.Activity;
 import android.content.Context;
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/OggTestData.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/OggTestData.java
deleted file mode 100644
index 88b5de7f65..0000000000
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/OggTestData.java
+++ /dev/null
@@ -1,1074 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.testutil;
-
-
-/**
- * Provides ogg/vorbis test data in bytes for unit tests.
- */
-public final class OggTestData {
-
-  public static FakeExtractorInput createInput(byte[] data, boolean simulateUnknownLength) {
-    return new FakeExtractorInput.Builder().setData(data).setSimulateIOErrors(true)
-        .setSimulateUnknownLength(simulateUnknownLength).setSimulatePartialReads(true).build();
-  }
-
-  public static byte[] buildOggHeader(int headerType, long granule, int pageSequenceCounter,
-      int pageSegmentCount) {
-    return TestUtil.createByteArray(
-        0x4F, 0x67, 0x67, 0x53, // Oggs.
-        0x00, // Stream revision.
-        headerType,
-        (int) (granule) & 0xFF,
-        (int) (granule >> 8) & 0xFF,
-        (int) (granule >> 16) & 0xFF,
-        (int) (granule >> 24) & 0xFF,
-        (int) (granule >> 32) & 0xFF,
-        (int) (granule >> 40) & 0xFF,
-        (int) (granule >> 48) & 0xFF,
-        (int) (granule >> 56) & 0xFF,
-        0x00, // LSB of data serial number.
-        0x10,
-        0x00,
-        0x00, // MSB of data serial number.
-        (pageSequenceCounter) & 0xFF,
-        (pageSequenceCounter >> 8) & 0xFF,
-        (pageSequenceCounter >> 16) & 0xFF,
-        (pageSequenceCounter >> 24) & 0xFF,
-        0x00, // LSB of page checksum.
-        0x00,
-        0x10,
-        0x00, // MSB of page checksum.
-        pageSegmentCount);
-  }
-
-  /**
-   * Returns the initial two pages of bytes which by spec contain the three vorbis header packets:
-   * identification, comment and setup header.
-   */
-  public static byte[] getVorbisHeaderPages() {
-    byte[] data = new byte[VORBIS_HEADER_PAGES.length];
-    System.arraycopy(VORBIS_HEADER_PAGES, 0, data, 0,
-        VORBIS_HEADER_PAGES.length);
-    return data;
-  }
-
-  /**
-   * Returns a valid vorbis identification header in bytes.
-   */
-  public static byte[] getIdentificationHeaderData() {
-    int idHeaderStart = 28;
-    int idHeaderLength = 30;
-    byte[] idHeaderData = new byte[idHeaderLength];
-    System.arraycopy(VORBIS_HEADER_PAGES, idHeaderStart, idHeaderData, 0, idHeaderLength);
-    return idHeaderData;
-  }
-
-  /**
-   * Returns a valid vorbis comment header with 3 comments including utf8 chars in bytes.
-   */
-  public static byte[] getCommentHeaderDataUTF8() {
-    byte[] commentHeaderData = new byte[COMMENT_HEADER_WITH_UTF8.length];
-    System.arraycopy(COMMENT_HEADER_WITH_UTF8, 0, commentHeaderData, 0,
-        COMMENT_HEADER_WITH_UTF8.length);
-    return commentHeaderData;
-  }
-
-  /**
-   * Returns a valid vorbis setup header in bytes.
-   */
-  public static byte[] getSetupHeaderData() {
-    int setupHeaderStart = 146;
-    int setupHeaderLength = VORBIS_HEADER_PAGES.length - setupHeaderStart;
-    byte[] setupHeaderData = new byte[setupHeaderLength];
-    System.arraycopy(VORBIS_HEADER_PAGES, setupHeaderStart, setupHeaderData, 0, setupHeaderLength);
-    return setupHeaderData;
-  }
-
-  private static final byte[] COMMENT_HEADER_WITH_UTF8 = {
-      (byte) 0x03, (byte) 0x76, (byte) 0x6f, (byte) 0x72, // 3, v, o, r,
-      (byte) 0x62, (byte) 0x69, (byte) 0x73, (byte) 0x2b, // b, i, s, .
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x58,
-      (byte) 0x69, (byte) 0x70, (byte) 0x68, (byte) 0x2e,
-      (byte) 0x4f, (byte) 0x72, (byte) 0x67, (byte) 0x20,
-      (byte) 0x6c, (byte) 0x69, (byte) 0x62, (byte) 0x56,
-      (byte) 0x6f, (byte) 0x72, (byte) 0x62, (byte) 0x69,
-      (byte) 0x73, (byte) 0x20, (byte) 0x49, (byte) 0x20,
-      (byte) 0x32, (byte) 0x30, (byte) 0x31, (byte) 0x32,
-      (byte) 0x30, (byte) 0x32, (byte) 0x30, (byte) 0x33,
-      (byte) 0x20, (byte) 0x28, (byte) 0x4f, (byte) 0x6d,
-      (byte) 0x6e, (byte) 0x69, (byte) 0x70, (byte) 0x72,
-      (byte) 0x65, (byte) 0x73, (byte) 0x65, (byte) 0x6e,
-      (byte) 0x74, (byte) 0x29, (byte) 0x03, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x0a, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x4c,
-      (byte) 0x42, (byte) 0x55, (byte) 0x4d, (byte) 0x3d,
-      (byte) 0xc3, (byte) 0xa4, (byte) 0xc3, (byte) 0xb6,
-      (byte) 0x13, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x54, (byte) 0x49, (byte) 0x54, (byte) 0x4c,
-      (byte) 0x45, (byte) 0x3d, (byte) 0x41, (byte) 0x20,
-      (byte) 0x73, (byte) 0x61, (byte) 0x6d, (byte) 0x70,
-      (byte) 0x6c, (byte) 0x65, (byte) 0x20, (byte) 0x73,
-      (byte) 0x6f, (byte) 0x6e, (byte) 0x67, (byte) 0x0d,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
-      (byte) 0x52, (byte) 0x54, (byte) 0x49, (byte) 0x53,
-      (byte) 0x54, (byte) 0x3d, (byte) 0x47, (byte) 0x6f,
-      (byte) 0x6f, (byte) 0x67, (byte) 0x6c, (byte) 0x65,
-      (byte) 0x01
-  };
-
-  // two OGG pages with 3 packets (id, comment and setup header)
-  // length: 3743 bytes
-  private static final byte[] VORBIS_HEADER_PAGES = {     /* capture pattern ogg header 1 */
-      (byte) 0x4f, (byte) 0x67, (byte) 0x67, (byte) 0x53, // O,g,g,S  : start pos 0
-      (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x5e, (byte) 0x5f,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x83, (byte) 0x36,
-      (byte) 0xe3, (byte) 0x49, (byte) 0x01, (byte) 0x1e, /* capture pattern vorbis id header */
-      (byte) 0x01, (byte) 0x76, (byte) 0x6f, (byte) 0x72, // 1,v,o,r  : start pos 28
-      (byte) 0x62, (byte) 0x69, (byte) 0x73, (byte) 0x00, // b,i,s,.
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02,
-      (byte) 0x22, (byte) 0x56, (byte) 0x00, (byte) 0x00,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0x6a, (byte) 0x04, (byte) 0x01, (byte) 0x00,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, /* capture pattern ogg header 2 */
-      (byte) 0xa9, (byte) 0x01, (byte) 0x4f, (byte) 0x67, // .,.,O,g  : start pos 86
-      (byte) 0x67, (byte) 0x53, (byte) 0x00, (byte) 0x00, // g,S,.,.
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x5e, (byte) 0x5f, (byte) 0x00, (byte) 0x00,
-      (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x69, (byte) 0xf8, (byte) 0xeb, (byte) 0xe1,
-      (byte) 0x10, (byte) 0x2d, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
-      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, /* capture pattern vorbis comment header*/
-      (byte) 0x1b, (byte) 0x03, (byte) 0x76, (byte) 0x6f, // .,3,v,o  : start pos 101
-      (byte) 0x72, (byte) 0x62, (byte) 0x69, (byte) 0x73, // r,b,i,s
-      (byte) 0x1d, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x58, (byte) 0x69, (byte) 0x70, (byte) 0x68,
-      (byte) 0x2e, (byte) 0x4f, (byte) 0x72, (byte) 0x67,
-      (byte) 0x20, (byte) 0x6c, (byte) 0x69, (byte) 0x62,
-      (byte) 0x56, (byte) 0x6f, (byte) 0x72, (byte) 0x62,
-      (byte) 0x69, (byte) 0x73, (byte) 0x20, (byte) 0x49,
-      (byte) 0x20, (byte) 0x32, (byte) 0x30, (byte) 0x30,
-      (byte) 0x33, (byte) 0x30, (byte) 0x39, (byte) 0x30,
-      (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, /* capture pattern vorbis setup header */
-      (byte) 0x00, (byte) 0x01, (byte) 0x05, (byte) 0x76, // .,.,5,v  : start pos 146
-      (byte) 0x6f, (byte) 0x72, (byte) 0x62, (byte) 0x69, // o,r,b,i
-      (byte) 0x73, (byte) 0x22, (byte) 0x42, (byte) 0x43, // s,.
-      (byte) 0x56, (byte) 0x01, (byte) 0x00, (byte) 0x40,
-      (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x42,
-      (byte) 0x10, (byte) 0x2a, (byte) 0x05, (byte) 0xad,
-      (byte) 0x63, (byte) 0x8e, (byte) 0x3a, (byte) 0xc8,
-      (byte) 0x15, (byte) 0x21, (byte) 0x8c, (byte) 0x19,
-      (byte) 0xa2, (byte) 0xa0, (byte) 0x42, (byte) 0xca,
-      (byte) 0x29, (byte) 0xc7, (byte) 0x1d, (byte) 0x42,
-      (byte) 0xd0, (byte) 0x21, (byte) 0xa3, (byte) 0x24,
-      (byte) 0x43, (byte) 0x88, (byte) 0x3a, (byte) 0xc6,
-      (byte) 0x35, (byte) 0xc7, (byte) 0x18, (byte) 0x63,
-      (byte) 0x47, (byte) 0xb9, (byte) 0x64, (byte) 0x8a,
-      (byte) 0x42, (byte) 0xc9, (byte) 0x81, (byte) 0xd0,
-      (byte) 0x90, (byte) 0x55, (byte) 0x00, (byte) 0x00,
-      (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0xa4,
-      (byte) 0x1c, (byte) 0x57, (byte) 0x50, (byte) 0x72,
-      (byte) 0x49, (byte) 0x2d, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0xa3, (byte) 0x18, (byte) 0x57,
-      (byte) 0xcc, (byte) 0x71, (byte) 0xe8, (byte) 0x20,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xe5,
-      (byte) 0x20, (byte) 0x67, (byte) 0xcc, (byte) 0x71,
-      (byte) 0x09, (byte) 0x25, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0x8e, (byte) 0x39, (byte) 0xe7,
-      (byte) 0x92, (byte) 0x72, (byte) 0x8e, (byte) 0x31,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xa3,
-      (byte) 0x18, (byte) 0x57, (byte) 0x0e, (byte) 0x72,
-      (byte) 0x29, (byte) 0x2d, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0x81, (byte) 0x14, (byte) 0x47,
-      (byte) 0x8a, (byte) 0x71, (byte) 0xa7, (byte) 0x18,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xa4,
-      (byte) 0x1c, (byte) 0x47, (byte) 0x8a, (byte) 0x71,
-      (byte) 0xa8, (byte) 0x18, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0x6d, (byte) 0x31, (byte) 0xb7,
-      (byte) 0x92, (byte) 0x72, (byte) 0xce, (byte) 0x39,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xe6,
-      (byte) 0x20, (byte) 0x87, (byte) 0x52, (byte) 0x72,
-      (byte) 0xae, (byte) 0x35, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0xa4, (byte) 0x18, (byte) 0x67,
-      (byte) 0x0e, (byte) 0x72, (byte) 0x0b, (byte) 0x25,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xc6,
-      (byte) 0x20, (byte) 0x67, (byte) 0xcc, (byte) 0x71,
-      (byte) 0xeb, (byte) 0x20, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0x8c, (byte) 0x35, (byte) 0xb7,
-      (byte) 0xd4, (byte) 0x72, (byte) 0xce, (byte) 0x39,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
-      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
-      (byte) 0xce, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0x8c, (byte) 0x31, (byte) 0xe7,
-      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0x6e,
-      (byte) 0x31, (byte) 0xe7, (byte) 0x16, (byte) 0x73,
-      (byte) 0xae, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
-      (byte) 0x1c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0x20,
-      (byte) 0x34, (byte) 0x64, (byte) 0x15, (byte) 0x00,
-      (byte) 0x90, (byte) 0x00, (byte) 0x00, (byte) 0xa0,
-      (byte) 0xa1, (byte) 0x28, (byte) 0x8a, (byte) 0xe2,
-      (byte) 0x28, (byte) 0x0e, (byte) 0x10, (byte) 0x1a,
-      (byte) 0xb2, (byte) 0x0a, (byte) 0x00, (byte) 0xc8,
-      (byte) 0x00, (byte) 0x00, (byte) 0x10, (byte) 0x40,
-      (byte) 0x71, (byte) 0x14, (byte) 0x47, (byte) 0x91,
-      (byte) 0x14, (byte) 0x4b, (byte) 0xb1, (byte) 0x1c,
-      (byte) 0xcb, (byte) 0xd1, (byte) 0x24, (byte) 0x0d,
-      (byte) 0x08, (byte) 0x0d, (byte) 0x59, (byte) 0x05,
-      (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
-      (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0xa0,
-      (byte) 0x48, (byte) 0x86, (byte) 0xa4, (byte) 0x48,
-      (byte) 0x8a, (byte) 0xa5, (byte) 0x58, (byte) 0x8e,
-      (byte) 0x66, (byte) 0x69, (byte) 0x9e, (byte) 0x26,
-      (byte) 0x7a, (byte) 0xa2, (byte) 0x28, (byte) 0x9a,
-      (byte) 0xa2, (byte) 0x2a, (byte) 0xab, (byte) 0xb2,
-      (byte) 0x69, (byte) 0xca, (byte) 0xb2, (byte) 0x2c,
-      (byte) 0xcb, (byte) 0xb2, (byte) 0xeb, (byte) 0xba,
-      (byte) 0x2e, (byte) 0x10, (byte) 0x1a, (byte) 0xb2,
-      (byte) 0x0a, (byte) 0x00, (byte) 0x48, (byte) 0x00,
-      (byte) 0x00, (byte) 0x50, (byte) 0x51, (byte) 0x14,
-      (byte) 0xc5, (byte) 0x70, (byte) 0x14, (byte) 0x07,
-      (byte) 0x08, (byte) 0x0d, (byte) 0x59, (byte) 0x05,
-      (byte) 0x00, (byte) 0x64, (byte) 0x00, (byte) 0x00,
-      (byte) 0x08, (byte) 0x60, (byte) 0x28, (byte) 0x8a,
-      (byte) 0xa3, (byte) 0x38, (byte) 0x8e, (byte) 0xe4,
-      (byte) 0x58, (byte) 0x92, (byte) 0xa5, (byte) 0x59,
-      (byte) 0x9e, (byte) 0x07, (byte) 0x84, (byte) 0x86,
-      (byte) 0xac, (byte) 0x02, (byte) 0x00, (byte) 0x80,
-      (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
-      (byte) 0x00, (byte) 0x50, (byte) 0x0c, (byte) 0x47,
-      (byte) 0xb1, (byte) 0x14, (byte) 0x4d, (byte) 0xf1,
-      (byte) 0x24, (byte) 0xcf, (byte) 0xf2, (byte) 0x3c,
-      (byte) 0xcf, (byte) 0xf3, (byte) 0x3c, (byte) 0xcf,
-      (byte) 0xf3, (byte) 0x3c, (byte) 0xcf, (byte) 0xf3,
-      (byte) 0x3c, (byte) 0xcf, (byte) 0xf3, (byte) 0x3c,
-      (byte) 0xcf, (byte) 0xf3, (byte) 0x3c, (byte) 0xcf,
-      (byte) 0xf3, (byte) 0x3c, (byte) 0x0d, (byte) 0x08,
-      (byte) 0x0d, (byte) 0x59, (byte) 0x05, (byte) 0x00,
-      (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x82, (byte) 0x28, (byte) 0x64, (byte) 0x18,
-      (byte) 0x03, (byte) 0x42, (byte) 0x43, (byte) 0x56,
-      (byte) 0x01, (byte) 0x00, (byte) 0x40, (byte) 0x00,
-      (byte) 0x00, (byte) 0x08, (byte) 0x21, (byte) 0x1a,
-      (byte) 0x19, (byte) 0x43, (byte) 0x9d, (byte) 0x52,
-      (byte) 0x12, (byte) 0x5c, (byte) 0x0a, (byte) 0x16,
-      (byte) 0x42, (byte) 0x1c, (byte) 0x11, (byte) 0x43,
-      (byte) 0x1d, (byte) 0x42, (byte) 0xce, (byte) 0x43,
-      (byte) 0xa9, (byte) 0xa5, (byte) 0x83, (byte) 0xe0,
-      (byte) 0x29, (byte) 0x85, (byte) 0x25, (byte) 0x63,
-      (byte) 0xd2, (byte) 0x53, (byte) 0xac, (byte) 0x41,
-      (byte) 0x08, (byte) 0x21, (byte) 0x7c, (byte) 0xef,
-      (byte) 0x3d, (byte) 0xf7, (byte) 0xde, (byte) 0x7b,
-      (byte) 0xef, (byte) 0x81, (byte) 0xd0, (byte) 0x90,
-      (byte) 0x55, (byte) 0x00, (byte) 0x00, (byte) 0x10,
-      (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x14,
-      (byte) 0x38, (byte) 0x88, (byte) 0x81, (byte) 0xc7,
-      (byte) 0x24, (byte) 0x08, (byte) 0x21, (byte) 0x84,
-      (byte) 0x62, (byte) 0x14, (byte) 0x27, (byte) 0x44,
-      (byte) 0x71, (byte) 0xa6, (byte) 0x20, (byte) 0x08,
-      (byte) 0x21, (byte) 0x84, (byte) 0xe5, (byte) 0x24,
-      (byte) 0x58, (byte) 0xca, (byte) 0x79, (byte) 0xe8,
-      (byte) 0x24, (byte) 0x08, (byte) 0xdd, (byte) 0x83,
-      (byte) 0x10, (byte) 0x42, (byte) 0xb8, (byte) 0x9c,
-      (byte) 0x7b, (byte) 0xcb, (byte) 0xb9, (byte) 0xf7,
-      (byte) 0xde, (byte) 0x7b, (byte) 0x20, (byte) 0x34,
-      (byte) 0x64, (byte) 0x15, (byte) 0x00, (byte) 0x00,
-      (byte) 0x08, (byte) 0x00, (byte) 0xc0, (byte) 0x20,
-      (byte) 0x84, (byte) 0x10, (byte) 0x42, (byte) 0x08,
-      (byte) 0x21, (byte) 0x84, (byte) 0x10, (byte) 0x42,
-      (byte) 0x08, (byte) 0x29, (byte) 0xa4, (byte) 0x94,
-      (byte) 0x52, (byte) 0x48, (byte) 0x29, (byte) 0xa6,
-      (byte) 0x98, (byte) 0x62, (byte) 0x8a, (byte) 0x29,
-      (byte) 0xc7, (byte) 0x1c, (byte) 0x73, (byte) 0xcc,
-      (byte) 0x31, (byte) 0xc7, (byte) 0x20, (byte) 0x83,
-      (byte) 0x0c, (byte) 0x32, (byte) 0xe8, (byte) 0xa0,
-      (byte) 0x93, (byte) 0x4e, (byte) 0x3a, (byte) 0xc9,
-      (byte) 0xa4, (byte) 0x92, (byte) 0x4e, (byte) 0x3a,
-      (byte) 0xca, (byte) 0x24, (byte) 0xa3, (byte) 0x8e,
-      (byte) 0x52, (byte) 0x6b, (byte) 0x29, (byte) 0xb5,
-      (byte) 0x14, (byte) 0x53, (byte) 0x4c, (byte) 0xb1,
-      (byte) 0xe5, (byte) 0x16, (byte) 0x63, (byte) 0xad,
-      (byte) 0xb5, (byte) 0xd6, (byte) 0x9c, (byte) 0x73,
-      (byte) 0xaf, (byte) 0x41, (byte) 0x29, (byte) 0x63,
-      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
-      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
-      (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
-      (byte) 0xc6, (byte) 0x18, (byte) 0x23, (byte) 0x08,
-      (byte) 0x0d, (byte) 0x59, (byte) 0x05, (byte) 0x00,
-      (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x10,
-      (byte) 0x06, (byte) 0x19, (byte) 0x64, (byte) 0x90,
-      (byte) 0x41, (byte) 0x08, (byte) 0x21, (byte) 0x84,
-      (byte) 0x14, (byte) 0x52, (byte) 0x48, (byte) 0x29,
-      (byte) 0xa6, (byte) 0x98, (byte) 0x72, (byte) 0xcc,
-      (byte) 0x31, (byte) 0xc7, (byte) 0x1c, (byte) 0x03,
-      (byte) 0x42, (byte) 0x43, (byte) 0x56, (byte) 0x01,
-      (byte) 0x00, (byte) 0x80, (byte) 0x00, (byte) 0x00,
-      (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x1c, (byte) 0x45, (byte) 0x52, (byte) 0x24,
-      (byte) 0x47, (byte) 0x72, (byte) 0x24, (byte) 0x47,
-      (byte) 0x92, (byte) 0x24, (byte) 0xc9, (byte) 0x92,
-      (byte) 0x2c, (byte) 0x49, (byte) 0x93, (byte) 0x3c,
-      (byte) 0xcb, (byte) 0xb3, (byte) 0x3c, (byte) 0xcb,
-      (byte) 0xb3, (byte) 0x3c, (byte) 0x4d, (byte) 0xd4,
-      (byte) 0x44, (byte) 0x4d, (byte) 0x15, (byte) 0x55,
-      (byte) 0xd5, (byte) 0x55, (byte) 0x6d, (byte) 0xd7,
-      (byte) 0xf6, (byte) 0x6d, (byte) 0x5f, (byte) 0xf6,
-      (byte) 0x6d, (byte) 0xdf, (byte) 0xd5, (byte) 0x65,
-      (byte) 0xdf, (byte) 0xf6, (byte) 0x65, (byte) 0xdb,
-      (byte) 0xd5, (byte) 0x65, (byte) 0x5d, (byte) 0x96,
-      (byte) 0x65, (byte) 0xdd, (byte) 0xb5, (byte) 0x6d,
-      (byte) 0x5d, (byte) 0xd6, (byte) 0x5d, (byte) 0x5d,
-      (byte) 0xd7, (byte) 0x75, (byte) 0x5d, (byte) 0xd7,
-      (byte) 0x75, (byte) 0x5d, (byte) 0xd7, (byte) 0x75,
-      (byte) 0x5d, (byte) 0xd7, (byte) 0x75, (byte) 0x5d,
-      (byte) 0xd7, (byte) 0x75, (byte) 0x5d, (byte) 0xd7,
-      (byte) 0x81, (byte) 0xd0, (byte) 0x90, (byte) 0x55,
-      (byte) 0x00, (byte) 0x80, (byte) 0x04, (byte) 0x00,
-      (byte) 0x80, (byte) 0x8e, (byte) 0xe4, (byte) 0x38,
-      (byte) 0x8e, (byte) 0xe4, (byte) 0x38, (byte) 0x8e,
-      (byte) 0xe4, (byte) 0x48, (byte) 0x8e, (byte) 0xa4,
-      (byte) 0x48, (byte) 0x0a, (byte) 0x10, (byte) 0x1a,
-      (byte) 0xb2, (byte) 0x0a, (byte) 0x00, (byte) 0x90,
-      (byte) 0x01, (byte) 0x00, (byte) 0x10, (byte) 0x00,
-      (byte) 0x80, (byte) 0xa3, (byte) 0x38, (byte) 0x8a,
-      (byte) 0xe3, (byte) 0x48, (byte) 0x8e, (byte) 0xe4,
-      (byte) 0x58, (byte) 0x8e, (byte) 0x25, (byte) 0x59,
-      (byte) 0x92, (byte) 0x26, (byte) 0x69, (byte) 0x96,
-      (byte) 0x67, (byte) 0x79, (byte) 0x96, (byte) 0xa7,
-      (byte) 0x79, (byte) 0x9a, (byte) 0xa8, (byte) 0x89,
-      (byte) 0x1e, (byte) 0x10, (byte) 0x1a, (byte) 0xb2,
-      (byte) 0x0a, (byte) 0x00, (byte) 0x00, (byte) 0x04,
-      (byte) 0x00, (byte) 0x10, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x80,
-      (byte) 0xa2, (byte) 0x28, (byte) 0x8a, (byte) 0xa3,
-      (byte) 0x38, (byte) 0x8e, (byte) 0x24, (byte) 0x59,
-      (byte) 0x96, (byte) 0xa6, (byte) 0x69, (byte) 0x9e,
-      (byte) 0xa7, (byte) 0x7a, (byte) 0xa2, (byte) 0x28,
-      (byte) 0x9a, (byte) 0xaa, (byte) 0xaa, (byte) 0x8a,
-      (byte) 0xa6, (byte) 0xa9, (byte) 0xaa, (byte) 0xaa,
-      (byte) 0x6a, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
-      (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x9a,
-      (byte) 0xa6, (byte) 0x69, (byte) 0x9a, (byte) 0xa6,
-      (byte) 0x69, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
-      (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x9a,
-      (byte) 0xa6, (byte) 0x69, (byte) 0x9a, (byte) 0xa6,
-      (byte) 0x69, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
-      (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x9a,
-      (byte) 0xa6, (byte) 0x69, (byte) 0x02, (byte) 0xa1,
-      (byte) 0x21, (byte) 0xab, (byte) 0x00, (byte) 0x00,
-      (byte) 0x09, (byte) 0x00, (byte) 0x00, (byte) 0x1d,
-      (byte) 0xc7, (byte) 0x71, (byte) 0x1c, (byte) 0x47,
-      (byte) 0x71, (byte) 0x1c, (byte) 0xc7, (byte) 0x71,
-      (byte) 0x24, (byte) 0x47, (byte) 0x92, (byte) 0x24,
-      (byte) 0x20, (byte) 0x34, (byte) 0x64, (byte) 0x15,
-      (byte) 0x00, (byte) 0x20, (byte) 0x03, (byte) 0x00,
-      (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x43,
-      (byte) 0x51, (byte) 0x1c, (byte) 0x45, (byte) 0x72,
-      (byte) 0x2c, (byte) 0xc7, (byte) 0x92, (byte) 0x34,
-      (byte) 0x4b, (byte) 0xb3, (byte) 0x3c, (byte) 0xcb,
-      (byte) 0xd3, (byte) 0x44, (byte) 0xcf, (byte) 0xf4,
-      (byte) 0x5c, (byte) 0x51, (byte) 0x36, (byte) 0x75,
-      (byte) 0x53, (byte) 0x57, (byte) 0x6d, (byte) 0x20,
-      (byte) 0x34, (byte) 0x64, (byte) 0x15, (byte) 0x00,
-      (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x20,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0xc7, (byte) 0x73,
-      (byte) 0x3c, (byte) 0xc7, (byte) 0x73, (byte) 0x3c,
-      (byte) 0xc9, (byte) 0x93, (byte) 0x3c, (byte) 0xcb,
-      (byte) 0x73, (byte) 0x3c, (byte) 0xc7, (byte) 0x93,
-      (byte) 0x3c, (byte) 0x49, (byte) 0xd3, (byte) 0x34,
-      (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
-      (byte) 0xd3, (byte) 0x34, (byte) 0x4d, (byte) 0xd3,
-      (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
-      (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
-      (byte) 0xd3, (byte) 0x34, (byte) 0x4d, (byte) 0xd3,
-      (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
-      (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
-      (byte) 0xd3, (byte) 0x34, (byte) 0x4d, (byte) 0xd3,
-      (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
-      (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
-      (byte) 0x03, (byte) 0x42, (byte) 0x43, (byte) 0x56,
-      (byte) 0x02, (byte) 0x00, (byte) 0x64, (byte) 0x00,
-      (byte) 0x00, (byte) 0x90, (byte) 0x02, (byte) 0xcf,
-      (byte) 0x42, (byte) 0x29, (byte) 0x2d, (byte) 0x46,
-      (byte) 0x02, (byte) 0x1c, (byte) 0x88, (byte) 0x98,
-      (byte) 0xa3, (byte) 0xd8, (byte) 0x7b, (byte) 0xef,
-      (byte) 0xbd, (byte) 0xf7, (byte) 0xde, (byte) 0x7b,
-      (byte) 0x65, (byte) 0x3c, (byte) 0x92, (byte) 0x88,
-      (byte) 0x49, (byte) 0xed, (byte) 0x31, (byte) 0xf4,
-      (byte) 0xd4, (byte) 0x31, (byte) 0x07, (byte) 0xb1,
-      (byte) 0x67, (byte) 0xc6, (byte) 0x23, (byte) 0x66,
-      (byte) 0x94, (byte) 0xa3, (byte) 0xd8, (byte) 0x29,
-      (byte) 0xcf, (byte) 0x1c, (byte) 0x42, (byte) 0x0c,
-      (byte) 0x62, (byte) 0xe8, (byte) 0x3c, (byte) 0x74,
-      (byte) 0x4a, (byte) 0x31, (byte) 0x88, (byte) 0x29,
-      (byte) 0xf5, (byte) 0x52, (byte) 0x32, (byte) 0xc6,
-      (byte) 0x20, (byte) 0xc6, (byte) 0xd8, (byte) 0x63,
-      (byte) 0x0c, (byte) 0x21, (byte) 0x94, (byte) 0x18,
-      (byte) 0x08, (byte) 0x0d, (byte) 0x59, (byte) 0x21,
-      (byte) 0x00, (byte) 0x84, (byte) 0x66, (byte) 0x00,
-      (byte) 0x18, (byte) 0x24, (byte) 0x09, (byte) 0x90,
-      (byte) 0x34, (byte) 0x0d, (byte) 0x90, (byte) 0x34,
-      (byte) 0x0d, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x24, (byte) 0x4f, (byte) 0x03, (byte) 0x34,
-      (byte) 0x51, (byte) 0x04, (byte) 0x34, (byte) 0x4f,
-      (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x49, (byte) 0xf3, (byte) 0x00, (byte) 0x4d,
-      (byte) 0xf4, (byte) 0x00, (byte) 0x4d, (byte) 0x14,
-      (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x90, (byte) 0x3c, (byte) 0x0d, (byte) 0xf0,
-      (byte) 0x44, (byte) 0x11, (byte) 0xd0, (byte) 0x44,
-      (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x34, (byte) 0x51, (byte) 0x04, (byte) 0x44,
-      (byte) 0x51, (byte) 0x05, (byte) 0x44, (byte) 0xd5,
-      (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x4d, (byte) 0x14, (byte) 0x01, (byte) 0x4f,
-      (byte) 0x15, (byte) 0x01, (byte) 0xd1, (byte) 0x54,
-      (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x90, (byte) 0x34, (byte) 0x0f, (byte) 0xd0,
-      (byte) 0x44, (byte) 0x11, (byte) 0xf0, (byte) 0x44,
-      (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x34, (byte) 0x51, (byte) 0x04, (byte) 0x44,
-      (byte) 0xd5, (byte) 0x04, (byte) 0x3c, (byte) 0x51,
-      (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x4d, (byte) 0x14, (byte) 0x01, (byte) 0xd1,
-      (byte) 0x54, (byte) 0x01, (byte) 0x51, (byte) 0x15,
-      (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04,
-      (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x38,
-      (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x58,
-      (byte) 0x08, (byte) 0x85, (byte) 0x86, (byte) 0xac,
-      (byte) 0x08, (byte) 0x00, (byte) 0xe2, (byte) 0x04,
-      (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x10,
-      (byte) 0x00, (byte) 0x00, (byte) 0x30, (byte) 0xe0,
-      (byte) 0x00, (byte) 0x00, (byte) 0x10, (byte) 0x60,
-      (byte) 0x42, (byte) 0x19, (byte) 0x28, (byte) 0x34,
-      (byte) 0x64, (byte) 0x45, (byte) 0x00, (byte) 0x10,
-      (byte) 0x27, (byte) 0x00, (byte) 0x60, (byte) 0x70,
-      (byte) 0x1c, (byte) 0xcb, (byte) 0x02, (byte) 0x00,
-      (byte) 0x00, (byte) 0x47, (byte) 0x92, (byte) 0x34,
-      (byte) 0x0d, (byte) 0x00, (byte) 0x00, (byte) 0x1c,
-      (byte) 0x49, (byte) 0xd2, (byte) 0x34, (byte) 0x00,
-      (byte) 0x00, (byte) 0xd0, (byte) 0x34, (byte) 0x4d,
-      (byte) 0x14, (byte) 0x01, (byte) 0x00, (byte) 0xc0,
-      (byte) 0xd2, (byte) 0x34, (byte) 0x51, (byte) 0x04,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x30,
-      (byte) 0xe0, (byte) 0x00, (byte) 0x00, (byte) 0x10,
-      (byte) 0x60, (byte) 0x42, (byte) 0x19, (byte) 0x28,
-      (byte) 0x34, (byte) 0x64, (byte) 0x25, (byte) 0x00,
-      (byte) 0x10, (byte) 0x05, (byte) 0x00, (byte) 0x60,
-      (byte) 0x30, (byte) 0x14, (byte) 0x4d, (byte) 0x03,
-      (byte) 0x58, (byte) 0x16, (byte) 0xc0, (byte) 0xb2,
-      (byte) 0x00, (byte) 0x9a, (byte) 0x06, (byte) 0xd0,
-      (byte) 0x34, (byte) 0x80, (byte) 0xe7, (byte) 0x01,
-      (byte) 0x3c, (byte) 0x11, (byte) 0x60, (byte) 0x9a,
-      (byte) 0x00, (byte) 0x40, (byte) 0x00, (byte) 0x00,
-      (byte) 0x40, (byte) 0x81, (byte) 0x03, (byte) 0x00,
-      (byte) 0x40, (byte) 0x80, (byte) 0x0d, (byte) 0x9a,
-      (byte) 0x12, (byte) 0x8b, (byte) 0x03, (byte) 0x14,
-      (byte) 0x1a, (byte) 0xb2, (byte) 0x12, (byte) 0x00,
-      (byte) 0x88, (byte) 0x02, (byte) 0x00, (byte) 0x30,
-      (byte) 0x28, (byte) 0x8a, (byte) 0x24, (byte) 0x59,
-      (byte) 0x96, (byte) 0xe7, (byte) 0x41, (byte) 0xd3,
-      (byte) 0x34, (byte) 0x4d, (byte) 0x14, (byte) 0xa1,
-      (byte) 0x69, (byte) 0x9a, (byte) 0x26, (byte) 0x8a,
-      (byte) 0xf0, (byte) 0x3c, (byte) 0xcf, (byte) 0x13,
-      (byte) 0x45, (byte) 0x78, (byte) 0x9e, (byte) 0xe7,
-      (byte) 0x99, (byte) 0x26, (byte) 0x44, (byte) 0xd1,
-      (byte) 0xf3, (byte) 0x4c, (byte) 0x13, (byte) 0xa2,
-      (byte) 0xe8, (byte) 0x79, (byte) 0xa6, (byte) 0x09,
-      (byte) 0xd3, (byte) 0x14, (byte) 0x45, (byte) 0xd3,
-      (byte) 0x04, (byte) 0xa2, (byte) 0x68, (byte) 0x9a,
-      (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x0a,
-      (byte) 0x1c, (byte) 0x00, (byte) 0x00, (byte) 0x02,
-      (byte) 0x6c, (byte) 0xd0, (byte) 0x94, (byte) 0x58,
-      (byte) 0x1c, (byte) 0xa0, (byte) 0xd0, (byte) 0x90,
-      (byte) 0x95, (byte) 0x00, (byte) 0x40, (byte) 0x48,
-      (byte) 0x00, (byte) 0x80, (byte) 0x41, (byte) 0x51,
-      (byte) 0x2c, (byte) 0xcb, (byte) 0xf3, (byte) 0x44,
-      (byte) 0x51, (byte) 0x14, (byte) 0x4d, (byte) 0x53,
-      (byte) 0x55, (byte) 0x5d, (byte) 0x17, (byte) 0x9a,
-      (byte) 0xe6, (byte) 0x79, (byte) 0xa2, (byte) 0x28,
-      (byte) 0x8a, (byte) 0xa6, (byte) 0xa9, (byte) 0xaa,
-      (byte) 0xae, (byte) 0x0b, (byte) 0x4d, (byte) 0xf3,
-      (byte) 0x3c, (byte) 0x51, (byte) 0x14, (byte) 0x45,
-      (byte) 0xd3, (byte) 0x54, (byte) 0x55, (byte) 0xd7,
-      (byte) 0x85, (byte) 0xe7, (byte) 0x79, (byte) 0xa2,
-      (byte) 0x29, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
-      (byte) 0xaa, (byte) 0xaa, (byte) 0xeb, (byte) 0xc2,
-      (byte) 0xf3, (byte) 0x44, (byte) 0xd1, (byte) 0x34,
-      (byte) 0x4d, (byte) 0x53, (byte) 0x55, (byte) 0x55,
-      (byte) 0xd7, (byte) 0x75, (byte) 0xe1, (byte) 0x79,
-      (byte) 0xa2, (byte) 0x68, (byte) 0x9a, (byte) 0xa6,
-      (byte) 0xa9, (byte) 0xaa, (byte) 0xae, (byte) 0xeb,
-      (byte) 0xba, (byte) 0xf0, (byte) 0x3c, (byte) 0x51,
-      (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x54,
-      (byte) 0x55, (byte) 0xd7, (byte) 0x95, (byte) 0x65,
-      (byte) 0x88, (byte) 0xa2, (byte) 0x28, (byte) 0x9a,
-      (byte) 0xa6, (byte) 0x69, (byte) 0xaa, (byte) 0xaa,
-      (byte) 0xeb, (byte) 0xca, (byte) 0x32, (byte) 0x10,
-      (byte) 0x45, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
-      (byte) 0x55, (byte) 0x75, (byte) 0x5d, (byte) 0x59,
-      (byte) 0x06, (byte) 0xa2, (byte) 0x68, (byte) 0x9a,
-      (byte) 0xaa, (byte) 0xea, (byte) 0xba, (byte) 0xae,
-      (byte) 0x2b, (byte) 0xcb, (byte) 0x40, (byte) 0x14,
-      (byte) 0x4d, (byte) 0x53, (byte) 0x55, (byte) 0x5d,
-      (byte) 0xd7, (byte) 0x75, (byte) 0x65, (byte) 0x19,
-      (byte) 0x98, (byte) 0xa6, (byte) 0x6a, (byte) 0xaa,
-      (byte) 0xaa, (byte) 0xeb, (byte) 0xca, (byte) 0xb2,
-      (byte) 0x2c, (byte) 0x03, (byte) 0x4c, (byte) 0x53,
-      (byte) 0x55, (byte) 0x5d, (byte) 0x57, (byte) 0x96,
-      (byte) 0x65, (byte) 0x19, (byte) 0xa0, (byte) 0xaa,
-      (byte) 0xae, (byte) 0xeb, (byte) 0xba, (byte) 0xb2,
-      (byte) 0x6c, (byte) 0xdb, (byte) 0x00, (byte) 0x55,
-      (byte) 0x75, (byte) 0x5d, (byte) 0xd7, (byte) 0x95,
-      (byte) 0x65, (byte) 0xdb, (byte) 0x06, (byte) 0xb8,
-      (byte) 0xae, (byte) 0xeb, (byte) 0xca, (byte) 0xb2,
-      (byte) 0x2c, (byte) 0xdb, (byte) 0x36, (byte) 0x00,
-      (byte) 0xd7, (byte) 0x95, (byte) 0x65, (byte) 0x59,
-      (byte) 0xb6, (byte) 0x6d, (byte) 0x01, (byte) 0x00,
-      (byte) 0x00, (byte) 0x07, (byte) 0x0e, (byte) 0x00,
-      (byte) 0x00, (byte) 0x01, (byte) 0x46, (byte) 0xd0,
-      (byte) 0x49, (byte) 0x46, (byte) 0x95, (byte) 0x45,
-      (byte) 0xd8, (byte) 0x68, (byte) 0xc2, (byte) 0x85,
-      (byte) 0x07, (byte) 0xa0, (byte) 0xd0, (byte) 0x90,
-      (byte) 0x15, (byte) 0x01, (byte) 0x40, (byte) 0x14,
-      (byte) 0x00, (byte) 0x00, (byte) 0x60, (byte) 0x8c,
-      (byte) 0x52, (byte) 0x8a, (byte) 0x29, (byte) 0x65,
-      (byte) 0x18, (byte) 0x93, (byte) 0x50, (byte) 0x4a,
-      (byte) 0x09, (byte) 0x0d, (byte) 0x63, (byte) 0x52,
-      (byte) 0x4a, (byte) 0x2a, (byte) 0xa5, (byte) 0x92,
-      (byte) 0x92, (byte) 0x52, (byte) 0x4a, (byte) 0xa5,
-      (byte) 0x54, (byte) 0x12, (byte) 0x52, (byte) 0x4a,
-      (byte) 0xa9, (byte) 0x94, (byte) 0x4a, (byte) 0x4a,
-      (byte) 0x4a, (byte) 0x29, (byte) 0x95, (byte) 0x92,
-      (byte) 0x51, (byte) 0x4a, (byte) 0x29, (byte) 0xb5,
-      (byte) 0x96, (byte) 0x2a, (byte) 0x29, (byte) 0xa9,
-      (byte) 0x94, (byte) 0x94, (byte) 0x52, (byte) 0x25,
-      (byte) 0xa5, (byte) 0xa4, (byte) 0x92, (byte) 0x52,
-      (byte) 0x2a, (byte) 0x00, (byte) 0x00, (byte) 0xec,
-      (byte) 0xc0, (byte) 0x01, (byte) 0x00, (byte) 0xec,
-      (byte) 0xc0, (byte) 0x42, (byte) 0x28, (byte) 0x34,
-      (byte) 0x64, (byte) 0x25, (byte) 0x00, (byte) 0x90,
-      (byte) 0x07, (byte) 0x00, (byte) 0x40, (byte) 0x10,
-      (byte) 0x82, (byte) 0x14, (byte) 0x63, (byte) 0x8c,
-      (byte) 0x39, (byte) 0x27, (byte) 0xa5, (byte) 0x54,
-      (byte) 0x8a, (byte) 0x31, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x93, (byte) 0x52, (byte) 0x2a, (byte) 0xc5,
-      (byte) 0x98, (byte) 0x73, (byte) 0xce, (byte) 0x49,
-      (byte) 0x29, (byte) 0x19, (byte) 0x63, (byte) 0xcc,
-      (byte) 0x39, (byte) 0xe7, (byte) 0xa4, (byte) 0x94,
-      (byte) 0x8c, (byte) 0x31, (byte) 0xe6, (byte) 0x9c,
-      (byte) 0x73, (byte) 0x52, (byte) 0x4a, (byte) 0xc6,
-      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
-      (byte) 0x29, (byte) 0x25, (byte) 0x63, (byte) 0xce,
-      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x94,
-      (byte) 0xd2, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x83, (byte) 0x50, (byte) 0x4a, (byte) 0x29,
-      (byte) 0xa5, (byte) 0x73, (byte) 0xce, (byte) 0x41,
-      (byte) 0x28, (byte) 0xa5, (byte) 0x94, (byte) 0x12,
-      (byte) 0x42, (byte) 0xe7, (byte) 0x20, (byte) 0x94,
-      (byte) 0x52, (byte) 0x4a, (byte) 0xe9, (byte) 0x9c,
-      (byte) 0x73, (byte) 0x10, (byte) 0x0a, (byte) 0x00,
-      (byte) 0x00, (byte) 0x2a, (byte) 0x70, (byte) 0x00,
-      (byte) 0x00, (byte) 0x08, (byte) 0xb0, (byte) 0x51,
-      (byte) 0x64, (byte) 0x73, (byte) 0x82, (byte) 0x91,
-      (byte) 0xa0, (byte) 0x42, (byte) 0x43, (byte) 0x56,
-      (byte) 0x02, (byte) 0x00, (byte) 0xa9, (byte) 0x00,
-      (byte) 0x00, (byte) 0x06, (byte) 0xc7, (byte) 0xb1,
-      (byte) 0x2c, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
-      (byte) 0xcf, (byte) 0x13, (byte) 0x45, (byte) 0x4b,
-      (byte) 0x92, (byte) 0x34, (byte) 0xcf, (byte) 0x13,
-      (byte) 0x3d, (byte) 0x4f, (byte) 0x14, (byte) 0x4d,
-      (byte) 0xd5, (byte) 0x92, (byte) 0x24, (byte) 0xcf,
-      (byte) 0x13, (byte) 0x45, (byte) 0xcf, (byte) 0x13,
-      (byte) 0x4d, (byte) 0x53, (byte) 0xe5, (byte) 0x79,
-      (byte) 0x9e, (byte) 0x28, (byte) 0x8a, (byte) 0xa2,
-      (byte) 0x68, (byte) 0x9a, (byte) 0xaa, (byte) 0x4a,
-      (byte) 0x14, (byte) 0x45, (byte) 0x4f, (byte) 0x14,
-      (byte) 0x45, (byte) 0xd1, (byte) 0x34, (byte) 0x55,
-      (byte) 0x95, (byte) 0x2c, (byte) 0x8b, (byte) 0xa2,
-      (byte) 0x69, (byte) 0x9a, (byte) 0xa6, (byte) 0xaa,
-      (byte) 0xba, (byte) 0x2e, (byte) 0x5b, (byte) 0x16,
-      (byte) 0x45, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
-      (byte) 0x55, (byte) 0x75, (byte) 0x5d, (byte) 0x98,
-      (byte) 0xa6, (byte) 0x28, (byte) 0xaa, (byte) 0xaa,
-      (byte) 0xeb, (byte) 0xca, (byte) 0x2e, (byte) 0x4c,
-      (byte) 0x53, (byte) 0x14, (byte) 0x4d, (byte) 0xd3,
-      (byte) 0x75, (byte) 0x65, (byte) 0x19, (byte) 0xb2,
-      (byte) 0xad, (byte) 0x9a, (byte) 0xaa, (byte) 0xea,
-      (byte) 0xba, (byte) 0xb2, (byte) 0x0d, (byte) 0xdb,
-      (byte) 0x36, (byte) 0x4d, (byte) 0x55, (byte) 0x75,
-      (byte) 0x5d, (byte) 0x59, (byte) 0x06, (byte) 0xae,
-      (byte) 0xeb, (byte) 0xba, (byte) 0xb2, (byte) 0x6c,
-      (byte) 0xeb, (byte) 0xc0, (byte) 0x75, (byte) 0x5d,
-      (byte) 0x57, (byte) 0x96, (byte) 0x6d, (byte) 0x5d,
-      (byte) 0x00, (byte) 0x00, (byte) 0x78, (byte) 0x82,
-      (byte) 0x03, (byte) 0x00, (byte) 0x50, (byte) 0x81,
-      (byte) 0x0d, (byte) 0xab, (byte) 0x23, (byte) 0x9c,
-      (byte) 0x14, (byte) 0x8d, (byte) 0x05, (byte) 0x16,
-      (byte) 0x1a, (byte) 0xb2, (byte) 0x12, (byte) 0x00,
-      (byte) 0xc8, (byte) 0x00, (byte) 0x00, (byte) 0x20,
-      (byte) 0x08, (byte) 0x41, (byte) 0x48, (byte) 0x29,
-      (byte) 0x85, (byte) 0x90, (byte) 0x52, (byte) 0x0a,
-      (byte) 0x21, (byte) 0xa5, (byte) 0x14, (byte) 0x42,
-      (byte) 0x4a, (byte) 0x29, (byte) 0x84, (byte) 0x04,
-      (byte) 0x00, (byte) 0x00, (byte) 0x0c, (byte) 0x38,
-      (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x98,
-      (byte) 0x50, (byte) 0x06, (byte) 0x0a, (byte) 0x0d,
-      (byte) 0x59, (byte) 0x09, (byte) 0x00, (byte) 0xa4,
-      (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x10,
-      (byte) 0x42, (byte) 0x08, (byte) 0x21, (byte) 0x84,
-      (byte) 0x10, (byte) 0x42, (byte) 0x08, (byte) 0x21,
-      (byte) 0x84, (byte) 0x10, (byte) 0x42, (byte) 0x08,
-      (byte) 0x21, (byte) 0x84, (byte) 0x10, (byte) 0x42,
-      (byte) 0x08, (byte) 0x21, (byte) 0x84, (byte) 0x10,
-      (byte) 0x42, (byte) 0x08, (byte) 0x21, (byte) 0x84,
-      (byte) 0x10, (byte) 0x42, (byte) 0x08, (byte) 0x21,
-      (byte) 0x84, (byte) 0x10, (byte) 0x42, (byte) 0x08,
-      (byte) 0x21, (byte) 0x84, (byte) 0x10, (byte) 0x42,
-      (byte) 0x08, (byte) 0x21, (byte) 0x84, (byte) 0x10,
-      (byte) 0x42, (byte) 0x08, (byte) 0x21, (byte) 0x84,
-      (byte) 0x10, (byte) 0x42, (byte) 0x08, (byte) 0x21,
-      (byte) 0x84, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
-      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
-      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
-      (byte) 0xce, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
-      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
-      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
-      (byte) 0xce, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
-      (byte) 0x73, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
-      (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
-      (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
-      (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
-      (byte) 0x02, (byte) 0x00, (byte) 0xb1, (byte) 0x2b,
-      (byte) 0x1c, (byte) 0x00, (byte) 0x76, (byte) 0x22,
-      (byte) 0x6c, (byte) 0x58, (byte) 0x1d, (byte) 0xe1,
-      (byte) 0xa4, (byte) 0x68, (byte) 0x2c, (byte) 0xb0,
-      (byte) 0xd0, (byte) 0x90, (byte) 0x95, (byte) 0x00,
-      (byte) 0x40, (byte) 0x38, (byte) 0x00, (byte) 0x00,
-      (byte) 0x60, (byte) 0x8c, (byte) 0x31, (byte) 0xce,
-      (byte) 0x59, (byte) 0xac, (byte) 0xb5, (byte) 0xd6,
-      (byte) 0x5a, (byte) 0x2b, (byte) 0xa5, (byte) 0x94,
-      (byte) 0x92, (byte) 0x50, (byte) 0x6b, (byte) 0xad,
-      (byte) 0xb5, (byte) 0xd6, (byte) 0x9a, (byte) 0x29,
-      (byte) 0xa4, (byte) 0x94, (byte) 0x84, (byte) 0x16,
-      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
-      (byte) 0x98, (byte) 0x31, (byte) 0x08, (byte) 0x29,
-      (byte) 0xb5, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
-      (byte) 0x31, (byte) 0xc6, (byte) 0x8c, (byte) 0x39,
-      (byte) 0x47, (byte) 0x2d, (byte) 0xc6, (byte) 0x18,
-      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xb6,
-      (byte) 0x56, (byte) 0x4a, (byte) 0x6c, (byte) 0x31,
-      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
-      (byte) 0xb1, (byte) 0xb5, (byte) 0x52, (byte) 0x62,
-      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
-      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
-      (byte) 0x16, (byte) 0x5b, (byte) 0x8c, (byte) 0x31,
-      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
-      (byte) 0x31, (byte) 0xb6, (byte) 0x18, (byte) 0x63,
-      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
-      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
-      (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
-      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
-      (byte) 0x31, (byte) 0xb6, (byte) 0x18, (byte) 0x63,
-      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
-      (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
-      (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
-      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
-      (byte) 0x31, (byte) 0xc6, (byte) 0x18, (byte) 0x63,
-      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
-      (byte) 0x63, (byte) 0x6c, (byte) 0x31, (byte) 0xc6,
-      (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
-      (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
-      (byte) 0x31, (byte) 0xc6, (byte) 0x18, (byte) 0x63,
-      (byte) 0x2c, (byte) 0x00, (byte) 0xc0, (byte) 0xe4,
-      (byte) 0xc1, (byte) 0x01, (byte) 0x00, (byte) 0x2a,
-      (byte) 0xc1, (byte) 0xc6, (byte) 0x19, (byte) 0x56,
-      (byte) 0x92, (byte) 0xce, (byte) 0x0a, (byte) 0x47,
-      (byte) 0x83, (byte) 0x0b, (byte) 0x0d, (byte) 0x59,
-      (byte) 0x09, (byte) 0x00, (byte) 0xe4, (byte) 0x06,
-      (byte) 0x00, (byte) 0x00, (byte) 0xc6, (byte) 0x28,
-      (byte) 0xc5, (byte) 0x98, (byte) 0x63, (byte) 0xce,
-      (byte) 0x41, (byte) 0x08, (byte) 0xa1, (byte) 0x94,
-      (byte) 0x12, (byte) 0x4a, (byte) 0x49, (byte) 0xad,
-      (byte) 0x75, (byte) 0xce, (byte) 0x39, (byte) 0x08,
-      (byte) 0x21, (byte) 0x94, (byte) 0x52, (byte) 0x4a,
-      (byte) 0x49, (byte) 0xa9, (byte) 0xb4, (byte) 0x94,
-      (byte) 0x62, (byte) 0xca, (byte) 0x98, (byte) 0x73,
-      (byte) 0xce, (byte) 0x41, (byte) 0x08, (byte) 0xa5,
-      (byte) 0x94, (byte) 0x12, (byte) 0x4a, (byte) 0x49,
-      (byte) 0xa9, (byte) 0xa5, (byte) 0xd4, (byte) 0x39,
-      (byte) 0xe7, (byte) 0x20, (byte) 0x94, (byte) 0x52,
-      (byte) 0x4a, (byte) 0x4a, (byte) 0x29, (byte) 0xa5,
-      (byte) 0x94, (byte) 0x5a, (byte) 0x6a, (byte) 0xad,
-      (byte) 0x73, (byte) 0x10, (byte) 0x42, (byte) 0x08,
-      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x4a,
-      (byte) 0x4a, (byte) 0x29, (byte) 0xa5, (byte) 0xd4,
-      (byte) 0x52, (byte) 0x08, (byte) 0x21, (byte) 0x94,
-      (byte) 0x52, (byte) 0x4a, (byte) 0x2a, (byte) 0x29,
-      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x6b,
-      (byte) 0xad, (byte) 0xa5, (byte) 0x10, (byte) 0x42,
-      (byte) 0x28, (byte) 0xa5, (byte) 0x94, (byte) 0x94,
-      (byte) 0x52, (byte) 0x4a, (byte) 0x29, (byte) 0xa5,
-      (byte) 0xd4, (byte) 0x5a, (byte) 0x8b, (byte) 0xa1,
-      (byte) 0x94, (byte) 0x90, (byte) 0x4a, (byte) 0x29,
-      (byte) 0x25, (byte) 0xa5, (byte) 0x94, (byte) 0x52,
-      (byte) 0x49, (byte) 0x2d, (byte) 0xb5, (byte) 0x96,
-      (byte) 0x5a, (byte) 0x2a, (byte) 0xa1, (byte) 0x94,
-      (byte) 0x54, (byte) 0x52, (byte) 0x4a, (byte) 0x29,
-      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x6b,
-      (byte) 0xa9, (byte) 0xb5, (byte) 0x56, (byte) 0x4a,
-      (byte) 0x49, (byte) 0x25, (byte) 0xa5, (byte) 0x94,
-      (byte) 0x52, (byte) 0x4a, (byte) 0x29, (byte) 0xa5,
-      (byte) 0xd4, (byte) 0x62, (byte) 0x6b, (byte) 0x29,
-      (byte) 0x94, (byte) 0x92, (byte) 0x52, (byte) 0x49,
-      (byte) 0x29, (byte) 0xb5, (byte) 0x94, (byte) 0x52,
-      (byte) 0x4a, (byte) 0xad, (byte) 0xc5, (byte) 0xd8,
-      (byte) 0x62, (byte) 0x29, (byte) 0xad, (byte) 0xa4,
-      (byte) 0x94, (byte) 0x52, (byte) 0x4a, (byte) 0x29,
-      (byte) 0xa5, (byte) 0xd6, (byte) 0x52, (byte) 0x6c,
-      (byte) 0xad, (byte) 0xb5, (byte) 0xd8, (byte) 0x52,
-      (byte) 0x4a, (byte) 0x29, (byte) 0xa5, (byte) 0x96,
-      (byte) 0x5a, (byte) 0x4a, (byte) 0x29, (byte) 0xb5,
-      (byte) 0x16, (byte) 0x5b, (byte) 0x6a, (byte) 0x2d,
-      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x4b,
-      (byte) 0x29, (byte) 0xa5, (byte) 0x96, (byte) 0x52,
-      (byte) 0x4b, (byte) 0x2d, (byte) 0xc6, (byte) 0xd6,
-      (byte) 0x5a, (byte) 0x4b, (byte) 0x29, (byte) 0xa5,
-      (byte) 0xd4, (byte) 0x52, (byte) 0x6a, (byte) 0xa9,
-      (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x6c,
-      (byte) 0xad, (byte) 0xb5, (byte) 0x98, (byte) 0x52,
-      (byte) 0x6a, (byte) 0x2d, (byte) 0xa5, (byte) 0xd4,
-      (byte) 0x52, (byte) 0x6b, (byte) 0x2d, (byte) 0xb5,
-      (byte) 0xd8, (byte) 0x52, (byte) 0x6a, (byte) 0x2d,
-      (byte) 0xb5, (byte) 0x94, (byte) 0x52, (byte) 0x6b,
-      (byte) 0xa9, (byte) 0xa5, (byte) 0x94, (byte) 0x5a,
-      (byte) 0x6b, (byte) 0x2d, (byte) 0xb6, (byte) 0xd8,
-      (byte) 0x5a, (byte) 0x6b, (byte) 0x29, (byte) 0xb5,
-      (byte) 0x94, (byte) 0x52, (byte) 0x4a, (byte) 0xa9,
-      (byte) 0xb5, (byte) 0x16, (byte) 0x5b, (byte) 0x8a,
-      (byte) 0xb1, (byte) 0xb5, (byte) 0xd4, (byte) 0x4a,
-      (byte) 0x4a, (byte) 0x29, (byte) 0xb5, (byte) 0xd4,
-      (byte) 0x5a, (byte) 0x6a, (byte) 0x2d, (byte) 0xb6,
-      (byte) 0x16, (byte) 0x5b, (byte) 0x6b, (byte) 0xad,
-      (byte) 0xa5, (byte) 0xd6, (byte) 0x5a, (byte) 0x6a,
-      (byte) 0x29, (byte) 0xa5, (byte) 0x16, (byte) 0x5b,
-      (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x16,
-      (byte) 0x63, (byte) 0x6b, (byte) 0x31, (byte) 0xa5,
-      (byte) 0x94, (byte) 0x52, (byte) 0x4b, (byte) 0xa9,
-      (byte) 0xa5, (byte) 0x02, (byte) 0x00, (byte) 0x80,
-      (byte) 0x0e, (byte) 0x1c, (byte) 0x00, (byte) 0x00,
-      (byte) 0x02, (byte) 0x8c, (byte) 0xa8, (byte) 0xb4,
-      (byte) 0x10, (byte) 0x3b, (byte) 0xcd, (byte) 0xb8,
-      (byte) 0xf2, (byte) 0x08, (byte) 0x1c, (byte) 0x51,
-      (byte) 0xc8, (byte) 0x30, (byte) 0x01, (byte) 0x15,
-      (byte) 0x1a, (byte) 0xb2, (byte) 0x12, (byte) 0x00,
-      (byte) 0x20, (byte) 0x03, (byte) 0x00, (byte) 0x20,
-      (byte) 0x90, (byte) 0x69, (byte) 0x92, (byte) 0x39,
-      (byte) 0x49, (byte) 0xa9, (byte) 0x11, (byte) 0x26,
-      (byte) 0x39, (byte) 0xc5, (byte) 0xa0, (byte) 0x94,
-      (byte) 0xe6, (byte) 0x9c, (byte) 0x53, (byte) 0x4a,
-      (byte) 0x29, (byte) 0xa5, (byte) 0x34, (byte) 0x44,
-      (byte) 0x96, (byte) 0x64, (byte) 0x90, (byte) 0x62,
-      (byte) 0x50, (byte) 0x1d, (byte) 0x99, (byte) 0x8c,
-      (byte) 0x39, (byte) 0x49, (byte) 0x39, (byte) 0x43,
-      (byte) 0xa4, (byte) 0x31, (byte) 0xa4, (byte) 0x20,
-      (byte) 0xf5, (byte) 0x4c, (byte) 0x91, (byte) 0xc7,
-      (byte) 0x94, (byte) 0x62, (byte) 0x10, (byte) 0x43,
-      (byte) 0x48, (byte) 0x2a, (byte) 0x74, (byte) 0x8a,
-      (byte) 0x39, (byte) 0x6c, (byte) 0x35, (byte) 0xf9,
-      (byte) 0x58, (byte) 0x42, (byte) 0x07, (byte) 0xb1,
-      (byte) 0x06, (byte) 0x65, (byte) 0x8c, (byte) 0x70,
-      (byte) 0x29, (byte) 0xc5, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x08, (byte) 0x02, (byte) 0x00,
-      (byte) 0x04, (byte) 0x84, (byte) 0x04, (byte) 0x00,
-      (byte) 0x18, (byte) 0x20, (byte) 0x28, (byte) 0x98,
-      (byte) 0x01, (byte) 0x00, (byte) 0x06, (byte) 0x07,
-      (byte) 0x08, (byte) 0x23, (byte) 0x07, (byte) 0x02,
-      (byte) 0x1d, (byte) 0x01, (byte) 0x04, (byte) 0x0e,
-      (byte) 0x6d, (byte) 0x00, (byte) 0x80, (byte) 0x81,
-      (byte) 0x08, (byte) 0x99, (byte) 0x09, (byte) 0x0c,
-      (byte) 0x0a, (byte) 0xa1, (byte) 0xc1, (byte) 0x41,
-      (byte) 0x26, (byte) 0x00, (byte) 0x3c, (byte) 0x40,
-      (byte) 0x44, (byte) 0x48, (byte) 0x05, (byte) 0x00,
-      (byte) 0x89, (byte) 0x09, (byte) 0x8a, (byte) 0xd2,
-      (byte) 0x85, (byte) 0x2e, (byte) 0x08, (byte) 0x21,
-      (byte) 0x82, (byte) 0x74, (byte) 0x11, (byte) 0x64,
-      (byte) 0xf1, (byte) 0xc0, (byte) 0x85, (byte) 0x13,
-      (byte) 0x37, (byte) 0x9e, (byte) 0xb8, (byte) 0xe1,
-      (byte) 0x84, (byte) 0x0e, (byte) 0x6d, (byte) 0x20,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x20, (byte) 0x00, (byte) 0xf0,
-      (byte) 0x01, (byte) 0x00, (byte) 0x90, (byte) 0x50,
-      (byte) 0x00, (byte) 0x11, (byte) 0x11, (byte) 0xd1,
-      (byte) 0xcc, (byte) 0x55, (byte) 0x58, (byte) 0x5c,
-      (byte) 0x60, (byte) 0x64, (byte) 0x68, (byte) 0x6c,
-      (byte) 0x70, (byte) 0x74, (byte) 0x78, (byte) 0x7c,
-      (byte) 0x80, (byte) 0x84, (byte) 0x08, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x10, (byte) 0x00, (byte) 0x7c, (byte) 0x00,
-      (byte) 0x00, (byte) 0x24, (byte) 0x22, (byte) 0x40,
-      (byte) 0x44, (byte) 0x44, (byte) 0x34, (byte) 0x73,
-      (byte) 0x15, (byte) 0x16, (byte) 0x17, (byte) 0x18,
-      (byte) 0x19, (byte) 0x1a, (byte) 0x1b, (byte) 0x1c,
-      (byte) 0x1d, (byte) 0x1e, (byte) 0x1f, (byte) 0x20,
-      (byte) 0x21, (byte) 0x01, (byte) 0x00, (byte) 0x80,
-      (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x00, (byte) 0x20, (byte) 0x80,
-      (byte) 0x00, (byte) 0x04, (byte) 0x04, (byte) 0x04,
-      (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00,
-      (byte) 0x00, (byte) 0x04, (byte) 0x04
-  };
-
-}
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
index 61d1ecaeea..ee17068242 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java
@@ -15,14 +15,12 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import android.app.Instrumentation;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import android.content.Context;
-import android.test.MoreAsserts;
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Timeline;
 import com.google.android.exoplayer2.extractor.Extractor;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.MediaSource.Listener;
 import com.google.android.exoplayer2.testutil.FakeExtractorInput.SimulatedIOException;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
@@ -32,7 +30,6 @@
 import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Random;
-import junit.framework.Assert;
 
 /**
  * Utility methods for tests.
@@ -68,6 +65,20 @@ public static boolean sniffTestData(Extractor extractor, FakeExtractorInput inpu
     return Arrays.copyOf(data, position);
   }
 
+  public static byte[] readExactly(DataSource dataSource, int length) throws IOException {
+    byte[] data = new byte[length];
+    int position = 0;
+    while (position < length) {
+      int bytesRead = dataSource.read(data, position, data.length - position);
+      if (bytesRead == C.RESULT_END_OF_INPUT) {
+        fail("Not enough data could be read: " + position + " < " + length);
+      } else {
+        position += bytesRead;
+      }
+    }
+    return data;
+  }
+
   public static byte[] buildTestData(int length) {
     return buildTestData(length, length);
   }
@@ -120,54 +131,16 @@ public static String buildTestString(int maxLength, Random random) {
     return joined;
   }
 
-  public static byte[] getByteArray(Instrumentation instrumentation, String fileName)
-      throws IOException {
-    return getByteArray(instrumentation.getContext(), fileName);
-  }
-
   public static byte[] getByteArray(Context context, String fileName) throws IOException {
     return Util.toByteArray(getInputStream(context, fileName));
   }
 
-  public static InputStream getInputStream(Instrumentation instrumentation, String fileName)
-      throws IOException {
-    return getInputStream(instrumentation.getContext(), fileName);
-  }
-
   public static InputStream getInputStream(Context context, String fileName) throws IOException {
     return context.getResources().getAssets().open(fileName);
   }
 
-  public static String getString(Instrumentation instrumentation, String fileName)
-      throws IOException {
-    return new String(getByteArray(instrumentation, fileName));
-  }
-
-  /**
-   * Extracts the timeline from a media source.
-   */
-  public static Timeline extractTimelineFromMediaSource(MediaSource mediaSource) {
-    class TimelineListener implements Listener {
-      private Timeline timeline;
-      @Override
-      public synchronized void onSourceInfoRefreshed(MediaSource source, Timeline timeline,
-          Object manifest) {
-        this.timeline = timeline;
-        this.notify();
-      }
-    }
-    TimelineListener listener = new TimelineListener();
-    mediaSource.prepareSource(null, true, listener);
-    synchronized (listener) {
-      while (listener.timeline == null) {
-        try {
-          listener.wait();
-        } catch (InterruptedException e) {
-          Assert.fail(e.getMessage());
-        }
-      }
-    }
-    return listener.timeline;
+  public static String getString(Context context, String fileName) throws IOException {
+    return new String(getByteArray(context, fileName));
   }
 
   /**
@@ -180,13 +153,14 @@ public synchronized void onSourceInfoRefreshed(MediaSource source, Timeline time
    *     data length. If false then it's asserted that {@link C#LENGTH_UNSET} is returned.
    * @throws IOException If an error occurs reading fom the {@link DataSource}.
    */
-  public static void assertDataSourceContent(DataSource dataSource, DataSpec dataSpec,
-      byte[] expectedData, boolean expectKnownLength) throws IOException {
+  public static void assertDataSourceContent(
+      DataSource dataSource, DataSpec dataSpec, byte[] expectedData, boolean expectKnownLength)
+      throws IOException {
     try {
       long length = dataSource.open(dataSpec);
-      Assert.assertEquals(expectKnownLength ? expectedData.length : C.LENGTH_UNSET, length);
-      byte[] readData = TestUtil.readToEnd(dataSource);
-      MoreAsserts.assertEquals(expectedData, readData);
+      assertThat(length).isEqualTo(expectKnownLength ? expectedData.length : C.LENGTH_UNSET);
+      byte[] readData = readToEnd(dataSource);
+      assertThat(readData).isEqualTo(expectedData);
     } finally {
       dataSource.close();
     }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
deleted file mode 100644
index b1df8f62e1..0000000000
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.google.android.exoplayer2.testutil;
-
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertTrue;
-
-import android.os.ConditionVariable;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.Timeline.Period;
-import com.google.android.exoplayer2.Timeline.Window;
-import com.google.android.exoplayer2.source.MediaPeriod;
-import com.google.android.exoplayer2.source.MediaPeriod.Callback;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
-
-/**
- * Unit test for {@link Timeline}.
- */
-public final class TimelineAsserts {
-
-  private TimelineAsserts() {}
-
-  /**
-   * Assert that timeline is empty (i.e. has no windows or periods).
-   */
-  public static void assertEmpty(Timeline timeline) {
-    assertWindowIds(timeline);
-    assertPeriodCounts(timeline);
-    for (boolean shuffled : new boolean[] {false, true}) {
-      assertEquals(C.INDEX_UNSET, timeline.getFirstWindowIndex(shuffled));
-      assertEquals(C.INDEX_UNSET, timeline.getLastWindowIndex(shuffled));
-    }
-  }
-
-  /**
-   * Asserts that window IDs are set correctly.
-   *
-   * @param expectedWindowIds A list of expected window IDs. If an ID is unknown or not important
-   *     {@code null} can be passed to skip this window.
-   */
-  public static void assertWindowIds(Timeline timeline, Object... expectedWindowIds) {
-    Window window = new Window();
-    assertEquals(expectedWindowIds.length, timeline.getWindowCount());
-    for (int i = 0; i < timeline.getWindowCount(); i++) {
-      timeline.getWindow(i, window, true);
-      if (expectedWindowIds[i] != null) {
-        assertEquals(expectedWindowIds[i], window.id);
-      }
-    }
-  }
-
-  /**
-   * Asserts that window properties {@link Window}.isDynamic are set correctly.
-   */
-  public static void assertWindowIsDynamic(Timeline timeline, boolean... windowIsDynamic) {
-    Window window = new Window();
-    for (int i = 0; i < timeline.getWindowCount(); i++) {
-      timeline.getWindow(i, window, true);
-      assertEquals(windowIsDynamic[i], window.isDynamic);
-    }
-  }
-
-  /**
-   * Asserts that previous window indices for each window depending on the repeat mode and the
-   * shuffle mode are equal to the given sequence.
-   */
-  public static void assertPreviousWindowIndices(Timeline timeline,
-      @Player.RepeatMode int repeatMode, boolean shuffleModeEnabled,
-      int... expectedPreviousWindowIndices) {
-    for (int i = 0; i < timeline.getWindowCount(); i++) {
-      assertEquals(expectedPreviousWindowIndices[i],
-          timeline.getPreviousWindowIndex(i, repeatMode, shuffleModeEnabled));
-    }
-  }
-
-  /**
-   * Asserts that next window indices for each window depending on the repeat mode and the
-   * shuffle mode are equal to the given sequence.
-   */
-  public static void assertNextWindowIndices(Timeline timeline, @Player.RepeatMode int repeatMode,
-      boolean shuffleModeEnabled, int... expectedNextWindowIndices) {
-    for (int i = 0; i < timeline.getWindowCount(); i++) {
-      assertEquals(expectedNextWindowIndices[i],
-          timeline.getNextWindowIndex(i, repeatMode, shuffleModeEnabled));
-    }
-  }
-
-  /**
-   * Asserts that period counts for each window are set correctly. Also asserts that
-   * {@link Window#firstPeriodIndex} and {@link Window#lastPeriodIndex} are set correctly, and it
-   * asserts the correct behavior of {@link Timeline#getNextWindowIndex(int, int, boolean)}.
-   */
-  public static void assertPeriodCounts(Timeline timeline, int... expectedPeriodCounts) {
-    int windowCount = timeline.getWindowCount();
-    int[] accumulatedPeriodCounts = new int[windowCount + 1];
-    accumulatedPeriodCounts[0] = 0;
-    for (int i = 0; i < windowCount; i++) {
-      accumulatedPeriodCounts[i + 1] = accumulatedPeriodCounts[i] + expectedPeriodCounts[i];
-    }
-    assertEquals(accumulatedPeriodCounts[accumulatedPeriodCounts.length - 1],
-        timeline.getPeriodCount());
-    Window window = new Window();
-    Period period = new Period();
-    for (int i = 0; i < windowCount; i++) {
-      timeline.getWindow(i, window, true);
-      assertEquals(accumulatedPeriodCounts[i], window.firstPeriodIndex);
-      assertEquals(accumulatedPeriodCounts[i + 1] - 1, window.lastPeriodIndex);
-    }
-    int expectedWindowIndex = 0;
-    for (int i = 0; i < timeline.getPeriodCount(); i++) {
-      timeline.getPeriod(i, period, true);
-      while (i >= accumulatedPeriodCounts[expectedWindowIndex + 1]) {
-        expectedWindowIndex++;
-      }
-      assertEquals(expectedWindowIndex, period.windowIndex);
-      assertEquals(i, timeline.getIndexOfPeriod(period.uid));
-      for (@Player.RepeatMode int repeatMode
-          : new int[] {Player.REPEAT_MODE_OFF, Player.REPEAT_MODE_ONE, Player.REPEAT_MODE_ALL}) {
-        if (i < accumulatedPeriodCounts[expectedWindowIndex + 1] - 1) {
-          assertEquals(i + 1, timeline.getNextPeriodIndex(i, period, window, repeatMode, false));
-        } else {
-          int nextWindow = timeline.getNextWindowIndex(expectedWindowIndex, repeatMode, false);
-          int nextPeriod = nextWindow == C.INDEX_UNSET ? C.INDEX_UNSET
-              : accumulatedPeriodCounts[nextWindow];
-          assertEquals(nextPeriod, timeline.getNextPeriodIndex(i, period, window, repeatMode,
-              false));
-        }
-      }
-    }
-  }
-
-  /**
-   * Asserts that periods' {@link Period#getAdGroupCount()} are set correctly.
-   */
-  public static void assertAdGroupCounts(Timeline timeline, int... expectedAdGroupCounts) {
-    Period period = new Period();
-    for (int i = 0; i < timeline.getPeriodCount(); i++) {
-      timeline.getPeriod(i, period);
-      assertEquals(expectedAdGroupCounts[i], period.getAdGroupCount());
-    }
-  }
-
-  /**
-   * Asserts that all period (including ad periods) can be created from the source, prepared, and
-   * released without exception and within timeout.
-   */
-  public static void assertAllPeriodsCanBeCreatedPreparedAndReleased(MediaSource mediaSource,
-      Timeline timeline, long timeoutMs) {
-    Period period = new Period();
-    for (int i = 0; i < timeline.getPeriodCount(); i++) {
-      assertPeriodCanBeCreatedPreparedAndReleased(mediaSource, new MediaPeriodId(i), timeoutMs);
-      timeline.getPeriod(i, period);
-      for (int adGroupIndex = 0; adGroupIndex < period.getAdGroupCount(); adGroupIndex++) {
-        for (int adIndex = 0; adIndex < period.getAdCountInAdGroup(adGroupIndex); adIndex++) {
-          assertPeriodCanBeCreatedPreparedAndReleased(mediaSource,
-              new MediaPeriodId(i, adGroupIndex, adIndex), timeoutMs);
-        }
-      }
-    }
-  }
-
-  private static void assertPeriodCanBeCreatedPreparedAndReleased(MediaSource mediaSource,
-      MediaPeriodId mediaPeriodId, long timeoutMs) {
-    MediaPeriod mediaPeriod = mediaSource.createPeriod(mediaPeriodId, null);
-    assertNotNull(mediaPeriod);
-    final ConditionVariable mediaPeriodPrepared = new ConditionVariable();
-    mediaPeriod.prepare(new Callback() {
-      @Override
-      public void onPrepared(MediaPeriod mediaPeriod) {
-        mediaPeriodPrepared.open();
-      }
-      @Override
-      public void onContinueLoadingRequested(MediaPeriod source) {}
-    }, /* positionUs= */ 0);
-    assertTrue(mediaPeriodPrepared.block(timeoutMs));
-    // MediaSource is supposed to support multiple calls to createPeriod with the same id without an
-    // intervening call to releasePeriod.
-    MediaPeriod secondMediaPeriod = mediaSource.createPeriod(mediaPeriodId, null);
-    assertNotNull(secondMediaPeriod);
-    mediaSource.releasePeriod(secondMediaPeriod);
-    mediaSource.releasePeriod(mediaPeriod);
-  }
-
-}
-
diff --git a/testutils/src/test/AndroidManifest.xml b/testutils/src/test/AndroidManifest.xml
new file mode 100644
index 0000000000..9602d01633
--- /dev/null
+++ b/testutils/src/test/AndroidManifest.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2017 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    package="com.google.android.exoplayer2.testutil.test">
+
+  <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="26"/>
+
+</manifest>
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSetTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSetTest.java
new file mode 100644
index 0000000000..7fd84f6287
--- /dev/null
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeAdaptiveDataSetTest.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
+import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData.Segment;
+import com.google.android.exoplayer2.util.MimeTypes;
+import java.util.List;
+import java.util.Random;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link FakeAdaptiveDataSet}. */
+@RunWith(RobolectricTestRunner.class)
+public final class FakeAdaptiveDataSetTest {
+
+  private static final Format[] TEST_FORMATS = {
+    Format.createVideoSampleFormat(
+        null,
+        MimeTypes.VIDEO_H264,
+        null,
+        1000000,
+        Format.NO_VALUE,
+        1280,
+        720,
+        Format.NO_VALUE,
+        null,
+        null),
+    Format.createVideoSampleFormat(
+        null,
+        MimeTypes.VIDEO_H264,
+        null,
+        300000,
+        Format.NO_VALUE,
+        640,
+        360,
+        Format.NO_VALUE,
+        null,
+        null)
+  };
+  private static final TrackGroup TRACK_GROUP = new TrackGroup(TEST_FORMATS);
+
+  @Test
+  public void testAdaptiveDataSet() {
+    long chunkDuration = 2 * C.MICROS_PER_SECOND;
+    FakeAdaptiveDataSet dataSet =
+        new FakeAdaptiveDataSet(
+            TRACK_GROUP, 10 * C.MICROS_PER_SECOND, chunkDuration, 0.0, new Random(0));
+    assertThat(dataSet.getAllData().size()).isEqualTo(TEST_FORMATS.length);
+    assertThat(dataSet.getUri(0).equals(dataSet.getUri(1))).isFalse();
+    assertThat(dataSet.getChunkCount()).isEqualTo(5);
+    assertThat(dataSet.getChunkIndexByPosition(4 * C.MICROS_PER_SECOND)).isEqualTo(2);
+    assertThat(dataSet.getChunkIndexByPosition(9 * C.MICROS_PER_SECOND)).isEqualTo(4);
+    for (int i = 0; i < dataSet.getChunkCount(); i++) {
+      assertThat(dataSet.getChunkDuration(i)).isEqualTo(chunkDuration);
+    }
+    assertChunkData(dataSet, chunkDuration);
+  }
+
+  @Test
+  public void testAdaptiveDataSetTrailingSmallChunk() {
+    long chunkDuration = 3 * C.MICROS_PER_SECOND;
+    FakeAdaptiveDataSet dataSet =
+        new FakeAdaptiveDataSet(
+            TRACK_GROUP, 10 * C.MICROS_PER_SECOND, chunkDuration, 0.0, new Random(0));
+    assertThat(dataSet.getAllData().size()).isEqualTo(TEST_FORMATS.length);
+    assertThat(dataSet.getUri(0).equals(dataSet.getUri(1))).isFalse();
+    assertThat(dataSet.getChunkCount()).isEqualTo(4);
+    assertThat(dataSet.getChunkIndexByPosition(4 * C.MICROS_PER_SECOND)).isEqualTo(1);
+    assertThat(dataSet.getChunkIndexByPosition(9 * C.MICROS_PER_SECOND)).isEqualTo(3);
+    for (int i = 0; i < dataSet.getChunkCount() - 1; i++) {
+      assertThat(dataSet.getChunkDuration(i)).isEqualTo(chunkDuration);
+    }
+    assertThat(dataSet.getChunkDuration(3)).isEqualTo(1 * C.MICROS_PER_SECOND);
+    assertChunkData(dataSet, chunkDuration);
+  }
+
+  @Test
+  public void testAdaptiveDataSetChunkSizeDistribution() {
+    double expectedStdDev = 4.0;
+    FakeAdaptiveDataSet dataSet =
+        new FakeAdaptiveDataSet(
+            TRACK_GROUP,
+            100000 * C.MICROS_PER_SECOND,
+            1 * C.MICROS_PER_SECOND,
+            expectedStdDev,
+            new Random(0));
+    for (int i = 0; i < TEST_FORMATS.length; i++) {
+      FakeData data = dataSet.getData(dataSet.getUri(i));
+      double mean = computeSegmentSizeMean(data.getSegments());
+      double stddev = computeSegmentSizeStdDev(data.getSegments(), mean);
+      double relativePercentStdDev = stddev / mean * 100.0;
+      assertThat(relativePercentStdDev).isWithin(0.02).of(expectedStdDev);
+      assertThat(mean * 8 / TEST_FORMATS[i].bitrate).isWithin(0.01).of(1.0);
+    }
+  }
+
+  private void assertChunkData(FakeAdaptiveDataSet dataSet, long chunkDuration) {
+    for (int i = 0; i < dataSet.getChunkCount(); i++) {
+      assertThat(dataSet.getStartTime(i)).isEqualTo(chunkDuration * i);
+    }
+    for (int s = 0; s < TEST_FORMATS.length; s++) {
+      FakeData data = dataSet.getData(dataSet.getUri(s));
+      assertThat(data.getSegments().size()).isEqualTo(dataSet.getChunkCount());
+      for (int i = 0; i < data.getSegments().size(); i++) {
+        long expectedLength =
+            TEST_FORMATS[s].bitrate * dataSet.getChunkDuration(i) / (8 * C.MICROS_PER_SECOND);
+        assertThat(data.getSegments().get(i).length).isEqualTo(expectedLength);
+      }
+    }
+  }
+
+  private static double computeSegmentSizeMean(List<Segment> segments) {
+    double totalSize = 0.0;
+    for (Segment segment : segments) {
+      totalSize += segment.length;
+    }
+    return totalSize / segments.size();
+  }
+
+  private static double computeSegmentSizeStdDev(List<Segment> segments, double mean) {
+    double totalSquaredSize = 0.0;
+    for (Segment segment : segments) {
+      totalSquaredSize += (double) segment.length * segment.length;
+    }
+    return Math.sqrt(totalSquaredSize / segments.size() - mean * mean);
+  }
+}
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java
new file mode 100644
index 0000000000..725753ce46
--- /dev/null
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeClockTest.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.os.ConditionVariable;
+import android.os.HandlerThread;
+import com.google.android.exoplayer2.util.Clock;
+import com.google.android.exoplayer2.util.HandlerWrapper;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+/** Unit test for {@link FakeClock}. */
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {RobolectricUtil.CustomLooper.class, RobolectricUtil.CustomMessageQueue.class})
+public final class FakeClockTest {
+
+  private static final long TIMEOUT_MS = 10000;
+
+  @Test
+  public void testAdvanceTime() {
+    FakeClock fakeClock = new FakeClock(2000);
+    assertThat(fakeClock.elapsedRealtime()).isEqualTo(2000);
+    fakeClock.advanceTime(500);
+    assertThat(fakeClock.elapsedRealtime()).isEqualTo(2500);
+    fakeClock.advanceTime(0);
+    assertThat(fakeClock.elapsedRealtime()).isEqualTo(2500);
+  }
+
+  @Test
+  public void testSleep() throws InterruptedException {
+    FakeClock fakeClock = new FakeClock(0);
+    SleeperThread sleeperThread = new SleeperThread(fakeClock, 1000);
+    sleeperThread.start();
+    assertThat(sleeperThread.waitUntilAsleep(TIMEOUT_MS)).isTrue();
+    assertThat(sleeperThread.isSleeping()).isTrue();
+    fakeClock.advanceTime(1000);
+    sleeperThread.join(TIMEOUT_MS);
+    assertThat(sleeperThread.isSleeping()).isFalse();
+
+    sleeperThread = new SleeperThread(fakeClock, 0);
+    sleeperThread.start();
+    sleeperThread.join();
+    assertThat(sleeperThread.isSleeping()).isFalse();
+
+    SleeperThread[] sleeperThreads = new SleeperThread[5];
+    sleeperThreads[0] = new SleeperThread(fakeClock, 1000);
+    sleeperThreads[1] = new SleeperThread(fakeClock, 1000);
+    sleeperThreads[2] = new SleeperThread(fakeClock, 2000);
+    sleeperThreads[3] = new SleeperThread(fakeClock, 3000);
+    sleeperThreads[4] = new SleeperThread(fakeClock, 4000);
+    for (SleeperThread thread : sleeperThreads) {
+      thread.start();
+      assertThat(thread.waitUntilAsleep(TIMEOUT_MS)).isTrue();
+    }
+    assertSleepingStates(new boolean[] {true, true, true, true, true}, sleeperThreads);
+    fakeClock.advanceTime(1500);
+    assertThat(sleeperThreads[0].waitUntilAwake(TIMEOUT_MS)).isTrue();
+    assertThat(sleeperThreads[1].waitUntilAwake(TIMEOUT_MS)).isTrue();
+    assertSleepingStates(new boolean[] {false, false, true, true, true}, sleeperThreads);
+    fakeClock.advanceTime(2000);
+    assertThat(sleeperThreads[2].waitUntilAwake(TIMEOUT_MS)).isTrue();
+    assertThat(sleeperThreads[3].waitUntilAwake(TIMEOUT_MS)).isTrue();
+    assertSleepingStates(new boolean[] {false, false, false, false, true}, sleeperThreads);
+    fakeClock.advanceTime(2000);
+    for (SleeperThread thread : sleeperThreads) {
+      thread.join(TIMEOUT_MS);
+    }
+    assertSleepingStates(new boolean[] {false, false, false, false, false}, sleeperThreads);
+  }
+
+  @Test
+  public void testPostDelayed() {
+    HandlerThread handlerThread = new HandlerThread("FakeClockTest thread");
+    handlerThread.start();
+    FakeClock fakeClock = new FakeClock(0);
+    HandlerWrapper handler =
+        fakeClock.createHandler(handlerThread.getLooper(), /* callback= */ null);
+
+    TestRunnable[] testRunnables = {
+      new TestRunnable(),
+      new TestRunnable(),
+      new TestRunnable(),
+      new TestRunnable(),
+      new TestRunnable()
+    };
+    handler.postDelayed(testRunnables[0], 0);
+    handler.postDelayed(testRunnables[1], 100);
+    handler.postDelayed(testRunnables[2], 200);
+    waitForHandler(handler);
+    assertTestRunnableStates(new boolean[] {true, false, false, false, false}, testRunnables);
+
+    fakeClock.advanceTime(150);
+    handler.postDelayed(testRunnables[3], 50);
+    handler.postDelayed(testRunnables[4], 100);
+    waitForHandler(handler);
+    assertTestRunnableStates(new boolean[] {true, true, false, false, false}, testRunnables);
+
+    fakeClock.advanceTime(50);
+    waitForHandler(handler);
+    assertTestRunnableStates(new boolean[] {true, true, true, true, false}, testRunnables);
+
+    fakeClock.advanceTime(1000);
+    waitForHandler(handler);
+    assertTestRunnableStates(new boolean[] {true, true, true, true, true}, testRunnables);
+  }
+
+  private static void assertSleepingStates(boolean[] states, SleeperThread[] sleeperThreads) {
+    for (int i = 0; i < sleeperThreads.length; i++) {
+      assertThat(sleeperThreads[i].isSleeping()).isEqualTo(states[i]);
+    }
+  }
+
+  private static void waitForHandler(HandlerWrapper handler) {
+    final ConditionVariable handlerFinished = new ConditionVariable();
+    handler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            handlerFinished.open();
+          }
+        });
+    handlerFinished.block();
+  }
+
+  private static void assertTestRunnableStates(boolean[] states, TestRunnable[] testRunnables) {
+    for (int i = 0; i < testRunnables.length; i++) {
+      assertThat(testRunnables[i].hasRun).isEqualTo(states[i]);
+    }
+  }
+
+  private static final class SleeperThread extends Thread {
+
+    private final Clock clock;
+    private final long sleepDurationMs;
+    private final CountDownLatch fallAsleepCountDownLatch;
+    private final CountDownLatch wakeUpCountDownLatch;
+
+    private volatile boolean isSleeping;
+
+    public SleeperThread(Clock clock, long sleepDurationMs) {
+      this.clock = clock;
+      this.sleepDurationMs = sleepDurationMs;
+      this.fallAsleepCountDownLatch = new CountDownLatch(1);
+      this.wakeUpCountDownLatch = new CountDownLatch(1);
+    }
+
+    public boolean waitUntilAsleep(long timeoutMs) throws InterruptedException {
+      return fallAsleepCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);
+    }
+
+    public boolean waitUntilAwake(long timeoutMs) throws InterruptedException {
+      return wakeUpCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);
+    }
+
+    public boolean isSleeping() {
+      return isSleeping;
+    }
+
+    @Override
+    public void run() {
+      // This relies on the FakeClock's methods synchronizing on its own monitor to ensure that
+      // any interactions with it occur only after sleep() has called wait() or returned.
+      synchronized (clock) {
+        isSleeping = true;
+        fallAsleepCountDownLatch.countDown();
+        clock.sleep(sleepDurationMs);
+        isSleeping = false;
+        wakeUpCountDownLatch.countDown();
+      }
+    }
+  }
+
+  private static final class TestRunnable implements Runnable {
+
+    public boolean hasRun;
+
+    @Override
+    public void run() {
+      hasRun = true;
+    }
+  }
+}
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java
new file mode 100644
index 0000000000..75c6f886c2
--- /dev/null
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSetTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData.Segment;
+import java.io.IOException;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link FakeDataSet} */
+@RunWith(RobolectricTestRunner.class)
+public final class FakeDataSetTest {
+
+  @Test
+  public void testMultipleDataSets() {
+    byte[][] testData = new byte[4][];
+    Uri[] uris = new Uri[3];
+    for (int i = 0; i < 4; i++) {
+      testData[i] = TestUtil.buildTestData(10, i);
+      if (i > 0) {
+        uris[i - 1] = Uri.parse("test_uri_" + i);
+      }
+    }
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .newDefaultData()
+            .appendReadData(testData[0])
+            .endData()
+            .setData(uris[0], testData[1])
+            .newData(uris[1])
+            .appendReadData(testData[2])
+            .endData()
+            .setData(uris[2], testData[3]);
+
+    assertThat(fakeDataSet.getAllData().size()).isEqualTo(4);
+    assertThat(fakeDataSet.getData("unseen_uri")).isEqualTo(fakeDataSet.getData((Uri) null));
+    for (int i = 0; i < 3; i++) {
+      assertThat(fakeDataSet.getData(uris[i]).uri).isEqualTo(uris[i]);
+    }
+    assertThat(fakeDataSet.getData((Uri) null).getData()).isEqualTo(testData[0]);
+    for (int i = 1; i < 4; i++) {
+      assertThat(fakeDataSet.getData(uris[i - 1]).getData()).isEqualTo(testData[i]);
+    }
+  }
+
+  @Test
+  public void testSegmentTypes() {
+    byte[] testData = TestUtil.buildTestData(3);
+    Runnable runnable =
+        new Runnable() {
+          @Override
+          public void run() {
+            // Do nothing.
+          }
+        };
+    IOException exception = new IOException();
+    FakeDataSet fakeDataSet =
+        new FakeDataSet()
+            .newDefaultData()
+            .appendReadData(testData)
+            .appendReadData(testData)
+            .appendReadData(50)
+            .appendReadAction(runnable)
+            .appendReadError(exception)
+            .endData();
+
+    List<Segment> segments = fakeDataSet.getData((Uri) null).getSegments();
+    assertThat(segments.size()).isEqualTo(5);
+    assertSegment(segments.get(0), testData, 3, 0, null, null);
+    assertSegment(segments.get(1), testData, 3, 3, null, null);
+    assertSegment(segments.get(2), null, 50, 6, null, null);
+    assertSegment(segments.get(3), null, 0, 56, runnable, null);
+    assertSegment(segments.get(4), null, 0, 56, null, exception);
+
+    byte[] allData = new byte[6];
+    System.arraycopy(testData, 0, allData, 0, 3);
+    System.arraycopy(testData, 0, allData, 3, 3);
+    assertThat(fakeDataSet.getData((Uri) null).getData()).isEqualTo(allData);
+  }
+
+  private static void assertSegment(
+      Segment segment,
+      byte[] data,
+      int length,
+      long byteOffset,
+      Runnable runnable,
+      IOException exception) {
+    if (data != null) {
+      assertThat(segment.data).isEqualTo(data);
+      assertThat(data).hasLength(length);
+    } else {
+      assertThat(segment.data).isNull();
+    }
+    assertThat(segment.length).isEqualTo(length);
+    assertThat(segment.byteOffset).isEqualTo(byteOffset);
+    assertThat(segment.action).isEqualTo(runnable);
+    assertThat(segment.isActionSegment()).isEqualTo(runnable != null);
+    assertThat(segment.exception).isEqualTo(exception);
+    assertThat(segment.isErrorSegment()).isEqualTo(exception != null);
+  }
+}
diff --git a/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSourceTest.java b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSourceTest.java
new file mode 100644
index 0000000000..c88aba4e08
--- /dev/null
+++ b/testutils/src/test/java/com/google/android/exoplayer2/testutil/FakeDataSourceTest.java
@@ -0,0 +1,251 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.net.Uri;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import java.io.IOException;
+import java.util.Arrays;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+
+/** Unit test for {@link FakeDataSource}. */
+@RunWith(RobolectricTestRunner.class)
+public final class FakeDataSourceTest {
+
+  private static final String URI_STRING = "test://test.test";
+  private static final byte[] BUFFER = new byte[500];
+  private static final byte[] TEST_DATA = TestUtil.buildTestData(15);
+  private static final byte[] TEST_DATA_PART_1 = Arrays.copyOf(TEST_DATA, 10);
+  private static final byte[] TEST_DATA_PART_2 = Arrays.copyOfRange(TEST_DATA, 10, 15);
+
+  private static Uri uri;
+  private static FakeDataSet fakeDataSet;
+
+  @Before
+  public void setUp() {
+    uri = Uri.parse(URI_STRING);
+    fakeDataSet =
+        new FakeDataSet()
+            .newData(uri.toString())
+            .appendReadData(TEST_DATA_PART_1)
+            .appendReadData(TEST_DATA_PART_2)
+            .endData();
+  }
+
+  @Test
+  public void testReadFull() throws IOException {
+    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
+    assertThat(dataSource.open(new DataSpec(uri))).isEqualTo(15);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(10);
+    assertBuffer(TEST_DATA_PART_1);
+    assertThat(dataSource.read(BUFFER, 10, BUFFER.length)).isEqualTo(5);
+    assertBuffer(TEST_DATA);
+    assertThat(dataSource.read(BUFFER, 15, BUFFER.length)).isEqualTo(C.RESULT_END_OF_INPUT);
+    assertBuffer(TEST_DATA);
+    assertThat(dataSource.read(BUFFER, 20, BUFFER.length)).isEqualTo(C.RESULT_END_OF_INPUT);
+    dataSource.close();
+  }
+
+  @Test
+  public void testReadPartialOpenEnded() throws IOException {
+    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
+    assertThat(dataSource.open(new DataSpec(uri, 7, C.LENGTH_UNSET, null))).isEqualTo(8);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(3);
+    assertBuffer(TEST_DATA_PART_1, 7, 3);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(5);
+    assertBuffer(TEST_DATA_PART_2);
+    assertThat(dataSource.read(BUFFER, 15, BUFFER.length)).isEqualTo(C.RESULT_END_OF_INPUT);
+    dataSource.close();
+  }
+
+  @Test
+  public void testReadPartialBounded() throws IOException {
+    FakeDataSource dataSource = new FakeDataSource(fakeDataSet);
+    assertThat(dataSource.open(new DataSpec(uri, 9, 3, null))).isEqualTo(3);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(1);
+    assertBuffer(TEST_DATA_PART_1, 9, 1);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(2);
+    assertBuffer(TEST_DATA_PART_2, 0, 2);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(C.RESULT_END_OF_INPUT);
+    dataSource.close();
+
+    assertThat(dataSource.open(new DataSpec(uri, 11, 4, null))).isEqualTo(4);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(4);
+    assertBuffer(TEST_DATA_PART_2, 1, 4);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(C.RESULT_END_OF_INPUT);
+    dataSource.close();
+  }
+
+  @Test
+  public void testDummyData() throws IOException {
+    FakeDataSource dataSource =
+        new FakeDataSource(
+            new FakeDataSet()
+                .newData(uri.toString())
+                .appendReadData(100)
+                .appendReadData(TEST_DATA)
+                .appendReadData(200)
+                .endData());
+    assertThat(dataSource.open(new DataSpec(uri))).isEqualTo(315);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(100);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(15);
+    assertBuffer(TEST_DATA);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(200);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(C.RESULT_END_OF_INPUT);
+    dataSource.close();
+  }
+
+  @Test
+  public void testException() throws IOException {
+    String errorMessage = "error, error, error";
+    IOException exception = new IOException(errorMessage);
+    FakeDataSource dataSource =
+        new FakeDataSource(
+            new FakeDataSet()
+                .newData(uri.toString())
+                .appendReadData(TEST_DATA)
+                .appendReadError(exception)
+                .appendReadData(TEST_DATA)
+                .endData());
+    assertThat(dataSource.open(new DataSpec(uri))).isEqualTo(30);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(15);
+    assertBuffer(TEST_DATA);
+    try {
+      dataSource.read(BUFFER, 0, BUFFER.length);
+      fail("IOException expected.");
+    } catch (IOException e) {
+      assertThat(e).hasMessageThat().isEqualTo(errorMessage);
+    }
+    try {
+      dataSource.read(BUFFER, 0, BUFFER.length);
+      fail("IOException expected.");
+    } catch (IOException e) {
+      assertThat(e).hasMessageThat().isEqualTo(errorMessage);
+    }
+    dataSource.close();
+    assertThat(dataSource.open(new DataSpec(uri, 15, 15, null))).isEqualTo(15);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(15);
+    assertBuffer(TEST_DATA);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(C.RESULT_END_OF_INPUT);
+    dataSource.close();
+  }
+
+  @Test
+  public void testRunnable() throws IOException {
+    TestRunnable[] runnables = new TestRunnable[3];
+    for (int i = 0; i < 3; i++) {
+      runnables[i] = new TestRunnable();
+    }
+    FakeDataSource dataSource =
+        new FakeDataSource(
+            new FakeDataSet()
+                .newData(uri.toString())
+                .appendReadData(TEST_DATA)
+                .appendReadAction(runnables[0])
+                .appendReadData(TEST_DATA)
+                .appendReadAction(runnables[1])
+                .appendReadAction(runnables[2])
+                .appendReadData(TEST_DATA)
+                .endData());
+    assertThat(dataSource.open(new DataSpec(uri))).isEqualTo(45);
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(15);
+    assertBuffer(TEST_DATA);
+    for (int i = 0; i < 3; i++) {
+      assertThat(runnables[i].ran).isFalse();
+    }
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(15);
+    assertBuffer(TEST_DATA);
+    assertThat(runnables[0].ran).isTrue();
+    assertThat(runnables[1].ran).isFalse();
+    assertThat(runnables[2].ran).isFalse();
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(15);
+    assertBuffer(TEST_DATA);
+    for (int i = 0; i < 3; i++) {
+      assertThat(runnables[i].ran).isTrue();
+    }
+    assertThat(dataSource.read(BUFFER, 0, BUFFER.length)).isEqualTo(C.RESULT_END_OF_INPUT);
+    dataSource.close();
+  }
+
+  @Test
+  public void testOpenSourceFailures() throws IOException {
+    // Empty data.
+    FakeDataSource dataSource =
+        new FakeDataSource(new FakeDataSet().newData(uri.toString()).endData());
+    try {
+      dataSource.open(new DataSpec(uri));
+      fail("IOException expected.");
+    } catch (IOException e) {
+      // Expected.
+    } finally {
+      dataSource.close();
+    }
+
+    // Non-existent data
+    dataSource = new FakeDataSource(new FakeDataSet());
+    try {
+      dataSource.open(new DataSpec(uri));
+      fail("IOException expected.");
+    } catch (IOException e) {
+      // Expected.
+    } finally {
+      dataSource.close();
+    }
+
+    // DataSpec out of bounds.
+    dataSource =
+        new FakeDataSource(
+            new FakeDataSet()
+                .newDefaultData()
+                .appendReadData(TestUtil.buildTestData(10))
+                .endData());
+    try {
+      dataSource.open(new DataSpec(uri, 5, 10, null));
+      fail("IOException expected.");
+    } catch (IOException e) {
+      // Expected.
+    } finally {
+      dataSource.close();
+    }
+  }
+
+  private static void assertBuffer(byte[] expected) {
+    assertBuffer(expected, 0, expected.length);
+  }
+
+  private static void assertBuffer(byte[] expected, int expectedStart, int expectedLength) {
+    for (int i = 0; i < expectedLength; i++) {
+      assertThat(BUFFER[i]).isEqualTo(expected[i + expectedStart]);
+    }
+  }
+
+  private static final class TestRunnable implements Runnable {
+
+    public boolean ran;
+
+    @Override
+    public void run() {
+      ran = true;
+    }
+  }
+}
diff --git a/testutils/src/test/resources/robolectric.properties b/testutils/src/test/resources/robolectric.properties
new file mode 100644
index 0000000000..2f3210368e
--- /dev/null
+++ b/testutils/src/test/resources/robolectric.properties
@@ -0,0 +1 @@
+manifest=src/test/AndroidManifest.xml
diff --git a/testutils_robolectric/build.gradle b/testutils_robolectric/build.gradle
new file mode 100644
index 0000000000..c221149c29
--- /dev/null
+++ b/testutils_robolectric/build.gradle
@@ -0,0 +1,39 @@
+// Copyright (C) 2018 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+apply from: '../constants.gradle'
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion project.ext.compileSdkVersion
+    buildToolsVersion project.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion project.ext.minSdkVersion
+        targetSdkVersion project.ext.targetSdkVersion
+    }
+
+    lintOptions {
+        // Truth depends on JUnit, which depends on java.lang.management, which
+        // is not part of Android. Remove this when JUnit 4.13 or later is used.
+        // See: https://github.com/junit-team/junit4/pull/1187.
+        disable 'InvalidPackage'
+    }
+}
+
+dependencies {
+    api 'org.robolectric:robolectric:' + robolectricVersion
+    api project(modulePrefix + 'testutils')
+    implementation project(modulePrefix + 'library-core')
+    implementation 'com.android.support:support-annotations:' + supportLibraryVersion
+}
diff --git a/testutils_robolectric/src/main/AndroidManifest.xml b/testutils_robolectric/src/main/AndroidManifest.xml
new file mode 100644
index 0000000000..057caad867
--- /dev/null
+++ b/testutils_robolectric/src/main/AndroidManifest.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2018 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest package="com.google.android.exoplayer2.testutil"/>
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
similarity index 60%
rename from testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
rename to testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
index 82fff0d4fe..6d3b15ac7a 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/CacheAsserts.java
@@ -15,28 +15,28 @@
  */
 package com.google.android.exoplayer2.testutil;
 
-import static junit.framework.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 
 import android.net.Uri;
-import android.test.MoreAsserts;
 import com.google.android.exoplayer2.testutil.FakeDataSet.FakeData;
-import com.google.android.exoplayer2.upstream.DataSourceInputStream;
+import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DataSpec;
 import com.google.android.exoplayer2.upstream.DummyDataSource;
 import com.google.android.exoplayer2.upstream.cache.Cache;
 import com.google.android.exoplayer2.upstream.cache.CacheDataSource;
 import com.google.android.exoplayer2.upstream.cache.CacheUtil;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
-import junit.framework.Assert;
 
-/**
- * Assertion methods for {@link Cache}.
- */
+/** Assertion methods for {@link Cache}. */
 public final class CacheAsserts {
 
-  /** Asserts that the cache content is equal to the data in the {@code fakeDataSet}. */
+  /**
+   * Asserts that the cache content is equal to the data in the {@code fakeDataSet}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
+   */
   public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws IOException {
     ArrayList<FakeData> allData = fakeDataSet.getAllData();
     Uri[] uris = new Uri[allData.size()];
@@ -48,6 +48,8 @@ public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet) throws
 
   /**
    * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
    */
   public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String... uriStrings)
       throws IOException {
@@ -60,6 +62,8 @@ public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, String
 
   /**
    * Asserts that the cache content is equal to the given subset of data in the {@code fakeDataSet}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
    */
   public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
       throws IOException {
@@ -69,10 +73,14 @@ public static void assertCachedData(Cache cache, FakeDataSet fakeDataSet, Uri...
       assertDataCached(cache, uri, data);
       totalLength += data.length;
     }
-    assertEquals(totalLength, cache.getCacheSpace());
+    assertThat(cache.getCacheSpace()).isEqualTo(totalLength);
   }
 
-  /** Asserts that the cache contains the given subset of data in the {@code fakeDataSet}. */
+  /**
+   * Asserts that the cache contains the given subset of data in the {@code fakeDataSet}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
+   */
   public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri... uris)
       throws IOException {
     for (Uri uri : uris) {
@@ -80,41 +88,49 @@ public static void assertDataCached(Cache cache, FakeDataSet fakeDataSet, Uri...
     }
   }
 
-  /** Asserts that the cache contains the given data for {@code uriString}. */
+  /**
+   * Asserts that the cache contains the given data for {@code uriString}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
+   */
   public static void assertDataCached(Cache cache, Uri uri, byte[] expected) throws IOException {
-    CacheDataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
-    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-    DataSourceInputStream inputStream = new DataSourceInputStream(dataSource,
-        new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH));
+    DataSpec dataSpec = new DataSpec(uri, DataSpec.FLAG_ALLOW_CACHING_UNKNOWN_LENGTH);
+    assertDataCached(cache, dataSpec, expected);
+  }
+
+  /**
+   * Asserts that the cache contains the given data for {@code dataSpec}.
+   *
+   * @throws IOException If an error occurred reading from the Cache.
+   */
+  public static void assertDataCached(Cache cache, DataSpec dataSpec, byte[] expected)
+      throws IOException {
+    DataSource dataSource = new CacheDataSource(cache, DummyDataSource.INSTANCE, 0);
+    dataSource.open(dataSpec);
     try {
-      inputStream.open();
-      byte[] buffer = new byte[1024];
-      int bytesRead;
-      while ((bytesRead = inputStream.read(buffer)) != -1) {
-        outputStream.write(buffer, 0, bytesRead);
-      }
-    } catch (IOException e) {
-      // Ignore
+      byte[] bytes = TestUtil.readToEnd(dataSource);
+      assertWithMessage("Cached data doesn't match expected for '" + dataSpec.uri + "',")
+          .that(bytes)
+          .isEqualTo(expected);
     } finally {
-      inputStream.close();
+      dataSource.close();
     }
-    MoreAsserts.assertEquals("Cached data doesn't match expected for '" + uri + "',",
-        expected, outputStream.toByteArray());
   }
 
   /** Asserts that there is no cache content for the given {@code uriStrings}. */
   public static void assertDataNotCached(Cache cache, String... uriStrings) {
     for (String uriString : uriStrings) {
-      Assert.assertNull("There is cached data for '" + uriString + "',",
-          cache.getCachedSpans(CacheUtil.generateKey(Uri.parse(uriString))));
+      assertWithMessage("There is cached data for '" + uriString + "',")
+          .that(cache.getCachedSpans(CacheUtil.generateKey(Uri.parse(uriString))).isEmpty())
+          .isTrue();
     }
   }
 
   /** Asserts that the cache is empty. */
   public static void assertCacheEmpty(Cache cache) {
-    assertEquals(0, cache.getCacheSpace());
+    assertThat(cache.getCacheSpace()).isEqualTo(0);
+    assertThat(cache.getKeys()).isEmpty();
   }
 
   private CacheAsserts() {}
-
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaClockRenderer.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaClockRenderer.java
similarity index 93%
rename from testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaClockRenderer.java
rename to testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaClockRenderer.java
index 4d118f9288..009afd1ff7 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaClockRenderer.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeMediaClockRenderer.java
@@ -19,9 +19,7 @@
 import com.google.android.exoplayer2.Renderer;
 import com.google.android.exoplayer2.util.MediaClock;
 
-/**
- * Fake abstract {@link Renderer} which is also a {@link MediaClock}.
- */
+/** Fake abstract {@link Renderer} which is also a {@link MediaClock}. */
 public abstract class FakeMediaClockRenderer extends FakeRenderer implements MediaClock {
 
   public FakeMediaClockRenderer(Format... expectedFormats) {
@@ -32,5 +30,4 @@ public FakeMediaClockRenderer(Format... expectedFormats) {
   public MediaClock getMediaClock() {
     return this;
   }
-
 }
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
similarity index 94%
rename from testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
rename to testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
index 0664f47023..cb70c75bdb 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeShuffleOrder.java
@@ -65,4 +65,8 @@ public ShuffleOrder cloneAndRemove(int removalIndex) {
     return new FakeShuffleOrder(length - 1);
   }
 
+  @Override
+  public ShuffleOrder cloneAndClear() {
+    return new FakeShuffleOrder(/* length= */ 0);
+  }
 }
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelection.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelection.java
new file mode 100644
index 0000000000..8ceb5338a6
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelection.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.chunk.MediaChunk;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import java.util.List;
+
+/**
+ * A fake {@link TrackSelection} that only returns 1 fixed track, and allows querying the number of
+ * calls to its methods.
+ */
+public final class FakeTrackSelection implements TrackSelection {
+
+  private final TrackGroup rendererTrackGroup;
+
+  public int enableCount;
+  public int releaseCount;
+  public boolean isEnabled;
+
+  public FakeTrackSelection(TrackGroup rendererTrackGroup) {
+    this.rendererTrackGroup = rendererTrackGroup;
+  }
+
+  @Override
+  public void enable() {
+    // assert that track selection is in disabled state before this call.
+    assertThat(isEnabled).isFalse();
+    enableCount++;
+    isEnabled = true;
+  }
+
+  @Override
+  public void disable() {
+    // assert that track selection is in enabled state before this call.
+    assertThat(isEnabled).isTrue();
+    releaseCount++;
+    isEnabled = false;
+  }
+
+  @Override
+  public TrackGroup getTrackGroup() {
+    return rendererTrackGroup;
+  }
+
+  @Override
+  public int length() {
+    return rendererTrackGroup.length;
+  }
+
+  @Override
+  public Format getFormat(int index) {
+    return rendererTrackGroup.getFormat(0);
+  }
+
+  @Override
+  public int getIndexInTrackGroup(int index) {
+    return 0;
+  }
+
+  @Override
+  public int indexOf(Format format) {
+    assertThat(isEnabled).isTrue();
+    return 0;
+  }
+
+  @Override
+  public int indexOf(int indexInTrackGroup) {
+    return 0;
+  }
+
+  @Override
+  public Format getSelectedFormat() {
+    return rendererTrackGroup.getFormat(0);
+  }
+
+  @Override
+  public int getSelectedIndexInTrackGroup() {
+    return 0;
+  }
+
+  @Override
+  public int getSelectedIndex() {
+    return 0;
+  }
+
+  @Override
+  public int getSelectionReason() {
+    return C.SELECTION_REASON_UNKNOWN;
+  }
+
+  @Override
+  public Object getSelectionData() {
+    return null;
+  }
+
+  @Override
+  public void onPlaybackSpeed(float speed) {
+    // Do nothing.
+  }
+
+  @Override
+  public void updateSelectedTrack(
+      long playbackPositionUs, long bufferedDurationUs, long availableDurationUs) {
+    assertThat(isEnabled).isTrue();
+  }
+
+  @Override
+  public int evaluateQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
+    assertThat(isEnabled).isTrue();
+    return 0;
+  }
+
+  @Override
+  public boolean blacklist(int index, long blacklistDurationMs) {
+    assertThat(isEnabled).isTrue();
+    return false;
+  }
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java
new file mode 100644
index 0000000000..2daafbbb0b
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/FakeTrackSelector.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import android.support.annotation.NonNull;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.RendererCapabilities;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import java.util.ArrayList;
+import java.util.List;
+
+/** A fake {@link MappingTrackSelector} that returns {@link FakeTrackSelection}s. */
+public class FakeTrackSelector extends MappingTrackSelector {
+
+  private final List<FakeTrackSelection> selectedTrackSelections = new ArrayList<>();
+  private final boolean mayReuseTrackSelection;
+
+  public FakeTrackSelector() {
+    this(false);
+  }
+
+  /**
+   * @param mayReuseTrackSelection Whether this {@link FakeTrackSelector} will reuse {@link
+   *     TrackSelection}s during track selection, when it finds previously-selected track selection
+   *     using the same {@link TrackGroup}.
+   */
+  public FakeTrackSelector(boolean mayReuseTrackSelection) {
+    this.mayReuseTrackSelection = mayReuseTrackSelection;
+  }
+
+  @Override
+  protected TrackSelection[] selectTracks(
+      RendererCapabilities[] rendererCapabilities,
+      TrackGroupArray[] rendererTrackGroupArrays,
+      int[][][] rendererFormatSupports)
+      throws ExoPlaybackException {
+    List<FakeTrackSelection> resultList = new ArrayList<>();
+    for (TrackGroupArray trackGroupArray : rendererTrackGroupArrays) {
+      TrackGroup trackGroup = trackGroupArray.get(0);
+      FakeTrackSelection trackSelectionForRenderer = reuseOrCreateTrackSelection(trackGroup);
+      resultList.add(trackSelectionForRenderer);
+    }
+    return resultList.toArray(new TrackSelection[resultList.size()]);
+  }
+
+  @NonNull
+  private FakeTrackSelection reuseOrCreateTrackSelection(TrackGroup trackGroup) {
+    FakeTrackSelection trackSelectionForRenderer = null;
+    if (mayReuseTrackSelection) {
+      for (FakeTrackSelection selectedTrackSelection : selectedTrackSelections) {
+        if (selectedTrackSelection.getTrackGroup().equals(trackGroup)) {
+          trackSelectionForRenderer = selectedTrackSelection;
+        }
+      }
+    }
+    if (trackSelectionForRenderer == null) {
+      trackSelectionForRenderer = new FakeTrackSelection(trackGroup);
+      selectedTrackSelections.add(trackSelectionForRenderer);
+    }
+    return trackSelectionForRenderer;
+  }
+
+  /** Returns list of all {@link FakeTrackSelection}s that this track selector has made so far. */
+  public List<FakeTrackSelection> getSelectedTrackSelections() {
+    return selectedTrackSelections;
+  }
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
new file mode 100644
index 0000000000..fbb48c9529
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/MediaSourceTestRunner.java
@@ -0,0 +1,327 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.os.ConditionVariable;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import com.google.android.exoplayer2.ExoPlaybackException;
+import com.google.android.exoplayer2.PlayerMessage;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaPeriod;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MediaSource.MediaPeriodId;
+import com.google.android.exoplayer2.upstream.Allocator;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.util.Util;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.concurrent.TimeUnit;
+
+/** A runner for {@link MediaSource} tests. */
+public class MediaSourceTestRunner {
+
+  public static final int TIMEOUT_MS = 10000;
+
+  private final StubExoPlayer player;
+  private final MediaSource mediaSource;
+  private final MediaSourceListener mediaSourceListener;
+  private final HandlerThread playbackThread;
+  private final Handler playbackHandler;
+  private final Allocator allocator;
+
+  private final LinkedBlockingDeque<Timeline> timelines;
+  private Timeline timeline;
+
+  /**
+   * @param mediaSource The source under test.
+   * @param allocator The allocator to use during the test run.
+   */
+  public MediaSourceTestRunner(MediaSource mediaSource, Allocator allocator) {
+    this.mediaSource = mediaSource;
+    this.allocator = allocator;
+    playbackThread = new HandlerThread("PlaybackThread");
+    playbackThread.start();
+    Looper playbackLooper = playbackThread.getLooper();
+    playbackHandler = new Handler(playbackLooper);
+    player = new EventHandlingExoPlayer(playbackLooper);
+    mediaSourceListener = new MediaSourceListener();
+    timelines = new LinkedBlockingDeque<>();
+  }
+
+  /**
+   * Runs the provided {@link Runnable} on the playback thread, blocking until execution completes.
+   *
+   * @param runnable The {@link Runnable} to run.
+   */
+  public void runOnPlaybackThread(final Runnable runnable) {
+    final Throwable[] throwable = new Throwable[1];
+    final ConditionVariable finishedCondition = new ConditionVariable();
+    playbackHandler.post(
+        new Runnable() {
+          @Override
+          public void run() {
+            try {
+              runnable.run();
+            } catch (Throwable e) {
+              throwable[0] = e;
+            } finally {
+              finishedCondition.open();
+            }
+          }
+        });
+    assertThat(finishedCondition.block(TIMEOUT_MS)).isTrue();
+    if (throwable[0] != null) {
+      Util.sneakyThrow(throwable[0]);
+    }
+  }
+
+  /**
+   * Prepares the source on the playback thread, asserting that it provides an initial timeline.
+   *
+   * @return The initial {@link Timeline}.
+   */
+  public Timeline prepareSource() throws IOException {
+    final IOException[] prepareError = new IOException[1];
+    runOnPlaybackThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            mediaSource.prepareSource(player, true, mediaSourceListener);
+            try {
+              // TODO: This only catches errors that are set synchronously in prepareSource. To
+              // capture async errors we'll need to poll maybeThrowSourceInfoRefreshError until the
+              // first call to onSourceInfoRefreshed.
+              mediaSource.maybeThrowSourceInfoRefreshError();
+            } catch (IOException e) {
+              prepareError[0] = e;
+            }
+          }
+        });
+    if (prepareError[0] != null) {
+      throw prepareError[0];
+    }
+    return assertTimelineChangeBlocking();
+  }
+
+  /**
+   * Calls {@link MediaSource#createPeriod(MediaSource.MediaPeriodId, Allocator)} on the playback
+   * thread, asserting that a non-null {@link MediaPeriod} is returned.
+   *
+   * @param periodId The id of the period to create.
+   * @return The created {@link MediaPeriod}.
+   */
+  public MediaPeriod createPeriod(final MediaPeriodId periodId) {
+    final MediaPeriod[] holder = new MediaPeriod[1];
+    runOnPlaybackThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            holder[0] = mediaSource.createPeriod(periodId, allocator);
+          }
+        });
+    assertThat(holder[0]).isNotNull();
+    return holder[0];
+  }
+
+  /**
+   * Calls {@link MediaPeriod#prepare(MediaPeriod.Callback, long)} on the playback thread and blocks
+   * until the method has been called.
+   *
+   * @param mediaPeriod The {@link MediaPeriod} to prepare.
+   * @param positionUs The position at which to prepare.
+   * @return A {@link CountDownLatch} that will be counted down when preparation completes.
+   */
+  public CountDownLatch preparePeriod(final MediaPeriod mediaPeriod, final long positionUs) {
+    final ConditionVariable prepareCalled = new ConditionVariable();
+    final CountDownLatch preparedCountDown = new CountDownLatch(1);
+    runOnPlaybackThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            mediaPeriod.prepare(
+                new MediaPeriod.Callback() {
+                  @Override
+                  public void onPrepared(MediaPeriod mediaPeriod) {
+                    preparedCountDown.countDown();
+                  }
+
+                  @Override
+                  public void onContinueLoadingRequested(MediaPeriod source) {
+                    // Do nothing.
+                  }
+                },
+                positionUs);
+            prepareCalled.open();
+          }
+        });
+    prepareCalled.block();
+    return preparedCountDown;
+  }
+
+  /**
+   * Calls {@link MediaSource#releasePeriod(MediaPeriod)} on the playback thread.
+   *
+   * @param mediaPeriod The {@link MediaPeriod} to release.
+   */
+  public void releasePeriod(final MediaPeriod mediaPeriod) {
+    runOnPlaybackThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            mediaSource.releasePeriod(mediaPeriod);
+          }
+        });
+  }
+
+  /** Calls {@link MediaSource#releaseSource()} on the playback thread. */
+  public void releaseSource() {
+    runOnPlaybackThread(
+        new Runnable() {
+          @Override
+          public void run() {
+            mediaSource.releaseSource();
+          }
+        });
+  }
+
+  /**
+   * Asserts that the source has not notified its listener of a timeline change since the last call
+   * to {@link #assertTimelineChangeBlocking()} or {@link #assertTimelineChange()} (or since the
+   * runner was created if neither method has been called).
+   */
+  public void assertNoTimelineChange() {
+    assertThat(timelines.isEmpty()).isTrue();
+  }
+
+  /**
+   * Asserts that the source has notified its listener of a single timeline change.
+   *
+   * @return The new {@link Timeline}.
+   */
+  public Timeline assertTimelineChange() {
+    timeline = timelines.removeFirst();
+    assertNoTimelineChange();
+    return timeline;
+  }
+
+  /**
+   * Asserts that the source notifies its listener of a single timeline change. If the source has
+   * not yet notified its listener, it has up to the timeout passed to the constructor to do so.
+   *
+   * @return The new {@link Timeline}.
+   */
+  public Timeline assertTimelineChangeBlocking() {
+    try {
+      timeline = timelines.poll(TIMEOUT_MS, TimeUnit.MILLISECONDS);
+      assertThat(timeline).isNotNull(); // Null indicates the poll timed out.
+      assertNoTimelineChange();
+      return timeline;
+    } catch (InterruptedException e) {
+      // Should never happen.
+      throw new RuntimeException(e);
+    }
+  }
+
+  /**
+   * Creates and releases all periods (including ad periods) defined in the last timeline to be
+   * returned from {@link #prepareSource()}, {@link #assertTimelineChange()} or {@link
+   * #assertTimelineChangeBlocking()}. The {@link MediaPeriodId#windowSequenceNumber} is set to the
+   * index of the window.
+   */
+  public void assertPrepareAndReleaseAllPeriods() throws InterruptedException {
+    Timeline.Period period = new Timeline.Period();
+    for (int i = 0; i < timeline.getPeriodCount(); i++) {
+      timeline.getPeriod(i, period);
+      assertPrepareAndReleasePeriod(new MediaPeriodId(i, period.windowIndex));
+      for (int adGroupIndex = 0; adGroupIndex < period.getAdGroupCount(); adGroupIndex++) {
+        for (int adIndex = 0; adIndex < period.getAdCountInAdGroup(adGroupIndex); adIndex++) {
+          assertPrepareAndReleasePeriod(
+              new MediaPeriodId(i, adGroupIndex, adIndex, period.windowIndex));
+        }
+      }
+    }
+  }
+
+  private void assertPrepareAndReleasePeriod(MediaPeriodId mediaPeriodId)
+      throws InterruptedException {
+    MediaPeriod mediaPeriod = createPeriod(mediaPeriodId);
+    CountDownLatch preparedCondition = preparePeriod(mediaPeriod, 0);
+    assertThat(preparedCondition.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)).isTrue();
+    // MediaSource is supposed to support multiple calls to createPeriod with the same id without an
+    // intervening call to releasePeriod.
+    MediaPeriod secondMediaPeriod = createPeriod(mediaPeriodId);
+    CountDownLatch secondPreparedCondition = preparePeriod(secondMediaPeriod, 0);
+    assertThat(secondPreparedCondition.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)).isTrue();
+    // Release the periods.
+    releasePeriod(mediaPeriod);
+    releasePeriod(secondMediaPeriod);
+  }
+
+  /** Releases the runner. Should be called when the runner is no longer required. */
+  public void release() {
+    playbackThread.quit();
+  }
+
+  private class MediaSourceListener implements MediaSource.Listener {
+
+    @Override
+    public void onSourceInfoRefreshed(MediaSource source, Timeline timeline, Object manifest) {
+      Assertions.checkState(Looper.myLooper() == playbackThread.getLooper());
+      timelines.addLast(timeline);
+    }
+  }
+
+  private static class EventHandlingExoPlayer extends StubExoPlayer
+      implements Handler.Callback, PlayerMessage.Sender {
+
+    private final Handler handler;
+
+    public EventHandlingExoPlayer(Looper looper) {
+      this.handler = new Handler(looper, this);
+    }
+
+    @Override
+    public PlayerMessage createMessage(PlayerMessage.Target target) {
+      return new PlayerMessage(
+          /* sender= */ this, target, Timeline.EMPTY, /* defaultWindowIndex= */ 0, handler);
+    }
+
+    @Override
+    public void sendMessage(PlayerMessage message) {
+      handler.obtainMessage(0, message).sendToTarget();
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public boolean handleMessage(Message msg) {
+      PlayerMessage message = (PlayerMessage) msg.obj;
+      try {
+        message.getTarget().handleMessage(message.getType(), message.getPayload());
+        message.markAsProcessed(/* isDelivered= */ true);
+      } catch (ExoPlaybackException e) {
+        fail("Unexpected ExoPlaybackException.");
+      }
+      return true;
+    }
+  }
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/OggTestData.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/OggTestData.java
new file mode 100644
index 0000000000..8dd0cd16b1
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/OggTestData.java
@@ -0,0 +1,1070 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+/** Provides ogg/vorbis test data in bytes for unit tests. */
+public final class OggTestData {
+
+  public static FakeExtractorInput createInput(byte[] data, boolean simulateUnknownLength) {
+    return new FakeExtractorInput.Builder()
+        .setData(data)
+        .setSimulateIOErrors(true)
+        .setSimulateUnknownLength(simulateUnknownLength)
+        .setSimulatePartialReads(true)
+        .build();
+  }
+
+  public static byte[] buildOggHeader(
+      int headerType, long granule, int pageSequenceCounter, int pageSegmentCount) {
+    return TestUtil.createByteArray(
+        0x4F,
+        0x67,
+        0x67,
+        0x53, // Oggs.
+        0x00, // Stream revision.
+        headerType,
+        (int) (granule) & 0xFF,
+        (int) (granule >> 8) & 0xFF,
+        (int) (granule >> 16) & 0xFF,
+        (int) (granule >> 24) & 0xFF,
+        (int) (granule >> 32) & 0xFF,
+        (int) (granule >> 40) & 0xFF,
+        (int) (granule >> 48) & 0xFF,
+        (int) (granule >> 56) & 0xFF,
+        0x00, // LSB of data serial number.
+        0x10,
+        0x00,
+        0x00, // MSB of data serial number.
+        (pageSequenceCounter) & 0xFF,
+        (pageSequenceCounter >> 8) & 0xFF,
+        (pageSequenceCounter >> 16) & 0xFF,
+        (pageSequenceCounter >> 24) & 0xFF,
+        0x00, // LSB of page checksum.
+        0x00,
+        0x10,
+        0x00, // MSB of page checksum.
+        pageSegmentCount);
+  }
+
+  /**
+   * Returns the initial two pages of bytes which by spec contain the three vorbis header packets:
+   * identification, comment and setup header.
+   */
+  public static byte[] getVorbisHeaderPages() {
+    byte[] data = new byte[VORBIS_HEADER_PAGES.length];
+    System.arraycopy(VORBIS_HEADER_PAGES, 0, data, 0, VORBIS_HEADER_PAGES.length);
+    return data;
+  }
+
+  /** Returns a valid vorbis identification header in bytes. */
+  public static byte[] getIdentificationHeaderData() {
+    int idHeaderStart = 28;
+    int idHeaderLength = 30;
+    byte[] idHeaderData = new byte[idHeaderLength];
+    System.arraycopy(VORBIS_HEADER_PAGES, idHeaderStart, idHeaderData, 0, idHeaderLength);
+    return idHeaderData;
+  }
+
+  /** Returns a valid vorbis comment header with 3 comments including utf8 chars in bytes. */
+  public static byte[] getCommentHeaderDataUTF8() {
+    byte[] commentHeaderData = new byte[COMMENT_HEADER_WITH_UTF8.length];
+    System.arraycopy(
+        COMMENT_HEADER_WITH_UTF8, 0, commentHeaderData, 0, COMMENT_HEADER_WITH_UTF8.length);
+    return commentHeaderData;
+  }
+
+  /** Returns a valid vorbis setup header in bytes. */
+  public static byte[] getSetupHeaderData() {
+    int setupHeaderStart = 146;
+    int setupHeaderLength = VORBIS_HEADER_PAGES.length - setupHeaderStart;
+    byte[] setupHeaderData = new byte[setupHeaderLength];
+    System.arraycopy(VORBIS_HEADER_PAGES, setupHeaderStart, setupHeaderData, 0, setupHeaderLength);
+    return setupHeaderData;
+  }
+
+  private static final byte[] COMMENT_HEADER_WITH_UTF8 = {
+    (byte) 0x03, (byte) 0x76, (byte) 0x6f, (byte) 0x72, // 3, v, o, r,
+    (byte) 0x62, (byte) 0x69, (byte) 0x73, (byte) 0x2b, // b, i, s, .
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x58,
+    (byte) 0x69, (byte) 0x70, (byte) 0x68, (byte) 0x2e,
+    (byte) 0x4f, (byte) 0x72, (byte) 0x67, (byte) 0x20,
+    (byte) 0x6c, (byte) 0x69, (byte) 0x62, (byte) 0x56,
+    (byte) 0x6f, (byte) 0x72, (byte) 0x62, (byte) 0x69,
+    (byte) 0x73, (byte) 0x20, (byte) 0x49, (byte) 0x20,
+    (byte) 0x32, (byte) 0x30, (byte) 0x31, (byte) 0x32,
+    (byte) 0x30, (byte) 0x32, (byte) 0x30, (byte) 0x33,
+    (byte) 0x20, (byte) 0x28, (byte) 0x4f, (byte) 0x6d,
+    (byte) 0x6e, (byte) 0x69, (byte) 0x70, (byte) 0x72,
+    (byte) 0x65, (byte) 0x73, (byte) 0x65, (byte) 0x6e,
+    (byte) 0x74, (byte) 0x29, (byte) 0x03, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x0a, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x4c,
+    (byte) 0x42, (byte) 0x55, (byte) 0x4d, (byte) 0x3d,
+    (byte) 0xc3, (byte) 0xa4, (byte) 0xc3, (byte) 0xb6,
+    (byte) 0x13, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x54, (byte) 0x49, (byte) 0x54, (byte) 0x4c,
+    (byte) 0x45, (byte) 0x3d, (byte) 0x41, (byte) 0x20,
+    (byte) 0x73, (byte) 0x61, (byte) 0x6d, (byte) 0x70,
+    (byte) 0x6c, (byte) 0x65, (byte) 0x20, (byte) 0x73,
+    (byte) 0x6f, (byte) 0x6e, (byte) 0x67, (byte) 0x0d,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41,
+    (byte) 0x52, (byte) 0x54, (byte) 0x49, (byte) 0x53,
+    (byte) 0x54, (byte) 0x3d, (byte) 0x47, (byte) 0x6f,
+    (byte) 0x6f, (byte) 0x67, (byte) 0x6c, (byte) 0x65,
+    (byte) 0x01
+  };
+
+  // two OGG pages with 3 packets (id, comment and setup header)
+  // length: 3743 bytes
+  private static final byte[] VORBIS_HEADER_PAGES = { /* capture pattern ogg header 1 */
+    (byte) 0x4f, (byte) 0x67, (byte) 0x67, (byte) 0x53, // O,g,g,S  : start pos 0
+    (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x5e, (byte) 0x5f,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x83, (byte) 0x36,
+    (byte) 0xe3, (byte) 0x49, (byte) 0x01, (byte) 0x1e, /* capture pattern vorbis id header */
+    (byte) 0x01, (byte) 0x76, (byte) 0x6f, (byte) 0x72, // 1,v,o,r  : start pos 28
+    (byte) 0x62, (byte) 0x69, (byte) 0x73, (byte) 0x00, // b,i,s,.
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02,
+    (byte) 0x22, (byte) 0x56, (byte) 0x00, (byte) 0x00,
+    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+    (byte) 0x6a, (byte) 0x04, (byte) 0x01, (byte) 0x00,
+    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, /* capture pattern ogg header 2 */
+    (byte) 0xa9, (byte) 0x01, (byte) 0x4f, (byte) 0x67, // .,.,O,g  : start pos 86
+    (byte) 0x67, (byte) 0x53, (byte) 0x00, (byte) 0x00, // g,S,.,.
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x5e, (byte) 0x5f, (byte) 0x00, (byte) 0x00,
+    (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x69, (byte) 0xf8, (byte) 0xeb, (byte) 0xe1,
+    (byte) 0x10, (byte) 0x2d, (byte) 0xff, (byte) 0xff,
+    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, /* capture pattern vorbis comment header*/
+    (byte) 0x1b, (byte) 0x03, (byte) 0x76, (byte) 0x6f, // .,3,v,o  : start pos 101
+    (byte) 0x72, (byte) 0x62, (byte) 0x69, (byte) 0x73, // r,b,i,s
+    (byte) 0x1d, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x58, (byte) 0x69, (byte) 0x70, (byte) 0x68,
+    (byte) 0x2e, (byte) 0x4f, (byte) 0x72, (byte) 0x67,
+    (byte) 0x20, (byte) 0x6c, (byte) 0x69, (byte) 0x62,
+    (byte) 0x56, (byte) 0x6f, (byte) 0x72, (byte) 0x62,
+    (byte) 0x69, (byte) 0x73, (byte) 0x20, (byte) 0x49,
+    (byte) 0x20, (byte) 0x32, (byte) 0x30, (byte) 0x30,
+    (byte) 0x33, (byte) 0x30, (byte) 0x39, (byte) 0x30,
+    (byte) 0x39, (byte) 0x00, (byte) 0x00, (byte) 0x00, /* capture pattern vorbis setup header */
+    (byte) 0x00, (byte) 0x01, (byte) 0x05, (byte) 0x76, // .,.,5,v  : start pos 146
+    (byte) 0x6f, (byte) 0x72, (byte) 0x62, (byte) 0x69, // o,r,b,i
+    (byte) 0x73, (byte) 0x22, (byte) 0x42, (byte) 0x43, // s,.
+    (byte) 0x56, (byte) 0x01, (byte) 0x00, (byte) 0x40,
+    (byte) 0x00, (byte) 0x00, (byte) 0x18, (byte) 0x42,
+    (byte) 0x10, (byte) 0x2a, (byte) 0x05, (byte) 0xad,
+    (byte) 0x63, (byte) 0x8e, (byte) 0x3a, (byte) 0xc8,
+    (byte) 0x15, (byte) 0x21, (byte) 0x8c, (byte) 0x19,
+    (byte) 0xa2, (byte) 0xa0, (byte) 0x42, (byte) 0xca,
+    (byte) 0x29, (byte) 0xc7, (byte) 0x1d, (byte) 0x42,
+    (byte) 0xd0, (byte) 0x21, (byte) 0xa3, (byte) 0x24,
+    (byte) 0x43, (byte) 0x88, (byte) 0x3a, (byte) 0xc6,
+    (byte) 0x35, (byte) 0xc7, (byte) 0x18, (byte) 0x63,
+    (byte) 0x47, (byte) 0xb9, (byte) 0x64, (byte) 0x8a,
+    (byte) 0x42, (byte) 0xc9, (byte) 0x81, (byte) 0xd0,
+    (byte) 0x90, (byte) 0x55, (byte) 0x00, (byte) 0x00,
+    (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0xa4,
+    (byte) 0x1c, (byte) 0x57, (byte) 0x50, (byte) 0x72,
+    (byte) 0x49, (byte) 0x2d, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0xa3, (byte) 0x18, (byte) 0x57,
+    (byte) 0xcc, (byte) 0x71, (byte) 0xe8, (byte) 0x20,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xe5,
+    (byte) 0x20, (byte) 0x67, (byte) 0xcc, (byte) 0x71,
+    (byte) 0x09, (byte) 0x25, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0x8e, (byte) 0x39, (byte) 0xe7,
+    (byte) 0x92, (byte) 0x72, (byte) 0x8e, (byte) 0x31,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xa3,
+    (byte) 0x18, (byte) 0x57, (byte) 0x0e, (byte) 0x72,
+    (byte) 0x29, (byte) 0x2d, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0x81, (byte) 0x14, (byte) 0x47,
+    (byte) 0x8a, (byte) 0x71, (byte) 0xa7, (byte) 0x18,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xa4,
+    (byte) 0x1c, (byte) 0x47, (byte) 0x8a, (byte) 0x71,
+    (byte) 0xa8, (byte) 0x18, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0x6d, (byte) 0x31, (byte) 0xb7,
+    (byte) 0x92, (byte) 0x72, (byte) 0xce, (byte) 0x39,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xe6,
+    (byte) 0x20, (byte) 0x87, (byte) 0x52, (byte) 0x72,
+    (byte) 0xae, (byte) 0x35, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0xa4, (byte) 0x18, (byte) 0x67,
+    (byte) 0x0e, (byte) 0x72, (byte) 0x0b, (byte) 0x25,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xc6,
+    (byte) 0x20, (byte) 0x67, (byte) 0xcc, (byte) 0x71,
+    (byte) 0xeb, (byte) 0x20, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0x8c, (byte) 0x35, (byte) 0xb7,
+    (byte) 0xd4, (byte) 0x72, (byte) 0xce, (byte) 0x39,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
+    (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
+    (byte) 0xce, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0x8c, (byte) 0x31, (byte) 0xe7,
+    (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0x6e,
+    (byte) 0x31, (byte) 0xe7, (byte) 0x16, (byte) 0x73,
+    (byte) 0xae, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
+    (byte) 0x1c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0x20,
+    (byte) 0x34, (byte) 0x64, (byte) 0x15, (byte) 0x00,
+    (byte) 0x90, (byte) 0x00, (byte) 0x00, (byte) 0xa0,
+    (byte) 0xa1, (byte) 0x28, (byte) 0x8a, (byte) 0xe2,
+    (byte) 0x28, (byte) 0x0e, (byte) 0x10, (byte) 0x1a,
+    (byte) 0xb2, (byte) 0x0a, (byte) 0x00, (byte) 0xc8,
+    (byte) 0x00, (byte) 0x00, (byte) 0x10, (byte) 0x40,
+    (byte) 0x71, (byte) 0x14, (byte) 0x47, (byte) 0x91,
+    (byte) 0x14, (byte) 0x4b, (byte) 0xb1, (byte) 0x1c,
+    (byte) 0xcb, (byte) 0xd1, (byte) 0x24, (byte) 0x0d,
+    (byte) 0x08, (byte) 0x0d, (byte) 0x59, (byte) 0x05,
+    (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x00,
+    (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0xa0,
+    (byte) 0x48, (byte) 0x86, (byte) 0xa4, (byte) 0x48,
+    (byte) 0x8a, (byte) 0xa5, (byte) 0x58, (byte) 0x8e,
+    (byte) 0x66, (byte) 0x69, (byte) 0x9e, (byte) 0x26,
+    (byte) 0x7a, (byte) 0xa2, (byte) 0x28, (byte) 0x9a,
+    (byte) 0xa2, (byte) 0x2a, (byte) 0xab, (byte) 0xb2,
+    (byte) 0x69, (byte) 0xca, (byte) 0xb2, (byte) 0x2c,
+    (byte) 0xcb, (byte) 0xb2, (byte) 0xeb, (byte) 0xba,
+    (byte) 0x2e, (byte) 0x10, (byte) 0x1a, (byte) 0xb2,
+    (byte) 0x0a, (byte) 0x00, (byte) 0x48, (byte) 0x00,
+    (byte) 0x00, (byte) 0x50, (byte) 0x51, (byte) 0x14,
+    (byte) 0xc5, (byte) 0x70, (byte) 0x14, (byte) 0x07,
+    (byte) 0x08, (byte) 0x0d, (byte) 0x59, (byte) 0x05,
+    (byte) 0x00, (byte) 0x64, (byte) 0x00, (byte) 0x00,
+    (byte) 0x08, (byte) 0x60, (byte) 0x28, (byte) 0x8a,
+    (byte) 0xa3, (byte) 0x38, (byte) 0x8e, (byte) 0xe4,
+    (byte) 0x58, (byte) 0x92, (byte) 0xa5, (byte) 0x59,
+    (byte) 0x9e, (byte) 0x07, (byte) 0x84, (byte) 0x86,
+    (byte) 0xac, (byte) 0x02, (byte) 0x00, (byte) 0x80,
+    (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x00,
+    (byte) 0x00, (byte) 0x50, (byte) 0x0c, (byte) 0x47,
+    (byte) 0xb1, (byte) 0x14, (byte) 0x4d, (byte) 0xf1,
+    (byte) 0x24, (byte) 0xcf, (byte) 0xf2, (byte) 0x3c,
+    (byte) 0xcf, (byte) 0xf3, (byte) 0x3c, (byte) 0xcf,
+    (byte) 0xf3, (byte) 0x3c, (byte) 0xcf, (byte) 0xf3,
+    (byte) 0x3c, (byte) 0xcf, (byte) 0xf3, (byte) 0x3c,
+    (byte) 0xcf, (byte) 0xf3, (byte) 0x3c, (byte) 0xcf,
+    (byte) 0xf3, (byte) 0x3c, (byte) 0x0d, (byte) 0x08,
+    (byte) 0x0d, (byte) 0x59, (byte) 0x05, (byte) 0x00,
+    (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x82, (byte) 0x28, (byte) 0x64, (byte) 0x18,
+    (byte) 0x03, (byte) 0x42, (byte) 0x43, (byte) 0x56,
+    (byte) 0x01, (byte) 0x00, (byte) 0x40, (byte) 0x00,
+    (byte) 0x00, (byte) 0x08, (byte) 0x21, (byte) 0x1a,
+    (byte) 0x19, (byte) 0x43, (byte) 0x9d, (byte) 0x52,
+    (byte) 0x12, (byte) 0x5c, (byte) 0x0a, (byte) 0x16,
+    (byte) 0x42, (byte) 0x1c, (byte) 0x11, (byte) 0x43,
+    (byte) 0x1d, (byte) 0x42, (byte) 0xce, (byte) 0x43,
+    (byte) 0xa9, (byte) 0xa5, (byte) 0x83, (byte) 0xe0,
+    (byte) 0x29, (byte) 0x85, (byte) 0x25, (byte) 0x63,
+    (byte) 0xd2, (byte) 0x53, (byte) 0xac, (byte) 0x41,
+    (byte) 0x08, (byte) 0x21, (byte) 0x7c, (byte) 0xef,
+    (byte) 0x3d, (byte) 0xf7, (byte) 0xde, (byte) 0x7b,
+    (byte) 0xef, (byte) 0x81, (byte) 0xd0, (byte) 0x90,
+    (byte) 0x55, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+    (byte) 0x00, (byte) 0x00, (byte) 0x61, (byte) 0x14,
+    (byte) 0x38, (byte) 0x88, (byte) 0x81, (byte) 0xc7,
+    (byte) 0x24, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+    (byte) 0x62, (byte) 0x14, (byte) 0x27, (byte) 0x44,
+    (byte) 0x71, (byte) 0xa6, (byte) 0x20, (byte) 0x08,
+    (byte) 0x21, (byte) 0x84, (byte) 0xe5, (byte) 0x24,
+    (byte) 0x58, (byte) 0xca, (byte) 0x79, (byte) 0xe8,
+    (byte) 0x24, (byte) 0x08, (byte) 0xdd, (byte) 0x83,
+    (byte) 0x10, (byte) 0x42, (byte) 0xb8, (byte) 0x9c,
+    (byte) 0x7b, (byte) 0xcb, (byte) 0xb9, (byte) 0xf7,
+    (byte) 0xde, (byte) 0x7b, (byte) 0x20, (byte) 0x34,
+    (byte) 0x64, (byte) 0x15, (byte) 0x00, (byte) 0x00,
+    (byte) 0x08, (byte) 0x00, (byte) 0xc0, (byte) 0x20,
+    (byte) 0x84, (byte) 0x10, (byte) 0x42, (byte) 0x08,
+    (byte) 0x21, (byte) 0x84, (byte) 0x10, (byte) 0x42,
+    (byte) 0x08, (byte) 0x29, (byte) 0xa4, (byte) 0x94,
+    (byte) 0x52, (byte) 0x48, (byte) 0x29, (byte) 0xa6,
+    (byte) 0x98, (byte) 0x62, (byte) 0x8a, (byte) 0x29,
+    (byte) 0xc7, (byte) 0x1c, (byte) 0x73, (byte) 0xcc,
+    (byte) 0x31, (byte) 0xc7, (byte) 0x20, (byte) 0x83,
+    (byte) 0x0c, (byte) 0x32, (byte) 0xe8, (byte) 0xa0,
+    (byte) 0x93, (byte) 0x4e, (byte) 0x3a, (byte) 0xc9,
+    (byte) 0xa4, (byte) 0x92, (byte) 0x4e, (byte) 0x3a,
+    (byte) 0xca, (byte) 0x24, (byte) 0xa3, (byte) 0x8e,
+    (byte) 0x52, (byte) 0x6b, (byte) 0x29, (byte) 0xb5,
+    (byte) 0x14, (byte) 0x53, (byte) 0x4c, (byte) 0xb1,
+    (byte) 0xe5, (byte) 0x16, (byte) 0x63, (byte) 0xad,
+    (byte) 0xb5, (byte) 0xd6, (byte) 0x9c, (byte) 0x73,
+    (byte) 0xaf, (byte) 0x41, (byte) 0x29, (byte) 0x63,
+    (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+    (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+    (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
+    (byte) 0xc6, (byte) 0x18, (byte) 0x23, (byte) 0x08,
+    (byte) 0x0d, (byte) 0x59, (byte) 0x05, (byte) 0x00,
+    (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+    (byte) 0x06, (byte) 0x19, (byte) 0x64, (byte) 0x90,
+    (byte) 0x41, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+    (byte) 0x14, (byte) 0x52, (byte) 0x48, (byte) 0x29,
+    (byte) 0xa6, (byte) 0x98, (byte) 0x72, (byte) 0xcc,
+    (byte) 0x31, (byte) 0xc7, (byte) 0x1c, (byte) 0x03,
+    (byte) 0x42, (byte) 0x43, (byte) 0x56, (byte) 0x01,
+    (byte) 0x00, (byte) 0x80, (byte) 0x00, (byte) 0x00,
+    (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x1c, (byte) 0x45, (byte) 0x52, (byte) 0x24,
+    (byte) 0x47, (byte) 0x72, (byte) 0x24, (byte) 0x47,
+    (byte) 0x92, (byte) 0x24, (byte) 0xc9, (byte) 0x92,
+    (byte) 0x2c, (byte) 0x49, (byte) 0x93, (byte) 0x3c,
+    (byte) 0xcb, (byte) 0xb3, (byte) 0x3c, (byte) 0xcb,
+    (byte) 0xb3, (byte) 0x3c, (byte) 0x4d, (byte) 0xd4,
+    (byte) 0x44, (byte) 0x4d, (byte) 0x15, (byte) 0x55,
+    (byte) 0xd5, (byte) 0x55, (byte) 0x6d, (byte) 0xd7,
+    (byte) 0xf6, (byte) 0x6d, (byte) 0x5f, (byte) 0xf6,
+    (byte) 0x6d, (byte) 0xdf, (byte) 0xd5, (byte) 0x65,
+    (byte) 0xdf, (byte) 0xf6, (byte) 0x65, (byte) 0xdb,
+    (byte) 0xd5, (byte) 0x65, (byte) 0x5d, (byte) 0x96,
+    (byte) 0x65, (byte) 0xdd, (byte) 0xb5, (byte) 0x6d,
+    (byte) 0x5d, (byte) 0xd6, (byte) 0x5d, (byte) 0x5d,
+    (byte) 0xd7, (byte) 0x75, (byte) 0x5d, (byte) 0xd7,
+    (byte) 0x75, (byte) 0x5d, (byte) 0xd7, (byte) 0x75,
+    (byte) 0x5d, (byte) 0xd7, (byte) 0x75, (byte) 0x5d,
+    (byte) 0xd7, (byte) 0x75, (byte) 0x5d, (byte) 0xd7,
+    (byte) 0x81, (byte) 0xd0, (byte) 0x90, (byte) 0x55,
+    (byte) 0x00, (byte) 0x80, (byte) 0x04, (byte) 0x00,
+    (byte) 0x80, (byte) 0x8e, (byte) 0xe4, (byte) 0x38,
+    (byte) 0x8e, (byte) 0xe4, (byte) 0x38, (byte) 0x8e,
+    (byte) 0xe4, (byte) 0x48, (byte) 0x8e, (byte) 0xa4,
+    (byte) 0x48, (byte) 0x0a, (byte) 0x10, (byte) 0x1a,
+    (byte) 0xb2, (byte) 0x0a, (byte) 0x00, (byte) 0x90,
+    (byte) 0x01, (byte) 0x00, (byte) 0x10, (byte) 0x00,
+    (byte) 0x80, (byte) 0xa3, (byte) 0x38, (byte) 0x8a,
+    (byte) 0xe3, (byte) 0x48, (byte) 0x8e, (byte) 0xe4,
+    (byte) 0x58, (byte) 0x8e, (byte) 0x25, (byte) 0x59,
+    (byte) 0x92, (byte) 0x26, (byte) 0x69, (byte) 0x96,
+    (byte) 0x67, (byte) 0x79, (byte) 0x96, (byte) 0xa7,
+    (byte) 0x79, (byte) 0x9a, (byte) 0xa8, (byte) 0x89,
+    (byte) 0x1e, (byte) 0x10, (byte) 0x1a, (byte) 0xb2,
+    (byte) 0x0a, (byte) 0x00, (byte) 0x00, (byte) 0x04,
+    (byte) 0x00, (byte) 0x10, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x80,
+    (byte) 0xa2, (byte) 0x28, (byte) 0x8a, (byte) 0xa3,
+    (byte) 0x38, (byte) 0x8e, (byte) 0x24, (byte) 0x59,
+    (byte) 0x96, (byte) 0xa6, (byte) 0x69, (byte) 0x9e,
+    (byte) 0xa7, (byte) 0x7a, (byte) 0xa2, (byte) 0x28,
+    (byte) 0x9a, (byte) 0xaa, (byte) 0xaa, (byte) 0x8a,
+    (byte) 0xa6, (byte) 0xa9, (byte) 0xaa, (byte) 0xaa,
+    (byte) 0x6a, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
+    (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x9a,
+    (byte) 0xa6, (byte) 0x69, (byte) 0x9a, (byte) 0xa6,
+    (byte) 0x69, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
+    (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x9a,
+    (byte) 0xa6, (byte) 0x69, (byte) 0x9a, (byte) 0xa6,
+    (byte) 0x69, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
+    (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x9a,
+    (byte) 0xa6, (byte) 0x69, (byte) 0x02, (byte) 0xa1,
+    (byte) 0x21, (byte) 0xab, (byte) 0x00, (byte) 0x00,
+    (byte) 0x09, (byte) 0x00, (byte) 0x00, (byte) 0x1d,
+    (byte) 0xc7, (byte) 0x71, (byte) 0x1c, (byte) 0x47,
+    (byte) 0x71, (byte) 0x1c, (byte) 0xc7, (byte) 0x71,
+    (byte) 0x24, (byte) 0x47, (byte) 0x92, (byte) 0x24,
+    (byte) 0x20, (byte) 0x34, (byte) 0x64, (byte) 0x15,
+    (byte) 0x00, (byte) 0x20, (byte) 0x03, (byte) 0x00,
+    (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x43,
+    (byte) 0x51, (byte) 0x1c, (byte) 0x45, (byte) 0x72,
+    (byte) 0x2c, (byte) 0xc7, (byte) 0x92, (byte) 0x34,
+    (byte) 0x4b, (byte) 0xb3, (byte) 0x3c, (byte) 0xcb,
+    (byte) 0xd3, (byte) 0x44, (byte) 0xcf, (byte) 0xf4,
+    (byte) 0x5c, (byte) 0x51, (byte) 0x36, (byte) 0x75,
+    (byte) 0x53, (byte) 0x57, (byte) 0x6d, (byte) 0x20,
+    (byte) 0x34, (byte) 0x64, (byte) 0x15, (byte) 0x00,
+    (byte) 0x00, (byte) 0x08, (byte) 0x00, (byte) 0x20,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0xc7, (byte) 0x73,
+    (byte) 0x3c, (byte) 0xc7, (byte) 0x73, (byte) 0x3c,
+    (byte) 0xc9, (byte) 0x93, (byte) 0x3c, (byte) 0xcb,
+    (byte) 0x73, (byte) 0x3c, (byte) 0xc7, (byte) 0x93,
+    (byte) 0x3c, (byte) 0x49, (byte) 0xd3, (byte) 0x34,
+    (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+    (byte) 0xd3, (byte) 0x34, (byte) 0x4d, (byte) 0xd3,
+    (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
+    (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+    (byte) 0xd3, (byte) 0x34, (byte) 0x4d, (byte) 0xd3,
+    (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
+    (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+    (byte) 0xd3, (byte) 0x34, (byte) 0x4d, (byte) 0xd3,
+    (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
+    (byte) 0x4d, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+    (byte) 0x03, (byte) 0x42, (byte) 0x43, (byte) 0x56,
+    (byte) 0x02, (byte) 0x00, (byte) 0x64, (byte) 0x00,
+    (byte) 0x00, (byte) 0x90, (byte) 0x02, (byte) 0xcf,
+    (byte) 0x42, (byte) 0x29, (byte) 0x2d, (byte) 0x46,
+    (byte) 0x02, (byte) 0x1c, (byte) 0x88, (byte) 0x98,
+    (byte) 0xa3, (byte) 0xd8, (byte) 0x7b, (byte) 0xef,
+    (byte) 0xbd, (byte) 0xf7, (byte) 0xde, (byte) 0x7b,
+    (byte) 0x65, (byte) 0x3c, (byte) 0x92, (byte) 0x88,
+    (byte) 0x49, (byte) 0xed, (byte) 0x31, (byte) 0xf4,
+    (byte) 0xd4, (byte) 0x31, (byte) 0x07, (byte) 0xb1,
+    (byte) 0x67, (byte) 0xc6, (byte) 0x23, (byte) 0x66,
+    (byte) 0x94, (byte) 0xa3, (byte) 0xd8, (byte) 0x29,
+    (byte) 0xcf, (byte) 0x1c, (byte) 0x42, (byte) 0x0c,
+    (byte) 0x62, (byte) 0xe8, (byte) 0x3c, (byte) 0x74,
+    (byte) 0x4a, (byte) 0x31, (byte) 0x88, (byte) 0x29,
+    (byte) 0xf5, (byte) 0x52, (byte) 0x32, (byte) 0xc6,
+    (byte) 0x20, (byte) 0xc6, (byte) 0xd8, (byte) 0x63,
+    (byte) 0x0c, (byte) 0x21, (byte) 0x94, (byte) 0x18,
+    (byte) 0x08, (byte) 0x0d, (byte) 0x59, (byte) 0x21,
+    (byte) 0x00, (byte) 0x84, (byte) 0x66, (byte) 0x00,
+    (byte) 0x18, (byte) 0x24, (byte) 0x09, (byte) 0x90,
+    (byte) 0x34, (byte) 0x0d, (byte) 0x90, (byte) 0x34,
+    (byte) 0x0d, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x24, (byte) 0x4f, (byte) 0x03, (byte) 0x34,
+    (byte) 0x51, (byte) 0x04, (byte) 0x34, (byte) 0x4f,
+    (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x49, (byte) 0xf3, (byte) 0x00, (byte) 0x4d,
+    (byte) 0xf4, (byte) 0x00, (byte) 0x4d, (byte) 0x14,
+    (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x90, (byte) 0x3c, (byte) 0x0d, (byte) 0xf0,
+    (byte) 0x44, (byte) 0x11, (byte) 0xd0, (byte) 0x44,
+    (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x34, (byte) 0x51, (byte) 0x04, (byte) 0x44,
+    (byte) 0x51, (byte) 0x05, (byte) 0x44, (byte) 0xd5,
+    (byte) 0x04, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x4d, (byte) 0x14, (byte) 0x01, (byte) 0x4f,
+    (byte) 0x15, (byte) 0x01, (byte) 0xd1, (byte) 0x54,
+    (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x90, (byte) 0x34, (byte) 0x0f, (byte) 0xd0,
+    (byte) 0x44, (byte) 0x11, (byte) 0xf0, (byte) 0x44,
+    (byte) 0x11, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x34, (byte) 0x51, (byte) 0x04, (byte) 0x44,
+    (byte) 0xd5, (byte) 0x04, (byte) 0x3c, (byte) 0x51,
+    (byte) 0x05, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x4d, (byte) 0x14, (byte) 0x01, (byte) 0xd1,
+    (byte) 0x54, (byte) 0x01, (byte) 0x51, (byte) 0x15,
+    (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x04,
+    (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x38,
+    (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x58,
+    (byte) 0x08, (byte) 0x85, (byte) 0x86, (byte) 0xac,
+    (byte) 0x08, (byte) 0x00, (byte) 0xe2, (byte) 0x04,
+    (byte) 0x00, (byte) 0x04, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+    (byte) 0x00, (byte) 0x00, (byte) 0x30, (byte) 0xe0,
+    (byte) 0x00, (byte) 0x00, (byte) 0x10, (byte) 0x60,
+    (byte) 0x42, (byte) 0x19, (byte) 0x28, (byte) 0x34,
+    (byte) 0x64, (byte) 0x45, (byte) 0x00, (byte) 0x10,
+    (byte) 0x27, (byte) 0x00, (byte) 0x60, (byte) 0x70,
+    (byte) 0x1c, (byte) 0xcb, (byte) 0x02, (byte) 0x00,
+    (byte) 0x00, (byte) 0x47, (byte) 0x92, (byte) 0x34,
+    (byte) 0x0d, (byte) 0x00, (byte) 0x00, (byte) 0x1c,
+    (byte) 0x49, (byte) 0xd2, (byte) 0x34, (byte) 0x00,
+    (byte) 0x00, (byte) 0xd0, (byte) 0x34, (byte) 0x4d,
+    (byte) 0x14, (byte) 0x01, (byte) 0x00, (byte) 0xc0,
+    (byte) 0xd2, (byte) 0x34, (byte) 0x51, (byte) 0x04,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x30,
+    (byte) 0xe0, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+    (byte) 0x60, (byte) 0x42, (byte) 0x19, (byte) 0x28,
+    (byte) 0x34, (byte) 0x64, (byte) 0x25, (byte) 0x00,
+    (byte) 0x10, (byte) 0x05, (byte) 0x00, (byte) 0x60,
+    (byte) 0x30, (byte) 0x14, (byte) 0x4d, (byte) 0x03,
+    (byte) 0x58, (byte) 0x16, (byte) 0xc0, (byte) 0xb2,
+    (byte) 0x00, (byte) 0x9a, (byte) 0x06, (byte) 0xd0,
+    (byte) 0x34, (byte) 0x80, (byte) 0xe7, (byte) 0x01,
+    (byte) 0x3c, (byte) 0x11, (byte) 0x60, (byte) 0x9a,
+    (byte) 0x00, (byte) 0x40, (byte) 0x00, (byte) 0x00,
+    (byte) 0x40, (byte) 0x81, (byte) 0x03, (byte) 0x00,
+    (byte) 0x40, (byte) 0x80, (byte) 0x0d, (byte) 0x9a,
+    (byte) 0x12, (byte) 0x8b, (byte) 0x03, (byte) 0x14,
+    (byte) 0x1a, (byte) 0xb2, (byte) 0x12, (byte) 0x00,
+    (byte) 0x88, (byte) 0x02, (byte) 0x00, (byte) 0x30,
+    (byte) 0x28, (byte) 0x8a, (byte) 0x24, (byte) 0x59,
+    (byte) 0x96, (byte) 0xe7, (byte) 0x41, (byte) 0xd3,
+    (byte) 0x34, (byte) 0x4d, (byte) 0x14, (byte) 0xa1,
+    (byte) 0x69, (byte) 0x9a, (byte) 0x26, (byte) 0x8a,
+    (byte) 0xf0, (byte) 0x3c, (byte) 0xcf, (byte) 0x13,
+    (byte) 0x45, (byte) 0x78, (byte) 0x9e, (byte) 0xe7,
+    (byte) 0x99, (byte) 0x26, (byte) 0x44, (byte) 0xd1,
+    (byte) 0xf3, (byte) 0x4c, (byte) 0x13, (byte) 0xa2,
+    (byte) 0xe8, (byte) 0x79, (byte) 0xa6, (byte) 0x09,
+    (byte) 0xd3, (byte) 0x14, (byte) 0x45, (byte) 0xd3,
+    (byte) 0x04, (byte) 0xa2, (byte) 0x68, (byte) 0x9a,
+    (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x0a,
+    (byte) 0x1c, (byte) 0x00, (byte) 0x00, (byte) 0x02,
+    (byte) 0x6c, (byte) 0xd0, (byte) 0x94, (byte) 0x58,
+    (byte) 0x1c, (byte) 0xa0, (byte) 0xd0, (byte) 0x90,
+    (byte) 0x95, (byte) 0x00, (byte) 0x40, (byte) 0x48,
+    (byte) 0x00, (byte) 0x80, (byte) 0x41, (byte) 0x51,
+    (byte) 0x2c, (byte) 0xcb, (byte) 0xf3, (byte) 0x44,
+    (byte) 0x51, (byte) 0x14, (byte) 0x4d, (byte) 0x53,
+    (byte) 0x55, (byte) 0x5d, (byte) 0x17, (byte) 0x9a,
+    (byte) 0xe6, (byte) 0x79, (byte) 0xa2, (byte) 0x28,
+    (byte) 0x8a, (byte) 0xa6, (byte) 0xa9, (byte) 0xaa,
+    (byte) 0xae, (byte) 0x0b, (byte) 0x4d, (byte) 0xf3,
+    (byte) 0x3c, (byte) 0x51, (byte) 0x14, (byte) 0x45,
+    (byte) 0xd3, (byte) 0x54, (byte) 0x55, (byte) 0xd7,
+    (byte) 0x85, (byte) 0xe7, (byte) 0x79, (byte) 0xa2,
+    (byte) 0x29, (byte) 0x9a, (byte) 0xa6, (byte) 0x69,
+    (byte) 0xaa, (byte) 0xaa, (byte) 0xeb, (byte) 0xc2,
+    (byte) 0xf3, (byte) 0x44, (byte) 0xd1, (byte) 0x34,
+    (byte) 0x4d, (byte) 0x53, (byte) 0x55, (byte) 0x55,
+    (byte) 0xd7, (byte) 0x75, (byte) 0xe1, (byte) 0x79,
+    (byte) 0xa2, (byte) 0x68, (byte) 0x9a, (byte) 0xa6,
+    (byte) 0xa9, (byte) 0xaa, (byte) 0xae, (byte) 0xeb,
+    (byte) 0xba, (byte) 0xf0, (byte) 0x3c, (byte) 0x51,
+    (byte) 0x34, (byte) 0x4d, (byte) 0xd3, (byte) 0x54,
+    (byte) 0x55, (byte) 0xd7, (byte) 0x95, (byte) 0x65,
+    (byte) 0x88, (byte) 0xa2, (byte) 0x28, (byte) 0x9a,
+    (byte) 0xa6, (byte) 0x69, (byte) 0xaa, (byte) 0xaa,
+    (byte) 0xeb, (byte) 0xca, (byte) 0x32, (byte) 0x10,
+    (byte) 0x45, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+    (byte) 0x55, (byte) 0x75, (byte) 0x5d, (byte) 0x59,
+    (byte) 0x06, (byte) 0xa2, (byte) 0x68, (byte) 0x9a,
+    (byte) 0xaa, (byte) 0xea, (byte) 0xba, (byte) 0xae,
+    (byte) 0x2b, (byte) 0xcb, (byte) 0x40, (byte) 0x14,
+    (byte) 0x4d, (byte) 0x53, (byte) 0x55, (byte) 0x5d,
+    (byte) 0xd7, (byte) 0x75, (byte) 0x65, (byte) 0x19,
+    (byte) 0x98, (byte) 0xa6, (byte) 0x6a, (byte) 0xaa,
+    (byte) 0xaa, (byte) 0xeb, (byte) 0xca, (byte) 0xb2,
+    (byte) 0x2c, (byte) 0x03, (byte) 0x4c, (byte) 0x53,
+    (byte) 0x55, (byte) 0x5d, (byte) 0x57, (byte) 0x96,
+    (byte) 0x65, (byte) 0x19, (byte) 0xa0, (byte) 0xaa,
+    (byte) 0xae, (byte) 0xeb, (byte) 0xba, (byte) 0xb2,
+    (byte) 0x6c, (byte) 0xdb, (byte) 0x00, (byte) 0x55,
+    (byte) 0x75, (byte) 0x5d, (byte) 0xd7, (byte) 0x95,
+    (byte) 0x65, (byte) 0xdb, (byte) 0x06, (byte) 0xb8,
+    (byte) 0xae, (byte) 0xeb, (byte) 0xca, (byte) 0xb2,
+    (byte) 0x2c, (byte) 0xdb, (byte) 0x36, (byte) 0x00,
+    (byte) 0xd7, (byte) 0x95, (byte) 0x65, (byte) 0x59,
+    (byte) 0xb6, (byte) 0x6d, (byte) 0x01, (byte) 0x00,
+    (byte) 0x00, (byte) 0x07, (byte) 0x0e, (byte) 0x00,
+    (byte) 0x00, (byte) 0x01, (byte) 0x46, (byte) 0xd0,
+    (byte) 0x49, (byte) 0x46, (byte) 0x95, (byte) 0x45,
+    (byte) 0xd8, (byte) 0x68, (byte) 0xc2, (byte) 0x85,
+    (byte) 0x07, (byte) 0xa0, (byte) 0xd0, (byte) 0x90,
+    (byte) 0x15, (byte) 0x01, (byte) 0x40, (byte) 0x14,
+    (byte) 0x00, (byte) 0x00, (byte) 0x60, (byte) 0x8c,
+    (byte) 0x52, (byte) 0x8a, (byte) 0x29, (byte) 0x65,
+    (byte) 0x18, (byte) 0x93, (byte) 0x50, (byte) 0x4a,
+    (byte) 0x09, (byte) 0x0d, (byte) 0x63, (byte) 0x52,
+    (byte) 0x4a, (byte) 0x2a, (byte) 0xa5, (byte) 0x92,
+    (byte) 0x92, (byte) 0x52, (byte) 0x4a, (byte) 0xa5,
+    (byte) 0x54, (byte) 0x12, (byte) 0x52, (byte) 0x4a,
+    (byte) 0xa9, (byte) 0x94, (byte) 0x4a, (byte) 0x4a,
+    (byte) 0x4a, (byte) 0x29, (byte) 0x95, (byte) 0x92,
+    (byte) 0x51, (byte) 0x4a, (byte) 0x29, (byte) 0xb5,
+    (byte) 0x96, (byte) 0x2a, (byte) 0x29, (byte) 0xa9,
+    (byte) 0x94, (byte) 0x94, (byte) 0x52, (byte) 0x25,
+    (byte) 0xa5, (byte) 0xa4, (byte) 0x92, (byte) 0x52,
+    (byte) 0x2a, (byte) 0x00, (byte) 0x00, (byte) 0xec,
+    (byte) 0xc0, (byte) 0x01, (byte) 0x00, (byte) 0xec,
+    (byte) 0xc0, (byte) 0x42, (byte) 0x28, (byte) 0x34,
+    (byte) 0x64, (byte) 0x25, (byte) 0x00, (byte) 0x90,
+    (byte) 0x07, (byte) 0x00, (byte) 0x40, (byte) 0x10,
+    (byte) 0x82, (byte) 0x14, (byte) 0x63, (byte) 0x8c,
+    (byte) 0x39, (byte) 0x27, (byte) 0xa5, (byte) 0x54,
+    (byte) 0x8a, (byte) 0x31, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x93, (byte) 0x52, (byte) 0x2a, (byte) 0xc5,
+    (byte) 0x98, (byte) 0x73, (byte) 0xce, (byte) 0x49,
+    (byte) 0x29, (byte) 0x19, (byte) 0x63, (byte) 0xcc,
+    (byte) 0x39, (byte) 0xe7, (byte) 0xa4, (byte) 0x94,
+    (byte) 0x8c, (byte) 0x31, (byte) 0xe6, (byte) 0x9c,
+    (byte) 0x73, (byte) 0x52, (byte) 0x4a, (byte) 0xc6,
+    (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+    (byte) 0x29, (byte) 0x25, (byte) 0x63, (byte) 0xce,
+    (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x94,
+    (byte) 0xd2, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x83, (byte) 0x50, (byte) 0x4a, (byte) 0x29,
+    (byte) 0xa5, (byte) 0x73, (byte) 0xce, (byte) 0x41,
+    (byte) 0x28, (byte) 0xa5, (byte) 0x94, (byte) 0x12,
+    (byte) 0x42, (byte) 0xe7, (byte) 0x20, (byte) 0x94,
+    (byte) 0x52, (byte) 0x4a, (byte) 0xe9, (byte) 0x9c,
+    (byte) 0x73, (byte) 0x10, (byte) 0x0a, (byte) 0x00,
+    (byte) 0x00, (byte) 0x2a, (byte) 0x70, (byte) 0x00,
+    (byte) 0x00, (byte) 0x08, (byte) 0xb0, (byte) 0x51,
+    (byte) 0x64, (byte) 0x73, (byte) 0x82, (byte) 0x91,
+    (byte) 0xa0, (byte) 0x42, (byte) 0x43, (byte) 0x56,
+    (byte) 0x02, (byte) 0x00, (byte) 0xa9, (byte) 0x00,
+    (byte) 0x00, (byte) 0x06, (byte) 0xc7, (byte) 0xb1,
+    (byte) 0x2c, (byte) 0x4d, (byte) 0xd3, (byte) 0x34,
+    (byte) 0xcf, (byte) 0x13, (byte) 0x45, (byte) 0x4b,
+    (byte) 0x92, (byte) 0x34, (byte) 0xcf, (byte) 0x13,
+    (byte) 0x3d, (byte) 0x4f, (byte) 0x14, (byte) 0x4d,
+    (byte) 0xd5, (byte) 0x92, (byte) 0x24, (byte) 0xcf,
+    (byte) 0x13, (byte) 0x45, (byte) 0xcf, (byte) 0x13,
+    (byte) 0x4d, (byte) 0x53, (byte) 0xe5, (byte) 0x79,
+    (byte) 0x9e, (byte) 0x28, (byte) 0x8a, (byte) 0xa2,
+    (byte) 0x68, (byte) 0x9a, (byte) 0xaa, (byte) 0x4a,
+    (byte) 0x14, (byte) 0x45, (byte) 0x4f, (byte) 0x14,
+    (byte) 0x45, (byte) 0xd1, (byte) 0x34, (byte) 0x55,
+    (byte) 0x95, (byte) 0x2c, (byte) 0x8b, (byte) 0xa2,
+    (byte) 0x69, (byte) 0x9a, (byte) 0xa6, (byte) 0xaa,
+    (byte) 0xba, (byte) 0x2e, (byte) 0x5b, (byte) 0x16,
+    (byte) 0x45, (byte) 0xd3, (byte) 0x34, (byte) 0x4d,
+    (byte) 0x55, (byte) 0x75, (byte) 0x5d, (byte) 0x98,
+    (byte) 0xa6, (byte) 0x28, (byte) 0xaa, (byte) 0xaa,
+    (byte) 0xeb, (byte) 0xca, (byte) 0x2e, (byte) 0x4c,
+    (byte) 0x53, (byte) 0x14, (byte) 0x4d, (byte) 0xd3,
+    (byte) 0x75, (byte) 0x65, (byte) 0x19, (byte) 0xb2,
+    (byte) 0xad, (byte) 0x9a, (byte) 0xaa, (byte) 0xea,
+    (byte) 0xba, (byte) 0xb2, (byte) 0x0d, (byte) 0xdb,
+    (byte) 0x36, (byte) 0x4d, (byte) 0x55, (byte) 0x75,
+    (byte) 0x5d, (byte) 0x59, (byte) 0x06, (byte) 0xae,
+    (byte) 0xeb, (byte) 0xba, (byte) 0xb2, (byte) 0x6c,
+    (byte) 0xeb, (byte) 0xc0, (byte) 0x75, (byte) 0x5d,
+    (byte) 0x57, (byte) 0x96, (byte) 0x6d, (byte) 0x5d,
+    (byte) 0x00, (byte) 0x00, (byte) 0x78, (byte) 0x82,
+    (byte) 0x03, (byte) 0x00, (byte) 0x50, (byte) 0x81,
+    (byte) 0x0d, (byte) 0xab, (byte) 0x23, (byte) 0x9c,
+    (byte) 0x14, (byte) 0x8d, (byte) 0x05, (byte) 0x16,
+    (byte) 0x1a, (byte) 0xb2, (byte) 0x12, (byte) 0x00,
+    (byte) 0xc8, (byte) 0x00, (byte) 0x00, (byte) 0x20,
+    (byte) 0x08, (byte) 0x41, (byte) 0x48, (byte) 0x29,
+    (byte) 0x85, (byte) 0x90, (byte) 0x52, (byte) 0x0a,
+    (byte) 0x21, (byte) 0xa5, (byte) 0x14, (byte) 0x42,
+    (byte) 0x4a, (byte) 0x29, (byte) 0x84, (byte) 0x04,
+    (byte) 0x00, (byte) 0x00, (byte) 0x0c, (byte) 0x38,
+    (byte) 0x00, (byte) 0x00, (byte) 0x04, (byte) 0x98,
+    (byte) 0x50, (byte) 0x06, (byte) 0x0a, (byte) 0x0d,
+    (byte) 0x59, (byte) 0x09, (byte) 0x00, (byte) 0xa4,
+    (byte) 0x02, (byte) 0x00, (byte) 0x00, (byte) 0x10,
+    (byte) 0x42, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+    (byte) 0x10, (byte) 0x42, (byte) 0x08, (byte) 0x21,
+    (byte) 0x84, (byte) 0x10, (byte) 0x42, (byte) 0x08,
+    (byte) 0x21, (byte) 0x84, (byte) 0x10, (byte) 0x42,
+    (byte) 0x08, (byte) 0x21, (byte) 0x84, (byte) 0x10,
+    (byte) 0x42, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+    (byte) 0x10, (byte) 0x42, (byte) 0x08, (byte) 0x21,
+    (byte) 0x84, (byte) 0x10, (byte) 0x42, (byte) 0x08,
+    (byte) 0x21, (byte) 0x84, (byte) 0x10, (byte) 0x42,
+    (byte) 0x08, (byte) 0x21, (byte) 0x84, (byte) 0x10,
+    (byte) 0x42, (byte) 0x08, (byte) 0x21, (byte) 0x84,
+    (byte) 0x10, (byte) 0x42, (byte) 0x08, (byte) 0x21,
+    (byte) 0x84, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
+    (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
+    (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
+    (byte) 0xce, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
+    (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
+    (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
+    (byte) 0xce, (byte) 0x39, (byte) 0xe7, (byte) 0x9c,
+    (byte) 0x73, (byte) 0xce, (byte) 0x39, (byte) 0xe7,
+    (byte) 0x9c, (byte) 0x73, (byte) 0xce, (byte) 0x39,
+    (byte) 0xe7, (byte) 0x9c, (byte) 0x73, (byte) 0xce,
+    (byte) 0x39, (byte) 0xe7, (byte) 0x9c, (byte) 0x73,
+    (byte) 0x02, (byte) 0x00, (byte) 0xb1, (byte) 0x2b,
+    (byte) 0x1c, (byte) 0x00, (byte) 0x76, (byte) 0x22,
+    (byte) 0x6c, (byte) 0x58, (byte) 0x1d, (byte) 0xe1,
+    (byte) 0xa4, (byte) 0x68, (byte) 0x2c, (byte) 0xb0,
+    (byte) 0xd0, (byte) 0x90, (byte) 0x95, (byte) 0x00,
+    (byte) 0x40, (byte) 0x38, (byte) 0x00, (byte) 0x00,
+    (byte) 0x60, (byte) 0x8c, (byte) 0x31, (byte) 0xce,
+    (byte) 0x59, (byte) 0xac, (byte) 0xb5, (byte) 0xd6,
+    (byte) 0x5a, (byte) 0x2b, (byte) 0xa5, (byte) 0x94,
+    (byte) 0x92, (byte) 0x50, (byte) 0x6b, (byte) 0xad,
+    (byte) 0xb5, (byte) 0xd6, (byte) 0x9a, (byte) 0x29,
+    (byte) 0xa4, (byte) 0x94, (byte) 0x84, (byte) 0x16,
+    (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+    (byte) 0x98, (byte) 0x31, (byte) 0x08, (byte) 0x29,
+    (byte) 0xb5, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+    (byte) 0x31, (byte) 0xc6, (byte) 0x8c, (byte) 0x39,
+    (byte) 0x47, (byte) 0x2d, (byte) 0xc6, (byte) 0x18,
+    (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xb6,
+    (byte) 0x56, (byte) 0x4a, (byte) 0x6c, (byte) 0x31,
+    (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+    (byte) 0xb1, (byte) 0xb5, (byte) 0x52, (byte) 0x62,
+    (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+    (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+    (byte) 0x16, (byte) 0x5b, (byte) 0x8c, (byte) 0x31,
+    (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+    (byte) 0x31, (byte) 0xb6, (byte) 0x18, (byte) 0x63,
+    (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+    (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+    (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
+    (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+    (byte) 0x31, (byte) 0xb6, (byte) 0x18, (byte) 0x63,
+    (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+    (byte) 0x63, (byte) 0x8c, (byte) 0x31, (byte) 0xc6,
+    (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
+    (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+    (byte) 0x31, (byte) 0xc6, (byte) 0x18, (byte) 0x63,
+    (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x18,
+    (byte) 0x63, (byte) 0x6c, (byte) 0x31, (byte) 0xc6,
+    (byte) 0x18, (byte) 0x63, (byte) 0x8c, (byte) 0x31,
+    (byte) 0xc6, (byte) 0x18, (byte) 0x63, (byte) 0x8c,
+    (byte) 0x31, (byte) 0xc6, (byte) 0x18, (byte) 0x63,
+    (byte) 0x2c, (byte) 0x00, (byte) 0xc0, (byte) 0xe4,
+    (byte) 0xc1, (byte) 0x01, (byte) 0x00, (byte) 0x2a,
+    (byte) 0xc1, (byte) 0xc6, (byte) 0x19, (byte) 0x56,
+    (byte) 0x92, (byte) 0xce, (byte) 0x0a, (byte) 0x47,
+    (byte) 0x83, (byte) 0x0b, (byte) 0x0d, (byte) 0x59,
+    (byte) 0x09, (byte) 0x00, (byte) 0xe4, (byte) 0x06,
+    (byte) 0x00, (byte) 0x00, (byte) 0xc6, (byte) 0x28,
+    (byte) 0xc5, (byte) 0x98, (byte) 0x63, (byte) 0xce,
+    (byte) 0x41, (byte) 0x08, (byte) 0xa1, (byte) 0x94,
+    (byte) 0x12, (byte) 0x4a, (byte) 0x49, (byte) 0xad,
+    (byte) 0x75, (byte) 0xce, (byte) 0x39, (byte) 0x08,
+    (byte) 0x21, (byte) 0x94, (byte) 0x52, (byte) 0x4a,
+    (byte) 0x49, (byte) 0xa9, (byte) 0xb4, (byte) 0x94,
+    (byte) 0x62, (byte) 0xca, (byte) 0x98, (byte) 0x73,
+    (byte) 0xce, (byte) 0x41, (byte) 0x08, (byte) 0xa5,
+    (byte) 0x94, (byte) 0x12, (byte) 0x4a, (byte) 0x49,
+    (byte) 0xa9, (byte) 0xa5, (byte) 0xd4, (byte) 0x39,
+    (byte) 0xe7, (byte) 0x20, (byte) 0x94, (byte) 0x52,
+    (byte) 0x4a, (byte) 0x4a, (byte) 0x29, (byte) 0xa5,
+    (byte) 0x94, (byte) 0x5a, (byte) 0x6a, (byte) 0xad,
+    (byte) 0x73, (byte) 0x10, (byte) 0x42, (byte) 0x08,
+    (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x4a,
+    (byte) 0x4a, (byte) 0x29, (byte) 0xa5, (byte) 0xd4,
+    (byte) 0x52, (byte) 0x08, (byte) 0x21, (byte) 0x94,
+    (byte) 0x52, (byte) 0x4a, (byte) 0x2a, (byte) 0x29,
+    (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x6b,
+    (byte) 0xad, (byte) 0xa5, (byte) 0x10, (byte) 0x42,
+    (byte) 0x28, (byte) 0xa5, (byte) 0x94, (byte) 0x94,
+    (byte) 0x52, (byte) 0x4a, (byte) 0x29, (byte) 0xa5,
+    (byte) 0xd4, (byte) 0x5a, (byte) 0x8b, (byte) 0xa1,
+    (byte) 0x94, (byte) 0x90, (byte) 0x4a, (byte) 0x29,
+    (byte) 0x25, (byte) 0xa5, (byte) 0x94, (byte) 0x52,
+    (byte) 0x49, (byte) 0x2d, (byte) 0xb5, (byte) 0x96,
+    (byte) 0x5a, (byte) 0x2a, (byte) 0xa1, (byte) 0x94,
+    (byte) 0x54, (byte) 0x52, (byte) 0x4a, (byte) 0x29,
+    (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x6b,
+    (byte) 0xa9, (byte) 0xb5, (byte) 0x56, (byte) 0x4a,
+    (byte) 0x49, (byte) 0x25, (byte) 0xa5, (byte) 0x94,
+    (byte) 0x52, (byte) 0x4a, (byte) 0x29, (byte) 0xa5,
+    (byte) 0xd4, (byte) 0x62, (byte) 0x6b, (byte) 0x29,
+    (byte) 0x94, (byte) 0x92, (byte) 0x52, (byte) 0x49,
+    (byte) 0x29, (byte) 0xb5, (byte) 0x94, (byte) 0x52,
+    (byte) 0x4a, (byte) 0xad, (byte) 0xc5, (byte) 0xd8,
+    (byte) 0x62, (byte) 0x29, (byte) 0xad, (byte) 0xa4,
+    (byte) 0x94, (byte) 0x52, (byte) 0x4a, (byte) 0x29,
+    (byte) 0xa5, (byte) 0xd6, (byte) 0x52, (byte) 0x6c,
+    (byte) 0xad, (byte) 0xb5, (byte) 0xd8, (byte) 0x52,
+    (byte) 0x4a, (byte) 0x29, (byte) 0xa5, (byte) 0x96,
+    (byte) 0x5a, (byte) 0x4a, (byte) 0x29, (byte) 0xb5,
+    (byte) 0x16, (byte) 0x5b, (byte) 0x6a, (byte) 0x2d,
+    (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x4b,
+    (byte) 0x29, (byte) 0xa5, (byte) 0x96, (byte) 0x52,
+    (byte) 0x4b, (byte) 0x2d, (byte) 0xc6, (byte) 0xd6,
+    (byte) 0x5a, (byte) 0x4b, (byte) 0x29, (byte) 0xa5,
+    (byte) 0xd4, (byte) 0x52, (byte) 0x6a, (byte) 0xa9,
+    (byte) 0xa5, (byte) 0x94, (byte) 0x52, (byte) 0x6c,
+    (byte) 0xad, (byte) 0xb5, (byte) 0x98, (byte) 0x52,
+    (byte) 0x6a, (byte) 0x2d, (byte) 0xa5, (byte) 0xd4,
+    (byte) 0x52, (byte) 0x6b, (byte) 0x2d, (byte) 0xb5,
+    (byte) 0xd8, (byte) 0x52, (byte) 0x6a, (byte) 0x2d,
+    (byte) 0xb5, (byte) 0x94, (byte) 0x52, (byte) 0x6b,
+    (byte) 0xa9, (byte) 0xa5, (byte) 0x94, (byte) 0x5a,
+    (byte) 0x6b, (byte) 0x2d, (byte) 0xb6, (byte) 0xd8,
+    (byte) 0x5a, (byte) 0x6b, (byte) 0x29, (byte) 0xb5,
+    (byte) 0x94, (byte) 0x52, (byte) 0x4a, (byte) 0xa9,
+    (byte) 0xb5, (byte) 0x16, (byte) 0x5b, (byte) 0x8a,
+    (byte) 0xb1, (byte) 0xb5, (byte) 0xd4, (byte) 0x4a,
+    (byte) 0x4a, (byte) 0x29, (byte) 0xb5, (byte) 0xd4,
+    (byte) 0x5a, (byte) 0x6a, (byte) 0x2d, (byte) 0xb6,
+    (byte) 0x16, (byte) 0x5b, (byte) 0x6b, (byte) 0xad,
+    (byte) 0xa5, (byte) 0xd6, (byte) 0x5a, (byte) 0x6a,
+    (byte) 0x29, (byte) 0xa5, (byte) 0x16, (byte) 0x5b,
+    (byte) 0x8c, (byte) 0x31, (byte) 0xc6, (byte) 0x16,
+    (byte) 0x63, (byte) 0x6b, (byte) 0x31, (byte) 0xa5,
+    (byte) 0x94, (byte) 0x52, (byte) 0x4b, (byte) 0xa9,
+    (byte) 0xa5, (byte) 0x02, (byte) 0x00, (byte) 0x80,
+    (byte) 0x0e, (byte) 0x1c, (byte) 0x00, (byte) 0x00,
+    (byte) 0x02, (byte) 0x8c, (byte) 0xa8, (byte) 0xb4,
+    (byte) 0x10, (byte) 0x3b, (byte) 0xcd, (byte) 0xb8,
+    (byte) 0xf2, (byte) 0x08, (byte) 0x1c, (byte) 0x51,
+    (byte) 0xc8, (byte) 0x30, (byte) 0x01, (byte) 0x15,
+    (byte) 0x1a, (byte) 0xb2, (byte) 0x12, (byte) 0x00,
+    (byte) 0x20, (byte) 0x03, (byte) 0x00, (byte) 0x20,
+    (byte) 0x90, (byte) 0x69, (byte) 0x92, (byte) 0x39,
+    (byte) 0x49, (byte) 0xa9, (byte) 0x11, (byte) 0x26,
+    (byte) 0x39, (byte) 0xc5, (byte) 0xa0, (byte) 0x94,
+    (byte) 0xe6, (byte) 0x9c, (byte) 0x53, (byte) 0x4a,
+    (byte) 0x29, (byte) 0xa5, (byte) 0x34, (byte) 0x44,
+    (byte) 0x96, (byte) 0x64, (byte) 0x90, (byte) 0x62,
+    (byte) 0x50, (byte) 0x1d, (byte) 0x99, (byte) 0x8c,
+    (byte) 0x39, (byte) 0x49, (byte) 0x39, (byte) 0x43,
+    (byte) 0xa4, (byte) 0x31, (byte) 0xa4, (byte) 0x20,
+    (byte) 0xf5, (byte) 0x4c, (byte) 0x91, (byte) 0xc7,
+    (byte) 0x94, (byte) 0x62, (byte) 0x10, (byte) 0x43,
+    (byte) 0x48, (byte) 0x2a, (byte) 0x74, (byte) 0x8a,
+    (byte) 0x39, (byte) 0x6c, (byte) 0x35, (byte) 0xf9,
+    (byte) 0x58, (byte) 0x42, (byte) 0x07, (byte) 0xb1,
+    (byte) 0x06, (byte) 0x65, (byte) 0x8c, (byte) 0x70,
+    (byte) 0x29, (byte) 0xc5, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x08, (byte) 0x02, (byte) 0x00,
+    (byte) 0x04, (byte) 0x84, (byte) 0x04, (byte) 0x00,
+    (byte) 0x18, (byte) 0x20, (byte) 0x28, (byte) 0x98,
+    (byte) 0x01, (byte) 0x00, (byte) 0x06, (byte) 0x07,
+    (byte) 0x08, (byte) 0x23, (byte) 0x07, (byte) 0x02,
+    (byte) 0x1d, (byte) 0x01, (byte) 0x04, (byte) 0x0e,
+    (byte) 0x6d, (byte) 0x00, (byte) 0x80, (byte) 0x81,
+    (byte) 0x08, (byte) 0x99, (byte) 0x09, (byte) 0x0c,
+    (byte) 0x0a, (byte) 0xa1, (byte) 0xc1, (byte) 0x41,
+    (byte) 0x26, (byte) 0x00, (byte) 0x3c, (byte) 0x40,
+    (byte) 0x44, (byte) 0x48, (byte) 0x05, (byte) 0x00,
+    (byte) 0x89, (byte) 0x09, (byte) 0x8a, (byte) 0xd2,
+    (byte) 0x85, (byte) 0x2e, (byte) 0x08, (byte) 0x21,
+    (byte) 0x82, (byte) 0x74, (byte) 0x11, (byte) 0x64,
+    (byte) 0xf1, (byte) 0xc0, (byte) 0x85, (byte) 0x13,
+    (byte) 0x37, (byte) 0x9e, (byte) 0xb8, (byte) 0xe1,
+    (byte) 0x84, (byte) 0x0e, (byte) 0x6d, (byte) 0x20,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x20, (byte) 0x00, (byte) 0xf0,
+    (byte) 0x01, (byte) 0x00, (byte) 0x90, (byte) 0x50,
+    (byte) 0x00, (byte) 0x11, (byte) 0x11, (byte) 0xd1,
+    (byte) 0xcc, (byte) 0x55, (byte) 0x58, (byte) 0x5c,
+    (byte) 0x60, (byte) 0x64, (byte) 0x68, (byte) 0x6c,
+    (byte) 0x70, (byte) 0x74, (byte) 0x78, (byte) 0x7c,
+    (byte) 0x80, (byte) 0x84, (byte) 0x08, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x10, (byte) 0x00, (byte) 0x7c, (byte) 0x00,
+    (byte) 0x00, (byte) 0x24, (byte) 0x22, (byte) 0x40,
+    (byte) 0x44, (byte) 0x44, (byte) 0x34, (byte) 0x73,
+    (byte) 0x15, (byte) 0x16, (byte) 0x17, (byte) 0x18,
+    (byte) 0x19, (byte) 0x1a, (byte) 0x1b, (byte) 0x1c,
+    (byte) 0x1d, (byte) 0x1e, (byte) 0x1f, (byte) 0x20,
+    (byte) 0x21, (byte) 0x01, (byte) 0x00, (byte) 0x80,
+    (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x00, (byte) 0x20, (byte) 0x80,
+    (byte) 0x00, (byte) 0x04, (byte) 0x04, (byte) 0x04,
+    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x00,
+    (byte) 0x00, (byte) 0x04, (byte) 0x04
+  };
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
new file mode 100644
index 0000000000..e606fd104b
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/RobolectricUtil.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static org.robolectric.Shadows.shadowOf;
+import static org.robolectric.util.ReflectionHelpers.callInstanceMethod;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.MessageQueue;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import com.google.android.exoplayer2.util.Util;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.PriorityBlockingQueue;
+import java.util.concurrent.atomic.AtomicLong;
+import org.robolectric.annotation.Implementation;
+import org.robolectric.annotation.Implements;
+import org.robolectric.shadows.ShadowLooper;
+import org.robolectric.shadows.ShadowMessageQueue;
+
+/** Collection of shadow classes used to run tests with Robolectric which require Loopers. */
+public final class RobolectricUtil {
+
+  private static final AtomicLong sequenceNumberGenerator = new AtomicLong(0);
+
+  private RobolectricUtil() {}
+
+  /**
+   * A custom implementation of Robolectric's ShadowLooper which runs all scheduled messages in the
+   * loop method of the looper. Also ensures to correctly emulate the message order of the real
+   * message loop and to avoid blocking caused by Robolectric's default implementation.
+   *
+   * <p>Only works in conjunction with {@link CustomMessageQueue}. Note that the test's {@code
+   * SystemClock} is not advanced automatically.
+   */
+  @Implements(Looper.class)
+  public static final class CustomLooper extends ShadowLooper {
+
+    private final PriorityBlockingQueue<PendingMessage> pendingMessages;
+    private final CopyOnWriteArraySet<RemovedMessage> removedMessages;
+
+    public CustomLooper() {
+      pendingMessages = new PriorityBlockingQueue<>();
+      removedMessages = new CopyOnWriteArraySet<>();
+    }
+
+    @Implementation
+    public static void loop() {
+      ShadowLooper looper = shadowOf(Looper.myLooper());
+      if (looper instanceof CustomLooper) {
+        ((CustomLooper) looper).doLoop();
+      }
+    }
+
+    @Implementation
+    @Override
+    public void quitUnchecked() {
+      super.quitUnchecked();
+      // Insert message at the front of the queue to quit loop as soon as possible.
+      addPendingMessage(/* message= */ null, /* when= */ Long.MIN_VALUE);
+    }
+
+    private void addPendingMessage(@Nullable Message message, long when) {
+      pendingMessages.put(new PendingMessage(message, when));
+    }
+
+    private void removeMessages(Handler handler, int what, Object object) {
+      RemovedMessage newRemovedMessage = new RemovedMessage(handler, what, object);
+      removedMessages.add(newRemovedMessage);
+      for (RemovedMessage removedMessage : removedMessages) {
+        if (removedMessage != newRemovedMessage
+            && removedMessage.handler == handler
+            && removedMessage.what == what
+            && removedMessage.object == object) {
+          removedMessages.remove(removedMessage);
+        }
+      }
+    }
+
+    private void doLoop() {
+      try {
+        while (true) {
+          PendingMessage pendingMessage = pendingMessages.take();
+          if (pendingMessage.message == null) {
+            // Null message is signal to end message loop.
+            return;
+          }
+          // Call through to real {@code Message.markInUse()} and {@code Message.recycle()} to
+          // ensure message recycling works. This is also done in Robolectric's own implementation
+          // of the message queue.
+          callInstanceMethod(pendingMessage.message, "markInUse");
+          Handler target = pendingMessage.message.getTarget();
+          if (target != null) {
+            boolean isRemoved = false;
+            for (RemovedMessage removedMessage : removedMessages) {
+              if (removedMessage.handler == target
+                  && removedMessage.what == pendingMessage.message.what
+                  && (removedMessage.object == null
+                      || removedMessage.object == pendingMessage.message.obj)
+                  && pendingMessage.sequenceNumber < removedMessage.sequenceNumber) {
+                isRemoved = true;
+              }
+            }
+            if (!isRemoved) {
+              try {
+                target.dispatchMessage(pendingMessage.message);
+              } catch (Throwable t) {
+                // Interrupt the main thread to terminate the test. Robolectric's HandlerThread will
+                // print the rethrown error to standard output.
+                Looper.getMainLooper().getThread().interrupt();
+                throw t;
+              }
+            }
+          }
+          if (Util.SDK_INT >= 21) {
+            callInstanceMethod(pendingMessage.message, "recycleUnchecked");
+          } else {
+            callInstanceMethod(pendingMessage.message, "recycle");
+          }
+        }
+      } catch (InterruptedException e) {
+        // Ignore.
+      }
+    }
+  }
+
+  /**
+   * Custom implementation of Robolectric's ShadowMessageQueue which is needed to let {@link
+   * CustomLooper} work as intended.
+   */
+  @Implements(MessageQueue.class)
+  public static final class CustomMessageQueue extends ShadowMessageQueue {
+
+    private final Thread looperThread;
+
+    public CustomMessageQueue() {
+      looperThread = Thread.currentThread();
+    }
+
+    @Implementation
+    @Override
+    public boolean enqueueMessage(Message msg, long when) {
+      ShadowLooper looper = shadowOf(ShadowLooper.getLooperForThread(looperThread));
+      if (looper instanceof CustomLooper) {
+        ((CustomLooper) looper).addPendingMessage(msg, when);
+      }
+      return true;
+    }
+
+    @Implementation
+    public void removeMessages(Handler handler, int what, Object object) {
+      ShadowLooper looper = shadowOf(ShadowLooper.getLooperForThread(looperThread));
+      if (looper instanceof CustomLooper) {
+        ((CustomLooper) looper).removeMessages(handler, what, object);
+      }
+    }
+  }
+
+  private static final class PendingMessage implements Comparable<PendingMessage> {
+
+    public final @Nullable Message message;
+    public final long when;
+    public final long sequenceNumber;
+
+    public PendingMessage(@Nullable Message message, long when) {
+      this.message = message;
+      this.when = when;
+      sequenceNumber = sequenceNumberGenerator.getAndIncrement();
+    }
+
+    @Override
+    public int compareTo(@NonNull PendingMessage other) {
+      int res = Util.compareLong(this.when, other.when);
+      if (res == 0 && this != other) {
+        res = Util.compareLong(this.sequenceNumber, other.sequenceNumber);
+      }
+      return res;
+    }
+  }
+
+  private static final class RemovedMessage {
+
+    public final Handler handler;
+    public final int what;
+    public final Object object;
+    public final long sequenceNumber;
+
+    public RemovedMessage(Handler handler, int what, Object object) {
+      this.handler = handler;
+      this.what = what;
+      this.object = object;
+      this.sequenceNumber = sequenceNumberGenerator.get();
+    }
+  }
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
new file mode 100644
index 0000000000..af8b10e6d3
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/StubExoPlayer.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import android.os.Looper;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.PlayerMessage;
+import com.google.android.exoplayer2.SeekParameters;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+
+/**
+ * An abstract {@link ExoPlayer} implementation that throws {@link UnsupportedOperationException}
+ * from every method.
+ */
+public abstract class StubExoPlayer implements ExoPlayer {
+
+  @Override
+  public VideoComponent getVideoComponent() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public TextComponent getTextComponent() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Looper getPlaybackLooper() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void addListener(Player.EventListener listener) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void removeListener(Player.EventListener listener) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getPlaybackState() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void prepare(MediaSource mediaSource) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void prepare(MediaSource mediaSource, boolean resetPosition, boolean resetState) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setPlayWhenReady(boolean playWhenReady) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean getPlayWhenReady() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setRepeatMode(@RepeatMode int repeatMode) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getRepeatMode() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setShuffleModeEnabled(boolean shuffleModeEnabled) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean getShuffleModeEnabled() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean isLoading() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void seekToDefaultPosition() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void seekToDefaultPosition(int windowIndex) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void seekTo(long positionMs) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void seekTo(int windowIndex, long positionMs) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setPlaybackParameters(PlaybackParameters playbackParameters) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public PlaybackParameters getPlaybackParameters() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void setSeekParameters(SeekParameters seekParameters) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void stop() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void stop(boolean resetStateAndPosition) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void release() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public PlayerMessage createMessage(PlayerMessage.Target target) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void sendMessages(ExoPlayerMessage... messages) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void blockingSendMessages(ExoPlayerMessage... messages) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getRendererCount() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getRendererType(int index) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public TrackGroupArray getCurrentTrackGroups() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public TrackSelectionArray getCurrentTrackSelections() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Object getCurrentManifest() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Timeline getCurrentTimeline() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getCurrentPeriodIndex() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getCurrentWindowIndex() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getNextWindowIndex() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getPreviousWindowIndex() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public long getDuration() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public long getCurrentPosition() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public long getBufferedPosition() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getBufferedPercentage() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean isCurrentWindowDynamic() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean isCurrentWindowSeekable() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean isPlayingAd() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getCurrentAdGroupIndex() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int getCurrentAdIndexInAdGroup() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public long getContentPosition() {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
new file mode 100644
index 0000000000..abef8e06be
--- /dev/null
+++ b/testutils_robolectric/src/main/java/com/google/android/exoplayer2/testutil/TimelineAsserts.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer2.testutil;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Timeline.Period;
+import com.google.android.exoplayer2.Timeline.Window;
+
+/** Unit test for {@link Timeline}. */
+public final class TimelineAsserts {
+
+  private static final int[] REPEAT_MODES = {
+    Player.REPEAT_MODE_OFF, Player.REPEAT_MODE_ONE, Player.REPEAT_MODE_ALL
+  };
+
+  private TimelineAsserts() {}
+
+  /** Assert that timeline is empty (i.e. has no windows or periods). */
+  public static void assertEmpty(Timeline timeline) {
+    assertWindowIds(timeline);
+    assertPeriodCounts(timeline);
+    for (boolean shuffled : new boolean[] {false, true}) {
+      assertThat(timeline.getFirstWindowIndex(shuffled)).isEqualTo(C.INDEX_UNSET);
+      assertThat(timeline.getLastWindowIndex(shuffled)).isEqualTo(C.INDEX_UNSET);
+    }
+  }
+
+  /**
+   * Asserts that window IDs are set correctly.
+   *
+   * @param expectedWindowIds A list of expected window IDs. If an ID is unknown or not important
+   *     {@code null} can be passed to skip this window.
+   */
+  public static void assertWindowIds(Timeline timeline, Object... expectedWindowIds) {
+    Window window = new Window();
+    assertThat(timeline.getWindowCount()).isEqualTo(expectedWindowIds.length);
+    for (int i = 0; i < timeline.getWindowCount(); i++) {
+      timeline.getWindow(i, window, true);
+      if (expectedWindowIds[i] != null) {
+        assertThat(window.id).isEqualTo(expectedWindowIds[i]);
+      }
+    }
+  }
+
+  /** Asserts that window properties {@link Window}.isDynamic are set correctly. */
+  public static void assertWindowIsDynamic(Timeline timeline, boolean... windowIsDynamic) {
+    Window window = new Window();
+    for (int i = 0; i < timeline.getWindowCount(); i++) {
+      timeline.getWindow(i, window, true);
+      assertThat(window.isDynamic).isEqualTo(windowIsDynamic[i]);
+    }
+  }
+
+  /**
+   * Asserts that previous window indices for each window depending on the repeat mode and the
+   * shuffle mode are equal to the given sequence.
+   */
+  public static void assertPreviousWindowIndices(
+      Timeline timeline,
+      @Player.RepeatMode int repeatMode,
+      boolean shuffleModeEnabled,
+      int... expectedPreviousWindowIndices) {
+    for (int i = 0; i < timeline.getWindowCount(); i++) {
+      assertThat(timeline.getPreviousWindowIndex(i, repeatMode, shuffleModeEnabled))
+          .isEqualTo(expectedPreviousWindowIndices[i]);
+    }
+  }
+
+  /**
+   * Asserts that next window indices for each window depending on the repeat mode and the shuffle
+   * mode are equal to the given sequence.
+   */
+  public static void assertNextWindowIndices(
+      Timeline timeline,
+      @Player.RepeatMode int repeatMode,
+      boolean shuffleModeEnabled,
+      int... expectedNextWindowIndices) {
+    for (int i = 0; i < timeline.getWindowCount(); i++) {
+      assertThat(timeline.getNextWindowIndex(i, repeatMode, shuffleModeEnabled))
+          .isEqualTo(expectedNextWindowIndices[i]);
+    }
+  }
+
+  /**
+   * Asserts that the durations of the periods in the {@link Timeline} and the durations in the
+   * given sequence are equal.
+   */
+  public static void assertPeriodDurations(Timeline timeline, long... durationsUs) {
+    int periodCount = timeline.getPeriodCount();
+    assertThat(periodCount).isEqualTo(durationsUs.length);
+    Period period = new Period();
+    for (int i = 0; i < periodCount; i++) {
+      assertThat(timeline.getPeriod(i, period).durationUs).isEqualTo(durationsUs[i]);
+    }
+  }
+
+  /**
+   * Asserts that period counts for each window are set correctly. Also asserts that {@link
+   * Window#firstPeriodIndex} and {@link Window#lastPeriodIndex} are set correctly, and it asserts
+   * the correct behavior of {@link Timeline#getNextWindowIndex(int, int, boolean)}.
+   */
+  public static void assertPeriodCounts(Timeline timeline, int... expectedPeriodCounts) {
+    int windowCount = timeline.getWindowCount();
+    int[] accumulatedPeriodCounts = new int[windowCount + 1];
+    accumulatedPeriodCounts[0] = 0;
+    for (int i = 0; i < windowCount; i++) {
+      accumulatedPeriodCounts[i + 1] = accumulatedPeriodCounts[i] + expectedPeriodCounts[i];
+    }
+    assertThat(timeline.getPeriodCount())
+        .isEqualTo(accumulatedPeriodCounts[accumulatedPeriodCounts.length - 1]);
+    Window window = new Window();
+    Period period = new Period();
+    for (int i = 0; i < windowCount; i++) {
+      timeline.getWindow(i, window, true);
+      assertThat(window.firstPeriodIndex).isEqualTo(accumulatedPeriodCounts[i]);
+      assertThat(window.lastPeriodIndex).isEqualTo(accumulatedPeriodCounts[i + 1] - 1);
+    }
+    int expectedWindowIndex = 0;
+    for (int i = 0; i < timeline.getPeriodCount(); i++) {
+      timeline.getPeriod(i, period, true);
+      while (i >= accumulatedPeriodCounts[expectedWindowIndex + 1]) {
+        expectedWindowIndex++;
+      }
+      assertThat(period.windowIndex).isEqualTo(expectedWindowIndex);
+      assertThat(timeline.getIndexOfPeriod(period.uid)).isEqualTo(i);
+      for (int repeatMode : REPEAT_MODES) {
+        if (i < accumulatedPeriodCounts[expectedWindowIndex + 1] - 1) {
+          assertThat(timeline.getNextPeriodIndex(i, period, window, repeatMode, false))
+              .isEqualTo(i + 1);
+        } else {
+          int nextWindow = timeline.getNextWindowIndex(expectedWindowIndex, repeatMode, false);
+          int nextPeriod =
+              nextWindow == C.INDEX_UNSET ? C.INDEX_UNSET : accumulatedPeriodCounts[nextWindow];
+          assertThat(timeline.getNextPeriodIndex(i, period, window, repeatMode, false))
+              .isEqualTo(nextPeriod);
+        }
+      }
+    }
+  }
+
+  /** Asserts that periods' {@link Period#getAdGroupCount()} are set correctly. */
+  public static void assertAdGroupCounts(Timeline timeline, int... expectedAdGroupCounts) {
+    Period period = new Period();
+    for (int i = 0; i < timeline.getPeriodCount(); i++) {
+      timeline.getPeriod(i, period);
+      assertThat(period.getAdGroupCount()).isEqualTo(expectedAdGroupCounts[i]);
+    }
+  }
+}
