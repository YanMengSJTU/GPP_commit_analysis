diff --git a/RELEASENOTES.md b/RELEASENOTES.md
index 3c792b1bee..fdd8d2c5ea 100644
--- a/RELEASENOTES.md
+++ b/RELEASENOTES.md
@@ -59,7 +59,9 @@
   ([#6335](https://github.com/google/ExoPlayer/issues/6335)).
 * Add `HttpDataSource.getResponseCode` to provide the status code associated
   with the most recent HTTP response.
-* Upgrade LibRtmp-Client-for-Android to fix RTMP playback issues
+* OkHttp extension: Upgrade OkHttp to fix HTTP2 socket timeout issue
+  ([#4078](https://github.com/google/ExoPlayer/issues/4078)).
+* RTMP extension: Upgrade LibRtmp-Client-for-Android to fix RTMP playback issues
   ([#4200](https://github.com/google/ExoPlayer/issues/4200),
   [#4249](https://github.com/google/ExoPlayer/issues/4249),
   [#4319](https://github.com/google/ExoPlayer/issues/4319),
diff --git a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
index 3108476964..27a6c82c8c 100644
--- a/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
+++ b/extensions/mediasession/src/main/java/com/google/android/exoplayer2/ext/mediasession/MediaSessionConnector.java
@@ -943,7 +943,9 @@ public MediaMetadataCompat getMetadata(Player player) {
       }
       builder.putLong(
           MediaMetadataCompat.METADATA_KEY_DURATION,
-          player.getDuration() == C.TIME_UNSET ? -1 : player.getDuration());
+          player.isCurrentWindowDynamic() || player.getDuration() == C.TIME_UNSET
+              ? -1
+              : player.getDuration());
       long activeQueueItemId = mediaController.getPlaybackState().getActiveQueueItemId();
       if (activeQueueItemId != MediaSessionCompat.QueueItem.UNKNOWN_ID) {
         List<MediaSessionCompat.QueueItem> queue = mediaController.getQueue();
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
index f4e51a38a0..6c323deca4 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java
@@ -34,6 +34,7 @@
 public abstract class BaseRenderer implements Renderer, RendererCapabilities {
 
   private final int trackType;
+  private final FormatHolder formatHolder;
 
   private RendererConfiguration configuration;
   private int index;
@@ -50,6 +51,7 @@
    */
   public BaseRenderer(int trackType) {
     this.trackType = trackType;
+    formatHolder = new FormatHolder();
     readingPositionUs = C.TIME_END_OF_SOURCE;
   }
 
@@ -157,6 +159,7 @@ public final void stop() throws ExoPlaybackException {
   @Override
   public final void disable() {
     Assertions.checkState(state == STATE_ENABLED);
+    formatHolder.clear();
     state = STATE_DISABLED;
     stream = null;
     streamFormats = null;
@@ -167,6 +170,7 @@ public final void disable() {
   @Override
   public final void reset() {
     Assertions.checkState(state == STATE_DISABLED);
+    formatHolder.clear();
     onReset();
   }
 
@@ -275,6 +279,12 @@ protected void onReset() {
 
   // Methods to be called by subclasses.
 
+  /** Returns a clear {@link FormatHolder}. */
+  protected final FormatHolder getFormatHolder() {
+    formatHolder.clear();
+    return formatHolder;
+  }
+
   /** Returns the formats of the currently enabled stream. */
   protected final Format[] getStreamFormats() {
     return streamFormats;
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
index 22c4119021..901b7b4d94 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/MediaPeriodQueue.java
@@ -454,7 +454,13 @@ private long resolvePeriodIndexToWindowSequenceNumber(Object periodUid) {
       mediaPeriodHolder = mediaPeriodHolder.getNext();
     }
     // If no match is found, create new sequence number.
-    return nextWindowSequenceNumber++;
+    long windowSequenceNumber = nextWindowSequenceNumber++;
+    if (playing == null) {
+      // If the queue is empty, save it as old front uid to allow later reuse.
+      oldFrontPeriodUid = periodUid;
+      oldFrontPeriodWindowSequenceNumber = windowSequenceNumber;
+    }
+    return windowSequenceNumber;
   }
 
   /**
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
index e92f1d63db..32516e7dcd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/audio/SimpleDecoderAudioRenderer.java
@@ -94,7 +94,6 @@
   private final boolean playClearSamplesWithoutKeys;
   private final EventDispatcher eventDispatcher;
   private final AudioSink audioSink;
-  private final FormatHolder formatHolder;
   private final DecoderInputBuffer flagsOnlyBuffer;
 
   private DecoderCounters decoderCounters;
@@ -212,7 +211,6 @@ public SimpleDecoderAudioRenderer(
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
     this.audioSink = audioSink;
     audioSink.setListener(new AudioSinkListener());
-    formatHolder = new FormatHolder();
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
     decoderReinitializationState = REINITIALIZATION_STATE_NONE;
     audioTrackNeedsConfigure = true;
@@ -270,12 +268,11 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     // Try and read a format if we don't have one already.
     if (inputFormat == null) {
       // We don't have a format yet, so try and read one.
-      formatHolder.clear();
+      FormatHolder formatHolder = getFormatHolder();
       flagsOnlyBuffer.clear();
       int result = readSource(formatHolder, flagsOnlyBuffer, true);
       if (result == C.RESULT_FORMAT_READ) {
         onInputFormatChanged(formatHolder);
-        formatHolder.clear();
       } else if (result == C.RESULT_BUFFER_READ) {
         // End of stream read having not read a format.
         Assertions.checkState(flagsOnlyBuffer.isEndOfStream());
@@ -440,11 +437,11 @@ private boolean feedInputBuffer() throws AudioDecoderException, ExoPlaybackExcep
     }
 
     int result;
+    FormatHolder formatHolder = getFormatHolder();
     if (waitingForKeys) {
       // We've already read an encrypted sample into buffer, and are waiting for keys.
       result = C.RESULT_BUFFER_READ;
     } else {
-      formatHolder.clear();
       result = readSource(formatHolder, inputBuffer, false);
     }
 
@@ -453,7 +450,6 @@ private boolean feedInputBuffer() throws AudioDecoderException, ExoPlaybackExcep
     }
     if (result == C.RESULT_FORMAT_READ) {
       onInputFormatChanged(formatHolder);
-      formatHolder.clear();
       return true;
     }
     if (inputBuffer.isEndOfStream()) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
index 763405aa65..e6364dbedb 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSession.java
@@ -106,6 +106,7 @@ public UnexpectedDrmSessionException(Throwable cause) {
   private final ProvisioningManager<T> provisioningManager;
   private final ReleaseCallback<T> releaseCallback;
   private final @DefaultDrmSessionManager.Mode int mode;
+  private final boolean isPlaceholderSession;
   @Nullable private final HashMap<String, String> optionalKeyRequestParameters;
   private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
@@ -134,8 +135,9 @@ public UnexpectedDrmSessionException(Throwable cause) {
    * @param provisioningManager The manager for provisioning.
    * @param releaseCallback The {@link ReleaseCallback}.
    * @param schemeDatas DRM scheme datas for this session, or null if an {@code
-   *     offlineLicenseKeySetId} is provided.
-   * @param mode The DRM mode.
+   *     offlineLicenseKeySetId} is provided or if {@code isPlaceholderSession} is true.
+   * @param mode The DRM mode. Ignored if {@code isPlaceholderSession} is true.
+   * @param isPlaceholderSession Whether this session is not expected to acquire any keys.
    * @param offlineLicenseKeySetId The offline license key set identifier, or null when not using
    *     offline keys.
    * @param optionalKeyRequestParameters The optional key request parameters.
@@ -152,6 +154,7 @@ public DefaultDrmSession(
       ReleaseCallback<T> releaseCallback,
       @Nullable List<SchemeData> schemeDatas,
       @DefaultDrmSessionManager.Mode int mode,
+      boolean isPlaceholderSession,
       @Nullable byte[] offlineLicenseKeySetId,
       @Nullable HashMap<String, String> optionalKeyRequestParameters,
       MediaDrmCallback callback,
@@ -167,6 +170,7 @@ public DefaultDrmSession(
     this.releaseCallback = releaseCallback;
     this.mediaDrm = mediaDrm;
     this.mode = mode;
+    this.isPlaceholderSession = isPlaceholderSession;
     if (offlineLicenseKeySetId != null) {
       this.offlineLicenseKeySetId = offlineLicenseKeySetId;
       this.schemeDatas = null;
@@ -342,6 +346,10 @@ private void onProvisionResponse(Object request, Object response) {
 
   @RequiresNonNull("sessionId")
   private void doLicense(boolean allowRetry) {
+    if (isPlaceholderSession) {
+      state = STATE_OPENED_WITH_KEYS;
+      return;
+    }
     byte[] sessionId = Util.castNonNull(this.sessionId);
     switch (mode) {
       case DefaultDrmSessionManager.MODE_PLAYBACK:
@@ -367,13 +375,8 @@ private void doLicense(boolean allowRetry) {
         }
         break;
       case DefaultDrmSessionManager.MODE_DOWNLOAD:
-        if (offlineLicenseKeySetId == null) {
+        if (offlineLicenseKeySetId == null || restoreKeys()) {
           postKeyRequest(sessionId, ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
-        } else {
-          // Renew
-          if (restoreKeys()) {
-            postKeyRequest(sessionId, ExoMediaDrm.KEY_TYPE_OFFLINE, allowRetry);
-          }
         }
         break;
       case DefaultDrmSessionManager.MODE_RELEASE:
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
index 0757ad12e0..ab6627936e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DefaultDrmSessionManager.java
@@ -93,11 +93,13 @@ private MissingSchemeDataException(UUID uuid) {
   @Nullable private final HashMap<String, String> optionalKeyRequestParameters;
   private final EventDispatcher<DefaultDrmSessionEventListener> eventDispatcher;
   private final boolean multiSession;
+  private final boolean allowPlaceholderSessions;
   private final LoadErrorHandlingPolicy loadErrorHandlingPolicy;
 
   private final List<DefaultDrmSession<T>> sessions;
   private final List<DefaultDrmSession<T>> provisioningSessions;
 
+  @Nullable private DefaultDrmSession<T> placeholderDrmSession;
   @Nullable private Looper playbackLooper;
   private int mode;
   @Nullable private byte[] offlineLicenseKeySetId;
@@ -232,6 +234,7 @@ public DefaultDrmSessionManager(
         callback,
         optionalKeyRequestParameters,
         multiSession,
+        /* allowPlaceholderSessions= */ false,
         new DefaultLoadErrorHandlingPolicy(initialDrmRequestRetryCount));
   }
 
@@ -241,6 +244,7 @@ private DefaultDrmSessionManager(
       MediaDrmCallback callback,
       @Nullable HashMap<String, String> optionalKeyRequestParameters,
       boolean multiSession,
+      boolean allowPlaceholderSessions,
       LoadErrorHandlingPolicy loadErrorHandlingPolicy) {
     Assertions.checkNotNull(uuid);
     Assertions.checkNotNull(mediaDrm);
@@ -251,6 +255,11 @@ private DefaultDrmSessionManager(
     this.optionalKeyRequestParameters = optionalKeyRequestParameters;
     this.eventDispatcher = new EventDispatcher<>();
     this.multiSession = multiSession;
+    boolean canAcquirePlaceholderSessions =
+        !FrameworkMediaCrypto.class.equals(mediaDrm.getExoMediaCryptoType())
+            || !FrameworkMediaCrypto.WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC;
+    // TODO: Allow customization once this class has a Builder.
+    this.allowPlaceholderSessions = canAcquirePlaceholderSessions && allowPlaceholderSessions;
     this.loadErrorHandlingPolicy = loadErrorHandlingPolicy;
     mode = MODE_PLAYBACK;
     sessions = new ArrayList<>();
@@ -399,14 +408,25 @@ public boolean canAcquireSession(DrmInitData drmInitData) {
   }
 
   @Override
-  public DrmSession<T> acquireSession(Looper playbackLooper, DrmInitData drmInitData) {
-    Assertions.checkState(this.playbackLooper == null || this.playbackLooper == playbackLooper);
-    if (sessions.isEmpty()) {
-      this.playbackLooper = playbackLooper;
-      if (mediaDrmHandler == null) {
-        mediaDrmHandler = new MediaDrmHandler(playbackLooper);
-      }
+  @Nullable
+  public DrmSession<T> acquirePlaceholderSession(Looper playbackLooper) {
+    if (!allowPlaceholderSessions) {
+      return null;
     }
+    maybeCreateMediaDrmHandler(playbackLooper);
+    if (placeholderDrmSession == null) {
+      DefaultDrmSession<T> placeholderDrmSession =
+          createNewDefaultSession(/* schemeDatas= */ null, /* isPlaceholderSession= */ true);
+      sessions.add(placeholderDrmSession);
+      this.placeholderDrmSession = placeholderDrmSession;
+    }
+    placeholderDrmSession.acquireReference();
+    return placeholderDrmSession;
+  }
+
+  @Override
+  public DrmSession<T> acquireSession(Looper playbackLooper, DrmInitData drmInitData) {
+    maybeCreateMediaDrmHandler(playbackLooper);
 
     List<SchemeData> schemeDatas = null;
     if (offlineLicenseKeySetId == null) {
@@ -434,26 +454,41 @@ public boolean canAcquireSession(DrmInitData drmInitData) {
 
     if (session == null) {
       // Create a new session.
-      session =
-          new DefaultDrmSession<>(
-              uuid,
-              mediaDrm,
-              /* provisioningManager= */ this,
-              /* releaseCallback= */ this::onSessionReleased,
-              schemeDatas,
-              mode,
-              offlineLicenseKeySetId,
-              optionalKeyRequestParameters,
-              callback,
-              playbackLooper,
-              eventDispatcher,
-              loadErrorHandlingPolicy);
+      session = createNewDefaultSession(schemeDatas, /* isPlaceholderSession= */ false);
       sessions.add(session);
     }
     session.acquireReference();
     return session;
   }
 
+  private DefaultDrmSession<T> createNewDefaultSession(
+      @Nullable List<SchemeData> schemeDatas, boolean isPlaceholderSession) {
+    return new DefaultDrmSession<>(
+        uuid,
+        mediaDrm,
+        /* provisioningManager= */ this,
+        /* releaseCallback= */ this::onSessionReleased,
+        schemeDatas,
+        mode,
+        isPlaceholderSession,
+        offlineLicenseKeySetId,
+        optionalKeyRequestParameters,
+        callback,
+        Assertions.checkNotNull(playbackLooper),
+        eventDispatcher,
+        loadErrorHandlingPolicy);
+  }
+
+  private void maybeCreateMediaDrmHandler(Looper playbackLooper) {
+    Assertions.checkState(this.playbackLooper == null || this.playbackLooper == playbackLooper);
+    if (sessions.isEmpty()) {
+      this.playbackLooper = playbackLooper;
+      if (mediaDrmHandler == null) {
+        mediaDrmHandler = new MediaDrmHandler(playbackLooper);
+      }
+    }
+  }
+
   @Override
   @Nullable
   public Class<T> getExoMediaCryptoType(DrmInitData drmInitData) {
@@ -495,6 +530,9 @@ public void onProvisionError(Exception error) {
 
   private void onSessionReleased(DefaultDrmSession<T> drmSession) {
     sessions.remove(drmSession);
+    if (placeholderDrmSession == drmSession) {
+      placeholderDrmSession = null;
+    }
     if (provisioningSessions.size() > 1 && provisioningSessions.get(0) == drmSession) {
       // Other sessions were waiting for the released session to complete a provision operation.
       // We need to have one of those sessions perform the provision operation instead.
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
index 9211cec144..457b1630c8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/DrmSessionManager.java
@@ -88,6 +88,23 @@ public boolean canAcquireSession(DrmInitData drmInitData) {
    */
   boolean canAcquireSession(DrmInitData drmInitData);
 
+  /**
+   * Returns a {@link DrmSession} with an acquired reference that does not execute key requests.
+   * Returns null if placeholder sessions are not supported by this DRM session manager.
+   *
+   * <p>Placeholder {@link DrmSession DrmSessions} may be used to configure secure decoders for
+   * playback of clear samples, which reduces the costs of transitioning between clear and encrypted
+   * content periods.
+   *
+   * @param playbackLooper The looper associated with the media playback thread.
+   * @return The placeholder DRM session, or null if this DRM session manager does not support
+   *     placeholder sessions.
+   */
+  @Nullable
+  default DrmSession<T> acquirePlaceholderSession(Looper playbackLooper) {
+    return null;
+  }
+
   /**
    * Returns a {@link DrmSession} with an acquired reference for the specified {@link DrmInitData}.
    *
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java
index 7211b5fcde..c139b522e9 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/drm/FrameworkMediaCrypto.java
@@ -16,6 +16,7 @@
 package com.google.android.exoplayer2.drm;
 
 import android.media.MediaCrypto;
+import com.google.android.exoplayer2.util.Util;
 import java.util.UUID;
 
 /**
@@ -24,6 +25,15 @@
  */
 public final class FrameworkMediaCrypto implements ExoMediaCrypto {
 
+  /**
+   * Whether the device needs keys to have been loaded into the {@link DrmSession} before codec
+   * configuration.
+   */
+  public static final boolean WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC =
+      "Amazon".equals(Util.MANUFACTURER)
+          && ("AFTM".equals(Util.MODEL) // Fire TV Stick Gen 1
+              || "AFTB".equals(Util.MODEL)); // Fire TV Gen 1
+
   /** The DRM scheme UUID. */
   public final UUID uuid;
   /** The DRM session id. */
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
index f853339474..14219b8dfd 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecRenderer.java
@@ -319,7 +319,6 @@ private static String getDiagnosticInfoV21(Throwable cause) {
   private final float assumedMinimumCodecOperatingRate;
   private final DecoderInputBuffer buffer;
   private final DecoderInputBuffer flagsOnlyBuffer;
-  private final FormatHolder formatHolder;
   private final TimedValueQueue<Format> formatQueue;
   private final ArrayList<Long> decodeOnlyPresentationTimestamps;
   private final MediaCodec.BufferInfo outputBufferInfo;
@@ -405,7 +404,6 @@ public MediaCodecRenderer(
     this.assumedMinimumCodecOperatingRate = assumedMinimumCodecOperatingRate;
     buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_DISABLED);
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
-    formatHolder = new FormatHolder();
     formatQueue = new TimedValueQueue<>();
     decodeOnlyPresentationTimestamps = new ArrayList<>();
     outputBufferInfo = new MediaCodec.BufferInfo();
@@ -523,7 +521,7 @@ protected final void maybeInitCodec() throws ExoPlaybackException {
                   && mediaCrypto.requiresSecureDecoderComponent(mimeType);
         }
       }
-      if (deviceNeedsDrmKeysToConfigureCodecWorkaround()) {
+      if (FrameworkMediaCrypto.WORKAROUND_DEVICE_NEEDS_KEYS_TO_CONFIGURE_CODEC) {
         @DrmSession.State int drmSessionState = codecDrmSession.getState();
         if (drmSessionState == DrmSession.STATE_ERROR) {
           throw ExoPlaybackException.createForRenderer(codecDrmSession.getError(), getIndex());
@@ -769,12 +767,11 @@ protected DecoderException createDecoderException(
 
   /** Reads into {@link #flagsOnlyBuffer} and returns whether a format was read. */
   private boolean readToFlagsOnlyBuffer(boolean requireFormat) throws ExoPlaybackException {
-    formatHolder.clear();
+    FormatHolder formatHolder = getFormatHolder();
     flagsOnlyBuffer.clear();
     int result = readSource(formatHolder, flagsOnlyBuffer, requireFormat);
     if (result == C.RESULT_FORMAT_READ) {
       onInputFormatChanged(formatHolder);
-      formatHolder.clear();
       return true;
     } else if (result == C.RESULT_BUFFER_READ && flagsOnlyBuffer.isEndOfStream()) {
       inputStreamEnded = true;
@@ -1042,6 +1039,7 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
     }
 
     int result;
+    FormatHolder formatHolder = getFormatHolder();
     int adaptiveReconfigurationBytes = 0;
     if (waitingForKeys) {
       // We've already read an encrypted sample into buffer, and are waiting for keys.
@@ -1057,7 +1055,6 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         codecReconfigurationState = RECONFIGURATION_STATE_QUEUE_PENDING;
       }
       adaptiveReconfigurationBytes = buffer.data.position();
-      formatHolder.clear();
       result = readSource(formatHolder, buffer, false);
     }
 
@@ -1077,7 +1074,6 @@ private boolean feedInputBuffer() throws ExoPlaybackException {
         codecReconfigurationState = RECONFIGURATION_STATE_WRITE_PENDING;
       }
       onInputFormatChanged(formatHolder);
-      formatHolder.clear();
       return true;
     }
 
@@ -1758,16 +1754,6 @@ private static boolean isMediaCodecExceptionV21(IllegalStateException error) {
     return error instanceof MediaCodec.CodecException;
   }
 
-  /**
-   * Returns whether the device needs keys to have been loaded into the {@link DrmSession} before
-   * codec configuration.
-   */
-  private boolean deviceNeedsDrmKeysToConfigureCodecWorkaround() {
-    return "Amazon".equals(Util.MANUFACTURER)
-        && ("AFTM".equals(Util.MODEL) // Fire TV Stick Gen 1
-            || "AFTB".equals(Util.MODEL)); // Fire TV Gen 1
-  }
-
   /**
    * Returns whether the decoder is known to fail when flushed.
    * <p>
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
index 3ec0094e60..2d76309b7a 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecUtil.java
@@ -602,7 +602,7 @@ private static boolean isSoftwareOnly(android.media.MediaCodecInfo codecInfo) {
     if (Util.SDK_INT >= 29) {
       return isSoftwareOnlyV29(codecInfo);
     }
-    String codecName = codecInfo.getName().toLowerCase();
+    String codecName = Util.toLowerInvariant(codecInfo.getName());
     if (codecName.startsWith("arc.")) { // App Runtime for Chrome (ARC) codecs
       return false;
     }
@@ -628,7 +628,7 @@ private static boolean isVendor(android.media.MediaCodecInfo codecInfo) {
     if (Util.SDK_INT >= 29) {
       return isVendorV29(codecInfo);
     }
-    String codecName = codecInfo.getName().toLowerCase();
+    String codecName = Util.toLowerInvariant(codecInfo.getName());
     return !codecName.startsWith("omx.google.")
         && !codecName.startsWith("c2.android.")
         && !codecName.startsWith("c2.google.");
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
index d162164f79..d738a8662e 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java
@@ -45,7 +45,6 @@
   private final MetadataDecoderFactory decoderFactory;
   private final MetadataOutput output;
   @Nullable private final Handler outputHandler;
-  private final FormatHolder formatHolder;
   private final MetadataInputBuffer buffer;
   private final Metadata[] pendingMetadata;
   private final long[] pendingMetadataTimestamps;
@@ -84,7 +83,6 @@ public MetadataRenderer(
     this.outputHandler =
         outputLooper == null ? null : Util.createHandler(outputLooper, /* callback= */ this);
     this.decoderFactory = Assertions.checkNotNull(decoderFactory);
-    formatHolder = new FormatHolder();
     buffer = new MetadataInputBuffer();
     pendingMetadata = new Metadata[MAX_PENDING_METADATA_COUNT];
     pendingMetadataTimestamps = new long[MAX_PENDING_METADATA_COUNT];
@@ -114,7 +112,7 @@ protected void onPositionReset(long positionUs, boolean joining) {
   public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackException {
     if (!inputStreamEnded && pendingMetadataCount < MAX_PENDING_METADATA_COUNT) {
       buffer.clear();
-      formatHolder.clear();
+      FormatHolder formatHolder = getFormatHolder();
       int result = readSource(formatHolder, buffer, false);
       if (result == C.RESULT_BUFFER_READ) {
         if (buffer.isEndOfStream()) {
@@ -142,7 +140,6 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
         }
       } else if (result == C.RESULT_FORMAT_READ) {
         subsampleOffsetUs = formatHolder.format.subsampleOffsetUs;
-        formatHolder.clear();
       }
     }
 
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/source/DecryptableSampleQueueReader.java b/library/core/src/main/java/com/google/android/exoplayer2/source/DecryptableSampleQueueReader.java
index 365a48cadf..b6f730cea3 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/source/DecryptableSampleQueueReader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/source/DecryptableSampleQueueReader.java
@@ -156,6 +156,7 @@ public int read(
    */
   private void onFormat(Format format, FormatHolder outputFormatHolder) {
     outputFormatHolder.format = format;
+    boolean isFirstFormat = currentFormat == null;
     DrmInitData oldDrmInitData = currentFormat != null ? currentFormat.drmInitData : null;
     currentFormat = format;
     if (sessionManager == DrmSessionManager.DUMMY) {
@@ -167,7 +168,7 @@ private void onFormat(Format format, FormatHolder outputFormatHolder) {
     }
     outputFormatHolder.includesDrmSession = true;
     outputFormatHolder.drmSession = currentSession;
-    if (Util.areEqual(oldDrmInitData, format.drmInitData)) {
+    if (!isFirstFormat && Util.areEqual(oldDrmInitData, format.drmInitData)) {
       // Nothing to do.
       return;
     }
@@ -175,12 +176,11 @@ private void onFormat(Format format, FormatHolder outputFormatHolder) {
     // can be used for both DrmInitData.
     DrmSession<?> previousSession = currentSession;
     DrmInitData drmInitData = currentFormat.drmInitData;
-    if (drmInitData != null) {
-      currentSession =
-          sessionManager.acquireSession(Assertions.checkNotNull(Looper.myLooper()), drmInitData);
-    } else {
-      currentSession = null;
-    }
+    Looper playbackLooper = Assertions.checkNotNull(Looper.myLooper());
+    currentSession =
+        drmInitData != null
+            ? sessionManager.acquireSession(playbackLooper, drmInitData)
+            : sessionManager.acquirePlaceholderSession(playbackLooper);
     outputFormatHolder.drmSession = currentSession;
 
     if (previousSession != null) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
index a9f571c085..035e3bfad8 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java
@@ -800,10 +800,14 @@ protected boolean processOutputBuffer(
     }
 
     long elapsedRealtimeNowUs = SystemClock.elapsedRealtime() * 1000;
+    long elapsedSinceLastRenderUs = elapsedRealtimeNowUs - lastRenderTimeUs;
     boolean isStarted = getState() == STATE_STARTED;
-    if (!renderedFirstFrame
-        || (isStarted
-            && shouldForceRenderOutputBuffer(earlyUs, elapsedRealtimeNowUs - lastRenderTimeUs))) {
+    // Don't force output until we joined and always render first frame if not joining.
+    boolean forceRenderOutputBuffer =
+        joiningDeadlineMs == C.TIME_UNSET
+            && (!renderedFirstFrame
+                || (isStarted && shouldForceRenderOutputBuffer(earlyUs, elapsedSinceLastRenderUs)));
+    if (forceRenderOutputBuffer) {
       long releaseTimeNs = System.nanoTime();
       notifyFrameMetadataListener(presentationTimeUs, releaseTimeNs, format);
       if (Util.SDK_INT >= 21) {
@@ -832,11 +836,17 @@ protected boolean processOutputBuffer(
         bufferPresentationTimeUs, unadjustedFrameReleaseTimeNs);
     earlyUs = (adjustedReleaseTimeNs - systemTimeNs) / 1000;
 
+    boolean treatDroppedBuffersAsSkipped = joiningDeadlineMs != C.TIME_UNSET;
     if (shouldDropBuffersToKeyframe(earlyUs, elapsedRealtimeUs, isLastBuffer)
-        && maybeDropBuffersToKeyframe(codec, bufferIndex, presentationTimeUs, positionUs)) {
+        && maybeDropBuffersToKeyframe(
+            codec, bufferIndex, presentationTimeUs, positionUs, treatDroppedBuffersAsSkipped)) {
       return false;
     } else if (shouldDropOutputBuffer(earlyUs, elapsedRealtimeUs, isLastBuffer)) {
-      dropOutputBuffer(codec, bufferIndex, presentationTimeUs);
+      if (treatDroppedBuffersAsSkipped) {
+        skipOutputBuffer(codec, bufferIndex, presentationTimeUs);
+      } else {
+        dropOutputBuffer(codec, bufferIndex, presentationTimeUs);
+      }
       return true;
     }
 
@@ -988,6 +998,7 @@ protected boolean shouldDropBuffersToKeyframe(
    * @return Returns whether to force rendering an output buffer.
    */
   protected boolean shouldForceRenderOutputBuffer(long earlyUs, long elapsedSinceLastRenderUs) {
+    // Force render late buffers every 100ms to avoid frozen video effect.
     return isBufferLate(earlyUs) && elapsedSinceLastRenderUs > 100000;
   }
 
@@ -1028,11 +1039,18 @@ protected void dropOutputBuffer(MediaCodec codec, int index, long presentationTi
    * @param index The index of the output buffer to drop.
    * @param presentationTimeUs The presentation time of the output buffer, in microseconds.
    * @param positionUs The current playback position, in microseconds.
+   * @param treatDroppedBuffersAsSkipped Whether dropped buffers should be treated as intentionally
+   *     skipped.
    * @return Whether any buffers were dropped.
    * @throws ExoPlaybackException If an error occurs flushing the codec.
    */
-  protected boolean maybeDropBuffersToKeyframe(MediaCodec codec, int index, long presentationTimeUs,
-      long positionUs) throws ExoPlaybackException {
+  protected boolean maybeDropBuffersToKeyframe(
+      MediaCodec codec,
+      int index,
+      long presentationTimeUs,
+      long positionUs,
+      boolean treatDroppedBuffersAsSkipped)
+      throws ExoPlaybackException {
     int droppedSourceBufferCount = skipSource(positionUs);
     if (droppedSourceBufferCount == 0) {
       return false;
@@ -1040,7 +1058,12 @@ protected boolean maybeDropBuffersToKeyframe(MediaCodec codec, int index, long p
     decoderCounters.droppedToKeyframeCount++;
     // We dropped some buffers to catch up, so update the decoder counters and flush the codec,
     // which releases all pending buffers buffers including the current output buffer.
-    updateDroppedBufferCounters(buffersInCodecCount + droppedSourceBufferCount);
+    int totalDroppedBufferCount = buffersInCodecCount + droppedSourceBufferCount;
+    if (treatDroppedBuffersAsSkipped) {
+      decoderCounters.skippedOutputBufferCount += totalDroppedBufferCount;
+    } else {
+      updateDroppedBufferCounters(totalDroppedBufferCount);
+    }
     flushOrReinitializeCodec();
     return true;
   }
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
index 048f9cbf0f..e8d63dd617 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/SimpleDecoderVideoRenderer.java
@@ -73,7 +73,6 @@
   private final int maxDroppedFramesToNotify;
   private final boolean playClearSamplesWithoutKeys;
   private final EventDispatcher eventDispatcher;
-  private final FormatHolder formatHolder;
   private final TimedValueQueue<Format> formatQueue;
   private final DecoderInputBuffer flagsOnlyBuffer;
   private final DrmSessionManager<ExoMediaCrypto> drmSessionManager;
@@ -144,7 +143,6 @@ protected SimpleDecoderVideoRenderer(
     this.playClearSamplesWithoutKeys = playClearSamplesWithoutKeys;
     joiningDeadlineMs = C.TIME_UNSET;
     clearReportedVideoSize();
-    formatHolder = new FormatHolder();
     formatQueue = new TimedValueQueue<>();
     flagsOnlyBuffer = DecoderInputBuffer.newFlagsOnlyInstance();
     eventDispatcher = new EventDispatcher(eventHandler, eventListener);
@@ -166,12 +164,11 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
 
     if (inputFormat == null) {
       // We don't have a format yet, so try and read one.
-      formatHolder.clear();
+      FormatHolder formatHolder = getFormatHolder();
       flagsOnlyBuffer.clear();
       int result = readSource(formatHolder, flagsOnlyBuffer, true);
       if (result == C.RESULT_FORMAT_READ) {
         onInputFormatChanged(formatHolder);
-        formatHolder.clear();
       } else if (result == C.RESULT_BUFFER_READ) {
         // End of stream read having not read a format.
         Assertions.checkState(flagsOnlyBuffer.isEndOfStream());
@@ -680,11 +677,11 @@ private boolean feedInputBuffer() throws VideoDecoderException, ExoPlaybackExcep
     }
 
     int result;
+    FormatHolder formatHolder = getFormatHolder();
     if (waitingForKeys) {
       // We've already read an encrypted sample into buffer, and are waiting for keys.
       result = C.RESULT_BUFFER_READ;
     } else {
-      formatHolder.clear();
       result = readSource(formatHolder, inputBuffer, false);
     }
 
@@ -693,7 +690,6 @@ private boolean feedInputBuffer() throws VideoDecoderException, ExoPlaybackExcep
     }
     if (result == C.RESULT_FORMAT_READ) {
       onInputFormatChanged(formatHolder);
-      formatHolder.clear();
       return true;
     }
     if (inputBuffer.isEndOfStream()) {
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
index 9384d32a6f..d1cf0abc56 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/video/spherical/CameraMotionRenderer.java
@@ -34,7 +34,6 @@
   // The amount of time to read samples ahead of the current time.
   private static final int SAMPLE_WINDOW_DURATION_US = 100000;
 
-  private final FormatHolder formatHolder;
   private final DecoderInputBuffer buffer;
   private final ParsableByteArray scratch;
 
@@ -44,7 +43,6 @@
 
   public CameraMotionRenderer() {
     super(C.TRACK_TYPE_CAMERA_MOTION);
-    formatHolder = new FormatHolder();
     buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
     scratch = new ParsableByteArray();
   }
@@ -85,10 +83,9 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     // Keep reading available samples as long as the sample time is not too far into the future.
     while (!hasReadStreamToEnd() && lastTimestampUs < positionUs + SAMPLE_WINDOW_DURATION_US) {
       buffer.clear();
-      formatHolder.clear();
+      FormatHolder formatHolder = getFormatHolder();
       int result = readSource(formatHolder, buffer, /* formatRequired= */ false);
       if (result != C.RESULT_BUFFER_READ || buffer.isEndOfStream()) {
-        formatHolder.clear();
         return;
       }
 
diff --git a/library/ui/src/main/res/values/strings.xml b/library/ui/src/main/res/values/strings.xml
index 056f4de409..f0282b4991 100644
--- a/library/ui/src/main/res/values/strings.xml
+++ b/library/ui/src/main/res/values/strings.xml
@@ -34,9 +34,9 @@
   <string name="exo_controls_repeat_one_description">Repeat one</string>
   <!-- Description for a button that controls the repeat mode of a media playback. In this mode the entire playlist is repeated. [CHAR LIMIT=30] -->
   <string name="exo_controls_repeat_all_description">Repeat all</string>
-  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is on. [CHAR LIMIT=33] -->
+  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is on. [CHAR LIMIT=40] -->
   <string name="exo_controls_shuffle_on_description">Shuffle on</string>
-  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is off. [CHAR LIMIT=33] -->
+  <!-- Description for a button that controls the shuffle mode of media playback. In this mode shuffle is off. [CHAR LIMIT=40] -->
   <string name="exo_controls_shuffle_off_description">Shuffle off</string>
   <!-- Description for a media control button that toggles whether a video playback is fullscreen. [CHAR LIMIT=30] -->
   <string name="exo_controls_fullscreen_description">Fullscreen mode</string>
diff --git a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java
index 499aa1ec9e..39d3d8f7f4 100644
--- a/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java
+++ b/testutils/src/main/java/com/google/android/exoplayer2/testutil/FakeRenderer.java
@@ -45,7 +45,6 @@
 
   private final List<Format> expectedFormats;
   private final DecoderInputBuffer buffer;
-  private final FormatHolder formatHolder;
 
   private long playbackPositionUs;
   private long lastSamplePositionUs;
@@ -60,7 +59,6 @@ public FakeRenderer(Format... expectedFormats) {
         : MimeTypes.getTrackType(expectedFormats[0].sampleMimeType));
     this.expectedFormats = Collections.unmodifiableList(Arrays.asList(expectedFormats));
     buffer = new DecoderInputBuffer(DecoderInputBuffer.BUFFER_REPLACEMENT_MODE_NORMAL);
-    formatHolder = new FormatHolder();
     lastSamplePositionUs = Long.MIN_VALUE;
   }
 
@@ -79,14 +77,13 @@ public void render(long positionUs, long elapsedRealtimeUs) throws ExoPlaybackEx
     }
     playbackPositionUs = positionUs;
     while (lastSamplePositionUs < positionUs + SOURCE_READAHEAD_US) {
-      formatHolder.clear();
+      FormatHolder formatHolder = getFormatHolder();
       buffer.clear();
       int result = readSource(formatHolder, buffer, false);
       if (result == C.RESULT_FORMAT_READ) {
         formatReadCount++;
         assertThat(expectedFormats).contains(formatHolder.format);
         onFormatChanged(formatHolder.format);
-        formatHolder.clear();
       } else if (result == C.RESULT_BUFFER_READ) {
         if (buffer.isEndOfStream()) {
           isEnded = true;
