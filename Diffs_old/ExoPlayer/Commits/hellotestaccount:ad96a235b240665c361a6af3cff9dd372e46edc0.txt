diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/QueuedDownload.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/QueuedDownload.java
new file mode 100644
index 0000000000..8d0e621260
--- /dev/null
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/QueuedDownload.java
@@ -0,0 +1,78 @@
+package com.google.android.exoplayer2.offline;
+
+import android.os.SystemClock;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+
+public class QueuedDownload<T> {
+
+    interface Callback<T> {
+        void download(T item) throws InterruptedException, IOException;
+    }
+
+    private final List<T> itemsToDownload;
+    private final int maxParallelSize;
+    private final Callback<T> callback;
+    private final Object Q_LOCK = new Object();
+
+    private int currentParallelCount = 0;
+    private InterruptedException interruptedExceptionHolder = null;
+    private IOException ioExceptionHolder = null;
+
+
+    public QueuedDownload(List<T> itemsToDownload, int maxParallelSize, Callback<T> callback) {
+        this.itemsToDownload = itemsToDownload;
+        this.maxParallelSize = maxParallelSize;
+        this.callback = callback;
+    }
+
+    public QueuedDownload(List<T> itemsToDownload, Callback<T> callback) {
+        this(itemsToDownload, 3, callback);
+    }
+
+    public void initDownload() throws IOException, InterruptedException {
+
+        while (itemsToDownload.size() > 0) {
+
+            while (currentParallelCount >= maxParallelSize) {
+                SystemClock.sleep(100);
+            }
+
+            if(interruptedExceptionHolder != null) {
+                throw interruptedExceptionHolder;
+            }
+
+            if(ioExceptionHolder != null) {
+                throw ioExceptionHolder;
+            }
+
+            T item = itemsToDownload.remove(0);
+            downloadAsync(item);
+
+        }
+    }
+
+    private void downloadAsync(T item) {
+
+        synchronized (Q_LOCK) {
+            currentParallelCount++;
+        }
+
+        new Thread(() -> {
+            try {
+                callback.download(item);
+            } catch (InterruptedException e) {
+                interruptedExceptionHolder = e;
+            }
+            catch (IOException e) {
+                ioExceptionHolder = e;
+            }
+            synchronized (Q_LOCK) {
+                currentParallelCount--;
+            }
+        }).start();
+
+    }
+}
diff --git a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
index 625ec4f5e7..47a2fcc54b 100644
--- a/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
+++ b/library/core/src/main/java/com/google/android/exoplayer2/offline/SegmentDownloader.java
@@ -73,6 +73,8 @@ public int compareTo(@NonNull Segment other) {
   private volatile int downloadedSegments;
   private volatile long downloadedBytes;
 
+  private final Object lock = new Object();
+
   /**
    * @param manifestUri The {@link Uri} of the manifest to be downloaded.
    * @param streamKeys Keys defining which streams in the manifest should be selected for download.
@@ -110,10 +112,11 @@ public final void download() throws IOException, InterruptedException {
       Collections.sort(segments);
       byte[] buffer = new byte[BUFFER_SIZE_BYTES];
       CachingCounters cachingCounters = new CachingCounters();
-      for (int i = 0; i < segments.size(); i++) {
+      QueuedDownload<Segment> queuedDownload = new QueuedDownload<>(segments, segment -> {
+
         try {
           CacheUtil.cache(
-              segments.get(i).dataSpec,
+              segment.dataSpec,
               cache,
               dataSource,
               buffer,
@@ -124,9 +127,13 @@ public final void download() throws IOException, InterruptedException {
               true);
           downloadedSegments++;
         } finally {
-          downloadedBytes += cachingCounters.newlyCachedBytes;
+          synchronized (lock) {
+            downloadedBytes += cachingCounters.newlyCachedBytes;
+          }
         }
-      }
+      });
+
+      queuedDownload.initDownload();
     } finally {
       priorityTaskManager.remove(C.PRIORITY_DOWNLOAD);
     }
