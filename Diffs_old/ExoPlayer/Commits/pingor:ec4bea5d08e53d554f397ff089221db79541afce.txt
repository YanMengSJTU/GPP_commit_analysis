diff --git a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
index ef374202ce..6d3925f751 100644
--- a/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
+++ b/demo/src/main/java/com/google/android/exoplayer/demo/player/DemoPlayer.java
@@ -24,6 +24,7 @@
 import com.google.android.exoplayer.MediaCodecTrackRenderer.DecoderInitializationException;
 import com.google.android.exoplayer.MediaCodecVideoTrackRenderer;
 import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.SingleSampleSource;
 import com.google.android.exoplayer.TimeRange;
 import com.google.android.exoplayer.TrackRenderer;
 import com.google.android.exoplayer.audio.AudioTrack;
@@ -59,10 +60,10 @@
  */
 public class DemoPlayer implements ExoPlayer.Listener, ChunkSampleSource.EventListener,
     HlsSampleSource.EventListener, ExtractorSampleSource.EventListener,
-    DefaultBandwidthMeter.EventListener, MediaCodecVideoTrackRenderer.EventListener,
-    MediaCodecAudioTrackRenderer.EventListener, StreamingDrmSessionManager.EventListener,
-    DashChunkSource.EventListener, TextRenderer, MetadataRenderer<List<Id3Frame>>,
-    DebugTextViewHelper.Provider {
+    SingleSampleSource.EventListener, DefaultBandwidthMeter.EventListener,
+    MediaCodecVideoTrackRenderer.EventListener, MediaCodecAudioTrackRenderer.EventListener,
+    StreamingDrmSessionManager.EventListener, DashChunkSource.EventListener, TextRenderer,
+    MetadataRenderer<List<Id3Frame>>, DebugTextViewHelper.Provider {
 
   /**
    * Builds renderers for the player.
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
index 0bfe3ccc14..b34f468615 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/FlacDecoder.java
@@ -16,7 +16,6 @@
 package com.google.android.exoplayer.ext.flac;
 
 import com.google.android.exoplayer.SampleHolder;
-import com.google.android.exoplayer.util.extensions.Buffer;
 import com.google.android.exoplayer.util.extensions.InputBuffer;
 import com.google.android.exoplayer.util.extensions.SimpleDecoder;
 
@@ -94,14 +93,6 @@ protected void releaseOutputBuffer(FlacOutputBuffer buffer) {
 
   @Override
   public FlacDecoderException decode(InputBuffer inputBuffer, FlacOutputBuffer outputBuffer) {
-    outputBuffer.reset();
-    if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
-      outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
-      return null;
-    }
-    if (inputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
-      outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
-    }
     SampleHolder sampleHolder = inputBuffer.sampleHolder;
     outputBuffer.timestampUs = sampleHolder.timeUs;
     sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
diff --git a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
index 59494d3f38..ad3ea4268e 100644
--- a/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
+++ b/extensions/flac/src/main/java/com/google/android/exoplayer/ext/flac/LibflacAudioTrackRenderer.java
@@ -92,7 +92,6 @@
   private boolean inputStreamEnded;
   private boolean outputStreamEnded;
   private boolean sourceIsReady;
-  private boolean notifyDiscontinuityToDecoder;
 
   private final AudioTrack audioTrack;
   private int audioSessionId;
@@ -262,10 +261,6 @@ private boolean feedInputBuffer(long positionUs) throws FlacDecoderException {
       inputStreamEnded = true;
       return false;
     }
-    if (notifyDiscontinuityToDecoder) {
-      notifyDiscontinuityToDecoder = false;
-      inputBuffer.setFlag(Buffer.FLAG_RESET);
-    }
 
     decoder.queueInputBuffer(inputBuffer);
     inputBuffer = null;
@@ -279,7 +274,6 @@ private void flushDecoder() {
       outputBuffer = null;
     }
     decoder.flush();
-    notifyDiscontinuityToDecoder = true;
   }
 
   @Override
diff --git a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
index 936444e573..9ad75f9e62 100644
--- a/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
+++ b/extensions/opus/src/main/java/com/google/android/exoplayer/ext/opus/OpusDecoder.java
@@ -151,14 +151,6 @@ protected void releaseOutputBuffer(OpusOutputBuffer buffer) {
 
   @Override
   public OpusDecoderException decode(InputBuffer inputBuffer, OpusOutputBuffer outputBuffer) {
-    outputBuffer.reset();
-    if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
-      outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
-      return null;
-    }
-    if (inputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
-      outputBuffer.setFlag(Buffer.FLAG_DECODE_ONLY);
-    }
     if (inputBuffer.getFlag(Buffer.FLAG_RESET)) {
       opusReset(nativeDecoderContext);
       // When seeking to 0, skip number of samples as specified in opus header. When seeking to
diff --git a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
index 1e0e8d5be7..4f8c845db8 100644
--- a/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
+++ b/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java
@@ -101,11 +101,6 @@ protected void releaseOutputBuffer(VpxOutputBuffer buffer) {
 
   @Override
   protected VpxDecoderException decode(VpxInputBuffer inputBuffer, VpxOutputBuffer outputBuffer) {
-    outputBuffer.reset();
-    if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
-      outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
-      return null;
-    }
     SampleHolder sampleHolder = inputBuffer.sampleHolder;
     outputBuffer.timestampUs = sampleHolder.timeUs;
     sampleHolder.data.position(sampleHolder.data.position() - sampleHolder.size);
diff --git a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArrayTest.java b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArrayTest.java
index 11238f74f8..17a0fd241e 100644
--- a/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArrayTest.java
+++ b/library/src/androidTest/java/com/google/android/exoplayer/extractor/ogg/VorbisBitArrayTest.java
@@ -269,11 +269,11 @@ public void testBitsLeft() {
     assertEquals(10, bitArray.bitsLeft());
     assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
 
-    bitArray.readBit();
+    bitArray.skipBits(1);
     assertEquals(9, bitArray.bitsLeft());
     assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
 
-    bitArray.readBits(1);
+    bitArray.skipBits(1);
     assertEquals(8, bitArray.bitsLeft());
     assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());
 
diff --git a/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
index ca66e23316..6d0aac646d 100644
--- a/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/SingleSampleSource.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer.util.Assertions;
 
 import android.net.Uri;
+import android.os.Handler;
 import android.os.SystemClock;
 
 import java.io.IOException;
@@ -34,6 +35,21 @@
 public final class SingleSampleSource implements SampleSource, SampleSourceReader, Loader.Callback,
     Loadable {
 
+  /**
+   * Interface definition for a callback to be notified of {@link SingleSampleSource} events.
+   */
+  public interface EventListener {
+
+    /**
+     * Invoked when an error occurs loading media data.
+     *
+     * @param sourceId The id of the reporting {@link SampleSource}.
+     * @param e The cause of the failure.
+     */
+    void onLoadError(int sourceId, IOException e);
+
+  }
+
   /**
    * The default minimum number of times to retry loading data prior to failing.
    */
@@ -52,6 +68,9 @@
   private final DataSource dataSource;
   private final MediaFormat format;
   private final int minLoadableRetryCount;
+  private final Handler eventHandler;
+  private final EventListener eventListener;
+  private final int eventSourceId;
 
   private int state;
   private byte[] sampleData;
@@ -70,10 +89,19 @@ public SingleSampleSource(Uri uri, DataSource dataSource, MediaFormat format) {
 
   public SingleSampleSource(Uri uri, DataSource dataSource, MediaFormat format,
       int minLoadableRetryCount) {
+    this(uri, dataSource, format, minLoadableRetryCount, null, null, 0);
+  }
+
+  public SingleSampleSource(Uri uri, DataSource dataSource, MediaFormat format,
+      int minLoadableRetryCount, Handler eventHandler, EventListener eventListener,
+      int eventSourceId) {
     this.uri = uri;
     this.dataSource = dataSource;
     this.format = format;
     this.minLoadableRetryCount = minLoadableRetryCount;
+    this.eventHandler = eventHandler;
+    this.eventListener = eventListener;
+    this.eventSourceId = eventSourceId;
     sampleData = new byte[INITIAL_SAMPLE_SIZE];
   }
 
@@ -222,6 +250,7 @@ public void onLoadError(Loadable loadable, IOException e) {
     currentLoadableException = e;
     currentLoadableExceptionCount++;
     currentLoadableExceptionTimestamp = SystemClock.elapsedRealtime();
+    notifyLoadError(e);
     maybeStartLoading();
   }
 
@@ -258,4 +287,15 @@ public void load() throws IOException, InterruptedException {
     }
   }
 
+  private void notifyLoadError(final IOException e) {
+    if (eventHandler != null && eventListener != null) {
+      eventHandler.post(new Runnable()  {
+        @Override
+        public void run() {
+          eventListener.onLoadError(eventSourceId, e);
+        }
+      });
+    }
+  }
+
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
index ed0558c620..77da26c008 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ExtractorSampleSource.java
@@ -55,9 +55,10 @@
  * <li>Ogg Vorbis ({@link com.google.android.exoplayer.extractor.ogg.OggVorbisExtractor}</li>
  * <li>MP3 ({@link com.google.android.exoplayer.extractor.mp3.Mp3Extractor})</li>
  * <li>AAC ({@link com.google.android.exoplayer.extractor.ts.AdtsExtractor})</li>
- * <li>MPEG TS ({@link com.google.android.exoplayer.extractor.ts.TsExtractor}</li>
- * <li>MPEG PS ({@link com.google.android.exoplayer.extractor.ts.PsExtractor}</li>
- * <li>FLV ({@link com.google.android.exoplayer.extractor.flv.FlvExtractor}</li>
+ * <li>MPEG TS ({@link com.google.android.exoplayer.extractor.ts.TsExtractor})</li>
+ * <li>MPEG PS ({@link com.google.android.exoplayer.extractor.ts.PsExtractor})</li>
+ * <li>FLV ({@link com.google.android.exoplayer.extractor.flv.FlvExtractor})</li>
+ * <li>WAV ({@link com.google.android.exoplayer.extractor.wav.WavExtractor})</li>
  * </ul>
  *
  * <p>Seeking in AAC, MPEG TS and FLV streams is not supported.
@@ -182,6 +183,13 @@ public UnrecognizedInputFormatException(Extractor[] extractors) {
     } catch (ClassNotFoundException e) {
       // Extractor not found.
     }
+    try {
+      DEFAULT_EXTRACTOR_CLASSES.add(
+          Class.forName("com.google.android.exoplayer.extractor.wav.WavExtractor")
+              .asSubclass(Extractor.class));
+    } catch (ClassNotFoundException e) {
+      // Extractor not found.
+    }
   }
 
   private final ExtractorHolder extractorHolder;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
index 4a349494b7..48df138304 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/RollingSampleBuffer.java
@@ -528,8 +528,8 @@ public int getReadIndex() {
      * The first entry in {@code offsetHolder} is filled with the absolute position of the sample's
      * data in the rolling buffer.
      * <p>
-     * The fields set are {SampleHolder#size}, {SampleHolder#timeUs}, {SampleHolder#flags} and
-     * {@code offsetHolder[0]}.
+     * Populates {@link SampleHolder#size}, {@link SampleHolder#timeUs}, {@link SampleHolder#flags}
+     * and the {@code extrasHolder}.
      *
      * @param holder The holder into which the current sample information should be written.
      * @param extrasHolder The holder into which extra sample information should be written.
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java
index 599ea01636..63cdcf0999 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/flv/VideoTagPayloadReader.java
@@ -20,7 +20,6 @@
 import com.google.android.exoplayer.ParserException;
 import com.google.android.exoplayer.extractor.TrackOutput;
 import com.google.android.exoplayer.util.Assertions;
-import com.google.android.exoplayer.util.CodecSpecificDataUtil;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.NalUnitUtil;
 import com.google.android.exoplayer.util.ParsableBitArray;
@@ -165,7 +164,7 @@ private AvcSequenceHeaderData parseAvcCodecPrivate(ParsableByteArray buffer)
       ParsableBitArray spsDataBitArray = new ParsableBitArray(initializationData.get(0));
       // Skip the NAL header consisting of the nalUnitLengthField and the type (1 byte).
       spsDataBitArray.setPosition(8 * (nalUnitLengthFieldLength + 1));
-      CodecSpecificDataUtil.SpsData sps = CodecSpecificDataUtil.parseSpsNalUnit(spsDataBitArray);
+      NalUnitUtil.SpsData sps = NalUnitUtil.parseSpsNalUnit(spsDataBitArray);
       width = sps.width;
       height = sps.height;
       pixelWidthAspectRatio = sps.pixelWidthAspectRatio;
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
index 604ca7d407..b7ab5d6c0e 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/mp4/AtomParsers.java
@@ -670,8 +670,7 @@ private static AvcCData parseAvcCFromParent(ParsableByteArray parent, int positi
       ParsableBitArray spsDataBitArray = new ParsableBitArray(initializationData.get(0));
       // Skip the NAL header consisting of the nalUnitLengthField and the type (1 byte).
       spsDataBitArray.setPosition(8 * (nalUnitLengthFieldLength + 1));
-      pixelWidthAspectRatio = CodecSpecificDataUtil.parseSpsNalUnit(spsDataBitArray)
-          .pixelWidthAspectRatio;
+      pixelWidthAspectRatio = NalUnitUtil.parseSpsNalUnit(spsDataBitArray).pixelWidthAspectRatio;
     }
 
     return new AvcCData(initializationData, nalUnitLengthFieldLength, pixelWidthAspectRatio);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
index ead08da623..a39d02bd00 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/AdtsReader.java
@@ -23,6 +23,7 @@
 import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import android.util.Log;
 import android.util.Pair;
 
 import java.util.Arrays;
@@ -33,6 +34,8 @@
  */
 /* package */ final class AdtsReader extends ElementaryStreamReader {
 
+  private static final String TAG = "AdtsReader";
+
   private static final int STATE_FINDING_SAMPLE = 0;
   private static final int STATE_READING_ID3_HEADER = 1;
   private static final int STATE_READING_ADTS_HEADER = 2;
@@ -251,6 +254,16 @@ private void parseAdtsHeader() {
 
     if (!hasOutputFormat) {
       int audioObjectType = adtsScratch.readBits(2) + 1;
+      if (audioObjectType == 1) {
+        // The stream indicates AAC Main but it's more likely that the stream contains HE-AAC.
+        // HE-AAC cannot be represented correctly in the ADTS header because it has an
+        // audioObjectType value of 5 whereas an ADTS header can only represent values up to 4.
+        // Since most Android devices don't support AAC Main anyway, we pretend that we're dealing
+        // with AAC LC and hope for the best. In practice this often works.
+        Log.w(TAG, "Detected AAC Main audio, but assuming AAC LC.");
+        audioObjectType = 2;
+      }
+
       int sampleRateIndex = adtsScratch.readBits(4);
       adtsScratch.skipBits(1);
       int channelConfig = adtsScratch.readBits(3);
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
index e20781adb5..e29a25605e 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H264Reader.java
@@ -18,13 +18,14 @@
 import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.MediaFormat;
 import com.google.android.exoplayer.extractor.TrackOutput;
-import com.google.android.exoplayer.util.CodecSpecificDataUtil;
-import com.google.android.exoplayer.util.CodecSpecificDataUtil.SpsData;
 import com.google.android.exoplayer.util.MimeTypes;
 import com.google.android.exoplayer.util.NalUnitUtil;
+import com.google.android.exoplayer.util.NalUnitUtil.SpsData;
 import com.google.android.exoplayer.util.ParsableBitArray;
 import com.google.android.exoplayer.util.ParsableByteArray;
 
+import android.util.SparseArray;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -34,15 +35,9 @@
  */
 /* package */ final class H264Reader extends ElementaryStreamReader {
 
-  private static final int FRAME_TYPE_I = 2;
-  private static final int FRAME_TYPE_ALL_I = 7;
-
-  private static final int NAL_UNIT_TYPE_IFR = 1; // Coded slice of a non-IDR picture
-  private static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
   private static final int NAL_UNIT_TYPE_SEI = 6; // Supplemental enhancement information
   private static final int NAL_UNIT_TYPE_SPS = 7; // Sequence parameter set
   private static final int NAL_UNIT_TYPE_PPS = 8; // Picture parameter set
-  private static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
 
   // State that should not be reset on seek.
   private boolean hasOutputFormat;
@@ -50,29 +45,32 @@
   // State that should be reset on seek.
   private final SeiReader seiReader;
   private final boolean[] prefixFlags;
-  private final IfrParserBuffer ifrParserBuffer;
+  private final SampleReader sampleReader;
   private final NalUnitTargetBuffer sps;
   private final NalUnitTargetBuffer pps;
   private final NalUnitTargetBuffer sei;
-  private boolean foundFirstSample;
   private long totalBytesWritten;
 
   // Per packet state that gets reset at the start of each packet.
   private long pesTimeUs;
 
-  // Per sample state that gets reset at the start of each sample.
-  private boolean isKeyframe;
-  private long samplePosition;
-  private long sampleTimeUs;
-
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
-  public H264Reader(TrackOutput output, SeiReader seiReader, boolean allowNonIdrKeyframes) {
+  /**
+   * @param output A {@link TrackOutput} to which H.264 samples should be written.
+   * @param seiReader A reader for EIA-608 samples in SEI NAL units.
+   * @param allowNonIdrKeyframes Whether to treat samples consisting of non-IDR I slices as
+   *     synchronization samples (key-frames).
+   * @param detectAccessUnits Whether to split the input stream into access units (samples) based on
+   *     slice headers. Pass {@code false} if the stream contains access unit delimiters (AUDs).
+   */
+  public H264Reader(TrackOutput output, SeiReader seiReader, boolean allowNonIdrKeyframes,
+      boolean detectAccessUnits) {
     super(output);
     this.seiReader = seiReader;
     prefixFlags = new boolean[3];
-    ifrParserBuffer = allowNonIdrKeyframes ? new IfrParserBuffer() : null;
+    sampleReader = new SampleReader(output, allowNonIdrKeyframes, detectAccessUnits);
     sps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SPS, 128);
     pps = new NalUnitTargetBuffer(NAL_UNIT_TYPE_PPS, 128);
     sei = new NalUnitTargetBuffer(NAL_UNIT_TYPE_SEI, 128);
@@ -85,10 +83,7 @@ public void seek() {
     sps.reset();
     pps.reset();
     sei.reset();
-    if (ifrParserBuffer != null) {
-      ifrParserBuffer.reset();
-    }
-    foundFirstSample = false;
+    sampleReader.reset();
     totalBytesWritten = 0;
   }
 
@@ -114,7 +109,7 @@ public void consume(ParsableByteArray data) {
 
         if (nalUnitOffset == limit) {
           // We've scanned to the end of the data without finding the start of another NAL unit.
-          feedNalUnitTargetBuffersData(dataArray, offset, limit);
+          nalUnitData(dataArray, offset, limit);
           return;
         }
 
@@ -125,42 +120,17 @@ public void consume(ParsableByteArray data) {
         // It may be negative if the NAL unit started in the previously consumed data.
         int lengthToNalUnit = nalUnitOffset - offset;
         if (lengthToNalUnit > 0) {
-          feedNalUnitTargetBuffersData(dataArray, offset, nalUnitOffset);
-        }
-
-        switch (nalUnitType) {
-          case NAL_UNIT_TYPE_IDR:
-            isKeyframe = true;
-            break;
-          case NAL_UNIT_TYPE_AUD:
-            int bytesWrittenPastNalUnit = limit - nalUnitOffset;
-            if (foundFirstSample) {
-              if (ifrParserBuffer != null && ifrParserBuffer.isCompleted()) {
-                int sliceType = ifrParserBuffer.getSliceType();
-                isKeyframe |= (sliceType == FRAME_TYPE_I || sliceType == FRAME_TYPE_ALL_I);
-                ifrParserBuffer.reset();
-              }
-              if (isKeyframe && !hasOutputFormat && sps.isCompleted() && pps.isCompleted()) {
-                output.format(parseMediaFormat(sps, pps));
-                hasOutputFormat = true;
-              }
-              int flags = isKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
-              int size = (int) (totalBytesWritten - samplePosition) - bytesWrittenPastNalUnit;
-              output.sampleMetadata(sampleTimeUs, flags, size, bytesWrittenPastNalUnit, null);
-            }
-            foundFirstSample = true;
-            samplePosition = totalBytesWritten - bytesWrittenPastNalUnit;
-            sampleTimeUs = pesTimeUs;
-            isKeyframe = false;
-            break;
+          nalUnitData(dataArray, offset, nalUnitOffset);
         }
-
+        int bytesWrittenPastPosition = limit - nalUnitOffset;
+        long absolutePosition = totalBytesWritten - bytesWrittenPastPosition;
         // Indicate the end of the previous NAL unit. If the length to the start of the next unit
         // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
         // when notifying that the unit has ended.
-        feedNalUnitTargetEnd(pesTimeUs, lengthToNalUnit < 0 ? -lengthToNalUnit : 0);
+        endNalUnit(absolutePosition, bytesWrittenPastPosition,
+            lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
         // Indicate the start of the next NAL unit.
-        feedNalUnitTargetBuffersStart(nalUnitType);
+        startNalUnit(absolutePosition, nalUnitType, pesTimeUs);
         // Continue scanning the data.
         offset = nalUnitOffset + 3;
       }
@@ -172,99 +142,153 @@ public void packetFinished() {
     // Do nothing.
   }
 
-  private void feedNalUnitTargetBuffersStart(int nalUnitType) {
-    if (ifrParserBuffer != null) {
-      ifrParserBuffer.startNalUnit(nalUnitType);
-    }
-    if (!hasOutputFormat) {
+  private void startNalUnit(long position, int nalUnitType, long pesTimeUs) {
+    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
       sps.startNalUnit(nalUnitType);
       pps.startNalUnit(nalUnitType);
     }
     sei.startNalUnit(nalUnitType);
+    sampleReader.startNalUnit(position, nalUnitType, pesTimeUs);
   }
 
-  private void feedNalUnitTargetBuffersData(byte[] dataArray, int offset, int limit) {
-    if (ifrParserBuffer != null) {
-      ifrParserBuffer.appendToNalUnit(dataArray, offset, limit);
-    }
-    if (!hasOutputFormat) {
+  private void nalUnitData(byte[] dataArray, int offset, int limit) {
+    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
       sps.appendToNalUnit(dataArray, offset, limit);
       pps.appendToNalUnit(dataArray, offset, limit);
     }
     sei.appendToNalUnit(dataArray, offset, limit);
+    sampleReader.appendToNalUnit(dataArray, offset, limit);
   }
 
-  private void feedNalUnitTargetEnd(long pesTimeUs, int discardPadding) {
-    sps.endNalUnit(discardPadding);
-    pps.endNalUnit(discardPadding);
+  private void endNalUnit(long position, int offset, int discardPadding, long pesTimeUs) {
+    if (!hasOutputFormat || sampleReader.needsSpsPps()) {
+      sps.endNalUnit(discardPadding);
+      pps.endNalUnit(discardPadding);
+      if (!hasOutputFormat) {
+        if (sps.isCompleted() && pps.isCompleted()) {
+          List<byte[]> initializationData = new ArrayList<>();
+          initializationData.add(Arrays.copyOf(sps.nalData, sps.nalLength));
+          initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
+          NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(unescape(sps));
+          NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(unescape(pps));
+          output.format(MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_H264,
+              MediaFormat.NO_VALUE, MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, spsData.width,
+              spsData.height, initializationData, MediaFormat.NO_VALUE,
+              spsData.pixelWidthAspectRatio));
+          hasOutputFormat = true;
+          sampleReader.putSps(spsData);
+          sampleReader.putPps(ppsData);
+          sps.reset();
+          pps.reset();
+        }
+      } else if (sps.isCompleted()) {
+        NalUnitUtil.SpsData spsData = NalUnitUtil.parseSpsNalUnit(unescape(sps));
+        sampleReader.putSps(spsData);
+        sps.reset();
+      } else if (pps.isCompleted()) {
+        NalUnitUtil.PpsData ppsData = NalUnitUtil.parsePpsNalUnit(unescape(pps));
+        sampleReader.putPps(ppsData);
+        pps.reset();
+      }
+    }
     if (sei.endNalUnit(discardPadding)) {
       int unescapedLength = NalUnitUtil.unescapeStream(sei.nalData, sei.nalLength);
       seiWrapper.reset(sei.nalData, unescapedLength);
       seiWrapper.setPosition(4); // NAL prefix and nal_unit() header.
       seiReader.consume(pesTimeUs, seiWrapper);
     }
+    sampleReader.endNalUnit(position, offset);
   }
 
-  private static MediaFormat parseMediaFormat(NalUnitTargetBuffer sps, NalUnitTargetBuffer pps) {
-    List<byte[]> initializationData = new ArrayList<>();
-    initializationData.add(Arrays.copyOf(sps.nalData, sps.nalLength));
-    initializationData.add(Arrays.copyOf(pps.nalData, pps.nalLength));
-
-    // Unescape and parse the SPS unit.
-    NalUnitUtil.unescapeStream(sps.nalData, sps.nalLength);
-    ParsableBitArray bitArray = new ParsableBitArray(sps.nalData);
+  private static ParsableBitArray unescape(NalUnitTargetBuffer buffer) {
+    int length = NalUnitUtil.unescapeStream(buffer.nalData, buffer.nalLength);
+    ParsableBitArray bitArray = new ParsableBitArray(buffer.nalData, length);
     bitArray.skipBits(32); // NAL header
-    SpsData parsedSpsData = CodecSpecificDataUtil.parseSpsNalUnit(bitArray);
-
-    return MediaFormat.createVideoFormat(null, MimeTypes.VIDEO_H264, MediaFormat.NO_VALUE,
-        MediaFormat.NO_VALUE, C.UNKNOWN_TIME_US, parsedSpsData.width, parsedSpsData.height,
-        initializationData, MediaFormat.NO_VALUE, parsedSpsData.pixelWidthAspectRatio);
+    return bitArray;
   }
 
   /**
-   * A buffer specifically for IFR units that can be used to parse the IFR's slice type.
+   * Consumes a stream of NAL units and outputs samples.
    */
-  private static final class IfrParserBuffer {
+  private static final class SampleReader {
 
     private static final int DEFAULT_BUFFER_SIZE = 128;
-    private static final int NOT_SET = -1;
 
-    private final ParsableBitArray scratchSliceType;
+    private static final int NAL_UNIT_TYPE_NON_IDR = 1; // Coded slice of a non-IDR picture
+    private static final int NAL_UNIT_TYPE_PARTITION_A = 2; // Coded slice data partition A
+    private static final int NAL_UNIT_TYPE_IDR = 5; // Coded slice of an IDR picture
+    private static final int NAL_UNIT_TYPE_AUD = 9; // Access unit delimiter
 
-    private byte[] ifrData;
-    private int ifrLength;
-    private boolean isFilling;
-    private int sliceType;
+    private final TrackOutput output;
+    private final boolean allowNonIdrKeyframes;
+    private final boolean detectAccessUnits;
+    private final ParsableBitArray scratch;
+    private final SparseArray<NalUnitUtil.SpsData> sps;
+    private final SparseArray<NalUnitUtil.PpsData> pps;
+
+    private byte[] buffer;
+    private int bufferLength;
 
-    public IfrParserBuffer() {
-      ifrData = new byte[DEFAULT_BUFFER_SIZE];
-      scratchSliceType = new ParsableBitArray(ifrData);
+    // Per NAL unit state. A sample consists of one or more NAL units.
+    private int nalUnitType;
+    private long nalUnitStartPosition;
+    private boolean isFilling;
+    private long nalUnitTimeUs;
+    private SliceHeaderData previousSliceHeader;
+    private SliceHeaderData sliceHeader;
+
+    // Per sample state that gets reset at the start of each sample.
+    private boolean readingSample;
+    private long samplePosition;
+    private long sampleTimeUs;
+    private boolean sampleIsKeyframe;
+
+    public SampleReader(TrackOutput output, boolean allowNonIdrKeyframes,
+        boolean detectAccessUnits) {
+      this.output = output;
+      this.allowNonIdrKeyframes = allowNonIdrKeyframes;
+      this.detectAccessUnits = detectAccessUnits;
+      sps = new SparseArray<>();
+      pps = new SparseArray<>();
+      previousSliceHeader = new SliceHeaderData();
+      sliceHeader = new SliceHeaderData();
+      scratch = new ParsableBitArray();
+      buffer = new byte[DEFAULT_BUFFER_SIZE];
       reset();
     }
 
-    /**
-     * Resets the buffer, clearing any data that it holds.
-     */
-    public void reset() {
-      isFilling = false;
-      ifrLength = 0;
-      sliceType = NOT_SET;
+    public boolean needsSpsPps() {
+      return detectAccessUnits;
     }
 
-    /**
-     * True if enough data was added to the buffer that the slice type was determined.
-     */
-    public boolean isCompleted() {
-      return sliceType != NOT_SET;
+    public void putSps(NalUnitUtil.SpsData spsData) {
+      sps.append(spsData.seqParameterSetId, spsData);
     }
 
-    /**
-     * Invoked to indicate that a NAL unit has started, and if it is an IFR then the buffer will
-     * start.
-     */
-    public void startNalUnit(int nalUnitType) {
-      if (nalUnitType == NAL_UNIT_TYPE_IFR) {
-        reset();
+    public void putPps(NalUnitUtil.PpsData ppsData) {
+      pps.append(ppsData.picParameterSetId, ppsData);
+    }
+
+    public void reset() {
+      isFilling = false;
+      readingSample = false;
+      sliceHeader.clear();
+    }
+
+    public void startNalUnit(long position, int type, long pesTimeUs) {
+      nalUnitType = type;
+      nalUnitTimeUs = pesTimeUs;
+      nalUnitStartPosition = position;
+      if ((allowNonIdrKeyframes && nalUnitType == NAL_UNIT_TYPE_NON_IDR)
+          || (detectAccessUnits && (nalUnitType == NAL_UNIT_TYPE_IDR
+              || nalUnitType == NAL_UNIT_TYPE_NON_IDR
+              || nalUnitType == NAL_UNIT_TYPE_PARTITION_A))) {
+        // Store the previous header and prepare to populate the new one.
+        SliceHeaderData newSliceHeader = previousSliceHeader;
+        previousSliceHeader = sliceHeader;
+        sliceHeader = newSliceHeader;
+        sliceHeader.clear();
+        bufferLength = 0;
         isFilling = true;
       }
     }
@@ -281,38 +305,214 @@ public void appendToNalUnit(byte[] data, int offset, int limit) {
         return;
       }
       int readLength = limit - offset;
-      if (ifrData.length < ifrLength + readLength) {
-        ifrData = Arrays.copyOf(ifrData, (ifrLength + readLength) * 2);
+      if (buffer.length < bufferLength + readLength) {
+        buffer = Arrays.copyOf(buffer, (bufferLength + readLength) * 2);
       }
-      System.arraycopy(data, offset, ifrData, ifrLength, readLength);
-      ifrLength += readLength;
-
-      scratchSliceType.reset(ifrData, ifrLength);
-      scratchSliceType.skipBits(8);
-      // first_mb_in_slice
-      int len = scratchSliceType.peekExpGolombCodedNumLength();
-      if ((len == -1) || (len > scratchSliceType.bitsLeft())) {
-        // Not enough yet
+      System.arraycopy(data, offset, buffer, bufferLength, readLength);
+      bufferLength += readLength;
+
+      scratch.reset(buffer, bufferLength);
+      if (scratch.bitsLeft() < 8) {
         return;
       }
+      scratch.skipBits(1); // forbidden_zero_bit
+      int nalRefIdc = scratch.readBits(2);
+      scratch.skipBits(5); // nal_unit_type
 
-      scratchSliceType.skipBits(len);
-      // slice_type
-      len = scratchSliceType.peekExpGolombCodedNumLength();
-      if ((len == -1) || (len > scratchSliceType.bitsLeft())) {
-        // Not enough yet
+      // Read the slice header using the syntax defined in ITU-T Recommendation H.264 (2013)
+      // subsection 7.3.3.
+      if (!scratch.canReadExpGolombCodedNum()) {
         return;
       }
-      sliceType = scratchSliceType.readUnsignedExpGolombCodedInt();
-
+      scratch.readUnsignedExpGolombCodedInt(); // first_mb_in_slice
+      if (!scratch.canReadExpGolombCodedNum()) {
+        return;
+      }
+      int sliceType = scratch.readUnsignedExpGolombCodedInt();
+      if (!detectAccessUnits) {
+        // There are AUDs in the stream so the rest of the header can be ignored.
+        isFilling = false;
+        sliceHeader.setSliceType(sliceType);
+        return;
+      }
+      if (!scratch.canReadExpGolombCodedNum()) {
+        return;
+      }
+      int picParameterSetId = scratch.readUnsignedExpGolombCodedInt();
+      if (pps.indexOfKey(picParameterSetId) < 0) {
+        // We have not seen the PPS yet, so don't try to parse the slice header.
+        isFilling = false;
+        return;
+      }
+      NalUnitUtil.PpsData ppsData = pps.get(picParameterSetId);
+      NalUnitUtil.SpsData spsData = sps.get(ppsData.seqParameterSetId);
+      if (spsData.separateColorPlaneFlag) {
+        if (scratch.bitsLeft() < 2) {
+          return;
+        }
+        scratch.skipBits(2); // colour_plane_id
+      }
+      if (scratch.bitsLeft() < spsData.frameNumLength) {
+        return;
+      }
+      boolean fieldPicFlag = false;
+      boolean bottomFieldFlagPresent = false;
+      boolean bottomFieldFlag = false;
+      int frameNum = scratch.readBits(spsData.frameNumLength);
+      if (!spsData.frameMbsOnlyFlag) {
+        if (scratch.bitsLeft() < 1) {
+          return;
+        }
+        fieldPicFlag = scratch.readBit();
+        if (fieldPicFlag) {
+          if (scratch.bitsLeft() < 1) {
+            return;
+          }
+          bottomFieldFlag = scratch.readBit();
+          bottomFieldFlagPresent = true;
+        }
+      }
+      boolean idrPicFlag = nalUnitType == NAL_UNIT_TYPE_IDR;
+      int idrPicId = 0;
+      if (idrPicFlag) {
+        if (!scratch.canReadExpGolombCodedNum()) {
+          return;
+        }
+        idrPicId = scratch.readUnsignedExpGolombCodedInt();
+      }
+      int picOrderCntLsb = 0;
+      int deltaPicOrderCntBottom = 0;
+      int deltaPicOrderCnt0 = 0;
+      int deltaPicOrderCnt1 = 0;
+      if (spsData.picOrderCountType == 0) {
+        if (scratch.bitsLeft() < spsData.picOrderCntLsbLength) {
+          return;
+        }
+        picOrderCntLsb = scratch.readBits(spsData.picOrderCntLsbLength);
+        if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
+          if (!scratch.canReadExpGolombCodedNum()) {
+            return;
+          }
+          deltaPicOrderCntBottom = scratch.readSignedExpGolombCodedInt();
+        }
+      } else if (spsData.picOrderCountType == 1
+          && !spsData.deltaPicOrderAlwaysZeroFlag) {
+        if (!scratch.canReadExpGolombCodedNum()) {
+          return;
+        }
+        deltaPicOrderCnt0 = scratch.readSignedExpGolombCodedInt();
+        if (ppsData.bottomFieldPicOrderInFramePresentFlag && !fieldPicFlag) {
+          if (!scratch.canReadExpGolombCodedNum()) {
+            return;
+          }
+          deltaPicOrderCnt1 = scratch.readSignedExpGolombCodedInt();
+        }
+      }
+      sliceHeader.setAll(spsData, nalRefIdc, sliceType, frameNum, picParameterSetId, fieldPicFlag,
+          bottomFieldFlagPresent, bottomFieldFlag, idrPicFlag, idrPicId, picOrderCntLsb,
+          deltaPicOrderCntBottom, deltaPicOrderCnt0, deltaPicOrderCnt1);
       isFilling = false;
     }
 
-    /**
-     * @return the slice type of the IFR.
-     */
-    public int getSliceType() {
-      return sliceType;
+    public void endNalUnit(long position, int offset) {
+      if (nalUnitType == NAL_UNIT_TYPE_AUD
+          || (detectAccessUnits && sliceHeader.isFirstVclNalUnitOfPicture(previousSliceHeader))) {
+        // If the NAL unit ending is the start of a new sample, output the previous one.
+        if (readingSample) {
+          int nalUnitLength = (int) (position - nalUnitStartPosition);
+          outputSample(offset + nalUnitLength);
+        }
+        samplePosition = nalUnitStartPosition;
+        sampleTimeUs = nalUnitTimeUs;
+        sampleIsKeyframe = false;
+        readingSample = true;
+      }
+      sampleIsKeyframe |= nalUnitType == NAL_UNIT_TYPE_IDR || (allowNonIdrKeyframes
+          && nalUnitType == NAL_UNIT_TYPE_NON_IDR && sliceHeader.isISlice());
+    }
+
+    private void outputSample(int offset) {
+      int flags = sampleIsKeyframe ? C.SAMPLE_FLAG_SYNC : 0;
+      int size = (int) (nalUnitStartPosition - samplePosition);
+      output.sampleMetadata(sampleTimeUs, flags, size, offset, null);
+    }
+
+    private static final class SliceHeaderData {
+
+      private static final int SLICE_TYPE_I = 2;
+      private static final int SLICE_TYPE_ALL_I = 7;
+
+      private boolean isComplete;
+      private boolean hasSliceType;
+
+      private SpsData spsData;
+      private int nalRefIdc;
+      private int sliceType;
+      private int frameNum;
+      private int picParameterSetId;
+      private boolean fieldPicFlag;
+      private boolean bottomFieldFlagPresent;
+      private boolean bottomFieldFlag;
+      private boolean idrPicFlag;
+      private int idrPicId;
+      private int picOrderCntLsb;
+      private int deltaPicOrderCntBottom;
+      private int deltaPicOrderCnt0;
+      private int deltaPicOrderCnt1;
+
+      public void clear() {
+        hasSliceType = false;
+        isComplete = false;
+      }
+
+      public void setSliceType(int sliceType) {
+        this.sliceType = sliceType;
+        hasSliceType = true;
+      }
+
+      public void setAll(SpsData spsData, int nalRefIdc, int sliceType, int frameNum,
+          int picParameterSetId, boolean fieldPicFlag, boolean bottomFieldFlagPresent,
+          boolean bottomFieldFlag, boolean idrPicFlag, int idrPicId, int picOrderCntLsb,
+          int deltaPicOrderCntBottom, int deltaPicOrderCnt0, int deltaPicOrderCnt1) {
+        this.spsData = spsData;
+        this.nalRefIdc = nalRefIdc;
+        this.sliceType = sliceType;
+        this.frameNum = frameNum;
+        this.picParameterSetId = picParameterSetId;
+        this.fieldPicFlag = fieldPicFlag;
+        this.bottomFieldFlagPresent = bottomFieldFlagPresent;
+        this.bottomFieldFlag = bottomFieldFlag;
+        this.idrPicFlag = idrPicFlag;
+        this.idrPicId = idrPicId;
+        this.picOrderCntLsb = picOrderCntLsb;
+        this.deltaPicOrderCntBottom = deltaPicOrderCntBottom;
+        this.deltaPicOrderCnt0 = deltaPicOrderCnt0;
+        this.deltaPicOrderCnt1 = deltaPicOrderCnt1;
+        isComplete = true;
+        hasSliceType = true;
+      }
+
+      public boolean isISlice() {
+        return hasSliceType && (sliceType == SLICE_TYPE_ALL_I || sliceType == SLICE_TYPE_I);
+      }
+
+      private boolean isFirstVclNalUnitOfPicture(SliceHeaderData other) {
+        // See ISO 14496-10 subsection 7.4.1.2.4.
+        return isComplete && (!other.isComplete || frameNum != other.frameNum
+            || picParameterSetId != other.picParameterSetId || fieldPicFlag != other.fieldPicFlag
+            || (bottomFieldFlagPresent && other.bottomFieldFlagPresent
+                && bottomFieldFlag != other.bottomFieldFlag)
+            || (nalRefIdc != other.nalRefIdc && (nalRefIdc == 0 || other.nalRefIdc == 0))
+            || (spsData.picOrderCountType == 0 && other.spsData.picOrderCountType == 0
+                && (picOrderCntLsb != other.picOrderCntLsb
+                    || deltaPicOrderCntBottom != other.deltaPicOrderCntBottom))
+            || (spsData.picOrderCountType == 1 && other.spsData.picOrderCountType == 1
+                && (deltaPicOrderCnt0 != other.deltaPicOrderCnt0
+                    || deltaPicOrderCnt1 != other.deltaPicOrderCnt1))
+            || idrPicFlag != other.idrPicFlag
+            || (idrPicFlag && other.idrPicFlag && idrPicId != other.idrPicId));
+      }
+
     }
 
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
index 6031dc7a01..2c1e6e0635 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/H265Reader.java
@@ -64,6 +64,10 @@
   // Scratch variables to avoid allocations.
   private final ParsableByteArray seiWrapper;
 
+  /**
+   * @param output A {@link TrackOutput} to which H.265 samples should be written.
+   * @param seiReader A reader for EIA-608 samples in SEI NAL units.
+   */
   public H265Reader(TrackOutput output, SeiReader seiReader) {
     super(output);
     this.seiReader = seiReader;
@@ -130,7 +134,7 @@ public void consume(ParsableByteArray data) {
         // Indicate the end of the previous NAL unit. If the length to the start of the next unit
         // is negative then we wrote too many bytes to the NAL buffers. Discard the excess bytes
         // when notifying that the unit has ended.
-        nalUnitEnd(absolutePosition, bytesWrittenPastPosition,
+        endNalUnit(absolutePosition, bytesWrittenPastPosition,
             lengthToNalUnit < 0 ? -lengthToNalUnit : 0, pesTimeUs);
         // Indicate the start of the next NAL unit.
         startNalUnit(absolutePosition, bytesWrittenPastPosition, nalUnitType, pesTimeUs);
@@ -168,7 +172,7 @@ private void nalUnitData(byte[] dataArray, int offset, int limit) {
     suffixSei.appendToNalUnit(dataArray, offset, limit);
   }
 
-  private void nalUnitEnd(long position, int offset, int discardPadding, long pesTimeUs) {
+  private void endNalUnit(long position, int offset, int discardPadding, long pesTimeUs) {
     if (hasOutputFormat) {
       sampleReader.endNalUnit(position, offset);
     } else {
@@ -218,10 +222,10 @@ private static MediaFormat parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTarg
     bitArray.skipBits(8); // general_level_idc
     int toSkip = 0;
     for (int i = 0; i < maxSubLayersMinus1; i++) {
-      if (bitArray.readBits(1) == 1) { // sub_layer_profile_present_flag[i]
+      if (bitArray.readBit()) { // sub_layer_profile_present_flag[i]
         toSkip += 89;
       }
-      if (bitArray.readBits(1) == 1) { // sub_layer_level_present_flag[i]
+      if (bitArray.readBit()) { // sub_layer_level_present_flag[i]
         toSkip += 8;
       }
     }
@@ -309,7 +313,9 @@ private static MediaFormat parseMediaFormat(NalUnitTargetBuffer vps, NalUnitTarg
         Collections.singletonList(csd), MediaFormat.NO_VALUE, pixelWidthHeightRatio);
   }
 
-  /** Skips scaling_list_data(). See H.265/HEVC (2014) 7.3.4. */
+  /**
+   * Skips scaling_list_data(). See H.265/HEVC (2014) 7.3.4.
+   */
   private static void skipScalingList(ParsableBitArray bitArray) {
     for (int sizeId = 0; sizeId < 4; sizeId++) {
       for (int matrixId = 0; matrixId < 6; matrixId += sizeId == 3 ? 3 : 1) {
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
index 815b288a02..476bc26f25 100644
--- a/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java
@@ -40,6 +40,7 @@
   public static final int WORKAROUND_ALLOW_NON_IDR_KEYFRAMES = 1;
   public static final int WORKAROUND_IGNORE_AAC_STREAM = 2;
   public static final int WORKAROUND_IGNORE_H264_STREAM = 4;
+  public static final int WORKAROUND_DETECT_ACCESS_UNITS = 8;
 
   private static final String TAG = "TsExtractor";
 
@@ -362,7 +363,8 @@ public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator,
             pesPayloadReader = (workaroundFlags & WORKAROUND_IGNORE_H264_STREAM) != 0 ? null
                 : new H264Reader(output.track(TS_STREAM_TYPE_H264),
                     new SeiReader(output.track(TS_STREAM_TYPE_EIA608)),
-                    (workaroundFlags & WORKAROUND_ALLOW_NON_IDR_KEYFRAMES) != 0);
+                    (workaroundFlags & WORKAROUND_ALLOW_NON_IDR_KEYFRAMES) != 0,
+                    (workaroundFlags & WORKAROUND_DETECT_ACCESS_UNITS) != 0);
             break;
           case TS_STREAM_TYPE_H265:
             pesPayloadReader = new H265Reader(output.track(TS_STREAM_TYPE_H265),
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
new file mode 100644
index 0000000000..f193c0e622
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavExtractor.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.wav;
+
+import com.google.android.exoplayer.C;
+import com.google.android.exoplayer.MediaFormat;
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.Extractor;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.extractor.ExtractorOutput;
+import com.google.android.exoplayer.extractor.PositionHolder;
+import com.google.android.exoplayer.extractor.SeekMap;
+import com.google.android.exoplayer.extractor.TrackOutput;
+import com.google.android.exoplayer.util.MimeTypes;
+
+import java.io.IOException;
+
+/** {@link Extractor} to extract samples from a WAV byte stream. */
+public final class WavExtractor implements Extractor, SeekMap {
+
+  /** Arbitrary maximum input size of 32KB, which is ~170ms of 16-bit stereo PCM audio at 48KHz. */
+  private static final int MAX_INPUT_SIZE = 32 * 1024;
+
+  private ExtractorOutput extractorOutput;
+  private TrackOutput trackOutput;
+  private WavHeader wavHeader;
+
+  @Override
+  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {
+    return WavHeaderReader.peek(input) != null;
+  }
+
+  @Override
+  public void init(ExtractorOutput output) {
+    extractorOutput = output;
+    trackOutput = output.track(0);
+    wavHeader = null;
+    output.endTracks();
+  }
+
+  @Override
+  public void seek() {
+    // Do nothing.
+  }
+
+  @Override
+  public int read(ExtractorInput input, PositionHolder seekPosition)
+      throws IOException, InterruptedException {
+
+    if (wavHeader == null) {
+      wavHeader = WavHeaderReader.peek(input);
+      if (wavHeader == null) {
+        // Someone tried to read a non-WAV or unsupported WAV without sniffing first.
+        throw new ParserException("Error initializing WavHeader. Did you sniff first?");
+      }
+    }
+
+    // If we haven't read in the data start and size, read and store them.
+    if (!wavHeader.hasDataBounds()) {
+      WavHeaderReader.skipToData(input, wavHeader);
+
+      trackOutput.format(
+          MediaFormat.createAudioFormat(
+              null,
+              MimeTypes.AUDIO_RAW,
+              wavHeader.getBitrate(),
+              MAX_INPUT_SIZE,
+              wavHeader.getDurationUs(),
+              wavHeader.getNumChannels(),
+              wavHeader.getSampleRateHz(),
+              null,
+              null));
+      extractorOutput.seekMap(this);
+    }
+
+    long inputPosition = input.getPosition();
+
+    int bytesRead = trackOutput.sampleData(input, MAX_INPUT_SIZE, true);
+    if (bytesRead == RESULT_END_OF_INPUT) {
+      return RESULT_END_OF_INPUT;
+    }
+    trackOutput.sampleMetadata(
+        wavHeader.getTimeUs(inputPosition), C.SAMPLE_FLAG_SYNC, bytesRead, 0, null);
+
+    return RESULT_CONTINUE;
+  }
+
+  // SeekMap implementation.
+
+  @Override
+  public boolean isSeekable() {
+    return true;
+  }
+
+  @Override
+  public long getPosition(long timeUs) {
+    return wavHeader.getPosition(timeUs);
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
new file mode 100644
index 0000000000..5e0d1afeb6
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeader.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.wav;
+
+import com.google.android.exoplayer.C;
+
+/** Header for a WAV file. */
+/*package*/ final class WavHeader {
+
+  /** Number of audio chanels. */
+  private final int numChannels;
+  /** Sample rate in Hertz. */
+  private final int sampleRateHz;
+  /** Average bytes per second for the sample data. */
+  private final int averageBytesPerSecond;
+  /** Alignment for frames of audio data; should equal {@code numChannels * bitsPerSample / 8}. */
+  private final int blockAlignment;
+  /** Bits per sample for the audio data. */
+  private final int bitsPerSample;
+  /** Offset to the start of sample data. */
+  private long dataStartPosition;
+  /** Total size in bytes of the sample data. */
+  private long dataSize;
+
+  public WavHeader(
+      int numChannels,
+      int sampleRateHz,
+      int averageBytesPerSecond,
+      int blockAlignment,
+      int bitsPerSample) {
+    this.numChannels = numChannels;
+    this.sampleRateHz = sampleRateHz;
+    this.averageBytesPerSecond = averageBytesPerSecond;
+    this.blockAlignment = blockAlignment;
+    this.bitsPerSample = bitsPerSample;
+  }
+
+  /** Returns the duration in microseconds of this WAV. */
+  public long getDurationUs() {
+    return (getNumFrames() * C.MICROS_PER_SECOND) / sampleRateHz;
+  }
+
+  /** Returns the number of samples in this WAV. */
+  public long getNumSamples() {
+    return dataSize / getBytesPerSample();
+  }
+
+  /** Returns the number of frames in this WAV. */
+  public long getNumFrames() {
+    return getNumSamples() / getNumChannels();
+  }
+
+  /** Returns the bytes per sample of this WAV. */
+  public int getBytesPerSample() {
+    return blockAlignment / numChannels;
+  }
+
+  /** Returns the bitrate of this WAV. */
+  public int getBitrate() {
+    return sampleRateHz * bitsPerSample * numChannels;
+  }
+
+  /** Returns the sample rate in Hertz of this WAV. */
+  public int getSampleRateHz() {
+    return sampleRateHz;
+  }
+
+  /** Returns the number of audio channels in this WAV. */
+  public int getNumChannels() {
+    return numChannels;
+  }
+
+  /** Returns the position in bytes in this WAV for the given time in microseconds. */
+  public long getPosition(long timeUs) {
+    long unroundedPosition = (timeUs * averageBytesPerSecond) / C.MICROS_PER_SECOND;
+    // Round down to nearest frame.
+    return (unroundedPosition / numChannels) * numChannels + dataStartPosition;
+  }
+
+  /** Returns the time in microseconds for the given position in bytes in this WAV. */
+  public long getTimeUs(long position) {
+    return position * C.MICROS_PER_SECOND / averageBytesPerSecond;
+  }
+
+  /** Returns true if the data start position and size have been set. */
+  public boolean hasDataBounds() {
+    return dataStartPosition != 0 && dataSize != 0;
+  }
+
+  /** Sets the start position and size in bytes of sample data in this WAV. */
+  public void setDataBounds(long dataStartPosition, long dataSize) {
+    this.dataStartPosition = dataStartPosition;
+    this.dataSize = dataSize;
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
new file mode 100644
index 0000000000..7f15d89398
--- /dev/null
+++ b/library/src/main/java/com/google/android/exoplayer/extractor/wav/WavHeaderReader.java
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.exoplayer.extractor.wav;
+
+import com.google.android.exoplayer.ParserException;
+import com.google.android.exoplayer.extractor.ExtractorInput;
+import com.google.android.exoplayer.util.Assertions;
+import com.google.android.exoplayer.util.ParsableByteArray;
+import com.google.android.exoplayer.util.Util;
+
+import android.util.Log;
+
+import java.io.IOException;
+
+/** Reads a {@code WavHeader} from an input stream; supports resuming from input failures. */
+/*package*/ final class WavHeaderReader {
+
+  private static final String TAG = "WavHeaderReader";
+
+  /** Integer PCM audio data. */
+  private static final int TYPE_PCM = 0x0001;
+  /** Extended WAVE format. */
+  private static final int TYPE_WAVE_FORMAT_EXTENSIBLE = 0xFFFE;
+
+  /**
+   * Peeks and returns a {@code WavHeader}.
+   *
+   * @param input Input stream to peek the WAV header from.
+   * @throws IOException If peeking from the input fails.
+   * @throws InterruptedException If interrupted while peeking from input.
+   * @throws ParserException If the input file is an incorrect RIFF WAV.
+   * @return A new {@code WavHeader} peeked from {@code input}, or null if the input is not a
+   *     supported WAV format.
+   */
+  public static WavHeader peek(ExtractorInput input)
+      throws IOException, InterruptedException, ParserException {
+    Assertions.checkNotNull(input);
+
+    // Allocate a scratch buffer large enough to store the format chunk.
+    ParsableByteArray scratch = new ParsableByteArray(16);
+
+    // Attempt to read the RIFF chunk.
+    ChunkHeader riffChunkHeader = ChunkHeader.peek(input, scratch);
+    if (riffChunkHeader.id != Util.getIntegerCodeForString("RIFF")) {
+      return null;
+    }
+
+    input.peekFully(scratch.data, 0, 4);
+    scratch.setPosition(0);
+    int riffFormat = scratch.readInt();
+    if (riffFormat != Util.getIntegerCodeForString("WAVE")) {
+      Log.e(TAG, "Unsupported RIFF format: " + riffFormat);
+      return null;
+    }
+
+    // Attempt to read the format chunk.
+    ChunkHeader formatChunkHeader = ChunkHeader.peek(input, scratch);
+    if (formatChunkHeader.id != Util.getIntegerCodeForString("fmt ")) {
+      throw new ParserException(
+          "Second chunk in RIFF WAV should be format; got: " + formatChunkHeader.id);
+    }
+
+    input.peekFully(scratch.data, 0, 16);
+    scratch.setPosition(0);
+    int type = scratch.readLittleEndianUnsignedShort();
+    int numChannels = scratch.readLittleEndianUnsignedShort();
+    int sampleRateHz = scratch.readLittleEndianUnsignedIntToInt();
+    int averageBytesPerSecond = scratch.readLittleEndianUnsignedIntToInt();
+    int blockAlignment = scratch.readLittleEndianUnsignedShort();
+    int bitsPerSample = scratch.readLittleEndianUnsignedShort();
+
+    int expectedBlockAlignment = numChannels * bitsPerSample / 8;
+    if (blockAlignment != expectedBlockAlignment) {
+      throw new ParserException(
+          "Expected WAV block alignment of: "
+              + expectedBlockAlignment
+              + "; got: "
+              + blockAlignment);
+    }
+    if (bitsPerSample != 16) {
+      Log.e(TAG, "Only 16-bit WAVs are supported; got: " + bitsPerSample);
+      return null;
+    }
+
+    if (type == TYPE_PCM) {
+      Assertions.checkState(formatChunkHeader.size == 16);
+      // No more data to read.
+    } else if (type == TYPE_WAVE_FORMAT_EXTENSIBLE) {
+      Assertions.checkState(formatChunkHeader.size == 40);
+      // Skip extensionSize, validBitsPerSample, channelMask, subFormatGuid.
+      input.advancePeekPosition(2 + 2 + 4 + 16);
+    } else {
+      Log.e(TAG, "Unsupported WAV format type: " + type);
+      return null;
+    }
+
+    return new WavHeader(
+        numChannels, sampleRateHz, averageBytesPerSecond, blockAlignment, bitsPerSample);
+  }
+
+  /**
+   * Skips to the data in the given WAV input stream and returns its data size. After calling, the
+   * input stream's position will point to the start of sample data in the WAV.
+   * <p>
+   * If an exception is thrown, the input position will be left pointing to a chunk header.
+   *
+   * @param input Input stream to skip to the data chunk in. Its peek position must be pointing to
+   *     a valid chunk header that is not the RIFF chunk.
+   * @param wavHeader WAV header to populate with data bounds.
+   * @throws IOException If reading from the input fails.
+   * @throws InterruptedException If interrupted while reading from input.
+   * @throws ParserException If an error occurs parsing chunks.
+   */
+  public static void skipToData(ExtractorInput input, WavHeader wavHeader)
+      throws IOException, InterruptedException, ParserException {
+    Assertions.checkNotNull(input);
+    Assertions.checkNotNull(wavHeader);
+
+    ParsableByteArray scratch = new ParsableByteArray(ChunkHeader.SIZE_IN_BYTES);
+    // Skip all chunks until we hit the data header.
+    ChunkHeader chunkHeader = ChunkHeader.peek(input, scratch);
+    while (chunkHeader.id != Util.getIntegerCodeForString("data")) {
+      Log.w(TAG, "Ignoring unknown WAV chunk: " + chunkHeader.id);
+      long bytesToSkip = ChunkHeader.SIZE_IN_BYTES + chunkHeader.size;
+      if (bytesToSkip > Integer.MAX_VALUE) {
+        throw new ParserException("Chunk is too large (~2GB+) to skip; id: " + chunkHeader.id);
+      }
+      input.skipFully((int) bytesToSkip);
+      chunkHeader = ChunkHeader.peek(input, scratch);
+    }
+    // Skip past the "data" header.
+    input.skipFully(ChunkHeader.SIZE_IN_BYTES);
+
+    wavHeader.setDataBounds(input.getPosition(), chunkHeader.size);
+  }
+
+  /** Container for a WAV chunk header. */
+  private static final class ChunkHeader {
+
+    /** Size in bytes of a WAV chunk header. */
+    public static final int SIZE_IN_BYTES = 8;
+
+    /** 4-character identifier, stored as an integer, for this chunk. */
+    public final int id;
+    /** Size of this chunk in bytes. */
+    public final long size;
+
+    private ChunkHeader(int id, long size) {
+      this.id = id;
+      this.size = size;
+    }
+
+    /**
+     * Peeks and returns a {@link ChunkHeader}.
+     *
+     * @param input Input stream to peek the chunk header from.
+     * @param scratch Buffer for temporary use.
+     * @throws IOException If peeking from the input fails.
+     * @throws InterruptedException If interrupted while peeking from input.
+     * @return A new {@code ChunkHeader} peeked from {@code input}.
+     */
+    public static ChunkHeader peek(ExtractorInput input, ParsableByteArray scratch)
+        throws IOException, InterruptedException {
+      input.peekFully(scratch.data, 0, SIZE_IN_BYTES);
+      scratch.setPosition(0);
+
+      int id = scratch.readInt();
+      long size = scratch.readLittleEndianUnsignedInt();
+
+      return new ChunkHeader(id, size);
+    }
+  }
+}
diff --git a/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java b/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
index 70a80d7b11..6ba16f0ee1 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/CodecSpecificDataUtil.java
@@ -15,7 +15,6 @@
  */
 package com.google.android.exoplayer.util;
 
-import android.util.Log;
 import android.util.Pair;
 
 import java.util.ArrayList;
@@ -26,23 +25,6 @@
  */
 public final class CodecSpecificDataUtil {
 
-  /**
-   * Holds data parsed from a sequence parameter set NAL unit.
-   */
-  public static final class SpsData {
-
-    public final int width;
-    public final int height;
-    public final float pixelWidthAspectRatio;
-
-    public SpsData(int width, int height, float pixelWidthAspectRatio) {
-      this.width = width;
-      this.height = height;
-      this.pixelWidthAspectRatio = pixelWidthAspectRatio;
-    }
-
-  }
-
   private static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
 
   private static final int AUDIO_SPECIFIC_CONFIG_FREQUENCY_INDEX_ARBITRARY = 0xF;
@@ -94,8 +76,6 @@ public SpsData(int width, int height, float pixelWidthAspectRatio) {
   // Parametric Stereo.
   private static final int AUDIO_OBJECT_TYPE_PS = 29;
 
-  private static final String TAG = "CodecSpecificDataUtil";
-
   private CodecSpecificDataUtil() {}
 
   /**
@@ -267,121 +247,4 @@ private static boolean isNalStartCode(byte[] data, int index) {
     return true;
   }
 
-  /**
-   * Parses an SPS NAL unit.
-   *
-   * @param bitArray A {@link ParsableBitArray} containing the SPS data. The position must to set
-   *     to the start of the data (i.e. the first bit of the profile_idc field).
-   * @return A parsed representation of the SPS data.
-   */
-  public static SpsData parseSpsNalUnit(ParsableBitArray bitArray) {
-    int profileIdc = bitArray.readBits(8);
-    bitArray.skipBits(16); // constraint bits (6), reserved (2) and level_idc (8)
-    bitArray.readUnsignedExpGolombCodedInt(); // seq_parameter_set_id
-
-    int chromaFormatIdc = 1; // Default is 4:2:0
-    if (profileIdc == 100 || profileIdc == 110 || profileIdc == 122 || profileIdc == 244
-        || profileIdc == 44 || profileIdc == 83 || profileIdc == 86 || profileIdc == 118
-        || profileIdc == 128 || profileIdc == 138) {
-      chromaFormatIdc = bitArray.readUnsignedExpGolombCodedInt();
-      if (chromaFormatIdc == 3) {
-        bitArray.skipBits(1); // separate_colour_plane_flag
-      }
-      bitArray.readUnsignedExpGolombCodedInt(); // bit_depth_luma_minus8
-      bitArray.readUnsignedExpGolombCodedInt(); // bit_depth_chroma_minus8
-      bitArray.skipBits(1); // qpprime_y_zero_transform_bypass_flag
-      boolean seqScalingMatrixPresentFlag = bitArray.readBit();
-      if (seqScalingMatrixPresentFlag) {
-        int limit = (chromaFormatIdc != 3) ? 8 : 12;
-        for (int i = 0; i < limit; i++) {
-          boolean seqScalingListPresentFlag = bitArray.readBit();
-          if (seqScalingListPresentFlag) {
-            skipScalingList(bitArray, i < 6 ? 16 : 64);
-          }
-        }
-      }
-    }
-
-    bitArray.readUnsignedExpGolombCodedInt(); // log2_max_frame_num_minus4
-    long picOrderCntType = bitArray.readUnsignedExpGolombCodedInt();
-    if (picOrderCntType == 0) {
-      bitArray.readUnsignedExpGolombCodedInt(); // log2_max_pic_order_cnt_lsb_minus4
-    } else if (picOrderCntType == 1) {
-      bitArray.skipBits(1); // delta_pic_order_always_zero_flag
-      bitArray.readSignedExpGolombCodedInt(); // offset_for_non_ref_pic
-      bitArray.readSignedExpGolombCodedInt(); // offset_for_top_to_bottom_field
-      long numRefFramesInPicOrderCntCycle = bitArray.readUnsignedExpGolombCodedInt();
-      for (int i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
-        bitArray.readUnsignedExpGolombCodedInt(); // offset_for_ref_frame[i]
-      }
-    }
-    bitArray.readUnsignedExpGolombCodedInt(); // max_num_ref_frames
-    bitArray.skipBits(1); // gaps_in_frame_num_value_allowed_flag
-
-    int picWidthInMbs = bitArray.readUnsignedExpGolombCodedInt() + 1;
-    int picHeightInMapUnits = bitArray.readUnsignedExpGolombCodedInt() + 1;
-    boolean frameMbsOnlyFlag = bitArray.readBit();
-    int frameHeightInMbs = (2 - (frameMbsOnlyFlag ? 1 : 0)) * picHeightInMapUnits;
-    if (!frameMbsOnlyFlag) {
-      bitArray.skipBits(1); // mb_adaptive_frame_field_flag
-    }
-
-    bitArray.skipBits(1); // direct_8x8_inference_flag
-    int frameWidth = picWidthInMbs * 16;
-    int frameHeight = frameHeightInMbs * 16;
-    boolean frameCroppingFlag = bitArray.readBit();
-    if (frameCroppingFlag) {
-      int frameCropLeftOffset = bitArray.readUnsignedExpGolombCodedInt();
-      int frameCropRightOffset = bitArray.readUnsignedExpGolombCodedInt();
-      int frameCropTopOffset = bitArray.readUnsignedExpGolombCodedInt();
-      int frameCropBottomOffset = bitArray.readUnsignedExpGolombCodedInt();
-      int cropUnitX, cropUnitY;
-      if (chromaFormatIdc == 0) {
-        cropUnitX = 1;
-        cropUnitY = 2 - (frameMbsOnlyFlag ? 1 : 0);
-      } else {
-        int subWidthC = (chromaFormatIdc == 3) ? 1 : 2;
-        int subHeightC = (chromaFormatIdc == 1) ? 2 : 1;
-        cropUnitX = subWidthC;
-        cropUnitY = subHeightC * (2 - (frameMbsOnlyFlag ? 1 : 0));
-      }
-      frameWidth -= (frameCropLeftOffset + frameCropRightOffset) * cropUnitX;
-      frameHeight -= (frameCropTopOffset + frameCropBottomOffset) * cropUnitY;
-    }
-
-    float pixelWidthHeightRatio = 1;
-    boolean vuiParametersPresentFlag = bitArray.readBit();
-    if (vuiParametersPresentFlag) {
-      boolean aspectRatioInfoPresentFlag = bitArray.readBit();
-      if (aspectRatioInfoPresentFlag) {
-        int aspectRatioIdc = bitArray.readBits(8);
-        if (aspectRatioIdc == NalUnitUtil.EXTENDED_SAR) {
-          int sarWidth = bitArray.readBits(16);
-          int sarHeight = bitArray.readBits(16);
-          if (sarWidth != 0 && sarHeight != 0) {
-            pixelWidthHeightRatio = (float) sarWidth / sarHeight;
-          }
-        } else if (aspectRatioIdc < NalUnitUtil.ASPECT_RATIO_IDC_VALUES.length) {
-          pixelWidthHeightRatio = NalUnitUtil.ASPECT_RATIO_IDC_VALUES[aspectRatioIdc];
-        } else {
-          Log.w(TAG, "Unexpected aspect_ratio_idc value: " + aspectRatioIdc);
-        }
-      }
-    }
-
-    return new SpsData(frameWidth, frameHeight, pixelWidthHeightRatio);
-  }
-
-  private static void skipScalingList(ParsableBitArray bitArray, int size) {
-    int lastScale = 8;
-    int nextScale = 8;
-    for (int i = 0; i < size; i++) {
-      if (nextScale != 0) {
-        int deltaScale = bitArray.readSignedExpGolombCodedInt();
-        nextScale = (lastScale + deltaScale + 256) % 256;
-      }
-      lastScale = (nextScale == 0) ? lastScale : nextScale;
-    }
-  }
-
 }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java b/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
index 7b4caae880..00a9f27ade 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/NalUnitUtil.java
@@ -15,6 +15,8 @@
  */
 package com.google.android.exoplayer.util;
 
+import android.util.Log;
+
 import java.nio.ByteBuffer;
 import java.util.Arrays;
 
@@ -23,6 +25,59 @@
  */
 public final class NalUnitUtil {
 
+  private static final String TAG = "NalUnitUtil";
+
+  /**
+   * Holds data parsed from a sequence parameter set NAL unit.
+   */
+  public static final class SpsData {
+
+    public final int seqParameterSetId;
+    public final int width;
+    public final int height;
+    public final float pixelWidthAspectRatio;
+    public final boolean separateColorPlaneFlag;
+    public final boolean frameMbsOnlyFlag;
+    public final int frameNumLength;
+    public final int picOrderCountType;
+    public final int picOrderCntLsbLength;
+    public final boolean deltaPicOrderAlwaysZeroFlag;
+
+    public SpsData(int seqParameterSetId, int width, int height, float pixelWidthAspectRatio,
+        boolean separateColorPlaneFlag, boolean frameMbsOnlyFlag, int frameNumLength,
+        int picOrderCountType, int picOrderCntLsbLength, boolean deltaPicOrderAlwaysZeroFlag) {
+      this.seqParameterSetId = seqParameterSetId;
+      this.width = width;
+      this.height = height;
+      this.pixelWidthAspectRatio = pixelWidthAspectRatio;
+      this.separateColorPlaneFlag = separateColorPlaneFlag;
+      this.frameMbsOnlyFlag = frameMbsOnlyFlag;
+      this.frameNumLength = frameNumLength;
+      this.picOrderCountType = picOrderCountType;
+      this.picOrderCntLsbLength = picOrderCntLsbLength;
+      this.deltaPicOrderAlwaysZeroFlag = deltaPicOrderAlwaysZeroFlag;
+    }
+
+  }
+
+  /**
+   * Holds data parsed from a picture parameter set NAL unit.
+   */
+  public static final class PpsData {
+
+    public final int picParameterSetId;
+    public final int seqParameterSetId;
+    public final boolean bottomFieldPicOrderInFramePresentFlag;
+
+    public PpsData(int picParameterSetId, int seqParameterSetId,
+        boolean bottomFieldPicOrderInFramePresentFlag) {
+      this.picParameterSetId = picParameterSetId;
+      this.seqParameterSetId = seqParameterSetId;
+      this.bottomFieldPicOrderInFramePresentFlag = bottomFieldPicOrderInFramePresentFlag;
+    }
+
+  }
+
   /** Four initial bytes that must prefix NAL units for decoding. */
   public static final byte[] NAL_START_CODE = new byte[] {0, 0, 0, 1};
 
@@ -177,6 +232,134 @@ public static int getH265NalUnitType(byte[] data, int offset) {
     return (data[offset + 3] & 0x7E) >> 1;
   }
 
+  /**
+   * Parses an SPS NAL unit using the syntax defined in ITU-T Recommendation H.264 (2013) subsection
+   * 7.3.2.1.1.
+   *
+   * @param data A {@link ParsableBitArray} containing the SPS data. The position must to set to the
+   *     start of the data (i.e. the first bit of the profile_idc field).
+   * @return A parsed representation of the SPS data.
+   */
+  public static SpsData parseSpsNalUnit(ParsableBitArray data) {
+    int profileIdc = data.readBits(8);
+    data.skipBits(16); // constraint bits (6), reserved (2) and level_idc (8)
+    int seqParameterSetId = data.readUnsignedExpGolombCodedInt();
+
+    int chromaFormatIdc = 1; // Default is 4:2:0
+    boolean separateColorPlaneFlag = false;
+    if (profileIdc == 100 || profileIdc == 110 || profileIdc == 122 || profileIdc == 244
+        || profileIdc == 44 || profileIdc == 83 || profileIdc == 86 || profileIdc == 118
+        || profileIdc == 128 || profileIdc == 138) {
+      chromaFormatIdc = data.readUnsignedExpGolombCodedInt();
+      if (chromaFormatIdc == 3) {
+        separateColorPlaneFlag = data.readBit();
+      }
+      data.readUnsignedExpGolombCodedInt(); // bit_depth_luma_minus8
+      data.readUnsignedExpGolombCodedInt(); // bit_depth_chroma_minus8
+      data.skipBits(1); // qpprime_y_zero_transform_bypass_flag
+      boolean seqScalingMatrixPresentFlag = data.readBit();
+      if (seqScalingMatrixPresentFlag) {
+        int limit = (chromaFormatIdc != 3) ? 8 : 12;
+        for (int i = 0; i < limit; i++) {
+          boolean seqScalingListPresentFlag = data.readBit();
+          if (seqScalingListPresentFlag) {
+            skipScalingList(data, i < 6 ? 16 : 64);
+          }
+        }
+      }
+    }
+
+    int frameNumLength = data.readUnsignedExpGolombCodedInt() + 4; // log2_max_frame_num_minus4 + 4
+    int picOrderCntType = data.readUnsignedExpGolombCodedInt();
+    int picOrderCntLsbLength = 0;
+    boolean deltaPicOrderAlwaysZeroFlag = false;
+    if (picOrderCntType == 0) {
+      // log2_max_pic_order_cnt_lsb_minus4 + 4
+      picOrderCntLsbLength = data.readUnsignedExpGolombCodedInt() + 4;
+    } else if (picOrderCntType == 1) {
+      deltaPicOrderAlwaysZeroFlag = data.readBit(); // delta_pic_order_always_zero_flag
+      data.readSignedExpGolombCodedInt(); // offset_for_non_ref_pic
+      data.readSignedExpGolombCodedInt(); // offset_for_top_to_bottom_field
+      long numRefFramesInPicOrderCntCycle = data.readUnsignedExpGolombCodedInt();
+      for (int i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
+        data.readUnsignedExpGolombCodedInt(); // offset_for_ref_frame[i]
+      }
+    }
+    data.readUnsignedExpGolombCodedInt(); // max_num_ref_frames
+    data.skipBits(1); // gaps_in_frame_num_value_allowed_flag
+
+    int picWidthInMbs = data.readUnsignedExpGolombCodedInt() + 1;
+    int picHeightInMapUnits = data.readUnsignedExpGolombCodedInt() + 1;
+    boolean frameMbsOnlyFlag = data.readBit();
+    int frameHeightInMbs = (2 - (frameMbsOnlyFlag ? 1 : 0)) * picHeightInMapUnits;
+    if (!frameMbsOnlyFlag) {
+      data.skipBits(1); // mb_adaptive_frame_field_flag
+    }
+
+    data.skipBits(1); // direct_8x8_inference_flag
+    int frameWidth = picWidthInMbs * 16;
+    int frameHeight = frameHeightInMbs * 16;
+    boolean frameCroppingFlag = data.readBit();
+    if (frameCroppingFlag) {
+      int frameCropLeftOffset = data.readUnsignedExpGolombCodedInt();
+      int frameCropRightOffset = data.readUnsignedExpGolombCodedInt();
+      int frameCropTopOffset = data.readUnsignedExpGolombCodedInt();
+      int frameCropBottomOffset = data.readUnsignedExpGolombCodedInt();
+      int cropUnitX, cropUnitY;
+      if (chromaFormatIdc == 0) {
+        cropUnitX = 1;
+        cropUnitY = 2 - (frameMbsOnlyFlag ? 1 : 0);
+      } else {
+        int subWidthC = (chromaFormatIdc == 3) ? 1 : 2;
+        int subHeightC = (chromaFormatIdc == 1) ? 2 : 1;
+        cropUnitX = subWidthC;
+        cropUnitY = subHeightC * (2 - (frameMbsOnlyFlag ? 1 : 0));
+      }
+      frameWidth -= (frameCropLeftOffset + frameCropRightOffset) * cropUnitX;
+      frameHeight -= (frameCropTopOffset + frameCropBottomOffset) * cropUnitY;
+    }
+
+    float pixelWidthHeightRatio = 1;
+    boolean vuiParametersPresentFlag = data.readBit();
+    if (vuiParametersPresentFlag) {
+      boolean aspectRatioInfoPresentFlag = data.readBit();
+      if (aspectRatioInfoPresentFlag) {
+        int aspectRatioIdc = data.readBits(8);
+        if (aspectRatioIdc == NalUnitUtil.EXTENDED_SAR) {
+          int sarWidth = data.readBits(16);
+          int sarHeight = data.readBits(16);
+          if (sarWidth != 0 && sarHeight != 0) {
+            pixelWidthHeightRatio = (float) sarWidth / sarHeight;
+          }
+        } else if (aspectRatioIdc < NalUnitUtil.ASPECT_RATIO_IDC_VALUES.length) {
+          pixelWidthHeightRatio = NalUnitUtil.ASPECT_RATIO_IDC_VALUES[aspectRatioIdc];
+        } else {
+          Log.w(TAG, "Unexpected aspect_ratio_idc value: " + aspectRatioIdc);
+        }
+      }
+    }
+
+    return new SpsData(seqParameterSetId, frameWidth, frameHeight, pixelWidthHeightRatio,
+        separateColorPlaneFlag, frameMbsOnlyFlag, frameNumLength, picOrderCntType,
+        picOrderCntLsbLength, deltaPicOrderAlwaysZeroFlag);
+  }
+
+  /**
+   * Parses a PPS NAL unit using the syntax defined in ITU-T Recommendation H.264 (2013) subsection
+   * 7.3.2.2.
+   *
+   * @param data A {@link ParsableBitArray} containing the PPS data. The position must to set to the
+   *     start of the data (i.e. the first bit of the pic_parameter_set_id field).
+   * @return A parsed representation of the PPS data.
+   */
+  public static PpsData parsePpsNalUnit(ParsableBitArray data) {
+    int picParameterSetId = data.readUnsignedExpGolombCodedInt();
+    int seqParameterSetId = data.readUnsignedExpGolombCodedInt();
+    data.skipBits(1); // entropy_coding_mode_flag
+    boolean bottomFieldPicOrderInFramePresentFlag = data.readBit();
+    return new PpsData(picParameterSetId, seqParameterSetId, bottomFieldPicOrderInFramePresentFlag);
+  }
+
   /**
    * Finds the first NAL unit in {@code data}.
    * <p>
@@ -276,6 +459,18 @@ private static int findNextUnescapeIndex(byte[] bytes, int offset, int limit) {
     return limit;
   }
 
+  private static void skipScalingList(ParsableBitArray bitArray, int size) {
+    int lastScale = 8;
+    int nextScale = 8;
+    for (int i = 0; i < size; i++) {
+      if (nextScale != 0) {
+        int deltaScale = bitArray.readSignedExpGolombCodedInt();
+        nextScale = (lastScale + deltaScale + 256) % 256;
+      }
+      lastScale = (nextScale == 0) ? lastScale : nextScale;
+    }
+  }
+
   private NalUnitUtil() {
     // Prevent instantiation.
   }
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
index ff47655598..443bfee406 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableBitArray.java
@@ -178,12 +178,12 @@ public int readBits(int numBits) {
   }
 
   /**
-   * Peeks the length of an Exp-Golomb-coded integer (signed or unsigned) starting from the current
-   * offset, returning the length or -1 if the limit is reached.
+   * Returns whether it is possible to read an Exp-Golomb-coded integer starting from the current
+   * offset. The offset is not modified.
    *
-   * @return The length of the Exp-Golob-coded integer, or -1.
+   * @return Whether it is possible to read an Exp-Golomb-coded integer.
    */
-  public int peekExpGolombCodedNumLength() {
+  public boolean canReadExpGolombCodedNum() {
     int initialByteOffset = byteOffset;
     int initialBitOffset = bitOffset;
     int leadingZeros = 0;
@@ -193,7 +193,7 @@ public int peekExpGolombCodedNumLength() {
     boolean hitLimit = byteOffset == byteLimit;
     byteOffset = initialByteOffset;
     bitOffset = initialBitOffset;
-    return hitLimit ? -1 : leadingZeros * 2 + 1;
+    return !hitLimit && bitsLeft() >= leadingZeros * 2 + 1;
   }
 
   /**
diff --git a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
index 8beff5f9cb..f54de76066 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java
@@ -194,6 +194,13 @@ public int readUnsignedInt24() {
         | (data[position++] & 0xFF);
   }
 
+  /** Reads the next three bytes as a signed value in little endian order. */
+  public int readLittleEndianInt24() {
+    return (data[position++] & 0xFF)
+        | (data[position++] & 0xFF) << 8
+        | (data[position++] & 0xFF) << 16;
+  }
+
   /**  Reads the next three bytes as an unsigned value in little endian order. */
   public int readLittleEndianUnsignedInt24() {
     return (data[position++] & 0xFF)
@@ -294,6 +301,20 @@ public int readUnsignedIntToInt() {
     return result;
   }
 
+  /**
+   * Reads the next four bytes as a little endian unsigned integer into an integer, if the top bit
+   * is a zero.
+   *
+   * @throws IllegalStateException Thrown if the top bit of the input data is set.
+   */
+  public int readLittleEndianUnsignedIntToInt() {
+    int result = readLittleEndianInt();
+    if (result < 0) {
+      throw new IllegalStateException("Top bit not zero: " + result);
+    }
+    return result;
+  }
+
   /**
    * Reads the next eight bytes as an unsigned long into a long, if the top bit is a zero.
    *
diff --git a/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
index c6fe12eb24..b8455611aa 100644
--- a/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
+++ b/library/src/main/java/com/google/android/exoplayer/util/extensions/SimpleDecoder.java
@@ -15,6 +15,7 @@
  */
 package com.google.android.exoplayer.util.extensions;
 
+import com.google.android.exoplayer.C;
 import com.google.android.exoplayer.util.Assertions;
 
 import java.util.LinkedList;
@@ -219,16 +220,23 @@ private boolean decode() throws InterruptedException {
       flushDecodedOutputBuffer = false;
     }
 
-    exception = decode(inputBuffer, outputBuffer);
-    if (exception != null) {
-      // Memory barrier to ensure that the decoder exception is visible from the playback thread.
-      synchronized (lock) {}
-      return false;
+    outputBuffer.reset();
+    if (inputBuffer.getFlag(Buffer.FLAG_END_OF_STREAM)) {
+      outputBuffer.setFlag(Buffer.FLAG_END_OF_STREAM);
+    } else {
+      if (inputBuffer.getFlag(C.SAMPLE_FLAG_DECODE_ONLY)) {
+        outputBuffer.setFlag(C.SAMPLE_FLAG_DECODE_ONLY);
+      }
+      exception = decode(inputBuffer, outputBuffer);
+      if (exception != null) {
+        // Memory barrier to ensure that the decoder exception is visible from the playback thread.
+        synchronized (lock) {}
+        return false;
+      }
     }
 
-    boolean decodeOnly = outputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY);
     synchronized (lock) {
-      if (flushDecodedOutputBuffer || decodeOnly) {
+      if (flushDecodedOutputBuffer || outputBuffer.getFlag(Buffer.FLAG_DECODE_ONLY)) {
         // If a flush occurred while decoding or the buffer was only for decoding (not presentation)
         // then make the output buffer available again rather than queueing it to be consumed.
         availableOutputBuffers[availableOutputBufferCount++] = outputBuffer;
@@ -261,10 +269,11 @@ private boolean canDecodeBuffer() {
    * Decodes the {@code inputBuffer} and stores any decoded output in {@code outputBuffer}.
    *
    * @param inputBuffer The buffer to decode.
-   * @param outputBuffer The output buffer to store decoded data. If the flag
-   *     {@link Buffer#FLAG_DECODE_ONLY} is set after this method returns, any output should not be
-   *     presented.
-   * @return A decode exception if an error occurred, or null if the decode was successful.
+   * @param outputBuffer The output buffer to store decoded data. The flag
+   *     {@link Buffer#FLAG_DECODE_ONLY} will be set if the same flag is set on {@code inputBuffer},
+   *     but the decoder may set/unset the flag if required. If the flag is set after this method
+   *     returns, any output should not be presented.
+   * @return A decoder exception if an error occurred, or null if decoding was successful.
    */
   protected abstract E decode(I inputBuffer, O outputBuffer);
 
